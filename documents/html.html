<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>HTML</title>
<link rel="stylesheet" href="vendors/public.css">
<link rel="stylesheet" href="vendors/SyntaxHighlighter/shCoreDefault.css"/>
</head>
<body>
<h1><a name="top">HTML <small>W3C</small></a></h1>

<main>
<nav>
  <ul>
      <li class="home">
        <a href="#" onclick="location = location.hostname == 'localhost' ? '../' : './';return false;">STUDY</a>
      </li>
    <li class="it"><a href="javascript:;">html</a></li>
  </ul>
</nav>

<h2>基础知识</h2><pre>
现代浏览器的内核主流内容主要有
Mozilla(Gecko)  Firefox,Flock等浏览器
WebKit          Safari、Chrome等浏览器
Opera(presto)   Opera浏览器
Trident         IE浏览器

www: world wide web

分辨率：
每英寸包含点的数量(dots per inch)
普通屏幕通常包含96dpi,一般将2倍于此即大于等于192dpi的屏幕称之为高分屏,如Mac视网膜屏就达到了192dpi(即2dppx),打印时一般会需要更大的dpi;
1dppx = 96dpi
1dpi ≈ 0.39dpcm
1dpcm ≈ 2.54dpi
1in = 2.54cm = 25.4 mm = 101.6q = 72pt = 6pc = 96px

颜色设定：
1.#000000 #ffffff(6位16进制)
2.rgb(0,255,255)
3.rgba(0,255,0,1)
4.单词white

小动画格式：GIF  *.gif;
颜色丰富：JPEG  *.jpg
推荐：*.png

HTML超文本标记语言(Hyper Text Markup Language)不是编程语言,使用markup tag来描述网页。
开始strat tag和结束标签end tag也被称为开放标签和闭合标签

!DOCTYPE html该标签表明文档使用HTML5版本

@media screen and (min-resolution: 96dpi) { ... }  /*兼容性差*/
@media print and (min-resolution: 300dpi) { ... }

【 href和src的区别 】
1、请求资源类型不同
href指向网络资源所在位置,建立和当前元素(锚点)或当前文档(链接)之间的联系
在请求src资源时会将其指向的资源下载并应用到文档中,如JS脚本、img图片

2、作用结果不同
href用于在当前文档和引用资源之间确立联系;
src用于替换当前内容;

3、浏览器解析方式不同
若在文档中添加浏览器会识别该文档为CSS文件,会并行下载资源并且不会停止对当前文档的处理。这也是为什么建议使用link方式加载CSS,而不是使用@import方式。
当浏览器解析到,会暂停其他资源的下载和处理直到将该资源加载、编译、执行完毕,图片和框架等也如此,类似于将所指向资源应用到当前内容。这也是为什么建议把js脚本放在底部而不是头部的原因。

</pre><textarea>
<!--html注释-->
<!--[if IE 8]> 条件注释,只有在IE中执行的HTML标签<![endif]-->
/*css注释*/
//js单行注释
/*js多行注释*/
//PHP单行注释
#PHP单行注释
/*php多行注释*/

</textarea>
</div>

<div id="tags">
<h2>标签集</h2><textarea>
＜base href="https//www.baidu.com" target="_blank"＞ 为页面上所有的链接包括link标签规定默认地址或目标

<hr> 横线
<hr size=9 width=80% color=00ff00 />

& nbsp; 占位符,空格   & lt <    & gt >    & amp &     & quot  "      & apos  '  & copy; ©版权符

格式换文本标签系列
<h1>heading</h1>   标题
<p style="font-family:verdana;font-size:28px;color:white;text-align:center"> paragraph</p>

<big>text</big>    呈现大号字体效果
<small></small>    呈现小号字体
<b></b>
<strong></strong>  把文本定义为语气更强的内容
<i></i>			       文本斜体
<em></em>          把文本定义为强调的内容
<sub></sub>		     下标文本
<sup></sup>		     上标文本

<br/>              空元素,强制换行标签
<xmp>              标签之间的内容不会被当作文档内容解析,HTML5规范内xmp元素已经完全被移除
<pre></pre>	       预格式文本,保留空格和空行,适合编写计算机代码,需将内容中的"<"转义为"&lt;",以防止被浏览器当作正常标签解析
<code></code>      代码,需要将内容中的"<"转义为"&lt ;",以防止被浏览器当作正常标签解析
<kbd></kbd><tt></tt><samp></samp><var></var>常用于显示计算机编程代码
<address></address>                                  写地址
<bdo dir="rtl">Here is some Hebrew text</bdo>        文字方向从右到左
<abbr title="People's Republic of China">PRC</abbr>  标记一个缩写,鼠标放上课显示全名
<acronym title="World Wide Web">WWW</acronym>	       标记首字母缩写

<font color="red" size="16px"></font>  设置字体
<center></center>                      文本水平居中

<img /><map></map> <area></area>       带有可点击区域的图像映射

<object></object>		        添加多媒体
<embed src="#" />           定义嵌入的内容,如插件多媒体

<header>顶部</header>       定义文档的页眉
<nav>导航栏</nav>           导航链接
<main></main>	              定义文档的主体
<article>内容</article>     规定独立的自包含内容
<section></section>         定义文档的节,部分
<aside>辅助栏</aside>       定义其所处内容之外的内容,应与附近的内容相关.块级元素,侧边栏
<footer>底部</footer>       定义文档或节的页脚

版权书写：
<span style="font-family:Arial;">Copyright©2016All Rright Reserved</span>
<span style="font-family:Arial;">©2016All Rright Reserved</span>
<span style="font-family:Arial;">&copy2016All Rright Reserved</span>

</textarea>html5新标签<textarea>
给汉字加拼音: 支持ruby元素的浏览器不会显示rp元素的内容<br/>
<ruby>
  做工程师不做码农
  <rt>zuo gong cheng shi bu zuo ma nong</rt>
</ruby>
<br/>
<ruby>
  漢 <rt><rp>(</rp>ㄏㄢˋ<rp>)</rp></rt>
</ruby>
<ruby>
  汉 <rp>(</rp><rt>han</rt><rp>)</rp>
  字 <rp>(</rp><rt>zi</rt><rp>)</rp>
</ruby>
<br/>
<ruby>
  明 日 <rp>(</rp><rt>ming ri</rt><rp>)</rp>
</ruby>

展开收起组件,效果和jQuery手风琴插件差不多,设置open属性让它默认为展开状态
<details>
  <summary>头条号《做工程师不做码农》</summary>
  欢迎大家关注我的头条号，专注大前端、全栈、程序员成长的公众号！如果对你有所启发和帮助，可以点个关注、收藏，也可以留言讨论，这是对作者的最大鼓励。
  作者简介：Web前端工程师，全栈开发工程师、持续学习者。
</details>
<details>
  <summary>Google Nexus 6</summary>
  <p>商品详情：</p>
  <dl>
    <dt>屏幕</dt>
    <dd>5.96” 2560x1440 QHD AMOLED display (493 ppi)</dd>
    <dt>电池</dt>
    <dd>3220 mAh</dd>
    <dt>相机</dt>
    <dd>13MP rear-facing with optical image stabilization 2MP front-facing</dd>
    <dt>处理器</dt>
    <dd>Qualcomm® Snapdragon™ 805 processor</dd>
  </dl>
</details>

</textarea>
</div>

<div id="marquee">
<h3>文字的滚动</h3><pre>
HTML跑马灯字幕标签marquee滚动效果,文字图片表格动画

字幕滚动效果属性:
1.滚动方向direction(包括4个值：up、 down、 left和 right)　　
2.滚动方式behavior(scroll:循环滚动,默认效果; slide:只滚动一次就停止; alternate:来回交替进行滚动)　　
3.滚动速度scrollamount(滚动速度是设置每次滚动时移动的长度,以像素pixels为单位)　　
4.滚动延迟scrolldelay(设置滚动的时间间隔,单位是毫秒millisecond)　　
5.滚动循环次数loop(默认值是-1,滚动会不断的循环下去)　　
6.滚动范围width、height,窗体宽度高度
7.滚动背景颜色bgcolor
8.空白空间hspace(相对于左外边距)、vspace(相对于上外边距)
9.Title 文字描述
10.align设定marquee标签内容的对齐方式

</pre>

<marquee behavior="scroll">滚动 behavior="scroll"</marquee>
<marquee behavior="slide">一次滑动 behavior="slide"</marquee>
<marquee behavior="alternate">交替 behavior="alternate"</marquee>
<marquee direction="down">交替 direction="left"</marquee>
<marquee id="m1" behavior="scroll" direction="up" height="80" width="445" bgcolor="#f60" loop="-1" hspace="0" vspace="10" scrollamount="2" scrolldelay="10" onMouseOut="this.start()" onMouseOver="this.stop()" style="padding-left: 38px;">
  <font size=+1 color=white>
    <ul>
      <li>恭喜135****5871用户获得300现金大礼包</li>
      <li>恭喜135****5872用户获得300现金大礼包</li>
      <li>恭喜135****5871用户获得300现金大礼包</li>
      <li>恭喜135****5872用户获得300现金大礼包</li>
      <li>恭喜135****5871用户获得300现金大礼包</li>
      <li>恭喜135****5872用户获得300现金大礼包</li>
    </ul>
  </font>
</marquee>

<pre class="html">
<marquee behavior="scroll">滚动 behavior="scroll"</marquee>
<marquee behavior="slide">一次滑动 behavior="slide"</marquee>
<marquee behavior="alternate">交替 behavior="alternate"</marquee>
<marquee direction="down">交替 direction="left"</marquee>

<marquee id="m1" behavior="scroll" direction="up" height="80rem" width="445rem;" bgcolor="#f60" loop="-1" hspace="0" vspace="10" scrollamount="4" scrolldelay="100" onMouseOut="this.start()" onMouseOver="this.stop()" style="padding-left: 38px;">
  <font size=+1 color=white>
    marquee:恭喜135****5871用户获得300现金大礼包
  </font>
</marquee>

</pre>
</div>

<div id="a">
<h3>超链接</h3><pre>
超链接(hyper text),标准叫法称为锚(anchor),使用a标签标记
内部链接,外部链接,email链接,锚点链接,空连接,脚本链接,下载链接

超链接属性：
href属性
target属性的值：_blank  _self  _parent
title属性
rel="nofollow"

a标签的href属性用于指定超链接目标的URL,可以是任何有效文档的相对或绝对URL,包括片段标识符和js代码段。
空链接应用：以后完善的链接,#  ###  ####

链接有两种使用a标签的方式：
1、通过使用href属性 - 创建指向另一个文档的链接
2、通过使用name属性 - 创建文档内的书签,name属性规定锚(anchor)的名称,即创建书签,多用于导航
可以使用id属性来替代name属性,命名锚同样有效。

【 锚点链接 】
1.创建锚点：
＜div id="tips"＞元素div的内容＜/div＞
＜a name="tips"＞基本的注意事项 - 有用的提示:可以不填内容＜/a＞

2.链接锚点：
＜a href="#tips"＞有用的提示＜/a＞   // 同一页面
＜a href="http://www.w3school.com.cn/html/html_links.asp#tips"＞有用的提示＜/a＞  // 外部页面

【 定义浏览器点击行为 】
＜a href="mailto:url"＞email链接＜/a＞

＜a href="sms:10086">发短信给: 10086＜/a＞

＜a href="tel:123456789">拨号＜/a＞
window.location.href = "tel:10086";
一般都会加上＜meta name="format-detection" content="telephone=no">,所以手机号码不会被识别为拨号链接

【 download属性 】
html5新属性,FF和chrome支持,IE、Safari、opera不支持
可设置一个任意值来规定下载文件的名称,浏览器将自动检测正确的文件扩展名并添加到文件 (.img, .pdf, .txt, .html等等)
＜a href="/images/logo.png" download="filename"＞下载＜/a＞

点击"下载"链接下载图片或文件而不是预览,直接添加一个download属性就可以
＜a href="large.jpg" download＞下载＜/a＞

下载链接：链接到浏览器不能直接打开的文件类型即可,如.rar
＜a href="文件名"＞下载＜/a＞

【 脚本链接 】
当单击设置脚本链接的文字或图像时可以运行相应的js语句
href="javascript:;",其中javascript:是伪协议,可通过一个链接来调用jS函数,实现a标签的点击事件运行

＜a href=" " onClick="function();"＞链接＜/a＞
＜a href="javascript:function();"＞链接＜/a＞
＜a href="javascript:window.open('https://www.baidu.com')"＞打开百度＜/a＞
＜a href="javascript:window.close()"＞＜b＞【关闭窗口】＜/b＞＜/a＞
＜a href="javascript:window.opener=null;window.close();"＞关闭＜/a＞
＜a href="javascript:window.opener=null;window.open('','_self');window.close();"＞关闭＜/a＞
＜a href="javascript:history.go(-1);"＞后退按钮＜/a＞
＜a href="javascript:history.back();"＞后退按钮＜/a＞

</div>

<div id="img">
<h4>图像img</h4><pre>
src源属性source
alt属性替换文本,描述图像文字
align对齐图片与文字对齐方式：垂直对齐默认bottom底部,top顶部,middle中部,;水平对齐默认left浮动到左,right浮动到右
width属性宽度,height属性高度
border属性边框

图片加载慢时用logo图片代替,onerror当图片不存或加载不出来才生效
＜img src="http://www.example.com/2323.jpg" onerror="this.src='img/loading.png'" />

</pre>

<h4>表格table</h4><pre>
数据单元格可以包含文本、图片、列表、段落、表单、水平线、表格等等

属性：
border                  pixels,规定表格边框的宽度
bordercolor
width
height
char
character	              规定根据哪个字符来对齐列组中的内容。
charoff
number	                规定第一个对齐字符的偏移量。
span
number	                规定列组应该横跨的列数。
bordercolorlight="black" 和 bordercolordark="white"不同设置立体
colspan="2" rowspan="2" 合并单元格
cellspacing="2"         单元格间距,默认为2
cellpadding="2"         单元格边距,默认为2
align="center           表格水平对齐,定义在列组合中内容的水平对齐方式,right/left/center/justify/char
valign="middle"         垂直居中对齐,定义在列组合中内容的垂直对齐方式,还有top,bottom,baseline
bgcoloer="red"
frame="box"             四周边框;above上边框;below下边框;hsides上下边框;vsides左右边框
rules="none"            不显示边框线;rows只显示横线;colspan只显示竖线;All全部显示

colgroup标签用于对表格中的列进行组合,以便对其进行格式化,colgroup标签只能在table元素中使用
需对全部列应用样式时colgroup标签很有用,这样就不需要对各个单元和各行重复应用样式了。

col的作用是细化colgroup,因为即使在一个组中列与列之间也可能会出现一些差别,这时就得用到col了

</pre><pre class="html">
< table width="100%" border="1" cellpadding="10" cellspacing="1" background="./image/logo.png" bgcolor="#ccc">
  < caption>表格标题< /caption>
  < colgroup width="50" style="background-color:yellow">< /colgroup>
  < colgroup span="3" style="background-color:red">
    < col span="2" width="100px">
    < col width="300px" style="background-color:green">
  < /colgroup>
  < thead>
    < tr>
      < th>表头< /th>
      < th>表头< /th>
      < th colspan="2" align="center">跨列表头< /th>
    < /tr>
  < /thead>
  < tbody>
    < tr>
      < td>表单元< /td>
      < td>表单元< /td>
      < td>表单元< /td>
    < /tr>
  < /tbody>
  < tfoot>
    < tr>
      < td>表单元< /td>
      < td>表单元< /td>
      < td>表单元< /td>
    < /tr>
  < /tfoot>
< /table>

</pre>
</div>

<div id="list">
<h3>列表项内部可以使用段落、换行符、图片、链接以及其他列表等等</h3><pre class="html">
<ul type="disc">         //默认黑点,circle圆圈,square方块
  <li>项目1</li>
  <li>项目2</li>
</ul>

<ol type="1"  strat="1">  //默认从1开始,A;a;I;i
  <li>项目1</li>
  <li>项目2</li>
</ol>

<dl> 自定义列表
  <dt>描述1</dt>
  <dd>内容1</dd>
  <dt>描述2</dt>
  <dd>内容2</dd>
</dl>

</pre>
</div>

<div id="div">
<h3>HTML块级元素</h3><pre>
HTML元素被定义为块级元素(block level element)或内联元素(inline element)
块级元素在浏览器显示时通常会以新行来开始和结束。

div
定义文档中的节或区域(块级元素),div没有默认样式,不会有margin、background等初始化设置
可用于组合其他HTML元素如span的容器,浏览器会在其前后显示折行,
如果与CSS一同使用,div元素可用于对大的内容块设置样式属性。

div元素的另一个常见的用途是文档布局,因为能够轻松地通过CSS对其进行定位。
它取代了使用表格定义布局的老式方法,使用table元素进行文档布局不是表格的正确用法,table元素的作用是显示表格化的数据。

span
定义文档中的行内小块或区域,无默认样式
span元素是内联元素,可用作文本的容器,当与CSS一同使用时span元素可用于为部分文本设置样式属性。

RWD指的是响应式Web设计(Responsive Web Design)
RWD能够以可变尺寸传递网页,对于平板和移动设备是必需的

</pre>
</div>

<div id="head">
<h2>HTML头部元素 head头标签</h2><pre>
head元素是所有头部元素的容器,包含关于所在网页的信息,主要是被浏览器所用,不会显示在网页的正文内容里。
head内的元素可包含脚本,指示浏览器在何处可以找到样式表,提供元信息等等
以下标签都可以添加到head部分：title、base、link、meta、script及style

标题(title)是最常用的head信息,显示在浏览器窗口的标题栏里

链接(link)建立和外部文件的链接,常用的是对CSS外部样式表(external style sheet)的链接
使用层叠样式表(CSS)来定义HTML元素的布局和显示属性
当浏览器读到一个样式表CSS就会按照这个样式表来对文档进行格式化
可以引用外部样式表link,也可以内部定义样式表style

JS使HTML页面具有更强的动态和交互性,最常用于图片操作、表单验证以及内容动态更新
script标签用于定义客户端脚本如JavaScript,VBScript,必需的type属性规定脚本的MIME类型
script元素既可包含脚本语句,也可通过src属性指向外部脚本文件

如果浏览器压根没法识别script标签,那么script标签所包含的内容将以文本方式显示在页面上
为了避免这种情况发生,应该将脚本隐藏在注释标签当中。
无法识别script标签的老浏览器将忽略这些注释,所以不会将标签的内容显示到页面上,而新的浏览器将读懂这些脚本并执行它们,即使代码被嵌套在注释标签内

【 Meta标签始终存在于head中 】
网页信息meta标记(meta tags)表示用来描述网页的有关信息。
元数据meta元素用来描述文档,关键词、文档的作者、最后修改时间以及其他元数据

meta标签是HTML中head头部的一个辅助性标签,它位于HTML文档头部的head和title标签之间,提供用户不可见的信息。虽然这部分信息用户不可见,但是其作用非常强大,设置合适的meta标签可以大大提升网站页面的可用性

桌面端开发中meta标签通常用来为搜索引擎优化SEO(关键词)及robots定义页面主题,或者是定义用户浏览器上的cookie;可以用于鉴别作者,设定页面格式,如何显示内容或重新加载页面,标注内容提要和关键字,还可以设置页面使其可以根据定义的时间间隔刷新自己以及设置RASC内容等级等等

移动端开发中meta标签除了桌面端中的功能设置外,还包括比如viewport设置,添加到主屏幕图标,标签页颜色等等实用设置

meta标签共有两个属性http-equiv属性和name属性,不同的属性有不同的参数值,实现了不同的网页功能。
1. name属性主要用于描述网页,与之对应的属性值为content,content中的内容主要是便于搜索引擎机器人查找信息和分类信息用的
＜meta name="参数" content="具体的参数值"＞

name属性主要有以下几种参数：
Keywords(关键字)
description(网站内容描述)
robots(机器人向导)告诉搜索机器人哪些页面要索引哪些不要,content参数有all(默认),none,index,noindex,follow,nofollow
author(作者) 标注网页的作者

2. http-equiv属性相当于http的文件头作用,可以向浏览器传回一些有用的信息,以帮助正确和精确地显示网页内容,与之对应的属性值为content,content中的内容是各个参数的变量值
＜meta http-equiv="参数" content="参数变量值"＞

http-equiv属性主要有以下几种参数：
Expires(期限) 可以用于设定网页的到期时间。一旦网页过期,不能再从本地缓冲例读取,必须到服务器上重新传输
Pragma(cache模式) 禁止浏览器从本地计算机的缓存中访问页面内容,使访问者将无法脱机浏览
Refresh(刷新) 自动刷新并跳转指向新页面,自动在指定的时间内去访问指定的网页
Set-Cookie(cookie设定) 如果网页过期,那么存盘的cookie将被删除。
Window-target(显示窗口的设定) 强制页面在当前窗口以独立页面显示,用来防止别人在框架里调用自己的页面。
content-Type(显示字符集的设定) 设定页面使用的字符集。

【 viewport 】
为移动设备添加viewport,可以让布局在移动浏览器上显示的更好
＜meta name ="viewport" content ="initial-scale=1, maximum-scale=3, minimum-scale=1, user-scalable=no"＞

content参数：
width           宽度(数值/device-width),width=device-width设置视窗宽度为设备视窗宽度,固定宽度如width=640单位px,常见于微信
height          高度(数值/device-height)
initial-scale   初始缩放比例
maximum-scale   最大缩放比例
minimum-scale   最小缩放比例
user-scalable   是否允许用户缩放(yes/no)

width=device-width会导致iPhone5添加到主屏后以WebApp全屏模式打开页面时出现黑边
有user-scalable=no就不用使用minimum-scale=1.0和maximum-scale=1.0来强制禁止缩放了
＜meta name="viewport" content="width=device-width,initial-scale=1.0,user-scalable=no"＞

如果网站不是响应式的就不要使用initial-scale或者禁用缩放
＜meta name="viewport" content="width=device-width,user-scalable=yes"＞

适配iPhone 6和iPhone 6plus则需要写：
＜meta name="viewport" content="width=375"＞
＜meta name="viewport" content="width=414"＞
大部分4.7~5寸的安卓设备的viewport宽设为360px,iPhone6上却是375px,大部分5.5寸安卓机器viewport宽为400,iPhone6 plus上是414px

</pre><pre class="html">
设置文档的字符编码
＜meta charset="utf-8"＞
＜meta http-equiv="Content-Type" content="text/html;charset=gbk" /＞

为了让IE浏览器运行最新的渲染模式下
＜meta http-equiv="X-UA-Compatible" content="IE=edge"＞
＜meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"＞
以上3个meta标签必须放在head的最前面其他任何的head内容必须在这些标签的后面

禁用自动检测和格式化可能的电话号码
默认情况下,设备会自动识别任何可能是电话号码的字符串,设置telephone=no禁止浏览器自动识别手机号码,email=no是禁止浏览器自动识别Email
＜meta name="format-detection" content="telephone=no"＞
＜meta name="format-detection" content="email=no"＞

</pre>

【 SEO优化部分 】
<textarea rows="30" cols="150">
页面标题title标签
<title>website title</title>

页面关键词 keywords
<meta name="keywords" content="关键字,在这里不使用空格,而用逗号进行分隔">
<meta name="keywords" content="science, education, entertaiment, human" />

针对页面的简短描述(限制150字符),在*某些*情况下,该描述是被用作搜索结果展示片段的一部分
<meta name="description" content="This page is about science, culture." />

定义网页作者author,最好使用<link rel="author">或humans.txt文件
<meta name="author" content="author,email address">
<meta name="author" content="root,root@21cn.com" />
<meta name="author" content="name, email@example.com">

定义网页搜索引擎索引方式,robotterms是一组使用英文逗号分割的值,通常有如下几种取值：none,noindex,nofollow,all,index和follow。
<meta name="robots" content="index,follow">
<meta name="robots" content="none" />
控制搜索引擎的抓取和索引行为
<meta name="robots" content="index,follow,noodp">所有的搜索引擎

<meta name="googlebot" content="index,follow">仅对 Google 有效
告诉 Google 不显示网站链接的搜索框
<meta name="google" content="nositelinkssearchbox">
告诉 Google 不提供此页面的翻译
<meta name="google" content="notranslate">
验证 Google 搜索控制台的所有权
<meta name="google-site-verification" content="verification_token">

</textarea>

【 缓存控制 】
某些WAP浏览器不支持用meta标签来控制缓存,最好在服务器端配置缓存控制,在服务器端的HTTP响应中设置HTTP头
<textarea rows="20" cols="150">
<meta http-equiv="Cache-Control" content="no-cache">
<meta http-equiv="Cache-Control" content="max-age=0"/>  等效
<meta http-equiv="Cache-Control" content="max-age=300"/>

<meta http-equiv="Expires" content="0">
<meta http-equiv="expires" content="Fri, 12 Jan 2001 18:18:18 GMT"/>
网页到期时间,必须使用GMT的时间格式
<meta http-equiv="Pragma" content="no-cache" />
禁止脱机浏览

<meta http-equiv="refresh" content="3" />                           页面每隔3秒钟刷新一次
<meta http-equiv="Refresh" content="2; URL=http://www.root.net" />  留2秒钟后自动刷新到URL网址
在一段时间后将用户重定向到新URL,W3C建议不使用该标签,Google建议使用服务器端的301重定向
<meta http-equiv="refresh" content="300; url=https://example.com/">

在客户端存储 cookie,web 浏览器的客户端识别,必须使用GMT的时间格式
<meta http-equiv="set-cookie" content="name=value; expires=date; path=url">
<meta http-equiv="Set-Cookie" content="cookievalue=xxx; expires=Friday, 12-Jan-2001 18:18:18 GMT; path=/">
</textarea>

<textarea rows="65" cols="150">
<base target="_blank" /> 页面中的所有链接在新窗口中打开
<base href="http://www.w3school.com.cn/images/" />

<meta name="language" content="en">
用于声明文档语言,但支持得不是很好,最好使用<html lang="zh-CN | EN">

百度禁止转码,百度手机打开网页时百度可能会对你的网页进行转码,贴狗皮膏药的广告,为此可在head内添加
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta http-equiv="Window-Target" content="_value">
指定要显示在一个特定框架中的页面
<meta http-equiv="Window-target" content="_top" />
必须在独立页面打开,防止页面被调用

<meta http-equiv="Page-Enter" content="revealTrans(duration=5.0, transition=20)" />
进入网页动画效果
<meta http-equiv="Page-Exit" content="revealTrans(duration=5.0, transition=20)"/>
离开网页动画效果

<meta http-equiv=″PICS－Label″  content=′(PICS－1.1 ″http://www.rsac.org/ratingsv01.html″  l gen true comment ″RSACi North America Server″  for ″http://www.rsac.org″  on ″2001.08.16T08:15－0500″  r (n 0 s 0 v 0 l 0))′ />
网页定级评价.浏览器可以防止浏览一些受限制的网站,而之所以浏览器会自动识别某些网站是否受限制,就是因为在网站meta标签中已经设置好了该网站的级别,而该级别的评定是由美国RSAC,如果你需要评价自己的网站,可以连接到网站http://www.rsac.org/,通过之后将提供的代码复制到自己网页里就可以了

地理标签
<meta name="ICBM" content="latitude, longitude">
<meta name="geo.position" content="latitude;longitude">
国家代码 (ISO 3166-1): 强制性, 州代码 (ISO 3166-2): 可选; 如 content="US" / content="US-NY"
<meta name="geo.region" content="country[-state]">
如 content="New York City"
<meta name="geo.placename" content="city/town">

允许控制资源的过度加载
<meta http-equiv="Content-Security-Policy" content="default-src 'self'">
尽早地放置在文档中
仅应用于该标签下的内容
Web 应用的名称(仅当网站被用作为一个应用时才使用)
<meta name="application-name" content="应用名称">

用来命名软件或用于构建网页(如 - WordPress、Dreamweaver)
<meta name="generator" content="program">
关于你的网站主题的简短描述
<meta name="subject" content="你的网站主题">
非常简短(少于 10 个字)的描述。主要用于学术论文。
<meta name="abstract" content="">
完整的域名或网址
<meta name="url" content="https://example.com/">
<meta name="directory" content="submission">
基于网站内容给出一般的年龄分级
<meta name="rating" content="General">
允许控制 referrer 信息如何传递
<meta name="referrer" content="never">

通过设置为"off"完全退出DNS预取
<meta http-equiv="x-dns-prefetch-control" content="off">
<meta name="topic" content="">                  描述网站的主题
<meta name="summary" content="">                公司概要或网站目的
<meta http-equiv="Pics-label" content="value">  控制在互联网上哪些用户可以访问

rss订阅
<link rel="alternate" type="application/rss+xml" title="RSS" href="/rss.xml" />

</textarea>

<pre>
【 link标签 】
引入外部CSS样式文件是link标签最常用的功能,此外比如浏览器favicon图标,touch图标等

</pre><textarea rows="85" cols="150">
表明一个CSS样式表
<link rel="stylesheet" href="https://example.com/styles.css">
<link rel="stylesheet" type="text/css" href="mystyle.css" />

有助于防止出现内容重复的问题
<link rel="canonical" href="https://example.com/2010/06/9-things-to-do-before-entering-social-media.html">

之前用于包含icon链接,但已被废弃并不再使用
<link rel="shortlink" href="https://example.com/?p=42">

链接到当前文档的一个AMP HTML版本
<link rel="amphtml" href="https://example.com/path/to/amp-version.html">

链接到一个指定Web应用程序"安装"证书的JSON文件
<link rel="manifest" href="manifest.json">

链接到文档的作者
<link rel="author" href="humans.txt">

指向一个适用于链接内容的版权申明
<link rel="copyright" href="copyright.html">

给出可能的另一种语言的文档位置参考
<link rel="alternate" href="https://es.example.com/" hreflang="es">

提供了关于作者或其他人的信息
<link rel="me" href="https://google.com/profiles/thenextweb" type="text/html">
<link rel="me" href="mailto:name@example.com">
<link rel="me" href="sms:+15035550125">

链接到一个文档,包含当前文档的一个归档链接
<link rel="archives" href="https://example.com/2003/05/" title="May 2003">

链接到层次结构中的顶级资源
<link rel="index" href="https://example.com/" title="DeWitt Clinton">

给出该文档的起点
<link rel="start" href="https://example.com/photos/pattern_recognition_1_about/" title="Pattern Recognition 1">

引导当前文档的前述资源序列
<link rel="prev" href="https://example.com/opensearch/opensearch-and-openid-a-sure-way-to-get-my-attention/" title="OpenSearch and OpenID? A sure way to get my attention.">

给出一个自我参考 - 当文档有多个可能的参考时非常有用
<link rel="self" type="application/atom+xml" href="https://example.com/atomFeed.php?page=3">

分别是在一系列文件中的第一个、下一个、上一个和最后一个
<link rel="first" href="https://example.com/atomFeed.php">
<link rel="next" href="https://example.com/atomFeed.php?page=4">
<link rel="previous" href="https://example.com/atomFeed.php?page=2">
<link rel="last" href="https://example.com/atomFeed.php?page=147">

当使用第三方服务来维护blog时使用
<link rel="EditURI" href="https://example.com/xmlrpc.php?rsd" type="application/rsd+xml" title="RSD">

当另一个WordPress博客链接到WordPress博客或文章时形成一个自动化的评论
<link rel="pingback" href="https://example.com/xmlrpc.php">

当你在自己的页面上链接到一个url时通知它
<link rel="webmention" href="https://example.com/webmention">

加载一个外部的HTML文件到当前HTML文件中
<link rel="import" href="component.html">

打开搜索
<link rel="search" href="/open-search.xml" type="application/opensearchdescription+xml" title="Search Title">

Feeds
<link rel="alternate" href="https://feeds.feedburner.com/example" type="application/rss+xml" title="RSS">
<link rel="alternate" href="https://example.com/feed.atom" type="application/atom+xml" title="Atom 0.3">

预取,预载,预浏览
<link rel="dns-prefetch" href="//example.com/">
<link rel="preconnect" href="https://www.example.com/">
<link rel="prefetch" href="https://www.example.com/">
<link rel="prerender" href="https://example.com/">
<link rel="preload" href="image.png" as="image">

不推荐的link标签
<link rel="shortcut icon" href="path/to/favicon.ico">
<link rel="subresource" href="styles.css">

</textarea>

【 favicon网站图标 】
<textarea rows="15" cols="150">
网站图标存放在根目录,大小一般为32*32
<link rel="shortcut icon" href="/favicon.ico" />
<link rel="bookmark" href="/favicon.ico" type="image/x-icon"/>

IE 11, Chrome, Firefox, Safari, Opera支持link形式设置：
<link rel="icon" href="path/to/favicon-16.png" sizes="16x16" type="image/png">
<link rel="icon" href="path/to/favicon-32.png" sizes="32x32" type="image/png">
<link rel="icon" href="path/to/favicon-48.png" sizes="48x48" type="image/png">
<link rel="icon" href="path/to/favicon-62.png" sizes="62x62" type="image/png">
<link rel="icon" href="path/to/favicon-192.png" sizes="192x192" type="image/png">
对于IE 10及以下版本不支持link形式设置,只通过将命名为favicon.ico的文件放置在网站根目录中实现

</textarea>
</div>

<div id="form">
<h2>表单</h2><pre>
表单用于接收搜集不同类型用户输入,是客户端与服务器进行学习交流的途径。注册登录信息,搜索引擎,发表帖子等。
静态网页和动态网页：交互性

【 button标签 】
所有主流浏览器都支持button标签
如果在HTML表单中使用button元素不同的浏览器会提交不同的值,IE将提交button标签之间的文本,而其他浏览器将提交value属性的内容

表单中应使用input元素来创建按钮。
button元素内部可放置内容如文本或图像。。

button控件与input type="button"相比提供了更为强大的功能和更丰富的内容,button标签之间的所有内容都是按钮的内容,其中包括任何可接受的正文内容如文本、图片或多媒体内容,这是该元素与使用input元素创建的按钮之间的不同之处,例如可以在按钮中包括一个图像和相关的文本,用它们在按钮中创建一个吸引人的标记图像。
唯一禁止使用的元素是图像映射,因为它对鼠标和键盘敏感的动作会干扰表单按钮的行为。

请始终为按钮规定type属性。IE的默认类型是button,而其他浏览器中包括W3C规范的默认值是submit

属性
autofocus: 值autofocus	,规定当页面加载时按钮应当自动地获得焦点。
disabled: 值disabled	,规定应该禁用该按钮。
form: 值form_name,	规定按钮属于一个或多个表单。
formaction: 值url,覆盖form元素的action属性,该属性与type="submit"配合使用。
formenctype: application/x-www-form-urlencoded、multipart/form-data、text/plain,覆盖form的enctype属性,该属性与type="submit"配合使用。
formmethod: 值get/post,覆盖form的method属性,该属性type="submit 配合使用。
formnovalidate: 值formnovalidate	,覆盖form的novalidate属性,该属性与type="submit"配合使用。
formtarget: _blank/_self/_parent/_top/framename,覆盖form的target属性,该属性与type="submit"配合使用。
name: 值button_name,规定按钮的名称。
type: button/reset/submit,规定按钮的类型。
value: 值text,规定按钮的初始值。可由脚本进行修改。

</pre>type为number、email等可以自动验证<pre class="html">
<button type="button">必须指明类型type="button",否则默认为submit,造成页面刷新</button>

<input type="text" style="width:50px">

<fieldset></fieldset>定义围绕表单的边框
<legend></legend>为fieldset元素定义标题
<form  action='url'  method="post" name="表单名称"></form>
<optgroup label="分组名称"> </optgroup>
<!--复选框分组-->

<output name="" for="id1  id2  ……"></output>  //IE不支持
<form oninput="x.value=parseInt(a.value)+parseInt(b.value)">0
  <input type="range" id="a" value="50">100
  +<input type="number" id="b" value="50">
  =<output name="x" for="a b"></output>
</form>
<!--定义不同类型的输出,比如脚本输出-->

<input type="text" name="文本框名称" value="初始值" maxlength="20" />
<!--单行文本框-->
<input type="password"  name="密码框名称" value="初始值" size="显示字符数" maxlength="20"/>
<!--密码框-->
<input type="radio"  name="单选框名称" value="提交值"  checked=" checked "/>选项
<!--单选框名称必须相同-->
<input type="Checkbox" name="复选框名称"  value=" 提交值" checked=" checked "/>选项
<!--复选框-->
<input type="search" >
<!--搜索-->
<input type="tel" >
<!--输入电话号码,返回字符串-->
<input type="email" multiple="multiple">
<!--输入email,返回字符串-->
<input type="color" >
<!--颜色选择-->
<input type="range" min="0" max="10" step="1" style="width: 100px"> onmousemove事件
<!--范围滑动控件-->
<input type="number" min="0" max="10">
<!--输入数字-->
<input type="date" min="1949-1-1" max="2017-1-1">
<!--输入日期,返回字符串-->
<input type="week" min="" max="">
<!--输入星期-->
<input type="month" min="" max="">
<!--输入月份-->
<input type="time" min="" max="">
<!--输入时间-->
<input type="datetime" min="" max="">
<!--输入日期时间-->
<input type="datetime-local" min="" max="">
<!--输入时区日期时间-->·
<input type="submit/reset/button" name="按钮名称"  value="按钮显示文本"/>
<!--提交,重置,普通按钮,重置按钮只会重置表单元素的值,不会重置相关提示信息等内容-->
＜input type="image" name="图片按钮名称"  src="./logo.png"/＞
<!--图片按钮图像输入-->
<input type="file" name="名称" multiple="multiple" />
<input type="file" accept="image/*" capture="camera">  html5调用手机摄像头
<input type="file" accept="video/*" capture="camcorder">
<input type="file" accept="audio/*" capture="microphone">
capture表示,可以捕获到系统默认的设备,比如：camera--照相机;camcorder--摄像机;microphone--录音
<!--文件上传-->
<input type="url" list="url_list" name="link" />    //list属性

目前只有Firefox和Opera支持datalist标签
datalist标签定义选项列表;必须与input元素配合使用该元素,来定义input 可能的值。datalist 及其选项不会被显示出来,它仅仅是合法的输入值列表,datalist中描述了input可能的值,作为input的输入提示
<datalist id="url_list">
  <option label="W3Schools" value="http://www.w3schools.com" />
  <option label="Google" value="http://www.google.com" />
  <option label="Microsoft" value="http://www.microsoft.com" />
</datalist>
<!--网址选项-->

<datalist id="browsers">
   <option value="Internet Explorer">
   <option value="Firefox">
   <option value="Chrome">
   <option value="Opera">
   <option value="Safari">
</datalist>
<!--下拉选框-->

<input type="hidden" name="名称"  value="提交值"/>
<input type="hidden" name="user[pwd]" value="yufeng">   数组形式
<input type="hidden" name="user[id]" value="10086">
<!--隐藏域-->

<select name="列表框名称" >
  <option selected=" selected" value="提交值">列表一</option>
  <option  value="提交值">列表二</option>
</select>

<select>  //选项组
    <optgroup label="Swedish Cars">
    <option value ="volvo">Volvo</option>
    <option value ="saab">Saab</option>
    </optgroup>
    <optgroup label="German Cars">
    <option value ="mercedes">Mercedes</option>
    <option value ="audi">Audi</option>
    </optgroup>
</select>
<!--下拉菜单列表框,没有selected 则默认第一个-->

<select name="列表框名称" size="显示的行数"  multiple(多选,无则单选)>
    <option  value="提交值">列表一</option>
    <option  value="提交值">列表二</option>
</select>
<!--列表式列表框,没有selected 则默认第一个-->

关联用法点击文字即可选中按钮表单元素标记label 为input元素定义标注,可嵌套使用
为input元素定义标签标记标注,for属性值为id值
<input type="radio" name="gender" id="manbt" value="man" checked="checked" />
<label for="manbt">男</label>
<label >
  <input type="radio" name="gender" value="female"/>女
</label>

textarea标签多行文本框,拉右下角可缩放,style="resize:none"

onblur="javascript:alert(typeof this.value)" 检验返回的数据类型

</pre>

<h3>input属性</h3><pre>
name属性定义元素名称
value属性规定默认值,预定义值,初始值
title属性可用于提示
checked="checked" 默认被选中
disabled="disabled" input元素加载时禁用,禁止点击属性,要去除时可用js删除该属性
readonly="readonly" 规定输入字段只读
表单元素在使用了disabled后将表单以POST或GET的方式提交的话,这个元素的值不会被传递出去,而readonly会将该值传递出去

form="formid"规定所属表单
size 属性规定输入字段的宽度,可视化属性,输入框宽度,可用css代替
min="number/date" max="number/date" 适用于number,range,date等时间
step="3" 输入间隔,可单独使用,也可配合min,max
maxlength="字符数" 限制输入的字符数,适用于text和password

multiple="multiple" 规定file和email多选
autofocus 属性规定在页面加载时,域自动地获得焦点,不用于隐藏域。
autocomplete属性,值：on、off,规定 form 或 input 域应该拥有自动完成功能。
pattern属性用于验证text/search/url/email/password/telephone的模式,即正则表达式 例：pattern="[A-z]{3}"
placeholder属性提供用户一种提示,输入字段为空时输入框内浅色字符串,获得焦点消失
required属性规定必填的内容,验证非空输入
例：input type="text" required oninvalid="setCustomValidity('自定义提示信息')" oninput="setCustomValidity('')"

</pre>

<h4>input type="file"特有属性：</h4><pre>
accept属性规定通过文件上传进行提交的文件MIME类型,多个MIME类型用英文逗号分开,默认是可以上传所有文件,主要在服务器端验证

accept="image/*"可以用来限制只允许上传图像格式不限制图片格式,但在Webkit浏览器下却出现了响应滞慢的问题,要等上好几秒才弹出文件选择框,解决方法就是将*通配符改为指定的MIME类型

</pre><pre class="html">
  <input type="file" accept="image/gif,image/jpeg,image/jpg,image/png">
  <input type="file" accept="image/* " >
  <input type="file" accept="image,excel,word">
</pre>

<h4>input type="image"特有属性：</h4><pre>
alt 属性规定上传的图片替代文字
heght
width
src
align: left right top middle bottom 规定图像输入的对齐格式

</pre><pre class="html">
//点击提交返回控件名.x=坐标 控件名.y=坐标
＜input type="image" src="./logo.png" name="tupain"  alt="提交"  align="right" onclick="return dosubmit()" style="cursor:pointer;"＞
< input type="image" onClick = "formName.submit()">
//有提交功能,在表单内会发生表单提交2次,重复写入数据库,解决方法：要把数据库设置为同一信息要唯一！
创建一个图像控件,该控件单击后将导致表单立即被提交

</pre>

<h4>form属性: </h4><pre>
accept-charset	规定在被提交表单中使用的字符集(默认：页面字符集)
action	规定向何处提交表单的地址(URL)(提交页面)action="mailto:3400982550@qq.com enctype="text/plain" 本地邮件客户端软件
autocomplete	规定浏览器应该自动完成表单(默认：开启)
enctype	规定被提交数据的编码(默认：url-encoded)。
method	规定在提交表单时所用的HTTP方法(默认：GET,)
name	规定识别表单的名称(对于DOM使用：document.forms.name)
novalidate	规定浏览器不验证表单。
target	规定action属性中地址的目标(默认：_self)

GET适合少量数据的提交,浏览器会设定容量限制,如搜索引擎查询,此时表单数据在页面地址栏是可见的;
POST适合表单正在更新数据,或者含密码等敏感信息,安全性更高,在地址栏不可见

</pre><pre class="html">
checked:&nbsp;<input type="checkbox" checked>
unchecked:<input type="checkbox" unchecked>

document.getElementById('indeterminate').indeterminate = true;

</pre><pre class="html">
<form class="form-horizontal" method="post" role="form">
  <div class="panel panel-default">
    <div class="panel-heading">安装选项</div>
    <div class="panel-body">
      <div class="form-group">
        <label class="col-sm-2 control-label">安装方式</label>
        <div class="col-sm-10">
          <label class="radio-inline">
            <input type="radio" name="type" value="local"{$insTypes['local']}{$disabled}> 离线安装
          </label>
          <div class="help-block hidden">
            <span style="color:red">由于在线安装是精简版,安装后,请务必注册云服务更新到完整版</span> <br/>
            在线安装能够直接安装最新版本微擎系统, 如果在线安装困难, 请下载离线安装包后使用本地安装. <br/>
            离线安装包可能不是最新程序, 如果你不确定, 可以现在访问官网重新下载一份最新的.
          </div>
        </div>
      </div>
    </div>
  </div>
  <div class="panel panel-default">
    <div class="panel-heading">数据库选项</div>
    <div class="panel-body">
      <div class="form-group">
        <label class="col-sm-2 control-label">数据库主机</label>
        <div class="col-sm-4">
          <input class="form-control" type="text" name="db[server]" value="127.0.0.1">
        </div>
      </div>
      <div class="form-group">
        <label class="col-sm-2 control-label">数据库用户</label>
        <div class="col-sm-4">
          <input class="form-control" type="text" name="db[username]" value="root">
        </div>
      </div>
      <div class="form-group">
        <label class="col-sm-2 control-label">数据库密码</label>
        <div class="col-sm-4">
          <input class="form-control" type="text" name="db[password]">
        </div>
      </div>
      <div class="form-group">
        <label class="col-sm-2 control-label">表前缀</label>
        <div class="col-sm-4">
          <input class="form-control" type="text" name="db[prefix]" value="ims_">
        </div>
      </div>
      <div class="form-group">
        <label class="col-sm-2 control-label">数据库名称</label>
        <div class="col-sm-4">
          <input class="form-control" type="text" name="db[name]" value="we7">
        </div>
      </div>
    </div>
  </div>
  <div class="panel panel-default">
    <div class="panel-heading">管理选项</div>
    <div class="panel-body">
      <div class="form-group">
        <label class="col-sm-2 control-label">管理员账号</label>
        <div class="col-sm-4">
          <input class="form-control" type="username" name="user[username]">
        </div>
      </div>
      <div class="form-group">
        <label class="col-sm-2 control-label">管理员密码</label>
        <div class="col-sm-4">
          <input class="form-control" type="password" name="user[password]">
        </div>
      </div>
      <div class="form-group">
        <label class="col-sm-2 control-label">确认密码</label>
        <div class="col-sm-4">
          <input class="form-control" type="password"">
        </div>
      </div>
    </div>
  </div>
  <input type="hidden" name="do" id="do" />
  <ul class="pager">
    <li class="previous"><a href="javascript:;" onclick="$('#do').val('back');$('form')[0].submit();"><span class="glyphicon glyphicon-chevron-left"></span> 返回</a></li>
    <li class="previous"><a href="javascript:;" onclick="if(check(this)){jQuery('#do').val('continue');if($('input[name=type]:checked').val() == 'remote'){alert('在线安装时,安装程序会下载精简版快速完成安装,完成后请务必注册云服务更新到完整版。')}$('form')[0].submit();}">继续 <span class="glyphicon glyphicon-chevron-right"></span></a></li>
  </ul>
</form>

</pre>
</div>

<div id="object">
<h2>多媒体 video和audio</h2><pre>
【 video元素 】
video元素用于在HTML或XHTML文档中嵌入媒体播放器,用于支持文档内的视频播放,也可将video标签用于音频,但audio元素可能在用户体验上更合适
在src属性里加入一个要展示的视频地址,同时也可用其他属性来定义视频的宽高度、是否自动或循环播放、是否展示浏览器默认的视频控件等信息
在video标签中间的内容是针对浏览器不支持此元素时候的降级处理, 当浏览器不支持video标签的时候显示出来,能够对旧的浏览器做一些兼容处理,浏览器并不是都支持相同的视频格式,所以可以在source元素里提供多个视频源,然后浏览器将会使用它所支持的第一个源

// Does the browser actually support the video element?
var supportsVideo = !!document.createElement('video').canPlayType;

</pre><pre class="html">
//播放视频需要占据一定的页面,设置宽度高度
< video src="web/media/oceans.mp4" width=960 height=400 controls loop autoplay></ video>

< video width="658" height="444"
src="http://www.youname.com/images/first.mp4"
poster="http://www.youname.com/images/first.png"
autoplay="autoplay"
preload="none"
loop="loop"
controls="controls"></ video>

// Simple video example,播放一个视频,视频一收到允许播放的时候就会立马开始播放,而不会停下来直到下载更多内容。 图片posterimage.jpg会一直展示在视频区域,直到开始播放。
< video src="videofile.ogg" autoplay poster="posterimage.jpg">
  抱歉,您的浏览器不支持内嵌视频,不过不用担心,你可以 < a href="videofile.ogg">下载</ a> 并用你喜欢的播放器观看!
</ video>

</pre><pre>
【 audio标签 】
audio标签与video标签的使用方式几乎完全相同,与video的差异如下：
1、audio标签不支持width/height属性,由于其并没有视觉部件,也就没有可以设置width/height的内容。
2、也不支持poster属性,同样没有视觉部件。
3、音频播放器所占用的空间比视频播放器要小,由于它没有视觉部件,只需要显示出能控制音频播放的控件

</pre><pre class="html">
< audio src=music.mp3></ audio>

//兼容用法
< audio>
  < source src="music.mp3" type="audio/mpeg">  //指定type属性(媒体资源类型)mp3
  < source src="music.wav" type="audio/x-wav"> //wav
  < source src="viper.mp3" type="audio/mp3">
  < source src="viper.ogg" type="audio/ogg">
  <p>你的浏览器不支持 HTML5 音频,可点击< a href="viper.mp3">此链接</ a>收听。</p>
</ audio>

因为浏览器限制有些格式的视频音频不能播放,最好的办法就是同时提供多种格式
同时提供ogg和MP3两种格式的音频,HTML5 audio元素会尝试以mp3或ogg来播放音频,否则会使用embed元素或直接显示文本信息
添加一个ogg类型的文件是为了使这段音频在Firefox和Opera中同样有效
< audio controls>
  < source src="song.ogg" type="audio/ogg">
  < source src="God is a girl.mp3" type="audio/mpeg">
  < embed height="100" width="100" src="God is a girl.mp3" />
  Your browser does not support the audio element.
</ audio>

</pre>动态的创建audio元素<pre class="js">
//方式1
var audio = document.createElement("audio");
audio.src = "hangge.mp3";
audio.play();

//方式2
var audio = new Audio("hangge.mp3");
audio.play();

</pre>

</pre><pre class="js">
< video id="video1" width="300" height="300" controls='controls' loop autoplay>
  < source src="lover-KATE.ogg" type="video/ogg" />
  < source src="lover-KATE.mp4" type="video/mp4" />
  < source src="lover-KATE.webm" type="video/webm" />
  your browser does not support the video tag!
</ video>
<p>
  <button type="button" onclick='playPause()'>播放/暂停</button>
  <button type="button" onclick="tobig()">大</button>
  <button type="button" onclick="normal()">中</button>
  <button type="button" onclick="tosmall()">小</button>
  <button type="button" onclick="load()">下载</button>
</p>

// js代码
var video1=document.getElementById('video1');

function playPause(){
  video1.paused ? video1.play() : video1.pause();
}

function tobig(){
  video1.width = video1.height = 500;
}

function normal(){
  video1.width = video1.height = 300;
}

function tosmall(){
  video1.width = video1.height = 200;
}

</pre><pre>
【 source标签: 多格式支持 】
MP3、MP4、WebM这些术语叫做容器格式,他们是用不同的方式来播放音频或者视频的,即这些容器是用不同的音频轨道、视频轨道、元数据来呈现媒体文件的

视频和音频都有不同的格式:
WebM容器通常包括了Ogg Vorbis音频和VP8/VP9视频,主要在FireFox和Chrome当中支持。
MP4(MPEG4)容器通常包括AAC以及MP3音频和H.264视频,主要在Internet Explorer和Safari当中支持。
老式的Ogg容器往往支持Ogg Vorbis音频和Ogg Theora视频,主要在Firefox和Chrome当中支持,不过这个容器已经被更强大的WebM容器所取代。

音频播放器将会直接播放音频文件,例如MP3和Ogg文件,这些不需要容器

以上的格式主要用于将音频和视频压缩成可管理的文件(原始的音频和视频文件非常大)。浏览器包含了不同的Codecs,如Vorbis和H.264,它们用来将已压缩的音频和视频转化成二进制数字。浏览器并不全支持相同的codecs,所以得使用几个不同格式的文件来兼容不同的浏览器,如果使用的格式都得不到浏览器的支持,那么媒体文件将不会播放

浏览器对视频格式的支持各不相同,小一点的浏览器厂商比如firefox和opera不愿支持商业的视频格式(mp4),因为需要支付专利费,而大一点的厂商如微软苹果等,不愿支持开源的格式,因为可能有专利问题。为了解决兼容性的问题,HTML5也给出了解决办法,那就是source标签

浏览器会最先尝试播放第一个视频,如果发现不支持会播放第二个,依次类推直到找到一个可以播放的,或者全部能播放

每个source标签页含有一个type属性,这个属性是可选的,但是建议添加上这个属性,它包含了视频文件的MIME types,同时浏览器也会通过检查这个属性来迅速的跳过那些不支持的格式。如果没有添加type属性,浏览器会尝试加载每一个文件,直到找到一个能正确播放的格式,这样会消耗掉大量的时间和资源

</pre><pre class="html">
< video controls>
  < source src="myVideo.mp4" type="video/mp4">
  < source src="myVideo.webm" type="video/webm">
  <p>Your browser doesn't support HTML5 video. Here is
     a < a href="myVideo.mp4">link to the video</ a> instead.</p>
</ video>

</pre><pre>
【 TimeRanges对象 】
TimeRanges接口用来表示一组时间范围,主要目的是跟踪供audio和video元素加载使用的媒体哪些部分已经被缓冲。
一个TimeRanges对象包括一个或多个时间范围,其中每个都由一个开始偏移量和结束偏移量指定。可以将想要检索的时间范围的索引值传递给start()和end()方法来引用每个时间范围。

术语"normalized TimeRanges object"指出这种对象中的范围时有序的,不重叠的,不为空并且不接触的(相邻范围被折叠成更大的范围)。

属性
TimeRanges.length 只读
返回一个unsigned long类型的数字,表示由time range对象表示的time ranges的数量。

方法
TimeRanges.start()
返回具有指定索引的范围的开始时间。

TimeRanges.end()
返回指定范围的结束时间。

【 服务器支持 】
如果视频的MIME类型设置不正确,视频可能不会显示,或显示包含一个X的灰色盒子

如果提供的视频是Ogg Theora格式的,在Apache Web服务器上可以通过"/etc/apache"中的"mime.types"文件或通过在httpd.conf中的"AddType的"配置指令把视频文件的扩展名(最常见的是".ogm", ".ogv", or ".ogg")添加到MIME类型"video/ogg"来解决这个问题。
AddType video/ogg .ogm
AddType video/ogg .ogv
AddType video/ogg .ogg

如果以WebM格式提供视频,在Apache Web服务器上可以通过"/etc/apache"中的"mime.types"文件或通过在httpd.conf中的"AddType的"配置指令把视频文件的扩展名(最常见的是".webm")添加到MIME类型"video/webm"来解决这个问题。
AddType video/webm .webm

web主机可能会提供一个简单的接口来修改MIME类型配置,直到服务器全面升级。

【 HTMLVideoElement接口 】
video元素实现了HTMLVideoElement接口

HTMLVideoElement接口提供了用于操作视频对象的特殊属性和方法,同时还继承了HTMLMediaElement和HTMLElement的属性与方法。

在不同浏览器中支持的媒体格式是不一样的,因此在提供媒体文件的时候,或者提供一种所有浏览器都支持的格式,或者提供格式不同的多个视频源来支持不同浏览器,保证想要支持的浏览器都能够播放。

</pre>

<h4>音频/视频属性</h4><pre>
src
设置或返回音频/视频元素的当前来源,可选
同img标签使用方式相同,要嵌到页面的视频的URL,也可以使用video块内的source元素来指定需要嵌到页面的视频。

width/height
视频展示区域的宽度高度,单位是CSS像素,也可以用CSS来控制视频尺寸。
无论使用哪种方式,视频都会保持它原始的长宽比即做纵横比,如果设置的尺寸没有保持视频原始长宽比,那么视频边框将会拉伸,而未被视频内容填充的部分将会显示默认的背景颜色

autoplay
设置或返回是否在加载完成后随即播放音频/视频
布尔属性,立即自动播放,即使页面的其他部分还没有加载完全

controls
设置或返回音频/视频是否显示浏览器默认播放控件(比如播放/暂停等),允许用户控制视频的播放,包括音量、跨帧、暂停/恢复播放,用来作为背景音乐的话可以把controls属性去掉,不显示播放界面
1、video标签内有track标签时会在默认播放控件中显示CC
2、video标签和audio标签在谷歌浏览器上自带下载按钮,不想要下载按钮的时候可以试一下以下操作
第一种方案：在video或者audio标签上添加controlsList="nodownload"即可关闭下载按钮
第二种方案：通过css将按钮超出进行隐藏
video::-webkit-media-controls-enclosure { overflow:hidden;}
video::-webkit-media-controls-panel { width: calc(100% + 30px);}
audio::-internal-media-controls-download-button { display:none;}

controlsList
controlsList="nodownload"
controlsList="nofullscreen"
controlsList="noremoteplayback"
controlsList="nodownload nofullscreen noremoteplayback"

loop
布尔属性,设置或返回音频/视频是否应在结束时重新播放,循环播放

preload
设置或返回音频/视频是否应该在页面加载后进行加载。
定义了页面是否预加载,被用来缓冲较大的文件,默认浏览器定义的,即不同浏览器会选择自己的默认值,即使规范建议设置为metadata。
可能是下列值之一：
none: 不预加载,服务器也想要最小化访问流量,即提示浏览器该视频不需要缓存。
metadata: 仅缓冲文件的元数据,预加载,但是只抓取元数据如长度
auto: 页面加载后缓存媒体文件,预加载资源信息,用户需要这个视频优先加载,如果需要的话可以下载整个视频,即使用户并不一定会用它。
空字符串：也就代指auto值。

paused
设置或返回音频/视频是否暂停状态

ended
返回音频/视频的播放是否已结束完成

erro
返回表示音频/视频错误状态的MediaError对象。

currentTime
设置或返回音频/视频中的当前播放位置(以秒计),播放跳转
通过pause()和play()方法可以使音乐暂停和继续播放,结合currentTime属性可以实现停止和重新播放

playbackRate
设置或返回音频/视频播放的速度
表示播放速度,取值区间为0到4,取值在0到1间时慢速播放,取值为1时正常播放。

volume
设置或返回音频/视频的音量,表示音量调整,取值为0(静音)到1
audio.volume = 0;  // 表示静音
audio.volume = 1;  // 表示声音最大

muted
设置或返回音频/视频是否静音
布尔属性,表示是否静音,指明了视频里的音频的默认设置,设置muted=true后音频会初始化为静音,默认值是false即视频播放的时候音频也会播放

poster
一个海报帧的URL,用于在用户播放或者跳帧之前展示。如果属性未指定那么在第一帧可用之前什么都不会展示,之后第一帧就像海报帧一样展示
这个图像会在视频播放前显示,通常用于粗略的预览或者广告

buffered
返回表示音频/视频已缓冲部分的TimeRanges对象,这个属性可以读取到哪段时间范围内的媒体被缓存了

played
返回表示音频/视频已播放部分的TimeRanges对象
一个TimeRanges对象,指明了视频已经播放的所有范围

crossorigin
设置或返回音频/视频的CORS设置
该枚举属性指明抓取相关图片是否必须用到CORS跨域资源共享。支持CORS的资源可在canvas元素中被重用,而不会被污染
不加这个属性时抓取资源不会走CORS请求(即不会发送 Origin: HTTP头),保证其在canvas元素中使用时不会被污染。如果指定非法值会被当作指定了枚举关键字anonymous一样使用
允许的值如下：
anonymous
跨域请求即使用Origin:的HTTP头会被执行,但是不发送凭证即不发送cookie、X.509证书或HTTP Basic授权。如果服务器不提供证书给源站点 (不设置Access-Control-Allow-Origin: HTTP头),图片会被污染并且它的使用会受限。
use-credentials
跨域请求A cross-origin request (i.e. with Origin: HTTP header) 会被执行,且凭证会被发送 (即发送一个cookie,一个证书和HTTP Basic授权会被执行)。如果服务器不提供证书给源站点 (通过Access-Control-Allow-Credentials: HTTP头),图像会被污染且它的使用会受限。

controller          返回表示音频/视频当前媒体控制器的MediaController对象。
currentSrc          返回当前音频/视频的URL。
duration            返回当前音频/视频的长度(以秒计),表示媒体播放时长
networkState	      返回音频/视频的当前网络状态。
readyState          返回音频/视频当前的就绪状态。
seekable            返回表示音频/视频可寻址部分的TimeRanges对象。
seeking             返回用户是否正在音频/视频中进行查找,是否跳转
startDate           返回表示当前时间偏移的Date对象。
audioTracks         返回表示可用音频轨道的AudioTrackList对象。
textTracks          返回表示可用文本轨道的TextTrackList对象。
videoTracks         返回表示可用视频轨道的VideoTrackLis对象。

defaultMuted        设置或返回音频/视频默认是否静音。
defaultPlaybackRate 设置或返回音频/视频的默认播放速度。
mediaGroup          设置或返回音频/视频所属的组合(用于连接多个音频/视频元素)。

initialTime         表示媒体开始播放时间

</pre>

<h4>音频/视频audio/video方法</h4><pre>
addTextTrack()
向音频/视频添加新的文本轨道。

canPlayType()
audio|video.canPlayType(type))
HTMLVideoElement的canPlayType API进行当前环境的格式兼容判断,检测浏览器是否能播放指定的音频/视频类型

type参数规定要检测的音频/视频类型。
常用值：
video/ogg
video/mp4
video/webm
audio/mpeg
audio/ogg
audio/mp4

常用值,包括编解码器：
video/ogg; codecs="theora, vorbis"
video/mp4; codecs="avc1.4D401E, mp4a.40.2"
video/webm; codecs="vp8.0, vorbis"
audio/ogg; codecs="vorbis"
audio/mp4; codecs="mp4a.40.5"

返回值是表示支持的级别,返回下列值之一：
"probably" - 浏览器最可能支持该音频/视频类型,如果包含编解码器则只能返回 "probably"。
"maybe" - 浏览器也许支持该音频/视频类型
"" - (空字符串)浏览器不支持该音频/视频类型

</pre>通过canPlayType()方法可以判断浏览器支持的编码方式,从而设置对应的音频文件<pre class="js">
if (audio.canPlayType("audio/mp3")) {
  audio.src = "hangge.mp3";
}else if(audio.canPlayType("audio/ogg")) {
  audio.src = "hangge.ogg";
}

</pre><pre class="js">
let videoEl = document.createElement("video");
videoEl.canPlayType('video/mp4') !== '';                                   // 是否支持MP4
videoEl.canPlayType('video/mp4; codecs="avc1.42E01E, mp4a.40.2"') !== '';  // 是否支持MP4 & 特定编码的
videoEl.canPlayType('video/webm; codecs="vp8, vorbis"') !== '';            // 是否支持webm & 特定编码的
videoEl.canPlayType('video/ogg; codecs="theora, vorbis"') !== '';          // 是否支持ogg & 特定编码的
videoEl.canPlayType('application/vnd.apple.mpegURL') !== '';               // 是否支持HLS的m3u8
videoEl.canPlayType('video/mp2t; codecs="avc1.42E01E,mp4a.40.2"') !== '';  // 是否支持HLS的TS切片

</pre><pre>
load()
重新加载音频/视频元素。

play()
开始播放音频/视频。

pause()
暂停当前播放的音频/视频。

</pre>

<h4>音频/视频事件</h4><pre>
abort
在播放被终止时触发,例如当播放中的视频重新开始播放时会触发这个事件。

canplay
在媒体数据已经有足够的数据(至少播放数帧)可供播放时触发,对应CAN_PLAY的readyState

canplaythrough
当浏览器可在不因缓冲而停顿的情况下进行播放时触发。
在媒体的readyState变为CAN_PLAY_THROUGH时触发,表明媒体可以在保持当前的下载速度的情况下不被中断地播放完毕。手动设置currentTime会使得firefox触发一次canplaythrough事件,其他浏览器或许不会如此。
audio.addEventListener("canplaythrough", () => console.log('音频文件已经准备好,随时待命'));

durationchange
当音频/视频的时长已更改时触发,元信息已载入或已改变,表明媒体的长度发生了改变,例如在媒体已被加载足够的长度从而得知总长度时会触发该事件

emptied
当目前的播放列表为空时触发,媒体被清空(初始化)时触发

ended
当目前的播放列表已结束或中断时触发,播放结束时触发,该事件通常用于提示播放完成的信息,例如 "谢谢收听", "谢谢观看" 等
audio.onended = () => alert("音频播放完成");

error
当在音频/视频加载期间发生错误时触发,在发生错误时触发,元素的error属性会包含更多信息

loadeddata
当浏览器已加载音频/视频的当前帧时触发,媒体的第一帧已经加载完毕

loadedmetadata
当浏览器已加载音频/视频的元数据(音频的时长等)时触发,媒体的元数据已经加载完毕,现在所有的属性包含了它们应有的有效信息

loadstart
当浏览器开始查找音频/视频时触发,在媒体开始加载时触发,在开始请求媒体资源时触发

pause
当音频/视频播放暂停时触发

play
当音频/视频已开始或不再暂停时触发,在媒体回放被暂停后再次开始时触发,即在一次暂停事件后恢复媒体回放
视频开始播放触发的事件(触发此事件,但是视频不一定可以播放)

playing
当音频/视频在因缓冲而暂停或停止后已就绪时触发,在媒体开始播放时触发(不论是初次播放、在暂停后恢复或是在结束后重新开始)
在缓存数据足够时可以播放触发,继续播放视频

progress
当浏览器正在下载音频/视频时触发,告知媒体相关部分的下载进度时周期性地触发,有关媒体当前已下载总计的信息可以在元素的buffered属性中获取到

ratechange
当音频/视频的播放速度已更改时触发,在回放速率变化时触发

seeked
当用户已移动/跳跃到音频/视频中的新位置时触发,在跳跃操作完成时触发

seeking
当用户开始移动/跳跃到音频/视频中的新位置时触发,在跳跃操作开始时触发

stalled
当浏览器尝试获取媒体数据,但数据不可用时触发。

suspend
当浏览器刻意不获取媒体数据时触发,在媒体资源加载终止时触发,这可能是因为下载已完成或因为其他原因暂停

timeupdate
当目前的播放位置已更改时触发,元素的currentTime属性表示的时间已经改变
调用出音频的时长: audio.duration,调用播放进度需要用到一个时间监听。currentTime代表当前播放的时间,当currentTime改变时触发timeupdate事件。因此监听timeupdate,并且输出currentTime即可完成进度的判断

js控制audio的快进,快退,以及显示进度与时长
控制快进,快退的原理比较简单,只不过是设置audio的currentTime
audio.currentTime += 10;   // 10秒快进

volumechange
当音量已更改时触发,在音频音量改变时触发(既可以是volume属性改变,也可以是muted属性改变)

waiting
当视频由于需要缓冲下一帧而停止时触发,在一个待执行的操作(如回放)因等待另一个操作(如跳跃或下载)被延迟时触发
在缓存数据不够等待播放时触发

mozaudioavailable
当音频数据缓存并交给音频层处理时

</pre>只要在媒体中跳跃到10s位置的操作完成,视频就会马上播放<pre class="js">
var v = document.getElementsByTagName("video")[0];
v.addEventListener("seeked", function() {             // 在video元素上监听了一个seeked事件,该事件会在跳跃操作完成后触发
  document.getElementsByTagName("video")[0].play();   // 开始视频的播放
}, true);
v.currentTime = 10.0;  // 初始化一个在媒体中跳跃(快进)到10s位置的操作,操作开始时触发seeking事件,当跳跃操作完成时触发seeked事件

</pre><pre class="js">
< audio id="bgMusic">
  < source src="hangge.mp3" type="audio/mp3">
  < source src="hangge.ogg" type="audio/ogg">
</ audio>

var audio = document.getElementById("bgMusic");

//播放(继续播放)
audio.play();

//暂停
audio.pause();

//停止
audio.pause();
audio.currentTime = 0;

//重新播放
audio.currentTime = 0;
audio.play();

// 跳到第50秒播放
audio.currentTime = 50;
audio.play();

</pre>连续点击播放和暂停引发页面错误,无法关闭页面<pre class="js">
// Uncaught (in promise) DOMException: The play() request was interrupted by a call to pause()

var music = new Audio();
music.src = "/1.mp3";
music.loop = true;
var playStatus = false;
var lastRunTime = Date.now();
function playOrPause(){
  var currentTime = Date.now();
  var protectTime = 100;                              //设置保护性延时,单位毫秒,不要小于50,建议100以上
  if((currentTime-lastRunTime) < protectTime) return; //两次执行太过频繁,直接退出

  playStatus ? music.pause() : music.play();
  playStatus = !playStatus;
  lastRunTime = Date.now();
}
var counter = 10;//要连点的次数
var timer = setInterval(function(){
  if(counter>0){
    document.querySelector("#btn1").click();
  }else{
    clearInterval(timer);
  }
  counter--;
}, 500)

</pre>

<h3>track标签</h3><pre>
字幕也是一个复杂的问题,简单的一个字幕就可能有下面的需求：格式,换行,颜色,卡拉OK等。所以现存的字幕格式就有50多种。使用字幕的方式和使用source的方式类似,同时可指定多个字幕文件,用来指代不同语言的字幕,用户可以自己选择想要的字幕。

给那些听不懂音频语言的人们提供一个音频内容的副本,video使之成为可能,有了WebVTT格式,可以使用track标签
副本指用文本记录下音频的内容

WebVTT是一个格式,用来编写文本文件,这个文本文件包含了众多的字符串,这些字符串会带有一些元数据,它们可以用来描述这个字符串将会在视频中显示的时间,甚至可以用来描述这些字符串的样式以及定位信息。这些字符串叫做cues,可以根据不同的需求来显示不同的样式,最常见的如下：
1、subtitle
通过添加翻译字幕,来帮助那些听不懂外国语言的人们理解音频当中的内容。

2、captions
同步翻译对白,或是描述一些有重要信息的声音,来帮助那些不能听音频的人们理解音频中的内容。

3、timed descriptions
将文字转换为音频,用于服务那些有视觉障碍的人。

</pre>一个典型的WebVTT文件格式,标记了每个字幕开始出现的时间和消失的时间<pre class="html">
WEBVTT

00:00:22.230 --> 00:00:24.606
第一段字幕

00:00:30.739 --> 00:00:34.074
第二段

</pre><pre>
让其与HTML媒体一起显示需要做如下工作：
1、以.vtt后缀名保存文件
2、用track标签链接.vtt文件,track标签需放在audio或video标签当中,同时需要放在所有source标签之后。使用kind属性来指明是哪一种类型,如subtitles 、 captions 、 descriptions。然后使用srclang来告诉浏览器是用什么语言来编写的subtitles。

</pre><pre class="html">
< video controls>
  < source src="example.mp4" type="video/mp4">
  < source src="example.webm" type="video/webm">
  < track kind="subtitles" src="subtitles_en.vtt" srclang="en">
</ video>

< video id="video" controls preload="metadata">
  < source src="video/sintel-short.mp4" type="video/mp4">
  < source src="video/sintel-short.webm" type="video/webm">
  < track label="English" kind="subtitles" srclang="en" src="captions/vtt/sintel-en.vtt" default>
  < track label="Deutsch" kind="subtitles" srclang="de" src="captions/vtt/sintel-de.vtt">
  < track label="Español" kind="subtitles" srclang="es" src="captions/vtt/sintel-es.vtt">
</ video>

// Video with subtitles,允许用户选择不同的字幕
< video src="foo.ogg">
  < track kind="subtitles" src="foo.en.vtt" srclang="en" label="English">
  < track kind="subtitles" src="foo.sv.vtt" srclang="sv" label="Svenska">
</ video>

</pre><pre>
文本轨道会使网站更容易被搜索引擎抓取到(SEO),由于搜索引擎的文本抓取能力非常强大,使用文本轨道甚至可以让搜索引擎通过视频的内容直接链接

</pre>

<h3>MediaSource</h3><pre>
MediaSource: mediaSource是Media Source Extensions API,表示媒体资源HTMLMediaElement对象的接口,MediaSource对象可以附着在HTMLMediaElement在客户端进行播放

区别于传统的直接在video标签中写上src="/server/media/demo.mp4"的用法,MediaSource的使用要稍微复杂一点
Media Source Extensions允许JS动态地为audio和video创建媒体流,而不是只能引用一个视频文件的url,极大地丰富了前端对音视频的处理能力

</pre><pre class="js">
interface MediaSource : EventTarget {
  readonly attribute SourceBufferList    sourceBuffers;
  readonly attribute SourceBufferList    activeSourceBuffers;
  readonly attribute ReadyState          readyState;
           attribute unrestricted double duration;
           attribute EventHandler        onsourceopen;
           attribute EventHandler        onsourceended;
           attribute EventHandler        onsourceclose;
  SourceBuffer addSourceBuffer(DOMString type);
  void         removeSourceBuffer(SourceBuffer sourceBuffer);
  void         endOfStream(optional EndOfStreamError error);
  void         setLiveSeekableRange(double start, double end);
  void         clearLiveSeekableRange();
  static boolean isTypeSupported(DOMString type);
};

</pre><pre>
【 构造函数 】
MediaSource()
构造并返回一个新的MediaSource的空对象(with no associated source buffers)

JS可通过URL.createObjectURL方法生成一个临时的src,该src和MediaSource对象绑定,MediaSource对象通过自己的SourceBuffer集合从外部接收数据,然后将数据输入到HTMLMediaElement对象进行数据解析播放。一个MediaSource对象有一个或多个SourceBuffer对象,JS可以自行通过addSourceBuffer接口添加

var video = document.querySelector('video');
var mediaSource = new MediaSource();
video.src = URL.createObjectURL(mediaSource);

</pre>

<h4>MS实例属性</h4><pre>
【 MediaSource.sourceBuffers 只读 】
sourceBuffers是MS实例上的一个属性,它返回的是一个SourceBufferList对象,里面可以获取当前MS上挂载的所有SB的对象列表,不过只有当MS为open状态时它才可以访问

let SBs = mediaSource.sourceBuffers;

怎么获取到具体的SB对象呢？因为其返回值是SourceBufferList对象,具体格式为：

</pre><pre class="js">
interface SourceBufferList : EventTarget {
  readonly attribute unsigned long length;
           attribute EventHandler  onaddsourcebuffer;
           attribute EventHandler  onremovesourcebuffer;
  getter SourceBuffer (unsigned long index);
};

</pre><pre>
可以直接通过index来访问具体的某个SB:
let SBs = mediaSource.sourceBuffers;
let SB1 = SBs[0];

SBL对象还提供了addsourcebuffer和removesourcebuffer事件,如果想监听SB的变化可以直接通过SBL来做,这也是MS没有提供监听事件的一个原因。所以删除某一个SB就可以通过SBL查找,然后利用remove方法移除即可：

let SBs = mediaSource.sourceBuffers;
let SB1 = SBs[0];
mediaSource.removeSourceBuffer(SB1);

【 MediaSource.activeSourceBuffers 只读 】
返回一个SourceBufferList对象,包含了这个MediaSource.sourceBuffers中的SourceBuffer子集的对象,ASBs包含的是当前正在使用的SB,每个SB实际上都可以具体代表一个track,即提供当前被选中的视频轨(video track),启用的音频轨(audio tracks)以及显示/隐藏的字幕轨(text tracks)的对象列表。

那怎么标识正在使用的SB呢？不用标识,因为控制哪一个SB正在使用是你来决定的,如果非要标识就需要使用到HTML中的video和audio节点

</pre><pre class="js">
audioTrack = media.audioTracks[index]
videoTrack = media.videoTracks[index]

// media为具体的video/audio的节点,返回值就是video/audio的底层tracks
audioTrack = media.audioTracks.getTrackById(id)
videoTrack = media.videoTracks.getTrackById(id)

videoTrack.selected // 返回boolean值,标识是否正在被使用

</pre><pre>
上面的代码只是告诉你正在使用的含义是什么,对于实际编码的SB来说并没有太多关系,了解就好。
ASBs返回值也是一个SBL,所以使用方式可以直接参考SBL即可。

track的切换
track是音视频播放的轨道,和MS没有太大的关系,不过和SB还是有一点关系的,因为一个SB里面可能会包含一个或几个track。所以推荐某一个SB最好包含一个值包含一个track,这样后面的track也方便更换。在track中的替换里有三种类型,audio,video,text轨道。

切换的含义有两种,一种是移除原有的,一种是添加新的
(a)移除原有不需要track:从activeSourceBuffers移除与当前track相关的SB,触发activeSourceBuffers的removesourcebuffer事件
(b)添加指定的track:从activeSourceBuffers添加指定的SourceBuffer,触发activeSourceBuffers的addsourcebuffer事件

【 如何界定track 】
track和SB并不是一一对应的关系,他们的关系只能是SB : track = 1: 1 or 2 or 3,即一个SB可能包含一个A/V track(1),或一个Video track ,一个Audio track(2),或再额外加一个text track(3)。

推荐将track和SB设置为一一对应的关系应该这样比较好控制,比如移除或同步等操作

SB里面怎么决定track的播放
track最重要的特性就是pts,duration,access point flag。
track中最基本的单位叫做Coded Frame,表示具体能够播放的音视频数据。它本身其实就是一些列的media data,并且这些media data里面必须包含pts,dts,sampleDuration的相关信息。在SB中有几个基本内部属性是用来标识前面两个字段的。

1、last decode timestamp: 用来表示最新一个frame的编码时间(pts),默认为null表示里面没有任何数据
2、last frame duration: 表示coded frame group里面最新的frame时长。
3、highest end timestamp: 相当于就是最后一个frame的pts + duration
4、need random access point flag: 这个就相当于是同步帧的意思。主要设置是根据音视频流里面具体字段决定的,和前端这边编码没关系。
5、track buffer ranges: 该字段表示的是coded frame group里面,每一帧对应存储的pts范围。

last frame duration即Coded Frame Duration的内容。Coded Frame Duration针对不同的track有两种不同的含义。一种是针对video/text的track,一种是针对audio的track

video/text: 其播放时长(duration)直接是根据pts直接的差值来决定,和具体播放的samplerate没啥关系。虽然官方也有一个计算refsampelDuration的公式：duration=timescale/fps,不过由于视频的帧率是动态变化的,没什么太大的作用。

audio: audio的播放时长必须是严格根据采样频率来的,即其播放时间必须和自己定制的timescale及sampleRate一致才行。对于AAC,因为其采样频率常为44100Hz,其固定播放时长则为：duration = 1024 / sampleRate * timescale

所以如果在针对unstable stream做同步的话,一定需要注意这个坑。有时dts不同步,有可能才是真正的同步。

如果界定track
一个SB里面是否拥有一个或多个track主要是根据里面的视频格式来决定的。比如你是在编码MP4的流文件,它里面的track内容则是根据moov box中的trak box来判断的,即如果你的MP4文件只包含一个,那么里面的track也有只有一个。

【 MediaSource.duration 】
获取和设置当前正在推流媒体的持续时间。

MS duration修正机制
MS的duration实际上是media中播放的时延。通常来说A/V track实际上是两个独立的播放流,这中间必定会存在先关的差异时间,但media播放机制永远会以最长的duration为准,这种情况对于live stream的播放特别适合,因为liveStream是不断动态添加buffer,但buffer内部会有一定的时长的,而MS就需要针对这个buffer进行动态更新。整个更新机制为：
1、当前MS.duration更新为new duration。
2、如果new duration比sourceBuffers中的最大的pts小的时候就会报错。
3、让最后一个的sample的end time为所后timeRanges的end time。
4、将new duration设置为当前SourceBuffer中最大的endTime。
5、将video/audio的播放时长(duration)设置为最新的new duration。

【 MediaSource.readyState 只读 】
返回一个包含当前MediaSource状态的集合

有三种可能的返回值：
closed: 当前源并未附着到一个media元素上,MSE实例未绑定到了媒体元素上,MS刚创建时就是该状态
open: 当前源已附着到一个media元素并准备好接收SourceBuffer对象,MSE实例已经绑定到了媒体元素上,等待接受数据或正在接受数据
ended: 当前源已附着到一个media元素,但流已被MediaSource.endOfStream()结束;MSE实例已经绑定到了媒体元素上,并且所有数据都已经接受到了,当endOfStream()执行完成会变为该状态

其对应MediaSource对象上三个监听事件：
1、sourceopen触发
当状态变为open时触发,通常只有当给video.src赋值之后MS和video元素成功绑定时才会正常触发
一般需要在给video.src赋值之后监听sourceopen事件,以确保MediaSource和HTMLMediaElement已经完成绑定,之后才开始进入数据处理流程。
sourceopen事件相当于是一个总领事件,只有当sourceopen事件触发后后续对于MS来说才是一个可操作的对象
let mediaSource = new MediaSource();
vidElement.src = URL.createObjectURL(mediaSource);

2、sourceended触发
当状态变为ended时触发,是在用户主动调用终止或视频数据解析、播放错误时被触发,所有数据接收完成后触发
sourceended的触发条件其实很简单,只有调用endOfStream的时候会进行相关的触发

3、sourceclose的触发
当状态变为closed时触发,是在SourceBuffer和MediaElement中无可用数据(一般是播放到视频末尾)时被触发
sourceclose是在media元素和MS断开的时候才会触发。那这个怎么断开呢？难道直接将media的元素的src直接设置为null就OK了吗？实际上并不,如果要手动触发sourceclose事件的话,则需要下列步骤：
将readyState设置为closed
将MS.duration设置为NaN
移除activeSourceBuffers上的所有Buffer
触发activeSourceBuffers的removesourcebuffer事件
移除sourceBuffers上的SourceBuffer。
触发sourceBuffers的removesourcebuffer事件
触发MediaSource的sourceclose事件

</pre>

<h4>MS实例方法 - 从父接口EventTarget上继承而来</h4><pre>
【 MediaSource.addSourceBuffer() 】
var mimeType = 'video/mp4; codecs="avc1.42E01E, mp4a.40.2"';
var sourceBuffer = mediaSource.addSourceBuffer(mimeType);
创建一个带有给定MIME类型的新的SourceBuffer并添加到MediaSource的SourceBuffers列表。返回一个具体的视频流SB,接受一个mimeType表示该流的编码格式

下面的错误可能会在调用该方法时被抛出。
InvalidAccessError	提交的mimeType是一个空字符串
InvalidStateError   MediaSource.readyState的值不等于open
NotSupportedError   当前浏览器不支持提交的mimeType,或it is not compatible with the mimeTypes specified for the SourceBuffer objects that already exist in MediaSource.sourceBuffers.
QuotaExceededError	The user agent can't handle any more SourceBuffer objects, or creating a SourceBuffer based on this mimeType would result in an unsupported SourceBuffer configuration.

【 MediaSource.removeSourceBuffer() 】
从MediaSource对象中的SourceBuffers列表删除指定的SourceBuffer,比如当前流已经结束就没必要再保留当前SB来占用空间,可直接移除
mediaSource.removeSourceBuffer(sourceBuffer);

【 MediaSource.endOfStream() 】
mediaSource.endOfStream(endOfStreamError);
表示流的结束,用来表示接受的视频流的停止,这里并不是断开,相当于只是下好了一部分视频,然后可以进行播放,此时MS的状态变为ended
endOfStreamError参数可选,一个DOMString,表示当流结束之时需要抛出的异常名,可选的值为network或decode

</pre><pre class="js">
var mediaSource = this;
var sourceBuffer = mediaSource.addSourceBuffer(mimeCodec);
req(assetURL, function (buf) {
  sourceBuffer.addEventListener('updateend', function (_) {
    mediaSource.endOfStream(); // 结束当前的接受
    video.play();              // 可以播放当前获得的流
  });
  sourceBuffer.appendBuffer(buf);
});

</pre><pre>
【 MediaSource.isTypeSupported()静态方法 】
返回一个Boolean值表明给定的MIME类型是否被当前的浏览器支持,这意味着是否可以成功的创建这个MIME类型的SourceBuffer对象。
判断是否支持要解码播放的视频文件编码和类型,主要是用来检测MS是否支持某个特定的编码和容器盒子

MediaSource.isTypeSupported('video/mp4;codecs="avc1.42E01E,mp4a.40.2"') //是否支持MP4
MediaSource.isTypeSupported('video/webm;codecs="vorbis,vp8"');          //是否支持webm
MediaSource.isTypeSupported('video/mp2t;codes="avc1.42E01E,mp4a.40.2"') //是否支持ts

设置编码类型mime字符串
var mime = 'video/mp4; codecs="avc1.42E01E, mp4a.40.2"'
video/mp4代表这是一段mp4格式封装的视频,同理video/webm、audio/mpeg、audio/mp4这样的mime格式,一般可通过canPlayType方法判断浏览器是否支持当前格式

codecs="avc1.42E01E, mp4a.40.2"以逗号相隔,分为两段：
第一段'avc1.42E01E'告诉浏览器关于视频编解码的一些重要信息,如编码方式、分辨率、帧率、码率及对解码器解码能力的要求。
'avc1'代表视频采用H.264编码,随后是一个分隔点,之后是3个两位的十六进制的数,这3个十六进制数分别代表：
AVCProfileIndication(42)
profile_compability(E0)
AVCLevelIndication(1E)
第一个用于标识H.264的profile,后两个用于标识视频对于解码器的要求
profile_compability、AVCLevelIndication只是浏览器用于判断自身的解码能力能否满足需求,所以不需要和视频完全对应,更高也是可以的

mp4视频可以使用mp4file这样的命令行工具：
mp4file --dump xxx.mp4
找到avcC Box后可以看到这三个值：
type avcC (moov.trak.mdia.minf.stbl.stsd.avc1.avcC) // avc1
configurationVersion = 1 (0x01)
AVCProfileIndication = 66 (0x42)    // 42
profile_compatibility = 224 (0xe0)  // E0
AVCLevelIndication = 30 (0x1e)      // 1E

第二段'mp4a.40.2'信息是关于音频部分的,代表视频的音频部分采用了AAC LC标准：'mp4a'代表此视频的音频部分采用MPEG-4压缩编码。
随后是一个分隔点和一个十六进制数(40),这是ObjectTypeIndication,40 对应的是Audio ISO/IEC 14496-3标准
然后又是一个分隔点和一个十进制数(2),这是MPEG-4 Audio Object Type,其实就是一种H.264视频中常用的音频编码规范

</pre>

<h4>SourceBuffer对象</h4><pre>
SourceBuffer是由mediaSource创建,并直接和HTMLMediaElement接触。它就是一个流的容器,里面提供的append(),remove()来进行流的操作,它可以包含一个或多个media segments

var sourceBuffer = mediaSource.addSourceBuffer(mimeCodec);

</pre><pre class="js">
interface SourceBuffer : EventTarget {
           attribute AppendMode          mode;
  readonly attribute boolean             updating;
  readonly attribute TimeRanges          buffered;
           attribute double              timestampOffset;
  readonly attribute AudioTrackList      audioTracks;
  readonly attribute VideoTrackList      videoTracks;
  readonly attribute TextTrackList       textTracks;
           attribute double              appendWindowStart;
           attribute unrestricted double appendWindowEnd;
           attribute EventHandler        onupdatestart;
           attribute EventHandler        onupdate;
           attribute EventHandler        onupdateend;
           attribute EventHandler        onerror;
           attribute EventHandler        onabort;
  void appendBuffer(BufferSource data);
  void abort();
  void remove(double start, unrestricted double end);
};

</pre><pre>
【 sourceBuffer.mode 】
SB(SourceBuffer)里面存储的是media segments,就是每次通过append添加进去的流片段

SB.mode有两种格式：
1、segments: 乱序排放,通过timestamps来标识其具体播放的顺序,比如：20s的buffer,30s的buffer等。
2、sequence: 按序排放,通过appendBuffer的顺序来决定每个mode添加的顺序,timestamps根据sequence自动产生。

那么上面两个哪个是默认值呢？看情况。当media segments天生自带timestamps,那么mode就为segments,否则为sequence。
所以一般情况下是不用管它的值。不过可以在后面将segments设置为sequence,反之将sequence设置为segments就有问题了

var bufferMode = sourceBuffer.mode;
if (bufferMode == 'segments') sourceBuffer.mode = 'sequence';

segments表示A/V的播放时根据视频播放流中的pts来决定,该模式也是最常使用的。因为音视频播放中最重要的就是pts的排序。因为pts可以决定播放的时长和顺序,如果一旦A/V的pts错开有可能就会造成A/V sync drift。

sequence则是根据空间上来进行播放的,每次通过appendBuffer来添加指定的Buffer时实际上就是添加一段A/V segment。此时播放器会根据其添加的位置来决定播放顺序。在播放的同时需要告诉SB,这段segment有多长,也就是该段Buffer的实际偏移量。而该段偏移量就是由timestampOffset决定的。整个过程用代码描述一下就是：
sb.appendBuffer(media.segment);
sb.timestampOffset += media.duration;

如果想手动更改mode也是可以的,不过需要注意几个先决条件：
1、对应的SB.updating必须为false
2、如果该parent MS处于ended状态则会手动将MS readyState变为open的状态

添加/移除buffer
在添加Buffer的时候需要了解所采用的mode是哪种类型,sequence或segments,这两种是完全两种不同的添加方式。

(1)segments
这种方式是直接根据MP4文件中的pts来决定播放的位置和顺序,它的添加方式极其简单,只需要判断updating === false,然后直接通过appendBuffer添加即可。

</pre><pre class="js">
if (!sb.updating) {
  let MS = this._mergeBuffer(media.tmpBuffer);
  sb.appendBuffer(MS);
  media.duration += lib.duration;
  media.tmpBuffer = [];
}

</pre><pre>
(2)sequence
如果采用这种方式添加Buffer进行播放也就没必要了解FMP4格式,而是了解MP4格式。因为该模式下SB是根据具体添加的位置来进行播放的,所以如果是FMP4的话有可能就有点不适合了。针对sequence来说,每段buffer都必须有自己本身的指定时长,每段buffer不需要参考的baseDts,即他们直接可以毫无关联。

sequence具体操作
在每一次添加过后都需要根据指定SB上的timestampOffset,该属性是用来控制具体Buffer的播放时长和位置的。

该方式比较容易用来直接控制buffer片段的添加,而不用过度关注相对baseDTS的值

</pre><pre class="js">
if (!sb.updating) {
  let MS = this._mergeBuffer(media.tmpBuffer);
  sb.appendBuffer(MS);
  sb.timestampOffset += lib.duration;
  media.tmpBuffer = [];
}

</pre><pre>
【 sourceBuffer.buffered 】
返回一个TimeRanges对象,用来表示当前被存储在SB中的buffer,描述了添加进去的所有媒体数据的range信息,为一个数组,里边标示了持续或间断的时间信息列表

</pre><pre class="js">
for(var i=0;i< buffered.length;i++){
  start=buffered.start(i)   //第i个range信息的开始时间
  end=buffered.end(i);      //第i个range信息的结束时间
}

</pre><pre>
如果播放的媒体数据是连续的,则只有一个开始时间点和一个结束时间点,所以如果要计算缓冲中还存在多少时间则可以通过该描述信息与当前播放时间点进行换算

</pre><pre class="js">
function play(){
  if(!this.mediaSource){
    this.mediaSource=new MediaSource();
    var me=this;
    this.mediaSource.addEventListener("sourceopen",function(){
      me.onMediaSourceOpen();
    });
    this.mediaSource.addEventListener("sourceended",function(){
      me.onMediaSourceEnded();
    });
    this.mediaSource.addEventListener('sourceclose',function(){
      me.onMediaSourceClose();
    });
    this.mediaSource.addEventListener("error",function(){
      me.onUpdataError();
    });
    this.video=this.createNewVideo();
    this.video.src=window.URL.createObjectURL(this.mediaSource);
    this.video.play();
  }
  if(!this.sourceBuffer){
    return ;
  }
  if(this.sourceBuffer.updating){
    return;//上一块数据还在添加中
  }
  try{
    this.sourceBuffer.appendBuffer(dataBytes);//添加数据
  }catch(err){}
}

function createNewVideo(){
  var newVideo=document.createElement("video");
  newVideo.id="player";
  newVideo.width=this.videoWidth;
  newVideo.height=this.videoHeight;
  return newVideo;
}

//事件侦听
onMediaSourceOpen:function(){
  //DOMString可以通过转码获得
  var typeNmae='video/mp4;codecs="avc1.42E01E,mp4a.40.2"';
  var issurpport=MediaSource.isTypeSupported(typeName);
  this.mediaSource.duration=this.totalDuration;//设置视频总时长
  this.sourceBuffer=this.mediaSource.addSourceBuffer(typeName);
}
onMediaSourceEnded:function(){
  console.log("source ended");
}
onMediaSourceClosed:function(){
  console.log("cource close");
}
}

</pre><pre>
【 sourceBuffer.updating 】
返回Boolean,表示当前SB是否正在被更新,如SourceBuffer.appendBuffer(), SourceBuffer.appendStream(), SourceBuffer.remove()调用时。
true：当前SB正在处理添加或移除的segment
false：当前SB处于空闲状态,当且仅当updating = false时才可以对SB进行额外的操作。

SB内部的buffer管理主要通过appendBuffer(BufferSource data)和remote()两个方法来实现的。当然并不是所有的Buffer都能随便添加给指定的SB,这里面是需要条件和相关顺序的。

该buffer必须满足MIME限定的类型
该buffer必须包含initialization segments(IS)和media segments(MS)

MSE只支持fmp4的格式,IS和MS实际上就是FMP4中不同盒子的集合而已

【 控制播放片段 sb.appendWindowStart和sb.appendWindowEnd 】
如果要在video标签中控制指定片段的播放一般是不可能的,因为在加载整个视频buffer的时候视频长度就已经固定的,剩下的只是如果在video标签中控制播放速度和音量大小。而在MSE中如何在已获得整个视频流Buffer的前提下完成底层视频Buffer的切割和指定时间段播放呢？
这里需要利用SB下的appendWindowStart和appendWindowEnd这两个属性。

他们两个属性主要是为了设置,当有视频Buffer添加时只有符合在[start,end]之间的media frame才能append,否则无法append,例如：
sourceBuffer.appendWindowStart = 2.0;
sourceBuffer.appendWindowEnd = 5.0;
设置添加Buffer的时间戳为[2s,5s]之间。appendWindowStart和appendWindowEnd的基准单位为s。该属性值通常在添加Buffer之前设置

</pre><pre>
【 sourceBuffer.appendBuffer(ArrayBuffer) 】
用于持续数据的添加播放,可动态地向MediaSource中添加视频/音频片段,用来添加ArrayBuffer,该ArrayBuffer一般是通过fetch的response.arrayBuffer();来获取的。在使用addSourceBuffer创建之前还需要保证当前浏览器是否支持该编码格式。当然不支持也行,顶多是当前MS报错,断掉当前JS线程

对于一个MediaSource可以同时存在多个SourceBuffer
sourceBuffer.appendBuffer(Uint8array);  //媒体二进制数据

如果视频很长,存在多个chunk的话,就需要不停地向SourceBuffer中加入新的chunk,但appendBuffer是异步执行的,在完成前不能append新的chunk

sourceBuffer.appendBuffer(buffer1)
sourceBuffer.appendBuffer(buffer2)
// Uncaught DOMException:
Failed to set the 'timestampOffset' property on 'SourceBuffer':
This SourceBuffer is still processing
an 'appendBuffer' or 'remove' operation.

</pre>而是应该监听SourceBuffer上的updateend事件,确定空闲后再加入新的chunk：<pre class="js">
sourceBuffer.addEventListener('updateend', () => {
  sourceBuffer.timestampOffset = 20;  // 这个时候才能加入新chunk,先设定新chunk加入的位置,比如第20秒处
  sourceBuffer.append(newBuffer);     // 然后加入
}

</pre><pre>
【 SB内存释放 remove()和abort() 】
SB内存释放其实就和在JS中将一个变量指向null一样的过程。

var a = new ArrayBuffer(1024 * 1000);
a = null; // start garbage collection

在SB中就是移除指定的time ranges’ buffer,需要用到的API为：
remove(double start, unrestricted double end);

具体的步骤为：
找到具体需要移除的segment。
得到其开始(start)的时间戳(以s为单位)
得到其结束(end)的时间戳(以s为单位)
此时updating为true,表明正在移除
完成之后触发updateend事件

如果想直接清空Buffer重新添加的话,可以直接利用abort() API来做,它的工作是清空当前SB中所有的segment,使用方法也很简单,不过需要注意不要和remove操作一起执行,更保险的做法就是直接通过updating===false来完成：
if(sb.updating===false) sb.abort();

这时abort的主要流程为：
确保MS.readyState==="open"
将appendWindowStart设置为pts原始值比如0
将appendWindowEnd设置为正无限大即Infinity。

abort(): 用来放弃当前append流的操作,不过该方法的业务场景也比较有限,只能用在当SB正在更新流的时候,即此时通过fetch已经接受到新流,并且使用 appendBuffer添加,此为开始的时间。然后到updateend事件触发之前,这段时间之内调用abort()。
有一个业务场景是当用户移动进度条,而此时fetch已经获取前一次的media segments,那么可以使用abort放弃该操作,转而请求新的media segments

【 sourceBuffer事件 】
在SB中相关事件触发包括：
updatestart： 当updating由false变为true。
update：当append()/remove()方法被成功调用完成时,updating由true变为false。
updateend: append()/remove()已经结束
error: 在append()过程中发生错误,updating由true变为false。
abort: 当append()/remove()过程中使用abort()方法废弃时会触发,此时updating由true变为false。

update和updateend两个事件比较类似,都是表示处理的结束,不同的是update比updateend先触发

</pre><pre class="js">
sourceBuffer.addEventListener('updateend', function (e) {
  mediaSource.endOfStream();   // 当指定的buffer加载完后就可以开始播放
  video.play();
});

</pre><pre>
错误：Failed to execute 'endOfStream' on 'MediaSource': The MediaSource's readyState is not 'open'.
原因：使用的MP4视频并不是fragmented的或mimeCodec错误
解决：使用Bento4工具将普通MP4转为framented mp4

下载Bento4
解压缩
打开bin目录
在bin目录上开启powershell或cmd
运行命令：.\mp4fragment.exe .\v0.mp4 v0_new.mp4
运行命令：.\mp4info.exe v0_new.mp4 | findstr Codec

对于普通MP4文件,整个mp4文件的的meta数据都在文件头,所有媒体数据为整体一块。当文件比较大时meta数据就比较大。这样对mp4文件的本地播放是没有问题。但对于一些视频播放网站而言,用户的播放器必须下载全meta数据才能开始播放,这就意味着用户的缓冲时间将因为mp4文件的存储结构而延长。目前一种解决方法是将大的mp4文件切成物理分离的多段,使得每段的meta都比较小,从而在一定程度上减少缓冲时间。
对于fragment mp4,mp4文件被分成多个frag分片,而原来的meta数据大大变小,且每个frag都可以单独索引、传输和播放,这样就可以解决mp4不能流式传输播放的问题,对用户体验比较好。然而目前这种格式并不被多数解码器完整支持,部分播放器加载文件时间过长,而且浏览器内嵌播放器也可能不支持播放

在DASH(自适应流媒体传输)中推荐使用的是fragmented Mp4(fMp4)格式
在fMp4格式中包含一系列的segments(moof+mdat的组合),这些segments可以被独立的request(利用byte-range request),这有利于在不同质量级别的码流之间做码率切换操作

</pre>demo<pre class="js">
var video = document.querySelector('video');

var assetURL = 'web/media/oceans_frag.mp4';
// Need to be specific for Blink regarding codecs,Bento4工具 ./mp4info frag_bunny.mp4 | grep Codec
// 设置编码类型mime字符串
var mimeCodec = 'video/mp4; codecs="avc1.42C01E, mp4a.40.2"';

if ('MediaSource' in window && MediaSource.isTypeSupported(mimeCodec)) {
  var mediaSource = new MediaSource();                   // 创建变量名为mediaSource的MediaSource对象
  console.log(mediaSource.readyState);                   // closed
  video.src = URL.createObjectURL(mediaSource);          // 将DOM::Video对象的属性src和mediaSource进行连接
  // 通过注册事件Event::sourceopen来触发当上述连接结束之后的回调处理,回调处理就是需要赋值视频数据的地方
  mediaSource.addEventListener('sourceopen', sourceOpen);
} else {
  console.error('Unsupported MIME type or codec: ', mimeCodec);
}

function sourceOpen () {
  // MediaSource的实例通过URL.createObjectURL()创建的url并不会同步连接到video.src,即URL.createObjectURL()只是底层流(MS)和video.src的连接中间者,一旦两者连接到一起之后该对象就没用了。那么什么时候MS才会和video.src连接到一起呢？创建实例都是同步的,但是底层流和video.src的连接是异步的。MS提供了一个sourceopen事件进行这项异步处理。一旦连接到一起之后该URL object就没用了,处于内存节省的目的,可以使用URL.revokeObjectURL(vidElement.src)销毁指定的URL object
  URL.revokeObjectURL(video.src);
  var mediaSource = this;           // e.target
  // 调用MediaSource::addSourceBuffer方法来构建一个存放视屏数据的Buffer
  var sourceBuffer = mediaSource.addSourceBuffer(mimeCodec);

  req(assetURL, function (buf) {
    // 往Buffer存数据结束之后会触发事件Event::updateend,通过注册这个事件的回调可知晓数据已经加载完毕,然后调用Video::play函数通知浏览器播放视频
    sourceBuffer.addEventListener('updateend', function () {
      mediaSource.endOfStream();
      video.play();
      console.log(mediaSource.readyState); // ended
    });
    sourceBuffer.appendBuffer(buf);        // buf is the arraybuffer to store the video data
  });
};

function req (url, cb) {
  var xhr = new XMLHttpRequest;
  xhr.open('GET', url);
  xhr.responseType = 'arraybuffer';
  xhr.onload = function () {
    if((xhr.status >= 200 && xhr.status < 300) || xhr.status == 304) cb(xhr.response);
  };
  xhr.send();
};

</pre>通过MediaSource分段播放: fileReader读取文件后用slice()将文件切片,然后将每个segment逐一传输到对等接收端<pre class="js">
< video controls id='video' height="200">< /video>
< input type='file' id='file'/>

let file = null;
let video = document.getElementById('video');
let mimeCodec = 'video/mp4; codecs="avc1.42E01E, mp4a.40.2"';
let i = 0;
document.getElementById('file').onchange = function(){
  file = this.files[0];
  //一个视频分成3段 首先这个视频要大于30*1024*1024,结尾是file.size
  let blob = file.slice(0,10*1024*1024);
  let blob2 = file.slice(10*1024*1024,20*1024*1024);
  let blob3 = file.slice(20*1024*1024);
  let mediaSource = new MediaSource();                    //创建MediaSource
  video.src = URL.createObjectURL(mediaSource);           //video.src 通过 URL.createObjectURL 链接 mediaSource
  mediaSource.addEventListener('sourceopen', sourceOpen); //mediaSource设置监听打开链接

  function sourceOpen(){
    let mediaSource = this;
    let sourceBuffer = mediaSource.addSourceBuffer(mimeCodec);  //创建sourceBuffer
    sourceBuffer.addEventListener('updateend', function (_) {   //sourceBuffer监听数据更新updateend
        //分了三段 so 0 1 2 ,当i==2时表示3段已经全部加入sourceBuffer
        if(i==2){
          mediaSource.endOfStream();
          URL.revokeObjectURL(video.src);
        }else{
          //回调中读取字节流触发updateend
          let cb = function (buf) {
            console.log(sourceBuffer.appendBuffer);
            sourceBuffer.appendBuffer(buf);
          }
          if(i==0) req(blob2, cb);       //i==0 表示第一段加载完毕,开始加载第二段
          else if(i==1) req(blob3, cb);  //i==0 表示第二段加载完毕,开始加载第三段
        }
        //第一段加载完毕就开始播放
        if(i==0) video.play();
        i++;
      });

    //调用读取数据的方法,在回调中加入字节流,触发updateend
    req(blob, function (buf) {
      console.log(sourceBuffer.appendBuffer);
      sourceBuffer.appendBuffer(buf);
    });

  }
  function req (file, cb) {
    let reader = new FileReader();
    reader.onload = function(e){
      console.log(e.target.result);
      cb(e.target.result);
    }
    reader.readAsArrayBuffer(file);

  }
}

</pre><pre>
数据处理的过程主要是围绕着SourceBuffer对象展开的。
首先媒体服务器把一个比较长的mp4视频文件拆分成video(只包含图像不含声音)和audio(只包含声音不含图像)两个独立的文件,然后分别把两个文件分片,切成一段一段彼此大小相差不多的二进制数据片段(一般后缀名为.ts)。
JS创建两个SourceBuffer对象,并输入对应的MimeType类型'video/mp4'、'audio/mp4',一个SourceBuffer对象只能接受一种格式的数据,所以这里需要为视频和音频数据分别创建一个SourceBuffer。然后创建XMLHTTPRequest,以一定的顺序序列从媒体服务器上请求video和audio的资源片段,将其append到对应的SourceBuffer中。

</pre><pre class="js">
var video = document.querySelector('video');
var videoCodec = 'video/mp4; codecs="avc1.42E01E"';
var audioCodec = 'audio/mp4; codecs="mp4a.40.2"';

var mediaSource = new MediaSource();
video.src = URL.createObjectURL(mediaSource);

mediaSource.addEventListener('sourceopen', sourceOpen);

function sourceOpen(){
    var mediaSource = this;
    var videoBuffer = mediaSource.addSourceBuffer(videoCodec);
    var audioBuffer = mediaSource.addSourceBuffer(audioCodec);

    // buffer数据处理(append、remove等)完成时会触发updateend事件,这里省略对audioBuffer的updateended事件等待
    videoBuffer.addEventListener('updateend', function(){
      mediaSource.endOfStream();
      video.play();
    });

    // 这里省略网络数据请求的过程,且假设音视频都只有一个片段文件。
    videoBuffer.appendBuffer(vbuf);
    audioBuffer.appendBuffer(abuf);
}

</pre><pre>
此处省略了两个部分,一是多个SourceBuffer的updateend事件的等待,需要使用Promise来进行异步处理;二是网络数据请求及把数据输入到SourceBuffer的过程。 对于网络请求重点需要关注的内容是请求的序列化。当前大多数网站使用的是清单文件的方式,里面包含一段视频的所有相关信息,包括总时长、音视频编码、加密方式、片段文件URI,最重要的是音视频的分片时间戳及对应的片段文件名(常见的有.xml、.mpd、.menifest等格式清单)。JS加载该文件并解析得到所有音视频文件路径后就可以批量下载数据了。下载完成的数据片段(单以video数据为例),可以不分先后顺序,调用appendBuffer方法输入到SourceBuffer里,浏览器内部会根据数据中的时间戳来进行排序。但此处不推荐这样做,因为这样会浪费一些内存空间

【 服务器音视频分片 】
熟悉代码的过程中需要服务器支持。媒体片段资源的生成及加密可以使用shaka-packager或bento4工具。以下是bento4工具命令的一个简单例子：
mp4split.exe h265fragment.mp4 --video --media-segment segment-%llu.m4s --pattern-parameters N
mp4split.exe h265fragment.mp4 --audio --media-segment segment-%llu.m4s --pattern-parameters N

这两条命令会把video和audio数据切分成片段,并以segment-0.m4s、segment-1.m4s...序列生成文件名。bento4是一个工具集,要切分视频不止这一种命令,详情需参阅官方文档。
不管服务器应用类型是iis、apache、nginx等其中哪一种,需要注意音视频切片文件后缀名需要有相应的MimeType类型与其对应,以免出现客户端下载出现错误404的情况。

【 直播 】
直播整体流程大致可分为：
1、视频采集端：可以是电脑上的音视频输入设备、或手机端的摄像头或麦克风,目前以移动端手机视频为主。
2、直播流视频服务端：一台Nginx服务器,采集视频录制端传输的视频流(H264/ACC编码),由服务器端进行解析编码,推送RTMP/HLS格式视频流至视频播放端。
3、视频播放端：可以是电脑上的播放器(QuickTime Player、VLC),手机端的native播放器,还有就是H5的video标签等,目前还是以手机端的native播放器为主

【 HLS 】
HLS(HTTP Live Streaming)是由Apple公司实现的基于HTTP的媒体流传输协议。Apple的全系列产品支持,由于HLS是苹果提出的,所以在Apple的全系列产品包括iphone、 ipad、safari都不需要安装任何插件就可以原生支持播放HLS,现在Android也加入了对HLS的支持。但PC端目前除了Microsoft Edge外,Chrome、Firefox等浏览器均不支持该协议的播放。可直接采用网上一些比较成熟的方案,如sewise-player、MediaElement、videojs-contrib-hls、jwplayer

</pre>对于支持HLS的浏览器来说,直接这样写就能播放了<pre class="html">
< video controls autoplay>
    < source src="http://live.hkstv.hk.lxdns.com/live/hks/playlist.m3u8" type="application/vnd.apple.mpegurl" />
    <p class="warning">Your browser does not support HTML5 video.</p>
</ video>

</pre><pre>
HLS的基本原理就是当采集推流端将视频流推送到流媒体服务器时,服务器将收到的流信息每缓存一段时间就封包成一个新的ts文件,同时服务器会建立一个m3u8的索引文件来维护最新几个ts片段的索引。当播放端获取直播时,它是从m3u8索引文件获取最新的ts视频文件片段来播放,从而保证用户在任何时候连接进来时都会看到较新的内容,实现近似直播的体验。

相对于常见的流媒体直播协议,例如RTMP协议、RTSP协议等,HLS最大的不同在于直播客户端获取到的并不是一个完整的数据流,而是连续的、短时长的媒体文件,客户端不断的下载并播放这些小文件。这种方式的理论最小延时为一个ts文件的时长,一般情况为2-3个ts文件的时长。HLS的分段策略,基本上推荐是10秒一个分片,这就看出了HLS的缺点：

1、通常HLS直播延时会达到20-30s,而高延时对于需要实时互动体验的直播来说是不可接受的。
2、HLS基于短连接HTTP,HTTP是基于TCP的,这就意味着HLS需要不断地与服务器建立连接,TCP每次建立连接时的三次握手、慢启动过程、断开连接时的四次挥手都会产生消耗。

不过HLS也有它的优点：
1、数据通过HTTP协议传输,所以采用HLS时不用考虑防火墙或者代理的问题。
2、使用短时长的分片文件来播放,客户端可以平滑的切换码率,以适应不同带宽条件下的播放。
3、HLS是苹果推出的流媒体协议,在iOS平台上可以获得天然的支持,采用系统提供的AVPlayer就能直接播放,不用自己开发播放器。
4、HLS有一个非常大的优点：HTML5可以直接打开播放;这个意味着可以把一个直播链接通过微信等转发分享,不需要安装任何独立的APP,有浏览器即可,所以流行度很高。社交直播APP,HLS可以说是刚需

HLS其实是一个"文本协议",而并不是一个流媒体协议。那么,什么样的协议才能称之为流媒体协议呢？
流(stream)： 数据在网络上按时间先后次序传输和播放的连续音/视频数据流。之所以可以按照顺序传输和播放连续是因为在类似RTMP,FLV协议中, 每一个音视频数据都被封装成了包含时间戳信息头的数据包。而当播放器拿到这些数据包解包的时候能够根据时间戳信息把这些音视频数据和之前到达的音视频数据连续起来播放。MP4,MKV等等类似这种封装,必须拿到完整的音视频文件才能播放,因为里面的单个音视频数据块不带有时间戳信息,播放器不能将这些没有时间戳信息数据块连续起来,所以就不能实时的解码播放。

【 MPEG DASH(Dynamic Adaptive Streaming over HTTP) 】
在基于HTTP提供流媒体的方面,到目前为止已经看到了三种方案,苹果的HLS,Adobe HTTP Dynamic Streaming (HDS)和Microsoft Smooth Streaming (MSS),各家用的协议格式都不会一样。于是每次做支持都要来三份的,于是就有了MPEG DASH作为标准

B站在2018.8.2发布的我们为什么使用DASH中提到以后点播会使用DASH方案,直播因为延迟问题仍然使用FLV

DASH又叫MPEG DASH,DASH：Dynamic Adaptive Streaming over HTTP ,是一种在互联网上传送动态码率的Video Streaming技术,类似于苹果的HLS,DASH会通过media presentation description (MPD)将视频内容切片成一个很短的文件片段,每个切片都有多个不同的码率,DASH Client可以根据网络的情况选择一个码率进行播放,支持在不同码率之间无缝切换。YouTube采用DASH,其网页端及移动端APP都使用了DASH。DASH的其他采用者包括：Netflix, Hulu。

DASH是由MPEG (Moving Picture Experts Group)组织制定,2010年开始启动,2011年11月发布Draft版本,2012年4月发布第一稿Version(ISO/IEC 23009-1:2012),2014年5月发布第二稿(ISO/IEC 23009-1:2014),最新稿(ISO/IEC 23009-3:2015)。
目前3GPP Release 10已经将DASH纳入其中;在HbbTV 1.5中也支持DASH;DVB-DASH也将DASH纳入到DVB。目前DASH Industry Forum由发起厂家组成,致力于推进DASH产品生态,将DASH产业化和业界最佳实践推向批量应用。

15年的B站我们使用整段的FLV和MP4,这种方案的好处是简单且兼容性高,抖音与今日头条就是用该方案。但缺点也很明显,随着视频时长的增长,整段的MP4的头部过于复杂,体积过于庞大,导致拉取与加载极为缓慢。

16年的B站为了规避这个问题,使用了分段的FLV来提升加载速度,这种方案的好处是视频头部小,加载速度高。爱奇艺和优酷也使用类似方案。这种方案简单且兼容性高,而且与直播流统一了格式,所以一直沿用至今,中间由于flv.js的出现 ,把这种方案带向了全平台。

但随着用户的增加,用户的网络种类和情况也变得更加复杂,如果需要在各种场景下都需要给用户较好的体验,需要选择一种能在不同网络下都能流畅播放的方案。需要引入Dynamic Adaptive Streaming/ Bitrate技术,以进一步提升用户体验。也需要对多音轨和多视频轨
在评估了一些行业内使用的方案后,选中了DASH,DASH也可以更灵活的实现用户与产品的新增需求。

【 MSE媒体源扩展 】
MSE(Media Source Extensions)是目前Youtube使用的DASH的基础

图片可以是blob,视频可以是blob,直播也可以是blob

原视频文件通过编码来压缩文件大小,再通过封装将压缩视音频、字幕组合到一个容器内,可以把video标签看做拥有解封装和解码功能的浏览器自带播放器,随着视频点播、直播等视频业务的发展,视频通过流媒体传输协议(目前常用的有两种:MPEG-DASH和Apple的HLS)从服务器端分发给客户端,媒体内容进一步包含在一层传输协议中,这样video就无法识别了。以HLS为例,将源文件内容分散地封装到了一个个TS文件中。
仅靠video标签无法识别这样的TS文件,那么就引入了MSE拓展来帮助浏览器识别并处理TS文件,将其变回原来可识别的媒体容器格式,这样video就可以识别并播放原来的文件了。那么支持HTML5的浏览器就相当于内置了一个能够解析流协议的播放器。

hls实际会先通过ajax(loader是可以完成自定义的)请求m3u8文件,然后会读取到文件的分片列表以及视频的编码格式、时长等,随后会按照顺序(非seek)去对分片进行请求,这些也是通过ajax请求二进制的文件,然后借助Media Source Extensions将buffer内容进行合流,然后组成一个可播的媒体资源文件

</pre>Media Source Extensions Demo<pre class="js">
< video id="v" controls preload="auto" style="max-width: 100%;">< /video>

var audioFragments = [
  "media/audio/init.mp4",
  "media/audio/seg-1.mp4",
  "media/audio/seg-2.mp4",
  "media/audio/seg-3.mp4",
  "media/audio/seg-4.mp4",
  "media/audio/seg-5.mp4",
  "media/audio/seg-6.mp4",
  "media/audio/seg-7.mp4",
];
var videoFragments = [
  "media/video/init.mp4",
  "media/video/seg-1.mp4",
  "media/video/seg-2.mp4",
  "media/video/seg-3.mp4",
  "media/video/seg-4.mp4",
  "media/video/seg-5.mp4",
  "media/video/seg-6.mp4",
  "media/video/seg-7.mp4",
];

function MSELoadTrack(fragments, type, mediaSource, name) {
  return new Promise((resolve, reject) => {
    var sourceBuffer;
    var curFragment = 0;

    function addNextFragment() {
      if (mediaSource.readyState == "closed") return;
      if (curFragment >= fragments.length) return resolve();

      var req = new XMLHttpRequest();
      req.open("GET", fragments[curFragment++]);
      req.responseType = "arraybuffer";
      req.addEventListener("load", function() {
        sourceBuffer.appendBuffer(new Uint8Array(req.response));
      });
      req.addEventListener("error", function(){reject();});
      req.addEventListener("abort", function(){reject();});
      req.send(null);
    }

    sourceBuffer = mediaSource.addSourceBuffer(type);
    sourceBuffer.addEventListener("updateend", addNextFragment);
    addNextFragment();
  });
}

function Load() {
  var video = document.querySelector("vedio");
  const audioContentType = 'audio/mp4; codecs="mp4a.40.2"';   // AAC-LC
  const videoContentType = 'video/mp4; codecs="avc1.64001F"'; // High profile level 3.1
  var ms = new MediaSource();
  video.src = URL.createObjectURL(ms);

  var SourceOpen = function () {
    ms.removeEventListener("sourceopen", SourceOpen);
    Promise.all([
      MSELoadTrack(videoFragments, videoContentType, ms, "video"),
      MSELoadTrack(audioFragments, audioContentType, ms, "audio")
    ]).then(function(){
      ms.endOfStream();
    });
  }

  ms.addEventListener("sourceopen", SourceOpen);
  video.addEventListener("canplay", () => {
    video.play();
  });
}
Load();

</pre><pre>
【 Encypted Media Extensions(EME) 】
EME是HTMLMediaElement对象的一套用于播放加密音视频的扩展API。相关的数据类型主要有Navigator、MediaKeys、MediaKeySystemAccess、MediaKeySession等。目前主流的媒体内容加密标准可以在MPEG-DASH网站查阅,这里只介绍较为常用的clearkey、widevine和playready。

整个播放过程可以分为以下几个部分：
1、服务器媒体资源加密、分片,加密时生成对应的kid和key值
2、客户端走MSE流程,请求加密内容,并将数据传输给HTMLMediaElement进行播放
3、HTMLMediaElement解析处理数据的过程中,发现数据header中"IsEncrypted"字段为1(假设的字段名),向JS抛出encrypted事件
4、JS调用EME相关API同CDM(Content Decryption Module)底层交互,并发起网络请求,从License服务器获取相应的密钥,传递给CDM
5、CDM拿到密钥对数据进行解密,然后转交给HTMLMediaElement底层继续播放

clearkey加密内容的安全级别较低,一般可以把kid、key值明文写在js代码中。而playready和widevine配合硬件设施,安全级别很高,key值只能通过底层CDM协助,播放时从License服务器获取,且无法被复用。kid是媒体内容加密时所用密钥的唯一标识,通过它可以从License服务器获取与其对应的key(加解密密钥)。在内容加密的过程中,它被写在文件片段的header中,与"IsEncrypted"字段一起作为文件头信息的一部分,在客户端解析媒体数据时它会被取出。

clearkey、widevine、playready加密视频数据的生成,同样也可以使用bento4、shaka-packager工具

</pre>clearkey加密视频<pre class="js">
<video id="v" controls preload="auto" style="max-width: 100%;"></video>

// "keyid" : "key"
var keys = {
  "2fef8ad812df429783e9bf6e5e493e53": "7f412f0575f44f718259beef56ec7771",
  "7eaa636ee7d142fd945d1f764877d8db": "624db3d757bb496fb93e51f341d11716",
};

var audioFragments = [
  "media/audio/init.mp4",
  "media/audio/seg-1.mp4",
  "media/audio/seg-2.mp4",
  "media/audio/seg-3.mp4",
  "media/audio/seg-4.mp4",
  "media/audio/seg-5.mp4",
  "media/audio/seg-6.mp4",
  "media/audio/seg-7.mp4",
];
var videoFragments = [
  "media/video/init.mp4",
  "media/video/seg-1.mp4",
  "media/video/seg-2.mp4",
  "media/video/seg-3.mp4",
  "media/video/seg-4.mp4",
  "media/video/seg-5.mp4",
  "media/video/seg-6.mp4",
  "media/video/seg-7.mp4",
];

// mediasource extension
function MSELoadTrack(fragments, type, mediaSource, name) {
  return new Promise(function (resolve, reject) {
    var sourceBuffer;
    var curFragment = 0;

    function addNextFragment() {
      if (mediaSource.readyState == "closed") return;
      if (curFragment >= fragments.length) return resolve();

      var req = new XMLHttpRequest();
      req.open("GET", fragments[curFragment++]);
      req.responseType = "arraybuffer";
      req.addEventListener("load", function () {
          sourceBuffer.appendBuffer(new Uint8Array(req.response));
      });
      req.addEventListener("error", function () { reject(); });
      req.addEventListener("abort", function () { reject(); });
      req.send(null);
    }
    sourceBuffer = mediaSource.addSourceBuffer(type);
    sourceBuffer.addEventListener("updateend", addNextFragment);
    addNextFragment();
  });
}

// encrypted media extension
function bail(message) {
  return function (err) {
    console.error(message + (err ? " " + err : ""));
  }
}

function ArrayBufferToString(arr) {
  var str = '';
  var view = new Uint8Array(arr);
  for (var i = 0; i < view.length; i++) {
    str += String.fromCharCode(view[i]);
  }
  return str;
}

function StringToArrayBuffer(str) {
  var arr = new ArrayBuffer(str.length);
  var view = new Uint8Array(arr);
  for (var i = 0; i < str.length; i++) {
    view[i] = str.charCodeAt(i);
  }
  return arr;
}

function Base64ToHex(str) {
  var bin = window.atob(str.replace(/-/g, "+").replace(/_/g, "/"));
  var res = "";
  for (var i = 0; i < bin.length; i++) {
    res += ("0" + bin.charCodeAt(i).toString(16)).substr(-2);
  }
  return res;
}

function HexToBase64(hex) {
  var bin = "";
  for (var i = 0; i < hex.length; i += 2) {
    bin += String.fromCharCode(parseInt(hex.substr(i, 2), 16));
  }
  return window.btoa(bin).replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
}

// clearkey的kid、key是写在代码里的,没有向服务器发起请求
function UpdateSessionFunc(name, keys) {
  return function (ev) {
    var msgStr = ArrayBufferToString(ev.message);
    var msg = JSON.parse(msgStr);
    var outKeys = [];

    for (var i = 0; i < msg.kids.length; i++) {
      var id64 = msg.kids[i];
      var idHex = Base64ToHex(msg.kids[i]).toLowerCase();
      var key = keys[idHex];

      if (key) {
        outKeys.push({ "kty": "oct", "alg": "A128KW", "kid": id64, "k": HexToBase64(key) });
      } else {
        bail(name + " couldn't find key for key id " + idHex);
      }
    }

    var update = JSON.stringify({ "keys": outKeys, "type": msg.type });

    // 调用session的update方法,传入license数据(包含key),license数据格式与initdatatype相关
    ev.target.update(StringToArrayBuffer(update)).then(function () {
      console.log(name + " MediaKeySession update ok!");
    }, bail(name + " MediaKeySession update failed"));
  }
}

function KeysChange(event) {
  var session = event.target;
  console.log("keystatuseschange event on session" + session.sessionId);
  var map = session.keyStatuses;
  for (var entry of map.entries()) {
    var keyId = entry[0];
    var status = entry[1];
    var base64KeyId = Base64ToHex(window.btoa(ArrayBufferToString(keyId)));
    console.log("SessionId=" + session.sessionId + " keyId=" + base64KeyId + " status=" + status);
  }
}

var ensurePromise;

function EnsureMediaKeysCreated(video, keySystem, options, encryptedEvent) {
  // We may already have a MediaKeys object if we initialized EME for a different MSE SourceBuffer's "encrypted" event, or the initialization may still be in progress.
  if (ensurePromise) {
    return ensurePromise;
  }

  /*
  *  通过navigator.requestMediaKeySystemAccess获取mediaKeySystemAccess
  *  通过mediaKeySystemAccess.createMediaKeys获取mediaKeys
  *  设置mediaKeys和HTMLMediaElement对象绑定
  */
  ensurePromise = navigator.requestMediaKeySystemAccess(keySystem, options)
      .then(function (keySystemAccess) {
          return keySystemAccess.createMediaKeys();
      }, bail(name + " Failed to request key system access."))
  .then(function (mediaKeys) {
      return video.setMediaKeys(mediaKeys);
  }, bail(name + " failed to create MediaKeys object"))

  return ensurePromise;
}

function SetupEME(video, keySystem, name, keys, options) {
  video.sessions = [];

  // 监听到video的encrypted事件后,开始同底层CDM交互并获取密钥
  video.addEventListener("encrypted", function (ev) {
      EnsureMediaKeysCreated(video, keySystem, options, ev)
        .then(function () {
          /*
          * 通过video.mediaKeys.createSession获取一个MediaKeySession session对象
          * 调用session.generateRequest通知底层CDM发起一条获取key的请求,传入参数来自于音视频片段文件头,其中包含kid
          * 监听CDM发送的message通知(message消息通知中返回的参数用来js向License服务器请求key信息)
          * 监听CDM发送的keystatuseschange通知
          */
          var session = video.mediaKeys.createSession();
          video.sessions.push(session);
          session.addEventListener("message", UpdateSessionFunc(name, keys));
          session.addEventListener("keystatuseschange", KeysChange);
          return session.generateRequest(ev.initDataType, ev.initData);
        }, bail(name + " failed to ensure MediaKeys on HTMLMediaElement"))

      .then(function () {
        console.log(name + " generated request");
      }, bail(name + " Failed to generate request."));
  });
}

function Load() {
  const KEYSYSTEM_TYPE = "org.w3.clearkey";   //com.widevine.alpha, com.micorsoft.playready
  var video = document.getElementById("v");

  var options = [];
  const audioContentType = 'audio/mp4; codecs="mp4a.40.2"';   // AAC-LC
  const videoContentType = 'video/mp4; codecs="avc1.64001F"'; // High profile level 3.1

  if (typeof (MediaKeySystemAccess.prototype.getConfiguration) == "undefined") {
    console.log("Detected obsolete navigator.requestMediaKeySystem options style.");
    options = [{
      initDataType: "cenc",
      videoType: videoContentType,
      audioType: audioContentType,
    }];
  } else {
    options = [{
      initDataTypes: ["cenc"],            // initDataType主要有三个值, cenc, kids, webm
      videoCapabilities: [{ contentType: videoContentType }],
      audioCapabilities: [{ contentType: audioContentType }],
    }];
  }

  SetupEME(video, KEYSYSTEM_TYPE, "video", keys, options);

  var ms = new MediaSource();
  video.src = URL.createObjectURL(ms);

  var SourceOpen = function () {
    ms.removeEventListener("sourceopen", SourceOpen);
    Promise.all([MSELoadTrack(videoFragments, videoContentType, ms, "video"), MSELoadTrack(audioFragments, audioContentType, ms, "audio")]).then(function () {
      ms.endOfStream();
    });
  }

  ms.addEventListener("sourceopen", SourceOpen);
  video.addEventListener("canplay", function () {
    video.play();
  });
}

Load();

</pre>

<h3>embed标签和object元素</h3><pre>
embed和object元素的功能不同于iframe,这些元素是用来嵌入多种类型的外部内容的通用嵌入工具,其中包括像Java小程序和Flash,PDF(可在浏览器中显示为一个PDF插件)这样的插件技术,甚至像视频,SVG和图像的内容！

插件是一种对浏览器原生无法读取的内容提供访问权限的软件。

然而不太可能使用这些元素,Applet几年来一直没有被使用;由于许多原因,Flash不再受欢迎;PDF更倾向于被链接而不是被嵌入;其他内容如图像和视频都有更优秀、更容易元素来处理。插件和这些嵌入方法真的是一种传统技术,提及它们主要是为了以防您在某些情况下遇到问题,比如内部网或企业项目等。

如果发现自己需要嵌入插件内容,那么至少需要一些这样的信息：
                                            embed                       object
嵌入内容的网址	                              src                         data
嵌入内容的准确媒体类型	                      type	                      type
由插件控制的框的高度和宽度(以CSS像素为单位) 	height/width	              height/width
名称和值,将插件作为参数提供	                  具有这些名称和值的ad hoc属性	单标签param元素,包含在内object
独立的HTML内容作为不可用资源的回退	            不支持(noembed已过时)	      包含在元素object之后param

object需要data属性,type属性或两者。如果您同时使用这两个,您也可以使用该typemustmatch属性(仅在Firefox中实现,在本文中)。typemustmatch保持嵌入文件不运行,除非type属性提供正确的媒体类型。typemustmatch因此,当您嵌入来自不同来源的内容(可以防止攻击者通过插件运行任意脚本)时,可以赋予重要的安全优势。

object标签的作用是支持HTML助手(插件辅助应用程序helper application)是可由浏览器启动的程序,也称为插件,
可用于播放音频和视频以及其他,允许用户来控制部分或全部播放设置。辅助程序是使用object标签来加载的

可使用object或embed标签来将插件添加到HTML页面
embed标签定义外部(非HTML)内容的容器,
object标签也可以定义外部(非HTML)内容的容器

</pre>使用embed元素嵌入Flash影片<pre class="html">
< embed src="whoosh.swf" quality="medium"
       bgcolor="#ffffff" width="550" height="400"
       name="whoosh" align="middle" allowScriptAccess="sameDomain"
       allowFullScreen="false" type="application/x-shockwave-flash"
       pluginspage="http://www.macromedia.com/go/getflashplayer">

</pre><pre>
很可怕,不是吗 。Adobe Flash工具生成的HTML往往更糟糕,使用嵌入object元素的embed元素来覆盖所有的基础(查看一个例子)。甚至有一段时间,Flash被成功地用作HTML5视频的备用内容,但是这种情况越来越被认为是不必要的。

</pre>object将PDF嵌入一个页面<pre class="html">
< object data="mypdf.pdf" type="application/pdf" width="800" height="1200" typemustmatch>
  <p>You don't have a PDF plugin, but you can < a href="myfile.pdf">download the PDF file.</ a></p>
</ object>

</pre><pre>
PDF是纸与数据之间重要的阶梯,但它们在可访问性上有些问题,并且可能难以在小屏幕上阅读。它们在一些圈子中仍然受欢迎,我们最好是用链接指向它们,而不是将其嵌入到网页中,以便它们可以在单独的页面上被下载或被阅读。

</pre><pre class="html">
雅虎播放器
链接播放
1.Flash播放
< embed  src="url"  width =""  height=""  wmode="transparent">< /embed>  使背景透明

2.插入mp3
< object align=middle class=OBJECT classid=CLSID:22d6f312-b0f6-11do-94ab=0080c74c7e95 id=MediaPlayer width=356 heigh=80>
  < param name="ShowstatusBar"  value="true">
  < param name="AutoStart"  value="true">
  < param name="Filename"  value="love.mp3">
  < param name="BorderStyle" value="1" />
  < param name="MousePointer" value="0" />
  < param name="Enabled" value="1" />
  < param name="Min" value="0" />
  < param name="Max" value="10" />
< /object>

3.插入背景音乐
< bgsound src="音乐文件名及路径"  loop="-1"/>  // 无限循环

4.插入视频wmv格式
< embed  src="url" >< /embed>

5.网络流媒体视频插入
优酷视频-分享-html代码
< embed align="center" autostart="false" height="600" loop="true" width="600" src="video\sugar.flv">

</pre>
</div>

<div id="frame">
<h2>框架集</h2><pre>
框架集 实现网页之中嵌套网页  -猫扑,邮箱
框架页面不需要body标记

iframe元素旨在允许将其他Web文档嵌入到当前文档中,这很适合将第三方内容纳入网站,可能无法直接控制,也不希望实现自己的版本,例如来自在线视频提供商的视频,Disqus等评论系统,在线地图提供商,广告横幅等,实时可编辑示例就是使用iframe实现的

</pre><pre class="html">
< iframe src="https://developer.mozilla.org/en-US/docs/Glossary" width="100%" height="500" frameborder="0" allowfullscreen sandbox>
  <p> < a href="https://developer.mozilla.org/en-US/docs/Glossary">
    Fallback link for browsers that don't support iframes
  </ a> </p>
</ iframe>

</pre><pre>
allowfullscreen
如果设置,iframe则可以通过全屏API设置为全屏模式

frameborder
如果设置为1则会告诉浏览器在此框架和其他框架之间绘制边框,这是默认行为。0删除边框。不推荐这样设置,因为在CSS中可以更好地实现相同的效果。border: none;

src
该属性与video/img一样包含指向要嵌入文档的URL路径。

width 和 height
这些属性指定iframe的宽度和高度。

备选内容
与video等其他类似元素相同,可以在iframe标签之间包含备选内容,如果浏览器不支持iframe将会显示备选内容,这种情况下已经添加了一个到该页面的链接。现在几乎不可能遇到任何不支持iframe的浏览器。

sandbox
该属性需要在已经支持其他iframe功能但稍微更现代的浏览器上才能工作,该属性可以提高安全性设置

为了提高速度,在主内容完成加载后使用Js设置iframe的src属性是个好主意,这使页面可以更快地被使用,并减少官方页面加载时间,重要的SEO指标

【 安全隐患 】
单击劫持是一种常见的iframe攻击,黑客将隐藏的iframe嵌入到您的文档中(或将您的文档嵌入到他们自己的恶意网站),并使用它来捕获用户的交互。这是误导用户或窃取敏感数据的常见方式

1、只有在必要时嵌入
有时嵌入第三方内容如YouTube视频和地图是有意义的,但如果只在完全需要时嵌入第三方内容可以省去很多麻烦。网络安全的一个很好的经验法则是"你怎么谨慎都不为过,如果你决定要做这件事,多检查一遍;如果是别人做的,在被证明是安全的之前,都假设这是危险的。"

除了安全问题,还应该意识到知识产权问题。无论在线内容还是离线内容,绝大部分内容都是有版权的,甚至是一些你没想到有版权的内容。不要在网页上展示一些不属于你的内容,除非你是所有者或所有者给了你明确的、书面的许可

如果内容获得许可,你必须遵守许可条款。例如MDN上的内容是在CC-BY-SA下许可的,这意味着如果要引用MDN内容就必须用适当的方式注明来源,即使对内容做了实质性的修改。

2、使用HTTPS
HTTPS是HTTP的加密版本,应该尽可能使用HTTPS为网站提供服务：
HTTPS减少了远程内容在传输过程中被篡改的机会,
HTTPS防止嵌入式内容访问您的父文档中的内容,反之亦然。

使用HTTPS需要一个安全证书,这可能是昂贵的(尽管Let's Encrypt让这件事变得更容易),如果你没有,可以使用HTTP来为你的父文档提供服务。但是,由于HTTPS的第二个好处,无论成本如何,您绝对不能使用HTTP嵌入第三方内容(在最好的情况下,您的用户的Web浏览器会给他们一个可怕的警告)。所有有声望的公司,例如Google Maps或Youtube,当您嵌入内容时,iframe将通过HTTPS提供 - 查iframe src属性内的URL。

Github页面允许默认情况下通过HTTPS提供内容,因此对托管内容很有用。如果您正在使用不同的托管,并且不确定,请向您的托管服务商询问。

3、始终使用sandbox属性
想尽可能减少攻击者在你的网站上做坏事的机会,那么你应该给嵌入的内容仅能完成自己工作的权限。当然这也适用于你自己的内容。一个允许包含在其里的代码以适当的方式执行或者用于测试,但不能对其他代码库(意外或恶意)造成任何损害的容器称为沙盒。

未沙盒化(Unsandboxed)内容可以做得太多(执行JavaScript,提交表单,弹出窗口等)默认情况下,您应该使用没有参数的sandbox属性来强制执行所有可用的限制

如果绝对需要可以逐个添加权限(sandbox=""属性值内),其中重要的一点是永远不应该同时添加allow-scripts和allow-same-origin到sandbox属性中-在这种情况下,嵌入式内容可以绕过阻止站点执行脚本的同源安全策略,并使用JavaScript完全关闭沙盒。

如果攻击者可以欺骗人们直接访问恶意内容(在iframe之外),则沙盒无法提供保护。如果某些内容可能是恶意的(例如用户生成的内容),请保证其是从不同的域向主站点提供的。

4、配置CSP指令
CSP代表内容安全策略,它提供一组HTTP标头(由web服务器发送时与元数据一起发送的元数据),旨在提高HTML文档的安全性。在iframes安全性方面,您可以将服务器配置为发送适当的X-Frame-Options标题。这样做可以防止其他网站在其网页中嵌入您的内容(这将导致点击和一系列其他攻击)

可以阅读Frederik Braun的帖子在X-Frame-Options安全性头上来获取有关此主题的更多背景信息

</pre>

<textarea rows="12" cols="120">
  <frameset  rows="" cols="" framespacing="" frameborder="yes/no,1/0"  border="" bordercolor="">
    <frame  src="url"   name="框架名称"  nosize="" >
  </frameset >

  内嵌式框架
   <iframe src="url" name="a1" width="" height="" frameborder="" scrolling="" ></iframe> url为默认页面
   <base target="a1">
   一、html方法
  <a href="http://www.lingdublog/" target="a1">零度博客</a>
  二、javascript方法：
  <a href="http://www.lingdublog.cc"  onclick="document.frames('a1').location=this.href;return false">零度博客</a>
</textarea>
</div>

<div id="data">
<h3>html5自定义属性data-*,用于存储页面或应用程序的js可以利用的私有自定义数据</h3><pre class="html">
src是属性,data-src是自定义属性
$('#imgid').attr('src')
$('#imgid').data('src')
$('#imgid').attr('data-src')

<div id="div1" data-drink="coffee" data-food="sushi" data-meal="lunch">¥20.12</div> //设置data-属性
var typeOfDrink=document.getElementById("div1").dataset.drink;               //获取data属性的值
var typeOfDrink=document.getElementById("div1").getAttribute('data-drink');  //获取data属性的值

</pre>

<h4>html5新属性：hidden</h4><pre class="html" >
<div id="target" hidden="true" style="height:40px; border:1px solid;"> hidden属性 </div>
<button onclick="var target=document.getElementById('target');target.hidden=!target.hidden;">显示/隐藏</button>

</pre>

<h4>html5新属性,全局属性：元素内容可编辑contenteditable="true"</h4><pre class="html" >
<ul contenteditable="true">
  <li>悼念遇难香港同胞 </li>
  <li>深圳特区30周年</li>
  <li>伊春空难</li>
</ul>

</pre>
</div>

<div id="templatetag">
<h3>template标签 免去手动拼接字符串的麻烦</h3><pre>
template元素是一种用于保存客户端内容的机制,该内容在页面加载时不被渲染,但可以在运行时使用JS进行实例化,可以将一个模板视为正在被存储以供随后在文档中使用的一个内容片段。
template标签内容隐藏不可见,默认情况下template是隐藏的,实际是默认其display属性为none,可以写在html的任意位置
虽然在加载页面的同时,解析器确实处理template元素的内容,这样做只是确保这些内容是有效的,然而元素的内容不会被渲染。

template标签元素仅包含全局属性,还包含只读的content属性,通过它可以读取模板内容。
可以通过判断content属性是否存在来判断浏览器是否支持template元素。

由于appendChild方法实际上会对元素进行剪切操作,因此无法实现模板复用的效果。因此需要复制模板内的元素,然后再将元素副本添加到当前文档中

首先要明确模板文档具有以下2个要求：
1.  <> "' 不被转成字符实体;
2. 含src特性的img标签不触发资源请求。

</pre>

<h4>存放模板文本的方式</h4><pre>
【 1、script标签 】
innerText和innerHTML获取结果一致
若模板中包含script闭合标签会造成标签结束符混乱的问题,因此通过该方式存放模板时不能包含script结束标签

</pre><pre class="js">
<!-- 模板文本开始 -->
＜script type="text/template" id="tpl"＞
  ＜img src="./image/logo.png" title="{{title}}"/＞
＜/script＞
<!-- 模板文本结束 -->

// js代码开始
// 获取模板对应方式
console.log("---------------script type='text/template'---------------------------------------");
var tplscript = document.getElementById('tpl');
console.log('tplscript.childNodes');
console.log(tplscript.childNodes);          //NodeList[1]
console.log('tplscript.childNodes[0]');
console.log(tplscript.childNodes[0]);
console.log('tplscript.childNodes[0] type: '+typeof tplscript.childNodes[0]);

var tplscript = document.getElementById('tpl');
console.log('innerText');
console.log(tplscript.innerText);           //innerText和innerHTML结果一致
console.log('innerHTML');
console.log(tplscript.innerHTML);
tplscript = tplscript.innerHTML.replace(/^[\s\u3000]*|[\s\u3000]*$/, '');
//Handlebars.compile(tpl)({title: 'test'})
//compile()方法用于在脚本执行过程中编译正则表达式,也用于改变和重新编译正则表达式,大量重复才能提高效率
// js代码结束

</pre><pre>
【 2、textarea标签 】
若模板中包含textarea闭合标签会造成标签结束符混乱的问题,因此通过该方式存放模板时,不能包含textarea结束标签
value、innerText获取,但不能通过innerHTML获取,因为它会对<>"'等转换为字符实体

</pre><pre class="js">
<!-- 模板文本开始 -->
＜textarea style="display: none" id="textarea"＞
  ＜img src="./image/logo.png" title="{{title}}"/＞
＜/textarea＞
<!-- 模板文本结束 -->

// js代码开始
// 获取模板对应方式
console.log("------------------textarea-----------------------------------------------");
var tpltextarea = document.getElementById('textarea');
console.log('tpltextarea.childNodes');
console.log(tpltextarea.childNodes);

console.log('value');
console.log(tpltextarea.value);
console.log('innerText');
console.log(tpltextarea.innerText);   //value和innerText结果一致
console.log('innerHTML');
console.log(tpltextarea.innerHTML);   //innerHTML被实体化
tpltextarea = tpltextarea.value.replace(/^[\s\u3000]*|[\s\u3000]*$/, '');
// js代码结束

</pre><pre>
【 3、xmp标签 】
xmp标签(语义为标识内容用作示例,现已被标准废除了,但各大浏览器依然支持该标签

【 4、template标签 】
innerText获取得到空,innerHTML获取string类型,content获取得到object类型
若模板中包含template闭合标签会造成标签结束符混乱的问题,因此通过该方式存放模板时不能包含template结束标签

</pre><pre class="js">
<!-- 模板文本开始 -->
＜template id="template"＞
  ＜img src="./image/logo.png" title="{{title}}"/＞
＜/template＞
<!-- 模板文本结束 -->

// js代码开始
// 获取模板对应方式
console.log("------------------template----------------------------------------");
var tplele = document.querySelector('#template');
console.log('tplele.childNodes: ', tplele.childNodes);
console.log('innerHtml: ', tplele.innerHTML);     //获取完整html片段
console.log('typeof innerHtml: ', typeof tplele.innerHTML);
console.log('innerText: ', tplele.innerText);
console.log('typeof innerText: ');
console.log('content: ', tplele.content);         //返回一个文档片段,类似document
console.log('tplele.content type: '+typeof tplele.content);

var img = tplele.content.querySelector('img');
console.log(img.src);                  // 显示空字符串
console.log(img.getAttribute('src'));  // 显示dummy.png
img.src = img.getAttribute('src');
console.log(img.src);

//由于appendChild方法实际上会对元素进行剪切操作,因此无法实现模板复用的效果。因此我们需要复制模板内的元素,然后再将元素副本添加到当前文档中
// document.body.appendChild(img);        //添加到当前文档中才会发起资源请求

//整个template提供的DocumentFragment导出到当前document
var x = tplele.content;
var clone = document.importNode(x, true);   //模板的克隆
document.body.appendChild(x);
// js代码结束

</pre><pre>
【 四种方式的区别 】
1.不一样的childNodes
script、textarea和xmp方式存放模板文本时,通过 tplEl.childNodes.length 均返回1, tplEl.childNodes[0].nodeName 均返回#text。而template返回的是0。

2.伪文档片段入口——content属性
通过innerHTML或innerText属性,template内部的模板文本将被视为普通文本来使用。但template元素为我们提供了另一种使用方式,那就是"文档片段"。

"文档片段"的[[Class]]为[object DocumentFragment],"文档片段"具有文档片段的所有功能API,不同的是设置img元素的src属性不会发出资源请求、不执行Script和CSS规则,而[object HTMLDocument]"文档"则会发送img请求并在当前browsing context(即window对象上下文)内执行Script和CSS规则。

</pre>
</div>

<div id="progress">
<h3>progress标签,IE9及更早的版本不支持<a href="/study/web/HTML5/progress_upload.html">demo</a></h3><pre>
progress标签定义运行中的进度,显示JS中耗费时间的函数的进度,上传下载进度,页面加载

属性设置：
max   最大值,若缺省进度值范围从0.0~1.0,如果设置成max=100则进度值范围从0~100
value 值,value属性的存在与否决定了progress进度条是否具有确定性,一旦有了value属性(即使无值)显示的样式不同
position是只读属性,当前进度的位置,就是value/max的值。如果进度条不确定则值为-1
labels也是只读属性

样式设置：
progress可以设置width,height,border等常用属性。
对于IE10+,firefox浏览器,可以用background设置进度条的背景色。
对于webkit浏览器,使用::-webkit-progress-bar设置进度条的背景色。
对于IE10+,用::-ms-fill设置进度条完成进度的背景色。
对于firefox,用::-moz-progress-bar设置进度条完成进度的背景色。
对于webkit浏览器,使用::-webkit-progress-value设置进度条完成进度的背景色。

::-webkit-progress-bar设置的是进度条的背景色,而::-moz-progres-bar设置的是进度条完成进度的背景色,正好是反着的。
而且对于webkit浏览器,在IOS上要用-wekbit-appearance:none来清空progress的默认样式,才能让背景色,进度颜色起作用。

</pre><pre class="html">
<progress value="22" max="100"></progress>
var percent = Math.round(loaded / total * 100);
$("progress").val(percent);

<progress>o(︶︿︶)o</progress>    value和max不存在时显示为左右晃动的横条,浏览器不支持该标签时显示标签中的内容

<progress max="100" value="20"><ie style="width:20%;"></ie></progress> 兼容性写法,增加progress标签额外样式即可
progress {
  display: inline-block;
  width: 160px;
  height: 20px;
  border: 1px solid #0064B4;
  background-color:#e6e6e6;
  color: #0064B4; /*IE10*/
}

progress ie {       /*ie6-ie9*/
  display:block;
  height: 100%;
  background: #0064B4;
}

progress::-moz-progress-bar { background: #0064B4; }
progress::-webkit-progress-bar { background: #e6e6e6; }
progress::-webkit-progress-value  { background: #0064B4; }

if (typeof window.screenX !== "number") {  //动态补丁,自定义progress和ie元素
  document.createElement("progress");
  document.createElement("ie");
}

</pre><pre class="html">
<progress value="0"  max="100">您的浏览器不支持progress元素</progress>
<br/><br/>
<input type="button" value="开始" onclick="goprogress()"/>

// js代码
function goprogress(){
  var pro=document.getElementsByTagName("progress")[0];
  gotoend(pro,0);
}
function gotoend(pro,value){
  var value=value+1;
  pro.value=value;
  if(value < 100) {
    setTimeout(function(){gotoend(pro, value);},20)
  }else{
    setTimeout(function(){alert("任务完成")},20);
  }
}

</pre><pre>
原生进度条和度量,progress不适合用来表示度量衡，如果想表示度量衡应该使用meter标签代替,meter用来度量给定范围（gauge）内的数据
< meter value="3" min="0" max="10">< /meter> 十分之三 < br>
< meter value="0.6">< /meter> 60%

</pre>
</div>

<div id="notifications">
<h3>HTML5桌面通知：Notification API</h3><pre>
Notification API是HTML新增的桌面通知API,用于向用户配置和显示桌面通知。该通知是脱离浏览器的,即使用户没有停留在当前标签页,甚至最小化了浏览器,该通知信息也一样会置顶显示出来

测试最多显示3个通知,多余通知关闭其它才会显示

【 构造方法 】
var notification = new Notification(title, options);

构造函数参数：都是实例化对象的属性,通过notification.title,notification.data获取
title   一定会被显示的通知标题
options 可选,一个被允许用来设置通知的对象,包含以下属性：
  body: 通知中额外显示的字符串
  tag:  赋予通知一个ID,以便在必要的时候对通知进行刷新、替换或移除,相同tag不会同时显示
  icon: 一个图片的URL,将被用于显示通知的图标
  data: { url: 'http://blog.gdfengshuo.com' }
  requireInteraction: true  // 要求互动交互,点击跳转或者关闭按钮才能关闭通知;默认false只显示几秒
  dir : 文字的方向,auto(自动),ltr(left to right),rtl(right to left)貌似无效
  lang: 指定通知中所使用的语言,这个字符串必须在BCP 47 language tag文档中是有效的
  renotify: false 再通知
  silent: false   安静
  vibrate: []     振动

【 属性 】
静态属性：仅在Notification对象上有效
Notification.permission 只读 用于表明当前通知显示授权状态的字符串
  denied (用户拒绝了通知的显示)
  granted (用户允许了通知的显示)
  default (因为不知道用户的选择,所以浏览器的行为与 denied 时相同)

实例属性：仅在Notification的实例中有效
Notification.title 只读  (moz only) 在构造方法中指定的 title 参数。
Notification.dir 只读  通知的文本显示方向。在构造方法的 options 中指定。
Notification.lang 只读  通知的语言。在构造方法的 options 中指定。
Notification.body 只读  通知的文本内容。在构造方法的 options 中指定。
Notification.tag 只读  通知的 ID。在构造方法的 options 中指定。
Notification.icon 只读 通知的图标图片的 URL 地址。在构造方法的 options 中指定。

【 方法 】
静态方法：仅在Notification对象中有效。
Notification.requestPermission()
用于当前页面想用户申请显示通知的权限。这个方法只能被用户行为调用(比如：onclick 事件),并且不能被其他的方式调用。

实例方法：仅在Notification实例或其prototype中有效。
Notification.close()  用于关闭通知。

Notification对象继承自EventTarget接口
EventTarget.addEventListener()
EventTarget.removeEventListener()
EventTarget.dispatchEvent()

【 事件处理 】
Notification.onclick  处理click事件的处理,当用户点击通知时被触发,比如打开一个网址引导用户回到自己的网站
Notification.onshow   处理show事件的处理,当通知显示的时候被触发
Notification.onerror  处理error事件的处理,每当通知遇到错误时被触发
Notification.onclose  处理close事件的处理,当用户关闭通知时被触发

【 用户权限 】
想要向用户显示通知消息,需要获取用户权限,而相同的域名只需要获取一次权限。只有用户允许的权限下Notification才能起到作用,避免某些网站的广告滥用Notification或其它给用户造成影响

if(Notification.permission === 'granted'){
  console.log('用户允许通知');
}else if(Notification.permission === 'denied'){
  console.log('用户拒绝通知');
}else{
  console.log('用户还没选择,去向用户申请权限吧');
}

【 请求权限 】
用户还没选择时需要向用户去请求权限,Notification对象提供了requestPermission()方法请求用户当前来源的权限以显示通知。
以前基于回调的语法已经弃用(当然在现在的浏览器中还是能用的),最新的规范已将此方法更新为基于promise的语法：

Notification.requestPermission().then(function(permission) {
  if(permission === 'granted'){
    console.log('用户允许通知');
  }else if(permission === 'denied'){
    console.log('用户拒绝通知');
  }
});

【 推送通知 】
获取用户授权之后就可以推送通知了

var n = new Notification('状态更新提醒',{
  body: '你的朋友圈有3条新状态,快去查看吧',
  tag: 'linxin',
  icon: 'http://localhost/study/image/dog.jpg',
  requireInteraction: true,
});

【 关闭通知 】
var n = new Notification('状态更新提醒',{ body: '你的朋友圈有3条新状态,快去查看吧'});
setTimeout(function() { n.close();}, 1000*60);   // 3秒后关闭通知

【 事件处理 】
var n = new Notification('状态更新提醒',{
  body: '你的朋友圈有3条新状态,快去查看吧',
  data: { url: 'http://blog.gdfengshuo.com' }
});
n.onclick = function(){
  window.open(n.data.url, '_blank'); // 打开网址
  n.close(); // 并且关闭通知
}

监听了页面beforeunload事件,关闭标签卡时通知也会被关闭
function addOnBeforeUnload(e) {
  FERD_NavNotice.notification.close();
}
if(window.attachEvent){
  window.attachEvent('onbeforeunload', addOnBeforeUnload);
} else {
  window.addEventListener('beforeunload', addOnBeforeUnload, false);
}

</pre><pre class="js">
if (!('Notification' in window)) {
  alert('Do not support notification');
} else {
  Notification.requestPermission(function() {
    console.log(Notification.permission);
      var notification = new Notification(title = 'Email received',
        options = {
            body: 'You have a total of 3 unread emails',
            tag:  'test',
            icon: '/study/image/dog.jpg',
            dir:  'auto',
            lang: '',
            requireInteraction: true,
            data: { url: 'http://localhost/study/html.html' },
        }
      );
      notification.onclick = function(){
        window.open(notification.data.url, '_blank');
        notification.close();
      };
      notification.onshow = function(){ console.log('show...')};
      notification.onerror = function(){ console.log('sth error...')};
      notification.onclose = function(){ console.log('close...')};
      console.log(notification);
      /*Notification{
        actions: Array[0]
      badge:   ""
      body:    "You have a total of 3 unread emails"
      data:    Object
      dir:     "auto"
      icon:    "/study/image/dog.jpg"
      lang:    ""
      onclick: ()
      onclose: null
      onerror: null
      onshow:  null
      renotify:false
      requireInteraction:true
      silent:  false
      tag:     "preset"
      timestamp:1508819293649
      title:   "Email received"
      vibrate: Array[0]
      __proto__:Notification
    }*/
  });
}
</pre>
</div>

<!--------------------------HTML5拖放---------------------------------------------->
<div id="drage">
<h3>HTML5拖放Drag、Drop</h3><pre>
元素draggable属性设置为TRUE;可用DOM元素的删除、插入来模拟

拖拽,拖放事件可以通过拖拽实现数据传递,达到良好的交互效果,如从操作系统拖拽文件实现文件选择,拖拽实现元素布局的修改
ondragstart
ondragover
ondrop

元素ondragstart属性调用函数drag(event),规定被拖动的数据
dataTransfer.setData(type,value)方法设置被拖动数据的数据类型和值

ondragover事件规定在何处防止被拖动的数据
默认的无法将数据/元素放置到其他元素中,如果需要,则必须通过调用ondragover事件的event.preventDefault()方法阻止对元素的默认处理方式

当放置被拖数据时会发生drop事件
datatransfer.getData(type)方法获得被拖动的数据

【 drag and drop事件流程 】
完整的drag and drop流程:
1、设置可拖拽目标,设置属性draggable="true"实现元素的可拖拽.
2、监听dragstart设置拖拽数据
3、为拖拽操作设置反馈图标(可选)
4、设置允许的拖放效果,如copy,move,link
5、设置拖放目标,默认情况下浏览器阻止所有的拖放操作,所以需要监听dragenter或者dragover取消浏览器默认行为使元素可拖放.
6、监听drop事件执行所需操作

【 拖拽事件 】
以下是拖拽产生的一系列事件,拖拽事件产生时不会产生对应的鼠标事件
dragstart:拖拽开始时在被拖拽元素上触发此事件,监听器需要设置拖拽所需数据,从操作系统拖拽文件到浏览器时不触发此事件.
dragenter:拖拽鼠标进入元素时在该元素上触发,用于给拖放元素设置视觉反馈,如高亮
dragover:拖拽时鼠标在目标元素上移动时触发.监听器通过阻止浏览器默认行为设置元素为可拖放元素.
dragleave:拖拽时鼠标移出目标元素时在目标元素上触发.此时监听器可以取消掉前面设置的视觉效果.
drag:拖拽期间在被拖拽元素上连续触发
drop:鼠标在拖放目标上释放时,在拖放目标上触发.此时监听器需要收集数据并且执行所需操作.如果是从操作系统拖放文件到浏览器,需要取消浏览器默认行为.
dragend:鼠标在拖放目标上释放时,在拖拽元素上触发.将元素从浏览器拖放到操作系统时不会触发此事件.

【 DataTransfer对象 】
拖拽事件周期中会初始化一个DataTransfer对象,用于保存拖拽数据和交互信息,它可以保存一项或多项数据、一种或者多种数据类型

dataTransfer对象的属性和方法：

dropEffect: 拖拽交互类型,通常决定浏览器如何显示鼠标光标并控制拖放操作.常见的取值有copy,move,link和none

effectAllowed: 指定允许的交互类型,可以取值:copy,move,link,copyLink,copyMove,limkMove, all, none默认为uninitialized(允许所有操作)

files: 包含File对象的FileList对象.从操作系统向浏览器拖放文件时有用

types: 保存DataTransfer对象中设置的所有数据类型

setData(format, data): 以键值对设置被拖数据的数据类型和值
format通常为数据格式,如Text,text/html,text/plain
function dragstart(event){
  event.dataTransfer.setData("Text", event.target.id);
}

function onDragStart(event) {
  event.dataTransfer.setData('text/plain', 'idname');
}

getData(format): 获取设置的对应格式数据,format与setData()中一致
function drop(event){
  event.preventDefault();     //drop事件的默认行为是以链接的形式打开
  var data=event.dataTransfer.getData("Text");  //获得以setData()方法中设置为相同类型的任何数据
  event.target.appendChild(document.getElementById(data));
}

clearData(format): 清除指定格式的数据

setDragImage(imgElement, x, y): 设置自定义图标

dataTransfer对象在传递给监听器的事件对象中可以访问
draggableElement.addEventListener('dragstart', function (event) {
  event.dataTransfer.setData('text', 'Hello World');
}, false);

【 推荐的拖拽元素和数据类型 】

文本
在页面中选择文本并拖拽,无需处理dragstart设置数据,浏览器自动设置选取的文本,相当于event.dataTransfer.setData("text/plain", "this is text to drag"),只需要在拖放目标上读取对应格式的数据即可

链接

</pre>拖拽元素到达目的区域,改变在DOM中的位置,同时设置反馈视觉效果<pre class="html">
<div id="demo1">
  <ul class="panel-list">
    <li class="panel-item"></li>
    <li class="panel-item"></li>
    <li class="panel-item"></li>
    <li class="panel-item"></li>
    <li class="panel-item"></li>
  </ul>
  <h2>拖拽下面的方块到上面任意容器中</h2>
  <!-- 设置draggable使元素成为可拖拽元素 -->
  <span class="movable" id="demo1-src" draggable="true"></span>

// css样式
#demo1 {margin: 20px;}
#demo1 .panel-list {overflow: hidden;list-style: none;margin: 0;padding: 0;}
#demo1 .panel-item {float: left;margin-right: 30px;width: 100px;height: 100px;background: #ddd;border: 1px solid #ddd;}
#demo1-src {display: inline-block;width: 50px;height: 50px;background: purple;}
#demo1 .over {border: 1px dashed #000;-webkit-transform: scale(0.8, 0.8);}

// js代码
(function () {
var dnd = {
  // 初始化
  init: function () {
    var me = this;
    me.src = document.querySelector('#demo1-src');
    me.panelList = document.querySelector('.panel-list');

    // 为拖拽源监听dragstart,设置关联数据
    me.src.addEventListener('dragstart', me.onDragStart, false);

    // 拖拽鼠标移入元素,在拖放目标上设置视觉反馈
    me.panelList.addEventListener('dragenter', me.onDragEnter, false);

    // 取消元素dragover默认行为,使其可拖放
    me.panelList.addEventListener('dragover', me.onDragOver, false);

    // 拖拽移出元素,清除视觉反馈
    me.panelList.addEventListener('dragleave', me.onDragLeave, false);

    // 鼠标释放,在拖放目标上接收数据并处理
    me.panelList.addEventListener('drop', me.onDrop, false);
  },
  onDragStart: function (e) {
    e.dataTransfer.setData('text/plain', 'demo1-src');
  },
  onDragEnter: function (e) {
    if (e.target.classList.contains('panel-item')) {
      e.target.classList.add('over');
    }
  },
  onDragLeave: function (e) {
    if (e.target.classList.contains('panel-item')) {
      e.target.classList.remove('over');
    }
  },
  onDragOver: function (e) {
    e.preventDefault();
  },
  onDrop: function (e) {
    var id = e.dataTransfer.getData('text/plain');
    var src = document.getElementById(id);
    var target = e.target;
    if (target.classList.contains('panel-item')) {
      target.appendChild(src);
      target.classList.remove('over');
    }
  }
};

dnd.init();
}());
</div>

</pre><pre>
从操作系统拖拽图片到指定区域进行预览
从操作系统拖拽文件到浏览器中,不会触发dragstart,dragend,只需取消拖放区域的默认行为,设置反馈,并在拖放发生时取消浏览器默认行为,通过e.dataTransfer.files获取文件信息进行操作

</pre><pre class="html">
// css样式
#demo2 { margin: 20px; }
#demo2 .preview { height: 300px; background: #ddd; }
#demo2 li {float: left;margin-left: 40px;}
#demo2 img {max-height: 150px;width: auto;}

<div id="demo2">
<h3>从文件夹中拖拽图片到下面的区域进行预览</h3>
<ul class="preview"></ul>

// js代码
(function (w) {
  var doc = w.document;
  var dnd = {
    init: function () {
      var me = this;
      var preview = doc.querySelector('#demo2 .preview');
      preview.addEventListener('dragover', function (e) {
          e.preventDefault();
      }, false);
      preview.addEventListener('drop', function (e) {
        // 操作系统拖放文件到浏览器需要取消默认行为
        e.preventDefault();
        [].forEach.call(e.dataTransfer.files, function (file) {
          if (file && file.type.match('image.*')) {
            var reader = new FileReader();
            reader.onload = function (e) {
              var img = doc.createElement('img');
              img.src = e.target.result;
              var li = doc.createElement('li');
              li.appendChild(img);
              preview.appendChild(li);
            };
            reader.readAsDataURL(file);
          }
        });
      }, false);
    }
  };
  dnd.init();
}(window));

</pre>
</div>

</pre><pre class="html">
/**来回拖动**/
<header ondrop="drop(event)" ondragover="allowDrop(event)" style="width:200px;height:150px;border:2px solid #58a;">
  <nav draggable="true" ondragstart="drag(event)" style="width:100px;height:100px;background:red;" /></nav>
</header>
<footer ondrop="drop(event)" ondragover="allowDrop(event)" style="width:200px;height:150px;border:2px solid #58a;"></footer>

// js代码
function drag(ev){                                      //ev.target：触发事件的元素
  ev.dataTransfer.setData("Text",ev.target.tagName);    //设置被拖动对象的数据类型和值
}
function allowDrop(ev){
  ev.preventDefault();	//取消默认事件
}
function drop(ev){
  ev.preventDefault();
  var data=ev.dataTransfer.getData("Text");            //获取被拖动对象的数据类型和值
  ev.target.appendChild(document.getElementsByTagName(data)[0]);
}

</pre>
</div>

<!-- -------------------------------------------------------------------------- -->
<div id="file">
<h2><a href="http://blog.csdn.net/zhu1988renhui/article/details/7936525">H5 FileAPI</a></h2>
</div>

<div id="base64">
<h3>base64编码解码</h3><pre>
base64是一组相似的二进制到文本(binary-to-text)的编码规则,使得二进制(8bit)数据在解释成radix-64的表现形式后能够用ASCII字符串的格式表示出来

base64编码普遍应用于需要通过被设计为处理文本数据的媒介上储存和传输二进制数据而需要编码该二进制数据的场景。这样是为了保证数据的完整并且不用在传输过程中修改这些数据。Base64也被一些应用(包括使用MIME的电子邮件)和在XML中储存复杂的数据时使用

Data URI scheme语法：
"data:image/gif;base64,R01G//OD45sd4dsd54/7855SDC+CXXC..... "
data:image/jpg;    声明数据协议及类型名称
base64,            编码形式为base64
/9j/4AAQSkZ……      base64编码结果

通过base64把文件嵌入文档中减少网络请求
复制到浏览器地址栏中打开就可以显示对应的图片

Data URI scheme支持的类型有：
data:,<文本数据>
data:text/plain,                       < 文本数据>
data:text/html,                        < HTML代码>
data:text/html;base64,                 < base64编码的HTML代码>
data:text/plain;charset=UTF-8;base64,  < base64编码的HTML代码>
data:text/css,                         < CSS代码>
data:text/css;base64,                  < base64编码的CSS代码>
data:text/javascript,                  < JS代码>
data:text/javascript;base64,           < base64编码的JS代码>
data:image/gif;base64,                 < base64编码的gif图片数据>
data:image/png;base64,                 < base64编码的png图片数据>
data:image/jpeg;base64,                < base64编码的jpeg图片数据>
data:image/x-icon;base64,              < base64编码的icon图片数据>

Data URL缺点：
1、Base64编码的数据体积通常是原数据体积4/3,Data URL形式的图片会比二进制格式的图片体积大1/3,但CSS和Js使用gzip压缩之后总体还是变小
2、Data URL形式的图片不会被浏览器缓存,每次访问这样页面时都被下载一次,尤其当图片被整个网站大量使用的时候,但浏览器会缓存css文件,Data URL可以嵌入css的url操作符中

CSS中
background-image: url(data:image/gif;base64,R0lGODlhFQAJAIAAACMtMP///yH5BAEAAAEALAAAAAAVAAkAAAIXjI+AywnaYnhUMoqt3gZXPmVg94yJVQAAOw==);
background-image: url('data:image/gif;base64,R0lGODlhAwADAIAAAP///8zMzCH5BAAAAAAALAAAAAADAAMAAAIEBHIJBQA7');

HTML中
＜img src="data:image/gif;base64,R0lGODlhFQAJAIAAACMtMP///yH5BAEAAAEALAAAAAAVAAkAAAIXjI+AywnaYnhUMoqt3gZXPmVg94yJVQAAOw=="/＞

network -> 图片预览 -> copy image as data URL

</pre><div style="overflow-x: auto"><pre class="html">
动态黑白圆环loading图片

img src="data:image/gif;base64,R0lGODlhJQAlAJECAL3L2AYrTv///wAAACH/C05FVFNDQVBFMi4wAwEAAAAh+QQFCgACACwAAAAAJQAlAAACi5SPqcvtDyGYIFpF690i8xUw3qJBwUlSadmcLqYmGQu6KDIeM13beGzYWWy3DlB4IYaMk+Dso2RWkFCfLPcRvFbZxFLUDTt21BW56TyjRep1e20+i+eYMR145W2eefj+6VFmgTQi+ECVY8iGxcg35phGo/iDFwlTyXWphwlm1imGRdcnuqhHeop6UAAAIfkEBQoAAgAsEAACAAQACwAAAgWMj6nLXAAh+QQFCgACACwVAAUACgALAAACFZQvgRi92dyJcVJlLobUdi8x4bIhBQAh+QQFCgACACwXABEADAADAAACBYyPqcsFACH5BAUKAAIALBUAFQAKAAsAAAITlGKZwWoMHYxqtmplxlNT7ixGAQAh+QQFCgACACwQABgABAALAAACBYyPqctcACH5BAUKAAIALAUAFQAKAAsAAAIVlC+BGL3Z3IlxUmUuhtR2LzHhsiEFACH5BAUKAAIALAEAEQAMAAMAAAIFjI+pywUAIfkEBQoAAgAsBQAFAAoACwAAAhOUYJnAagwdjGq2amXGU1PuLEYBACH5BAUKAAIALBAAAgAEAAsAAAIFhI+py1wAIfkEBQoAAgAsFQAFAAoACwAAAhWUL4AIvdnciXFSZS6G1HYvMeGyIQUAIfkEBQoAAgAsFwARAAwAAwAAAgWEj6nLBQAh+QQFCgACACwVABUACgALAAACE5RgmcBqDB2MarZqZcZTU+4sRgEAIfkEBQoAAgAsEAAYAAQACwAAAgWEj6nLXAAh+QQFCgACACwFABUACgALAAACFZQvgAi92dyJcVJlLobUdi8x4bIhBQAh+QQFCgACACwBABEADAADAAACBYSPqcsFADs="

静态圆形loading
width:18px;height:18px;background: transparent url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMjAiIGhlaWdodD0iMTIwIiB2aWV3Qm94PSIwIDAgMTAwIDEwMCI+PHBhdGggZmlsbD0ibm9uZSIgZD0iTTAgMGgxMDB2MTAwSDB6Ii8+PHJlY3Qgd2lkdGg9IjciIGhlaWdodD0iMjAiIHg9IjQ2LjUiIHk9IjQwIiBmaWxsPSIjRTlFOUU5IiByeD0iNSIgcnk9IjUiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDAgLTMwKSIvPjxyZWN0IHdpZHRoPSI3IiBoZWlnaHQ9IjIwIiB4PSI0Ni41IiB5PSI0MCIgZmlsbD0iIzk4OTY5NyIgcng9IjUiIHJ5PSI1IiB0cmFuc2Zvcm09InJvdGF0ZSgzMCAxMDUuOTggNjUpIi8+PHJlY3Qgd2lkdGg9IjciIGhlaWdodD0iMjAiIHg9IjQ2LjUiIHk9IjQwIiBmaWxsPSIjOUI5OTlBIiByeD0iNSIgcnk9IjUiIHRyYW5zZm9ybT0icm90YXRlKDYwIDc1Ljk4IDY1KSIvPjxyZWN0IHdpZHRoPSI3IiBoZWlnaHQ9IjIwIiB4PSI0Ni41IiB5PSI0MCIgZmlsbD0iI0EzQTFBMiIgcng9IjUiIHJ5PSI1IiB0cmFuc2Zvcm09InJvdGF0ZSg5MCA2NSA2NSkiLz48cmVjdCB3aWR0aD0iNyIgaGVpZ2h0PSIyMCIgeD0iNDYuNSIgeT0iNDAiIGZpbGw9IiNBQkE5QUEiIHJ4PSI1IiByeT0iNSIgdHJhbnNmb3JtPSJyb3RhdGUoMTIwIDU4LjY2IDY1KSIvPjxyZWN0IHdpZHRoPSI3IiBoZWlnaHQ9IjIwIiB4PSI0Ni41IiB5PSI0MCIgZmlsbD0iI0IyQjJCMiIgcng9IjUiIHJ5PSI1IiB0cmFuc2Zvcm09InJvdGF0ZSgxNTAgNTQuMDIgNjUpIi8+PHJlY3Qgd2lkdGg9IjciIGhlaWdodD0iMjAiIHg9IjQ2LjUiIHk9IjQwIiBmaWxsPSIjQkFCOEI5IiByeD0iNSIgcnk9IjUiIHRyYW5zZm9ybT0icm90YXRlKDE4MCA1MCA2NSkiLz48cmVjdCB3aWR0aD0iNyIgaGVpZ2h0PSIyMCIgeD0iNDYuNSIgeT0iNDAiIGZpbGw9IiNDMkMwQzEiIHJ4PSI1IiByeT0iNSIgdHJhbnNmb3JtPSJyb3RhdGUoLTE1MCA0NS45OCA2NSkiLz48cmVjdCB3aWR0aD0iNyIgaGVpZ2h0PSIyMCIgeD0iNDYuNSIgeT0iNDAiIGZpbGw9IiNDQkNCQ0IiIHJ4PSI1IiByeT0iNSIgdHJhbnNmb3JtPSJyb3RhdGUoLTEyMCA0MS4zNCA2NSkiLz48cmVjdCB3aWR0aD0iNyIgaGVpZ2h0PSIyMCIgeD0iNDYuNSIgeT0iNDAiIGZpbGw9IiNEMkQyRDIiIHJ4PSI1IiByeT0iNSIgdHJhbnNmb3JtPSJyb3RhdGUoLTkwIDM1IDY1KSIvPjxyZWN0IHdpZHRoPSI3IiBoZWlnaHQ9IjIwIiB4PSI0Ni41IiB5PSI0MCIgZmlsbD0iI0RBREFEQSIgcng9IjUiIHJ5PSI1IiB0cmFuc2Zvcm09InJvdGF0ZSgtNjAgMjQuMDIgNjUpIi8+PHJlY3Qgd2lkdGg9IjciIGhlaWdodD0iMjAiIHg9IjQ2LjUiIHk9IjQwIiBmaWxsPSIjRTJFMkUyIiByeD0iNSIgcnk9IjUiIHRyYW5zZm9ybT0icm90YXRlKC0zMCAtNS45OCA2NSkiLz48L3N2Zz4=) no-repeat;background-size: 100%;

动态黑白条状loading图片
img src="data:image/gif;base64,R0lGODlhgAAPAPIAAP///wAAAMbGxrKyskJCQgAAAAAAAAAAACH+GkNyZWF0ZWQgd2l0aCBhamF4bG9hZC5pbmZvACH5BAAKAAAAIf8LTkVUU0NBUEUyLjADAQAAACwAAAAAgAAPAAAD5wiyC/6sPRfFpPGqfKv2HTeBowiZGLORq1lJqfuW7Gud9YzLud3zQNVOGCO2jDZaEHZk+nRFJ7R5i1apSuQ0OZT+nleuNetdhrfob1kLXrvPariZLGfPuz66Hr8f8/9+gVh4YoOChYhpd4eKdgwDkJEDE5KRlJWTD5iZDpuXlZ+SoZaamKOQp5wAm56loK6isKSdprKotqqttK+7sb2zq6y8wcO6xL7HwMbLtb+3zrnNycKp1bjW0NjT0cXSzMLK3uLd5Mjf5uPo5eDa5+Hrz9vt6e/qosO/GvjJ+sj5F/sC+uMHcCCoBAAh+QQACgABACwAAAAAgAAPAAAD/wi0C/4ixgeloM5erDHonOWBFFlJoxiiTFtqWwa/Jhx/86nKdc7vuJ6mxaABbUaUTvljBo++pxO5nFQFxMY1aW12pV+q9yYGk6NlW5bAPQuh7yl6Hg/TLeu2fssf7/19Zn9meYFpd3J1bnCMiY0RhYCSgoaIdoqDhxoFnJ0FFAOhogOgo6GlpqijqqKspw+mrw6xpLCxrrWzsZ6duL62qcCrwq3EsgC0v7rBy8PNorycysi3xrnUzNjO2sXPx8nW07TRn+Hm3tfg6OLV6+fc37vR7Nnq8Ont9/Tb9v3yvPu66Xvnr16+gvwO3gKIIdszDw65Qdz2sCFFiRYFVmQFIAEBACH5BAAKAAIALAAAAACAAA8AAAP/CLQL/qw9J2qd1AoM9MYeF4KaWJKWmaJXxEyulI3zWa/39Xh6/vkT3q/DC/JiBFjMSCM2hUybUwrdFa3Pqw+pdEVxU3AViKVqwz30cKzmQpZl8ZlNn9uzeLPH7eCrv2l1eXKDgXd6Gn5+goiEjYaFa4eOFopwZJh/cZCPkpGAnhoFo6QFE6WkEwOrrAOqrauvsLKttKy2sQ+wuQ67rrq7uAOoo6fEwsjAs8q1zLfOvAC+yb3B0MPHD8Sm19TS1tXL4c3jz+XR093X28ao3unnv/Hv4N/i9uT45vqr7NrZ89QFHMhPXkF69+AV9OeA4UGBDwkqnFiPYsJg7jBktMXhD165jvk+YvCoD+Q+kRwTAAAh+QQACgADACwAAAAAgAAPAAAD/wi0C/6sPRfJdCLnC/S+nsCFo1dq5zeRoFlJ1Du91hOq3b3qNo/5OdZPGDT1QrSZDLIcGp2o47MYheJuImmVer0lmRVlWNslYndm4Jmctba5gm9sPI+gp2v3fZuH78t4Xk0Kg3J+bH9vfYtqjWlIhZF0h3qIlpWYlJpYhp2DjI+BoXyOoqYaBamqBROrqq2urA8DtLUDE7a1uLm3s7y7ucC2wrq+wca2sbIOyrCuxLTQvQ680wDV0tnIxdS/27TND+HMsdrdx+fD39bY6+bX3um14wD09O3y0e77+ezx8OgAqutnr5w4g/3e4RPIjaG+hPwc+stV8NlBixAzSlT4bxqhx46/MF5MxUGkPA4BT15IyRDlwG0uG55MAAAh+QQACgAEACwAAAAAgAAPAAAD/wi0C/6sPRfJpPECwbnu3gUKH1h2ZziNKVlJWDW9FvSuI/nkusPjrF0OaBIGfTna7GaTNTPGIvK4GUZRV1WV+ssKlE/G0hmDTqVbdPeMZWvX6XacAy6LwzAF092b9+GAVnxEcjx1emSIZop3g16Eb4J+kH+ShnuMeYeHgVyWn56hakmYm6WYnaOihaCqrh0FsbIFE7Oytba0D7m6DgO/wAMTwcDDxMIPx8i+x8bEzsHQwLy4ttWz17fJzdvP3dHfxeG/0uTjywDK1Lu52bHuvenczN704Pbi+Ob66MrlA+scBAQwcKC/c/8SIlzI71/BduysRcTGUF49i/cw5tO4jytjv3keH0oUCJHkSI8KG1Y8qLIlypMm312ASZCiNA0X8eHMqPNCTo07iyUAACH5BAAKAAUALAAAAACAAA8AAAP/CLQL/qw9F8mk8ap8hffaB3ZiWJKfmaJgJWHV5FqQK9uPuDr6yPeTniAIzBV/utktVmPCOE8GUTc9Ia0AYXWXPXaTuOhr4yRDzVIjVY3VsrnuK7ynbJ7rYlp+6/u2vXF+c2tyHnhoY4eKYYJ9gY+AkYSNAotllneMkJObf5ySIphpe3ajiHqUfENvjqCDniIFsrMFE7Sztre1D7q7Dr0TA8LDA8HEwsbHycTLw83ID8fCwLy6ubfXtNm40dLPxd3K4czjzuXQDtID1L/W1djv2vHc6d7n4PXi+eT75v3oANSxAzCwoLt28P7hC2hP4beH974ZTEjwYEWKA9VBdBixLSNHhRPlIRR5kWTGhgz1peS30l9LgBojUhzpa56GmSVr9tOgcueFni15styZAAAh+QQACgAGACwAAAAAgAAPAAAD/wi0C/6sPRfJpPGqfKsWIPiFwhia4kWWKrl5UGXFMFa/nJ0Da+r0rF9vAiQOH0DZTMeYKJ0y6O2JPApXRmxVe3VtSVSmRLzENWm7MM+65ra93dNXHgep71H0mSzdFec+b3SCgX91AnhTeXx6Y2aOhoRBkllwlICIi49liWmaapGhbKJuSZ+niqmeN6SWrYOvIAWztAUTtbS3uLYPu7wOvrq4EwPFxgPEx8XJyszHzsbQxcG9u8K117nVw9vYD8rL3+DSyOLN5s/oxtTA1t3a7dzx3vPwAODlDvjk/Orh+uDYARBI0F29WdkQ+st3b9zCfgDPRTxWUN5AgxctVqTXUDNix3QToz0cGXIaxo32UCo8+OujyJIM95F0+Y8mMov1NODMuPKdTo4hNXgMemGoS6HPEgAAIfkEAAoABwAsAAAAAIAADwAAA/8ItAv+rD0XyaTxqnyr9pcgitpIhmaZouMGYq/LwbPMTJVE34/Z9j7BJCgE+obBnAWSwzWZMaUz+nQQkUfjyhrEmqTQGnins5XH5iU3u94Crtpfe4SuV9NT8R0Nn5/8RYBedHuFVId6iDyCcX9vXY2Bjz52imeGiZmLk259nHKfjkSVmpeWanhhm56skIyABbGyBROzsrW2tA+5ug68uLbAsxMDxcYDxMfFycrMx87Gv7u5wrfTwdfD2da+1A/Ky9/g0OEO4MjiytLd2Oza7twA6/Le8LHk6Obj6c/8xvjzAtaj147gO4Px5p3Dx9BfOQDnBBaUeJBiwoELHeaDuE8uXzONFu9tE2mvF0KSJ00q7Mjxo8d+L/9pRKihILyaB29esEnzgkt/Gn7GDPosAQAh+QQACgAIACwAAAAAgAAPAAAD/wi0C/6sPRfJpPGqfKv2HTcJJKmV5oUKJ7qBGPyKMzNVUkzjFoSPK9YjKHQQgSve7eeTKZs7ps4GpRqDSNcQu01Kazlwbxp+ksfipezY1V5X2ZI5XS1/5/j7l/12A/h/QXlOeoSGUYdWgXBtJXEpfXKFiJSKg5V2a1yRkIt+RJeWk6KJmZhogKmbniUFrq8FE7CvsrOxD7a3Drm1s72wv7QPA8TFAxPGxcjJx8PMvLi2wa7TugDQu9LRvtvAzsnL4N/G4cbY19rZ3Ore7MLu1N3v6OsAzM0O9+XK48Xn/+notRM4D2C9c/r6Edu3UOEAgwMhFgwoMR48awnzMWOIzyfeM4ogD4aMOHJivYwexWlUmZJcPXcaXhKMORDmBZkyWa5suE8DuAQAIfkEAAoACQAsAAAAAIAADwAAA/8ItAv+rD0XyaTxqnyr9h03gZNgmtqJXqqwka8YM2NlQXYN2ze254/WyiF0BYU8nSyJ+zmXQB8UViwJrS2mlNacerlbSbg3E5fJ1WMLq9KeleB3N+6uR+XEq1rFPtmfdHd/X2aDcWl5a3t+go2AhY6EZIZmiACWRZSTkYGPm55wlXqJfIsmBaipBROqqaytqw+wsQ6zr623qrmusrATA8DBA7/CwMTFtr24yrrMvLW+zqi709K0AMkOxcYP28Pd29nY0dDL5c3nz+Pm6+jt6uLex8LzweL35O/V6fv61/js4m2rx01buHwA3SWEh7BhwHzywBUjOGBhP4v/HCrUyJAbXUSDEyXSY5dOA8l3Jt2VvHCypUoAIetpmJgAACH5BAAKAAoALAAAAACAAA8AAAP/CLQL/qw9F8mk8ap8q/YdN4Gj+AgoqqVqJWHkFrsW5Jbzbee8yaaTH4qGMxF3Rh0s2WMUnUioQygICo9LqYzJ1WK3XiX4Na5Nhdbfdy1mN8nuLlxMTbPi4be5/Jzr+3tfdSdXbYZ/UX5ygYeLdkCEao15jomMiFmKlFqDZz8FoKEFE6KhpKWjD6ipDqunpa+isaaqqLOgEwO6uwO5vLqutbDCssS0rbbGuMqsAMHIw9DFDr+6vr/PzsnSx9rR3tPg3dnk2+LL1NXXvOXf7eHv4+bx6OfN1b0P+PTN/Lf98wK6ExgO37pd/pj9W6iwIbd6CdP9OmjtGzcNFsVhDHfxDELGjxw1Xpg4kheABAAh+QQACgALACwAAAAAgAAPAAAD/wi0C/6sPRfJpPGqfKv2HTeBowiZjqCqG9malYS5sXXScYnvcP6swJqux2MMjTeiEjlbyl5MAHAlTEarzasv+8RCu9uvjTuWTgXedFhdBLfLbGf5jF7b30e3PA+/739ncVp4VnqDf2R8ioBTgoaPfYSJhZGIYhN0BZqbBROcm56fnQ+iow6loZ+pnKugpKKtmrGmAAO2twOor6q7rL2up7C/ssO0usG8yL7KwLW4tscA0dPCzMTWxtXS2tTJ297P0Nzj3t3L3+fmzerX6M3hueTp8uv07ezZ5fa08Piz/8UAYhPo7t6+CfDcafDGbOG5hhcYKoz4cGIrh80cPAOQAAAh+QQACgAMACwAAAAAgAAPAAAD5wi0C/6sPRfJpPGqfKv2HTeBowiZGLORq1lJqfuW7Gud9YzLud3zQNVOGCO2jDZaEHZk+nRFJ7R5i1apSuQ0OZT+nleuNetdhrfob1kLXrvPariZLGfPuz66Hr8f8/9+gVh4YoOChYhpd4eKdgwFkJEFE5KRlJWTD5iZDpuXlZ+SoZaamKOQp5wAm56loK6isKSdprKotqqttK+7sb2zq6y8wcO6xL7HwMbLtb+3zrnNycKp1bjW0NjT0cXSzMLK3uLd5Mjf5uPo5eDa5+Hrz9vt6e/qosO/GvjJ+sj5F/sC+uMHcCCoBAA7AAAAAAAAAAAA"

关闭按钮
style="width:18px;height:18px;background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABIAAAASBAMAAACk4JNkAAAALVBMVEUAAAAzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMFCKs1AAAADnRSTlMAAwGYnKilo/Tpjn6RhfLwgGgAAAB3SURBVAjXY7hxiAEEhLsZ+p4oABmMcS8Z7N45AVmi714xiL8DCjLGvTNiYKx75wQUeqzAABJUBAkxgARdwUIgwXcgIbAgVAik8QmEJQqUdYIKmYEFQWYp5gEFIcaLAQUhxjOCBP3AZokBXdAHMgso+JJh5yKoSwHamjhPbLDp2gAAAABJRU5ErkJggg==)"

上下按钮
img src="data:image/gif;base64,R0lGODlhFQAJAIAAACMtMP///yH5BAEAAAEALAAAAAAVAAkAAAIXjI+AywnaYnhUMoqt3gZXPmVg94yJVQAAOw=="

向下按钮
style="width:20px;height:20px;background: #ffffff url('data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZlcnNpb249IjEuMSIgeD0iMTJweCIgeT0iMHB4IiB3aWR0aD0iMjRweCIgaGVpZ2h0PSIzcHgiIHZpZXdCb3g9IjAgMCA2IDMiIGVuYWJsZS1iYWNrZ3JvdW5kPSJuZXcgMCAwIDYgMyIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+PHBvbHlnb24gcG9pbnRzPSI1Ljk5MiwwIDIuOTkyLDMgLTAuMDA4LDAgIi8+PC9zdmc+') no-repeat 100% center;"

笔形
style="width:18px;height:18px;background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIQAAACECAMAAABmmnOVAAAAA3NCSVQICAjb4U/gAAAACXBIWXMAAAeHAAAHhwFd+hRDAAAAGXRFWHRTb2Z0d2FyZQB3d3cuaW5rc2NhcGUub3Jnm+48GgAAAHVQTFRFAAAAOTk5MzMzOzs7Nzc3QUFBQEBAPz8/Pj4+QUFBQEBAPz8/Pj4+QUFBQEBAPz8/QUFBPj4+Pz8/Pz8/Pj4+Pz8/Pz8/Pz8/Pj4+Pz8/Pj4+Pz8/Pz8/Pz8/Pz8/Pz8/Pj4+Pz8/Pz8/Pz8/Pz8/QEBAPz8/n3QmjwAAACZ0Uk5TAAkKDQ4zODk6OzxBQkNERUusrbG0tba7vL3Excbu8fL19fb3+PgucqJgAAACqklEQVR42sXc23LCIBAGYKy2pgft0WpP2vTA+z9i0+goCZAs7O7P3oWZTL5ZYAh7sca0MXmYG3jM7yfu4/TV1jdow01tX6cdg4UrGoN1FNM3a+GK1nBSzPYGrOJgsPZt1hrerYUrjoa9wjHgFI7B2veZWVk3tpCdWm07H30y8+4AIhedPFj7cW7wioABrggawIqIAaroGbYXzlGCUvQNnc0IUgwaQIoRA0QxagAoCAZ1BcmgrCAaVBVkg6IiwaCmSDIoKRINKopkg4IiwyCuyDIIKzINoopsg6CCYRBTsAxCCqZBRLGo2RcrtkLAwFaIGJgKIQNLIWZgKAQN2QpRg1dKoCmEDVkKcUOGQsGQrFAxJCqUDEkKNUOCQtFAVqgaiAplg69YFDAQFADDqAJiGFGADI1iF1XADAOKvqHSLApHFFBDRAE2BBVwQ0BRwOApfn8LGDxFEcOQAmeIK5CGmAJrCCvQBq8A8r9Zrw08qp6irvAGs/zpIr4XBQxf3nQsyhvwipABrQgbsIqYAamIG3CKnqH+LKDoGXbVwD84zDB4E4AZ4IqgAayIGKCKqMGYS5RiwOArlgUMnuJrWcAAUYwaAAqCQV1BMigriAZVBdmgqEgwqCmSDEqKRIOKItmgoMgwiCv6hkvaa6KKTIOoItsgqGAYxBQsg5CCaRBRsA0CCgEDWyFiYCqEDCyFmIGhEDRkK0QNmQphQ5ZC3JChUDAkK1QMiQolQ5JCzZCguNUzkBV3P4oGokLZQFKoGwgKgGFUATGMKECGQQXMYMxVTAE0RBVQQ0QBNgQVcENI8QwoBo8cUiszWYPz4OVi3bQ9cBQoQ0exblsvTDZwg6PYHNo/tE0XmvVwa4BxWBentgtnL+A8HHPxcnYaaBRoQ6twDY3iEW5oFI8Hwx/QxSE448b+MwAAAABJRU5ErkJggg==);background-color: rgba(255, 255, 255, 0.8);"

三横
style="width:20px;height:20px;background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADUAAADcBAMAAAAig/QJAAAAA3NCSVQICAjb4U/gAAAACXBIWXMAAFtDAABbQwH5xg68AAAAGXRFWHRTb2Z0d2FyZQB3d3cuaW5rc2NhcGUub3Jnm+48GgAAAB5QTFRFAAAA////cXFxaWlp////ZmZmnJycoaGhpqam////1D9b6wAAAAV0Uk5TAAgJERExZxYzAAAAYklEQVRYw+3WoQ2AUBAE0SsBOiBUQEIDCArA4FFoHBaJxNItFYz/x5+xz282VmwJTdM0rRzbsS1e7Pm9zdgUVn491rkFmqZpSezEjqo/Sos1HoAEjdjgFmiapiWxG7tq/igfnYteFlnOWZEAAAAASUVORK5CYII=);background-size: auto 100%;"

粗下划线
style="width: 1.8em;height: 1.8em;background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAJAAAAB0CAQAAADAmnOnAAAAAnNCSVQICFXsRgQAAAAJcEhZcwAAWwEAAFsBAXkZiFwAAAAZdEVYdFNvZnR3YXJlAHd3dy5pbmtzY2FwZS5vcmeb7jwaAAAGaklEQVR42u3cfUxVZRwH8O8FRERRfNfKt4zM2UzNMszZFPMPW5KWzizJ0JJWitOU3mYs54ZuNRk6zblSaebUnKllSpopaRorJiqmtjRNK4sNEBR5+fbH45ELwrnn5Tnn3gPP7/cv9/7O/eyc5zyvAF6PrlgAFTrRHcQmtFIQekDEYXRRFA3GzP4gCOI39FcaDcQ7g24BEUUYrTz0gIhKvKZE9IAIIhNhSkUPiNiGaOWiB0Tko4eS0QMi/sQQZaMHRJRivNLRAyKqkKZ89IAIYg1aKCDq5l60U0D6WYDeCkg/r2KEAtLPG5iqgPSzBukKKFB+ikgFpJ+56KyA9PMcHjBXYYwjGRmyQMR/GGWmAqVnNV4N4TuIICowPXhA1ZgR0o+Y6Yk1uTyVeD7E26Da3GpsYk0iTwQ3kSS5nbLboAj0wnBMwGwsRhaysRO5yEMe8iJP2bjig+joIlALbhE86xguCWUgXkYmduMMbjrQVhLEWfRzCagldwmelfTZhOmM8ViGXJQ7hFI3iwK906SUieLXgifTFs9DeA/HUOMKjP87LdlhoFb8RvB8ZJHHhxHIxEWXYfzzY0Q4BtSG3wueDyzhxCAFvwSRJuA7zeYXx/CQ4LEy/3sPlqMkBHBEHkN36UBt+YPgWWgapzfWoiJkcERewECpQB2YR5I1nG/6PbUcN0IMR2QJxhkEWsi0gPkjSVYzxRROS6SjLCRxGplYa+QPq2goqjnTFM8wFIQwjpZZCJcDVMmppu6dTNf7OFbzEDoFAKrcx5yA+ZIJnh444hEckcfRUxcoXe5wMwH/eIqHIK7gUbeAklHlOR4xCElyA2iWR3mIGixyHijDoziMqRw8xflH7H2v8vTjKfIyhzoLNNurPM+xVHRksp0EesabbU84M1hDklVMo885oMdcmhGUnO25W9w7xUx0sh8Ui/Ne5InjCcFTwL4BetI2gbZ5kedZreXZwjYBx2K2gKZ7DydMa3mqRcvjJFAcrnmNJ5ZfiXunlBMNzgfZAPrSazx9eVzwnOB9hmcULQM96TWeCSwRPFv9Wx6ngMKQ3zRaHqeAXvQSTzttNfgaJ5leOLQE5EOhd3j6MF/wnGSchZVVS0Bj5f6ELhzKiZzLdC7nOm7nAebzPIvqZKHF7x7DfwXPNsZYWpu3BLTD/iptPFO4mnt5muWGVg0uW6ozj5UBWh4ngPpYHZxG8nGmcTPPsJpmwzxQK34mPlrGKTY2UFkAWmJ+y8wopnM/y/QEilnAQ9zJbGZxMedzBif559EF5mr24s/ie3/nIFtb8CwAnTV+md04hzm83hBIFQu5mUv5Op/mQMbK3YKXyGJR5Vt2NPqzZAH1N3aJrTmNu1lRn6WUOVzGJA5hlHN7FFNFy0N+yAjbu1xNA70duFOWwPXaeFmLIu7gmxxm5oKtAUVxvahYzhfMVZAFdES/GU7m6bo0Z7mMw2n7jLsxoB78SVQ9T9OHfeUARfluNv5QzeNFf5pCvssBbm4DHsm/ReXvaOGkhhyg+MbeU3N4pZamhGs53O190m/wprZ/0tKDLAdo7p3f4GMSL9Ti/MpZbO32RvIofiKqX2eS1QpSgMI+r//5+7mvFucgE+nQf9TQA7qbR0X9PzjUegUpQG1O1F04eau2j3OAw4JzFGGE9nDvYQc7FaQARRf7rwwc1nDOcbLtbeUWgVK0vtYK2jw5LwMo2nf7c8navVPORWY7fbKAorlRXMMNJtuvIAMoTusKLhXzc2QO74UrcSfQXdodfEnOwy0D6GGxY3qPNj+XBNeiPlCCNs+TY3y05ThQ7EiwK4+JCztjdJTsBFCaNtpaJe9AlgSgsVN6aQOJzWwLBAcokqu1lucVmRUkAC2eeElsKE+F66EBdWOuyXkeF4EYT7LCzZanPtBoXtXmeTrJriAD6AmW8SkgWEC3W541bCm/ggygRxiPIMWSB1cInAqTRyJcnw8KUrD7rXmewY5VaAJA++W3PE0JKMPUPE8MEpoXkLnBcBL+wqpmBWQiemIXCCqghiIcadoxvvYbFFD9GIDDtb9s3EkF5B9RyKj7jy0UkH+MvnNBXAFp0QEbGjoCqoC0mNPwL1NACshYhKUqIN2YvFEB6ca0LxSQAlJACkgBKSAFpICsADXdVEAKSAEpIAWkgBSQAlJACkgBKaDgA41hc8vUXHM3UPOLVQpIAbkH9D87oz0rvnJrOgAAAABJRU5ErkJggg==);"

</pre></div><pre>
JS能从canvas.toDataURL()、FileReader.readAsDataURL()、window.btoa()等方法获取到base64字符串

【 window.btoa(str) window.atob(base64Str) 】
let decodedData = window.atob(encodedData);      // 解码通过base64编码的字符串数据
let encodedData = window.btoa(stringToEncode);   // 从二进制数据字符串创建一个base64编码的ASCII字符串
参数为一个字符串,其字符分别表示要编码为ASCII的二进制数据的单个字节
返回值为一个包含stringToEncode的Base64表示的字符串

图片的base64数据只对'data:image/png;base64,'后面的内容解码
window.btoa()方法编码一个可能在传输过程中出现问题的数据,并且在接受数据之后使用window.atob()方法来将数据解码得到源数据。例如可以把ASCII里面数值0到31的控制字符进行编码、传输和解码

base64转码的对象只能是字符串,atob()和btoa()均使用字符串,还可使用ArrayBuffers,btoa方法仅支持ASCII编码

</pre><pre class="js">
var str = 'javascript';
window.btoa(str)                   //编码结果 "amF2YXNjcmlwdA=="
window.atob("amF2YXNjcmlwdA==")    //解码结果 "javascript"

</pre><pre>
【 汉字转码 】
使用window.btoa对Unicode字符串进行编码都会触发一个字符越界的异常,可以先把Unicode字符串转换为UTF-8编码

</pre><pre class="js">
var str = "China,中国";
window.btoa(window.encodeURIComponent(str))   // "Q2hpbmElRUYlQkMlOEMlRTQlQjglQUQlRTUlOUIlQkQ="
window.decodeURIComponent(window.atob('Q2hpbmElRUYlQkMlOEMlRTQlQjglQUQlRTUlOUIlQkQ='))  // "China,中国"

function utf8_to_b64(str) {
  return window.btoa(unescape(encodeURIComponent(str)));
}

function b64_to_utf8(str) {
  return decodeURIComponent(escape(window.atob(str)));
}

// Usage:
utf8_to_b64('✓ à la mode');                    // JTI1dTI3MTMlMjUyMCUyNUUwJTI1MjBsYSUyNTIwbW9kZQ==
b64_to_utf8('JTI1dTI3MTMlMjUyMCUyNUUwJTI1MjBsYSUyNTIwbW9kZQ=='); // "✓ à la mode"

utf8_to_b64('I \u2661 Unicode!');              // SSUyNTIwJTI1dTI2NjElMjUyMFVuaWNvZGUlMjUyMQ==
b64_to_utf8('SSUyNTIwJTI1dTI2NjElMjUyMFVuaWNvZGUlMjUyMQ==');     // "I ♡ Unicode!"

</pre>【 把base64转成Uint8Array创建Blob对象 】<pre class="js">
function base64toBlob(base64Str, sliceSize) {
  sliceSize = sliceSize || 512;
  var byteCharacters = atob(base64Str.substring(base64Str.indexOf(',') + 1));
  var byteArrays = [];
  for (var offset = 0; offset < byteCharacters.length; offset += sliceSize) {
    var slice = byteCharacters.slice(offset, offset + sliceSize);
    var byteNumbers = new Array(slice.length);
    for (var i = 0; i < slice.length; i++) {
      byteNumbers[i] = slice.charCodeAt(i);   // 二进制字符串转ascii码
    }
    var byteArray = new Uint8Array(byteNumbers);
    byteArrays.push(byteArray);
  }
  var blob = new Blob(byteArrays, {type: base64Str.substring(base64Str.indexOf(':') + 1, base64Str.indexOf(';'))});
  return blob;
};

var base64Str = 'data:image/gif;base64,R0lGODlhFQAJAIAAACMtMP///yH5BAEAAAEALAAAAAAVAAkAAAIXjI+AywnaYnhUMoqt3gZXPmVg94yJVQAAOw==';
console.log(base64toBlob(base64Str));  // Blob(64) {size: 64, type: "image/gif"}

</pre>base64通过atob转成二进制字符串,再通过charCodeAt转成Blob对象,再将Blob对象通过window.URL.createObjectURL来提供下载的图片文件<pre class="js">
// 不通过input标签的type=file的形式来实现本地文件选择,而是直接指定自己想要上传的文件
// 通过将产品内部的图片转成base64,在需要使用的时候再转换回图片,这种方式不需要产品附带图片文件,产品最终只有一个js文件,极大地减少了产品尺寸,以xlsx文件为例

function createFile(base64Str){
  var bytes = window.atob(base64Str.substring(base64Str.indexOf(',') + 1));//对base64解码,截取后面部分
  var n = bytes.length;
  var u8arr = new Uint8Array(n);
  while(n--){
    u8arr[n] = bytes.charCodeAt(n);                         // 将编码转换成Unicode编码,转成Uint类型
  }
  return new Blob([u8arr],{type: base64Str.substring(base64Str.indexOf(':') + 1, base64Str.indexOf(';'))});
}
var base64Str = "data:image/gif;base64,iVBORw0KG ... ";     // str接收来自后端返回的base64
var myFile = createFile(base64Str);                         // 返回一个base64转换来的Blob对象,文件对象
console.log(myFile);                                        // Blob {size: 3951, type: "image/gif"}
var newname = 'new.gif';                                    // 设置保存的文件名

if(navigator.appVersion.toString().indexOf(".NET")>0){      // 兼容IE
  window.navigator.msSaveBlob(myFile, newname);
}else{
  var a = document.createElement("a");
  a.href = window.URL.createObjectURL(myFile);              // 下载路径指向这个文件对象
  a.download = newname;
  a.click();                                                // 指定页面自动下载文件
  document.body.appendChild(a);
}

</pre>文件转base64 - 图片转base64<pre class="js">
<input type="file" id="fileElem" multiple  style="display:none" onchange="handleFiles(this.files)">
<a href="#" id="fileSelect">Select some files translate to base64 data</a>
<div id="preview"></div>

function handleFiles(files){
  if (!files.length) return preview.innerHTML = "No files selected!";
  preview.innerHTML = "";
  [].forEach.call(files, file => {
      var reader = new FileReader();
      reader.onload = function(e) {
        preview.innerHTML = file.name + 'base64数据： + e.target.result;
      };
      reader.readAsDataURL(file);
  })
}

var fileElem = document.getElementById("fileElem");
document.getElementById("fileSelect").addEventListener("click", function (e) {
  fileElem && fileElem.click();
  e.preventDefault();          // prevent navigation to "#"
}, false);

</pre>
</div>

<div id="Blob">
<h3>Blob对象 - 原始数据类型 - Blob全称Binary Large Object：二进制类型的大对象</h3><pre>
js有一个底层的Blob对象,Blob对象表示一个不可变(immutable)、原始数据(raw data)的(包含有只读原始数据)类文件对象,Blob表示的不一定是JS原生格式的数据。Blob对象相当于一个容器,可以用于存放二进制数据

File接口基于Blob,继承Blob的功能并将其扩展使其支持用户系统上的文件

图片可以是blob,视频可以是blob,直播也可以是blob

通过canvas.toBlob()构造blob对象
var canvas = document.getElementById("canvas");
canvas.toBlob(function(blob){
  console.log(blob);
});

【 构造函数 】
var blob = new Blob( array[, options]);
blob的内容由参数数组中给出的值的串联组成

参数array,包含了将要添加到Blob对象中的数据,是由任意多个ArrayBuffer、ArrayBufferView(TypedArray和DataView)、Blob、DOMString等对象构成的数组,或它们的各种组合,它将会被放进Blob,DOMStrings会被编码为UTF-8

参数options是一个可选的BlobPropertyBag字典,它可能会指定如下两个属性：
type,默认"",代表了将会被放入到blob中的数组内容的MIME类型。
endings,默认值为"transparent",用于指定包含行结束符\n的字符串如何被写入,可能值：
"native"代表行结束符会被更改为适合宿主操作系统文件系统的换行符
"transparent"代表会保持blob中保存的结束符不变

var myBlob= new Blob(arrayBuffer);

var myFile=new Blob([u8arr],{type : 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'});
第一个参数是一个Uint8Array的TypedArray类型,它是一个8比特的无符号的int数组,通过base64转换而来

在JS中DOMString就是String,规范中DOMString指UTF-16字符串,而JS正是使用了这种编码的字符串,因此在Ajax中DOMString就等同于JS中的普通字符串

blob与ArrayBuffer的区别是除了raw bytes以外它还提供了mime type作为元数据,但它依然是无法直接被读写的

ArrayBuffer似乎是Blob的底层,Blob内部使用了ArrayBuffer,并且构造好的一个Blob实体就是一个raw data。既然用途差不多,那为什么一个Blob一个ArrayBuffer呢？当然设计Blob和ArrayBuffer的目的是不同的,因为ArrayBuffer更底层,所以它专注的是细节,比如说按字节读写文件。相反Blob更像一个整体,它不在意细节：就是那么一个原始的Binary Data,只要来回传输就行了

【 属性和方法 】
Blob对象包含两个只读属性(size和type)以及一个方法slice([start,[end,[contentType]]])。十分符合Blob的定义,不可变的原始数据的类文件对象。其中由Blob所延伸出的的Blob URL在实际场景中常会用到

size属性
类型:unsigned long long,表示可以很大的数值,Blob对象中所包含数据的大小,字节为单位,只读

type属性
类型:DOMString	一个字符串,表明该Blob对象所包含数据的MIME类型,例如image/jpeg,如果类型未知则该值为空字符串。 只读。

Blob.slice(start:number, end:number, contentType:string)
返回一个新的Blob对象,包含了原Blob对象中指定范围内的数据,可以实现文件的分割
start：开始索引,默认为0,如果start参数的值比源Blob对象的size属性值还大则返回的Blob对象的size值为0即不包含任何数据
end：截取结束索引(不包括end)
contentType：新Blob的MIME类型,默认为空字符串

</pre><pre class="js">
var domstr = ['<a id="a"><b id="b">hey!</b></a>'];    // 一个包含DOMString的数组
var blob = new Blob(domstr, {type : 'text/html'});    // 得到blob
console.log(blob);                                    // Blob {size: 32, type: "text/html"}

var debug = {hello: "world"};
var blob = new Blob([JSON.stringify(debug, null, 2)], {type : 'application/json'});
console.log(blob);                                    // Blob {size: 22, type: "application/json"}

// 使用Blob创建一个指向类型数组的URL
var typedArray = GetTheTypedArraySomehow();
var blob = new Blob([typedArray], {type: "application/octet-binary"}); // 传入一个合适的MIME类型
var url = URL.createObjectURL(blob);
// 会产生一个类似blob:d3958f5c-0777-0845-9dcf-2cb28783acaf的URL字符串,可以像使用一个普通URL那样使用它,比如用在img.src上

</pre>从Blob中读取内容的唯一方法是使用FileReader,将Blob的内容作为类型数组、字符串或data URL读取<pre class="js">
var reader = new FileReader();
reader.addEventListener("loadend", function() {
  // reader.result包含转化为类型数组的blob
});
reader.readAsArrayBuffer(blob);

</pre><pre class="js">
// 将字符串转换成Blob对象
var blob = new Blob(["Hello World!"], { type: 'text/plain' });
console.info(blob);                            // Blob(12) {size: 12, type: "text/plain"}
console.info(blob.slice(1, 3, 'text/plain'));  // Blob(2) {size: 2, type: "text/plain"}
var blob = new Blob(['中文字符串'], { type: 'text/plain' });
console.log(blob);                             // Blob(15) {size: 15, type: "text/plain"}

// 将Blob对象转换成字符串,使用FileReader的readAsText方法
var blob = new Blob(['中文字符串'], { type: 'text/plain' });
var reader = new FileReader();
reader.onload = function (e) {
  console.info(reader.result);                 // 中文字符串
}
reader.readAsText(blob, 'utf-8');

// 将TypeArray转换成Blob对象,注意必须[]的包裹
var array = new Uint16Array([97, 32, 72, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100, 33]);
var blob1 = new Blob([array], { type: "application/octet-binary" });
var blob2 = new Blob([array]);
console.info(blob1);                           // Blob(28) {size: 28, type: "application/octet-binary"}
console.info(blob2);                           // Blob(28) {size: 28, type: ""}

// ArrayBuffer转Blob,注意必须包裹[]
var buffer = new ArrayBuffer(32);
var blob = new Blob([buffer]);

//将Blob对象转换成ArrayBuffer使用FileReader的readAsArrayBuffer方法
var blob = new Blob(['中文字符串'], { type: 'text/plain' });
var reader = new FileReader();
reader.readAsArrayBuffer(blob);
reader.onload = function (e) {
  var result = reader.result;
  console.info(result);     // ArrayBuffer(15) {}
  //经常会遇到的异常Uncaught RangeError: byte length of Int16Array should be a multiple of 2
  //var buf = new int16array(reader.result);
  //console.info(buf);

  //将ArrayBuffer转换成TypedArray,再读取成string
  var buf = new Uint8Array(result);
  console.info(buf);   // Uint8Array(15) [228, 184, 173, 230, 150, 135, 229, 173, 151, 231, 172, 166, 228, 184, 178]
  reader.readAsText(new Blob([buf]), 'utf-8');
  reader.onload = function () {
    console.info(reader.result);     // 中文字符串

    //将ArrayBuffer转换成DataView,再读取成string
    var buf = new DataView(result);
    console.info(buf);               // DataView(15) {}
    reader.readAsText(new Blob([buf]), 'utf-8');
    reader.onload = function () {
      console.info(reader.result);   //中文字符串
    };
  };
}

</pre><pre class="js">
function blobSlice(blob,startByte,endByte){
  if(blob.slice){
    return  blob.slice(startByte,endByte);
  }else if(blob.mozSlice){                         // 兼容firefox
    return  blob.mozSlice(startByte,endByte);
  }else if(blob.webkitSlice){                      // 兼容webkit
    return  blob.webkitSlice(startByte,endByte);
  }
  return null;
}

</pre><pre>
【 Blob应用场景 】
1.分片上传
File接口基于Blob,继承了Blob的功能并进行了扩展,可以像使用Blob一样使用File对象。通过Blob.slice方法可以将大文件分片,轮循向后台提交各文件片段,即可实现文件的分片上传。

分片上传逻辑：
获取要上传文件的File对象,根据chunk(每片大小)对文件进行分片
通过post方法轮循上传每片文件,其中url中拼接querystring用于描述当前上传的文件信息;post body中存放本次要上传的二进制数据片段
接口每次返回offset,用于执行下次上传

以下是文件分片上传前端的简单实现,当然此功能还可以更加完善,如后台需要对合并后的文件大小进行校验;或者前端加密文件,全部上传完毕后后端解密校验等

</pre><pre class="js">
initUpload();

//初始化上传
function initUpload() {
  var chunk = 100 * 1024;   //每片大小
  var input = document.querySelector("input[type=file]");
  input.onchange = function (e) {
    var file = this.files[0];
    var query = {};
    var chunks = [];
    if (!!file) {
      var start = 0;
      for (var i = 0; i < Math.ceil(file.size / chunk); i++) {
        var end = start + chunk;
        chunks[i] = file.slice(start , end);   //文件分片
        start = end;
      }

      // 采用post方法上传文件,url query上拼接以下参数用于记录上传偏移,post body中存放本次要上传的二进制数据
      query = {
        fileSize: file.size,
        dataSize: chunk,
        nextOffset: 0
      }

      upload(chunks, query, successPerUpload);
    }
  }
}

// 每片上传成功后执行
function successPerUpload(resp, chunks, query) {
  if (resp.isFinish === true) {
    alert("上传成功");
  } else {
    query.offset = resp.offset;
     (chunks, query, successPerUpload);
  }
}

// 执行上传
function upload(chunks, query, cb) {
  var queryStr = Object.getOwnPropertyNames(query).map(key => {
    return key + "=" + query[key];
  }).join("&");
  var xhr = new XMLHttpRequest();
  xhr.open("POST", "http://xxxx/opload?" + queryStr);
  xhr.overrideMimeType("application/octet-stream");

  //获取post body中二进制数据
  var index = Math.floor(query.nextOffset / query.dataSize);
  getFileBinary(chunks[index], function (binary) {
    xhr.sendAsBinary ? xhr.sendAsBinary(binary) : xhr.send(binary);
  });

  xhr.onreadystatechange = function (e) {
    if (xhr.readyState === 4) {
      if (xhr.status === 200) {
        var resp = JSON.parse(xhr.responseText);
        // resp = { isFinish:false, offset:100*1024 };   // 接口返回nextoffset
        if (typeof cb === "function") cb.call(this, resp, chunks, query)
      }
    }
  }
}

// 获取文件二进制数据
function getFileBinary(file, cb) {
  var reader = new FileReader();
  reader.readAsArrayBuffer(file);
  reader.onload = function (e) {
    if (typeof cb === "function") cb.call(this, this.result);
   }
}

</pre><pre>
2.通过url下载文件
window.URL对象可以为Blob对象生成一个网络地址,结合a标签的download属性,可以实现点击url下载文件,同理可以将字符串保存为一个文本文件

</pre>把canvas下载为一个图片文件<pre class="js">
var canvas = document.getElementById('canvas');
canvas.toBlob(function(blob){
    var url = URL.createObjectURL(blob);  // 使用createObjectURL生成地址,格式为 blob:null/fd95b806-db11-4f98-b2ce-5eb16b38ba36
    var a = document.createElement('a');
    a.download = 'canvas';
    a.href = url;
    a.click();                  // 模拟a标签点击进行下载
    URL.revokeObjectURL(url);   // 下载后告诉浏览器不再需要保持这个文件的引用了
});

</pre>3.通过XHR请求显示图片<pre class="js">
var xhr = new XMLHttpRequest();
xhr.open("get", "mm1.jpg", true);
xhr.responseType = "blob";
xhr.onload = function() {
  if (this.status == 200) {
    var blob = this.response;                  // this.response也就是请求的返回就是Blob对象
    var img = document.createElement("img");
    img.onload = function(e) {
      window.URL.revokeObjectURL(img.src);     // 清除释放
    };
    img.src = window.URL.createObjectURL(blob);
    eleAppend.appendChild(img);
  }
}
xhr.send();

</pre>4.通过input type=File显示图片<pre class="js">
<input type="file" id="fileElem" multiple accept="image/*"
style="display:none" onchange="handleFiles(this.files)">
<a href="#" id="fileSelect">Select some files</a>
<div id="fileList">
  <p>No files selected!</p>
</div>

window.URL = window.URL || window.webkitURL;

var fileSelect = document.getElementById("fileSelect"),
    fileElem = document.getElementById("fileElem"),
    fileList = document.getElementById("fileList");

fileSelect.addEventListener("click", function (e) {
  if (fileElem) {
    fileElem.click();
  }
  e.preventDefault(); // prevent navigation to "#"
}, false);

function handleFiles(files) {
  if (!files.length) {
    fileList.innerHTML = "<p>No files selected!</p>";
  } else {
    fileList.innerHTML = "";
    var list = document.createElement("ul");
    fileList.appendChild(list);
    for (var i = 0; i < files.length; i++) {
      var li = document.createElement("li");
      list.appendChild(li);

      var img = document.createElement("img");
      img.src = window.URL.createObjectURL(files[i]);
      img.height = 60;
      img.onload = function() {
        window.URL.revokeObjectURL(this.src);
      }
      li.appendChild(img);
      var info = document.createElement("span");
      info.innerHTML = files[i].name + ": " + files[i].size + " bytes";
      li.appendChild(info);
    }
  }
}


</pre>
</div>

<div id="FileList">
<h3>FileList对象：一个或多个File对象组成的类数组</h3><pre>
一个FileList对象通常来自input元素的files属性,可通过这个对象访问到用户所选择的文件,还有可能来自用户的拖放操作DataTransfer

所有type属性为file的input元素都有一个files属性(property),用来存储用户所选择的文件

</pre>使用label元素来触发一个隐藏的file input元素<pre class="js">
<input type="file" id="fileElem" multiple accept="image/*" class="visually-hidden">
<label for="fileElem">Select some files</label>

.visually-hidden {
  position: absolute !important;
  height: 1px;
  width: 1px;
  overflow: hidden;
  clip: rect(1px, 1px, 1px, 1px);
}

input.visually-hidden:focus + label {
  outline: thin dotted;
}

</pre>用ele.click()模拟触发隐藏的fileinput控件<pre class="js">
<input type="file" id="fileElem" multiple accept="image/*" style="display:none" onchange="handleFiles(this.files)">
<button id="fileSelect">Select some files</button>

const fileSelect = document.getElementById("fileSelect"),
fileElem = document.getElementById("fileElem");
fileSelect.addEventListener("click", function (e) {
  if (fileElem) fileElem.click();
}, false);

</pre><pre class="js">
< input id="file" type="file">
var file=document.getElementById('file').files[0];  // 获取到一个FileList对象中的第一个文件(File对象)

< input id="myfiles" multiple type="file">
document.querySelector("#myfiles").onchange = function(){
  var fileInput = this.files;
  var i=0;
  while ( i < files.length) {
    console.log(files[i].name);
    i++;
  }
}

</pre><pre class="js">
var fileInput = document.getElementById("fileinput");
var files = fileInput.files;                                  // files是一个FileList对象,多个file对象的集合,类似NodeList
var allowedTypes = ["image/png", "image/jpeg", "image/gif"];  // 仅允许*.png, *.jpeg *.gif类型的图片文件
for (var i = 0; i < files.length; i++) {
  if (allowedTypes.indexOf(files[i].type) > -1) {
    console.log(files[i].name + " - " + files[i].size + " 字节");
  }
}

</pre><pre class="js">
< input type="file" id="Files" name="files[]" multiple />
<div id="Lists"></div>

// 通过表单file控件访问本地文件
function fileSelect(e) {
  e = e || window.event;
  console.log(e.target === document.querySelector('#Files')); // true
  var files = e.target.files;                                 // FileList Objects,this.files
  console.log(files);                                         // FileList {0: File, length: 1}
  var output = [];
  for(var i = 0; files[i]; i++) {
    console.log(files[i]);
    //File{name: "attention.png", lastModified: 1145888544000, lastModifiedDate: Mon Apr 24 2006 22:22:24 GMT+0800 (中国标准时间), webkitRelativePath: "", size: 3250,type: "image/png"}
    output.push('<li>'+files[i].name+'('+files[i].type+') - '+files[i].size+' bytes - '+files[i].lastModified+'</li>');
  }
  document.getElementById('Lists').innerHTML = '<ul>' + output.join('') + '</ul>';
}

// 检测浏览器支持情况
!(window.File && window.FileList && window.FileReader && window.Blob) && document.write('您的浏览器不支持File Api');
document.getElementById('Files').addEventListener('change', fileSelect, false);

</pre>
</div>

<div id="File">
<h3>File对象</h3><pre>
html5提供了File API允许js读取本地文件,但并不能直接访问本地文件,而是要依赖于用户行为

File API主要是用来获取本地文件系统中文件的reference,通过File API可以获得一个代表本地文件的js对象即File对象

File对象来源：
用户在一个input type='file'元素上选择文件后返回的FileList对象
将文件拖拽到浏览器上拖放操作生成的DataTransfer对象
HTMLCanvasElement上的mozGetAsFile() API,canvas对象的mozGetAsFile API中获取file对象

File Api给js提供了以下几个接口来访问本地文件系统:
File       单个文件,继承Blob接口,增加了name、file size、mimetype,lastModifiedDate等只读文件属性
FileList   一个类数组File对象集合
Blob       文件对象的二进制原始数据,并且允许通过JS对其数据以字节为单位进行切割操作
FileReader 提供了异步读取文件的方法和包含读取结果的事件模型

File接口没有定义任何方法,但是继承了Blob接口的方法
FileList[index]           // 得到第index个文件
Blob.size                 // blob对象的只读属性,二进制对象数据的字节数大小
Blob.type                 // 表示二进制对象的类型 (如果是File对象分割的,会继承type属性)
Blob.slice(start, length) // 将当前文件切割分割,并将结果返回,返回的仍然是一个Blob类型

File对象是特殊类型的Blob,且可以用在任意的Blob类型的context中。比如说FileReader,URL.createObjectURL(),createImageBitmap()及XMLHttpRequest.send()都能处理Blob和File

【 File对象的属性 】
处于安全性的考虑,File对象不会暴露出文件的内容,它只提供了一些只读的属性来描述修改时间、文件类型、长度、名字等

File对象也是二进制对象,因此从属于Blob对象,Blob对象的一些属性与方法File对象同样适合,且推荐使用Blob对象的属性与方法

File接口继承了Blob接口的属性：
File.lastModified     只读,返回当前File对象所引用文件最后修改时间,格式为时间戳,自1970年1月1日0:00以来的毫秒数
File.lastModifiedDate 只读,返回当前File对象所引用文件最后修改时间的Date对象
File.name             只读,返回当前File对象所引用文件的名字
File.size             只读,返回文件的大小,单位字节,继承自Blob
File.type             只读,返回File对象所表示文件的媒体类型MIME
File.webkitRelativePath   只读,返回File相关的path或URL
File.urn                  只读属性,代表该文件的URN,几乎用不到
File.slice(start, length) 继承自Blob,同Blob.slice

File.type基于文件扩展来假设;重命名为.txt的PNG图像文件为"text/plain"而不是"image/png"
file.type仅仅对常见文件类型可靠,如图像、文档、音频和视频,不常见的文件扩展名会返回空字符串,最好不要依靠这个属性作为唯一的验证方案

image/*
text/plain, text/html, text/css, text/javascript
image/gif, image/png, image/jpeg, image/bmp, image/webp
audio/midi, audio/mpeg, audio/webm, audio/ogg, audio/wav
video/webm, video/ogg, video/mp4
application/octet-stream, application/pkcs12, application/vnd.mspowerpoint, application/xhtml+xml, application/xml,  application/pdf

</pre><pre class="js">
<input type="file" multiple accept="image/*" onchange="handleFiles(this.files)">

function handleFiles(fileList) {
  var file = fileList[0];
  console.log(file instanceof Blob, file);    // true
}

File(9139) {
  lastModified:1490360658589,
  lastModifiedDate:Fri Mar 24 2017 21:04:18 GMT+0800 (中国标准时间) {},
  name:"2.jpg",
  size:9139,
  type:"image/jpeg",
  webkitRelativePath:"",
  __proto__:File,
}

</pre>
</div>

<div id="ObjectURl">
<h3>对象URL,也称blob URL</h3><pre>
Blob URL： Blob URLs是W3C的官方名称,在实际使用时常称为Object-URLs。Blob URLs只能通过URL.createObjectURL方法暂时生成在浏览器中,此方法将生成一个指向于Blob和File的对象的URL,并能通过URL.revokeObjectURL方法释放,在页面关闭时被销毁掉并只存在于当前session中。

对比Data URLs： Blob URLs只是暂时的协议允许Blob和File对象能够利用URL以资源的形式被使用在图片(img标签)、二进制数据下载链接等,而不需通过上传文件到server端后返回URL资源。而Data URLs定义为data:[< mediatype >][;base64],< data >,在JS中为二进制数据需要编码为Base64字符串,而一个字符需要占用两字节,使得原始纯二进制数据的Blob URLs相比于Data URLs更小更快。

解决的问题： 在面对需要保存canvas为图片的需求中,可以通过canvas.toDataURL方法转数据为base64编码并用以下载和展示。但在面对长图时,过长的base64编码将消耗过多的内存,并且由于客户端能力不尽相同使得在客户端有内存溢出风险甚至引起浏览器崩溃。但canvas同时可以使用canvas.toBlob方法获得原始二进制数据的Blob对象,并通过URL.createObjectURL方法获取暂时的URL资源,相比于base64消耗更低的内存风险也更小

</pre>生成Blob URLs并下载<pre class="js">
canvas.toBlob((blob)=>{
  let url = URL.createObjectURL(blob);
  let a = documen.createElement('a');
  a.href = url;
  a.download = 'test.test';
  document.body.appendChild();
  a.click();
},'image/png',1);

</pre>通过FileReader读取Blob<pre class="js">
canvas.toBlob((blob)=>{
  let fr = new FileReader();
  fr.addEventListener('load' , (event) => {
    //dosomething to event.target.result
  })
  // readAsArrayBuffer、readAsBinaryString、readAsText
  fr.readAsDataURL(blob);
},'image/png',1);

</pre><pre>
【 window.URL.createObjectURL() 】
创建简单的URL字符串对象,用于指向任何DOM File对象数据,包括用户电脑中的本地文件img/pdf/video,URL对象是File对象的一个字符串标识。

URL.createObjectURL()静态方法会创建一个DOMString,其中包含一个表示参数中给出的对象的URL,这个URL的生命周期和创建它的窗口中的document绑定,这个新的URL对象表示指定的File对象或Blob对象

objectURL = URL.createObjectURL(object);
参数object表示用于创建URL的File对象、Blob对象或MediaSource对象
返回值是一个指向一块内存的地址的字符串,因为这个字符串是URL,所以在DOM中也能使用

URL.createObjectURL(object)会对二进制数据生成一个URL,这个URL可以放置于任何通常可以放置URL的地方,比如img标签的src属性
即使是同样的二进制数据,每调用一次URL.createObjectURL方法就会得到一个不一样的URL,都会创建一个新的URL对象。这个URL的存在时间等同于网页的存在时间,一旦网页刷新或卸载这个URL就失效,File和Blob又何尝不是这样,除此之外也可以手动调用URL.revokeObjectURL方法使URL失效,但是为了获得最佳性能和内存使用状况应该在安全的时机主动释放掉它们。

URL.revokeObjectURL(objectURL);
释放由createObjectURL方法创建的URL对象,以便释放浏览器内存

使用对象URL的好处是可以不必把文件内容读取到JS中而直接使用文件内容,只要在需要文件内容的地方提供对象URL即可。

此特性在Web Worker中可用,在Service Worker中不可用,因为它有可能导致内存泄漏。

URL的构造方法：var url = new URL(urlstrig, [baseurlstring]);

</pre>URL.createObjectURL(BlobObject)<pre class="js">
var blob = new Blob(["Hello World!"], { type: 'text/plain' });
console.info(blob);                             // Blob(12) {size: 12, type: "text/plain"}
var objURL = window.URL.createObjectURL(blob);
console.log(objURL);                            // blob:http://localhost/73db7524-cba7-4c0c-bd92-2ced695b74d4

</pre>生成了一个超链接,点击它就能下载一个名为a.txt的文件,里面的内容是Hello hanzichi<pre class="js">
var blob = new Blob(["Hello hanzichi"]);
var a = document.createElement("a");
a.href = window.URL.createObjectURL(blob);
a.download = "a.txt";
a.textContent = "Download";
document.body.appendChild(a);

</pre>URL.createObjectURL(FileObject)<pre class="js">
<input type="file">
<img src="">

document.querySelector('input[type=file]').onchange = function(){
  var objectURL = URL.createObjectURL(this.files[0]);
  console.log(objectURL);                       // blob:http://localhost/c73c715c-0de2-4204-bfad-ce6ed5b43858
  document.images[0].src = objectURL;
}

</pre>Using object URLs to display images<pre class="js">
<input type="file" id="fileElem" multiple accept="image/*" style="display:none" onchange="handleFiles(this.files)">
<a href="#" id="fileSelect">Select some files</a>
<div id="fileList"><p>No files selected!</p></div>

window.URL = window.URL || window.webkitURL;

const fileSelect = document.getElementById("fileSelect"),
    fileElem = document.getElementById("fileElem"),
    fileList = document.getElementById("fileList");

fileSelect.addEventListener("click", function (e) {
  if (fileElem) fileElem.click();
  e.preventDefault();              // prevent navigation to "#"
}, false);

function handleFiles(files) {
  if (!files.length) {
    fileList.innerHTML = "<p>No files selected!</p>";
  } else {
    fileList.innerHTML = "";
    const list = document.createElement("ul");
    fileList.appendChild(list);
    for (let i = 0; i < files.length; i++) {
      const li = document.createElement("li");
      list.appendChild(li);

      var objURL = window.URL.createObjectURL(files[i]);
      console.log(objURL);  // blob:http://localhost/5143954c-d11b-4281-b56f-cafebed20cf4

      const img = document.createElement("img");
      img.src = objURL;
      img.height = 60;
      img.onload = function() {
        window.URL.revokeObjectURL(this.src);
      }
      li.appendChild(img);
      const info = document.createElement("span");
      info.innerHTML = files[i].name + ": " + files[i].size + " bytes";
      li.appendChild(info);
    }
  }
}

</pre>Using object URLs to display embedded PDF files or any other resources that can be displayed by the browser rather than proposed as a downloaded file - 把pdf文件变成图片(Mozilla的pdf.js库)<pre class="js">
document.querySelector('input[type=file]').onchange = function(){
  var fileList = this.files;
  var file = fileList[0];
  console.log(file instanceof Blob, file);  // true, File(7156807) {name: "ThinkPHP5快速入门.pdf", …}
  const reader = new FileReader();
  reader.onload = function() {
    var title = file.name;
    var blob = new Blob([this.result], { type: 'application/pdf' });
    blob.name = title;
    if (!!window.ActiveXObject || "ActiveXObject" in window) {  // isIE
      window.navigator.msSaveOrOpenBlob(blob, title);
    } else {
      var fileURL = URL.createObjectURL(blob);
      var win = window.open();
      win.document.write('< iframe name="' + title + '" src="' + fileURL + '" frameborder="0" style="border:0; top:0px; left:0px; bottom:0px; right:0px; width:100%; height:100%;" allowfullscreen></ iframe>');
      win.document.title = title;
    }
  };
  reader.readAsArrayBuffer(file);
}

</pre><pre>
【 Using object URLs with other file types - preview uploaded video 】

</pre><pre class="js">
const video = document.getElementById('video');
const obj_url = window.URL.createObjectURL(blob);
video.src = obj_url;
video.play()
window.URL.revokeObjectURL(obj_url);

</pre>上传预览图片的2种方法<pre class="js">
objURL方式：<input type="file" id="imgFile" name="files[]" multiple accept="image/gif,image/jpeg,image/png" style="position: absolute;clip: rect(0 0 0 0);" />
<label for="imgFile" style="border:2px solid;padding: .5rem;"> + 选择图片文件</label>

/*
input控件必须要显示,可通过clip让它看不见,clip要想使元素起作用必须设置absolute定位,也可通过left:-9999em;让它超出文档视图范围
创建一个img对象可以通过new Image()和createElement("img")或html()
*/

//创建对象URL的兼容方法
function getObjectURL(file) {
  var url = null ;
  if (window.createObjectURL != undefined) {  // basic
    url = window.createObjectURL(file) ;
  } else if (window.URL != undefined) {       // mozilla(firefox)
    url = window.URL.createObjectURL(file) ;
  } else if (window.webkitURL != undefined) { // webkit or chrome
    url = window.webkitURL.createObjectURL(file) ;
  }
  return url ;
}

//创建对象URL的兼容方法
function getObjectURL(file){
  return window[window.webkitURL ? 'webkitURL' : 'URL']['createObjectURL'](file);
};

//上传预览图片的2种方法： URL.createObjectURL方式
document.getElementById('imgFile').onchange = function(e){
  var file =  e.target.files[0];
  if(/image/.test(file.type)){
    var url = getObjectURL(file);   //通过createObjectURL创建的是一个对象的url引用
    console.log(url);
    //onload事件中保证img对象显示了图片后才调用revokeObjectURL方法来释放创建的URL对象
    img.onload = function(){
      URL.revokeObjectURL(this.src);
    }
    var pvImg = "＜img id='previewImg' src='"+ url +"' /＞";
    $('#preview').append(pvImg);
  }else{
    alert('请选择图片上传');
  }
}

//上传预览图片的2种方法： filereader方式
document.getElementById('imgFile1').onchange = function(e){
  var file =  e.target.files[0];
  if(/image/.test(file.type)){
    var reader = new FileReader();
    reader.readAsDataURL(file);
    reader.onload = function(){
      console.log(this.result);
      var pvImg = "＜img id='previewImg' src='"+ this.result +"' /＞";
      $('#preview1').append(pvImg);
    }
  }else{
    alert('请选择图片上传');
  }
}

</pre>头像上传预览加剪裁效果<pre class="js">
<button class="uploadButton" style="cursor:pointer;">
  上传文件 <input class="fileInput" accept="image/*" type="file" style="display:none;">
</button>
<canvas class="canvas" width="240" height="240" style="display: none;cursor: move;"> Your browser not support HTML5 </canvas>
<input class="rangeInput" type="range" step="0.01" min="1" max="2" value="1" style="display: none;width:220px;cursor:pointer;">

var canvas = document.getElementsByClassName("canvas")[0];
var ctx = canvas.getContext("2d");

var border = {
  width: 40, //头像边框厚度
  color: "rgba(247, 248, 250, .9)" //头像边框颜色
}
//图像的最小高度与宽度
var minImgRect = { width: null, height: null };
//保存当前图像的宽度与高度(缩放后)
var imgRect = { width: null, height: null };
//保存当前图片在canvas里的位置
var currLoc = { x: null, y: null };
// 保存当前图片的居中比例,拖动时清空,缩放时重新计算;居中比例：以canvas中轴线为基准将图片切成两部分,左侧部分占总宽度的比例,y方向同理。
var midpoint = null;


var uploadButton = document.getElementsByClassName("uploadButton")[0]; //图像上传按钮对象
var fileInput = uploadButton.getElementsByClassName("fileInput")[0]; //图像上传控件
var rangeInput = document.getElementsByClassName("rangeInput")[0]; //滑块对象
var image = new Image(); //图像文件

//模拟图片上传按钮
uploadButton.onclick = function(e) {
  return fileInput.click();
}

//图片上传处理代码
fileInput.addEventListener('change', function(e) {
  canvas.style.display = rangeInput.style.display = 'block';
  var file = this.files[0];
  image.onload = function(e) {
    //缩放图片到刚好填满中框,根据原图宽高的最小值按比例缩小图片使缩小后的图片宽度或高度刚好显示
    if (image.width < image.height) {
      minImgRect.width = canvas.width - border.width * 2;
      minImgRect.height = parseInt(minImgRect.width / image.width * image.height);
    } else {
      minImgRect.height = canvas.height - border.width * 2;
      minImgRect.width = parseInt(minImgRect.height / image.height * image.width);
    }
    //绘制初始图片
    imgRect.width = minImgRect.width;
    imgRect.height = minImgRect.height;
    drawing(centerImg({ x: 0.5, y: 0.5 }));
  };
  image.src = URL.createObjectURL(file);
}, false);

//根据居中比例及图像大小计算放置图片的坐标,参数: {x: < 0-1 >, y: < 0-1 >}
function centerImg(ratio) {
  return { // 居中时应满足如下条件,借此计算出偏移量 x 和 y
    x: canvas.width / 2 - imgRect.width * ratio.x, // 横坐标偏移(x) + 图像宽度*横向居中比例 应等于 canvas 宽度的一半(中点横坐标)
    y: canvas.height / 2 - imgRect.height * ratio.y // 纵坐标偏移(y) + 图像高度*纵向居中比例 应等于 canvas 高度的一半(中点纵坐标)
  };
}

//绘制图片到canvas
function drawing(loc) {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.drawImage(image, loc.x, loc.y, imgRect.width, imgRect.height); //指定坐标输出图像
  ctx.strokeStyle = border.color;
  ctx.lineWidth = border.width;
  ctx.strokeRect(border.width / 2, border.width / 2, canvas.width - border.width, canvas.height - border.width);
  currLoc = loc;
}

//缩放相关代码
rangeInput.oninput = function(e) {
  //检查缩放前是否发生过拖动(midpoint是否被清除),如果是则重新计算居中比例
  if (midpoint == null) {
    midpoint = {
      x: (canvas.width * 0.5 - currLoc.x) / imgRect.width,
      y: (canvas.height * 0.5 - currLoc.y) / imgRect.height
    }
  }

  imgRect.width = minImgRect.width * parseFloat(this.value);
  imgRect.height = minImgRect.height * parseFloat(this.value);
  loc = centerImg(midpoint);
  //检查计算出的位置是否存在脱离中框的情况
  if (loc.x > 40) loc.x = 40;
  if (loc.x + imgRect.width < canvas.width - 40) loc.x = canvas.width - 40 - imgRect.width;
  if (loc.y > 40) loc.y = 40;
  if (loc.y + imgRect.height < canvas.height - 40) loc.y = canvas.height - 40 - imgRect.height;
  midpoint = null; //由于发生位移,需要情况居中比例,重新计算
  drawing(loc);
}

//拖动相关代码
canvas.onmousedown = function(e) {
  var lastMouseLoc = { x: e.clientX, y: e.clientY };

  document.onmousemove = function dragging(e) {
    midpoint = null; //由于位置改变,居中比例需要清空,以便在缩放时重新计算。
    var mouseMove = {
      x: e.clientX - lastMouseLoc.x,
      y: e.clientY - lastMouseLoc.y
    };
    lastMouseLoc = {
      x: lastMouseLoc.x + mouseMove.x,
      y: lastMouseLoc.y + mouseMove.y
    };

    if (currLoc.x + mouseMove.x > 40) { //禁止图像向左拖出中框
      mouseMove.x = 40 - currLoc.x;
    }
    if (currLoc.x + mouseMove.x + imgRect.width < canvas.width - 40) { //禁止图像向右拖出中框
      mouseMove.x = canvas.width - 40 - currLoc.x - imgRect.width;
    }
    if (currLoc.y + mouseMove.y > 40) { //禁止图像向下拖出中框
      mouseMove.y = 40 - currLoc.y;
    }
    if (currLoc.y + mouseMove.y + imgRect.height < canvas.height - 40) { //禁止图像向上拖出中框
      mouseMove.y = canvas.height - 40 - currLoc.y - imgRect.height;
    }

    drawing({ x: currLoc.x + mouseMove.x, y: currLoc.y + mouseMove.y });
  }

  document.onmouseup = function(e) {
    document.onmousemove = null;
  }
};

</pre>
</div>

<div id="DragAPI">
<h4>拖放API</h4><pre>
除了可以通过表单file控件访问本地文件外,还可以通过拖放API来访问

html5提供了一个更快捷的方式来触发读取文件的时机,浏览器不能主动地访问本地操作系统,只能依赖于用户行为,用户想要访问文件时才去访问本地文件系统。

拖放api是以event对象的dataTransfer对象作为数据载体,该对象具有一个files属性,通过该属性可以拿到想要的FileList集合

</pre><pre class="js">
// Drag And Drop API
function fileDrop(e) {
  e = e || window.event;
  e.stopPropagation(); // 阻止冒泡
  e.preventDefault();  // 阻止默认行为
  var files = e.dataTransfer.files;   //FileList
  var output = [];
  for(var i = 0, f; f = files[i]; i++) {
    output.push('<li><strong>' + f.name + '</strong>(' + f.type + ') - ' + f.size +' bytes</li>');
  }
  document.getElementById('Lists').innerHTML = '<ul>' + output.join('') + '</ul>';
};

function dragOver(e) {
  e = e || window.event;
  e.stopPropagation();
  e.preventDefault();
  e.dataTransfer.dropEffect = 'copy'; //指定拖放视觉效果
};

var d = document.getElementById('DropZone');
try {
  d.addEventListener('dragover', dragOver, false);
  d.addEventListener('drop', fileDrop, false)
} catch(ex) {
  document.write('something must be wrong!');
}

</pre>Asynchronously handling the file upload process<pre class="js">
// index.php
if (isset($_FILES['myFile'])) {
    // Example:
    move_uploaded_file($_FILES['myFile']['tmp_name'], "uploads/" . $_FILES['myFile']['name']);
    exit;
}

// index.php js code
function sendFile(file) {
  const uri = "/index.php";
  const xhr = new XMLHttpRequest();
  const fd = new FormData();

  xhr.open("POST", uri, true);
  xhr.onreadystatechange = function() {
    if (xhr.readyState == 4 && xhr.status == 200) {
      alert(xhr.responseText); // handle response.
    }
  };
  fd.append('myFile', file);
  // Initiate a multipart/form-data upload
  xhr.send(fd);
}

window.onload = function() {
  const dropzone = document.getElementById("dropzone");
  dropzone.ondragover = dropzone.ondragenter = function(event) {
    event.stopPropagation();
    event.preventDefault();
  }

  dropzone.ondrop = function(event) {
    event.stopPropagation();
    event.preventDefault();

    const filesArray = event.dataTransfer.files;
    for (let i=0; i< filesArray.length; i++) {
      sendFile(filesArray[i]);
    }
  }
}

// index.php html code
<div>
  <div id="dropzone" style="margin:30px; width:500px; height:300px; border:1px dotted grey;">Drag & drop your file here...</div>
</div>

</pre>
</div>

<div id="FileReader">
<h3>FileReader对象</h3><pre>
FileReader对象主要用来把文件读入内存,并且读取文件中的数据

FileReader对象允许Web程序异步读取用户计算机上的本地文件或原始数据缓冲区内容,FileReader操作的对象是Blob以及继承于Blob的File对象
,FlieReader类型实现的是一种异步文件读取机制

可以把FileReader想象成XMLHttpRequest,区别只是它读取的是文件系统,而不是远程服务器
可以使用File对象或Blob对象来指定所要读取的文件或数据

通过构造函数创建一个FileReader对象
var reader = new FileReader();

【 FileReader对象的属性 】
result
只读,返回读取的文件内容
只有当读取方法调用并且读取完成时才能用此属性,且数据格式取决于读取操作发起的方法(二进制、文本或DataURL格式)

readyState
只读,表示FileReader对象的当前状态,可以是以下值:
0---EMPTY    还没有加载任何数据
1---LOADING  数据正在加载中
2---DONE     数据已经加载完成,已完成全部的读取请求

error
只读,当读取文件发生错误时返回的错误信息

【 FileReader对象的方法 】
read**()系列方法都是异步操作,所以要等待文件读取完成后才能设置img的src属性。
需要监听FileReader的onload事件,其回调函数含有一个event对象,可以通过event.target.result获取url地址,也可以直接通过reader.result属性获取url地址

FileReader的实例拥有4个方法,无论读取成功或失败读取结果存储在result属性中,读取失败则result的值为null,否则是读取的结果

1.abort()
中断读取操作,此时readyState将改变为DONE,无参数
当该FileReader对象没有在进行读取操作时(也就是readyState属性的值不为LOADING时),调用abort()方法会抛出该异常

2.readAsBinaryString(file/blob) 已废除
读取文件为二进制字符串,读取文件并返回一个由文件原始二进制数据转化成string字符串,IE浏览器不支持该方法

3.readAsArrayBuffer(BlobObject|FileObject)
读取文件并返回一个包含文件内容的ArrayBuffer对象
此方法会按字节读取文件内容并转换为ArrayBuffer对象。
readAsArrayBuffer读取文件后会在内存中创建一个ArrayBuffer对象(二进制缓冲区),将二进制数据存放在其中,通过此方式可以直接在网络中传输二进制内容

</pre>通过readAsArrayBuffer()方法转换成blob来读取图片文件和文本文件<pre class="js">
window.onload = function () {
  var input = document.getElementById("file");
  input.onchange = function () {
    var file = this.files[0];
    if (!!file) {
      var reader = new FileReader();
      reader.onload = function () {
        console.log(this.result);
        console.log(new Blob([this.result]))
      }
      reader.readAsArrayBuffer(file);
    }
  }
}

</pre><pre>
4.readAsText(file, [encoding])
将文件取为纯文本,将返回的text string保存在result属性中,encoding指定文件编码(默认值utf-8)

5.readAsDataURL(BlobObject|FileObject)
读取文件并返回一个引用文件内容的url对象,将文件以DataURL的形式保存在result属性中
该方法将文件读取为一段以data:开头的字符串,实质就是Data URL,Data URL是一种将小文件(通常是指图像与html等格式的文件)直接嵌入文档的方案;转换成base64编码的字符串形式并存储在URL中,冠以mime-type
如果需要服务器端处理,把字符串base64,后面的字符发送给服务器并用Base64解码就可以得到原始文件的二进制内容

【 FileReader包含了一套完整的事件模型用于捕获读取文件时的状态 】
onloadstart  读取开始时触发
onprogress   读取进行时触发,读取中,表示是否又读取了数据;在读取数据过程中周期性调用
onabort      读取发生中断时触发
onerror      读取出错时触发
onload       文件读取成功完成时触发,表示是否读完了这个文件
onloadend    读取完成触发,无论成功或失败,该处理程序在onload或onerror之后调用

</pre>IE10以下的版本不支持FileReader()构造函数,不过可以利用滤镜来兼容旧版本的IE<pre class="js">
var loadImageFile = (function () {
  if (window.FileReader) {
    var	oPreviewImg = null;
    var reader = new window.FileReader();
    var	rFilter = /^(?:image\/bmp|image\/cis\-cod|image\/gif|image\/ief|image\/jpeg|image\/jpeg|image\/jpeg|image\/pipeg|image\/png|image\/svg\+xml|image\/tiff|image\/x\-cmu\-raster|image\/x\-cmx|image\/x\-icon|image\/x\-portable\-anymap|image\/x\-portable\-bitmap|image\/x\-portable\-graymap|image\/x\-portable\-pixmap|image\/x\-rgb|image\/x\-xbitmap|image\/x\-xpixmap|image\/x\-xwindowdump)$/i;

    reader.onload = function (event) {
      if (!oPreviewImg) {
        var newPreview = document.getElementById("imagePreview");
        oPreviewImg = new Image();
        oPreviewImg.style.width = (newPreview.offsetWidth).toString() + "px";
        oPreviewImg.style.height = (newPreview.offsetHeight).toString() + "px";
        newPreview.appendChild(oPreviewImg);
      }
      oPreviewImg.src = event.target.result;
    };

    return function () {
      var aFiles = document.getElementById("imageInput").files;
      if (aFiles.length === 0) { return; }
      if (!rFilter.test(aFiles[0].type)) {
        alert("You must select a valid image file!");
        return;
      }
      reader.readAsDataURL(aFiles[0]);
    }

  }
  if (navigator.appName === "Microsoft Internet Explorer") {
    return function () {
      document.getElementById("imagePreview").filters.item("DXImageTransform.Microsoft.AlphaImageLoader").src = document.getElementById("imageInput").value;
    }
  }
})();

</pre><pre class="js">
$('[type=file]').change(function(){
  var file = this.files[0];
  if(window.FileReader) {
    var fr = new FileReader();
    fr.onload = function(e) {
      document.querySelector("#portrait").src = e.target.result;   //this.result;
    };
    fr.readAsDataURL(file);
  }else {
    console.log("Not supported by your browser!");
  }
}

</pre><pre>
【 FileReader常见应用 】
1、预览本地图片,主要用到FileReader的readAsDataURL方法,通过将图片数据读取成Data URL的方法将图片展示出来

2、预览文本文件,主要用到FileReader的readAsText,对于诸如mimetype为text/plain、text/html等文件均认为是文本文件,即minetype为text开头都能在本例中预览
由于需要在页面上正常显示预览文本,如果使用innerHTML插入文本的话则需要对html中一些特殊字符进行实体编码

3、数据备份与恢复
FileReader对象的readAsText()可以读取文件的文本,结合Blob对象下载文件的功能,那就可以实现将数据导出文件备份到本地,当数据要恢复时通过input把备份文件上传,使用readAsText()读取文本,恢复数据

</pre>预览本地图片<pre class="js">
function fileSelect(e) {
  e = e || window.event;
  var files = e.target.files;  //FileList Objects
  var ireg = /image\/.*/i;
  var p = document.getElementById('Preview');
  var ul = document.getElementById('Errors');
  for(var i = 0, f; f = files[i]; i++) {
    if(!f.type.match(ireg)) {    //设置错误信息
      var li = document.createElement('li');
      li.innerHTML = '<li>' + f.name +'不是图片文件.</li>';
      ul.appendChild(li);
      continue;
    }

    var reader = new FileReader();
    reader.onload = (function(file) {
      return function(e) {
        var span = document.createElement('span');
        span.innerHTML='＜img class="thumb" src="' + this.result +'" alt="'+file.name +'" /＞';
        p.insertBefore(span, null);
      };
    })(f);
    reader.readAsDataURL(f);   //读取文件内容
  }
}

if(window.File && window.FileList && window.FileReader && window.Blob) {
  document.getElementById('Files').addEventListener('change', fileSelect, false);
} else {
  document.write('您的浏览器不支持File Api');
}

</pre>Showing thumbnails of user-selected images<pre class="js">
function handleFiles(files) {
  for (let i = 0; i < files.length; i++) {
    const file = files[i];
    if (!file.type.startsWith('image/')) continue;
    const img = document.createElement("img");
    img.classList.add("obj");
    img.file = file;
    document.querySelector('#preview').appendChild(img);

    const reader = new FileReader();
    reader.onload = (function(aImg) {
      return function(e) {
        aImg.src = e.target.result;
      };
    })(img);
    reader.readAsDataURL(file);
  }
}

</pre>预览文本文件<pre class="js">
function encodeHTML(source) {   //存在语法错误
  return source.replace(/&/g,'\&').replace(/</g,'\<').replace(/>/g,'\>').replace(/"/,'\"').replace(/'/,'\'');
};
function fileSelect(e) {
  e = e || window.event;
  var files = e.target.files;  //FileList Objects
  var ireg = /text\/.*/i;
  var p = document.getElementById('Preview');
  var ul = document.getElementById('Errors');
  for(var i = 0, f; f = files[i]; i++) {
    console.log(f.type);
    if(!f.type.match(ireg)) {
        var li = document.createElement('li');     //设置错误信息
        li.innerHTML = '<li>' + f.name +'不是文本文件.</li>';
        ul.appendChild(li);
        continue;
    }
    var reader = new FileReader();
    reader.onload = (function(file) {
      return function(e) {
        var div = document.createElement('div');
        div.className = "text"
        div.innerHTML = encodeHTML(this.result);
        p.insertBefore(div, null);
      };
    })(f);
    reader.readAsText(f);   //读取文件内容
  }
}

if(window.File && window.FileList && window.FileReader && window.Blob) {
  document.getElementById('Files').addEventListener('change', fileSelect, false);
} else {
  document.write('您的浏览器不支持File Api');
}

</pre>分段读取文件内容,防止一次性将一个大文件读入内存<pre class="js">
function readBlob(start, end) {
  var files = document.getElementById('file').files;
  if(!files.length) {
    alert('请选择文件');
    return;
  }
  var file = files[0],
    start = parseInt(start, 10) || 0,
    end = parseInt(end, 10) || (file.size - 1);

  var r = document.getElementById('range'),
      c = document.getElementById('content');

  var reader = new FileReader();

  reader.onloadend = function(e) {
    if(this.readyState == FileReader.DONE) {
      c.textContent = this.result;
      r.textContent = "Read bytes: " + (start + 1) + " - " + (end + 1) + " of " + file.size + " bytes";
    }
  };
  var blob = blobSlice(file,start,end + 1)
  reader.readAsBinaryString(blob);
};

function blobSlice(blob,startByte,endByte){
  if(blob.slice) return  blob.slice(startByte,endByte);
  if(blob.mozSlice) return  blob.mozSlice(startByte,endByte);        // 兼容firefox
  if(blob.webkitSlice) return  blob.webkitSlice(startByte,endByte);  // 兼容webkit
  return null;
}

try {
  document.getElementById('buttons').addEventListener('click', function(e) {
    if(e.target.tagName.toLowerCase() == 'button') {
      var start = e.target.getAttribute('data-start'),
          end = e.target.getAttribute('data-end');
      readBlob(start, end);
    }
  });
} catch(ex) {
  console.log('something error happens!')
}

</pre><pre>
【 FileReader进度条 】
FileReader的onloadstart及onprogress等事件可以用来监听FileReader异步读取文件内容的进度

onprogress的事件处理器中提供了一个ProgressEvent对象,这个事件对象继承了Event对象
提供了三个只读属性：lengthComputable、loaded、total;通过以上几个属性即可实时显示读取进度

</pre>为了安全地、正常地观察到文件读取进度,采用分段读取的方法来测试FileReader的进度条<pre class="js">
<form>
  <fieldset>
    <legend>分度读取文件：</legend>
    <input type="file" id="File" />
    <input type="button" value="中断" id="Abort" />
    <p><label>读取进度：</label><progress id="Progress" value="0" max="100"></progress></p>
    <p id="Status"></p>
  </fieldset>
</form>

var h = {
  init: function() {
    var me = this;

    document.getElementById('File').onchange = me.fileHandler;
    document.getElementById('Abort').onclick = me.abortHandler;

    me.status = document.getElementById('Status');
    me.progress = document.getElementById('Progress');
    me.percent = document.getElementById('Percent');

    me.loaded = 0;
    me.step = 1024 * 1024;   //每次读取1M
    me.times = 0;
  },
  fileHandler: function(e) {
    var me = h;  console.log(h);
    var file = me.file = this.files[0];
    var reader = me.reader = new FileReader();
    console.log(reader);
    me.total = file.size;

    reader.onabort = me.onAbort;
    reader.onerror = me.onerror;
    reader.onload = me.onLoad;
    reader.onloadstart = me.onLoadStart;
    reader.onloadend = me.onLoadEnd;
    reader.onprogress = me.onProgress;

    me.readBlob(file, 0);   //读取第一块
  },
  onLoadStart: function() {
    var me = h;
  },
  onAbort: function() {
    var me = h;
  },
  onError: function() {
    var me = h;
  },
  onLoadEnd: function() {
    var me = h;
  },
  onProgress: function(e) {
    var me = h;
    me.loaded += e.loaded;
    me.progress.value = (me.loaded / me.total) * 100;   //更新进度条
  },
  onLoad: function() {
    var me = h;

    if(me.loaded < me.total) {
      me.readBlob(me.loaded);
    } else {
      me.loaded = me.total;
    }
  },
  readBlob: function(start) {
    var me = h;
    var file = me.file;
    me.times += 1;

    var blob = me.blobSlice(file, start, start + me.step + 1);
    console.log(blob);
    me.reader.readAsText(blob);
  },
  abortHandler: function() {
    var me = h;
    if(me.reader) me.reader.abort();
  },
  blobSlice: function(blob,startByte,length){
    if(blob.slice){
      return blob.slice(startByte,length);
    } else if(blob.webkitSlice){
      return blob.webkitSlice(startByte,length);
    } else if(blob.webkitSlice){
      return blob.webkitSlice(startByte,length);
    } else {
     return null;
    }
  }
};

h.init();

</pre>Uploading a user-selected file<pre class="js">
function sendFiles() {
  const imgs = document.querySelectorAll(".obj");
  for (let i = 0; i < imgs.length; i++) {
    new FileUpload(imgs[i], imgs[i].file);
  }
}

function FileUpload(img, file) {
  const reader = new FileReader();
  this.ctrl = createThrobber(img);
  const xhr = new XMLHttpRequest();
  this.xhr = xhr;

  const self = this;
  this.xhr.upload.addEventListener("progress", function(e) {
    if (e.lengthComputable) {
      const percentage = Math.round((e.loaded * 100) / e.total);
      self.ctrl.update(percentage);
    }
  }, false);

  xhr.upload.addEventListener("load", function(e){
    self.ctrl.update(100);
    const canvas = self.ctrl.ctx.canvas;
    canvas.parentNode.removeChild(canvas);
  }, false);

  xhr.open("POST", "http://demos.hacks.mozilla.org/paul/demos/resources/webservices/devnull.php");
  xhr.overrideMimeType('text/plain; charset=x-user-defined-binary');
  reader.onload = function(evt) {
    xhr.send(evt.target.result);
  };
  reader.readAsBinaryString(file);
}

</pre>上传表单美化,拖放,图片预览,FileReader,window.URL.createObjectURL(file),ajax上传,显示进度<pre class="js">
<input type="file" id="fileElem" multiple accept="image/*" style="display:none" onchange="handleFiles(this.files)">
<a href="#" id="fileSelect">Select some files</a>
<hr/>
<input type="file" id="fileElem" multiple accept="image/*" style="display:none" onchange="handleFiles(this.files)">
<label for="fileElem">Select some files</label>
<hr/>
<div id="dropbox" style="width: 50rem;height: 10rem;border: 1px dashed"></div>
<div id="preview" style="width: 50rem;height: 20rem;"></div>

<progress value="0" max="100">您的浏览器不支持progress元素</progress>
<button onclick="sendFiles()">upload</button>

function handleFiles(files){
  if (!files.length) return preview.innerHTML = "<p>No files selected!</p>";
  preview.innerHTML = "";
  var totalSzie = 0;
  [].forEach.call(files, file => {
    if (!file.type.startsWith('image/')) alert('It is not image file');
    totalSzie += file.size;

    var img = document.createElement("img");
    img.classList.add("obj");
    img.file = file;
    preview.appendChild(img);

    var reader = new FileReader();
    reader.onload = function(e) {
      img.src = e.target.result;
    };
    reader.readAsDataURL(file);

    window.URL = window.URL || window.webkitURL;
    var objectURL = window.URL.createObjectURL(file);
    console.log(typeof objectURL, objectURL);
    var img2 = document.createElement("img");
    img2.classList.add("obj");
    img2.file = file;
    img2.src = objectURL;
    img2.onload = function() {
      var res = window.URL.revokeObjectURL(this.src);
      console.log(typeof res, res);
    }
    preview.appendChild(img2);
  })

  // 统计所有文件的大小
  totalbytes = totalSzie + " bytes";
  for (var aMultiples = ["KiB", "MiB", "GiB", "TiB", "PiB", "EiB", "ZiB", "YiB"], nMultiple = 0, nApprox = totalSzie / 1024; nApprox > 1; nApprox /= 1024, nMultiple++) {
      totalbytes = nApprox.toFixed(3) + " " + aMultiples[nMultiple] + " (" + totalSzie + " bytes)";
  }
  console.log(`选择${files.length}个文件,总计大小为${totalbytes}`);

}

var fileSelect = document.getElementById("fileSelect");
var fileElem = document.getElementById("fileElem");

fileSelect.addEventListener("click", function (e) {
    fileElem &&fileElem.click();
    e.preventDefault();          // prevent navigation to "#"
}, false);

/*--------------------------------------------------------*/
var dropbox = document.getElementById("dropbox");
dropbox.addEventListener("dragenter", dragenter, false);
dropbox.addEventListener("dragover", dragover, false);
dropbox.addEventListener("drop", drop, false);

function dragenter(e) {
  e.stopPropagation();
  e.preventDefault();
}

function dragover(e) {
  e.stopPropagation();
  e.preventDefault();
}

function drop(e) {
  e.stopPropagation();
  e.preventDefault();
  var files = e.dataTransfer.files;
  handleFiles(files);
}

/*--------------------------------------------------------*/
function sendFiles() {
  var imgs = document.querySelectorAll(".obj");
  for (var i = 0; i < imgs.length; i++) {
    new FileUpload(imgs[i], imgs[i].file);
  }
}

function FileUpload(img, file) {
  var reader = new FileReader();
  var xhr = new XMLHttpRequest();

  var self = this;
  xhr.upload.addEventListener("progress", function(e) {
    if (e.lengthComputable) {
      var percentage = Math.round((e.loaded * 100) / e.total);
      document.querySelector('progress').value = percentage;
    }
  }, false);

  xhr.upload.addEventListener("load", function(e){
      console.log('100%');
  }, false);
  xhr.open("POST", "http://localhost:8888/upload");

  // MIME 类型上传是通过调用 XMLHttpRequest 的函数 overrideMimeType() 设置。在这种情况下,我们使用一个通用的 MIME 类型;你可以选择不设置 MIME 类型,这取决于你的使用情况
  xhr.overrideMimeType('text/plain; charset=x-user-defined-binary');
  reader.onload = function(evt) {
      xhr.send(evt.target.result);
  };

  // 把 file 转换成二进制字符串
  // 使用标准的send(Blob data)方法代替
  reader.readAsBinaryString(file);
}

</pre>
</div>

<!--------------------------客户端存储web数据---------------------------------------------->
<div id="storage">
<h2>客户端存储web数据 - 本地数据 - 使用js存储访问数据</h2><pre>
1.localStorage没有时间限制的数据存储,除非被清除否则永久保存,在客户端存储一个键值对的方式,值可存储序列化之后的json字符串
2.sessionStorage是针对一个session的数据存储,用于临时保存同一窗口或标签页的数据,关闭浏览器、关闭窗口或标签页则会删除,JS可通过window.sessionStorage调用此对象
3.cookie
4.html5还可使用indexdb,又称索引数据库,该数据库可用来存储离线对象

</pre>

<h4>localStorage</h4><pre>
本地存储作用是在浏览器内的,跨浏览器获取不到

控制台输入localStorage查询宿主(浏览器)提供的localStorage自带的方法,常用的API如下：
key(i)                    读取第i个数据的名字或称为键值(从0开始计数)
length	                  localStorage存储变量的个数
clear()	                  清空localStorage上存储的数据
setItem(key)              存储数据
getItem(key)              读取数据
removeItem(key)           删除某个具体变量
hasOwnProperty(key)       检查localStorage上是否保存了变量key
propertyIsEnumerable(key) 用来检测属性是否属于某个对象的
valueOf()                 获取所有存储的数据
localStorage.arr.toLocaleString()  将arr字段值(数组)转为本地字符串

localStorage.setItem(key)
localStorage.getItem(key)
localStorage.removeItem(key)

localStorage.name="maoguiyou"             // 直接把值赋给name字段,通过localStorage的name属性来获取
localStorage.setItem("name","maoguiyou")  // 一参是字段名,二参是值,与赋值的区别就在于能动态存储数据

localStorage['todosVuejs'] = JSON.stringify(items);
var val = localStorage['todosVuejs'] ? JSON.parse(localStorage['todosVuejs']) : [];
var val = JSON.parse(localStorage['todosVuejs'] || "[]");

</pre><pre class="js">
for(var i=0; i < 5; i++){
  localStorage.setItem(i,i);
}

结果是：key     value
        0         0
        1         1
        ...      ...
        4         4

for(var i=0; i < 5; i++){
  localStorage.i=i;
}

结果是：key     value
        i         4

</pre><pre class="js">
localStorage.name="heiying6958";
if(localStorage.pagecount){
  localStorage.pagecount=Number(localStorage.pagecount)+1;
}else{
  localStorage.pagecount=1;
}
document.write(localStorage.name+"访问了",localStorage.pagecount+"次！<br>");

</pre><pre class="js">
const store_key = 'items';
let data = [{id: 0, title: '测试内容0'}, {id: 1, title: '测试内容1'}];
localStorage[store_key] = JSON.stringify(data);

data = localStorage[store_key] ? JSON.parse(localStorage[store_key]) : [];
console.log(data[0] && data[0].title);

</pre><pre class="js">
<input type='button' onclick='setItems()' value='存值'　/>
<input type='button' onclick='getItems()' value='取值'　/>
<input type='button' onclick='deleteItem()' value='删除'　/>

//localStorage存值永久有效
function setItems(){
  var user = {};
  user.name = 'Adam Li';
  user.age  = 25;
  user.home = 'China';
  localStorage.setItem('userinfo',JSON.stringify(user));
}
//localStorage取值
function getItems(){
  var data = JSON.parse(localStorage.getItem('userinfo'));
  console.log("name:"+data.name+'\r age:'+data.age+"\r home:"+data.home);
}

//localStorage删除指定键对应的值
function deleteItem(){
  localStorage.removeItem('userinfo');
  console.log(localStorage.getItem('userinfo'));
}

</pre>

<h4>sessionStorage</h4><pre>
【 特点 】
1、同源策略限制。若想在不同页面之间对同一个sessionStorage进行操作,这些页面必须在同一协议、同一主机名和同一端口下。IE8和9存储数据仅基于同一主机名,忽略协议(HTTP和HTTPS)和端口号的要求

2、单标签页限制。sessionStorage操作限制在单个标签页中,在此标签页进行同源页面访问都可以共享sessionStorage数据。

3、只在本地存储。seesionStorage的数据不会跟随HTTP请求一起发送到服务器,只会在本地生效,并在关闭标签页后清除数据。若使用Chrome的恢复标签页功能,seesionStorage的数据也会恢复

4、存储方式。seesionStorage的存储方式采用key、value的方式。value的值必须为字符串类型(传入非字符串,也会在存储时转换为字符串。true值会转换为"true")。

5、存储上限限制：不同的浏览器存储的上限也不一样,但大多数浏览器把上限限制在5MB以下

适合场景
sessionStorage 非常适合SPA(单页应用程序),可以方便在各业务模块进行传值

【 属性 】
属性readonly int sessionStorage.length
返回一个整数,表示存储在sessionStorage对象中的数据项(键值对)数量。

【 方法 】
string sessionStorage.key(int index)
返回当前 sessionStorage 对象的第index序号的key名称。若没有返回null。

string sessionStorage.getItem(string key)
返回键名(key)对应的值(value)。若没有返回null。

void sessionStorage.setItem(string key, string value)
该方法接受一个键名(key)和值(value)作为参数,将键值对添加到存储中;如果键名存在,则更新其对应的值。

void sessionStorage.removeItem(string key)
将指定的键名(key)从sessionStorage对象中移除。

void sessionStorage.clear()
清除sessionStorage对象所有的项。

【 存储数据 】
1、采用setItem()方法存储
sessionStorage.setItem('testKey','这是一个测试的value值'); // 存入一个值
2、通过属性方式存储　　
sessionStorage['testKey'] = '这是一个测试的value值';

【 读取数据 】
1、通过getItem()方法取值
sessionStorage.getItem('testKey'); // => 返回testKey对应的值
2、通过属性方式取值
sessionStorage['testKey']; // => 这是一个测试的value值

【 存储Json对象 】
sessionStorage也可存储Json对象：存储时,通过JSON.stringify()将对象转换为文本格式;读取时,通过JSON.parse()将文本转换回对象

</pre><pre class="js">
var userEntity = { name: 'tom', age: 22 };

// 存储值：将对象转换为Json字符串
sessionStorage.setItem('user', JSON.stringify(userEntity));

// 取值时：把获取到的Json字符串转换回对象
var userJsonStr = sessionStorage.getItem('user');
userEntity = JSON.parse(userJsonStr);
console.log(userEntity.name);           // => tom

</pre><pre class="js">
sessionStorage.name="Berlin";
if(sessionStorage.pagecount){
  sessionStorage.pagecount = Number(sessionStorage.pagecount) + 1;
}else{
  sessionStorage.pagecount = 1;
}
document.write(sessionStorage.name+"访问了",sessionStorage.pagecount+"次！<br>");
</pre>

<h3>html5 indexdb索引数据库</h3>
<pre>
【 indexdb 】
所有的请求完成之后都会有一个回调,onsuccess 和onerror,
其中：onsuccess表示请求成功时候的回调,onerror 表示请求失败时候的回调。
同时还可以使用JavaScript中的 try/catch来捕获异常,在进一步的处理

一个数据库一次只能有一个版本,初次创建改数据库的时候版本号是0,
需要更改已经创建好的数据库时候,就需要更改其版本号,当更改 版本号的时候,会触发upgradeneeded回调,
所以修改数据库或者存储对象的方法必须放到upgradeneeded方法中执行

判断当前浏览器是否支持indexdb
if (!window.indexedDB) {
    alert("您的浏览器不支持indexdb");
}

</pre><pre class="html">
<a href="javascript:createDatabase('firstdb')">createDatabase</a>
<a href="javascript:deleteDatabase('firstdb')">deleteDatabase</a>
＜script type="text/javascript"＞
  function createDatabase(indexDbName) {
    //调用 open 方法并传递数据库名称。如果不存在具有指定名称的数据库,则会创建该数据库
    var openRequest = indexedDB.open(indexDbName);
    var db;
    openRequest.onerror = function(e) {//当创建数据库失败时候的回调
        console.log("Database error: " + e.target.errorCode);
    };
    openRequest.onsuccess = function(event) {
        console.log("Database created");
        db = openRequest.result;//创建数据库成功时候,将结果给db,此时db就是当前数据库
        console.log(db);
    };
    openRequest.onupgradeneeded = function (evt) {//更改数据库,或者存储对象时候在这里处理

    };
  }
  function deleteDatabase(indexDbName) {   //调用 deleteDatabase 方法删除indexdb
    var deleteDbRequest = indexedDB.deleteDatabase(indexDbName);
    deleteDbRequest.onsuccess = function (event) {
        console.log("detete database success");
    };
    deleteDbRequest.onerror = function (e) {
        console.log("Database error: " + e.target.errorCode);
    };
  }
＜/script＞
</pre>

<pre>
【 indexdb存储数据objectstore 】
在indexdb中没有表的概念,而是使用objectstore来存储对象的,一个数据库中可以包含多个objectStore,
objectStore是一个灵活的数据结构,可以存放多种类型数据。
我们可以使用每条记录中的某个指定字段作为键值(keyPath),也可以使用自动生成的递增数字作为键值(keyGenerator),也可以不指定。
选择键的类型不同,objectStore可以存储的数据结构也有差异

事务：在更新数据库内容或者插入新的数据时候,需要首先开启到事务,并且需要制定当前事物操作了那些objectstore
因为对新数据的操作都需要在transaction中进行,而transaction又要求指定object store,所以我们只能在创建数据库的时候初始化object store以供后面使用
事务具有三种模式：
1、只读：read,不能修改数据库数据,可以并发执行
2、读写：readwrite,可以进行读写操作
3、版本变更：verionchange

指定keyid添加数据。指定keyid,可以理解为指定一个主键

使用autoIncrement添加数据
指定autoIncrement,可以理解为指定了一个主键自动增长。

</pre><pre class="html">
＜a href="javascript:insertAnObj('firstdb')"＞indexdb 添加数据＜/a＞
＜a href="javascript:insertAutoInc('firstdb')"＞indexdb insertAutoInc 添加数据＜/a＞
＜script＞
//添加数据
function insertAnObj(indexDbName) {
    var userinfos=[{
          id:1001,
          name:"小李",
          age:24
      },{
          id:1002,
          name:"老王",
          age:30
      },{
          id:1003,
          name:"王麻子",
          age:26
      }];
    var openRequest = indexedDB.open(indexDbName,1);
    openRequest.onerror = function(e) {//当创建数据库失败时候的回调
        console.log("Database error: " + e.target.errorCode);
    };
    openRequest.onsuccess = function(event) {
      console.log("Database created");
      db = openRequest.result; //创建数据库成功时候,将结果给db,此时db就是当前数据库
      console.log(db);
      //打开和userinfo相关的objectstore的事物
      var transaction = db.transaction("userinfo",'readwrite');
      var store=transaction.objectStore("userinfo");
      for(var i=0;i　<　userinfos.length;i++){
          alert("add"+userinfos[i]);
          store.add(userinfos[i]);//将对象添加至userinfo相关的objectstore中
      }
    };
    openRequest.onupgradeneeded = function(event) {
       var db = event.target.result;
        //在第一次创建数据库的时候,就创建userinfo相关的objectstore,以供后面添加数据时候使用
        if(!db.objectStoreNames.contains('userinfo')){
            //keyPath:Javascript对象,对象必须有一属性作为键值
            db.createObjectStore('userinfo',{keyPath:"id"});
        }

    }
}

//指定主键自动增长
function insertAutoInc(indexDbName) {
    var userinfos=[{
          id:1001,
          name:"小李",
          age:24
      },{
          id:1002,
          name:"老王",
          age:30
      },{
          id:1003,
          name:"王麻子",
          age:26
      }];
    var openRequest = indexedDB.open(indexDbName,2);
    openRequest.onerror = function(e) {//当创建数据库失败时候的回调
      console.log("Database error: " + e.target.errorCode);
    };
    openRequest.onsuccess = function(event) {
      console.log("Database created");
      db = openRequest.result; //创建数据库成功时候,将结果给db,此时db就是当前数据库
      //alert("this is :"+db);
      //打开和userinfo相关的objectstore的事物
      var transaction = db.transaction("userinfo",'readwrite');
      var store=transaction.objectStore("userinfo");
      for(var i=0;i　<　userinfos.length;i++){
        //alert("add"+userinfos[i]);
        store.add(userinfos[i]);//将对象添加至userinfo相关的objectstore中
      }
    };
    openRequest.onupgradeneeded = function(event) {
     var db = event.target.result;
      //在第一次创建数据库的时候,就创建userinfo相关的objectstore,以供后面添加数据时候使用
      if(!db.objectStoreNames.contains('userinfo')){
        //keyPath:Javascript对象,对象必须有一属性作为键值
        db.createObjectStore('userinfo',{autoIncrement: true});
      }
    }
}
＜/script＞
</pre>

<pre>
【 查找数据 】
根据id查找数
之前我们已经添加过了定义key为autoincreament类型方式的数据,现在就可以根据id来查找单条数据了

</pre><pre class="html">
＜a href="javascript:findDbdata('firstdb',1001)"＞indexdb根据id查找数＜/a＞
＜a href="javascript:findAllDbdata('firstdb')"＞indexdb查找所有数据＜/a＞
＜script＞
//根据id查找数据
function findDbdata(indexDbName,value) {
  var openRequest = indexedDB.open(indexDbName);
  var db;
  openRequest.onerror = function(e) {//当创建数据库失败时候的回调
    console.log("Database error: " + e.target.errorCode);
  };
  openRequest.onsuccess = function(event) {
    console.log("Database created");
    db = openRequest.result; //创建数据库成功时候,将结果给db,此时db就是当前数据库
    var transaction = db.transaction("userinfo",'readwrite');
    var objectStore = transaction.objectStore("userinfo");
    //var cursor = objectStore.openCursor();
    var request = objectStore.get(Number(1));//查找i=1的对象,这里使用Number将1转换成数值类型
    request.onsuccess = function(e) {
      var res = e.target.result; //查找成功时候返回的结果对象
      console.dir(res);
      if (res) {
        for (var field in res) { //遍历每一个对象属性
          console.log(field+":"+res[field]);
          // alert(res[field]);
        };
      };
    }
  };
  openRequest.onupgradeneeded = function (event) {//更改数据库,或者存储对象时候在这里处理

  };
}

//查找所有数据
function findAllDbdata(indexDbName) {
  var openRequest = indexedDB.open(indexDbName);
  var db;
  openRequest.onsuccess = function(event) {
    console.log("Database created");
    db = openRequest.result; //创建数据库成功时候,将结果给db,此时db就是当前数据库
    var transaction = db.transaction("userinfo",'readonly');
    var objectStore = transaction.objectStore("userinfo");
    var cursor = objectStore.openCursor();
    cursor.onsuccess = function(e) {
      var res = e.target.result;
      if(res) {
        console.log("Key", res.key);
        var request = objectStore.get(Number(res.key));//根据查找出来的id,再次逐个查找
        request.onsuccess = function(e) {
          var res = e.target.result; //查找成功时候返回的结果对象
          //console.dir(res);
          if (res) {
            for (var field in res) { //遍历每一个对象属性
              console.log(field+":"+res[field]);
              // alert(res[field]);
            };
          };
        }
        res.continue();
      }
    }
  };
}
＜/script＞

</pre><pre>
【 删除数据 】
根据id删除数据:删除跟新增一样,需要创建事务,然后调用删除接口delete来删除数据
删除所有数据:通过objectstore.clear()删除所有的数据

</pre><pre class="html">
＜a href="javascript:deleteDataById('firstdb')"＞indexdb根据id删除数据＜/a＞
＜a href="javascript:deleteAllData('firstdb')"＞indexdb删除所有数据＜/a＞
＜script＞
//根据id删除数据
function deleteDataById(indexDbName) {
  var openRequest = indexedDB.open(indexDbName);
  var db;
  openRequest.onsuccess = function(event) {
    db = openRequest.result; //创建数据库成功时候,将结果给db,此时db就是当前数据库
    var transaction = db.transaction("userinfo",'readwrite');
    var objectStore = transaction.objectStore("userinfo");
    var request = objectStore.delete(Number(2));//根据查找出来的id,再次逐个查找
    request.onsuccess = function(e) {
      console.log("delete success");
    }
  }
}

//删除所有数据
function deleteAllData(indexDbName) {
  var openRequest = indexedDB.open(indexDbName);
  var db;
  openRequest.onsuccess = function(event) {
    db = openRequest.result; //创建数据库成功时候,将结果给db,此时db就是当前数据库
    var transaction = db.transaction("userinfo",'readwrite');
    var objectStore = transaction.objectStore("userinfo");
    objectStore.clear();
  }
}

＜/script＞
</pre>

<pre>
【 创建索引 】
可以在创建object store的时候指明索引,使用object store的createIndex创建索引,方法有三个参数
索引名称
索引属性字段名
索引属性值是否唯一

</pre><pre class="html">
＜a href="javascript:insertAutoInc('firstdb')"＞indexdb insertAutoInc创建索引 添加数据＜/a＞
＜script＞
//新创建一个数据库,并且设置基于name和age的索引
//指定主键自动增长
function insertAutoInc(indexDbName) {
  var userinfos=[{
      id:1001,
      name:"小李",
      age:24
  },{
      id:1002,
      name:"老王",
      age:30
  },{
      id:1003,
      name:"王麻子",
      age:26
  }];
  var openRequest = indexedDB.open(indexDbName,2);
  openRequest.onerror = function(e) {//当创建数据库失败时候的回调
    console.log("Database error: " + e.target.errorCode);
  };
  openRequest.onsuccess = function(event) {
    console.log("Database created");
    db = openRequest.result; //创建数据库成功时候,将结果给db,此时db就是当前数据库
    //alert("this is :"+db);
    //打开和userinfo相关的objectstore的事物
    var transaction = db.transaction("userinfo",'readwrite');
    var store=transaction.objectStore("userinfo");
    for(var i=0;i < userinfos.length;i++){
      //alert("add"+userinfos[i]);
      store.add(userinfos[i]);//将对象添加至userinfo相关的objectstore中
    }
  };
  openRequest.onupgradeneeded = function(event) {
   var db = event.target.result;
    //在第一次创建数据库的时候,就创建userinfo相关的objectstore,以供后面添加数据时候使用
    if(!db.objectStoreNames.contains('userinfo')){
      //keyPath:Javascript对象,对象必须有一属性作为键值
      var objectStore = db.createObjectStore('userinfo',{autoIncrement: true});
      objectStore.createIndex('nameIndex','name',{unique:true});//这里假定名字不能重复,创建基于name的唯一索引
      objectStore.createIndex('ageIndex','age',{unique:false});//创建基于age的索引
    }
  }
}
＜/script＞
</pre>

<pre>
【 利用索引查询数据 】
可以利用索引快速获取数据,name的索引是唯一的没问题,但是对于age索引只会取到第一个匹配值,要想得到所有age符合条件的值就需要使用游标了

</pre><pre class="html">
＜a href="javascript:getDataByIndex('firstdb')"＞indexdb 利用索引查询数据＜/a＞
＜script＞
//利用索引查询数据
function getDataByIndex(indexDbName) {
  var openRequest = indexedDB.open(indexDbName);
  var db;
  openRequest.onerror = function(e) {//当创建数据库失败时候的回调
    console.log("Database error: " + e.target.errorCode);
  };
  openRequest.onsuccess = function(event) {
    console.log("Database created");
    db = openRequest.result; //创建数据库成功时候,将结果给db,此时db就是当前数据库
    var transaction = db.transaction("userinfo",'readwrite');
    var objectStore = transaction.objectStore("userinfo");
    var nameIndex = objectStore.index("nameIndex"); //获得nameIndex索引
    nameIndex.get("小李").onsuccess = function(e) { //根据name索引获得数据成功的回调
     var userinfo = e.target.result;
     console.log("id:"+userinfo.id+"==name:"+userinfo.name+"==age:"+userinfo.age);
    }
  }
}
＜/script＞
</pre>

<pre>
【 游标和索引结合使用 】
刚才不仅创建了一个name的唯一索引,而且还创建了一个age的索引,如果我们根据age来获取数据,有可能会有多条,
由于age不唯一,所以这个时候就需要使用游标来遍历数据。这里我先插入两条age=24的记录

同时可以在opencursor的时候传入key range,来限制范围。
IDBKeyRange.only(value):只获取指定数据
IDBKeyRange.lowerBound(value,isOpen)：获取最小是value的数据,第二个参数用来指示是否排除value值本身,也就是数学中的是否是开区间
IDBKeyRange.upperBound(value,isOpen)：和上面类似,用于获取最大值是value的数据
IDBKeyRange.bound(value1,value2,isOpen1,isOpen2)：表示在value1和value2之间,是否包含value1和value2

例：var request = nameIndex.openCursor(IDBKeyRange.only(Number(24)));
    var request = nameIndex.openCursor(IDBKeyRange.lowerBound(Number(28),true));

</pre><pre class="html">
＜a href="javascript:getDataByAgeIndex('firstdb');"＞indexdb 游标和索引结合使用＜/a＞

//游标和索引结合使用
function getDataByAgeIndex(indexDbName) {
  var openRequest = indexedDB.open(indexDbName);
  var db;
  openRequest.onerror = function(e) {//当创建数据库失败时候的回调
    console.log("Database error: " + e.target.errorCode);
  };
  openRequest.onsuccess = function(event) {
    console.log("Database created");
    db = openRequest.result; //创建数据库成功时候,将结果给db,此时db就是当前数据库
    var transaction = db.transaction("userinfo",'readwrite');
    var objectStore = transaction.objectStore("userinfo");
    var nameIndex = objectStore.index("ageIndex"); //获得ageIndex索引
    var request = nameIndex.openCursor();//openCursor没有参数的时候,表示获得所有数据
    request.onsuccess = function(e) {//openCursor成功的时候回调该方法
      var cursor = e.target.result;
      if (cursor) {//循环遍历cursor
        var userinfo = cursor.value;
        //alert(userinfo.name);
        console.log("id:"+userinfo.id+"==name:"+userinfo.name+"==age:"+userinfo.age);
        cursor.continue();
      };
    }
  }
}
</pre>
</div>

<!--------------------------应用程序缓存---------------------------------------------->
<div id="cache">
<h2>HTML5应用程序缓存-Application Cache</h2>
<h4>某个页面如需在用户访问时启用应用程序缓存,必须在html标签内添加属性：manifest="demo.appcache" ;或者manifest文件中指定该页面</h4>
<pre>
web应用进行缓存,可在没有网络的时候进行访问,但是IE暂不支持,一般浏览器对数据容量限制为5M
1.离线浏览
2.已缓存资源加载更快
3.减少服务器负载

manifest文件是简单的文本文件,告知浏览器被缓存的内容,其扩展名 .appcache
manifest文件必须在web服务器上配置正确的MIME-type,即"text/cache-manifest"

一旦应用被缓存发生以下情况才会更新缓存
1.用户清空浏览器缓存
2.manifest文件被修改,更新注释行中的日期和版本号是一种是浏览器重新缓存文件的办法
3.有程序来更新应用缓存

</pre><pre class="html">
#完整的Manifest文件  #注释行

CACHE MANIFEST      #必须！当manifest文件加载后,浏览器会将下列文件会在首次下载后进行缓存
#2017-03-26 v1.0.0
/vendors/public.css
/logo.gif
/main.js

NETWORK:            #需要与服务器连接,永远不会被缓存的文件资源,可以用*表示其他所有文件
login.php

FALLBACK:	       #规定页面若无法访问时的回退页面,如404.html代替/html5/目录中的所有文件
/html5/  /404.html

</pre>
</div>

<!--------------------------HTML5 web workers---------------------------------------------->
<div id="workers">
<h2>HTML5 web workers</h2><pre>
Web Workers API用来在web应用程序中实现后台处理的一种技术,用户创建在后台运行的线程,可以创建多个worker线程,在不干扰UI、不影响前台响应用户的操作的情况下执行任务
js创建的程序和页面是共用一个单线程的,如果花费时间长的话web界面就会长时间没有响应,设置跳出一个脚本提示框
worker创建后可以向由指定的事件监听函数传递消息,这样worker生成的所有任务就都会接收到这个消息

HTML5 Web Workers是为网页脚本提供了一种能在后台进程中运行的方法。当创建workers象后,WebwbrkerS就可以通过postMessage方法向任务池发送任务请求,执行完之后再通过postMessage返回消息给创建者指定的事件处理程序(事件监听函数),然后通过onmessage捕获返回消息,实现前后台数据的交互

web workers分为2类：
1.dedicated web worker专用线程:为当前页面服务,随当前页面关闭而结束,大多数情况下足够使用
2.shared web worker共享线程:为多个相关页面服务,只有全部关闭才会结束

【 web Workers的局限性 】
1、worker有同源策略限制,即worker无法引入一个跨域的资源来直接使用,但worker的一个方法可绕过同源限制来动态加载其他域脚本

2、为了安全,worker线程无法读取本地文件,它所加载的脚本必须来自网络,且需要与主线程的脚本同源

3、Web Worker无法访问DOM节点,也无法通过任何方式影响页面的外观,如果希望后台程序处理的结果能够改变DOM,只能通过返回消息给创建者的回调函数进行处理

worker线程中的代码具有独立的执行环境,可以把它假想成一个mini的global环境,为便于处理数据,Web Worker本身也是一个最小化的运行环境
worker线程在与主线程的window不同的另一个全局上下文中运行,与当前网页中的代码不共享作用域,其中无法读取主线程所在网页的DOM对象,也不能获取document、window等对象,但可以获取最小化的navgator对象(online、appName、appVersion、userAgent、platform)、location(只读)、XMLHttpRequest、setTimeout、setInterval、clearTimeout()和clearInterval()方法等浏览器API

4、通信限制
worker线程与主线程不在同一个上下文,不能直接通信,需要通过postMessage方法来通信。
在主页面与worker之间传递的数据是通过拷贝,而不是共享来完成的。
传递给worker的对象需要经过序列化,接下来在另一端还需要反序列化。
页面与worker不会共享同一个实例,最终的结果就是在每次通信结束时生成了数据的一个副本。
大部分浏览器使用结构化拷贝来实现该特性

5、脚本限制
worker线程不能执行alert、confirm之类的函数,但可以使用XMLHttpRequest对象发出ajax请求。

6、Web Worker无法访问全局变量或是全局函数
Web Worker中的全局对象是worker对象本身,即在这个特殊的全局作用域中,this和self引用的都是worker对象,self:即当前worker的GlobalWorker对象

7、只能用的上js内置对象和方法,可以使用所有的ECMA对象：Object、Array、Date、JSON对象等

虽然Web Workers不会导致浏览器UI停止响应,但是仍然会消耗CPU周期,导致系统反应速度变慢。
如果开发人员创建的Web应用程序需要执行一些后台数据处理,但又不希望这些数据处理任务影响Web页面本身的交互性,那么可以通过Web Workers生成一个Worker去执行数据处理任务,同时添加一个事件监听器进行监听,并与之进行数据交互

Web Workers接口可以创建真正的系统级别的进程,还可以使用XMLHttpRequest来处理I/O,无论responseXML和channel属性是否为null。使用它可以很容易设计并发操作效果,例如在做网站下载的时候使用Worker,或者使用Worker实现处理扩展功能。

不过因为worker一旦新建就会一直运行,不会被主线程的活动打断,这样有利于随时响应主线程的通性,但是也会造成资源的浪费,所以不应过度使用,用完注意关闭。或者说：如果worker无实例引用,该worker空闲后立即会被关闭;如果worker实列引用不为0,该worker空闲也不会被关闭

【 适用场景 】
主线程可以把计算密集型或高延迟的任务交给worker线程执行,这样主线程就会变得轻松不会被阻塞或拖慢,这并不意味着JS语言本身支持了多线程能力,而是浏览器作为宿主环境提供了JS一个多线程运行的环境

1.可以加载一个JS进行大量的复杂计算而不挂起主进程,并通过postMessage,onmessage进行通信
2.可以在worker中通过importScripts(url)加载另外的脚本文件
3.可以使用setTimeout(), clearTimeout(), setInterval(), and clearInterval()
4.可以使用XMLHttpRequest来发送请求
5.可以访问navigator的部分属性
6.可以使用JavaScript核心对象。

Web Workers的另一个用途是可以监听由后台服务器广播的消息,收到后台服务器的消息后,将其显示在Web页面上。这种与后台服务器对话的场景,Web Workers可能会使用到Web Sockets或Server—Sent事件

1、加密数据
有些加解密的算法比较复杂或在加解密很多数据的时候,这会非常耗费计算资源,导致UI线程无响应,因此这是使用Web Worker的好时机,使用Worker线程可以让用户更加无缝的操作UI。

2、预取数据
有时候为了提升数据加载速度,可以提前使用Worker线程获取数据,因为Worker线程是可以是用XMLHttpRequest

3、预渲染
在某些渲染场景下,比如渲染复杂的canvas时需计算的效果比如反射、折射、光影、材料等,这些计算的逻辑可以使用Worker线程来执行,也可以使用多个Worker线程

4、复杂数据处理场景
某些检索、排序、过滤、分析会非常耗费时间,这时可以使用Web Worker来进行,不占用主线程。

5、预加载图片
有时候一个页面有很多图片或有几个很大的图片的时候,如果业务限制不考虑懒加载,也可以使用Web Worker来加载图片

</pre><pre class="js">
// 主线程
let w = new Worker("js/workers.js");
w.onmessage = function (event) {
  var img = document.createElement("img");
  img.src = window.URL.createObjectURL(event.data);
  document.querySelector('#result').appendChild(img)
}
w.onerror = function(e){
  e.currentTarget.terminate();
  console.log('erro: ' + e.message);
};

// worker线程
let arr = [...imgsUrlArray];
for (let i = 0, len = arr.length; i < len; i++) {
  let req = new XMLHttpRequest();
  req.open('GET', arr[i], true);
  req.responseType = "blob";
  req.setRequestHeader("client_type", "DESKTOP_WEB");
  req.onreadystatechange = () => {
    if (req.readyState == 4) {
      postMessage(req.response);
    }
  }
  req.send(null);
}

</pre>

<h3>Worker线程中全局对象为self,代表子线程自身,这时this指向self</h3><pre>
在主线程中生成Worker线程：
var myWorker = new Worker(jsUrl, options)
jsUrl第一个参数是脚本的网址,必须遵守同源政策,该参数是必需的,且只能加载JS脚本,否则报错
options第二个参数是配置对象,该对象可选。它的一个作用就是指定Worker的名称,用来区分多个Worker线程。

</pre><pre class="js">
// 主线程
var worker = new Worker('a.js');
var myWorker = new Worker('worker.js', { name : 'myWorker' });

// Worker 线程
self.name       // myWorker

</pre><pre>
worker线程中加载脚本的api：
importScripts('script1.js')                  // 加载单个脚本
importScripts('script1.js', 'script2.js')    // 加载多个脚本

w.postMessage(aMessage, transferList)方法接受两个参数
aMessage是可以传递任何类型数据的包括对象,这种通信是拷贝关系,即传值而不是传址,Worker对通信内容的修改,不会影响到主线程。事实上浏览器内部的运行机制是先将通信内容串行化,然后把串行化后的字符串发给Worker,后者再将它还原。
一个可选的Transferable对象的数组,用于传递所有权。如果一个对象的所有权被转移,在发送它的上下文中将变为不可用(中止),并且只有在它被发送到的worker中可用。可转移对象是如ArrayBuffer,MessagePort或ImageBitmap的实例对象,transferList数组中不可传入null

【 outside事件 】
1.onmessage事件
当a.js即worker线程中调用postMessage(sData)方法时, onmessage可以侦听该事件,并执行指定回调方法
指定worker线程发消息时的回调,也可以通过worker.addEventListener('message',cb)的方式
worker.onmessage = e => console.log(e.data)

2.onerror事件
捕获a.js中worker线程中语法异常和运行时各类异常,包括404加载失败的异常
指定worker线程发生错误时的回调,也可以worker.addEventListener('error',cb)

worker.onerror = function(e){
  e.message  // 错误信息
  e.lineno   // 行号
  e.filename //返回完整的错误文件的url
};

worker.addEventListener('message',function(e){ });

【 outside方法 】
1. postMessage方法: 主线程往worker线程发消息,消息可以是任意类型数据,包括二进制数据,worker线程必须同时注册onmessage事件
2. terminate方法: 主线程关闭worker线程

【 inside事件 】
1.onmessage事件
当out页调用worker.postMessage(sData)方法时, onmessage可以侦听该事件,并执行指定回调方法
self.onmessage: 指定主线程发worker线程消息时的回调,也可以self.addEventListener('message',cb)

2、self.onerror: 指定worker线程发生错误时的回调,也可以 self.addEventListener('error',cb)

【 inside方法 】
1. postMessage方法
self.postMessage: worker线程往主线程发消息,消息可以是任意类型数据,包括二进制数据,out页必须同时注册worker.onmessage事件

2. close方法
停掉worker的行为
在worker内部,调用close()方法也可以停止工作。Worker停止工作后就不会再有事件发生。
self.close: worker线程关闭自己

3. importScripts方法
worker线程动态加载外部脚本用;该方法会冻结worker线程,直到动态加载脚本加载完毕或执行完毕(浏览器差异)
importScripts方法支持同时加载多个脚本：importScripts('a.js','b.js','c.js');
同时加载多个脚本在各个浏览器中均为并行加载,前提是HTTP连接数够用
但执行顺序是严格按照参数顺序进行的,即先执行a 后执行b 然后才是c,无论哪个先加载完,FF有差异

Worker的全局作用域中提供了importScripts()方法。这个方法接收一个或多个指向JavaScript文件的URL。
每个加载过程都是异步进行的,因此所有的脚本加载并执行完成之后,importScripts()才会执行
importScripts('file1.js','file2.js');
即使file2.js先于file1.js下载完,执行的时候仍然会按照先后顺序实行,而且这些脚本是在Worker的全局作用域中执行,
如果脚本中包含与页面相关的Js代码,那么脚本可能无法正确运行。

</pre><pre class="html">
// 浏览器下载my_task.js文件,但不会执行它,只有worker接收到消息才会实际执行my_task.js文件中的代码
var myWorker = new Worker("my_task.js");
//如希望收到worker的通知,可以将worker的onmessage属性设置成事件处理函数
myWorker.onmessage = function (oEvent) {
  console.log("Worker said : " + oEvent.data);
};
myWorker.postMessage("ali"); // 如果希望能够发送信息到worker,可以使用postmessage方法

//my_task.js(Worker)
postMessage("I\'m working before postMessage(\'ali\').");
onmessage = function (oEvent) {
  postMessage("Hi " + oEvent.data);
};

*****************************************************************************
//html文档js代码
var w;
function start(){
  alert("计时开始了吗？");
  if(Worker){                               //检测浏览器是否支持worker
    if(!w) w=new Worker("demo_workers.js")  //检测是否存在worker,不存在则新建web worker对象,运行js代码
    w.onmessage = function (event) {        //onmessage监听接收event.data的数据
      document.getElementsByName("time")[0].value=event.data; //该代码在worker js文件中运行
    };
  }else{
    alert("Sorry, your browser does not support Web Workers...");
  }
  alert("计时开始了吗？");   //先测试代码,该js内其他代码执行完毕再执行worker.js
}
function stop(){
  w.terminate();   //终止web worker,释放系统资源
}

//demo_workers.js文档
var i=0;
function timeCount(){
  i++;
  postMessage(i);                  //postMessage()向HTML页面传回一段消息
  setTimeout(timeCount, 1000);
}
timeCount();

</pre>

<h4>例：后台js测试从0加到100,前台计算这个过程需要的耗时,前后台通过监听message事件POSTMessage传递数据
  <a href="./web/HTML5/web-workers2.html" target="_blank">演示</a>
</h4>

<pre class="html">
// HTML代码
  <p>输入：<input type="number" name="number" value="100000000">
      <input type="submit" name="submit" value="叠加求和" onclick="count()">
  </p>
  <p>结果：<input type="text" name="result" value=""></p>
  <p>耗时：<input type="text" name="time" value=""></p>
  <p>后台js测试从0加到100,前台计算这个过程需要的耗时,前后台通过监听message事件POSTMessage传递数据</p>
  <p>多个监听事件</p>

// js代码
  function count(){
    var number=document.getElementsByName("number")[0].value;
    var result=document.getElementsByName("result")[0];
    var time=document.getElementsByName("time")[0];
    result.value=time.value='';
    var i=0
    var timer=setInterval(function(){i++;time.value=i;},1000);   //点击之后开始计时
    if(Worker){
      if(typeof(w)=="undefined"){
        var w=new Worker("demo_workers1.js");
      }
      //w.addEventListener("message",function (event){result.value=event.data;},false);
      w.onmessage=function(event){
        result.value=event.data;
        result.style.background='yellow';
        clearTimeout(timer);               //获得返回数据之后停止计时
        w.terminate();                     //终止web worker,释放系统资源
      }
      w.postMessage(number);
    }else{
      alert("抱歉,您的浏览器不支持Web Workers...");
    }
  }

//demo_workers1.js文件代码
  addEventListener("message",function(event){
    var r=0;
    for(var n=0;n<=event.data;n++){
      r+=n;
    }
    postMessage(r);
  },false);
</pre>
</div>

<div id="Server-Sent">
<h3>HTML5服务器发送事件Server-sent Events SSE</h3><pre>
在Web应用中浏览器和服务器之间使用的是请求/响应的交互模式。
浏览器发出请求,服务器根据收到的请求来生成相应的响应,浏览器再对收到的响应进行处理展现给用户,响应的格式可能是HTML、XML或JSON等。随着REST架构风格和AJAX的流行,服务器更多地使用JSON作为响应的数据格式。Web应用使用XMLHttpRequest对象来发送请求,并根据服务器端返回的数据,对页面的内容进行动态更新。用户在页面上的操作比如点击或移动鼠标会触发相应的事件。由XMLHttpRequest对象来发出请求,得到服务器响应之后进行页面的局部更新。这种方式的不足之处在于：服务器端产生的数据变化不能及时地通知浏览器,而是需要等到下次请求发出时才能被浏览器获取。对于某些对数据实时性要求很高的应用来说,这种延迟是不能接受的。

为了满足这类应用的需求,就需要有某种方式能够从服务器端推送数据给浏览器,以保证服务器端的数据变化可以在第一时间通知给用户。目前常见的解决办法主要可以分成两类,区别在于是否基于HTTP协议来实现。不使用HTTP协议的做法是使用HTML5新增的WebSocket规范,而使用HTTP协议的做法则包括简易轮询、COMET技术和HTML5服务器推送事件

WebSocket使用的是套接字连接,基于TCP协议,适用于需要进行复杂双向数据通讯的场景。使用WebSocket之后实际上在服务器端和浏览器之间建立一个套接字连接,可以进行双向的数据传输。WebSocket的功能是很强大的,使用起来也灵活,可以适用于不同的场景。不过WebSocket技术也比较复杂,包括服务器端和浏览器端的实现都不同于一般的Web应用

Ajax异步轮询/简易轮询即浏览器端定时向服务器端发出请求来查询是否有数据更新,这种做法比较简单,可以在一定程度上解决问题。不过对于轮询的时间间隔需要进行仔细考虑,轮询的间隔过长会导致用户不能及时接收到更新的数据,轮询的间隔过短会导致查询请求过多,增加服务器端的负担

COMET技术改进了简易轮询的缺点,使用的是长轮询。长轮询的方式在每次请求时服务器端会保持该连接在一段时间内处于打开状态,而不是在响应完成之后就立即关闭。这样做的好处是在连接处于打开状态的时间段内,服务器端产生的数据更新可以被及时地返回给浏览器,当上一个长连接关闭之后浏览器会立即打开一个新的长连接来继续请求。不过COMET技术的实现在服务器端和浏览器端都需要第三方库的支持。

对于简单的服务器数据推送的场景,使用服务器推送事件就足够了

【 HTML5服务器推送事件 】
严格地说HTTP协议无法做到服务器主动推送信息,但是有一种变通方法,就是服务器向客户端声明接下来要发送的是流信息)streaming),即发送的不是一次性的数据包,而是一个数据流,会连续不断地发送过来,这时客户端不会关闭连接,会一直等着服务器发过来的新的数据流,视频播放就是这样的例子。本质上这种通信就是以流信息的方式完成一次用时很长的下载。

SSE(Server-Sent事件)就是利用这种机制,使用流信息向浏览器推送信息,它基于HTTP协议,目前除了IE/Edge其他浏览器都支持。

SSE与WebSocket作用相似,都是建立浏览器与服务器之间的通信渠道,然后服务器向浏览器推送信息,总体来说WebSocket更强大和灵活,因为它是全双工通道,可以双向通信;SSE是单向通道,只能服务器向浏览器发送,因为流信息本质上就是下载, 基于http单向消息传递。如果浏览器向服务器发送信息就变成了另一次HTTP请求

SSE的优点
SSE使用HTTP协议,现有的服务器软件都支持,WebSocket是一个独立协议
SSE属于轻量级,使用简单;WebSocket 协议相对复杂
SSE默认支持断线重连,WebSocket需要自己实现
SSE一般只用来传送文本,二进制数据需要编码后传送,WebSocket默认支持传送二进制数据
SSE支持自定义发送的消息类型

在Web应用程序中使用服务器发送事件很简单,在服务器端只需要按照一定的格式返回事件流,在客户端中只需要为一些事件类型绑定监听函数

页面的单线程js会阻断server-sent,有数据的话默认是3s推送一次

Server-sent Events规范主要由两个部分组成：第一个部分是服务器端与浏览器端之间的通讯协议,第二部分则是在浏览器端可供js使用的EventSource对象
通讯协议是基于纯文本的简单协议
服务器端的响应的内容类型是"text/event-stream",PHP报头"Content-Type"设置为"text/event-stream",事件流

【 事件流格式 】
事件流仅仅是一个简单的文本数据流,文本应该使用UTF-8格式的编码,每条消息后面都由一个空行作为分隔符,每条消息是由多个字段组成的,每个字段由字段名、冒号及字段值组成

响应文本的内容(string类型)可以看成是一个事件流,由不同的事件所组成,每个事件由类型和数据两部分组成,同时每个事件可以有一个可选的标识符,每个事件的数据可能由多行组成。不同事件的内容之间通过仅包含回车符和换行符的空行("\r\n")来分隔

</pre>服务器端响应的示例<pre class="js">
未命名事件:The default event type is "message"
: this is a test stream

data: first event            // 只包含数据"first event",会产生默认的事件"message"

data: second event           // 标识符是100,数据为"second event"
id: 100

: this is a comment          // 最后一个事件的数据为"fourth event\nfourth event continue"
data: fourth event           // 当有多行数据时,实际的数据由每行数据以换行符连接而成。
data: fourth event continue

data: other message, it      // 该消息包含的两个data字段会被解析成为一个字段,值为"other message, it\nhas two lines."
data: has two lines.

命名事件:每个事件的类型都是由event字段指定的,另外每个data字段的值可以使用JSON格式,当然也可以不是
event: myevent               // 第三个事件会产生类型为"myevent"的事件
data: third event
id: 101

event: userconnect
data: {"username": "bobby", "time": "02:33:48"}

event: add                  // 自定义事件
data: 73857293

event: remove
data: 2153

event: userconnect
data: {"username": "bobby", "time": "02:33:48"}

event: usermessage
data: {"username": "bobby", "time": "02:34:11", "text": "Hi everyone."}

event: userdisconnect
data: {"username": "bobby", "time": "02:34:23"}

event: usermessage
data: {"username": "sean", "time": "02:34:36", "text": "Bye, bobby."}

</pre><pre>
每一行冒号前面表示的是该行的类型,冒号后面则是对应的值,可能的类型包括：
1、类型为空白
冒号开头表示该行是注释,在处理时被忽略,注释行可以用来防止连接超时,服务器可以定期发送一条消息注释行,以保持连接不断

2、类型为data
表示该行包含的是数据,以data开头的行可以出现多次,所有这些行都是该事件的数据,客户端会用换行符把它们连接成一个字符串来作为字段值

data:  message\n\n

如果数据很长可以分成多行,最后一行用\n\n结尾,前面行都用\n结尾。
data: begin message\n
data: continue message\n\n

发送JSON数据
data: {\n
data: "foo": "bar",\n
data: "baz", 555\n
data: }\n\n

3、类型为event
表示该行用来声明事件的类型,浏览器在收到数据时会产生对应类型的事件。
如果指定了该字段则在客户端接收到该条消息时会在当前的EventSource对象上触发一个事件,事件类型就是该字段的字段值,可以使用addEventListener()方法在当前EventSource对象上监听任意类型的命名事件,如果该条消息没有event字段则会触发onmessage属性上的事件处理函数,即每人为message类型

event字段表示自定义的事件类型,默认是message事件,浏览器可以用addEventListener()监听该事件。

event: foo\n
data: a foo event\n\n

data: an unnamed event\n\n

event: bar\n
data: a bar event\n\n

event: userconnect
data: {"username": "bobby", "time": "02:33:48"}

event: usermessage
data: {"username": "bobby", "time": "02:34:11", "text": "Hi everyone."}

event: userdisconnect
data: {"username": "bobby", "time": "02:34:23"}

event: usermessage
data: {"username": "sean", "time": "02:34:36", "text": "Bye, bobby."}

4、类型为id
表示该行用来声明事件的标识符,事件ID,数据标识符用id字段表示,相当于每一条数据的编号

浏览器用lastEventId属性读取这个值。
一旦连接断线,浏览器会发送一个HTTP头里面包含一个特殊的Last-Event-ID头信息,将这个值发送回来,用来帮助服务器端重建连接,因此这个头信息可以被视为一种同步机制

id: msg1\n
data: message\n\n

5、类型为retry
服务器可以用retry字段指定浏览器重新发起连接的时间间隔
一个整数值,指定了重新连接的时间(单位为毫秒),如果该字段值不是整数则会被忽略
两种情况会导致浏览器重新发起连接：一种是时间间隔到期,二是由于网络错误等原因,导致连接出错

retry: 10000\n

除了上面规定的字段名,其他所有的字段名都会被忽略
如果一行文本中不包含冒号,则整行文本会被解析成为字段名,其字段值为空

如果服务器端返回的数据中包含了事件的标识符,浏览器会记录最近一次接收到的事件的标识符,如果与服务器端的连接中断,当浏览器端再次进行连接时会通过HTTP头"Last-Event-ID"来声明最后一次接收到的事件的标识符,服务器端可以通过浏览器端发送的事件标识符来确定从哪个事件开始来继续连接。

【 EventSource对象 】
SSE的客户端API部署在EventSource对象上

对于服务器端返回的响应,浏览器端需要在js中使用EventSource对象来进行处理,EventSource对象用于接收服务器发送事件通知,EventSource使用的是标准的事件监听器方式,只需要在对象上添加相应的事件处理方法即可,服务器端可以返回自定义类型的事件,可以使用addEventListener方法来添加相应的事件处理方法

</pre>The EventSource interface<pre class="js">
[Constructor(DOMString url, optional EventSourceInit eventSourceInitDict)]
interface EventSource : EventTarget {
  readonly attribute DOMString url;
  readonly attribute boolean withCredentials;

  // ready state
  const unsigned short CONNECTING = 0;
  const unsigned short OPEN = 1;
  const unsigned short CLOSED = 2;
  readonly attribute unsigned short readyState;

  // networking
  attribute EventHandler onopen;
  attribute EventHandler onmessage;
  attribute EventHandler onerror;
  void close();
};

dictionary EventSourceInit {
  boolean withCredentials = false;
};

</pre><pre>
if ('EventSource' in window) {
  console.log('检测浏览器是否支持 SSE');
}

使用SSE时浏览器首先生成一个EventSource实例向服务器发起连接
var source = new EventSource(url);

参数url可以与当前网址同域,也可以跨域,跨域时可以指定第二个参数打开withCredentials属性,表示是否一起发送Cookie。
var source = new EventSource(url, { withCredentials: true });

EventSource实例的withCredentials属性
默认false

EventSource实例的url属性
返回完整的url路径,如"http://localhost/study/web/html5/demo_sse.php"

EventSource实例的readyState属性,表明连接的当前状态,该属性只读,可以取以下值。
0：相当于常量EventSource.CONNECTING,表示连接还未建立或断线正在重连。
1：相当于常量EventSource.OPEN,表示连接已经建立,可以接受数据。
2：相当于常量EventSource.CLOSED,表示连接已断,且不会重连。

source.close();
close方法用于关闭SSE连接。

EventSource提供了三个标准事件
1、open
当成功与服务器建立连接时产生,连接一旦建立就会触发open事件,可以在onopen属性定义回调函数

2、message
当客户端收到服务器发送的消息数据时触发message事件,可以在onmessage属性的回调函数获取消息,事件对象的data属性就是服务器端传回的文本格式数据

3、error
如果发生通信错误比如连接中断就会触发error事件,可以在onerror属性定义回调函数

MessageEvent事件对象
MessageEvent {
bubbles:false,
cancelBubble:false,
cancelable:false,
composed:false,
currentTarget:EventSource {url: "http://localhost/study/web/html5/demo_sse.php", withCredentials: false, readyState: 2, onopen: null, onmessage: ƒ, …},
data:"The server time is:Sun, 16 Jun 2019 13:23:38 +0800",
defaultPrevented:false,
eventPhase:0,
isTrusted:true,
lastEventId:"",
origin:"http://localhost",
path:[],
ports:[],
returnValue:true,
source:null,
srcElement:EventSource {url: "http://localhost/study/web/html5/demo_sse.php", withCredentials: false, readyState: 2, onopen: null, onmessage: ƒ, …},
target:EventSource {url: "http://localhost/study/web/html5/demo_sse.php", withCredentials: false, readyState: 2, onopen: null, onmessage: ƒ, …},
timeStamp:835.4200000000001,
type:"message",
__proto__:MessageEvent
}

</pre><pre class="js">
var es = new EventSource('events');   // 在指定URL创建出EventSource对象
es.onmessage = function(e) {
  console.log(e.data);
};
es.addEventListener('myeventPing', function(e) {
  console.log(e.data);
});

</pre><pre class="js">
var source = new EventSource('demo_sse.php');
source.onopen = function (event) {
  console.log('Connection open ...');
};
source.onerror = function (event) {
  console.log('Connection close');
};
source.onmessage = function (event) {
  console.log('Message: ' + event.data);
};

// php code
date_default_timezone_set("PRC");
header('Content-Type:text/event-stream');  // 设置报头
header('Cache-Control:no-cache');          // 规定不对页面进行缓存
$time = date('r');
echo "data:The server time is:{$time}\n\n";
flush();

// 循环输出以下内容
Connection open ...
Message: The server time is:Sun, 16 Jun 2019 13:38:39 +0800
Connection close
Connection open ...
Message: The server time is:Sun, 16 Jun 2019 13:38:42 +0800
Connection close

</pre><pre>
【 自定义事件 】
默认情况下服务器发来的数据总是触发浏览器EventSource实例的message事件,还可以自定义SSE事件,这种情况下发送回来的数据不会触发message事件。

</pre><pre class="js">
source.addEventListener('foo', function (event) {  // 浏览器对SSE的foo事件进行监听
  var data = event.data;
  // handle message
}, false);

source.onfoo = function (event) {                  // 浏览器对SSE的foo事件进行监听
  var data = event.data;
  // handle message
};

</pre><pre>
【 服务器端实现 】
服务器端推送事件是一个比较简单的协议,服务器端的实现也相对比较简单,只需要按照协议规定的格式返回响应内容即可。在开源社区可以找到各种不同的服务器端技术相对应的实现。自己开发的难度也不大

服务器向浏览器发送的SSE数据必须是UTF-8编码的文本,具有如下的HTTP头信息。
Content-Type: text/event-stream  // 必须为event-stream
Cache-Control: no-cache
Connection: keep-alive

每一次发送的信息,由若干个message组成,每个message之间用\n\n分隔,每个message内部由若干行组成,每一行都是如下格式。
[field]: value\n

</pre><pre class="js">
<h1>获得服务器更新</h1>
<div id="result"></div>

if(EventSource){
  var source = new EventSource("demo_sse.php");  // 新建EventSource对象,初始化了一个事件源,规定发送更新的页面URL
  source.onmessage = function(e){                // 每接收到一次更新数据就发生onmessage事件
    document.getElementById("result").innerHTML += e.data+"<br/>";
  }
}else{
  document.getElementById("result").innerHTML = "抱歉,您的浏览器不支持server-sent事件";
}

// demo_sse.php服务器端发送事件流
date_default_timezone_set("PRC");
header('Content-Type:text/event-stream');  // 设置报头
header('Cache-Control:no-cache');          // 规定不对页面进行缓存
$time = date('r');
echo "data:The server time is:{$time}\n\n";
flush();                                   // 向网页刷新输出数据

// demo_sse2.php
// 让服务器每隔一秒生成一个事件流并返回,其中每条消息的事件类型为"ping",数据字段都使用了JSON格式,数组字段中包含了每个事件流生成时的时间字符串.而且会随机返回一些无事件类型的消息
date_default_timezone_set("PRC");
header("Content-Type: text/event-stream\n\n");
$counter = rand(1, 10);
while (1) {
  // Every second, sent a "ping" event.
  echo "event: ping\n";
  $curDate = date(DATE_ISO8601);
  echo 'data: {"time": "' . $curDate . '"}';
  echo "\n\n";

  // Send a simple message at random intervals.
  $counter--;
  if (!$counter) {
    echo 'data: This is a message at time ' . $curDate . "\n\n";
    $counter = rand(1, 10);
  }
  ob_flush();
  flush();
  sleep(1);
}

</pre><pre>
【 Node服务器实例 】
SSE要求服务器与浏览器保持连接。对于不同的服务器软件来说,所消耗的资源是不一样的。Apache服务器每个连接就是一个线程,如果要维持大量连接势必要消耗大量资源。Node则是所有连接都使用同一个线程,因此消耗的资源会小得多,但是这要求每个连接不能包含很耗时的操作,比如磁盘的IO读写

</pre><pre class="js">
var http = require("http");

http.createServer(function (req, res) {
  var fileName = "." + req.url;

  if (fileName === "./stream") {
    res.writeHead(200, {
      "Content-Type":"text/event-stream",
      "Cache-Control":"no-cache",
      "Connection":"keep-alive",
      "Access-Control-Allow-Origin": '*',
    });
    res.write("retry: 10000\n");
    res.write("event: connecttime\n");
    res.write("data: " + (new Date()) + "\n\n");
    res.write("data: " + (new Date()) + "\n\n");

    interval = setInterval(function () {
      res.write("data: " + (new Date()) + "\n\n");
    }, 1000);

    req.connection.addListener("close", function () {
      clearInterval(interval);
    }, false);
  }
}).listen(8844, "127.0.0.1");

</pre>

<h4>IE支持</h4><pre>
使用浏览器原生的EventSource对象的一个比较大的问题是IE并不提供支持。为了在IE上提供同样的支持一般有两种办法,第一种办法是在其他浏览器上使用原生EventSource对象,而在IE上则使用简易轮询或COMET技术来实现;另外一种做法是使用polyfill技术,即在页面中加载使用第三方提供的js库来屏蔽浏览器的不同即可,应用本身的浏览器端代码并不需要进行改动。一般推荐使用第二种做法,这样在服务器端只需要使用一种实现技术即可。

在IE上提供类似原生EventSource对象的实现并不简单。理论上来说只需要通过XMLHttpRequest对象来获取服务器端的响应内容,并通过文本解析,就可以提取出相应的事件,并触发对应的事件处理方法。不过问题在于IE上的XMLHttpRequest对象并不支持获取部分的响应内容。只有在响应完成之后才能获取其内容。由于服务器端推送事件使用的是一个长连接。当连接一直处于打开状态时,通过XMLHttpRequest对象并不能获取响应的内容,也就无法触发对应的事件。更具体的来说,当XMLHttpRequest对象的readyState为3(READYSTATE_INTERACTIVE)时其responseText属性是无法获取的。

为了解决IE上XMLHttpRequest对象的问题就需要使用IE 8中引入的XDomainRequest对象。XDomainRequest对象的作用是发出跨域的AJAX请求。XDomainRequest对象提供了onprogress事件。当onprogress事件发生时可以通过responseText属性来获取到响应的部分内容。这是XDomainRequest对象和XMLHttpRequest对象的最大不同,也是使用XDomainRequest对象来实现类似原生EventSource对象的基础。在使用XDomainRequest对象打开与服务器端的连接之后,当服务器端有新的数据产生时可以通过XDomainRequest对象的onprogress事件的处理方法来进行处理,对接收到的数据进行解析,根据数据的内容触发相应的事件。

不过由于XDomainRequest对象本来的目的是发出跨域AJAX请求,考虑到跨域访问的安全性问题,XDomainRequest对象在使用时的限制也比较严格。这些限制会影响到其作为EventSource对象的实现方式。

具体的限制和解决办法如下所示：
1、服务器端的响应需要包含Access-Control-Allow-Origin头,用来声明允许从哪些域访问该URL。"*"表示允许来自任何域的访问,不推荐使用该值。一般使用与当前应用相同的域,限制只允许来自当前域的访问。

2、XDomainRequest对象发出的请求不能包含自定义的HTTP头,这就限制了不能使用Last-Event-ID头来声明浏览器端最近一次接收到的事件的标识符。只能通过HTTP请求的其他方式来传递该标识符,如GET请求的参数或POST请求的内容体。

3、XDomainRequest对象的请求的内容类型(Content-Type)只能是"text/plain"。这就意味着当使用POST请求时服务器端使用的框架如servlet不会对POST请求的内容进行自动解析,无法使用HttpServletRequest类的getParameter方法来获取POST请求的内容。只能在服务器端对原始的请求内容进行解析,获取到其中的参数的值。

4、XDomainRequest对象发出的请求中不包含任何与用户认证相关的信息包括cookie等。这就意味着如果服务器端需要认证则需要通过HTTP请求的其他方式来传递用户的认证信息,比如session的ID等。

由于XDomainRequest对象的这些限制,服务器端的实现也需要作出相应的改动。这些改动包括返回Access-Control-Allow-Origin头;对于浏览器端发送的"text/plain"类型的参数进行解析;处理请求中包含的用户认证相关的信息。

可使用的polyfill库是GitHub上的Yaffle开发的EventSource项目,在使用该polyfill库并对服务器端的实现进行修改之后,就可以在IE 8及以上的浏览器中使用服务器推送事件。如果需要支持IE 7则只能使用简易轮询或COMET技术

</pre>
</div>

<div id="404">
<h3>404页面</h3><pre>
死链：网站上不存在或已删除的页面
404页面是客户端在浏览网页时,服务器无法正常提供信息,或是服务器无法回应,且不知道原因所返回的页面。
当用户输入了错误的链接时,返回的页面,
它会告诉浏览者其所请求的页面不存在或链接错误,同时引导用户使用网站其他页面而不是关闭窗口离开,
自定义404错误页面是增强用户体验的很好的做法。

404页面不能转向网站主页,否则可能会导致主页在搜索引擎中消失

您好像迷路了,请返回重试！

apache配置文件httpd.conf修改404

404error
抱歉！页面无法访问……
此处为世界尽头
请穿越到首页吧
可能因为：
网址有错误,请检查地址是否完整或存在多余的字符
网址已失效,可能页面已删除,活动已下线等
返回首页

</pre>
</div>

<div id="load">
<h2>html加载、解析、渲染优化</h2><pre>
浏览器的主要功能是将用户选择的web资源呈现出来,它需要从服务器请求资源,并将其显示在浏览器窗口中
前端资源包括html、css、js、image、flash、audio、video、pdf等

【 浏览器的主要组件 】
1. 用户界面: 包括地址栏、后退/前进按钮、书签目录等,也就是看到的除了用来显示你所请求页面的主窗口之外的其他部分;
2. 浏览器引擎: 用来查询及操作渲染引擎的接口;
3. 渲染引擎： 用来显示请求的内容,例如如果请求内容为html,它负责解析html及css,并将解析后的结果显示出来;
4. 网络: 用来完成网络调用,例如http请求,它具有平台无关的接口,可以在不同平台上工作;
5. UI后端: 用来绘制类似组合选择框及对话框等基本组件,具有不特定于某个平台的通用接口,底层使用操作系统的用户接口;
6. JS解释器: 用来解释执行JS代码;
7. 数据存储: H5定义了web database技术,这是一种轻量级完整的客户端存储技术;

【 浏览器工作流程 】
1、用户输入网址,用URI来指定所请求资源的位置,浏览器调用loadUrl解析url
2、浏览器查找域名的IP地址,DNS服务器通过域名查找对应的web服务器ip地址,如果浏览器有dns缓存则直接返回IP,否则查询本地机器的DNS,并逐层往上查找。最终返回IP,然后将其存到DNS缓存并设置过期时间
3、浏览器调用网络模块,和目标IP建立TCP连接,涉及到客户端与服务器的tcp三次握手与四次挥手,再给web服务器发送一个HTTP请求
4、网站服务的永久重定向响应
5、浏览器跟踪重定向地址,现在浏览器知道了要访问的正确地址,所以它会发送另一个获取请求。
6、服务器处理请求,服务器接收到获取请求,然后处理并返回一个响应。
7、服务器发回一个HTML响应
8、浏览器开始显示HTML,解析html构建dom树 -> 构建render树 -> 布局render树 -> 绘制render树
9、浏览器发送请求,以获取嵌入在HTML中的对象。在浏览器显示HTML时它会注意到需要获取其他地址内容的标签。这时浏览器会发送一个获取请求来重新获得这些文件。这些文件就包括CSS/JS/图片等资源,这些资源的地址都要经历一个和HTML读取类似的过程。所以浏览器会在DNS中查找这些域名,发送请求,重定向等;

【 HTML页面加载和解析流程 】
1、用户第一次访问输入html页面网址,浏览器向服务器发出请求,服务器返回html文件。
2、浏览器开始载入html代码,从head标签开始逐行解析,发现head标签内有一个link标签引用外部CSS文件,浏览器又发出CSS文件的异步请求,有多个css文件会同时加载,服务器返回CSS文件。
3、遇到script标签或js文件就会立即执行,js文件是阻塞式的同步加载,当浏览器在执行js代码时不会做其他的事情,只有js代码执行后才会继续渲染页面,脚本文件的下载和执行会阻断其他资源文件的下载,无疑将大大降低浏览器性能,所以应该把js放到页面的底部,将JS代码交给JS引擎执行
4、到了body标签就开始渲染页面,并且CSS文件已经加载,按照从头到尾的顺序依次渲染dom元素,开始渲染页面
5、代码中发现img标签时向服务器发出异步请求,此时浏览器不会等到图片下载完,而是继续渲染后面的代码
6、服务器返回图片文件,由于图片占用了一定面积,影响了后面段落的排布,浏览器要回过头来重新渲染这部分代码
7、浏览器发现一个包含一行Js代码的script标签会立即执行
8、Js脚本语句命令浏览器隐藏掉代码中的某元素(style.display="none"),浏览器不得不重新渲染这部分代码
9、如果遇到了dom节点的变化,元素尺寸变化,浏览器不得不回头重新渲染这部分代码
10、终于等到了html结束标签的到来
11、用户点了一下界面中的"换肤"按钮,Javascript让浏览器换了一下link标签的CSS路径
12、浏览器召集所有页面html元素,根据用户的操作,浏览器向服务器请求了新的CSS文件,重新渲染页面

两点
一是加载优化,即提高资源加载的速度
二是渲染优化,即资源拿到之后到解析完成的阶段的优化

通过Network瀑布流Waterfall可以查看资源加载的过程

【 浏览器加载和渲染html的顺序 】
1、浏览器为了体验友好,并不是文档全部都解析才绘制到屏幕上,而是从上至下开始解析html,浏览器下载的顺序是从上到下,渲染的顺序也是从上到下,下载和渲染是同时进行的,遇到css会开启线程下载css
2、在渲染到页面的某一部分时,其上面的所有部分都已经下载完成,并不是说所有相关联的元素都已经下载完
3、如果遇到语义解释性的标签嵌入文件(JS脚本、CSS样式),那么此时IE的下载过程会启用单独连接进行下载
4、样式表在下载完成后,将和以前下载的所有样式表一起进行解析,解析完成后将对此前所有元素(含以前已经渲染的)重新进行渲染
5、JS、CSS中如有重定义,后定义函数将覆盖前定义函数

解析：
1、将HTML构建成一个DOM树,构建过程是深度遍历,当前节点的所有子节点都构建好后才会去构建当前节点的下一个兄弟节点
2、将CSS解析成CSS去构造CSSOM树(CSS Object Model CSS对象模型)
3、根据DOM树和CSSOM构造Rendering Tree(渲染树)。渲染树不等同于DOM树,像header或display:none的元素没必要放在渲染树中
4、有了Render Tree,浏览器已经能知道网页中有哪些节点、各个节点的CSS定义以及他们的从属关系。
5、Layout就是计算出每个节点在屏幕中的位置,layout render tree,为每个元素计算尺寸和位置信息
6、绘制(Paint)即遍历render树,并使用浏览器UI后端层绘制每个节点。
7、执行图层合并(Composite Layers)

为了尽快的让用户看到页面内容,需要快速的完成DOM+CSSOM - Layout - Paint - Composite Layers的整个过程,一切会阻塞DOM生成阻塞CSSOM生成的动作都应尽可能消除或延迟

CSS是阻塞渲染的资源,需要将它尽早尽快地下载到客户端,以便缩短首次渲染的时间,通常们将css放在head里面优先加载执行

js既可以操作CSS,也可以直接修改DOM。浏览器不知道JS的具体内容,因此默认情况下Js会阻止渲染引擎的执行,转而去执行JS线程,如果是外部js文件,浏览器必须停下来,等待从磁盘、缓存或远程服务器获取脚本,这就可能给关键渲染路径增加数十至数千毫秒的延迟,除非遇到带有async或defer的标签。向script标记添加异步关键字可以指示浏览器在等待脚本可用期间不阻止DOM构建,这样可以显著提升性能

为弄清每个对象在网页上的确切大小和位置,浏览器从渲染树的根节点开始进行遍历,根据盒模型和CSS计算规则生成计算样式computed style,最后调用绘制线程将DOM绘制到页面上

【 performance api 】
实际项目中采用打点的方式,即在关键的地方埋点,然后根据需要将打点信息进行计算得到各项指标

window.performance.timing对象包含了完整的网页加载性能数据

在浏览器console中输入performance.timing
PerformanceTiming {
connectEnd: 1576344731788
connectStart: 1576344731788
domComplete: 1576345072538
domContentLoadedEventEnd: 1576344755769
domContentLoadedEventStart: 1576344753388
domInteractive: 1576344753386
domLoading: 1576344732600
domainLookupEnd: 1576344731788
domainLookupStart: 1576344731788
fetchStart: 1576344731788
loadEventEnd: 1576345072553
loadEventStart: 1576345072539
navigationStart: 1576344731774
redirectEnd: 0
redirectStart: 0
requestStart: 1576344731790
responseEnd: 1576344750323
responseStart: 1576344732077
secureConnectionStart: 0
unloadEventEnd: 0
unloadEventStart: 0
__proto__: PerformanceTiming
}

返回的各字节返回毫秒时间戳和js中直接new Date().getTime()的时间不一样,这个时间和真实时间没有关系,而且perfermance api精确度更高。

connectEnd	浏览器与服务器之间的连接建立时的时间戳,连接建立指的是所有握手和认证过程全部结束
connectStart	HTTP请求开始向服务器发送时的时间戳,如果是持久连接则等同于fetchStart。
domComplete	当前网页DOM结构生成时即Document.readyState属性变为complete且相应的readystatechange事件触发时的时间戳。
domContentLoadedEventEnd	当前网页DOMContentLoaded事件发生时,也就是DOM结构解析完毕、所有脚本运行完成时的时间戳。
domContentLoadedEventStart	当前网页DOMContentLoaded事件发生时,也就是DOM结构解析完毕、所有脚本开始运行时的时间戳。
domInteractive	当前网页DOM结构结束解析、开始加载内嵌资源时,也就是Document.readyState属性变为“interactive”、并且相应的readystatechange事件触发时的时间戳。
domLoading	当前网页DOM结构开始解析时即Document.readyState属性变为loading且相应的readystatechange事件触发时的时间戳。
domainLookupEnd	域名查询结束时的时间戳。如果使用持久连接,或者从本地缓存获取信息的,等同于fetchStart
domainLookupStart	域名查询开始时的时间戳。如果使用持久连接,或者从本地缓存获取信息的,等同于fetchStart
fetchStart	浏览器准备通过HTTP请求去获取页面的时间戳。在检查应用缓存之前发生。
loadEventEnd	当前网页load事件的回调函数结束时的时间戳。如果该事件还没有发生,返回0。
loadEventStart	当前网页load事件的回调函数开始时的时间戳。如果该事件还没有发生,返回0。
navigationStart	当前浏览器窗口的前一个网页关闭,发生unload事件时的时间戳。如果没有前一个网页,就等于fetchStart
redirectEnd	最后一次重定向完成,也就是Http响应的最后一个字节返回时的时间戳。如果没有重定向或上次重定向不是同源的则为0
redirectStart	第一次重定向开始时的时间戳,如果没有重定向,或者上次重定向不是同源的。则为0
requestStart	浏览器向服务器发出HTTP请求时或开始读取本地缓存时的时间戳。
responseEnd	浏览器从服务器收到或从本地缓存读取最后一个字节时的时间戳,如果在此之前HTTP连接已经关闭则返回关闭时的时间戳
responseStart	浏览器从服务器收到或从本地缓存读取第一个字节时的时间戳。
secureConnectionStart	浏览器与服务器开始安全链接的握手时的时间戳。如果当前网页不要求安全连接则返回0。
unloadEventEnd	如果前网页与当前网页属于同域下则表示前一个网页的unload回调结束时的时间戳。如果没有前一个网页或之前的网页跳转不是属于同一个域内则返回值为0。
unloadEventStart	如果前网页与当前网页属于同域下则表示前一个网页的unload事件发生时的时间戳。如果没有前一个网页或之前的网页跳转不是属于同一个域内则返回值为0。

了解上面timeing提供的各种属性之后,可以计算出网页在加载时候某一部分消耗的具体时间,可以精确到千分之一毫秒。例如要计算出发送请求到接受完数据所消耗的时间。
const timing = window.performance.timing
const contactDuration = timing.responseEnd - timing.requestStart

.navigationStart 准备加载页面的起始时间
.unloadEventStart 如果前一个文档和当前文档同源,返回前一个文档开始unload的时间
.unloadEventEnd 如果前一个文档和当前文档同源,返回前一个文档开始unload结束的时间
.redirectStart 如果有重定向,这里是重定向开始的时间.
.redirectEnd 如果有重定向,这里是重定向结束的时间.
.fetchStart 开始检查缓存或开始获取资源的时间
.domainLookupStart 开始进行dns查询的时间
.domainLookupEnd dns 查询结束的时间
.connectStart 开始建立连接请求资源的时间
.connectEnd 建立连接成功的时间
.secureConnectionStart 如果是https请求,返回ssl握手的时间
.requestStart 开始请求文档时间(包括从服务器,本地缓存请求)
.responseStart 接收到第一个字节的时间
.responseEnd 接收到最后一个字节的时间
.domLoading 'current document readiness' 设置为loading的时间 (这个时候还没开始解析文档)
.domInteractive 文档解析结束的时间
.domContentLoadedEventStart DOMContentLoaded事件开始的时间
.domContentLoadedEventEnd DOMContentLoaded事件结束的时间
.domComplete current document readiness被设置complete的时间
.loadEventStart 触发onload事件的时间
.loadEventEnd onload事件结束的时间

通过performance.timing对象各个属性获取页面加载期间各个阶段的性能
1、页面加载的第一个时间点是navigationStart,表示上一个页面的unload事件触发,接下来的事件点是fetchStart,表示开始获取当前页面内容,fetchStart时间点和navigationStart时间点之间的时间差是浏览器内核为加载新页面做的一些准备工作耗时

2、获取页面内容的第一步是查询是否有跟页面相关的资源缓存,查询完毕之后会触发开始DNS解析的时间点domainLookupStart,domainLookupStart时间点和fetchStart事件点之间的时间差是查询缓存所消耗的时间

3、DNS解析结束的时间点是domainLookupEnd,omainLookupEnd时间点和domainLookupStart时间点之间的时间差是DNS解析消耗的时间

4、DNS解析技术之后会开始建立TCP连接,TCP连接开始和结束的时间点分别是connectStart和connectEnd,connectStart时间点紧接着domainLookupEnd时间点,connectEnd时间点和connectStart时间点之间的时间差是建立TCP消耗的时间

5、TCP连接建立之后,开始发送请求内容至服务器端,这个时间点是requestStart,服务器端接收到完整请求并处理完毕后,会将响应结果返回客户端, 开始发送响应结果的时间点为responseStart,浏览器收到完整的响应结果之后会触发responseEnd时间点

6、浏览器接收到响应的结果之后会开始DOM树解析,这个时间点是domLoading,DOM解析完成的时间点是domInteractive,DOM解析完成是指DOM树构建完成,页面依赖的外部资源如css、js、图片等还未开始加载,domLoading时间点不一定在responseEnd时间点之后,有可能浏览器只接受了部分响应数据就开始解析DOM树

7、DOM树解析完成之后会开始按照顺序运行页面脚本和加载依赖外部资源,其中JS资源会同步加载和执行,一但所有页面脚本运行完毕会触发DOMContentLoaded事件,这个时间点是domContentLoadedStart

8、开发者注册的DOMContentLoaded事件执行完毕之后会触发domContentLoadedEnd时间点

9、当依赖的外部资源全部加载并解析完成之后会触发domComplete时间点,同时会发触发暴露给开发者的load事件,loadEventStart时间点表示load事件开始触发,loadEventEnd时间点表示所有开发者注册在load事件上的脚本执行完毕

</pre><pre class="js">
window.onload = function(){
  setTimeout(function(){
    let t = performance.timing
    console.log('DNS查询耗时 ：' + (t.domainLookupEnd - t.domainLookupStart).toFixed(0))
    console.log('TCP链接耗时 ：' + (t.connectEnd - t.connectStart).toFixed(0))
    console.log('request请求耗时 ：' + (t.responseEnd - t.responseStart).toFixed(0))
    console.log('解析dom树耗时 ：' + (t.domComplete - t.domInteractive).toFixed(0))
    console.log('白屏时间 ：' + (t.responseStart - t.navigationStart).toFixed(0))
    console.log('domready时间 ：' + (t.domContentLoadedEventEnd - t.navigationStart).toFixed(0))
    console.log('onload时间 ：' + (t.loadEventEnd - t.navigationStart).toFixed(0))

    if(t = performance.memory){
      console.log('js内存使用占比 ：' + (t.usedJSHeapSize / t.totalJSHeapSize * 100).toFixed(2) + '%')
    }
  })
}

if("performance" in window){ 
  window.addEventListener("load", ()=>{ 
    let paintMetrics = performance.getEntriesByType("paint");   // 将所有"paint"类型的事件收集到paintMetrics变量中
    if(paintMetrics !== undefined && paintMetrics.length > 0){ 
      paintMetrics.forEach((paintMetric)=>{ 
        console.log(`${paintMetric.name}: ${paintMetric.startTime}`);
      }); 
    } 
  }); 
}

</pre><pre>
PerformanceNavigation接口
呈现了如何导航到当前文档的信息。PerformanceNavigation有两个属性,一个是type,表示如何导航到当前页面的,主要有4个值。
type=0：表示当前页面是通过点击链接,书签和表单提交,或者脚本操作,或者在url中直接输入地址访问的。
type=1: 表示当前页面是点击刷新或调用Location.reload()方法访问的。
type=2: 表示当前页面是通过历史记录或者前进后退按钮访问的。
type=255: 其他方式访问的
另外一个属性是redirectCount表示到达当前页面之前经过几次重定向。

如果performamce api埋的点不够用,还可以自定义一些关心的指标,比如请求时间)成功和失败分开统计)、较长js操作时间或比较重要的功能等

</pre>

<h3>前端优化</h3><pre>
【 页面重构 】
网站重构：在不改变外部行为的前提下,简化结构、添加可读性,而在网站前端保持一致的行为。 也就是说是在不改变UI的情况下,对网站进行优化,在扩展的同时保持一致的UI。

对于传统的网站来说重构通常是：
表格(table)布局改为DIV+CSS 使网站前端兼容于现代浏览器(针对于不合规范的CSS、如对IE6有效的) 对于移动平台的优化 针对于SEO进行优化 深层次的网站重构应该考虑的方面
减少代码间的耦合,让代码保持弹性,严格按规范编写代码,设计可扩展的API,代替旧有的框架、语言(如VB),增强用户体验,通常来说对于速度的优化也包含在重构中
压缩JS、CSS、image等前端资源(通常是由服务器来解决) 程序的性能优化(如数据读写) 采用CDN来加速资源加载 对于JS DOM的优化 HTTP服务器的文件缓存

前端优化的目的
1.从用户角度而言,优化能够让页面加载得更快、对用户的操作响应得更及时,能够给用户提供更为友好的体验。
2.从服务商角度而言,优化能够减少页面请求数或减小请求所占带宽,能够节省可观的资源。

【 前端性能优化的关键的指标 】
1、白屏时间
用户从打开页面开始到有页面开始呈现为止,减少首屏加载内容,首屏内容渐出等
白屏的测量方法最古老的方法是js计算head内容的加载执行时间

2、首屏加载时间
首屏时间是指用户在没有滚动时候看到的内容渲染完成并且可以交互的时间。至于加载时间则是整个页面滚动到底部,所有内容加载完毕并可交互的时间,用户可以进行正常的事件输入交互操作。
firstscreenready - navigationStart这个时间就是用户实际感知的网站快慢的时间

1.js外联文件放到body底部,css外联文件放到head内 
2.http静态资源尽量用多个子域名 
3.服务器端提供html和http静态资源时最好开启gzip 
4.在js,css,img等资源响应的http headers里设置expires,last-modified 
5.尽量减少http requests的数量 
6.js/css/html/img资源压缩 
7.使用css spirtes,可以减少img请求次数 
8.大图使用lazyload懒加载 
9.避免404,减少外联js 
10.减少cookie大小可以提高获得响应的时间 
11.减少dom elements的数量 
12.使用异步脚本,动态创建脚本

3、完全加载时间
通常网页以两个事件的触发时间来确定页面的加载时间
DOMContentLoaded事件,表示直接书写在HTML页面中的内容但不包括外部资源被加载完成的时间,其中外部资源指的是css、js、图片、flash等需要产生额外HTTP请求的内容。
onload 事件,表示连同外部资源被加载完成的事件

</pre>

<h4>前端优化的方式</h4><pre>
前端优化的途径有很多,按粒度大致可分为两类,第一类是页面级别的优化,例如HTTP请求数、脚本的无阻塞加载、内联脚本的位置优化等;第二类则是代码级别的优化,例如JS中的DOM操作优化、CSS选择符优化、图片优化及HTML结构优化等,完整的前端优化还应该包括很多其他的途径,例如CDN、Gzip、多域名、无Cookie服务器等

【 减少HTTP请求数 】
最重要最有效的优化策略

首先每个请求都是有成本的,包含时间成本和资源成本。一个完整的请求都需要经过DNS寻址、与服务器建立连接、发送数据、等待服务器响应、接收数据这样漫长而复杂的过程。时间成本就是用户需要看到这个资源是必须要等待这个过程结束的,资源上由于每个请求都需要携带数据,因此每个请求都需要占用带宽。
由于浏览器进行并发请求的请求数是有上限的,因此请求数多了以后,浏览器需要分批进行请求,因此会增加用户的等待时间,给用户造成站点速度慢的印象,即使可能用户能看到的第一屏的资源都已经请求完了,但浏览器的进度条会一直存在。

减少HTTP请求数的主要途径包括：
减少页面上引用的文件数量可以减少HTTP连接数,Js、CSS、image文件合并、压缩,CSS Sprites合并CSS图片

(1). 从设计实现层面简化页面,保持页面简洁、减少资源的使用是最直接的
删除不必要的空格、注释
将inline的script和css移到外部文件,减少inline js、css的数量

(2). 合理设置HTTP缓存,恰当的缓存设置可以大大的减少HTTP请求
对重复使用的数据进行缓存,恰当的缓存设置可以大大的减少HTTP请求,能缓存越多越好,能缓存越久越好
很少变化的图片资源可以直接通过HTTP Header中的Expires设置一个很长的过期头;
变化不频繁而又可能会变的资源可以使用Last-Modifed来做请求验证

(3). 资源合并与压缩
尽可能的将外部的脚本、样式进行合并,多个合为一个,CSS、Js、Image都可以用相应的工具进行压缩,压缩后往往能省下不少空间。

(4). CSS Sprites
合并CSS图片,减少请求数的又一个好办法。

(5). Inline Images
使用data: URL scheme的方式将图片嵌入到页面或CSS中,如果不考虑资源管理上的问题的话不失为一个好办法。如果是嵌入页面的话换来的是增大了页面的体积,而且无法利用浏览器缓存。使用在CSS中的图片则更为理想一些

(6). Lazy Load Image
这条策略实际上并不一定能减少HTTP请求数,但是却能在某些条件下或页面刚加载时减少HTTP请求数。对于图片而言,在页面刚加载的时候可以只加载第一屏,当用户继续往后滚屏的时候才加载后续的图片,假如用户只对第一屏的内容感兴趣时,那剩余的图片请求就都节省了
这条策略实际上并不一定能减少HTTP请求数,但是却能在某些条件下或者页面刚加载时减少HTTP请求数。对于图片而言,在页面刚加载的时候可以只加载第一屏,当用户继续往后滚屏的时候才加载后续的图片。假如用户只对第一屏的内容感兴趣时,那剩余的图片请求就都节省了。有啊首页曾经的做法是在加载的时候把第一屏之后的图片地址缓存在Textarea标签中,待用户往下滚屏的时候才"惰性"加载

(7). 避免重复的资源请求
这种情况主要是由于疏忽或页面由多个模块拼接而成,然后每个模块中请求了同样的资源时会导致资源的重复请求

(8). 减少不必要的HTTP跳转
对于以目录形式访问的HTTP链接,很多人都会忽略链接最后是否带'/',假如服务器对此是区别对待的话,这其中很可能隐藏了301跳转,增加了多余请求

【 减少域名查询 】
DNS查询和解析域名也是消耗时间的,要减少对外部Js、CSS、图片等资源的引用,不同域名的使用越少越好

【 优化页面元素加载顺序 】
首先加载页面最初显示的内容和与之相关的Js和CSS,然后加载HTML相关的东西,不是最初显示相关的图片、flash、视频等资源就最后加载

【 使用CSS和合法的标签 】
使用CSS来减少标签和图像,例如使用CSS+文字完全可以替代一些只有文字的图片。
使用合法的标签避免浏览器解析HTML时做"error correction"等操作

【 Chunk your content 】
不要使用嵌套table,而使用非嵌套table或div,将基于大块嵌套的table的layout分解成多个小table,这样就不需要等到整个页面或大table内容全部加载完才显示。

【 指定图像和table的大小 】
如果浏览器可以立即决定图像或table的大小,那么它就可以马上显示页面而不要重新做一些布局安排的工作。
这不仅加快了页面的显示,也预防了页面完成加载后布局的一些不当的改变。
image使用height和width
图片的预处理,事先裁剪图片,而不是依赖浏览器在布局时的缩放
Image压缩工具

【 借助HTML5 Web Worker解决资源预加载的一些顽疾 】
有时为了访问下一个页面时可以更快,可能在当前页面onload之后利用空闲去预加载下一个页面以及相关资源
为了不影响当前页面,必须保证这些预加载的html css js资源不被解析或执行

【 CDN、Gzip、多域名、无Cookie服务器等等 】
启用GZIP压缩

【 性能优化之重绘、重排 】
元素的一些属性和方法在被访问或调用时会触发浏览器的布局动作及后续的Paint动作,而布局基本上都会波及页面上的所有元素,当页面元素比较多的时候布局和绘制都会花费比较大。
比如访问一个元素的offsetWidth(布局宽度)属性时,浏览器需要重新计算、布局,然后才能返回最新的值。如果这个动作发生在一个很大的循环中,那么浏览器就不得不进行多次的重新布局,这可能会产生严重的性能问题,正确的做法是先将这个值读出来,然后缓存在一个变量上(触发一次重新布局),以便后续使用

影响页面渲染速度主要有：reflow(回流/重排)和repaint(重绘),其中回流是导致DOM脚本执行低效的关键因素之一。
(1)Reflow
当某个部分发生了变化影响了布局,渲染树需要重新计算。
修改布局相关属性会触发Layout-Paint-Composite Layers,比如对位置、尺寸信息的修改,element.style.width='100px',element.style.top='100px'

(2)Repaint
改变了某个元素的背景颜色、文字颜色等不影响元素周围或内部布局的属性,将只会引起浏览器的repaint,根据元素的新属性重新绘制,使元素呈现新的外观。重绘不会带来重新布局,并不一定伴随重排;
修改绘制相关属性不会触发Layout,但会触发后续的Paint-Composite Layers,比如对背景色、前景色的修改element.style.backgroundColor='red' ;

Reflow要比Repaint更花费时间,也就更影响性能,所以写代码时要尽量避免过多的Reflow。

reflow的原因：
(1)页面初始化
(2)操作DOM
(3)元素的尺寸变化
(4)CSS的属性发生变化

CSS Triggers是一个完整的CSS属性列表,包含了会影响布局或绘制的CSS属性,以及在不同的浏览器上的不同表现

【 DOM操作 】
DOM操作应该是脚本中最耗性能的一类操作,例如增加、修改、删除DOM元素或对DOM集合进行操作。如果脚本中包含了大量的DOM操作则需要注意以下几点：
用innerHTML代替DOM操作,减少DOM操作次数,优化js性能

dom深度尽量浅

使用变量缓存DOM节点查找的结果
在脚本中document.images、document.forms、getElementsByTagName()返回的都是HTMLCollection类型的集合,在平时使用的时候大多将它作为数组来使用,因为它有length属性,也可以使用索引访问每一个元素。不过在访问性能上则比数组要差很多,原因是这个集合并不是一个静态的结果,它表示的仅仅是一个特定的查询,每次访问该集合时都会重新执行这个查询从而更新查询结果。所谓的"访问集合"包括读取集合的length属性、访问集合中的元素。
因此需要遍历HTML Collection的时候尽量将它转为数组后再访问,以提高性能。即使不转换为数组,也请尽可能少的访问它,例如在遍历的时候可以将length属性、成员保存到局部变量后再使用局部变量。

DOM操作还需要考虑浏览器的Reflow和Repaint,因为这些都是需要消耗资源的

尽量少使用table布局,因为可能很小的一个小改动会造成整个table的重新布局

把DOM离线后修改,使用文档片段,使用documentFragment对象在内存里操作DOM,先把DOM给display:none(有一次reflow),然后想怎么改就怎么改,比如修改100次,然后再把他显示出来。
var fragment = document.createDocumentFragment();
//一些基于fragment的大量DOM操作
document.getElementById('myElement').appendChild(fragment);

把DOM离线后修改,设置DOM元素的display样式为none再操作该元素
var myElement = document.getElementById('myElement');
myElement.style.display = 'none';
//一些基于myElement的大量DOM操作
myElement.style.display = 'block';

把DOM离线后修改,复制DOM元素到内存中再对其进行操作,clone一个DOM结点到内存里,然后想怎么改就怎么改,改完后和在线的那个的交换一下。
var old = document.getElementById('myElement');
var clone = old.cloneNode(true);
//一些基于clone的大量操作
old.parentNode.replaceChild(clone, old);

不要把DOM结点的属性值放在一个循环里当成循环里的变量,不然这会导致大量地读写这个结点的属性,用局部变量缓存样式信息从而避免频繁获取DOM数据
//bad operation
for (var i = 0; i < paragraphs.length; i++){
  paragraphs[i].style.width = box.offsetWidth + 'px';
}
//better operation
var width = box.offsetWidth;
for (var i = 0; i < paragraphs.length; i++){
  paragraphs[i].style.width = width + 'px';
}

合并多次DOM操作,不要一条一条地修改DOM的样式,还不如预先定义好css的class,然后修改DOM的className
// bad operation
var left = 10, top = 10;
el.style.top = top;
el.style.left = left;

// better operation
el.style.cssText += "; left: " + left + "px; top: " + top + "px;";

// better operation（将样式内容设置于某一类名，再进行元素类名绑定）
el.className += " theclassName";

【 css动画造成页面不流畅问题分析优化 】
使用css3动画造成页面的不流畅和卡顿问题，其潜在原因往往还是页面的回流和重绘，减少页面动画元素对其他元素的影响是提高性能的根本方向，而实现可如下：
1）设置动画元素position样式为absolute或fixed，可避免动画的进行对页面其它元素造成影响，导致其重排和重绘的发生；
2）避免使用使用fixed或absoulte的position、margin，top，left，width，height等属性执行动画，用transform进行替代；尽量用transform和opacity完成动画的展示，因为这两个属性可以避免重排和重绘的发生

合理的提升合成层，以减少页面不必要的绘制和重排
有一些特别的属性可以在不同的层中单独绘制,然后再合并图层。对这种属性的访问,如果正确使用了CSS不会触发Layout - Paint,而是直接进行Compsite Layers: transform、opacity
合成层的好处是不会影响到其他元素的绘制和不被其他层所影响，因此为了彼此之前的影响造成的性能损失，需合理的将动画效果中的元素或固定元素提升为合成层。
提升合成层的最好方式是使用CSS的will-change属性,将will-change设置为opacity、transform、top、left、bottom、right可以将元素提升为合成层。
CSS3属性will-change为web开发者提供了一种告知浏览器该元素会有哪些变化的方法,这样浏览器可在元素属性真正发生变化前做好对应的优化准备工作
transform又分为:translate, scale, rotate等,这些层应该放入单独的渲染层中,为了对这个元素创建一个独立的渲染层必须提升该元素。
#target { will-change: transform; }
对于还不兼容该属性的浏览器使用3D transform予以代替
#target { transform: translateZ(0); }

对于像页面顶部栏、侧栏等固定不变的位置元素也可将其提升为合成层以避免其被其他元素影响而发生重绘，但合成层的提升也意味着性能的消耗增加，必须通过调试以测出合理的临界值，不能盲目提升合成层，此外盲目提升合成层也可能造成重叠产生的额外合成层，容易导致层爆炸的出现，即页面连锁出现大量合成层默认提升，,太多的独立渲染层,虽然缩减了Paint的时间,但增加了Composite Layers的时间,因此需要仔细权衡,在作调整之前需要查看浏览器控制台的Timeline的运行结果来做支持。

</pre>

<h3>JS的加载</h3><pre>
当引用了JS时浏览器发送1个js request,Js的执行会阻塞DOM的构建过程,一直等待该request的返回。
因为浏览器需要稳定的DOM树结构,而JS中代码很有可能直接改变DOM树结构,如使用document.write或appendChild,甚至直接用location.href跳转
浏览器为了防止出现JS修改DOM树导致需要重新构建DOM树,所以浏览器会等待JS引擎的执行阻塞其他的下载和呈现,js执行结束之后再恢复DOM的构建
但并不是所有的JS都会涉及DOM操作,比如审计信息、WebWorker等,对于这些脚本可以显式地指定该脚本是不阻塞DOM渲染的。

js代码的编译与执行顺序
js是按照代码块来进行编译和执行的,一个script标签就是一个代码块,代码块间相互独立,但变量和方法共享
一个代码块中运行报错当前代码块后面的语句不会执行,但不影响下一个代码块的执行,这就是代码块间的独立性
而一个代码块中能调用另一个代码块中的变量则是块间共享性

整个js代码执行过程是这样的：
1、读入第一个代码块
2、对代码做语法分析,如果有错则报语法错误,并停止解析当前代码块,开始读取下一个代码块。
3.若语法分析没问题,进行预编译处理,将变量和函数的声明提前,但变量并没有初始化,值为undefined。
4、预编译之后才开始正式执行语句,如果某个语句有错,当前代码块中后面的语句不会执行,并且开始读取下一个代码块。
5、如果当前代码块完全正确,代码执行完毕后,开始读取下一个代码块

页面中的script标签越少,加载也就越快,响应也越迅速,无论是外链脚本还是内嵌脚本都是如此。
不要使用document.write()这种输出内容的方法,使用现代W3C DOM方法来为现代浏览器处理页面内容
用setTimeout来避免页面失去响应
用hash-table来优化查找
当需要设置的样式很多时设置className而不是直接操作style
少用全局变量
在onScroll、onresize中做耗时任务

window.onload = function(){}
$(document).ready(function(){})

【 js位置,将外部脚本置底 】
浏览器是可以并发请求的,这一特点使得其能够更快的加载资源,然而外链脚本在加载时却会阻塞其他资源,例如在脚本加载完成之前,后面的图片、样式及其他脚本都处于阻塞状态,直到脚本加载完成后才会开始加载。将脚本放在比较靠前的位置则会影响整个页面的加载速度从而影响用户体验
在解析html的时候遇到js会阻塞页面渲染,所以一般会将所有的script标签放到页面底部,body闭合标签之前,确保在脚本执行前页面已经完成了DOM树渲染,尽可能地合并脚本,减少对并发下载的影响

【 Lazy Load Javascript 】
随着Js框架的流行,越来越多的站点也使用起了框架。不过一个框架往往包括了很多的功能实现,这些功能并不是每一个页面都需要的,如果下载了不需要的脚本则算得上是一种资源浪费,既浪费了带宽又浪费了执行花费的时间。目前的做法大概有两种,一种是为那些流量特别大的页面专门定制一个专用的mini版框架,另一种则是Lazy Load。YUI则使用了第二种方式,在YUI的实现中最初只加载核心模块,其他模块可以等到需要使用的时候才加载

【 减少作用域链查找 】
作用域链查找问题在循环中是尤其需要注意的问题。如果在循环中需要访问非本作用域下的变量时请在遍历之前用局部变量缓存该变量,并在遍历结束后再重写那个变量,这一点对全局变量尤其重要,因为全局变量处于作用域链的最顶端,访问时的查找次数是最多的。
此外要减少作用域链查找还应该减少闭包的使用。

</pre><textarea>
var globalVar = 1;
function myCallback(info){
  for( var i = 100000; i–;){
    globalVar += i;    //每次访问globalVar都需要查找到作用域链最顶端,本例中需要访问100000次
  }
}

更高效的写法：
var globalVar = 1;
function myCallback(info){
  var localVar = globalVar;    // 局部变量缓存全局变量
  for( var i = 100000; i–-;){
    localVar += i;             // 访问局部变量是最快的
  }
  globalVar = localVar;        // 本例中只需要访问2次全局变量
}

</textarea><pre>
【 数据访问 】
JS中的数据访问包括直接量(字符串、正则表达式)、变量、对象属性以及数组,其中对直接量和局部变量的访问是最快的,对对象属性以及数组的访问需要更大的开销。当出现以下情况时,建议将数据放入局部变量：
a、对任何对象属性的访问超过1次
b、对任何数组成员的访问次数超过1次
另外,还应当尽可能的减少对对象以及数组深度查找

【 字符串拼接 】
在JS中使用"+"号来拼接字符串效率是比较低的,因为每次运行都会开辟新的内存并生成新的字符串变量,然后将拼接结果赋值给新变量。与之相比更为高效的做法是使用数组的join方法,即将需要拼接的字符串放在数组中最后调用其join方法得到结果。不过由于使用数组也有一定的开销,因此当需要拼接的字符串较多的时候可以考虑用此方法

【 异步请求Callback 】
在某些页面中可能存在这样一种需求,需要使用script标签来异步的请求数据

/*Callback函数*/
function myCallback(info){
//do something here
}

< script type="text/javascript" src="http://abc.com/cb">< /script>

cb返回的内容:
myCallback(‘Hello world!’);

像以上这种方式直接在页面上写script对页面的性能也是有影响的,即增加了页面首次加载的负担,推迟了DOMLoaded和window.onload事件的触发时机。如果时效性允许的话,可以考虑在DOMLoaded事件触发的时候加载,或使用setTimeout方式来灵活的控制加载的时机。

【 异步执行inline脚本 】
inline脚本对性能的影响与外部脚本相比是有过之而无不及,与外部脚本一样inline脚本在执行的时候一样会阻塞并发请求,由于浏览器在页面处理方面是单线程的,当inline脚本在页面渲染之前执行时页面的渲染工作则会被推迟。inline脚本在执行的时候页面处于空白状态,因此建议将执行时间较长的inline脚本异步执行,异步的方式有很多种,例如使用script元素的defer属性、使用setTimeout,此外在HTML5中引入了Web Workers的机制恰恰可以解决此类问题

【 采用异步无阻塞下载JS脚本的方法 】
(1)使用script标签的defer、async属性
(2)使用动态创建的script元素来下载并执行代码等异步加载等方法

defer和async都是异步下载,但执行时刻不一致
带有async标记的脚本,浏览器仍然会下载它,并在合适的时机执行,但不会影响DOM树的构建过程。

相同点：
加载文件时不阻塞页面渲染;
使用这两个属性的脚本中不能调用document.write方法;
允许不定义属性值,仅仅使用属性名;

不同点：
html4.0中定义了defer,html5.0中定义了async,这将造成由于浏览器版本的不同而对其支持的程度不同;
每一个async属性的脚本都在它下载结束之后立刻执行,同时会在window的load事件之前执行,所以就有可能出现脚本执行顺序被打乱的情况;
每一个defer属性的脚本都是在页面解析完毕之后,按照原本的顺序执行,同时会在document的DOMContentLoaded之前执行;

</pre>动态创建DOM方式<pre class="js">
function downloadJSAtOnload() {
  var urlList = [
    "@ViewHelper.Content("/Content/plugin/alert/js/j_alert.js", "20170111")",
    "@ViewHelper.Content("/Content/js/swiper.min.js")",
    "@ViewHelper.Content("/Content/js/imageview_new.js", "201702271")"
  ];
  for (var i = 0; i <= urlList.length - 1; i++) {
    var element = document.createElement("script");
    element.src = urlList[i];
    document.body.appendChild(element);
  }
}

// 创建script,插入到DOM中,加载完毕后callback
function loadScript(url, callback){
  var script = document.createElement("script")
  script.type = "text/javascript";
  if (script.readyState){            //IE
    script.onreadystatechange = function(){
      if (script.readyState == "loaded" || script.readyState == "complete"){
        script.onreadystatechange = null;
        callback();
      }
    };
  } else {                          //Others: Firefox, Safari, Chrome, and Opera
    script.onload = function(){
      callback();
    };
  }
  script.src = url;
  document.body.appendChild(script);
}

</pre><pre>
【 慎用with 】
with(obj){ p = 1}; 代码块的行为实际上是修改了代码块中的执行环境,将obj放在了其作用域链的最前端,在with代码块中访问非局部变量是都是先从obj上开始查找,如果没有再依次按作用域链向上查找,因此使用with相当于增加了作用域链长度。而每次查找作用域链都是要消耗时间的,过长的作用域链会导致查找性能下降。因此除非能肯定在with代码中只访问obj中的属性,否则慎用with,替代的可以使用局部变量缓存需要访问的属性。

【 避免使用eval和Function 】
每次eval或Function构造函数作用于字符串表示的源代码时,脚本引擎都需要将源代码转换成可执行代码。这是很消耗资源的操作,通常比简单的函数调用慢100倍以上。
eval函数效率特别低,由于事先无法知晓传给eval的字符串中的内容,eval在其上下文中解释要处理的代码,编译器无法优化上下文,因此只能有浏览器在运行时解释代码,这对性能影响很大。
Function构造函数比eval略好,因为使用此代码不会影响周围代码,但其速度仍很慢。
此外使用eval和Function也不利于Javascript压缩工具执行压缩。

</pre>

<h3>页面渲染之css</h3><pre>
避免使用CSS Expression

CSS规则越复杂,在构建Render Tree时浏览器花费的时间越长。CSS规则有自己的优先级,不同的写法对效率也会有影响,特别是当规则很多的时候

【 将CSS放在HEAD中 】
如果将CSS放在其他地方比如BODY中,则浏览器有可能还未下载和解析到CSS就已经开始渲染页面了,这就导致页面由无CSS状态跳转到CSS状态,用户体验比较糟糕。除此之外,有些浏览器会在CSS下载完成后才开始渲染页面,如果CSS放在靠下的位置则会导致浏览器将渲染时间推迟。

【 CSS选择符 】
浏览器对选择符的解析是从右往左进行的,#nav li会去找所有的li,然后再去确定它的父元素是不是#nav
#toc A { color: #444; }
如果是从右往左解析则效率会很高,因为第一个ID选择基本上就把查找的范围限定了,但实际上浏览器必须遍历查找每一个A标签的祖先节点,效率并不像之前想象的那样高

不要为id选择器指定类名或是标签,因为id可以唯一确定一个元素。

避免后代选择符#tp p{},尽量使用子选择符#tp>p{},子元素匹配符的概率要大于后代元素匹配符

避免使用通配符
.mod .hd *{font-size:14px;} 根据匹配顺序将首先匹配通配符,也就是说先匹配出通配符,然后匹配.hd(就是要对dom树上的所有节点进行遍历他的父级元素),然后匹配.mod,这样的性能耗费可想而知

【 分割CSS 】
对于不同的浏览终端,同一终端的不同模式可能会提供不同的规则集：
@ media print { }
@ media orientation : landscape {}
如果将这些内容写到一个文件中,浏览器需要下载并解析这些内容,虽然不会实际应用这些规则,更好的做法是将这些内容通过对link元素的media属性来指定：
link href = "print.css" rel = "stylesheet" media = "print"
link href = "landscape.css" rel = "stylesheet" media = "orientation:landscape"
这样print.css和landscape.css的内容不会阻塞Render Tree的建立,用户可以更快的看到页面,从而获得更好的体验

【 使用GPU加速 】
很多动画都会定时执行,每次执行都可能会导致浏览器的重新布局,比如：
@ keyframes my {
  20 % {top : 10px ;}
  50 % {top : 120px ;}
}
这些内容可以放到GPU加速执行,GPU是专门设计来进行图形处理的,在图形处理上比CPU要高效很多
可以通过使用transform来启动这一特性：
transform : translateY ( 10px );
transform : translateY ( 120px );

</pre>
</div>

<div id="website_cache">
<h2>网站缓存 清除浏览器缓存 chrome://cache即可查看浏览器缓存(快取)</h2><pre>
【 meta方法 】
＜meta HTTP-EQUIV="pragma" CONTENT="no-cache" /＞
＜meta HTTP-EQUIV="Cache-Control" CONTENT="no-cache, must-revalidate" /＞
＜meta HTTP-EQUIV="expires" CONTENT="0" /＞

【 清理form表单的临时缓存 】
body onLoad="javascript:document.yourFormName.reset()"

【 Location对象 】
window.location.replace("http://www.w3school.com.cn")

【 ajax方法1 】
$.ajax({
  url:'www.haorooms.com',
  dataType:'json',
  data:{},
  beforeSend :function(xmlHttp){
    xmlHttp.setRequestHeader("If-Modified-Since","0");
    xmlHttp.setRequestHeader("Cache-Control","no-cache");
  },
  success:function(response){
    //操作
  }
  async:false
});

【 ajax方法2 】
$.ajax({
  url:'www.haorooms.com',
  dataType:'json',
  data:{},
  cache:false,
  ifModified :true ,
  success:function(response){
     //操作
  }
  async:false
});

【 URL参数 】
URL参数后加"?ran=" + Math.random(); 或 "?timestamp=" + new Date().getTime();

【 用php后端清理 】
服务端加header("Cache-Control: no-cache, must-revalidate");等

</pre>

<h3>缓存</h3><pre>
缓存原本是一个硬件的概念：缓存就是数据交换的缓冲区(称作Cache),当某一硬件要读取数据时会首先从缓存中查找需要的数据,如果找到了则直接执行,找不到的话则从内存中找。由于缓存的运行速度比内存快得多,故缓存的作用就是帮助硬件更快地运行

一般一个网站或应用的标准流程是浏览器请求应用服务器,应用服务器做一堆计算后再请求数据库,数据库收到请求后再作一堆计算后把数据返回给应用服务器,应用服务器再作一堆计算后把数据返回给浏览器
但互连网的普及,应用需要支撑的并发量就越来越多,应用服务器和数据库服务器所做的计算也越来越多,但应用服务器资源是有限的,数据库每秒接受请求的次数也是有限的(硬盘转速有限)
如何利用有限的资源来提供尽可能大的吞吐量呢,一个办法:减少计算量,缩短请求流程(减少网络io或硬盘io),这时候缓存就可以大展手脚了
缓存的基本原理就是打破标准流程,在这个标准流程中任何一个环节都可以被切断,请求可以从缓存里取到数据直接返回,这样不但节省了时间,提高了响应速度,而且也节省了硬件资源,让有限的硬件资源来服务更多的用户

缓存的作用主要有：
加快页面打开速度
减少网络带宽消耗
降低服务器压力

缓存是存贮数据(使用频繁的数据)的临时地方,因为取原始数据的代价太大了,所以可以取得快一些
缓存(caching)是一个描述存储可重用资源以便加快后续请求的行为的术语。有许多不同类型的缓存,每种都有其自身的特点,应用程序缓存和内存缓存由于其对特定回复的加速都很常用

缓存命中率：
一个缓存的有效性依照缓存的命中率度量,可以从缓存中得到数据的请求数与所有请求数的比率,缓存命中率高意味着有很高比例的数据可以从缓存中获得,这通常是大多数管理员想要的结果。

失效：
失效是依据过期日期从缓存中移除内容的过程。当内容在原始服务器上已被改变时就必须这样做,缓存中过期的内容会导致客户端发生问题。

【 缓存算法 】
先进先出算法(FIFO)：
如果一个数据最先进入缓存中则应该最早淘汰掉
如果服务器接受到的数据请求与时间高度相关,可以考虑使用FIFO算法。

最不经常使用算法(LFU)：
这个缓存算法使用一个计数器来记录条目被访问的频率。通过使用LFU缓存算法最低访问数的条目首先被移除。
不经常使用,因为它无法对一个拥有最初高访问率之后长时间没有被访问的条目缓存负责。

最近最少使用算法(LRU)：
这个缓存算法将最近使用的条目存放到靠近缓存顶部的位置。当一个新条目被访问时,LRU将它放置到缓存的顶部。当缓存达到极限时,较早之前访问的条目将从缓存底部开始被移除。这里会使用到昂贵的算法,而且它需要记录"年龄位"来精确显示条目是何时被访问的。此外,当一个LRU缓存算法删除某个条目后,"年龄位"将随其他条目发生改变。

自适应缓存替换算法(ARC)：
这个缓存算法同时跟踪记录LFU和LRU,以及驱逐缓存条目,来获得可用缓存的最佳使用。

最近最常使用算法(MRU)：这个缓存算法最先移除最近最常使用的条目。一个MRU算法擅长处理一个条目越久,越容易被访问的情况。

缓存存在位置
网站缓存按照存放的地点不同,可以分为客户端缓存、服务端缓存
在一个Web应用中,应用到缓存的地方有很多,主要有浏览器缓存,页面缓存,服务器缓存,数据库缓存等

【 客户端缓存-web缓存 】
客户端缓存又可分为：浏览器缓存、网关或代理服务器缓存
网关或代理服务器缓存是将网页缓存中网关服务器上,多用户访问同一个页面时直接从网关服务器把页面传送给用户。

浏览器缓存规则主要在HTTP协议头和HTML的meta标签中定义,他们分别从新鲜度和校验值两个维度来规定浏览器是否可以直接使用缓存中的副本,还是需要去源服务器获取更新的版本

新鲜度(过期机制)：即缓存副本有效期。一个缓存副本必须满足以下条件,浏览器会认为它是有效的,足够新的：
1、含有完整的过期时间控制头信息(HTTP协议报头),并且仍在有效期内;
2、浏览器已经使用过这个缓存副本,并且在一个会话中已经检查过新鲜度
3、满足以上两个情况的一种,浏览器会直接从缓存中获取副本并渲染。

校验值(验证机制)：服务器返回资源的时候有时在控制头信息带上这个资源的实体标签Etag(Entity Tag),它可以用来作为浏览器再次请求过程的校验标识。如发现校验标识不匹配,说明资源已经被修改或过期,浏览器需求重新获取资源内容

浏览器缓存(客户端缓存)是最靠近用户的缓存,浏览器缓存的控制可以设置meta标签;但只有部分浏览器可以支持,而且所有缓存代理服务器都不支持,因为代理不解析HTML内容本身;而广泛应用的还是HTTP头信息来控制缓存

在HTTP请求和响应的消息报头中,常见的与缓存有关的消息报头有：
规则   消息报头  值示例  类型 作用
新鲜度
Expires
如Sun,16 Oct 2016 05:43:02 GMT,类型响应,告诉浏览器在过期时间之前可使用副本(时间可能不一致)
Expires是HTTP1.0的东西,现在默认浏览器均默认使用HTTP 1.1,所以它的作用基本忽略

Pragma
no-cache,类型响应,告诉浏览器忽略资源的缓存副本(http1.1用Cache-Control代替)

Cache-Control
no-cache,类型响应,告诉浏览器忽略资源的缓存副本,强制每次请求直接发送给源服务器
no-store,类型响应,强制缓存在任何情况下都不要保留任何副本
max-age=[秒],类型响应,指明缓存副本的有效时长,从请求时开始到过期时间之间的秒数
public,类型响应,任何途径的缓存者(本地缓存,代理服务器)可以无条件的缓存该资源
private,类型响应,只针对单个用户或实体(不同用户,窗口)缓存资源

Last-Modified
如Sun,16 Oct 2016 05:43:02 GMT,类型响应,web服务器在响应请求时告诉浏览器当前资源的最后修改时间

If-Modified-Since
如Sun,16 Oct 2016 05:43:02 GMT,类型请求,如果浏览器第一次请求时响应中的Last-Modified非空,第二次请求同一资源时会把它作为该项的值发送给服务器

Last-Modified/If-Modified-Since要配合Cache-Control使用。
If-Modified-Since：当资源过期时(使用Cache-Control标识的max-age),发现资源具有Last-Modified声明,则再次向web服务器请求时带上头 If-Modified-Since,表示请求时间。web服务器收到请求后发现有头If-Modified-Since 则与被请求资源的最后修改时间进行比对。若最后修改时间较新,说明资源又被改动过,则响应整片资源内容(写在响应消息包体内),HTTP 200;若最后修改时间较旧,说明资源无新修改,则响应HTTP 304 (无需包体,节省浏览),告知浏览器继续使用所保存的cache。

校验值

Etag
如50b1c1d4f775c61:df3,类型响应,告诉浏览器当前资源在服务器的唯一标识符(生成规则由服务器决定)

If-None-Match
如如50b1c1d4f775c61:df3,类型请求,如果浏览器第一次请求时响应中的Etag非空,第二次请求同一资源时会把它作为该项的值发送给服务器

Etag/If-None-Match
Etag/If-None-Match也要配合Cache-Control使用。
Etag：web服务器响应请求时,告诉浏览器当前资源在服务器的唯一标识(生成规则由服务器决定)。Apache中ETag的值默认是对文件的索引节(INode),大小(Size)和最后修改时间(MTime)进行Hash后得到的。
If-None-Match：当资源过期时(使用Cache-Control标识的max-age),发现资源具有Etage声明,则再次向web服务器请求时带上头If-None-Match (Etag的值)。web服务器收到请求后发现有头If-None-Match 则与被请求资源的相应校验串进行比对,决定返回200或304。

Last-Modified已经足以让浏览器知道本地的缓存副本是否足够新,为什么还需要Etag(实体标识)呢？
HTTP1.1中Etag的出现主要是为了解决几个Last-Modified比较难解决的问题：
1、Last-Modified标注的最后修改只能精确到秒级,如果某些文件在1秒钟以内被修改多次的话,它将不能准确标注文件的修改时间
2、如果某些文件会被定期生成,当有时内容并没有任何变化,但Last-Modified却改变了,导致文件没法使用缓存
3、有可能存在服务器没有准确获取文件修改时间,或者与代理服务器时间不一致等情形

Etag是服务器自动生成或者由开发者生成的对应资源在服务器端的唯一标识符,能够更加准确的控制缓存。Last-Modified与ETag是可以一起使用的,服务器会优先验证ETag,一致的情况下才会继续比对Last-Modified,最后才决定是否返回304

辅助

Vary
Accept-Encoding,类型响应,辅助从多个缓存副本中筛选合适的版本(不同压缩算法产生的副本)

【 HTTP缓存机制 】
缓存行为主要由缓存策略决定,而缓存策略由内容拥有者设置。这些策略主要通过特定的HTTP头部来清晰地表达。

当一个用户发起一个静态资源请求的时候,浏览器会通过以下几步来获取资源：
1、本地缓存阶段：先在本地查找该资源,如果有发现该资源,而且该资源还没有过期,就使用这一个资源,完全不会发送http请求到服务器;
2、协商缓存阶段：如果在本地缓存找到对应的资源,但是不知道该资源是否过期或者已经过期,则发一个http请求到服务器,然后服务器判断这个请求,如果请求的资源在服务器上没有改动过,则返回304,让浏览器使用本地找到的那个资源;
3、缓存失败阶段：当服务器发现请求的资源已经修改过,或者这是一个新的请求(在本来没有找到资源),服务器则返回该资源的数据,并且返回200, 当然这个是指找到资源的情况下,如果服务器上没有这个资源则返回404

1、本地缓存阶段
Expires
指定缓存到期GMT的绝对时间,如果设了max-age,max-age就会覆盖expires。如果expires到期需要重新请求。

Cache-Control
Cache-Control是http 1.1中为了弥补Expires缺陷新加入的。对已缓存的内容进行控制：
public表示缓存的版本可以被代理服务器或者其他中间服务器识别。
private意味着这个文件对不同的用户是不同的。只有用户自己的浏览器能够进行缓存,公共的代理服务器不允许缓存。
no-cache意味着文件的内容不应当被缓存。这在搜索或者翻页结果中非常有用,因为同样的URL对应的内容会发生变化
max-age: 指定缓存过期的相对时间秒数,max-ag=0或负值,浏览器会在对应的缓存中把Expires设置为1970-01-01 08:00:00。
s-maxage: 类似于max-age,只用在共享缓存上,比如proxy。
public: 通常情况下需要http身份验证的情况,响应是不可cahce的,加上public可以使它被cache。
no-cache: 强制浏览器在使用cache拷贝之前先提交一个http请求到源服务器进行确认。这对身份验证来说是非常有用的,能比较好的遵守 (可以结合public进行考虑)。它对维持一个资源总是最新的也很有用,与此同时还不完全丧失cache带来的好处),因为它在本地是有拷贝的,但是在用之前都进行了确认,这样http请求并未减少,但可能会减少一个响应体。
no-store: 告诉浏览器在任何情况下都不要进行cache,不在本地保留拷贝。
must-revalidate: 强制浏览器严格遵守你设置的cache规则。
proxy-revalidate: 强制proxy严格遵守你设置的cache规则。
cache：使用本地缓存,不发生请求。
用法举例: Cache-Control: max-age=3600, must-revalidate

2、协商缓存阶段
Last-Modified & if-modified-since
Last-Modified与If-Modified-Since是一对报文头,属于http 1.0。
last-modified是WEB服务器认为对象的最后修改时间,比如文件的最后修改时间,动态页面的最后产生时间。

ETag & If-None-Match
ETag与If-None-Match是一对报文,属于http 1.1。
ETag可以用来解决这种问题。ETag是一个文件的唯一标志符。就像一个哈希或者指纹,每个文件都有一个单独的标志,只要这个文件发生了改变,这个标志就会发生变化。
ETag机制类似于乐观锁机制,如果请求报文的ETag与服务器的不一致,则表示该资源已经被修改过,需要发最新的内容给浏览器。

同时使用这两个报文头,在完全匹配If-Modified-Since和If-None-Match即检查完修改时间和Etag之后,如都与服务器的相符服务器返回304,否则发送最新内容给浏览器。

Etag/lastModified过程如下：
客户端请求一个页面(A)。
服务器返回页面A,并在给A加上一个Last-Modified/ETag。
客户端展现该页面,并将页面连同Last-Modified/ETag一起缓存。
客户再次请求页面A,并将上次请求时服务器返回的Last-Modified/ETag一起传递给服务器。
服务器检查该Last-Modified或ETag,并判断出该页面自上次客户端请求之后还未被修改,直接返回响应304和一个空的响应体。
304：通过If-Modified-Since If-Match判断资源是否修改,如未修改则返回304,发生了一次请求,但请求内容长度为0,节省了带宽。 如果有多台负载均衡的服务器,不同服务器计算出的Etag可能不同,这样就会造成资源的重复加载。

Etag 主要为了解决 Last-Modified 无法解决的一些问题：
1、一些文件也许会周期性的更改,但是他的内容并不改变(仅仅改变的修改时间),这时并不希望客户端认为这个文件被修改了,而重新GET;
2、某些文件修改非常频繁,比如在秒以下的时间内进行修改,(比方说1s内修改了N次),If-Modified-Since能检查到的粒度是s级的,这种修改无法判断(或者说UNIX记录MTIME只能精确到秒);
3、某些服务器不能精确的得到文件的最后修改时间。

其他标签
Content-Length：尽管并没有在缓存中明确涉及,Content-Length头部在设置缓存策略时很重要。某些软件如果不提前获知内容的大小以留出足够空间,则会拒绝缓存该内容。

Vary：缓存系统通常使用请求的主机和路径作为存储该资源的键。当判断一个请求是否是请求同样内容时,Vary头部可以被用来提醒缓存系统需要注意另一个附加头部。它通常被用来告诉缓存系统同样注意Accept-Encoding头部,以便缓存系统能够区分压缩和未压缩的内容。

【 用户行为与缓存 】
浏览器缓存行为还有用户的行为有关

用户操作        Expires/Cache-Control        Last-Modified/Etag
地址栏回车      有效                         有效
页面链接跳转    有效                         有效
新开窗口        有效                        有效
前进、后退       有效                        有效
F5刷新          无效                        有效
Ctrl+F5刷新     无效                        无效

浏览器中的操作对缓存的影响:
强制刷新 – 当按下ctrl+F5来刷新页面的时候, 浏览器将绕过各种缓存(本地缓存和协商缓存), 直接让服务器返回最新的资源;
普通刷新 – 当按下F5或者点击刷新按钮来刷新页面的时候,浏览器将绕过本地缓存来发送请求到服务器, 此时协商缓存是有效的
回车或转向 – 当在地址栏上输入回车或者按下跳转按钮的时候, 所有缓存都生效

浏览器第一次发出请求
＜img src="image/cache.png"＞
浏览器第二次发出请求
＜img src="image/cache2.png"＞

如果启用缓存用户在访问同一个页面时将不再从服务器下载页面,而是从本机的缓存目录中读取页面,然后再浏览器中展现这个页面。
不过现在的网站为了保证用户访问到最新的内容,一般很少采用浏览器缓存,取而代之的是更加灵活的服务器缓存

浏览器缓存(浏览器端的静态缓存技术)
在nginx中设置expires,并不是指把静态内容缓存在nginx中,而是设置客户端浏览器缓存的时间
location ~.*\.(gif|jpg|jpeg|png|bmp|swf)${
  expires 1d;
}
location ~.*\.(js|css)?&{
  expires 15d;
}

nginx设置的expires优先级大于代码中meta设置的expires优先级
expires是给一个资源设定一个过期时间,也就是说无需去服务端验证,直接通过浏览器自身确认是否过期即可,所以不会产生额外的流量。此种方法非常适合不经常变动的资源。如果文件变动较频繁,就不要使用 expires 来缓存

如访问一张静态文件不想客户端缓存,需要每次都去服务器端取数据,可以用last-modified参数来实现,last-modified是根据文件更新时间来确定是否再次发送加载
location ~.*\.(gif|jpg|jpeg|png|bmp|swf)${
  add header Last-modified 10;
  expires 1d;
}
更改掉服务器传回客户端的" last-modified "文件修改时间参数的值,导致客户端本地保存的文件时间每次跟服务器端传回来的时间不一致,所以每次客户端" 误认为 "服务器端有静态文件更新,每次都会去服务器端取" 所谓的最新数据 "。这样不管在浏览器访问多少次,返回的http状态都是200,再也找不到304状态了

【 服务端缓存-Ehcache与memcached与redis 】
服务端缓存分为：页面缓存、数据缓存、数据库缓存

页面缓存
页面缓存是将动态页面直接生成静态的页面放在服务器端,用户调取相同页面时,静态页面将直接下载到客户端,不再需要通过程序的运行和数据库的访问,大大节约了服务器的负载。
早期的网站很多使用发布系统来完成这个功能,在后台发布时将数据和页面模板整合成静态页面存放在硬盘中。但这样的缺陷很明显,一是后台的程序的编写很复杂,二是缓存的控制只能通过人为的方式来控制,这对一些更新十分频繁的网站就是一个噩梦,网站可能在不停的做缓存的删除和重建。当然后来出现了一些自动更新这些缓存的框架,比如PHP的SMARTY模板技术,可以定义缓存过期的时间自动去更新这些缓存。这对一些信息发布类网站已经确实适用了。

除了整个页面的缓存技术,还有一种技术叫做"网页片段缓存技术",将页面的部分而不是全部进行缓存。代表作有ESI cache。

数据缓存
Ehcache、memcached、redis
比较有名的数据缓存框架有ehcache和 memcached

目前缓存的做法分为两种模式:
内存缓存：缓存数据存放在服务器的内存空间中。
优点：速度快 缺点：资源有限

文件缓存：缓存数据存放在服务器的硬盘空间中。
优点：容量大 缺点：速度偏慢,尤其在缓存数量巨大时

数据库缓存
数据库的缓存一般由数据库提供,可以对表建立高速缓存。数据库中用户可能多次执行相同的查询语句,为了提高查询效率,数据库会在内存划分一个专门的区域,用来存放用户最近执行的查询,这块区域就是缓存。
数据库缓存的使用必须在一定的应用环境下：查询的数据库表不会经常变动、有大量相同的查询(如订单信息查询)。

这个缓存策略也可以用在前端,比如订单信息不变的情况下,可以在前端设置一个对象,保存请求的地址、参数、结果,第一次请求时会保存请求的地址、参数和结果,再次请求时,如果请求的地址、参数一样,则查询该对象直接返回请求的结果。

磁盘缓存(服务器端的静态缓存技术)
nginx基于epoll网络模型,而相比apache基于select网络模型。所以apache的优势在于密计算型,稳定性好。而nginx偏向静态处理,反向代理,高并发。比如apache+php的稳定性比 nginx+php要好,而性能是明显nginx要优秀许多。

nginx主要通过proxy_cache来实现web cache
在location里不仅可以实现静态文件的缓存,还可以实现动态文件的缓存

location ~.*\.(.gif|jpg|jpeg|png|mp|dwf|html)${
  proxy_cache cache_one;                 #keys_zone后的内容对应
  proxy_cache_valid 200 304 301 302 10d; #哪些状态缓存多长时间
  proxy_cache_valid any 1d;              #其他的缓存多长时间
  proxy_cache_key $host$uri$is_args$args;#通过key来hash,定义KEY值

  proxy_pass http://10.168.247.180:81;
  proxy_set_header Host            $host;
  proxy_set_header X-Real_IP       $remote_addr;
  proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
}

内存缓存(服务器端的静态缓存技术)：静态文件缓存在服务器端的内存中

nginx的内存缓存
location /images/ {
  set $memcached_keys $request_uri;
  add_header X-mem_key $memcached_key;
  memcached_pass 127.0.0.1:11211;
  default_type text/html;
  error_page 404 502 504=@app;
}
memcached_pass指定服务器地址,使用变量$memcache_key为key查询值,memcache查询对应value值
如访问：http://example.com/image/test.jpg 则nginx去memcache中查询key为" test.jpg "的value值并返回。如果没有相应的值则返回error_page 404。
关键在于存储在memcache中的静态文件,需要通过代码写入memcache中

Nginx的内存缓存因为需要通过编码实现,所以灵活性特别高。这块可以结合自身业务系统的特点,让静态缓存的灵活性和效率都能得到保障。可能唯一的缺陷就是通过编码实现的方式给维护管理带来了负担。

电商系统可以把客户的订单照片通过 php 代码写入 memcache,客户访问取图的时候,从 memcache 中获取,速度效率特别高。Nginx 作为一款在七层无所不能且轻量级高性能的中间件,能够直接去 memcache 中取数据,来实现静态缓存的效果,这块相应的功能是其他软件无法相媲美的

【 缓存的同步、复制与分发 】
缓存的同步指的是写命中缓存的时候,如果保持缓存与磁盘上数据一致性的问题。一般有两种方案：

直写式WT(Write Through)：当CPU要将数据写入内存时,除了更新缓冲内存上的数据外,也将数据写在磁盘中以维持主存与缓冲内存的一致性,当要写入内存的数据多起来的话,速度自然就慢了下来。
回写式WB(Write Back)：当CPU要将数据写入内存时,只会先更新缓冲内存上的数据,随后再让缓冲内存在总线不塞车的时候才把数据写回磁盘,所以速度会快得多。
两种方式各有利弊,直写缓存方法利用了高速缓存中的数据始终与主存储器中数据匹配的特点。但是,需要的总线周期却非常耗时,从而降低性能。回写缓存可以维持性能,因为写入始终是在"爆发"中进行的,因而运行所需的总线周期将大大减少。
两个CPU,或者CPU与DMA同时共享一块物理内存时,writer在写完后,要write back,这样另一个reader才能看到它写入的数据;在writer变为reader的时候,需要invalidate,否则看不到另一个 writer写入的数据。所以在共享的时候,需要同时做writeback和invalidate。

</pre>

<h3>CDN</h3><pre>
CDN是静态缓存加速最典型的代表。CDN技术并不是一门新的技术,是基于传统nginx、squid、varnish等web缓存技术,结合DNS智能解析的静态缓存加速技术
对动态链接访问并没有加速效果

CDN的静态缓存技术核心主要在于两点：
节点缓存：对需要加速的网站应用,相应的静态资源通过内存缓存+磁盘缓存的方式缓存在服务器端。
精准调度：对访问的用户ip进行智能解析调度,实现就近缓存节点访问。比如北京用户访问www.a.com,dns 解析的时候分析用户ip,发现是北京用户,则dns返回对应北京缓存节点的ip地址给到用户,则用户www.a.com默认访问北京服务器上面的缓存数据,实现就近访问的策略,大大提升了访问速度。

CDN的全称是Content Delivery Network,即内容分发网络。其基本思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节,使内容传输的更快、更稳定。通过在网络各处放置节点服务器所构成的在现有的互联网基础之上的一层智能虚拟网络,CDN系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。其目的是使用户可就近取得所需内容,解决 Internet网络拥挤的状况,提高用户访问网站的响应速度

CDN是构建在网络之上的内容分发网络,依靠部署在各地的边缘服务器,通过中心平台的负载均衡、内容分发、调度等功能模块,使用户就近获取所需内容,降低网络拥塞,提高用户访问响应速度和命中率。CDN的关键技术主要有内容存储和分发技术。

CDN的基本原理是广泛采用各种缓存服务器,将这些缓存服务器分布到用户访问相对集中的地区或网络中,在用户访问网站时,利用全局负载技术将用户的访问指向距离最近的工作正常的缓存服务器上,由缓存服务器直接响应用户请求

内容分发网络,将网站内容发布到最接近用户的边缘节点,使网民可就近取得所需内容,提高网民访问的响应速度和成功率,同时能够保护源站。解决由于地域、带宽、运营商接入等问题带来的访问延迟高问题,有效帮助站点提升访问速度

百度云加速
https://su.baidu.com/

阿里云

</pre>
</div>

<div id="mobile">
<h2>移动端web开发</h2><pre>
移动设备主要特点是不配备鼠标,键盘也只是在需要输入的地方才会激活虚拟键盘。所以以前的pc端事件在移动端使用起来就没有以前那么爽了,虽然部分仍然可以使用

为何要用touch事件代替click事件？
- click事件300ms延时
- touch事件支持多点触摸
- 手势操作

Click事件在移动手机开发中有300ms的延迟,因为在手机早期浏览器系统有放大和缩放功能,用户在屏幕上点击两次之后系统会触发放大或者缩放功能。因此系统做了一个处理,当触摸一次后在300ms这段时间内有没有触摸第二次,如果触摸了第二次的话,说明是触发放大或缩放功能,否则的话是click事件。因此当click时候,所有用户必须等待于300ms后才会触发click事件。所以当在移动端使用click事件的时候,会感觉到有300ms的迟钝

dblclick事件失效
由于双击缩放的存在,pc端的dblclick事件也失效了

移动端常见的一些事件包括原生支持的click、touch、tap、swipe事件,也有定义型的gesture手势事件(目前只是一个概念,使用的时候需封装模拟)

【移动端的touch手势事件】
1、touchstart
当用户手指触摸到的触摸屏的时候触发,事件对象的target就是touch发生位置的那个元素

2、touchmove
当已经接触屏幕的手指开始移动后触发
当用户在触摸屏上移动触点(手指)的时候触发touchmove事件
一定是先要触发touchstart事件,再有可能触发touchmove事件
​touchmove事件的target与最先触发的touchstart的target保持一致。
touchmove事件和鼠标的mousemove事件都会多次重复调用,所以事件处理时不能有太多耗时操作
不同的设备,移动同样的距离touchmove事件的触发频率是不同的。
即使手指移出了原来的target元素touchmove仍然会被一直触发,而且target仍然是原来的target元素

3、touchend
当用户的手指抬起离开屏幕时触发touchend事件
用户的手指从触屏设备的边缘移出了触屏设备,也会触发touchend事件。
touchend事件的target也是与touchstart的target一致,即使已经移出了元素

4、touchcancel
当触点由于某些原因被中断时触发,可能的原因如下(具体的原因根据不同的设备和浏览器有所不同):
当在滑动手机的过程中突然出现一个系统事件,比如电话,这会就cancel掉
当一些更高级别的事件发生的时候(如电话接入或者弹出信息)会取消当前的touch操作,即触发touchcancel
由于某个事件取消了触摸：例如触摸过程被一个模态的弹出框打断。
触点离开了文档窗口,而进入了浏览器的界面元素、插件或者其他外部内容区域。
当用户产生的触点个数超过了设备支持的个数,从而导致TouchList中最早的Touch对象被取消

touchcancel事件一般用于保存现场数据。比如正在玩游戏,如果发生了touchcancel事件,则应该把游戏当前状态相关的一些数据保存起来,暂停游戏、存档等操作

与移动端相关的interface主要有三个：
1、TouchEvent
表示触摸状态发生改变时触发的event
为了区别触摸相关的状态改变,存在多种类型的触摸事件,可以通过检查触摸事件的TouchEvent.type属性(event.type)来确定当前事件属于哪种类型

在很多情况下,触摸事件和鼠标事件会同时被触发(目的是让没有对触摸设备优化的代码仍然可以在触摸设备上正常工作)。如果你使用了触摸事件,可以调用 event.preventDefault()来阻止鼠标事件被触发

event.stopPropagation() 阻止冒泡

PC端鼠标点击时触发一次touchstart和一次touchend事件

2、Touch
表示用户和触屏设备之间接触时单独的交互点(a single point of contact)
这个交互点通常是一个手指或者触摸笔,触摸设备通常是触摸屏或者触摸板
js对象提供了多个只读属性来描述Touch对象

每个touch对象都包含了以下几个属性：
identifier: 表示每1个Touch对象的独一无二的identifier,有了这个identifier可以确保总能追踪到这个Touch对象
screenX: 触摸点相对于屏幕左边缘的x坐标。
screenY: 触摸点相对于屏幕上边缘的y坐标。
clientX: 触摸点相对于浏览器的viewport左边缘的x坐标。不会包括左边的滚动距离。
clientY: 触摸点相对于浏览器的viewport上边缘的y坐标。不会包括上边的滚动距离。
pageX: 触摸点相对于document的左边缘的x坐标。与clientX不同的是,他包括左边滚动的距离,如果有的话。
pageY: 触摸点相对于document的左边缘的y坐标。与clientY不同的是,他包括上边滚动的距离,如果有的话。
target: 总是表示手指最开始放在触摸设备上的触发点所在位置的element DOM节点目标。即使已经移出了元素甚至移出了document,他表示的element仍然不变

3、TouchList
表示一组touches,当发生多点触摸的时候才用的到
一个TouchList代表一个触摸屏幕上所有触点的列表
用户三根手指接触屏幕(或触控板),与之相关的TouchList 对于每根手指都会生成一个Touch对象,共计3个

TouchList有1个属性,2个方法
只读属性：length
返回这个TouchList中Touch对的个数。(就是有几个手指接触到了屏幕)

touches: 表示当前跟踪的触摸操作的touch对象的数组
当一个手指在触屏上时event.touches.length = 1
当二个手指在触屏上时event.touches.length=2

方法：identifiedTouch()
返回值是在TouchList中的第1个Touch对象,已经被标记为过时,虽然有的浏览器还可以使用,但是不建议使用。

方法：item(index)
返回TouchList中指定索引的Touch对象。

想获取TouchList对象,TouchEvent的三个属性可以获取到TouchList:
1、changedTouches:(只读)
这个TouchList对象列出了和这个触摸事件对应的那些发生了变化的 Touch 对象。
表示上次触摸以来发生了什么改变的touch对象的数组

对于touchstart事件, 这个 TouchList 对象列出在此次事件中新增加的触点。
对于touchmove事件,列出和上一次事件相比较,发生了变化的触点。
对于touchend列出离开触摸平面的触点(这些触点对应已经不接触触摸平面的手指)

2、targetTouches:(只读)
这个TouchList列出了那些touchstart发生在这个元,并且还没有离开touch surface的touch point(手指),是touches的一个严格子集
特定于事件目标的touch对象的数组。touch事件会冒泡,所以可以使用这个属性指出目标对象

EventUtil.addHandler(touch,"touchstart",function(event){
  console.log(event.targetTouches);
})

3、touches:(只读)
这个TouchList列出了事件触发时touch suface上所有的touch point

touches.length>=targetTouches.length

</pre><pre class="js">
var div = document.querySelector("div");
var p = document.querySelector("p");
div.addEventListener("touchstart", function (e){
  p.innerHTML = "touches.length: " + e.touches.length + "<br> targetTouches.length: " + e.targetTouches.length + "<br> changedTouches.length: " + e.changedTouches.length;
})

</pre><pre class="js">
var EventUtil = {
  addHandler: function(element,type,handler) {
    if(element.addEventListener) {
      element.addEventListener(type,handler,false);
    }else if(element.attachEvent) {
      element.attachEvent("on"+type,handler);
    }else {
      element["on" +type] = handler;
    }
  },
  removeHandler: function(element,type,handler){
    if(element.removeEventListener) {
      element.removeEventListener(type,handler,false);
    }else if(element.detachEvent) {
      element.detachEvent("on"+type,handler);
    }else {
      element["on" +type] = null;
    }
  }
};
var touch = document.getElementById("touch");
EventUtil.addHandler(touch,"touchstart",function(event){
  console.log(event);
});
// 连续滑动触发
EventUtil.addHandler(window,"touchmove",function(event){
  alert(1);
});
//当手指从屏幕上离开时触发;
EventUtil.addHandler(window,"touchend",function(event){
  alert(1);
})

</pre>封装移动端事件<pre class="js">
(function (window){              //传入window,提高变量的查找效率
  function myQuery(selector){    //这个函数就是对外提供的接口
    return myQuery.prototype._init(selector);  //调用这个函数的原型对象上的_init方法并返回
  }
  myQuery.prototype = {
    _init: function (selector){           // 初始化方法,获取当前query对象的方法
      if (typeof selector == "string"){   //把查找到的元素存入到这个原型对象上
        this.ele = window.document.querySelector(selector);
        return this;                      //返回值其实就是原型对象
      }
    },
    /*单击事件：
     * 为了规避click的300ms的延迟,自定义一个单击事件
     * 触发时间：当抬起手指的时候触发
     * 需要判断手指落下和手指抬起的事件间隔,如果小于500ms表示单击时间。
     * 如果是大于等于500ms,算是长按时间
     * */
    tap: function (handler){
      this.ele.addEventListener("touchstart", touchFn);
      this.ele.addEventListener("touchend", touchFn);
      var startTime,endTime;
      function touchFn(e){
        e.preventDefault()
        switch (e.type){
          case "touchstart":
              startTime = new Date().getTime();
              break;
          case "touchend":
              endTime = new Date().getTime();
              if (endTime - startTime < 500) handler.call(this, e);
              break;
        }
      }
    },
    // 长按
    longTag: function (handler){
      this.ele.addEventListener("touchstart", touchFn);
      this.ele.addEventListener("touchmove", touchFn);
      this.ele.addEventListener("touchend", touchFn);
      var timerId;
      function touchFn(e){
        switch (e.type){
          case "touchstart" :  //500ms之后执行
              timerId = setTimeout(() => handler.call(this, e), 500)
              break;
          case "touchmove" :  //如果中间有移动也清除定时器
              clearTimeout(timerId)
              break;
          case "touchend" :  //如果在500ms之内抬起了手指,则需要定时器
              clearTimeout(timerId);
              break;
        }
      }
    },
    // 左侧滑动,记录手指按下的左边,在离开的时候计算deltaX是否满足左滑的条件
    slideLeft: function (handler){
      this.ele.addEventListener("touchstart", touchFn);
      this.ele.addEventListener("touchend", touchFn);
      var startX, startY, endX, endY;
      function touchFn(e){
        e.preventDefault();
        var firstTouch = e.changedTouches[0];
        switch (e.type){
          case "touchstart":
              startX = firstTouch.pageX;
              startY = firstTouch.pageY;
              break;
          case "touchend":
              endX = firstTouch.pageX;
              endY = firstTouch.pageY;
              if (Math.abs(endX - startX) >= Math.abs(endY - startY) && startX - endX >= 25){  
                handler.call(this, e);   //x方向移动大于y方向的移动,并且x方向的移动大于25个像素,表示在向左侧滑动
              }
              break;
        }
      }
    },
    // 右侧滑动。
    rightLeft: function (e){ }
  }
  window.$ = window.myQuery = myQuery;
})(window);

/* 使用,$("div")表示实例化一个myQuery对象,$("div").tap()表示调用该对象的tap方法 */
$("div").tap(function (e){
  console.log("单击事件")
})
$("div").longTag(function (){
  console.log("长按事件");
})

$("div").slideLeft(function (e){
  console.log(this);
  this.innerHTML = "左侧滑动了....."
})

</pre><pre>
【 移动端click事件300ms延迟 】
click事件在移动端会经过300ms的延迟后才触发。原因是,移动浏览器提供一个特殊的功能：双击(double tap)放大,用户碰触页面之后,需要等待一段时间来判断是不是双击(double tap)动作,而不是立即响应单击(click),等待的这段时间大约是300ms。那么怎么消除这个300ms延迟呢？

1.使用fastclick插件,会消除所有click事件的延迟,不推荐使用插件来解决这个问题

2.不用click事件,用移动设备提供的原生touch事件或某些移动端手势库提供的tap事件。移动端touch事件提供了 touchstart 、 touchmove 、 touchend等,
对于简单的页面,可以把touchstart或者touchend当作tap来用,这样可以解决300ms延迟问题,
但并不完美,比如手指接触目标元素,按住不放,慢慢移出响应区域,依然会触发 touchstart事件对应的事件处理器(本不应该触发),touchend也有类似的问题,
所以如果想模拟原生App的点击事件,需要自己封装一套tap事件或者使用手势库的tap事件,tap事件原理也非常简单,是由touchstart和touchend组合而成,首先要判断touchend和touchstart的偏移距离,然后阻止掉touchend事件300ms之后触发的click事件,并且始终以touchend事件作为触发的必要条件

</pre><pre class="js">
function tap(node,callback,scope) {
  node.addEventListener(TOUCHSTART, function(e) {
    x = e.touches[0].pageX;
    y = e.touches[0].pageY;
});
  node.addEventListener(TOUCHEND, function(e) {
    e.stopPropagation();
    e.preventDefault();
    var curx = e.changedTouches[0].pageX;
    var cury = e.changedTouches[0].pageY;
    if (Math.abs(curx - x) < 6 && Math.abs(cury - y) < 6) {
      callback.apply(scope, arguments);
    }
  });
}

</pre><pre>
【 点击穿透 】
如果某个返回按钮的位置,恰好在要返回的这个页面的带有href属性的a标签的范围内,在点击返回按钮后,页面快速切换到有a标签的页面,300ms后触发了click事件,从而触发了a标签的意外跳转,这个就是典型的点击穿透问题。罪魁祸首其实就是a标签跳转默认是click事件触发,而移动端的touch事件触发之后,依然会在300ms后触发click事件。解决办法其实在上面一条已经提到了。

1.就是消费掉touch事件完成后的click事件。
2.不要混用touch和click事件。显然不可能都绑定click事件,因为要解决300ms延迟问题(除了fastclick),那么只能都绑定touch事件,这样click事件永远不会被触发。
综上二条,最好的办法就是自己封装一个tap事件,并且自己阻止掉300ms后的click事件,完美解决。

注意：zepto并没有阻止click事件,所以使用zepto的tap事件依然会导致点击穿透问题,你需要手动添加 e.preventDefault() 来阻止click事件

【 tap事件的原理 】
tap事件的原理其实是源于触摸touch事件,在移动触摸事件就是在同个点触发,及touchmove的距离距离touchstar的距离为0,并且点击的时间不超过某个设定的时间值,超过该时间值的话,就属于长按了

</pre><pre class="js">
//封装tap的方法
function tap(ele, callBack){
  var startTime=0;  //触摸开始的时间
  var ismove=false; //定义touchmove是否触发
  var maxTime=250;
  ele.addEventListener('touchstart',function(e){
    startTime=Date.now();
    ismove=false;
  })
  ele.addEventListener('touchmove',function(e){
    ismove=true;  //触发就赋值为true
  })
  ele.addEventListener('touchend',function(e){
    if (ismove) return //判断是否是touchmove是否触发
    if ((Date.now()-startTime)>maxTime) return // 判断是否为长按
    // 如果能够到这里
    callBack(e);
  })

}

</pre><pre>
Gestures
这个事件针对IOS设备上的,一个Gestures事件在两个或更多手指触摸屏幕时触发。如果任何手指你正在监听的Gesture事件(gesturestart,gesturechange,gestureend)节点上,你将收到对应的gestures事件。
Gesturestart：当一个手指已经按在屏幕上,而另一个手指又触摸在屏幕时触发。
Gesturechange：当触摸屏幕的任何一个手指的位置发生改变的时候触发。
Gestureend：当任何一个手指从屏幕上面移开时触发。

触摸事件和手势事件的之间关系：
当一个手指放在屏幕上时,会触发touchstart事件,而另一个手指触摸在屏幕上时触发gesturestart事件,随后触发基于该手指的touchstart事件。
如果一个或两个手指在屏幕上滑动时,将会触发gesturechange事件,但是只要有一个手指移开时候,则会触发gestureend事件,紧接着会触发touchend事件。

手势的专有属性：
rotation: 表示手指变化引起的旋转角度,负值表示逆时针,正值表示顺时针,从0开始;
scale: 表示2个手指之间的距离情况,向内收缩会缩短距离,这个值从1开始的并随距离拉大而增长

</pre><pre class="js">
1.判断是否为iPhone
function isAppleMobile() {
  return (navigator.platform.indexOf('iPad') != -1);
};

2.自动大写与自动修正
要关闭这两项功能,可以通过autocapitalize与autocorrect 这两个选项：
input type="text" autocapitalize="off" autocorrect="off"

3.禁止iOS弹出各种操作窗口
-webkit-touch-callout:none

4. 禁止用户选中文字
-webkit-user-select:none

5. 关于 iOS 系统中,中文输入法输入英文时,字母之间可能会出现一个六分之一空格
this.value = this.value.replace(/u2006/g, '');

6. Andriod 上去掉语音输入按钮
input::-webkit-input-speech-button {display: none}

7. 判断是否为微信浏览器;
function is_weixn(){
  var ua = navigator.userAgent.toLowerCase();
  return ua.match(/MicroMessenger/i)=="micromessenger" ? true : false;
}

五：屏幕旋转事件(onorientationchange),判断屏幕是否旋转的JS代码如下：

</pre><pre class="js">
function orientationChange() {
  switch(window.orientation) {
    case 0: alert("肖像模式 0,screen-width:"+screen.width+";screen-height:"+screen.height); break;
    case -90: alert("左旋 -90,screen-width:"+screen.width+";screen-height:"+screen.height); break;
    case 90: alert("右旋 90,screen-width:"+screen.width+";screen-height:"+screen.height); break;
    case 180: alert("风景模式 180,screen-width:"+screen.width+";screen-height:"+screen.height); break;
  };
};
// 添加测试监听函数代码如下：
addEventListener('load', function(){
  orientationChange();
  window.onorientationchange = orientationChange;
});

</pre><pre>
【 四大浏览器内核 】
1.Trident (IE浏览器)
因为在早期IE占有大量的市场份额,所以以前有很多网页是根据这个Trident的标准来编写的,但是实际上这个内核对真正的网页标准支持不是很好,同时存在许多安全Bug
2.Gecko:(FireFox)优点就是功能强大、丰富,可以支持很多复杂网页效果和浏览器扩展接口,缺点是消耗很多的资源,比如内存
3.Webkit: (Chrome/Safari/UC)
优点就是Webkit拥有清晰的源码结构、极快的渲染速度,缺点是对网页代码的兼容性较低,会使一些编写不标准的网页无法正确显示
4.Presto: (欧朋)
被称为公认的浏览网页速度最快的内核,同时也是处理JS脚本最兼容的内核,能在Windows、Mac及Linux操作系统下完美运行

移动端开发主要对象是手持设备,其中绝大部分是IOS和Android系统,基于Webkit内核,可使用Chrome浏览器调试即可

主流的手机浏览器：UC、百度、欧朋、QQ、海豚、safari、Chrome,都是基于webkit内核的,兼容性方面不存在问题,同时对html5和css3的支持很好

主流的手机分辨率为：480*800像素、320*480像素,而1280*720像素(720P)会是接下来的趋势。这些都是很粗略的统计,要有精确的数据需要花费不少的精力,那是数据分析人员的工作

【 移动端开发的优劣 】
优势：
移动端开发的优势简单来说就是兼容性更好了,基本上只需要针对webkit内核的浏览器做兼容就好了,而且本身这类浏览器对html5、css3的兼容性就比较高,所以PC端不太敢用的属性就大胆的用起来吧。
移动端还可以使用很多设备接口来实现更好的交互效果,比如陀螺仪实现类似3D VR效果,多指操作实现图片缩放旋转,获取地理位置等。

劣势：
移动端目前设备类型特别多,移动端的适配比较难处理,移动端的事件也是一个难题,比如tap延迟,点击穿透等问题

【 响应式web开发 】
用自适应布局模式可以让页面在ipad、itouch、ipod、iphone、android、web   safarik、chrome都能够正常的显示,无需再次考虑设备的分辨率
响应式web设计采用了媒体查询(@media screen and (max-width:960px){})、流式布局(百分比)、液态图片(max-width:100%)三项技术,把它们组合在一起来制作页面,使得页面不只在传统桌面,在平板电脑和手机上,各种不同的分辨率都能够完美显示

＜meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0" /＞
强制让文档的宽度与设备的宽度保持1:1,并且文档最大的宽度比例是1.0,且不允许用户点击屏幕放大浏览

＜meta content="yes" name=" apple-mobile-web-app-capable" /＞
meta标签是iphone设备中的safari私有meta标签,表示允许全屏模式浏览

＜meta content="black" name=" apple-mobile-web-app-status-bar-style"   /＞
meta标签也是iphone的私有标签,它指定的iphone中safari顶端的状态条的样式

＜meta content="telephone=no,email=no" name="format-detection" /＞
禁止自动识别电话号码和邮箱

＜meta content="yes" name="apple-mobile-web-app-capable"＞
苹果手机：会删除默认的工具栏和菜单栏,网站开启对web app程序的支持

＜meta name="apple-mobile-web-app-status-bar-style" content="black" /＞
苹果手机：在web app应用下状态条(屏幕顶部条)的颜色,默认值为default(白色),可以定为black(黑色)和black-translucent(灰色半透明)

＜meta name="apple-touch-fullscreen" content="yes" /＞
苹果手机：如果把一个web app添加到了主屏幕中,那么从主屏幕中打开这个web app则全屏显示

＜link rel="apple-touch-icon" href="/static/images/identity/HTML5_Badge_64.png" /＞
苹果手机：将应用添加到手机主屏幕,会有一个icon可以直接进入


【 HTTP刷新 】
＜meta http-equiv="Cache-Control" content="no-cache"/＞
＜meta http-equiv="refresh" content="15"/＞

注意的是这个 XHTML MP 例子中需要 ＜meta http-equiv="Cache-Control" content="no-cache"/＞. 如果上述代码没被包含, WAP 浏览器将仅仅显示缓存中的文档的复本, 而不需要每次刷新都连接服务器.
＜meta http-equiv="refresh" content="15;URL=hello_world_example1.xhtml"/＞
某些 WAP 浏览器是不支持 HTTP 刷新的. 例如, HTTP 刷新在 Openwave 移动浏览器 6.2.2 版上运行良好, 但在 Nokia 移动浏览器 4.0 版, Sony Ericsson T610 和 T68i 移动电话模拟器上是不起作用的.

【 注释 】
＜meta name="author" content="mark"/＞

【 clearType字体 】
＜meta http-eqiv="cleartype" content="ON|OFF"＞

定义页面尺寸
IE的使用:＜meta name="MobileOptimized" content="240"＞
google搜索中知道这个可以解决flash不能全屏的问题,自己没遇到过。
其他使用:＜meta id="viewport" name="viewport" content="width=320; initial-scale=1.0; maximum-scale=1.0; user-scalable=0;" /＞

3.学会使用webkit-box。
我们说过自适应布局模式,有些同学可能会问：如何在移动设备上做到完全自适应呢？很感谢webkit为display属性提供了一个 "webkit-box" 的值,它可以帮助前端工程师做到盒子模型灵活控制。

4、如何去除Android平台中对邮箱地址的识别 看过iOS webapp  API的同学都知道iOS提供了一个meta标签:用于禁用iOS对页面中电话号码的自动识别。在iOS中是不自动识别邮件地址的,但在Android平 台,它会自动检测邮件地址,当用户touch到这个邮件地址时,Android会弹出一个框提示用户发送邮件,如果你不想Android自动识别页面中的 邮件地址,你不妨加上这样一句meta标签在head中
＜meta content="email=no" name="format-detection" /＞

5、如何去除iOS和Android中的输入URL的控件条 你的老板或者PD或者交互设计师可能会要求你：能否让我们的webapp更加像nativeapp,我不想让用户看见那个输入url的控件条？答案是可以做到的。我们可以利用一句简单的javascript代码来实现这个效果

setTimeout(scrollTo,0,0,0);

请注意,这句代码必须放在window.onload里才能够正常的工作,而且你的当前文档的内容高度必须是高于窗口的高度时,这句代码才能有效的执行。

6、如何禁止用户旋转设备 我曾经也想禁止用户旋转设备,也想实现像某些客户端那样：只能在肖像模式或景观模式下才能正常运行。但现在我可以很负责任的告诉你：别想了!在移动版的webkit中做不到！至少Apple webapp  API已经说到了：我们为了让用户在safari中正常的浏览网页,我们必须保证用户的设备处于任何一个方位时,safari都能够正常的显示网页内容 (也就是自适应),所以我们禁止开发者阻止浏览器的orientationchange事件,看来苹果公司的出发点是正确的,苹果确实不是一般的苹果。iOS已经禁止开发者阻止orientationchange事件,那Android呢？对不起,我没有找到任何资料说Android禁止开发者阻止浏览器orientationchange事件,但是在Android平台,确实也是阻止不了的。

7、如何检测用户是通过主屏启动你的webapp
看过Apple webapp API的同学都知道iOS为safari提供了一个将当前页面添加主屏的功能,按下iphone\ipod\ipod  touch底部工具中的小加号,或者ipad顶部左侧的小加号,就可以将当前的页面添加到设备的主屏,在设备的主屏会自动增加一个当前页面的启动图标,点 击该启动图标就可以快速、便捷的启动你的webapp。从主屏启动的webapp和浏览器访问你的webapp最大的区别是它清除了浏览器上方和下方的工具条,这样你的webapp就更加像是nativeapp了,还有一个区别是window对像中的navigator子对象的一个standalone属性。iOS中浏览器直 接访问站点时,navigator.standalone为false,从主屏启动webapp时,navigator.standalone为true,  我们可以通过navigator.standalone这个属性获知用户当前是否是从主屏访问我们的webapp的。在Android中从来没有添加到主 屏这回事！

6、如何关闭iOS中键盘自动大写 我们知道在iOS中,当虚拟键盘弹出时,默认情况下键盘是开启首字母大写的功能的,根据某些业务场景,可能我们需要关闭这个功能,移动版本webkit为input元素提供了autocapitalize属性,通过指定autocapitalize="off"来关闭键盘默认首字母大写。

</pre><textarea rows="20" cols="150">
<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=2.0, user-scalable=no" />
<title>首页</title>
<meta name="keywords" content="首页关键字" />
<meta name="description" content="首页描述" />
<meta http-equiv="Cache-Control" content="no-cache" />
<meta name="format-detection" content="telephone=no">
<meta name="apple-mobile-web-app-capable" content="yes" />
<link rel="apple-touch-icon-precomposed" sizes="48×48" href="/imgs/48×48.png" />
<link rel="apple-touch-icon-precomposed" sizes="72×72" href="/imgs/72×72.png" />
<link rel="apple-touch-icon-precomposed" sizes="114×114" href="/imgs/114×114.png" />
</head>
<body>
</body>
</html>

</textarea>
</div>

<div id="jqueryMobile">
<h2>jquery mobile</h2>
<pre>
jQuery Mobile 是一个为触控优化的框架,用于创建移动 web 应用程序。
jQuery 适用于所有流行的智能手机和平板电脑：
jQuery Mobile 构建于 jQuery 库之上,这使其更易学习,如果您通晓 jQuery 的话。
它使用 HTML5、CSS3、JavaScript 和 AJAX 通过尽可能少的代码来完成对页面的布局
jQuery Mobile 将"写得更少、做得更多"这一理念提升到了新的层次：它会自动为网页设计交互的易用外观,并在所有移动设计上保持一致
jQuery Mobile只用 HTML、CSS 和 JavaScript,这些技术都是所有移动 web 浏览器的标准

< head>
< link rel="stylesheet" href="http://code.jquery.com/mobile/1.3.2/jquery.mobile-1.3.2.min.css">
< script src="http://code.jquery.com/jquery-1.8.3.min.js"></ script>
< script src="http://code.jquery.com/mobile/1.3.2/jquery.mobile-1.3.2.min.js"></ script>
</ head>

</pre><pre class="html">
<div data-role="page">
  <div data-role="header">
    <h1>欢迎访问我的主页</h1>
  </div>

  <div data-role="content">
    <p>现在我已经成为一名移动开发者！</p>
  </div>

  <div data-role="footer">
    <h1>页脚文本</h1>
  </div>
</div>

</pre><pre>
在 jQuery Mobile,可以在单一HTML文件中创建多个页面,请通过唯一的id来分隔每张页面,并使用href属性来连接彼此

</pre><pre class="html">
<div data-role="page" id="pageone">
  <div data-role="content">
    <a href="#pagetwo">转到页面二</a>
  </div>
</div>

<div data-role="page" id="pagetwo">
  <div data-role="content">
    <a href="#pageone">转到页面一</a>
  </div>
</div>

</pre><pre>
【将页面用作对话框】
对话框是用来显示信息或请求输入的视窗类型。
如需在用户点击(轻触)链接时创建一个对话框,请向该链接添加 data-rel="dialog"

【jQuery Mobile 过渡效果】
jQuery Mobile 拥有一系列关于如何从一页过渡到下一页的效果。
如需实现过渡效果,浏览器必须支持 CSS3 3D 转换

过渡效果可应用于任意链接或通过使用 data-transition 属性进行的表单提交：
< a href="#anylink" data-transition="slide">滑动到页面二</ a>

fade	    所有链接上都是默认的。淡入淡出到下一页
flip	    从后向前翻动到下一页
flow	    抛出当前页面,引入下一页
pop         像弹出窗口那样转到下一页
slide	    从右向左滑动到下一页
slidefade   从右向左滑动并淡入到下一页
slideup	    从下到上滑动到下一页
slidedown   从上到下滑动到下一页
turn	    转向下一页
none	    无过渡效果

以上所有效果同时支持反向动作,例如,如果您希望页面从左向右滑动,而不是从右向左,请使用值为 "reverse" 的 data-direction 属性。在后退按钮上是默认的

【在 jQuery Mobile 中创建按钮】
jQuery Mobile 中的按钮可通过三种方法创建：
使用button元素
使用input元素
使用data-role="button"的a元素

行内按钮
jQuery Mobile 中的按钮会自动获得样式,这增强了他们在移动设备上的交互性和可用性
默认情况下,按钮会占据屏幕的全部宽度。如果您需要按钮适应其内容,或者如果您需要两个或多个按钮并排显示,请添加 data-inline="true"

组合按钮
jQuery Mobile 提供了对按钮进行组合的简单方法。
data-role="controlgroup"属性与data-type="horizontal|vertical"一同使用,以规定水平或垂直地组合按钮

默认情况下,组合按钮是垂直分组的,彼此间没有外边距和空白。并且只有第一个和最后一个按钮拥有圆角,在组合后就创造出了漂亮的外观

后退按钮
如需创建后退按钮,请使用 data-rel="back" 属性(会忽略锚的 href 值)

</pre><pre class="html">
<div data-role="controlgroup" data-type="horizontal">
  <p>水平分组：</p>
  <a href="#" data-role="button">按钮 1</a>
  <a href="#" data-role="button">按钮 2</a>
  <a href="#" data-role="button">按钮 3</a>
</div><br>

<div data-role="controlgroup" data-type="vertical">
  <p>垂直分组(默认)：</p>
  <a href="#" data-role="button">按钮 1</a>
  <a href="#" data-role="button">按钮 2</a>
  <a href="#" data-role="button">按钮 3</a>
</div>

<a href="#" data-role="button" data-rel="back">返回</a>

</pre><pre>
更多用于按钮的 data-* 属性
data-corners    true | false	规定按钮是否有圆角
data-mini       true | false	规定是否是小型按钮
data-shadow     true | false	规定按钮是否有阴影

按钮添加图标时使用data-icon属性,属性错误时默认为加号图标
< a href="#anylink" data-role="button" data-icon="search">搜索</ a>

data-icon="arrow-l"	左箭头
data-icon="arrow-r"	右箭头
data-icon="arrow-u"	上箭头
data-icon="arrow-d"	下箭头
data-icon="plus"	加,添加转发按钮
data-icon="minus"	减
data-icon="delete"	删除
data-icon="check"	检查
data-icon="home"	首页
data-icon="info"	信息
data-icon="grid"	网格
data-icon="gear"	齿轮
data-icon="search"	搜索
data-icon="back"	后退,返回
data-icon="forward"	向前
data-icon="refresh"	刷新
data-icon="star"	星
data-icon="alert"	提醒

定位图标
您也能够规定图标被放置的位置：上、右、下或左。
请使用 data-iconpos 属性来规定位置:left right top bottom
默认地,所有按钮中的图标靠左放置

如果只需显示图标,请将 data-iconpos 设置为 "notext"

【jQuery Mobile 工具栏】
工具栏元素常被放置于页眉和页脚中 - 以实现"已访问"的导航

标题栏
页眉通常会包含页眉标题/LOGO 或一到两个按钮(通常是首页、选项或搜索按钮)
可以在页眉中向左侧或/以及右侧添加按钮
页眉标题两侧只有一个按钮时默认添加到左侧,如需添加到右侧需在按钮上添加规定类名 "ui-btn-right"
页眉可包含一个或两个按钮,然而页脚没有限制

页脚栏
与页眉相比,页脚更具伸缩性 - 它们更实用且多变,所以能够包含所需数量的按钮
页脚与页眉的样式不同(它会减去一些内边距和空白,并且按钮不会居中)。如果要修正该问题,请在页脚设置类名 "ui-btn",如：div data-role="footer" class="ui-btn"

</pre><pre class="html">
<div data-role="header">
  <a href="#" data-role="button">首页</a>
  <h1>欢迎来到我的主页</h1>
  <a href="#" data-role="button">搜索</a>
</div>

<div data-role="footer">
  <a href="#" data-role="button" data-icon="plus">转播到新浪微博</a>
  <a href="#" data-role="button" data-icon="plus">转播到腾讯微博</a>
  <a href="#" data-role="button" data-icon="plus">转播到QQ空间</a>
</div>

也能够选择在页脚中水平还是垂直地组合按钮
<div data-role="footer" class="ui-btn">
  <div data-role="controlgroup" data-type="horizontal">
    <a href="#" data-role="button" data-icon="plus">转播到新浪微博</a>
    <a href="#" data-role="button" data-icon="plus">转播到腾讯微博</a>
    <a href="#" data-role="button" data-icon="plus">转播到 QQ 空间</a>
  </div>
</div>

</pre><pre>
定位页眉和页脚
请使用 data-position 属性来定位页眉和页脚
放置页眉和页脚的方式有三种：
Inline - 默认。页眉和页脚与页面内容位于行内,占据页面位置。
Fixed - 页面和页脚会留在页面顶部和底部,不占页面位置。
Fullscreen - 与 fixed 类似;页面和页脚会留在页面顶部和底部,but also over the page content. It is also slightly see-through

如果需要启用全面定位,请使用 data-position="fixed",并向该元素添加 data-fullscreen 属性

fullscreen对于照片、图像和视频非常理想。
对于fixed和fullscreen定位,触摸屏幕将隐藏和显示页眉及页脚
如果滚动条可用,那么敲击屏幕将隐藏或显示页眉/页脚。效果会根据您在页面上的位置而变化,显示隐藏页眉或页脚或者两者同时显示或隐藏

</pre><pre class="html">
Inline 定位(默认)
<div data-role="header" data-position="inline"></div>
<div data-role="footer" data-position="inline"></div>

Fixed 定位
<div data-role="header" data-position="fixed"></div>
<div data-role="footer" data-position="fixed"></div>

Fullscreen 定位
<div data-role="header" data-position="fixed" data-fullscreen="true"></div>
<div data-role="footer" data-position="fixed" data-fullscreen="true"></div>

</pre><pre>
【导航栏】
导航栏由一组水平排列的链接构成,通常位于页眉或页脚内部,也可位于content部分
默认地,导航栏中的链接会自动转换为按钮(无需 data-role="button")。
请使用 data-role="navbar" 属性来定义导航栏

按钮的宽度,默认地与其内容一致。使用无序列表来均等地划分按钮：一个按钮占据 100% 的宽度,两个按钮各分享 50% 的宽度,三个按钮 33.3%,以此类推。不过,如果您在导航栏中规定了五个以上的按钮,那么它会弯折为多行

活动按钮
当导航栏中的链接被敲击时,会获得选取外观(按下)。
如需在不敲击链接时实现此外观,请使用 class="ui-btn-active"

对于多个页面,您也许需要为每个按钮设置"被选"外观,以表示用户正在浏览该页面。如果要这么做,请向链接添加 "ui-state-persist" 类,以及 "ui-btn-active" 类
< li>< a href="#anylink" class="ui-btn-active ui-state-persist">首页</ a></ li>

</pre><pre class="html">
<div data-role="header">
  <div data-role="navbar">
    <ul>
      <li><a href="#anylink" class="ui-btn-active">首页</a></li>
      <li><a href="#anylink">页面二</a></li>
      <li><a href="#anylink">搜索</a></li>
    </ul>
  </div>
</div>

</pre><pre>
【可折叠的内容块】
可折叠Collapsibles允许隐藏或显示内容 - 对于存储部分信息很有用。
如需创建可折叠的内容块,请向某个容器分配 data-role="collapsible" 属性。在容器div中添加一个标题元素(h1-h6),其后是您需要扩展的任意HTML标记

默认地该内容是关闭的。如需在页面加载时扩展内容,请使用 data-collapsed="false
默认地可折叠块带有包含外边距的圆角,使用 data-inset="false" 可去掉圆角
通过data-mini最小化collapsibles,使 collapsibles 更小巧
通过data-collapsed-icon和data-expanded-icon改变collapsibles的图标(默认是 + 和 -)

可折叠内容块可以被嵌套任意次数

</pre><pre class="html">
<div data-role="collapsible" data-collapsed="false">
  <h1>点击我 - 我可以折叠！默认展开</h1>
  <p>现在我默认是展开的。</p>
</div>
<div data-role="collapsible">
  <h1>点击我 - 我可以折叠！</h1>
  <p>我是可折叠的内容。</p>
</div>
<div data-role="collapsible">
  <h1>点击我 - 我可以折叠！嵌套的可折叠</h1>
  <p>我是被展开的内容。</p>
  <div data-role="collapsible">
    <h1>点击我 - 我是嵌套的可折叠块！</h1>
    <p>我是嵌套的可折叠块中被展开的内容。</p>
  </div>
</div>
<div data-role="collapsible" data-collapsed-icon="arrow-d" data-expanded-icon="arrow-u">
  <h1>data-collapsed-icon 规定按钮的图标。</h1>
  <p>data-expanded-icon 规定内容被展开时按钮的图标。</p>
</div>

</pre><pre>
可折叠集合
可折叠集合(Collapsible sets)指的是被组合在一起的可折叠块(常被称为手风琴)。当新块被打开时,所有其他块会关闭。
创建若干内容块,然后通过 data-role="collapsible-set" 用新容器包装这个可折叠块：

</pre><pre class="html">
<div data-role="collapsible-set">
  <div data-role="collapsible">
    <h1>点击我 - 我可以折叠！</h1>
    <p>我是被展开的内容。</p>
  </div>
  <div data-role="collapsible">
    <h1>点击我 - 我可以折叠！</h1>
    <p>我是被展开的内容。</p>
  </div>
</div>

</pre><pre>
【布局网格】
jQuery Mobile提供了一套基于CSS的列布局方案。不过一般不推荐在移动设备上使用列布局,这是由于移动设备的屏幕宽度所限。
但是有时您需要定位更小的元素,比如按钮或导航栏,就像在表格中那样并排。这时,列布局就恰如其分。
网格中的列是等宽的(总宽是 100%),无边框、背景、外边距或内边距。

在列容器中,根据不同的列数,子元素可设置类 ui-block-a|b|c|d|e。这些列将依次并排浮动

可使用的布局网格有四种：
网格类	   列	列宽度	                     对应
ui-grid-a	2	50% / 50%	                 ui-block-a|b
ui-grid-b	3	33% / 33% / 33%	             ui-block-a|b|c
ui-grid-c	4	25% / 25% / 25% / 25%	     ui-block-a|b|c|d
ui-grid-d	5	20% / 20% / 20% / 20% / 20%	 ui-block-a|b|c|d|e

可以通过使用 CSS 来定制列块
设置.ui-block-a,.ui-block-b,.ui-block-c样式
或者通过行内样式设置

</pre><pre class="html">
<p>两列布局：</p>
<div class="ui-grid-a">
 <div class="ui-block-a"><a href="#" data-role="button">第一列按钮</a><br>
   <span>第一列：This is some text. This is some text.</span>
 </div>
 <div class="ui-block-b">
   <a href="#" data-role="button">第二列按钮</a><br>
   <span>第二列：This is some text. This is some text.</span>
 </div>
</div>

<p>五列布局：</p>
<div class="ui-grid-d">
 <div class="ui-block-a"><a href="#" data-role="button">第一列</a><br>
   <span>第一列：This is some text. This is some text. </span>
 </div>
 <div class="ui-block-b">
   <a href="#" data-role="button">第二列</a><br>
   <span>第二列：This is some text. This is some text.</span>
 </div>
 <div class="ui-block-c">
   <a href="#" data-role="button">第三列</a><br>
   <span>第三列：This is some text. This is some text. </span>
 </div>
 <div class="ui-block-d">
   <a href="#" data-role="button">第四列</a><br>
   <span>第四列：This is some text. This is some text. </span>
 </div>
 <div class="ui-block-e">
   <a href="#" data-role="button">第五列</a><br>
   <span>第五列：This is some text. This is some text. </span>
 </div>
</div>

</pre><pre>
在列中包含多个行也是可能的
ui-block-a-class 将始终创建新行

</pre><pre class="html">
<div class="ui-grid-b">
  <div class="ui-block-a"><span>Some Text</span></div>
  <div class="ui-block-b"><span>Some Text</span></div>
  <div class="ui-block-c"><span>Some Text</span></div>
  <div class="ui-block-a"><span>Some Text</span></div>
  <div class="ui-block-b"><span>Some Text</span></div>
  <div class="ui-block-a"><span>Some Text</span></div>
</div>

</pre><pre>
【列表视图】
jQuery Mobile 中的列表视图是标准的 HTML 列表：有序列表ol和无序列表ul
如需创建列表请向ol或ul元素添加 data-role="listview",如需使这些项目可点击,请在每个列表项li中规定链接
默认地,列表中的列表项会自动转换为按钮(无需 data-role="button")
如需为列表添加圆角和外边距,请使用 data-inset="true" 属性

只读列表：创建没有链接的列表,不是按钮,不可点击

列表缩略图
对于大于16x16px的图像,请在链接中添加img元素,jQuery Mobile将自动把图像调整至80x80px
如需向您的列表添加16x16px的图标,请向img元素添加 class="ui-li-icon" 属性

列表项设置不同的链接图标(右箭头是默认的),自定义时在li上设置data-icon="plus"
plus     +
minus    -
delete   ×
info     !
false

列表分隔符(List Dividers)用于把项目组织和组合为分类/节。
如需规定列表分隔符,请向li元素添加 data-role="list-divider" 属性

如果您的列表是字母顺序的(比如通讯录),jQuery Mobile 自动添加恰当的分隔符,通过在ol,ul元素上设置 data-autodividers="true" 属性
data-autodividers="true" 属性通过对列表项文本的首字母进行大写来创建分隔符

搜索过滤器
如需在列表中添加搜索框,请在ul或ol使用data-filter="true" 属性
默认地,搜索框中的文本是 "Filter items..."。
如需修改默认文本,请使用 data-filter-placeholder 属性

</pre><pre class="html">
<ol data-role="listview">
  <li><a href="#">列表项</a></li>
  <li><a href="#">列表项</a></li>
  <li><a href="#">列表项</a></li>
</ol>
<ul data-role="listview">
  <li data-role="list-divider">欧洲</li>
  <li><a href="#">德国</a></li>
  <li><a href="#">英国</a></li>
  <li data-role="list-divider">亚洲</li>
  <li><a href="#">中国</a></li>
  <li><a href="#">印度</a></li>
  <li data-role="list-divider">非洲</li>
  <li><a href="#">埃及</a></li>
  <li><a href="#">南非</a></li>
</ul>

</pre><pre>
拆分按钮
如需创建带有垂直分隔栏的拆分列表,请在li元素内放置两个链接。
jQuery Mobile 会自动为第二个链接添加蓝色箭头图标的样式,链接中的文本(如有)将在用户划过该图标时显示
通过添加页面和对话框,可使链接的功能更强

</pre><pre class="html">
<ul data-role="listview" data-inset="true">
  <li data-role="divider">Browsers</li>
  <li>
    <a href="#">
    < img src="/i/chrome.png">
    <h2>Google Chrome</h2>
    <p>Google Chrome is a free, open-source web browser. Released in 2008.</p>
    </a>
    <a href="#download" data-rel="dialog" data-transition="pop">Download Browser</a>
  </li>
  <li>
    <a href="#">
    < img src="/i/firefox.png">
    <h2>Mozilla Firefox</h2>
    <p>Firefox is a web browser from Mozilla. Released in 2004.</p>
    </a>
    <a href="#download" data-rel="dialog" data-transition="pop">Download Browser</a>
  </li>
</ul>

</pre><pre>
计数泡沫
计数泡沫用于显示与列表项相关的数目,例如邮箱中的消息
如需添加计数泡沫,请使用行内元素,比如span,设置class "ui-li-count"属性并添加数字

如需在计数泡泡中显示正确的数字,就必须进行程序化更新

</pre><pre class="html">
<h2>我的邮箱</h2>
<ul data-role="listview" data-inset="true">
  <li><a href="#">收件箱<span class="ui-li-count">25</span></a></li>
  <li><a href="#">发件箱<span class="ui-li-count">432</span></a></li>
  <li><a href="#">垃圾箱<span class="ui-li-count">7</span></a></li>
</ul>

</pre><pre>
【表单】
jQuery Mobile会自动通过AJAX进行表单提交,并会尝试将服务器响应整合入应用程序的DOM中

jQuery Mobile会自动为HTML表单添加优异的便于触控的外观
jQuery Mobile使用CSS来设置HTML表单元素的样式,以使其更有吸引力更易用。

在jQuery Mobile中可以使用以下表单控件：
文本框
搜索框
单选框
复选框
选择菜单
滑动条
翻转切换开关

当您与jQuery Mobile表单打交道时,应该了解以下信息：
form元素必须设置method和action属性
每个表单元素必须设置唯一的"id"属性。该id在站点的页面中必须是唯一的。这是因为jQuery Mobile的单页面导航模型允许许多不同的"页面"同时呈现。
每个表单元素必须有一个标记label,请设置label的for属性来匹配元素的id
如需隐藏label请使用类ui-hidden-accessible,这很常用,当您需要元素的placeholder属性充当label时
如果需label和表单元素在宽屏幕上显示正常,请用带有data-role="fieldcontain"属性的div或fieldset元素来包装label或表单元素
fieldcontain 属性基于页面宽度来设置 label 和表单控件的样式。当页面宽度大于 480px 时,它会自动将 label 与表单控件放置于同一行。当小于 480px 时,label 会被放置于表单元素之上

如需避免 jQuery Mobile 自动为可点击元素设置样式,请使用 data-role="none" 属性

如需对单选框或复选框进行水平分组,请使用 data-type="horizontal" 属性

如果您希望在所有移动设备上显示一致外观的选择菜单,请使用 jQuery 的自定义选择菜单,data-native-menu="false" 属性

切换开关常用于开/关或对/错按钮：
如需创建切换,请使用 data-role="slider" 的select元素,并添加两个option元素
使用 "selected" 属性来把选项之一设置为预选(突出显示

</pre><pre class="html">
<form method="post" action="">
  <div data-role="fieldcontain">
    <label for="fname">First name:</label>
    <input type="text" name="fname" id="fname">
    <label for="lname">Last name:</label>
    <input type="text" name="lname" id="lname">
  </div>
</form>

<form method="post" action="">
  <fieldset data-role="controlgroup" data-type="horizontal">
    <legend>Choose your gender:</legend>
      <label for="male">Male</label>
      <input type="radio" name="gender" id="male" value="male">
      <label for="female">Female</label>
      <input type="radio" name="gender" id="female" value="female">
  </fieldset>
</form>

<select name="day" id="day">
   <optgroup label="Weekdays">
    <option value="mon">Monday</option>
    <option value="tue">Tuesday</option>
    <option value="wed">Wednesday</option>
   </optgroup>
   <optgroup label="Weekends">
    <option value="sat">Saturday</option>
    <option value="sun">Sunday</option>
   </optgroup>
</select>

<form method="post" action="。。。">
  <div data-role="fieldcontain">
    <label for="switch">Toggle Switch:</label>
    <select name="switch" id="switch" data-role="slider">
      <option value="on">On</option>
      <option value="off">Off</option>
    </select>
  </div>
</form>

</pre><pre>
【jQuery Mobile 主题】
jQuery Mobile提供五种不同的样式主题,从"a"到"e"- 每种主题带有不同颜色的按钮、栏、内容块等等,每一种主题由多种可见的效果和颜色构成。
如需定制应用程序的外观可使用data-theme属性为页面的任意元素设置
< div data-role="page" data-theme="a|b|c|d|e">

默认地jQuery Mobile为页眉和页脚使用 "a" 主题,为页眉内容使用 "c" 主题(亮灰)
默认地页面的子元素会继承应用主题的父元素的样式,如需改变可在链接中添加 data-theme 属性

a	默认。黑色背景上的白色文本
b	蓝色背景上的白色文本 / 灰色背景上的黑色文本
c	亮灰色背景上的黑色文本
d	白色背景上的黑色文本
e	橙色背景上的黑色文本

主题化的对话框
data-overlay-theme 属性规定对话框出现在其上的页面的背景色
</pre><pre class="html">
<a href="#pagetwo" data-rel="dialog">Go To The Themed Dialog Page</a>

<div data-role="page" id="pagetwo" data-overlay-theme="e">
  <div data-role="header" data-theme="b"></div>
  <div data-role="content" data-theme="a"></div>
  <div data-role="footer" data-theme="c"></div>
</div>

</pre>主题化的按钮<pre class="html">
<a href="#" data-role="button" data-theme="a">Button</a>
<a href="#" data-role="button" data-theme="b">Button</a>
<a href="#" data-role="button" data-theme="c">Button</a>

</pre>自定义新主题,为工具条添加类ui-bar-(a-z)并为内容添加类ui-body-(a-z)<pre class="html">
.ui-bar-f{
  color:green;
  background-color:yellow;
}
.ui-body-f{
  font-weight:bold;
  color:purple;
}

<div data-role="page">
  <div data-role="header" data-theme="f">
    <h1>应用 "f" 主题的标题</h1>
  </div>

  <div data-role="content" data-theme="f">
    <p>应用新的 "f" 主题的内容！</p>
  </div>
</div>

</pre><h3>jquery.mobile事件</h3><pre>
在jQuery Mobile中可以使用任何标准的jQuery事件
此外jQuery Mobile还提供若干种为移动浏览定制的事件：
触摸事件 - 当用户触摸屏幕时触发(敲击和滑动)
滚动事件 - 当上下滚动时触发
方向事件 - 当设备垂直或水平旋转时触发
页面事件 - 当页面被显示、隐藏、创建、加载以及/或卸载时触发

在jQuery中文档ready事件阻止jQuery代码在文档结束加载(is ready)前运行
在jQuery Mobile中使用pageinit事件,该事件在页面已初始化并完善样式设置后发生

$(document).ready(function(){
   // 此处是 jQuery 事件...
});

$(document).on("pageinit","#pageone",function(){
   // 此处是 jQuery 事件...
   // 第二个参数指向("#pageone") 指向页面的idpoints to the id of the page to specify the events for
});

【Touch事件在用户触摸屏幕(页面)时触发】
Touch事件同样适用于桌面电脑：点击鼠标

</pre>tap事件在用户敲击某个元素时触发<pre class="js">
$(document).on("pageinit","#pageone",function(){
  $("p").on("tap",function(){
    $(this).hide();
  });
});

</pre>taphold 事件在用户敲击某个元素并保持一秒时被触发<pre class="js">
$(document).on("pageinit","#pageone",function(){
  $("p").on("taphold",function(){
    $(this).hide();
  });
});

</pre><pre>
swipe 事件在用户在某个元素上水平滑动超过 30px 时被触发
swipeleft 事件在用户在某个元素上从左滑动超过 30px 时被触发
swiperight 事件在用户在某个元素上从右滑动超过 30px 时被触发

</pre><pre class="js">
$(document).on("pageinit","#pageone",function(){
  $("p").on("swipe",function(){
    $("span").text("Swipe detected!");
  });
});

</pre><pre>
【jQuery Mobile提供两种滚动事件：在滚动开始和当滚动结束】
scrollstart 事件在用户开始滚动页面时被触发
scrollstop 事件在用户停止滚动页面时被触发

iOS设备会在滚动事件发生时冻结DOM操作,这意味着当用户滚动时无法改变任何事物

</pre><pre class="js">
$(document).on("pageinit","#pageone",function(){
  $(document).on("scrollstart",function(){
    alert("开始滚动！");
  });
  $(document).on("scrollstop",function(){
  alert("结束滚动！");
  });
});

</pre><pre>
【orientationchange事件在用户垂直或水平旋转移动设备时被触发】

$(window).on("orientationchange", callback);
callback函数可以设置一个参数,即 event 对象,它会返回移动设备的方向："portrait" (设备被握持的方向是垂直的)或 "landscape" (设备被握持的方向是水平的)

如需使用orientationchange事件,请把它添加到window对象
由于orientationchange事件与window对象绑定,我们能够使用window.orientation属性来,例如设置不同样式以区分portrait和landscape视图
window.orientation属性对portrait视图返回0,对landscape视图返回90或-90

</pre><pre class="js">
$(document).on("pageinit",function(event){
  $(window).on("orientationchange",function(event){
    alert("方向已改变为：" + event.orientation);
  });
});

$(document).on("pageinit",function(event){
  $(window).on("orientationchange",function(){
    if(window.orientation == 0){
      $("p").text("方向已经变为portrait").css({"background-color":"yellow","font-size":"300%"});
    }else{
      $("p").text("方向已经变为landscape").css({"background-color":"pink","font-size":"200%"});
    }
  });
});

</pre><pre>
【页面事件】
在jQuery Mobile中与页面打交道的事件被分为四类：
Page Initialization - 在页面创建前,当页面创建时,以及在页面初始化之后
Page Load/Unload - 当外部页面加载时、卸载时或遭遇失败时
Page Transition - 在页面过渡之前和之后
Page Change - 当页面被更改,或遭遇失败时

Initialization事件:
当jQuery Mobile中的一张典型页面进行初始化时会经历三个阶段：
在页面创建前
页面创建
页面初始化

每个阶段触发的事件都可用于插入或操作代码

pagebeforecreate  当页面即将初始化并且在jQuery Mobile已开始增强页面之前,触发该事件
pagecreate	当页面已创建但增强完成之前,触发该事件
pageinit	当页面已初始化并且在jQuery Mobile已完成页面增强之后,触发该事件

</pre><pre class="js">
$(document).on("pagebeforecreate",function(){
  alert("触发pagebeforecreate事件 - 页面即将初始化。jQuery Mobile 仍未开始增强页面。");
});
$(document).on("pagecreate",function(){
  alert("触发pagecreate事件 - 已创建页面,但增强未完成。");
});
$(document).on("pageinit",function(){
  alert("触发pageinit事件 - 页面已初始化,DOM已加载,jQuery Mobile已完成页面增强。")
});

</pre><pre>
Load 事件
页面加载事件属于外部页面。
无论外部页面何时载入DOM将触发两个事件,第一个是pagebeforeload,第二个是pageload(成功)或pageloadfailed(失败)

pagebeforeload	在任何页面加载请求作出之前触发。
pageload	    在页面已成功加载并插入 DOM 后触发。
pageloadfailed	如果页面加载请求失败则触发该事件。默认地将显示"Error Loading Page"消息

</pre><pre class="js">
$(document).on("pageload",function(event,data){
  alert("触发 pageload 事件！\nURL: " + data.url);
});
$(document).on("pageloadfailed",function(event,data){
  alert("抱歉,被请求页面不存在。");
});

</pre><pre>
过渡事件
我们还可以在从一页过渡到下一页时使用事件。
页面过渡涉及两个页面：一张"来"的页面和一张"去"的页面 - 这些过渡使当前活动页面("来的"页面)到新页面("去的"页面的改变过程变得更加动感

pagebeforeshow	在"去的"页面触发,在过渡动画开始前。
pageshow	    在"去的"页面触发,在过渡动画完成后。
pagebeforehide	在"来的"页面触发,在过渡动画开始前。
pagehide	    在"来的"页面触发,在过渡动画完成后。

</pre><pre class="js">
$(document).on("pagebeforeshow","#pagetwo",function(){ // 当进入页面二时
  alert("页面二即将显示");
});
$(document).on("pageshow","#pagetwo",function(){ // 当进入页面二时
  alert("现在显示页面二");
});
$(document).on("pagebeforehide","#pagetwo",function(){ // 当离开页面二时
  alert("页面二即将隐藏");
});
$(document).on("pagehide","#pagetwo",function(){ // 当离开页面二时
  alert("现在隐藏页面二");
});

</pre><h3>jQuery CSS 类</h3><pre>
全局类
以下类可以在jQuery Mobile小工具中使用 (按钮,工具条,面板,表格,列表等。):
ui-corner-all	    为元素添加圆角
ui-shadow	        为元素添加阴影
ui-overlay-shadow	为元素添加多层阴影
ui-mini	            让元素变小

按钮类
除了全局类外可以向a或button元素添加以下类 (不是 input 按钮):
ui-btn	            添加在a元素上并以按钮形式展示
ui-btn-inline	    在同一行上显示按钮
ui-btn-icon-top	    定位图标在按钮文本之上
ui-btn-icon-right	定位图标在按钮文本的右边
ui-btn-icon-bottom	定位图标在按钮文本之下
ui-btn-icon-left	定位图标在按钮文本的左边
ui-btn-icon-notext	只显示图标
ui-btn-a|b	指定按钮演示,"a"是默认(灰色背景黑色文本样式),"b"修改颜色为黑色背景白色文本

图标类
所有可用图片的类用在a或button元素上
Class	图标描述	图标
ui-icon-action	    动作 (一般用于页面跳转切换)	action
ui-icon-alert	    三角形内的感叹号	alert
ui-icon-audio	    音响/音箱	audio
ui-icon-arrow-d-l	左下角箭头	arrow-d-l
ui-icon-arrow-d-r	右下角箭头	arrow-d-r
ui-icon-arrow-u-l	左上角箭头	arrow-u-l
ui-icon-arrow-u-r	右上角箭头	arrow-u-r
ui-icon-arrow-l	    左角箭头	arrow-l
ui-icon-arrow-r	    右角箭头	arrow-r
ui-icon-arrow-u	    向上箭头	arrow-u
ui-icon-arrow-d	    向下箭头	arrow-d
ui-icon-back	    返回	back
ui-icon-bars	    三条水平线,一般用于展示列表按钮图标	bars
ui-icon-bullets	    用于展示列表按钮图标	bullets
ui-icon-calendar	日历	calendar
ui-icon-camera	    相机	camera
ui-icon-carat-d	    向下滑动图标	carat-d
ui-icon-carat-l	    向左滑动图标	carat-l
ui-icon-carat-r	    向右滑动图标	carat-r
ui-icon-carat-u	    向上滑动图标	carat-u
ui-icon-check	    勾选	check
ui-icon-clock	    闹钟	clock
ui-icon-cloud	    云	cloud
ui-icon-comment	    评论 / 消息	comment
ui-icon-delete	    删除	delete
ui-icon-edit	    编辑 / 铅笔	edit
ui-icon-eye	        眼睛	eye
ui-icon-forbidden	禁用标识 sign	forbidden
ui-icon-forward	    撤销 - (返回上一步)	forward
ui-icon-gear	    齿轮,一般用于设置按钮图标	gear
ui-icon-grid	    网格	grid
ui-icon-heart	    心型,可用于文章收藏	heart
ui-icon-home	    主页	home
ui-icon-info	    信息	info
ui-icon-location	定位	location
ui-icon-lock	    锁	lock
ui-icon-mail	    邮件 / 信封	mail
ui-icon-minus	    减号	minus
ui-icon-navigation	导航	navigation
ui-icon-phone	    电话	phone
ui-icon-power	    开关 (On/off)	power
ui-icon-plus	    加号	plus
ui-icon-recycle	    循环 标识	recycle
ui-icon-refresh	    刷新	refresh
ui-icon-search	    搜索 / 放大镜	search
ui-icon-shop	    商店/购物袋	shop
ui-icon-star	    星号	star
ui-icon-tag	        标签	tag
ui-icon-user	    用户 / 人物	user
ui-icon-video	    视频 / 相机	camera1

主题类 Classes
ui-bar-(a-z)	指定栏目演示 - 头部,底部及其他栏目
ui-body-(a-z)	指定内容块的颜色 - 页面内容部分,列表视图,弹窗,侧栏,面板,加载,折叠
ui-btn-(a-z)	指定按钮颜色
ui-group-theme-(a-z)  定义了控制组的演示 listviews 和 collapsible 集合。
ui-overlay-(a-z)	  定义了页面背景颜色,包括对话框,弹窗和其他出现在最顶层的页面容器
ui-page-theme-(a-z)	  定义了页面演示

网格类
网格中的列是等宽的(合计是 100%),没有边框、背景、margin 或 padding。 这里有四种布局网格可供使用：
网格类	列	列宽	对应	实例
ui-grid-solo	1	100%	ui-block-a
ui-grid-a	2	50% / 50%	ui-block-a|b
ui-grid-b	3	33% / 33% / 33%	ui-block-a|b|c
ui-grid-c	4	25% / 25% / 25% / 25%	ui-block-a|b|c|d
ui-grid-d	5	20% / 20% / 20% / 20% / 20%	ui-block-a|b|c|d|e

</pre>
</div>

<div id="bootstrap">
<h2>bootstrap</h2><pre>
用Jquery的话,如果要做一个网站,PC端用jQuery-ui手机端用jQuery mobile,需要做两套网站
如果用bootstrap的话只需要一套就够了

适用场景
Bootstrap通常用于：展示网站的响应式布局开发,使得网站可以在不同设备上方便浏览;以及网站后台管理系统的前端CSS框架。
jQuery Mobile通常用于：期望接近移动APP体验的WebAPP,项目只运行在手机端,不用于电脑设备展示(虽然是可以展示的,但是效果不好)

总结
如果做跨设备响应式前端,选择Boostrap;如果仅作移动端,期望得到近似APP的WebAPP,使用jQuery Mobile

Bootstrap是最受欢迎的HTML、CSS和JS框架,用于开发响应式布局、移动设备优先的WEB项目

</pre><textarea cols="120" rows="30">
<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- 上述3个meta标签*必须*放在最前面,任何其他内容都*必须*跟随其后！ -->
    <title>Bootstrap 101 Template</title>
    <!-- Bootstrap -->
    <link href="https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css" rel="stylesheet">

    <!-- HTML5 shim 和 Respond.js 是为了让 IE8 支持 HTML5 元素和媒体查询(media queries)功能 -->
    <!-- 警告：通过 file:// 协议(就是直接将 html 页面拖拽到浏览器中)访问页面时 Respond.js 不起作用 -->

    <!--[if lt IE 9]>
      <script src="https://cdn.bootcss.com/html5shiv/3.7.3/html5shiv.min.js"></script>
      <script src="https://cdn.bootcss.com/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
  </head>
  <body>
    <h1>你好,世界！</h1>

    <!-- jQuery (Bootstrap 的所有 JavaScript 插件都依赖 jQuery,所以必须放在前边) -->
    <script src="https://cdn.bootcss.com/jquery/1.12.4/jquery.min.js"></script>
    <!-- 加载 Bootstrap 的所有 JavaScript 插件。你也可以根据需要只加载单个插件。 -->
    <script src="https://cdn.bootcss.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>
  </body>
</html>
</textarea>

</pre><h3>全局css样式</h3><pre>
Bootstrap 排版、链接样式设置了基本的全局样式。分别是：
为body元素设置 background-color: #fff;
使用 @font-family-base、@font-size-base 和 @line-height-base 变量作为排版的基本参数
为所有链接设置了基本颜色 @link-color ,并且当链接处于 :hover 状态时才添加下划线
这些样式都能在 scaffolding.less 文件中找到对应的源码。

Bootstrap 将全局 font-size 设置为 14px,line-height 设置为 1.428,这些属性直接赋予body元素和所有段落元素,另外p元素还被设置了等于1/2行高(10px)的底部外边距margin

为了增强跨浏览器表现的一致性使用了Normalize.css,这是一个CSS重置样式库

为页面内容和栅格系统包裹一个.container容器,由于padding等属性的原因,这两种容器类不能互相嵌套
.container 类用于固定宽度并支持响应式布局的容器。
.container-fluid 类用于100%宽度,占据全部视口viewport的容器

【 栅格系统 】
Bootstrap提供了一套响应式、移动设备优先的流式栅格系统,随着屏幕或视口viewport尺寸的增加,系统会自动分为最多12列。它包含了易于使用的预定义类,还有强大的mixin 用于生成更具语义的布局

栅格系统用于通过一系列的行row与列column组合来创建页面布局,内容就可放入这些创建好的布局中
一个.row内包含的列column大于12个,包含多余列元素将作为一个整体单元被另起一行排列

超小屏幕  手机 (< 768px)	       .col-xs-
小屏幕    平板 (≥768px)	           .col-sm-
中等屏幕  桌面显示器 (≥992px)      .col-md-
大屏幕    大桌面显示器 (≥1200px)   .col-lg-

列偏移
使用.col-md-offset-*类可以将列向右侧偏移。这些类实际是通过使用 * 选择器为当前元素增加了左侧的边距margin
例如.col-md-offset-4类将.col-md-4元素向右侧偏移了4个列column的宽度

嵌套列
为了使用内置的栅格系统将内容再次嵌套,可以通过添加一个新的.row元素和一系列.col-sm-*元素到已经存在的.col-sm-*元素内

列排序
通过使用 .col-md-push-* 和 .col-md-pull-* 类就可以很容易的改变列(column)的顺序

响应工具类
.visible-xs-*	仅超小屏幕可见
.visible-sm-*	仅小屏幕可见
.visible-md-*	仅中等屏幕可见
.visible-lg-*	仅大屏幕可见
.visible-print	打印机可见,浏览器隐藏
.hidden-xs	    仅超小屏幕隐藏
.hidden-sm	    仅小屏幕隐藏
.hidden-md	    仅中等屏幕隐藏
.hidden-lg      仅大屏幕隐藏
.hidden-print	打印机隐藏,浏览器可见

</pre><pre class="html">
/* 流式布局容器 */
<div class="container-fluid">
  <div class="row">
    <div class="col-md-6">.col-md-6</div>
    <div class="col-md-6">.col-md-6</div>
  </div>
  <div class="row">
    <div class="col-xs-12 col-md-8">.col-xs-12 .col-md-8</div>
    <div class="col-xs-6 col-md-4">.col-xs-6 .col-md-4</div>
  </div>
  <div class="row">
    <div class="col-xs-12 col-sm-6 col-md-8">.col-xs-12 .col-sm-6 .col-md-8</div>
    <div class="col-xs-6 col-md-4">.col-xs-6 .col-md-4</div>
  </div>
  <div class="row">
    <div class="col-xs-6 col-sm-4">.col-xs-6 .col-sm-4</div>
    <div class="col-xs-6 col-sm-4">.col-xs-6 .col-sm-4</div>
    <!-- Optional: clear the XS cols if their content doesn't match in height -->
    <div class="clearfix visible-xs-block"></div>
    <div class="col-xs-6 col-sm-4">.col-xs-6 .col-sm-4</div>
  </div>
  <div class="row">
    <div class="col-md-9 col-md-push-3">列排序,此列在后</div>
    <div class="col-md-3 col-md-pull-9">此列在后</div>
  </div>
</div>

</pre><pre>
【排版样式】
对齐类
text-left
text-center
text-right
text-justify
text-nowrap

情境文本颜色
text-muted
text-primary
text-success
text-info
text-warning
text-danger

情景背景色
bg-primary
bg-success
bg-info
bg-warning
bg-danger

改变大小写
text-lowercase
text-uppercase
text-capitalize

列表
list-unstyled  移除了默认的 list-style 样式和左侧外边距的一组元素
list-inline    内联列表,通过设置display: inline-block;并添加少量padding将所有元素放置于同一行
.dl-horizontal 可以让dl内的短语及其描述排在一行

表格
.table 类添加到任意table标签可以为其赋予基本的样式,少量的padding和水平方向的分隔线
.table-striped 类可以给tbody之内的每一行增加斑马条纹样式
.table-bordered 类为表格和其中的每个单元格增加边框
.table-hover 类可以让tbody中的每一行对鼠标悬停状态作出响应
.table-condensed 类可以让表格更加紧凑,单元格中的padding均会减半
.table-responsive 类嵌套.table元素可创建响应式表格,小屏幕设备上水平滚动,大屏幕水平滚动条消失

表格tr或者td
.active	    鼠标悬停在行或单元格上时所设置的颜色
.success	标识成功或积极的动作
.info	    标识普通的提示信息或动作
.warning	标识警告或需要用户注意
.danger	    标识危险或潜在的带来负面影响的动作

表单
.form-control 类的input、textarea、select元素都将被默认设置宽度属性为width: 100%;。 .form-group 类嵌套label元素和表单控件可以获得最好的排列
.form-inline 类的form元素表现为内联表单,内容左对齐并且表现为inline-block级别的控件。只适用于视口viewport至少在768px宽度时,视口宽度再小的话就会使表单折叠
.form-horizontal 类的form元素联合使用Bootstrap预置的栅格类,可以将label标签和控件组水平并排布局。这样做将改变.form-group的行为,使其表现为栅格系统中的行row,因此就无需再额外添加.row
.checkbox, .radio 类嵌套多选、单选框,.disabled 类嵌套表示不可选
.checkbox-inline 或 .radio-inline 类应用到一系列的多选框checkbox或单选框radio控件上,可以使这些控件排列在一行

.input-lg 类似的类可以为控件设置高度,通过 .col-lg-* 类似的类可以为控件设置宽度

静态控件
如果需要在表单中将一行纯文本和label元素放置于同一行,为p元素添加.form-control-static 类即可

为fieldset设置disabled属性,可以禁用fieldset中包含的所有控件

</pre><pre class="html">
<form>
  <div class="form-group">
    <label for="exampleInputEmail1">Email address</label>
    <input type="email" class="form-control" id="exampleInputEmail1" placeholder="Email">
  </div>
  <div class="form-group">
    <label for="exampleInputPassword1">Password</label>
    <input type="password" class="form-control" id="exampleInputPassword1" placeholder="Password">
  </div>
  <textarea class="form-control" rows="3"></textarea>
  <div class="form-group">
    <label for="exampleInputFile">File input</label>
    <input type="file" id="exampleInputFile">
    <p class="help-block">Example block-level help text here.</p>
  </div>
  <div class="checkbox">
    <label>
      <input type="checkbox"> Check me out
    </label>
  </div>
  <div class="checkbox disabled">
  <label>
    <input type="checkbox" value="" disabled>Option two is disabled
  </label>
  </div>
  <div class="radio">
  <label>
      <input type="radio" name="optionsRadios" id="optionsRadios1" value="option1" checked>
      Option one is this and that&mdash;be sure to include why it's great
  </label>
  </div>
  <div class="radio">
  <label>
      <input type="radio" name="optionsRadios" id="optionsRadios2" value="option2">
      Option two can be something else and selecting it will deselect option one
  </label>
  </div>
  <div class="radio disabled">
  <label>
      <input type="radio" name="optionsRadios" id="optionsRadios3" value="option3" disabled>
      Option three is disabled
  </label>
  </div>
  <select class="form-control">
    <option>1</option>
    <option>2</option>
    <option>3</option>
  </select>
  <button type="submit" class="btn btn-default">Submit</button>
</form>

/* 内联表单 */
<form class="form-inline">
  <div class="form-group">
    <label class="sr-only" for="inputAmount">Amount (in dollars)</label>
    <div class="input-group">
      <div class="input-group-addon">$</div>
      <input type="text" class="form-control" id="inputAmount" placeholder="Amount">
      <div class="input-group-addon">.00</div>
    </div>
  </div>
  <button type="submit" class="btn btn-primary">Transfer cash</button>
</form>

/* 水平排列的表单 */
<form class="form-horizontal">
  <div class="form-group">
    <label for="inputEmail3" class="col-sm-2 control-label">Email</label>
    <div class="col-sm-10">
      <input type="email" class="form-control" id="inputEmail3" placeholder="Email">
    </div>
  </div>
  <div class="form-group">
    <label for="inputPassword3" class="col-sm-2 control-label">Password</label>
    <div class="col-sm-10">
      <input type="password" class="form-control" id="inputPassword3" placeholder="Password">
    </div>
  </div>
  <div class="form-group">
    <div class="col-sm-offset-2 col-sm-10">
      <div class="checkbox">
        <label>
          <input type="checkbox"> Remember me
        </label>
      </div>
    </div>
  </div>
  <div class="form-group">
    <div class="col-sm-offset-2 col-sm-10">
      <button type="submit" class="btn btn-default">Sign in</button>
    </div>
  </div>
</form>

</pre><pre>
表单校验状态

Bootstrap 对表单控件的校验状态,如 error、warning 和 success 状态,都定义了样式。使用时,添加 .has-warning、.has-error 或 .has-success 类到这些控件的父元素即可。任何包含在此元素之内的 .control-label、.form-control 和 .help-block 元素都将接受这些校验状态的样式

还可以针对校验状态为输入框添加额外的图标。只需设置相应的 .has-feedback 类并添加正确的图标即可。
反馈图标feedback icon只能使用在文本输入框input class="form-control"元素上

</pre><pre class="html">
<div class="form-group has-success has-feedback">
  <label class="control-label" for="inputSuccess2">Input with success</label>
  <input type="text" class="form-control" id="inputSuccess2" aria-describedby="inputSuccess2Status">
  <span class="glyphicon glyphicon-ok form-control-feedback" aria-hidden="true"></span>
  <span id="inputSuccess2Status" class="sr-only">(success)</span>
</div>
<div class="form-group has-warning has-feedback">
  <label class="control-label" for="inputWarning2">Input with warning</label>
  <input type="text" class="form-control" id="inputWarning2" aria-describedby="inputWarning2Status">
  <span class="glyphicon glyphicon-warning-sign form-control-feedback" aria-hidden="true"></span>
  <span id="inputWarning2Status" class="sr-only">(warning)</span>
</div>
<div class="form-group has-error has-feedback">
  <label class="control-label" for="inputError2">Input with error</label>
  <input type="text" class="form-control" id="inputError2" aria-describedby="inputError2Status">
  <span class="glyphicon glyphicon-remove form-control-feedback" aria-hidden="true"></span>
  <span id="inputError2Status" class="sr-only">(error)</span>
</div>
<div class="form-group has-success has-feedback">
  <label class="control-label" for="inputGroupSuccess1">Input group with success</label>
  <div class="input-group">
    <span class="input-group-addon">@</span>
    <input type="text" class="form-control" id="inputGroupSuccess1" aria-describedby="inputGroupSuccess1Status">
  </div>
  <span class="glyphicon glyphicon-ok form-control-feedback" aria-hidden="true"></span>
  <span id="inputGroupSuccess1Status" class="sr-only">(success)</span>
</div>

</pre><pre>
按钮样式
.btn .btn-default 类为a、button或input元素添加按钮类button class
.btn-lg、.btn-sm 或 .btn-xs 就可以获得不同尺寸的按钮
.btn-block 类可以将其拉伸至父元素100%的宽度,而且按钮也变为了块级(block)元素
.active 类使按钮处于激活状态

</pre><pre class="html">
<a class="btn btn-default" href="#" role="button">Link</a>
<button class="btn btn-default" type="submit">Button</button>
<input class="btn btn-default" type="button" value="Input">
<input class="btn btn-default" type="submit" value="Submit">

<button type="button" class="btn btn-default">(默认样式)Default</button>
<button type="button" class="btn btn-primary">(首选项)Primary</button>
<button type="button" class="btn btn-success">(成功)Success</button>
<button type="button" class="btn btn-info">(一般信息)Info</button>
<button type="button" class="btn btn-warning">(警告)Warning</button>
<button type="button" class="btn btn-danger">(危险)Danger</button>
<button type="button" class="btn btn-link">(链接)Link</button>

</pre><pre class="html">
<button type="button" id="myButton" data-loading-text="Loading..." class="btn btn-primary" autocomplete="off">
  Loading state
</button>

// 点击按钮之后loading...禁用
$('#myButton').on('click', function () {
  var $btn = $(this).button('loading')
  // business logic...
  $btn.button('reset')
})

</pre><pre>
图片
.img-responsive 类可以让图片支持响应式布局,实质是为图片设置max-width: 100%;height: auto;display: block;属性,从而让图片在其父元素中更好的缩放
.center-block 类使.img-responsive类的图片水平居中
.img-rounded 类使图片显示圆角
.img-circle  类使图片显示为圆
.img-thumbnail 类使图片显示轮廓

</pre><pre class="html">
关闭按钮
<button type="button" class="close" aria-label="Close"><span aria-hidden="true">&times;</span></button>

三角符号
<span class="caret"></span>

快速浮动
<div class="pull-left">...</div>
<div class="pull-right">...</div>

让内容块居中,为任意元素设置display: block属性并通过margin属性让其中的内容居中
<div class="center-block">...</div>

通过为父元素添加 .clearfix 类可以很容易地清除浮动float
<div class="clearfix">...</div>

.show 和 .hidden 类可以强制任意元素显示或隐藏,对于屏幕阅读器也能起效
<div class="show">...</div>
<div class="hidden">...</div>

.sr-only 类可以对屏幕阅读器以外的设备隐藏内容。.sr-only 和 .sr-only-focusable 联合使用的话可以在元素有焦点的时候再次显示出来(例如,使用键盘导航的用户
<a class="sr-only sr-only-focusable" href="#content">Skip to main content</a>

</pre>


<h3>bootstrap组件</h3><pre>
【Glyphicons 字体图标】

</pre><pre class="html">
<span class="glyphicon glyphicon-search" aria-hidden="true"></span>

<button type="button" class="btn btn-default btn-lg">
  <span class="glyphicon glyphicon-star" aria-hidden="true"></span> Star
</button>

<div class="alert alert-danger" role="alert">
  <span class="glyphicon glyphicon-exclamation-sign" aria-hidden="true"></span>
  <span class="sr-only">Error:</span> Enter a valid email address
</div>

</pre><pre>
【　下拉菜单　】
将下拉菜单触发器和下拉菜单都包裹在 .dropdown 里
通过为下拉菜单的父元素设置 .dropup 类,可以让菜单向上弹出(默认是向下弹出的)
默认情况下下拉菜单自动沿着父元素的上沿和左侧被定位为 100% 宽度。 为 .dropdown-menu 添加 .dropdown-menu-right 类可以让菜单右对齐

</pre><pre class="html">
<div class="dropdown">
  <button class="btn btn-default dropdown-toggle" type="button" id="dropdownMenu1" data-toggle="dropdown" aria-haspopup="true" aria-expanded="true">
    Dropdown
    <span class="caret"></span>
  </button>
  <ul class="dropdown-menu" aria-labelledby="dropdownMenu1">
    <li class="dropdown-header">Dropdown header 标题</li>
    <li><a href="#">Action</a></li>
    <li class="disabled"><a href="#">禁用项</a></li>
    <li class="dropdown-header">Dropdown header 标题</li>
    <li><a href="#">Something else here</a></li>
    <li role="separator" class="divider"></li> <!-- 分割线 -->
    <li><a href="#">Separated link</a></li>
  </ul>
</div>

</pre><pre>
【按钮组】
把一组div.btn-group组合进一个div.btn-toolbar中就可以做成更复杂的组件
只要给.btn-group加上.btn-group-*类就省去为按钮组中的每个按钮都赋予尺寸类了,如果包含了多个按钮组时也适用
想要把下拉菜单混合到一系列按钮中,只须把 .btn-group 放入另一个 .btn-group 中
.btn-group-vertical让一组按钮垂直堆叠排列显示而不是水平排列

</pre><pre class="html">
<div class="btn-group" role="group" aria-label="...">
  <button type="button" class="btn btn-default">Left</button>
  <button type="button" class="btn btn-default">Middle</button>
  <button type="button" class="btn btn-default">Right</button>
</div>

按钮组嵌套
<div class="btn-group" role="group" aria-label="...">
  <button type="button" class="btn btn-default">1</button>
  <button type="button" class="btn btn-default">2</button>

  <div class="btn-group" role="group">
    <button type="button" class="btn btn-default dropdown-toggle" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
      Dropdown
      <span class="caret"></span>
    </button>
    <ul class="dropdown-menu">
      <li><a href="#">Dropdown link</a></li>
      <li><a href="#">Dropdown link</a></li>
    </ul>
  </div>
</div>

</pre><pre>
【导航】
.nav-justified 类可以很容易的让标签页或胶囊式标签呈现出同等宽度,实现两端对齐
将导航条内放置品牌标志的地方替换为img元素即可展示自己的品牌图标
添加 .navbar-fixed-top 类可以让导航条固定在顶部,还可包含一个 .container 或 .container-fluid 容器,从而让导航条居中,并在两侧添加内补(padding)
添加 .navbar-fixed-bottom 类可以让导航条固定在底部,并且还可以包含一个 .container 或 .container-fluid 容器,从而让导航条居中,并在两侧添加内补(padding)
通过添加 .navbar-static-top 类即可创建一个与页面等宽度的导航条,它会随着页面向下滚动而消失。还可以包含一个 .container 或 .container-fluid 容器,用于将导航条居中对齐并在两侧添加内补(padding)
通过添加 .navbar-inverse 类可以改变导航条的外观

</pre><pre class="html">
标签页导航
<ul class="nav nav-tabs">
  <li role="presentation" class="active"><a href="#">Home</a></li>
  <li role="presentation"><a href="#">Profile</a></li>
  <li role="presentation"><a href="#">Messages</a></li>
</ul>

胶囊式标签页导航,添加 .nav-stacked 类实现垂直方向堆叠排列
<ul class="nav nav-pills">
  <li role="presentation" class="active"><a href="#">Home</a></li>
  <li role="presentation"><a href="#">Profile</a></li>
  <li role="presentation"><a href="#">Messages</a></li>
</ul>

带下拉菜单的胶囊式标签页
<ul class="nav nav-pills">
  ...
  <li role="presentation" class="dropdown">
    <a class="dropdown-toggle" data-toggle="dropdown" href="#" role="button" aria-haspopup="true" aria-expanded="false">
      Dropdown <span class="caret"></span>
    </a>
    <ul class="dropdown-menu">
      ...
    </ul>
  </li>
  ...
</ul>

导航条
<nav class="navbar navbar-default">
  <div class="container-fluid">
    <!-- Brand and toggle get grouped for better mobile display -->
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="#">Brand</a>
    </div>

    <!-- Collect the nav links, forms, and other content for toggling -->
    <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
      <ul class="nav navbar-nav">
        <li class="active"><a href="#">Link <span class="sr-only">(current)</span></a></li>
        <li><a href="#">Link</a></li>
        <li class="dropdown">
          <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Dropdown <span class="caret"></span></a>
          <ul class="dropdown-menu">
            <li><a href="#">Action</a></li>
            <li><a href="#">Another action</a></li>
            <li><a href="#">Something else here</a></li>
            <li role="separator" class="divider"></li>
            <li><a href="#">Separated link</a></li>
            <li role="separator" class="divider"></li>
            <li><a href="#">One more separated link</a></li>
          </ul>
        </li>
      </ul>
      <form class="navbar-form navbar-left">
        <div class="form-group">
          <input type="text" class="form-control" placeholder="Search">
        </div>
        <button type="submit" class="btn btn-default">Submit</button>
      </form>
      <ul class="nav navbar-nav navbar-right">
        <li><a href="#">Link</a></li>
        <li class="dropdown">
          <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Dropdown <span class="caret"></span></a>
          <ul class="dropdown-menu">
            <li><a href="#">Action</a></li>
            <li><a href="#">Another action</a></li>
            <li><a href="#">Something else here</a></li>
            <li role="separator" class="divider"></li>
            <li><a href="#">Separated link</a></li>
          </ul>
        </li>
      </ul>
    </div><!-- /.navbar-collapse -->
  </div><!-- /.container-fluid -->
</nav>

</pre><pre>
【路径导航】
在一个带有层次的导航结构中标明当前页面的位置。
各路径间的分隔符已经自动通过 CSS 的 :before 和 content 属性添加了

</pre><pre class="html">
<ol class="breadcrumb">
  <li><a href="#">Home</a></li>
  <li><a href="#">Library</a></li>
  <li class="active">Data</li>
</ol>

</pre><pre>
【分页】

</pre><pre class="html">
<nav aria-label="Page navigation">
  <ul class="pagination">
    <li>
      <a href="#" aria-label="Previous">
        <span aria-hidden="true">&laquo;</span>
      </a>
    </li>
    <li><a href="#">1</a></li>
    <li><a href="#">2</a></li>
    <li><a href="#">3</a></li>
    <li><a href="#">4</a></li>
    <li><a href="#">5</a></li>
    <li>
      <a href="#" aria-label="Next">
        <span aria-hidden="true">&raquo;</span>
      </a>
    </li>
  </ul>
</nav>

<nav aria-label="Page navigation">
  <ul class="pagination">
    <li class="disabled">
      <span>
        <span aria-hidden="true">&laquo;</span>
      </span>
    </li>
    <li class="active">
      <span>1 <span class="sr-only">(current)</span></span>
    </li>
    ...
  </ul>
</nav>

</pre><pre>
【标签】

</pre><pre class="html">
<span class="label label-default">Default</span>
<span class="label label-primary">Primary</span>
<span class="label label-success">Success</span>
<span class="label label-info">Info</span>
<span class="label label-warning">Warning</span>
<span class="label label-danger">Danger</span>

</pre><pre>
【徽章】

</pre><pre class="html">
<a href="#">Inbox <span class="badge">42</span></a>

<button class="btn btn-primary" type="button">
  Messages <span class="badge">4</span>
</button>

<ul class="nav nav-pills" role="tablist">
  <li role="presentation" class="active"><a href="#">Home <span class="badge">42</span></a></li>
  <li role="presentation"><a href="#">Profile</a></li>
  <li role="presentation"><a href="#">Messages <span class="badge">3</span></a></li>
</ul>

</pre><pre>
【巨幕】

</pre><pre class="html">
<div class="jumbotron">
  <h1>Hello, world!</h1>
  <p>...</p>
  <p><a class="btn btn-primary btn-lg" href="#" role="button">Learn more</a></p>
</div>

</pre><pre>
【缩略图】

</pre><pre class="html">
<div class="row">
  <div class="col-sm-6 col-md-4">
    <div class="thumbnail">
      <img src="" alt="...">
      <div class="caption">
        <h3>Thumbnail label</h3>
        <p>...</p>
        <p><a href="#" class="btn btn-primary" role="button">Button</a> <a href="#" class="btn btn-default" role="button">Button</a></p>
      </div>
    </div>
  </div>
</div>

</pre><pre>
【警告框】

</pre><pre class="html">
<div class="alert alert-warning alert-dismissible" role="alert">
  <button type="button" class="close" data-dismiss="alert" aria-label="Close"><span aria-hidden="true">&times;</span></button>
  <strong>Warning!</strong> Better check yourself, you're not looking too good.
</div>

</pre><pre>
【进度条】

</pre><pre class="html">
<div class="progress">
  <div class="progress-bar" role="progressbar" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100" style="min-width: 2em;">
    0%
  </div>
</div>
<div class="progress">
  <div class="progress-bar" role="progressbar" aria-valuenow="2" aria-valuemin="0" aria-valuemax="100" style="min-width: 2em; width: 2%;">
    2%
  </div>
</div>

情景效果
<div class="progress">
  <div class="progress-bar progress-bar-success" role="progressbar" aria-valuenow="40" aria-valuemin="0" aria-valuemax="100" style="width: 40%">
    <span class="sr-only">40% Complete (success)</span>
  </div>
</div>
<div class="progress">
  <div class="progress-bar progress-bar-info" role="progressbar" aria-valuenow="20" aria-valuemin="0" aria-valuemax="100" style="width: 20%">
    <span class="sr-only">20% Complete</span>
  </div>
</div>
<div class="progress">
  <div class="progress-bar progress-bar-warning" role="progressbar" aria-valuenow="60" aria-valuemin="0" aria-valuemax="100" style="width: 60%">
    <span class="sr-only">60% Complete (warning)</span>
  </div>
</div>
<div class="progress">
  <div class="progress-bar progress-bar-danger" role="progressbar" aria-valuenow="80" aria-valuemin="0" aria-valuemax="100" style="width: 80%">
    <span class="sr-only">80% Complete (danger)</span>
  </div>
</div>

条纹效果
<div class="progress">
  <div class="progress-bar progress-bar-success progress-bar-striped" role="progressbar" aria-valuenow="40" aria-valuemin="0" aria-valuemax="100" style="width: 40%">
    <span class="sr-only">40% Complete (success)</span>
  </div>
</div>
<div class="progress">
  <div class="progress-bar progress-bar-info progress-bar-striped" role="progressbar" aria-valuenow="20" aria-valuemin="0" aria-valuemax="100" style="width: 20%">
    <span class="sr-only">20% Complete</span>
  </div>
</div>
<div class="progress">
  <div class="progress-bar progress-bar-warning progress-bar-striped" role="progressbar" aria-valuenow="60" aria-valuemin="0" aria-valuemax="100" style="width: 60%">
    <span class="sr-only">60% Complete (warning)</span>
  </div>
</div>
<div class="progress">
  <div class="progress-bar progress-bar-danger progress-bar-striped" role="progressbar" aria-valuenow="80" aria-valuemin="0" aria-valuemax="100" style="width: 80%">
    <span class="sr-only">80% Complete (danger)</span>
  </div>
</div>

动画效果
<div class="progress">
  <div class="progress-bar progress-bar-striped active" role="progressbar" aria-valuenow="45" aria-valuemin="0" aria-valuemax="100" style="width: 45%">
    <span class="sr-only">45% Complete</span>
  </div>
</div>

</pre><pre>
【列表组】

</pre><pre class="html">
<ul class="list-group">
  <li class="list-group-item">
    <span class="badge">14</span>Cras justo odio
  </li>
  <li class="list-group-item">
    <span class="badge">14</span>Cras justo odio
  </li>
</ul>

<div class="list-group">
  <a href="#" class="list-group-item active">Cras justo odio</a>
  <a href="#" class="list-group-item">Dapibus ac facilisis in</a>
  <a href="#" class="list-group-item">Morbi leo risus</a>
  <a href="#" class="list-group-item">Porta ac consectetur ac</a>
  <a href="#" class="list-group-item">Vestibulum at eros</a>
</div>

</pre><pre>
【面板】

</pre><pre class="html">
<div class="panel panel-default">
  <div class="panel-heading">
    <h3 class="panel-title">Panel title</h3>
  </div>
  <div class="panel-body">
    Panel content
  </div>
</div>

<div class="panel panel-default">
  <!-- Default panel contents -->
  <div class="panel-heading">Panel heading</div>
  <div class="panel-body">
    <p>...</p>
  </div>

  <!-- List group -->
  <ul class="list-group">
    <li class="list-group-item">Cras justo odio</li>
    <li class="list-group-item">Dapibus ac facilisis in</li>
    <li class="list-group-item">Morbi leo risus</li>
    <li class="list-group-item">Porta ac consectetur ac</li>
    <li class="list-group-item">Vestibulum at eros</li>
  </ul>
</div>

</pre><pre>
【模态框】
模态框提供了两个可选尺寸,通过为 .modal-dialog增加一个样式调整类实现
modal-lg
modal-sm

</pre><pre class="html">
<!-- Button trigger modal -->
<button type="button" class="btn btn-primary btn-lg" data-toggle="modal" data-target="#myModal">
  Launch demo modal
</button>

<!-- Modal -->
<div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel">
  <div class="modal-dialog" role="document">
    <div class="modal-content">
      <div class="modal-header">
        <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
        <h4 class="modal-title" id="myModalLabel">Modal title</h4>
      </div>
      <div class="modal-body">
        ...
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-default" data-dismiss="modal">Close</button>
        <button type="button" class="btn btn-primary">Save changes</button>
      </div>
    </div>
  </div>
</div>

</pre><pre>
【Carousel】

</pre><pre class="html">
<div id="carousel-example-generic" class="carousel slide" data-ride="carousel">
  <!-- Indicators -->
  <ol class="carousel-indicators">
    <li data-target="#carousel-example-generic" data-slide-to="0" class="active"></li>
    <li data-target="#carousel-example-generic" data-slide-to="1"></li>
    <li data-target="#carousel-example-generic" data-slide-to="2"></li>
  </ol>

  <!-- Wrapper for slides -->
  <div class="carousel-inner" role="listbox">
    <div class="item active">
      <img src="" alt="...">
      <div class="carousel-caption">
        ...
      </div>
    </div>
    <div class="item">
      <img src="" alt="...">
      <div class="carousel-caption">
        ...
      </div>
    </div>
    ...
  </div>

  <!-- Controls -->
  <a class="left carousel-control" href="#carousel-example-generic" role="button" data-slide="prev">
    <span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>
    <span class="sr-only">Previous</span>
  </a>
  <a class="right carousel-control" href="#carousel-example-generic" role="button" data-slide="next">
    <span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span>
    <span class="sr-only">Next</span>
  </a>
</div>

</pre><pre>
【tooltips】

</pre><pre class="html">
<button type="button" class="btn btn-default" data-toggle="tooltip" data-placement="left" title="Tooltip on left">Tooltip on left</button>

<button type="button" class="btn btn-default" data-toggle="tooltip" data-placement="top" title="Tooltip on top">Tooltip on top</button>

<button type="button" class="btn btn-default" data-toggle="tooltip" data-placement="bottom" title="Tooltip on bottom">Tooltip on bottom</button>

<button type="button" class="btn btn-default" data-toggle="tooltip" data-placement="right" title="Tooltip on right">Tooltip on right</button>

</pre><pre>
【弹出框】

</pre><pre class="html">
<a tabindex="0" class="btn btn-lg btn-danger" role="button" data-toggle="popover" data-trigger="focus" title="Dismissible popover" data-content="And here's some amazing content. It's very engaging. Right?">可消失的弹出框</a>

</pre><pre>
【collapse】
</pre><pre class="html">
<a class="btn btn-primary" role="button" data-toggle="collapse" href="#collapseExample" aria-expanded="false" aria-controls="collapseExample">
  Link with href
</a>
<button class="btn btn-primary" type="button" data-toggle="collapse" data-target="#collapseExample" aria-expanded="false" aria-controls="collapseExample">
  Button with data-target
</button>
<div class="collapse" id="collapseExample">
  <div class="well">
    ...
  </div>
</div>


</pre>
</div>

</main>
<ol>
  <li><a href="#top">顶部</a></li>
  <li><a href="#tags">标签集</a></li>
  <li><a href="#marquee">marquee文字滚动</a></li>
  <li><a href="#a">a超链接</a></li>
  <li><a href="#img">img-table</a></li>
  <li><a href="#list">列表</a></li>
  <li><a href="#div">块级元素</a></li>
  <li><a href="#head">头部信息</a></li>
  <li><a href="#form">form表单</a></li>
  <li><a href="#object">多媒体</a></li>
  <li><a href="#frame">框架</a></li>
  <li><a href="#data">data属性</a></li>
  <li><a href="#templatetag">template标签</a></li>
  <li><a href="#progress">progress标签</a></li>
  <li><a href="#notifications" title="桌面通知">notification</a></li>
  <li><a href="#drage">html5拖拽</a></li>
  <li>
    <a href="#file">文件对象上传 ▼</a>
    <ul>
      <li><a href="#base64">base64</a></li>
      <li><a href="#Blob">Blob</a></li>
      <li><a href="#FileList">FileList</a></li>
      <li><a href="#File">File</a></li>
      <li><a href="#ObjectURl">ObjectURl</a></li>
      <li><a href="#DragAPI">DragAPI</a></li>
      <li><a href="#FileReader">FileReader</a></li>
    </ul>
  </li>
  <li><a href="#storage">storage indexdb</a></li>
  <li><a href="#cache">html5 cache</a></li>
  <li><a href="#workers">html5 workers</a></li>
  <li><a href="#Server-Sent">html5 sever-sent</a></li>
  <li><a href="#404">404</a></li>
  <li><a href="#load">加载渲染优化</a></li>
  <li><a href="#website_cache">website cache</a></li>
  <li><a href="#mobile">mobile</a></li>
  <li><a href="#jqueryMobile">jqueryMobile</a></li>
  <li><a href="#bootstrap">bootstrap</a></li>
</ol>

<script src="vendors/jquery-3.3.1.min.js"></script>
<script src="vendors/public.js"></script>
<script src="vendors/SyntaxHighlighter/shCore.js"></script>
<script>
  // 代码高亮
  $('pre[class=html]').addClass('brush:html;toolbar:false');
  $('pre[class=js]').addClass('brush:js;toolbar:false');
  $('pre[class=php]').addClass('brush:php;toolbar:false');
  SyntaxHighlighter.all();
</script>
</body>
</html>
