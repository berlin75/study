<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>dux</title>
<link rel="stylesheet" href="vendors/public.css">
</head>
<body>
<h1><a name="top">dux</a></h1>

<main>
<pre>
项目描述
1) 此项目为一个前后台分离的招聘的SPA,包括前端应用和后端应用
2) 包括用户注册/登录,大神/老板列表,实时聊天等模块
3) 前端: 使用React全家桶+ES6+webpack等技术
4) 后端: 使用Node+express+mongodb+socketIO等技术
5) 采用模块化、组件化、工程化的模式开发

技术选型
前台数据展现/交互/组件化 react + react-router-dom + redux + antd-mobile (react全家桶/技术栈)
后台项目 node + express + mongodb + mongoose + socket.io
前后台交互 1、ajax请求(axios, async/await) 2、测试API接口(postman)
模块化 ES6 babel
项目构建/工程化 webpack + react-create-app + eslint
其他相关库 blueimp-md5 + js-cookie + rc-queue-anim

前端路由
注册(register.jsx) /register
登录(login.jsx) /login
主界面(main.jsx) 
  - 老板主界面(laoban.jsx) /laoban
  - 大神主界面(dashen.jsx) /dashen
  - 消息列表界面(message.jsx) /message
  - 个人中心界面(personal.jsx) /personal
  - 老板信息完善界面(laoban-info.jsx) /laobaninfo
  - 大神信息完善界面(dashen-info.jsx) /dasheninfo
  - 聊天界面(chat.jsx) /chat/:userid

API接口(前后台交互API接口)
接口文档: url + method + params + reesponse content_type
测试接口、对接口、调接口、联调
前后台分离: 后台ejs模板引擎
mock(模拟)数据

编码测试 npm start
打包发布 npm run build

前后端分离时域名相同端口号(lcoalhost:3000 -> localhost:4000)不同会产生浏览器的跨域请求
配置ajax请求的代理：package.json,proxy选项支持HTTP,HTTPS以及WebSocket连接
"proxy": "http://localhost:4000"  # 自动将"http://localhost:3000"请求转发到"http://localhost:4000"的服务器
没有遇到CORS问题,因为在浏览器眼里还是将请求发送到"http://localhost:3000",并不知道creat-react-app已经将请求转发到了"http://localhost:4000"这个会触发浏览器CORS安全策略的其他Origin
proxy字段可以与create-react-app的react-scripts结合使用:Proxying API Requests in Development,react-scripts应该是基于HTTP_PROXY环境变量做了一些封装

</pre><textarea>
// 配置多个代理需要在定义几个入口
{
  // ...
  "proxy": {
    // Matches any request starting with /api
    "/api": {
      "target": "http://0.0.0.89:7300",
      "ws": true
    },
    // Matches any request starting with /foo
    "/foo": {
      "target": "http://0.0.11.22:8848",
      "ws": true,
      "pathRewrite": {
        "^/foo": "/foo/beta"
      }
    },
    // Matches /bar/abc.html but not /bar/sub/def.html
    "/bar/[^/]*[.]html": {
      "target": "http://0.0.11.22:8848",
      // ...
    },
    // Matches /baz/abc.html and /baz/sub/def.html
    "/baz/.*/.*[.]html": {
      "target": "http://0.0.11.22:8848",
      // ...
    }
  }
  // ...
}

</textarea>
</pre>

<div id="taro">
<h2>taro</h2><pre>
< ShopIcon name='104' style={{color: '#536DFE',fontSize: Taro.pxTransform(48)}} />

< View className={['integral-exchange__foot', !!stock ? 'integral-exchange__foot--enable' : 'integral-exchange__foot--disable']} />
    
< Text numberOfLines={2} className='integral-exchange__exchange-popup__body__middle__title number-of-lines--2' style={{'-webkit-box-orient': 'vertical'}}>
  超长字符串自动省略后面字符串显示省略号
< /Text>

webpack打包
/*! autoprefixer: off */
-webkit-box-orient: vertical;
/* autoprefixer: on */

/*! autoprefixer: ignore next */
-webkit-box-orient: vertical;

import nervLogo from './nerv_logo.png'
< Image mode='aspectFill' src={nervLogo} />
< Image mode='aspectFill' src={require('../../static/images/exchange1-1008.png')} className='integral-exchange__head__img' />
< Image mode='aspectFill' className='page-personal__name__img' src='https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1583821630037&di=f624acc1ac353d354f6a34104a25495c&imgtype=0&src=http%3A%2F%2Fimage.biaobaiju.com%2Fuploads%2F20181111%2F20%2F1541938896-tJBPCuMWgY.jpg' />
< Image style='width: 300px;height: 300px;' src='https://camo.githubusercontent.com/3e1b76e514b895760055987f164ce6c95935a3aa/687474703a2f2f73746f726167652e333630627579696d672e636f6d2f6d74642f686f6d652f6c6f676f2d3278313531333833373932363730372e706e67' />

mode有13种模式,其中4种缩放模式和9种裁剪模式
mode: scaleToFill：不保持纵横比缩放图片,使图片完全适应
mode: aspectFit：保持纵横比缩放图片,使图片的长边能完全显示出来,可以将图片完整的显示出来,但有部分空白
mode: aspectFill：保持纵横比缩放图片,只保证图片的短边能完全显示出来,长边可能会被隐藏
mode: widthFix：宽度不变,高度自动变化,保持原图宽高比不变
mode: top：不缩放图片,只显示图片的顶部区域
mode: bottom：不缩放图片,只显示图片的底部区域
mode: center：不缩放图片,只显示图片的中间区域
mode: left：不缩放图片,只显示图片的左边区域
mode: right：不缩放图片,只显示图片的右边边区域
mode: top left：不缩放图片,只显示图片的左上边区域
mode: top right：不缩放图片,只显示图片的右上边区域
mode: bottom left：不缩放图片,只显示图片的左下边区域
mode: bottom right：不缩放图片,只显示图片的右下边区域

</pre><textarea>
input(name, e) {
  this.setState({[name]: e.detail.value.trim() }, () => {
    let { phone, password } = this.state
    if(phone.length > 0 && password.length > 0){
      this.setState({btnEnable: !0 })
    }
  })
}

tologin() {
  const phoneReg = /^(?:(?:\+|00)86)?1[3-9]\d{9}$/  // 13,14,15,16,17,18,19开头
  const passwordReg = /^.{6,}$/
  const { phone, password, btnEnable } = this.state
  if(!btnEnable){
    toast('请输入手机号和密码')
    return
  }
  if(!phoneReg.test(phone)){
    toast('请输入正确的手机号')
    return
  }
  if(!passwordReg.test(password)){
    toast('请输入正确的密码')
    return
  }

  // request({
  //   url: 'member/Login/index',
  //   method: 'POST',
  //   data: { phone, password }
  // }).then(res => {
  //   if (res.data.code == 200) {
  //     let userInfo = res.data.result
  //     userInfo['expired'] = (new Date()) * 1 + 259200000
  //     userInfo['data'] = userInfo['data'] || {}
  //     Taro.setStorage({key: 'userInfo', data: userInfo }).catch(err => console.error(err))
  //     nav('back:2')
  //   } else {
  //     Taro.showToast({title: res.data.message || '服务器错误 登录失败', icon: 'none'})
  //   }
  // }).catch(err => {
  //   console.error(err)
  //   toast(err.message || '网络或服务器错误 登录失败')
  // })
  nav('/main/index/index')
}

<View className='auth-login__form'>
  <View className='auth-login__form__item'>
    <ShopIcon name='shoujihao' />
    <Input className='auth-login__form__input' placeholder='请输入手机号' type='number' onInput={this.input.bind(this, 'phone')} />
  </View>
  <View className='auth-login__form__item'>
    <ShopIcon name='mima' />
    <Input className='auth-login__form__input' placeholder='请输入密码' onInput={this.input.bind(this, 'password')} password />
  </View>
  <Text className='auth-login__form__toReset' onClick={() => nav('/main/auth/reset')}>忘记密码?</Text>
  <Text className={['auth-login__form__btn', this.state.btnEnable ? 'auth-login__form__btn--enable' : 'auth-login__form__btn--disable']} onClick={this.tologin.bind(this)}
  >登录</Text>
</View>

</textarea>保存图片<textarea>
async save(url) {
  try {
    await Taro.authorize({ scope: "scope.writePhotosAlbum" })
    const { tempFilePath } = await Taro.downloadFile({ url })
    await Taro.saveImageToPhotosAlbum({filePath: tempFilePath}) // 二维码图片文件路径，可以是临时文件路径或永久文件路径 (本地路径) ，不支持网络路径
    await Taro.showModal({ title: '系统提示', content: '图片保存成功', showCancel: false, })
  } catch (error) {
    if(error.errMsg == 'authorize:fail auth deny'){
      let result = await Taro.showModal({ title: '授权失败', content: '请先授权，再保存此图片。' })
      console.log(result)
      if(result.confirm){
        let res = await Taro.openSetting()  //进入小程序授权设置页面
        if(res.authSetting['scope.writePhotosAlbum']){  //用户打开了保存图片授权开关
          this.save(url)
        }
      }
    }else if(error.errMsg == "saveImageToPhotosAlbum:fail auth deny"){
      Taro.showToast({ title: '保存失败,请稍后重试', icon: 'none' })
    }else {
      Taro.showToast({ title: "下载失败,请稍后重试", icon: "none" })
    }
  }
}

async savePic(url = ''){
  try {
    await Taro.authorize({ scope: "scope.writePhotosAlbum" })
    const { tempFilePath } = await Taro.downloadFile({ url })
    await Taro.saveImageToPhotosAlbum({ filePath: tempFilePath })
    Taro.showToast({ title: '保存成功', icon: 'none' })
  } catch (err) {
    Taro.showToast({ title: '保存失败', icon: 'none' })
  }
}

</textarea>
</div>

<div id="react">
<h2>react</h2><pre>
React起源于Facebook的内部项目,于2013年开源
React是一个声明式,高效高性能且灵活的用于构建用户界面UI的js库,代码逻辑非常简单,很多人认为React是MVC中的V

React特点
1.声明式设计 −React采用声明范式,可轻松描述应用。
2.高效 −React通过对DOM的模拟,最大限度地减少与DOM的交互。
3.灵活 −React可以与已知的库或框架很好地配合。
4.JSX − JSX是js语法的扩展,React开发不一定使用JSX,但建议使用它。
5.组件 − 通过React构建组件,使得代码更加容易得到复用,能够很好的应用在大项目的开发中。
6.单向响应的数据流 − React实现了单向响应的数据流,从而减少了重复代码,这也是它为什么比传统数据绑定更简单。

React可直接下载使用,下载包中也提供了很多学习的实例。也可以直接使用Staticfile CDN的React CDN库
src="https://cdn.staticfile.org/react/16.4.0/umd/react.development.js" // React的核心库
src="https://cdn.staticfile.org/react-dom/16.4.0/umd/react-dom.development.js"  // 提供与DOM相关的功能
src="https://cdn.staticfile.org/babel-standalone/6.26.0/babel.min.js" // 生产环境中不建议使用
官方提供的CDN地址：
src="https://unpkg.com/react@16/umd/react.development.js"
src="https://unpkg.com/react-dom@16/umd/react-dom.development.js"
src="https://unpkg.com/babel-standalone@6.15.0/babel.min.js" // 生产环境中不建议使用
Babel内嵌了对JSX的支持,在浏览器中使用Babel编译JSX效率非常低,Babel可以将ES6代码转为ES5代码,这样就能在不支持ES6浏览器上执行React代码

通过npm使用React
建议在React中使用CommonJS模块系统,比如browserify或webpack

</textarea><textarea>
<div id="container"></div>

<script type="text/babel">
class ProductCategoryRow extends React.Component {
  render() {
    const {category} = this.props
    return (<tr><th colSpan="2">{category}</th></tr>);
  }
}

class ProductRow extends React.Component {
  render() {
    const {product} = this.props;
    const name = product.stocked ? product.name : <span style={{color: 'red'}}>{product.name}</span>;

    return (
      <tr>
        <td>{name}</td>
        <td>{product.price}</td>
      </tr>
    );
  }
}

class ProductTable extends React.Component {
  render() {
    const filterText = this.props.filterText;
    const inStockOnly = this.props.inStockOnly;

    const rows = [];
    let lastCategory = null;

    this.props.products.forEach((product) => {
      if (product.name.indexOf(filterText) === -1) return;
      if (inStockOnly && !product.stocked) return;
      if (product.category !== lastCategory) rows.push(<ProductCategoryRow category={product.category} key={product.category} />);
      rows.push(<ProductRow product={product} key={product.name} />);
      lastCategory = product.category;
    });

    return (<table><thead><tr><th>Name</th><th>Price</th></tr></thead><tbody>{rows}</tbody></table>);
  }
}

class SearchBar extends React.Component {
  constructor(props) {
    super(props);
    this.handleFilterTextChange = this.handleFilterTextChange.bind(this);
    this.handleInStockChange = this.handleInStockChange.bind(this);
  }
  
  handleFilterTextChange(e) {
    this.props.onFilterTextChange(e.target.value);
  }
  
  handleInStockChange(e) {
    this.props.onInStockChange(e.target.checked);
  }
  
  render() {
    return (
      <form>
        <input type="text" placeholder="Search..." value={this.props.filterText} onChange={this.handleFilterTextChange} />
        <p>
          <input type="checkbox" checked={this.props.inStockOnly} onChange={this.handleInStockChange} />
          {' '}
          Only show products in stock
        </p>
      </form>
    );
  }
}

class FilterableProductTable extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      filterText: '',
      inStockOnly: false
    };
    
    this.handleFilterTextChange = this.handleFilterTextChange.bind(this);
    this.handleInStockChange = this.handleInStockChange.bind(this);
  }

  handleFilterTextChange(filterText) {
    this.setState({filterText: filterText});
  }
  
  handleInStockChange(inStockOnly) {
    this.setState({inStockOnly: inStockOnly})
  }

  render() {
    return (
      <div>
        <SearchBar
          filterText={this.state.filterText}
          inStockOnly={this.state.inStockOnly}
          onFilterTextChange={this.handleFilterTextChange}
          onInStockChange={this.handleInStockChange}
        />
        <ProductTable
          products={this.props.products}
          filterText={this.state.filterText}
          inStockOnly={this.state.inStockOnly}
        />
      </div>
    );
  }
}

const PRODUCTS = [
  {category: 'Sporting Goods', price: '$49.99', stocked: true, name: 'Football'},
  {category: 'Sporting Goods', price: '$9.99', stocked: true, name: 'Baseball'},
  {category: 'Sporting Goods', price: '$29.99', stocked: false, name: 'Basketball'},
  {category: 'Electronics', price: '$99.99', stocked: true, name: 'iPod Touch'},
  {category: 'Electronics', price: '$399.99', stocked: false, name: 'iPhone 5'},
  {category: 'Electronics', price: '$199.99', stocked: true, name: 'Nexus 7'}
];

ReactDOM.render(
  <FilterableProductTable products={PRODUCTS} />,
  document.getElementById('container')
);

</script>

</textarea>Ajax 组件的数据来源 把一个Promise对象传入组件<textarea>
<script src="https://cdn.staticfile.org/react/16.8.0/umd/react.development.js"></script>
<script src="https://cdn.staticfile.org/react-dom/16.8.0/umd/react-dom.development.js"></script>
<script src="https://cdn.staticfile.org/babel-standalone/6.26.0/babel.min.js"></script>
<script src="../vendors/jquery-3.3.1.min.js"></script>
  
<div id="root"></div>

<script type="text/babel">
// 如果Promise对象正在抓取数据(pending状态),组件显示"正在加载";如果Promise对象报错(rejected状态),组件显示报错信息;如果Promise对象抓取数据成功(fulfilled状态),组件显示获取的数据
class RepoList extends React.Component {
  constructor(props) {
    super(props)
    this.state = {
      loading: true,
      error: null,
      data: null
    };
    console.log(this.props.promise)
  }

  componentDidMount() {
    this.props.promise.then(
      value => this.setState({loading: false, data: value}),
      error => this.setState({loading: false, error: error})
    );
  }

  render() {
    if (this.state.loading) {
      return <span>Loading...</span>;
    }else if (this.state.error !== null) {
      return <span>Error: {this.state.error.message}</span>;
    }else {
      var repos = this.state.data.items;
      var repoList = repos.map((repo, index) => {
        return (<li key={index}><a href={repo.html_url}>{repo.name}</a> ({repo.stargazers_count} stars) <br/> {repo.description}</li>);
      });
      return (
        <main>
          <h1>Most Popular JavaScript Projects in Github</h1>
          <ol>{repoList}</ol>
        </main>
      );
    }
  }
}

ReactDOM.render(
  <RepoList promise={$.getJSON('https://api.github.com/search/repositories?q=javascript&sort=stars')} />,
  document.getElementById('root')
);
</script>

</textarea><pre>
【 使用create-react-app快速构建React开发环境 】
通过create-react-app命令即无需配置就能快速构建React开发环境,自动创建的项目是基于react+Webpack+ES6,是创建新的单页应用的最佳方式
create-react-app不会处理后端逻辑或操纵数据库,只是创建一个前端构建流水线(build pipeline),所以可以使用它来配合任何后端,它在内部使用Babel和webpack

npx create-react-app my-app
npx create-react-app my-app --typescript
cd my-app
npm start
浏览器中打开http://localhost:3000/
当准备好部署到生产环境时,执行npm run build会在build文件夹内生成应用的优化版本

项目的目录结构如下：
my-app/
 - README.md
 - node_modules/
 - package.json
 - .gitignore
 - public/
 - - favicon.ico
 - - index.html
 - - manifest.json  # 指定了开始页面index.html,一切的开始都从这里开始,所以这个是代码执行的源头
 - src/
 - - App.css
 - - App.js
 - - App.test.js
 - - index.css
 - - index.js
 - - logo.svg

React可以将一些简短、独立的代码片段组合成复杂的UI界面,这些代码片段被称作组件,数据发生改变时React会高效地更新并重新渲染组件

React中拥有多种不同类型的组件,先从React.Component的子类开始介绍：

</textarea><textarea>
class ShoppingList extends React.Component {
  render() {
    return (
      <div className="shopping-list">
        <h1>Shopping List for {this.props.name}</h1>
        <ul>
          <li>Instagram</li>
          <li>WhatsApp</li>
          <li>Oculus</li>
        </ul>
      </div>
    );
  }
}

// 用法示例
<ShoppingList name="Mark" />

// 语法<div />会被编译成React.createElement('div'),上述的代码等同于：
return React.createElement('div', {className: 'shopping-list'},
  React.createElement('h1', /* ... h1 children ... */),
  React.createElement('ul', /* ... ul children ... */)
);

</textarea><pre>
ShoppingList是一个React组件类。一个组件接收一些参数,这些参数叫做props(properties),然后通过render方法返回需要展示在屏幕上的视图的层次结构
render返回了一个React元素,名为JSX的特殊语法是一种对渲染内容的轻量级描述,JSX可以更轻松地书写这些结构。
JSX中可以任意使用js表达式,只需要用一个大括号把表达式括起来。每一个React元素事实上都是一个js对象,可以在程序中把它当保存在变量中或作为参数传递

组件渲染一些内置的DOM组件如div、li等,也可以组合和渲染自定义的React组件。例如可以通过< ShoppingList />来表示整个购物清单组件。
每个组件都是封装好的,并且可以单独运行,这样就可以通过组合简单的组件来构建复杂的UI界面

import logo from '../logo/svg'
< img src={require('../logo.svg')} />
< img src='../logo.svg' />
< img src={logo} />

</textarea>
</div>

<div id="jsx">
<h4>jsx</h4><pre>
const element = < h1>Hello, world!< /h1>;
JSX是一个JS的语法扩展,建议在React中配合使用JSX,JSX可以生成react元素,JSX可以很好地描述UI应该呈现出它应有交互的本质形式。JSX可能会使人联想到模版语言,但它具有Js的全部功能。

React认为渲染逻辑本质上与其他UI逻辑内在耦合,比如在UI中需要绑定处理事件、在某些时刻状态发生变化时需要通知到UI,以及需要在UI中展示准备好的数据。
React并没有采用将标记与逻辑进行分离到不同文件这种人为地分离方式,而是通过将二者共同存放在称之为组件的松散耦合单元之中来实现关注点分离

在JSX中嵌入表达式
在JSX语法中可以在大括号内放置任何有效的js表达式,如2+2,user.firstName或formatName(user)都是有效的js表达式
建议将内容包裹在括号中,虽然这样做不是强制要求的,但这可以避免遇到自动插入分号陷阱

</textarea>注释<textarea>
<div>
  {/* 注释写在这里 */}
  Hello, {name}!
</div>

<div>
  {/* 多行注释 
  也同样有效。 */}
  Hello, {name}! 
</div>

</textarea>JSX的基本语法规则：遇到HTML标签就用HTML规则解析;遇到代码块(以{开头)就用JavaScript规则解析<textarea>
var names = ['Alice', 'Emily', 'Kate'];

ReactDOM.render(
  <div>
  {
    names.map(function (name) {
      return <div>Hello, {name}!</div>
    })
  }
  </div>,
  document.getElementById('example')
);

</textarea>JSX允许直接在模板插入js变量。如果这个变量是一个数组则会展开这个数组的所有成员添加到模板<textarea>
var arr = [
  <h1>Hello world!</h1>,
  <h2>React is awesome</h2>,
];
ReactDOM.render(
  <div>{arr}</div>,
  document.getElementById('example')
);

</textarea><textarea>
const name = 'Josh Perez';
const element = <h1>Hello, {name}</h1>;

ReactDOM.render(
  element,
  document.getElementById('root')
);

function formatName(user) {
  return user.firstName + ' ' + user.lastName;
}

const user = {
  firstName: 'Harper',
  lastName: 'Perez'
};

const element = (
  <h1>Hello, {formatName(user)}!</h1>
);

ReactDOM.render(
  element,
  document.getElementById('root')
);

</textarea><pre>
JSX也是一个表达式
在编译之后JSX表达式会被转为普通js函数调用,并且对其取值后得到js对象,即可以在if语句和for循环的代码块中使用JSX,将JSX赋值给变量,把JSX当作参数传入,以及从函数中返回JSX：

</textarea><textarea>
function getGreeting(user) {
  if (user) return <h1>Hello, {formatName(user)}!</h1>;
  return <h1>Hello, Stranger.</h1>;
}

</textarea><pre>
JSX特定属性
可以通过使用引号来将属性值指定为字符串字面量,也可以使用大括号来在属性值中插入一个js表达式
在属性中嵌入js表达式时不要在大括号外面加上引号,应该仅使用引号(对于字符串值)或大括号(对于表达式)中的一个,对于同一属性不能同时使用这两种符号
假如一个标签里面没有内容,可以使用/>来闭合标签,就像XML语法一样,JSX标签里能够包含很多子元素

因为JSX语法上更接近js而不是HTML,所以React DOM使用camelCase小驼峰命名来定义属性的名称,而不使用HTML属性名称的命名约定,例如JSX里的class变成了className,而tabindex则变为tabIndex

</textarea>使用JSX指定子元素<textarea>
const element = <div tabIndex="0"></div>

const element = <img src={user.avatarUrl} />;

const element = (
  <div>
    <h1>Hello!</h1>
    <h2>Good to see you here.</h2>
  </div>
);

</textarea><pre>
JSX防止注入攻击
可以安全地在JSX当中插入用户输入内容,直接使用用户输入内容是安全的,React DOM在渲染所有输入内容之前默认会进行转义,它可以确保在应用中永远不会注入那些并非自己明确编写的内容。所有的内容在渲染之前都被转换成了字符串,这样可以有效地防止XSS攻击。

</textarea><textarea>
const title = response.potentiallyMaliciousInput;
const element = <h1>{title}</h1>;

</textarea><pre>
JSX表示对象
Babel会把JSX转译成一个名为React.createElement()函数调用,以下两种示例代码完全等效：

</textarea><textarea>
const element = (
  <h1 className="greeting">Hello, world!</h1>
);
const element = React.createElement(
  'h1',
  {className: 'greeting'},
  'Hello, world!'
);

// React.createElement()会预先执行一些检查,以帮助编写无错代码,但实际上它创建了一个这样的对象,以下是简化过的结构
const element = {
  type: 'h1',
  props: {
    className: 'greeting',
    children: 'Hello, world!'
  }
};

</textarea><pre>
这些对象被称为React元素,它们描述了希望在屏幕上看到的内容。React通过读取这些对象,然后使用它们来构建DOM及保持随时更新

在JSX类型中使用点语法
在JSX中也可以使用点语法来引用一个React组件。当在一个模块中导出许多React组件时,这会非常方便

</textarea><textarea>
const MyComponents = {
  DatePicker: function DatePicker(props) {
    return <div>Imagine a {props.color} datepicker here.</div>;
  }
}

function BlueDatePicker() {
  return <MyComponents.DatePicker color="blue" />; // MyComponents.DatePicker 是一个组件
}

</textarea>
</div>

<div id="element">
<h4>元素渲染</h4><pre>
元素是构成React应用的最小砖块,元素描述了在屏幕上想看到的内容,组件是由元素构成的
const element = < h1>Hello, world< /h1>;
与浏览器的DOM元素不同,React元素是创建开销极小的普通对象,React DOM会负责更新DOM来与React元素保持一致。

将一个元素渲染为DOM
假设HTML文件某处有一个< div id="root">< /div>,将其称为根DOM节点,因为该节点内的所有内容都将由React DOM管理。
仅使用React构建的应用通常只有单一的根DOM节点;如果在将React集成进一个已有应用,那么可以在应用中包含任意多的独立根DOM节点。
想要将一个React元素渲染到根DOM节点中,只需把它们一起传入ReactDOM.render()：
ReactDOM.render(element, document.getElementById('root'));

更新已渲染的元素
React元素是不可变对象,一旦被创建就无法更改它的子元素或属性,一个元素就像电影的单帧代表了某个特定时刻的UI。
更新UI唯一的方式是创建一个全新的元素,并将其传入ReactDOM.render()

</textarea>计时器的例子<textarea>
function tick() {
  const element = (
    <div>
      <h1>Hello, world!</h1>
      <h2>It is {new Date().toLocaleTimeString()}.</h2>
    </div>
  );
  ReactDOM.render(element, document.getElementById('root'));
}
setInterval(tick, 1000);  // 在实践中大多数React应用只会调用一次ReactDOM.render()

</textarea><pre>
React只更新它需要更新的部分
React DOM会将元素和它的子元素与它们之前的状态进行比较,并只会进行必要的更新来使DOM达到预期的状态
尽管每一秒都会新建一个描述整个UI树的元素,React DOM只会更新实际改变了的内容,也就是例子中的文本节点
考虑UI在任意给定时刻的状态,而不是随时间变化的过程,能够消灭一整类的bug

</textarea>
</div>

<div id="component_props">
<h4>组件 & Props</h4><pre>
组件允许将UI拆分为独立可复用的代码片段,并对每个片段进行独立构思
React 允许将代码封装成组件(component),然后像插入普通HTML标签一样,在网页中插入这个组件
组件从概念上类似于js函数,它接受任意的入参即props,并返回用于描述页面展示内容的React元素

定义组件有两个要求：
1、组件名称必须以大写字母开头
2、组件的返回值只能有一个根元素

函数组件与class组件
函数组件的性能比类组件的性能要高,因为类组件使用的时候要实例化,而函数组件直接执行函数取返回结果即可
尽管函数组件和类组件的性能优化策略有些不同,但是他们性能上的差异是很微小的
通过hooks,函数组件也可以有state和类生命周期回调了

区别	函数组件	类组件
是否有this	没有	有
是否有生命周期	没有	有
是否有状态state	没有	有

</textarea>React函数组件接收唯一带有数据的props(代表属性)对象与并返回一个React元素,函数组件本质上就是js函数<textarea>
function Welcome(props) {
  return <h1>Hello, {props.name}</h1>;
}

</textarea>使用ES6的class定义组件<textarea>
class Welcome extends React.Component {
  render() {
    return <h1>Hello, {this.props.name}</h1>;
  }
}

</textarea><pre>
渲染组件
之前遇到的React元素都只是DOM标签：
const element = < div />;
不过React元素也可以是用户自定义的组件：
const element = < Welcome name="Sara" />;
当React元素为用户自定义组件时,它会将JSX所接收的属性(attributes)转换为单个对象传递给组件,这个对象被称之为props

</textarea><textarea>
function Welcome(props) {
  return <h1>Hello, {props.name}</h1>;
}
const element = <Welcome name="Sara" />;
ReactDOM.render(
  element,
  document.getElementById('root')
);

</textarea><pre>
jsx规范组件名称必须以大写字母开头。
React会将以小写字母开头的组件视为原生DOM标签,例如div代表HTML的div标签,而< Welcome />则代表一个组件,并且需在作用域内使用Welcome

组合组件
组件可以在其输出中引用其他组件,这就可以用同一组件来抽象出任意层次的细节,按钮、表单、对话框甚至整个屏幕的内容,在React应用程序中这些通常都会以组件的形式表示。

</textarea>创建一个可以多次渲染Welcome组件的App组件<textarea>
function Welcome(props) {
  return <h1>Hello, {props.name}</h1>;
}

function App() {
  return (
    <div>
      <Welcome name="Sara" />
      <Welcome name="Cahal" />
      <Welcome name="Edite" />
    </div>
  );
}

ReactDOM.render(
  <App />,
  document.getElementById('root')
);

</textarea><pre>
通常每个新的React应用程序的顶层组件都是App组件,但如果将React集成到现有的应用程序中,可能需要使用像Button这样的小组件,并自下而上地将这类组件逐步应用到视图层的每一处

提取组件
将组件拆分为更小的组件

</textarea><textarea>
function Comment(props) {
  return (
    <div className="Comment">
      <div className="UserInfo">
        <img className="Avatar" src={props.author.avatarUrl} alt={props.author.name} />
        <div className="UserInfo-name">{props.author.name}</div>
      </div>
      <div className="Comment-text">{props.text}</div>
      <div className="Comment-date">{formatDate(props.date)}</div>
    </div>
  );
}

// 该组件用于描述一个社交媒体网站上的评论功能,它接收author对象,text字符串及date日期作为props。该组件由于嵌套的关系变得难以维护,且很难复用它的各个部分,因此从中提取一些组件出来,首先提取Avatar组件

function Avatar(props) {
  return (<img className="Avatar" src={props.user.avatarUrl} alt={props.user.name} />);
}

// Avatar不需知道它在Comment组件内部是如何渲染的,因此给它的props起了一个更通用的名字user,而不是author。建议从组件自身的角度命名props,而不是依赖于调用组件的上下文命名
function UserInfo(props) {
  return (
    <div className="UserInfo">
      <Avatar user={props.user} />
      <div className="UserInfo-name">{props.user.name}</div>
    </div>
  );
}

function Comment(props) {
  return (
    <div className="Comment">
      <UserInfo user={props.author} />
      <div className="Comment-text">{props.text}</div>
      <div className="Comment-date">{formatDate(props.date)}</div>
    </div>
  );
}

</textarea><pre>
最初看上去,提取组件可能是一件繁重的工作,但在大型应用中构建可复用组件库是完全值得的。如果UI中有一部分被多次使用(Button,Panel,Avatar)或组件本身就足够复杂(App,FeedStory,Comment),那么它就是一个可复用组件的候选项

组件的用法与原生的HTML标签完全一致,可以任意加入属性,比如< HelloMessage name="John">就是HelloMessage组件加入一个name属性,值为John。组件的属性可以在组件类的this.props对象上获取,比如name属性就可以通过this.props.name读取

添加class属性需要写成className,for属性需要写成htmlFor,这是因为class和for是JavaScript的保留字

state和 props之间的区别
props(“properties”的缩写)和state都是普通的JavaScript对象。它们都是用来保存信息的,这些信息可以控制组件的渲染输出,而它们的一个重要的不同点就是：props是传递给组件的(类似于函数的形参),而state是在组件内被组件自己管理的(类似于在一个函数内声明的变量)

this.props 和 this.state 都代表着已经被渲染了的值,即当前屏幕上显示的值

Props的只读性
所有React组件都必须是纯函数,无论是使用函数声明还是通过class声明的组件都禁止修改自身的props
属性props是外界传递过来的,状态state是组件本身的,状态可以在组件中任意修改

组件的属性和状态改变都会更新视图
React是单项数据流,父组件改变了属性,那么子组件视图会更新

</textarea><textarea>
function sum(a, b) {
  return a + b;
}
function withdraw(account, amount) {
  account.total -= amount;
}

</textarea><pre>
sum这样的函数被称为“纯函数”,因为该函数不会尝试更改入参,且多次调用下相同的入参始终返回相同的结果。withdraw函数则不是纯函数,因为它更改了自己的入参

React非常灵活,但它也有一个严格的规则：所有React组件都必须像纯函数一样保护它们的props不被更改。
当然应用程序的UI是动态的,并会伴随着时间的推移而变化。在不违反上述规则的情况下,state允许React组件随用户操作、网络响应或者其他变化而动态更改输出内容。

【 使用PropTypes进行类型检查 】
随着应用程序不断增长,可以通过类型检查捕获大量错误。对于某些应用程序来说,可以使用Flow或TypeScript等js扩展来对整个应用程序做类型检查。但即使不使用这些扩展,React也内置了一些类型检查的功能。要在组件的props上进行类型检查,只需配置特定的propTypes属性

组件的属性可以接受任意值,字符串、对象、函数等都可以,需要一种机制,验证别人使用组件时,提供的参数是否符合要求。
组件类的PropTypes属性就是用来验证组件实例的属性是否符合要求

</textarea><textarea>
import PropTypes from 'prop-types';

class Greeting extends React.Component {
  render() {
    return (
      <h1>Hello, {this.props.name}</h1>
    );
  }
}

Greeting.propTypes = {
  name: PropTypes.string
};

</textarea><pre>
PropTypes提供一系列验证器,可用于确保组件接收到的数据类型是有效的,如PropTypes.string。当传入的prop值类型不正确时,js控制台将会显示警告。出于性能方面的考虑,propTypes仅在开发模式下进行检查

使用不同验证器,可以将属性声明为JS原生类型,默认情况下这些属性都是可选的

</textarea><textarea>
import PropTypes from 'prop-types';

MyComponent.propTypes = {
  optionalArray: PropTypes.array,
  optionalBool: PropTypes.bool,
  optionalFunc: PropTypes.func,
  optionalNumber: PropTypes.number,
  optionalObject: PropTypes.object,
  optionalString: PropTypes.string,
  optionalSymbol: PropTypes.symbol,
  optionalNode: PropTypes.node, // 任何可被渲染的元素(包括数字、字符串、元素或数组或Fragment) 也包含这些类型
  optionalElement: PropTypes.element,// 一个React元素。
  optionalElementType: PropTypes.elementType, // 一个React元素类型(即MyComponent)。
  optionalMessage: PropTypes.instanceOf(Message), // 也可以声明prop为类的实例,这里使用JS的instanceof操作符。  
  optionalEnum: PropTypes.oneOf(['News', 'Photos']), // 可以让prop只能是特定的值,指定它为枚举类型
  
  requiredFunc: PropTypes.func.isRequired, // 可在任何PropTypes属性后面加上isRequired确保这个prop没有被提供时会打印警告信息。
  requiredAny: PropTypes.any.isRequired,  // 任意类型的数据

  // 一个对象可以是几种类型中的任意一个类型
  optionalUnion: PropTypes.oneOfType([
    PropTypes.string,
    PropTypes.number,
    PropTypes.instanceOf(Message)
  ]),

  optionalArrayOf: PropTypes.arrayOf(PropTypes.number), // 可以指定一个数组由某一类型的元素组成
  optionalObjectOf: PropTypes.objectOf(PropTypes.number), // 可以指定一个对象由某一类型的值组成

  // 可以指定一个对象由特定的类型值组成
  optionalObjectWithShape: PropTypes.shape({
    color: PropTypes.string,
    fontSize: PropTypes.number
  }),
  
  // An object with warnings on extra properties
  optionalObjectWithStrictShape: PropTypes.exact({
    name: PropTypes.string,
    quantity: PropTypes.number
  }),   


  // 可指定一个自定义验证器,验证失败时返回一个Error对象。不要用console.warn或抛出异常,因为这在onOfType中不会起作用。
  customProp: function(props, propName, componentName) {
    if (!/matchme/.test(props[propName])) {
      return new Error('Invalid prop `' + propName + '` supplied to' +' `' + componentName + '`. Validation failed.');
    }
  },

  // 也可以提供一个自定义的`arrayOf`或`objectOf`验证器,验证失败时返回一个Error对象。
  // 验证器将验证数组或对象中的每个值。验证器的前两个参数,第一个是数组或对象本身,第二个是他们当前的键。
  customArrayProp: PropTypes.arrayOf(function(propValue, key, componentName, location, propFullName) {
    if (!/matchme/.test(propValue[key])) {
      return new Error(
        'Invalid prop `' + propFullName + '` supplied to' + ' `' + componentName + '`. Validation failed.'
      );
    }
  })
};

</textarea>限制单个元素:可以通过PropTypes.element来确保传递给组件的children中只包含一个元素<textarea>
import PropTypes from 'prop-types';
class MyComponent extends React.Component {
  render() {
    const children = this.props.children; // 这必须只有一个元素,否则控制台会打印警告
    return (<div>{children}</div>);
  }
}

MyComponent.propTypes = {
  children: PropTypes.element.isRequired
};

</textarea><pre>
【 Prop默认值 】
无论是函数组件还是class组件都拥有defaultProps属性
可以通过配置特定的defaultProps属性来定义props的默认值,defaultProps用于确保this.props.name在父组件没有指定其值时有一个默认值。propTypes类型检查发生在defaultProps赋值后,所以类型检查也适用于defaultProps。

</textarea><textarea>
class Greeting extends React.Component {
  render() {
    return (<h1>Hello, {this.props.name}</h1>);
  }
}

// 指定props的默认值：
Greeting.defaultProps = {
  name: 'Stranger'
};

// 渲染出"Hello, Stranger"：
ReactDOM.render(
  <Greeting />,
  document.getElementById('example')
);

</textarea>如果正在使用像transform-class-properties的Babel转换工具,也可以在React组件类中声明defaultProps作为静态属性。此语法提案还没有最终确定,需要进行编译后才能在浏览器中运行<textarea>
class Greeting extends React.Component {
  static defaultProps = {
    name: 'stranger'
  }

  render() {
    return (<div>Hello, {this.props.name}</div>)
  }
}

</textarea>
</div>

<div id="props_children">
<h4>props.children 组合 vs 继承</h4><pre>
React有十分强大的组合模式,推荐使用组合而非继承来实现组件间的代码重用。

this.props对象的属性与组件的属性一一对应,但是有一个例外就是this.props.children属性表示组件的所有子节点
this.props.children的值有三种可能：如果当前组件没有子节点,它就是undefined;如果有一个子节点,数据类型是object;如果有多个子节点,数据类型就是array

包含关系
有些组件无法提前知晓它们子组件的具体内容。在Sidebar(侧边栏)和Dialog(对话框)等展现通用容器(box)的组件中特别容易遇到这种情况。
建议这些组件使用一个特殊的children prop来将他们的子组件传递到渲染结果中,这使得别的组件可以通过JSX嵌套将任意组件作为子组件传递给它们

</textarea><textarea>
function NotesList(props){
  return (<ol>{props.children.map((child) => (<li>{child}</li>))}</ol>)
}

ReactDOM.render(
  <NotesList>
    <span>hello</span>
    <span>world</span>
  </NotesList>,
  document.getElementById('root')
);

</textarea><textarea>
function FancyBorder(props) {
  return (<div className={'FancyBorder FancyBorder-' + props.color}>{props.children}</div>);
}

function WelcomeDialog() {
  return (
    <FancyBorder color="blue">
      <h1 className="Dialog-title">Welcome</h1>
      <p className="Dialog-message">Thank you for visiting our spacecraft!</p>
    </FancyBorder>
  );
}

</textarea><pre>
FancyBorder JSX标签中的所有内容都会作为一个children prop传递给FancyBorder组件。因为FancyBorder将{props.children}渲染在一个div中,被传递的这些子组件最终都会出现在输出结果中。
少数情况下可能需要在一个组件中预留出几个洞,这种情况下可以不使用children,而是自行约定：将所需内容传入props,并使用相应的prop。

</textarea><textarea>
function SplitPane(props) {
  return (
    <div className="SplitPane">
      <div className="SplitPane-left">{props.left}</div>
      <div className="SplitPane-right">{props.right}</div>
    </div>
  );
}

function App() {
  return (
    <SplitPane left={<Contacts />} right={<Chat />} />
  );
}

</textarea><pre>
Contacts和Chat之类的React元素本质就是对象,所以可以把它们当作props,像其他数据一样传递。这种方法可能使你想起别的库中“槽”(slot)的概念,但React没有槽这一概念的限制,可以将任何东西作为props进行传递

特例关系
一些组件可看作是其他组件的特殊实例,如WelcomeDialog可以说是Dialog的特殊实例,React也可以通过组合来实现这一点,特殊组件可以通过props定制并渲染一般组件：

</textarea><textarea>
function Dialog(props) {
  return (
    <FancyBorder color="blue">
      <h1 className="Dialog-title">{props.title}</h1>
      <p className="Dialog-message">{props.message}</p>
    </FancyBorder>
  );
}

function WelcomeDialog() {
  return <Dialog title="Welcome" message="Thank you for visiting our spacecraft!" />
}

</textarea>组合也同样适用于以class形式定义的组件<textarea>
function Dialog(props) {
  return (
    <FancyBorder color="blue">
      <h1 className="Dialog-title">{props.title}</h1>
      <p className="Dialog-message">{props.message}</p>
      {props.children}
    </FancyBorder>
  );
}

class SignUpDialog extends React.Component {
  constructor(props) {
    super(props);
    this.handleChange = this.handleChange.bind(this);
    this.handleSignUp = this.handleSignUp.bind(this);
    this.state = {login: ''};
  }

  handleChange(e) {
    this.setState({login: e.target.value});
  }

  handleSignUp() {
    alert(`Welcome aboard, ${this.state.login}!`);
  }

  render() {
    return (
      <Dialog title="Mars Exploration Program"  message="How should we refer to you?">
        <input value={this.state.login} onChange={this.handleChange} />
        <button onClick={this.handleSignUp}> Sign Me Up! </button>
      </Dialog>
    );
  }
}

</textarea><pre>
继承
在Facebook,在成百上千个组件中使用React,并没有发现需要使用继承来构建组件层次的情况。
Props和组合提供了清晰而安全地定制组件外观和行为的灵活方式。组件可以接受任意props,包括基本数据类型、React元素以及函数。
如果想要在组件间复用非UI的功能,建议将其提取为一个单独的js模块,如函数、对象或类。组件可以直接引入(import)而无需通过extend继承它们

</textarea>
</div>

<div id="ref">
<h4>Ref属性引用</h4><pre>
在日常写React代码的时候一般用不到Refs,因为并不直接操作底层DOM元素,而是在render函数里去编写页面结构,由React来组织DOM元素的更新。
凡事总有例外,有时需要直接去操作页面的真实DOM,这就要求有直接访问真实DOM的能力,而Refs就提供了这样的能力。
看这个名字也知道,Refs其实是提供了一个对真实DOM(组件)的引用,可以通过这个引用直接去操作DOM(组件)
处理DOM元素的focus,文本的选择或者媒体的播放等,以及处罚强制动画或同第三方DOM库集成的时候,也就是React无法控制局面时就需要直接操作Refs

组件并不是真实的DOM节点,而是存在于内存之中的一种数据结构叫做虚拟DOM (virtual DOM)。只有当它插入文档以后才会变成真实的DOM 。根据React的设计,所有的DOM变动都先在虚拟DOM上发生,然后再将实际发生变动的部分反映在真实DOM上,这种算法叫做DOM diff ,它可以极大提高网页的性能表现。
Refs提供ref属性允许访问真实DOM节点或在render方法中创建的React元素

在典型的React数据流中,props是父组件与子组件交互的唯一方式。要修改一个子组件需要使用新的props来重新渲染它。但在某些情况下需要在典型数据流之外强制修改子组件。被修改的子组件可能是一个React组件的实例,也可能是一个DOM元素。对于这两种情况React都提供了解决办法

何时使用Refs
管理焦点,文本选择或媒体播放。
触发强制动画。
集成第三方DOM库。
避免使用refs来做任何可以通过声明式实现来完成的事情,例如避免在Dialog组件里暴露open()和close()方法,最好传递isOpen属性

勿过度使用Refs
可能首先会想到使用refs在app中让事情发生。如果是这种情况,请认真再考虑一下state属性应该被安排在哪个组件层中,通常让更高的组件层级拥有这个state是更恰当的,即状态提升

【 回调Refs 】
React也支持另一种设置refs的方式,称为“回调refs”。它能更精细地控制何时refs被设置和解除。
不同于传递createRef()创建的ref属性,你会传递一个函数,这个函数中接受React组件实例或HTML DOM元素作为参数,以使它们能在其他地方被存储和访问。

</textarea>使用ref回调函数,在实例的属性中存储对DOM节点的引用<textarea>
class CustomTextInput extends React.Component {
  constructor(props) {
    super(props);

    this.textInput = null;

    this.setTextInputRef = element => {
      this.textInput = element;
    };

    this.focusTextInput = () => {
      if (this.textInput) this.textInput.focus();  // 使用原生DOM API使text输入框获得焦点
    };
  }

  componentDidMount() {
    this.focusTextInput(); // 组件挂载后,让文本框自动获得焦点
  }

  render() {
    // 使用ref的回调函数将text输入框DOM节点的引用存储到React实例上(比如this.textInput)
    return (
      <div>
        <input type="text" ref={this.setTextInputRef} />
        <input type="button" value="Focus the text input" onClick={this.focusTextInput} />
      </div>
    );
  }
}

</textarea><pre>
React将在组件挂载时会调用ref回调函数并传入DOM元素,当卸载时调用它并传入null。在componentDidMount或componentDidUpdate触发前React会保证refs一定是最新的

可以在组件间传递回调形式的refs,就像可以传递通过React.createRef()创建的对象refs一样
在下面的例子中,Parent把它的refs回调函数当作inputRef props传递给了CustomTextInput,而且CustomTextInput把相同的函数作为特殊的ref属性传递给了input。结果是在Parent中的this.inputElement会被设置为与CustomTextInput中的input元素相对应的DOM节点

</textarea><textarea>
function CustomTextInput(props) {
  return (
    <div>
      <input ref={props.inputRef} />
    </div>
  );
}

class Parent extends React.Component {
  render() {
    return (<CustomTextInput inputRef={el => this.inputElement = el} />);
  }
}

</textarea>React16之前一般都是通过一个回调函数的方式的refs,把当前组件的DOM绑定到一个实例变量上<textarea>
class AutoFocusTextInput extends React.Component {
  constructor(props) {
    super(props);
    this.textInput = null;
  }

  componentDidMount() {
    this.textInput.focus();
  }

  render() {
    return (<input ref={ele => { this.textInput = ele}} />);
  }
}

ReactDOM.render(
  <AutoFocusTextInput />,
  document.getElementById('root')
);

</textarea><pre>
先声明一个值为null的textInput变量,然后在ref中以回调的方式将组件DOM赋值给textInput,然后就可以通过this.textInput.focus()这样的性质来直接调用CustomTextInput这个组件的实例方法。

但这个方式有以下两个不太好：
1、每次组件重新渲染的时候,行内函数都会执行两次,第一次的ele的值为空,第二次才为真正的DOM对象。
因为在每次渲染中React都会创建一个新函数实例,因此React需要清理旧ref并且设置新的。通过将ref的回调函数定义成类的绑定函数的方式可以避免上述问题,
2、如果想要将一个子组件的ref传递给父组件,可能会有点麻烦,虽然通过一个特殊的prop属性可以做到,但是感觉有点不太正规

关于回调refs的说明
如果ref回调函数是以内联函数的方式定义的,在更新过程中它会被执行两次,第一次传入参数null,然后第二次会传入参数DOM元素。这是因为在每次渲染时会创建一个新的函数实例,所以React清空旧的ref并且设置新的。通过将ref的回调函数定义成class的绑定函数的方式可以避免上述问题,但是大多数情况下它是无关紧要的。

【 React.createRef() 】
React16新增一个API：React.createRef();通过这个API可以先创建一个ref变量,然后再将这个变量赋值给组件声明中ref属性就好了。

创建Refs
Refs是使用React.createRef()创建的,并通过ref属性附加到React元素。在构造组件时通常将Refs分配给实例属性,以便可以在整个组件中引用它们。

</textarea><textarea>
class MyComponent extends React.Component {
  constructor(props) {
    super(props);
    this.myRef = React.createRef();
  }
  render() {
    return <div ref={this.myRef} />;
  }
}

</textarea><pre>
访问Refs
当ref被传递给render中的元素时,对该节点的引用可以在ref的current属性中被访问。
const node = this.myRef.current;

ref的值根据节点的类型而有所不同：
当ref属性用于HTML元素时,构造函数中使用React.createRef()创建的ref接收底层DOM元素作为其current属性。
当ref属性用于自定义class组件时,ref对象接收组件的挂载实例作为其current属性。
不能在函数组件上使用ref属性,因为他们没有实例。

在V16版本前可以直接通过变量访问元素的方法,在V16后需要通过this.textInput.current,即真实的DOM是通过current属性来引用的。
如果通过createRef API赋值给组件的ref,那么引用的就是组件实例;如果是DOM元素,那引用的自然的就是DOM元素了

</textarea><textarea>
// 为DOM元素添加ref,使用ref去存储DOM节点的引用
// React会在组件挂载时给current属性传入DOM元素,并在组件卸载时传入null值。ref会在componentDidMount或componentDidUpdate生命周期钩子触发前更新。
class CustomTextInput extends React.Component {
  constructor(props) {
    super(props);
    this.textInput = React.createRef();  // 创建一个ref来存储textInput的DOM元素
  }

  focusTextInput() {
    this.textInput.current.focus();  // 直接使用原生API使text输入框获得焦点,通过current来访问DOM节点
  }

  render() {
    return (
      <div>
        <input type="text" ref={this.textInput} />  // 告诉React把input ref关联到构造器里创建的textInput上,将React.createRef创建的ref和input这个真实DOM联系起来
        <input type="button" value="Focus the text input" onClick={this.focusTextInput.bind(this)} />
      </div>
    );
  }
}

// 为class组件添加Ref
// 包装上面的CustomTextInput来模拟它挂载之后立即被点击的操作,可以使用ref来获取这个自定义的input组件并手动调用它的focusTextInput方法：
class AutoFocusTextInput extends React.Component {
  constructor(props) {
    super(props);
    this.textInput = React.createRef();
  }

  componentDidMount() {
    this.textInput.current.focusTextInput();
  }

  render() {
    return (<CustomTextInput ref={this.textInput} />);
  }
}

</textarea><pre>
【 Refs与函数组件 】
默认不能在函数组件上使用ref属性,因为它们没有实例

</textarea>This will *not* work!<textarea>
function MyFunctionComponent() {
  return <input />;
}

class Parent extends React.Component {
  constructor(props) {
    super(props);
    this.textInput = React.createRef();
  }
  render() {
    return (<MyFunctionComponent ref={this.textInput} />);
  }
}

</textarea><pre>
如果要在函数组件中使用ref,可以使用forwardRef(可与useImperativeHandle结合使用),或者可以将该组件转化为class组件。
不管怎样,可以在函数组件内部使用ref属性,只要它指向一个DOM元素或class组件

</textarea><textarea>
function CustomTextInput(props) {
  let textInput = React.createRef();  // 这里必须声明textInput,这样ref才可以引用它

  function handleClick() {
    textInput.current.focus();
  }

  return (
    <div>
      <input type="text" ref={textInput} />
      <input type="button" value="Focus the text input" onClick={handleClick} />
    </div>
  );
}

</textarea><pre>
【 React.forwardRef() 传递Ref Ref转发 】
在V16版本之前想要父组件拿到子组件的ref,需要通过一些特殊的方法,V16版本之后React提供了一种原生的方式来完成这种操作。
这就涉及到React新增的另一个API：React.forwardRef(),通过接受一个函数来传递ref,接受渲染函数作为参数,React将使用props和ref作为参数来调用此函数,此函数应返回React节点

React.forwardRef会创建一个React组件,这个组件能够将其接受的ref属性转发到其组件树下的另一个组件中。这种技术并不常见,但在以下两种场景中特别有用：
1、转发refs到DOM组件
2、在高阶组件中转发refs

</textarea><textarea>
function FancyButton(props) {
  return (<button className="FancyButton">{props.children}</button>);
}

</textarea><pre>
React组件隐藏其实现细节,包括其渲染结果。其他使用FancyButton的组件通常不需要获取内部的DOM元素button的ref。这很好,因为这防止组件过度依赖其他组件的DOM结构。

虽然这种封装对类似FeedStory或Comment这样的应用级组件是理想的,但其对FancyButton或MyTextInput这样的高可复用组件来说可能是不方便的。这些组件倾向于在整个应用中以一种类似常规DOM button和input的方式被使用,并且访问其DOM节点对管理焦点、选中或动画来说是不可避免的。

Ref转发是一个可选特性,其允许某些组件接收ref,并将其向下传递转发给子组件。
Ref转发是一项将ref自动地通过组件传递到其子组件的技巧。对于大多数应用中的组件来说不是必需的,但其对某些组件尤其是可重用的组件库是很有用的

</textarea><textarea>
// FancyButton使用React.forwardRef来获取传递给它的ref,然后转发到它渲染的DOM button,这样使用FancyButton的组件可以获取底层DOM节点button的ref,并在必要时访问,就像其直接使用DOM button一样
const FancyButton = React.forwardRef((props, ref) => (
  <button ref={ref} className="FancyButton">{props.children}</button>
));

// You can now get a ref directly to the DOM button:
const ref = React.createRef();
<FancyButton ref={ref}>Click me!</FancyButton>;

</textarea><pre>
在上述的示例中,React会将< FancyButton ref={ref}>元素的ref作为第二个参数传递给React.forwardRef函数中的渲染函数,该渲染函数会将ref传递给button元素。因此,当React附加了ref属性之后,ref.current将直接指向button DOM元素实例

简单来说就是创建一个引用,本来是给外面的FancyButton组件的,但因为React.forwardRef的处理,这个引用被传递给了内部的button元素。这样ref.current的引用由本来的FancyButton实例传递到了button元素

第二个参数ref只在使用React.forwardRef定义组件时存在。常规函数和class组件不接收ref参数,且props中也不存在ref。
Ref转发不仅限于DOM组件,也可以转发refs到class组件实例中

【 在高阶组件HOC中转发refs 】
高阶组件简单的说就是通过组件包裹的方式来提到代码复用,高阶组件就是一个函数,且该函数接受一个组件作为参数,并返回一个新的组件。

</textarea><textarea>
// 输出组件的props到控制台的HOC
function logProps(WrappedComponent) {
  class LogProps extends React.Component {
    componentDidUpdate(prevProps) {
      console.log('old props:', prevProps);
      console.log('new props:', this.props);
    }

    render() {
      return <WrappedComponent {...this.props} />;
    }
  }

  return LogProps;
}

// logProps HOC透传(pass through)所有props到其包裹的组件,所以渲染结果将是相同的。例如可以使用该HOC记录所有传递到FancyButton组件的props：
class FancyButton extends React.Component {
  // ...
}

// 导出LogProps,而不是FancyButton,虽然它也会渲染一个FancyButton。
export default logProps(FancyButton);

import FancyButton from './FancyButton';
const ref = React.createRef();
// 导入的FancyButton组件是高阶组件LogProps。尽管渲染结果将是一样的,但ref将指向LogProps而不是内部的FancyButton组件,这意味着不能调用例如ref.current.focus()这样的方法
<FancyButton label="Click Me" handleClick={handleClick} ref={ref} />;

</textarea><pre>
上面的示例有一点需要注意：refs将不会透传下去。这是因为ref不是prop属性。就像key一样,其被React进行了特殊处理。如果对HOC添加ref,该ref将引用最外层的容器组件,而不是被包裹的组件。这意味着用于FancyButton组件的refs实际上将被挂载到LogProps组件

但可使用React.forwardRef API明确地将refs转发到内部的FancyButton组件。React.forwardRef接受一个渲染函数,其接收props和ref参数并返回一个React节点

</textarea><textarea>
function logProps(Component) {
  class LogProps extends React.Component {
    componentDidUpdate(prevProps) {
      console.log('old props:', prevProps);
      console.log('new props:', this.props);
    }

    render() {
      const {forwardedRef, ...rest} = this.props;
      return <Component ref={forwardedRef} {...rest} />;  // 将自定义的prop属性“forwardedRef”定义为ref
    }
  }

  // React.forwardRe回调的第二个参ref,可以将其作为常规prop属性传递给LogProps如forwardedRef,然后它就可以被挂载到被LogProps包裹的子组件上。
  return React.forwardRef((props, ref) => <LogProps {...props} forwardedRef={ref} />);
}

</textarea>实例二 <textarea>
function logProps(WrappedComponent) {
  class LogProps extends React.Component {
    render() {
      return <WrappedComponent {...this.props} />;
    }
  }
  return LogProps;
}

// 用法
class FancyButton extends React.Component {
  // ...
}

// 先声明一个FancyButton的组件,然后将其作为参数传入logProps函数,最后得到的其实是一个LogProps组件。
export default logProps(FancyButton);

// 接下来使用refs
import FancyButton from './FancyButton';
const ref = React.createRef();

// The FancyButton component we imported is the LogProps HOC.
// Even though the rendered output will be the same,
// Our ref will point to LogProps instead of the inner FancyButton component!
// This means we can't call e.g. ref.current.focus()
<FancyButton label="Click Me" handleClick={handleClick} ref={ref} />;

// 通过文件引入FancyButton(其实引入的是LogProps组件)然后createRef并指向FancyButton。本意是希望引入真正的FancyButton组件,实际上引用的是 外层包裹组件LogProps组件。可以通过以下改造来完善代码：
function logProps(Component) {
  class LogProps extends React.Component {
    render() {
      const {forwardedRef, ...rest} = this.props;
      return <Component ref={forwardedRef} {...rest} />;  // Assign the custom prop "forwardedRef" as a ref
    }
  }

  // Note the second param "ref" provided by React.forwardRef.
  // We can pass it along to LogProps as a regular prop, e.g. "forwardedRef"
  // And it can then be attached to the Component. 
  return React.forwardRef((props, ref) => {
    return <LogProps {...props} forwardedRef={ref} />;
  });
}

</textarea><pre>
如上代码修改了高阶组件logProps函数的实现方式,在内部组件LogProps的render方法中,给被包裹组件(作为参数传入的组件)添加了来自props的ref。
最终返回的也是一个React.forwardRef处理过的组件,这个组件将ref传递到内部的props中去。
这样,但通过logProps(FancyButton)函数调用的时候,其实返回的是一个经过React.forwardRef处理的组件, 当通过
< FancyButton label="Click Me" handleClick={handleClick} ref={ref} />;
去添加ref的时候,这个ref其实直接添加到了内部的LogProps组件的forwardedRef属性上,然后在LogProps组件内部,又通过props属性的方式被赋值了被包裹组件(作为参数的组件,也就是FancyButton组件)。这个传递其实经过了三次。。。。

总的来说,高阶组件的ref其实是通过React.forwardRef技术将ref传递到包裹组件logProps上,然后通过属性传递传递到真正的FancyButton组件上,两次传递才完成

【 组件库维护 】
当开始在组件库中使用forwardRef时,应当将其视为一个破坏性更改,并发布库的一个新的主版本。这是因为你的库可能会有明显不同的行为(例如refs被分配给了谁以及导出了什么类型),并且这样可能会导致依赖旧行为的应用和其他库崩溃。
出于同样的原因,当React.forwardRef存在时有条件地使用它也是不推荐的：它改变了你的库的行为,并在升级React自身时破坏用户的应用。

【 在DevTools中显示自定义名称 】
React.forwardRef接受一个渲染函数,React DevTools使用该函数来决定为ref转发组件显示的内容。

</textarea><textarea>
// 以下组件将在DevTools中显示为“ForwardRef”：
const WrappedComponent = React.forwardRef((props, ref) => {
  return <LogProps {...props} forwardedRef={ref} />;
});

// 如果命名了渲染函数,DevTools也将包含其名称(例如 “ForwardRef(myFunction)”)：
const WrappedComponent = React.forwardRef(
  function myFunction(props, ref) {
    return <LogProps {...props} forwardedRef={ref} />;
  }
);

// 甚至可以设置函数的displayName属性来包含被包裹组件的名称
function logProps(Component) {
  class LogProps extends React.Component {
    // ...
  }

  function forwardRef(props, ref) {
    return <LogProps {...props} forwardedRef={ref} />;
  }

  // 在DevTools中为该组件提供一个更有用的显示名。例如“ForwardRef(logProps(MyComponent))”
  const name = Component.displayName || Component.name;
  forwardRef.displayName = `logProps(${name})`;

  return React.forwardRef(forwardRef);
}

</textarea>
</div>

<div id="state_lifecycle">
<h4>State & 生命周期</h4><pre>
组件免不了要与用户互动,React的一大创新就是将组件看成是一个状态机,一开始有一个初始状态,然后用户互动导致状态变化,从而触发重新渲染UI
this.props和this.state都用于描述组件的特性,可能会产生混淆。一个简单的区分方法是,this.props表示那些一旦定义就不再改变的特性,而this.state是会随着用户互动而产生变化的特性
state是私有的,并且完全受控于当前组件

</textarea><textarea>
// 一种更新UI界面的方法是通过调用ReactDOM.render()来修改想要渲染的元素
function tick() {
  const element = (<div><h2>It is {new Date().toLocaleTimeString()}.</h2></div>);
  ReactDOM.render(
    element,
    document.getElementById('root')
  );
}
setInterval(tick, 1000);

/* 封装真正可复用的Clock组件,它将设置自己的计时器并每秒更新一次 */
// 从封装时钟的外观开始
function Clock(props) {
  return (<div><h2>It is {props.date.toLocaleTimeString()}.</h2></div>);
}

function tick() {
  ReactDOM.render(
    <Clock date={new Date()} />,
    document.getElementById('root')
  );
}
setInterval(tick, 1000);

// 忽略了一个关键的技术细节：Clock组件需要设置一个计时器,并且需要每秒更新UI。理想情况下希望只编写一次代码,便可以让Clock组件自我更新：
ReactDOM.render(
  <Clock />,
  document.getElementById('root')
);

// 需要在Clock组件中添加state来实现这个功能。
// 每次组件更新时render方法都会被调用,但只要在相同的DOM节点中渲染Clock就仅有一个Clock组件的class实例被创建使用。这就使得可以使用如state或生命周期方法等很多其他特性

// 向class组件中添加局部的state,将date从props移动到state中,之后会将计时器相关的代码添加到组件中
class Clock extends React.Component {
  // 添加一个class构造函数,然后在该函数中为this.state赋初值
  // 通过以下方式将props传递到父类的构造函数中,Class组件应该始终使用props参数来调用父类的构造函数
  constructor(props) { 
    super(props);
    this.state = {date: new Date()};
  }

  // 把render()方法中的this.props.date替换成this.state.date
  render() {
    return (<div><h2>It is {this.state.date.toLocaleTimeString()}.</h2></div>);
  }
}

ReactDOM.render(
  <Clock />,   // 移除Clock元素中的date属性
  document.getElementById('root')
);

</textarea><pre>
将生命周期方法添加到Class中
在具有许多组件的应用程序中,当组件被销毁时释放所占用的资源是非常重要的。
当Clock组件第一次被渲染到DOM中的时候就为其设置一个计时器。这在React中被称为“挂载(mount)”。
同时当DOM中Clock组件被删除的时候,应该清除计时器。这在React中被称为“卸载(unmount)”。
可以为class组件声明一些特殊的方法,当组件挂载或卸载时就会去执行这些方法,这些方法叫做“生命周期方法”

生命周期分为三大类
组件初始化(创建):constructor -> render -> React更新DOM和refs -> componentDidMount
组件更新: new props/setState()/forceUpdate() -> render -> React更新DOM和refs -> componentDidUpdate
组件卸载:componentWillUnmount

组件的生命周期分成三个状态：
Mounting：已插入真实 DOM
Updating：正在被重新渲染
Unmounting：已移出真实 DOM

React为每个状态都提供了两种处理函数,will函数在进入状态之前调用,did函数在进入状态之后调用,三种状态共计五种处理函数。
componentWillMount()
componentDidMount()
componentWillUpdate(object nextProps, object nextState)
componentDidUpdate(object prevProps, object prevState)
componentWillUnmount()

此外React还提供两种特殊状态的处理函数
componentWillReceiveProps(object nextProps)：已加载组件收到新的参数时调用
shouldComponentUpdate(object nextProps, object nextState)：组件判断是否重新渲染时调用

组件的数据来源通常是通过Ajax请求从服务器获取,可以使用componentDidMount方法设置Ajax请求,等到请求成功再用this.setState方法重新渲染UI
在 componentDidMount这个生命周期函数中发起AJAX请求,这样可以拿到AJAX请求返回的数据并通过setState来更新组件

</textarea><textarea>
class MyComponent extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      error: null,
      isLoaded: false,
      items: []
    };
  }

  componentDidMount() {
    fetch("https://api.example.com/items")
      .then(res => res.json())
      .then(
        (result) => {
          this.setState({
            isLoaded: true,
            items: result.items
          });
        },
        // 需要在此处处理错误,而不是使用 catch() 去捕获错误,因为使用catch去捕获异常会掩盖掉组件本身可能产生的bug
        (error) => {
          this.setState({
            isLoaded: true,
            error
          });
        }
      )
  }

  render() {
    const { error, isLoaded, items } = this.state;
    if (error) {
      return <div>Error: {error.message}</div>;
    } else if (!isLoaded) {
      return <div>Loading...</div>;
    } else {
      return (
        <ul>
          {items.map(item => (
            <li key={item.name}>{item.name} {item.price}</li>
          ))}
        </ul>
      );
    }
  }
}

</textarea><textarea>
import 'bootstrap.css'

class Clock extends React.Component {
  constructor(props) {
    super(props);
    this.state = {date: new Date()};
  }
  
  // componentDidMount()方法会在组件已经被渲染到DOM中后运行,所以最好在这里设置计时器,把计时器的ID保存在this之中
  // 尽管this.props和this.state是React本身设置的,且都拥有特殊的含义,但其实可向class中随意添加不参与数据流(比如计时器ID)的额外字段
  componentDidMount() {
    this.timerID = setInterval(() => this.tick(), 1000);
  }

  // 在componentWillUnmount()生命周期方法中清除计时器
  componentWillUnmount() {
    clearInterval(this.timerID);
  }
  
  // 实现一个叫tick()的方法,Clock组件每秒都会调用它,使用this.setState()来时刻更新组件state
  tick() {
    this.setState({date: new Date()});
  }

  componentDidUpdate(prevProps, state){
    console.log(state)
  }

  render() {
    return (
      <div className="clock-component jumbotron">
        <h1>{this.state.date.toLocaleTimeString()}</h1>
      </div>
    );
  }
}

ReactDOM.render(
  <Clock />,
  document.getElementById('root')
);

</textarea><pre>
现在时钟每秒都会刷新,概括一下发生了什么和这些方法的调用顺序：
当Clock被传给ReactDOM.render()时,React会调用Clock组件的构造函数。因为Clock需要显示当前的时间,所以它会用一个包含当前时间的对象来初始化this.state,会在之后更新state。
之后React会调用组件的render()方法,这就是React确定该在页面上展示什么的方式,然后React更新DOM来匹配Clock渲染的输出。
当Clock的输出被插入到DOM中后,React就会调用ComponentDidMount()生命周期方法。在这个方法中Clock组件向浏览器请求设置一个计时器来每秒调用一次组件的tick()方法。
浏览器每秒都会调用一次tick()方法,在这方法之中Clock组件会通过调用setState()来计划进行一次UI更新。得益于setState()的调用,React能够知道state已经改变了,然后会重新调用render()方法来确定页面上该显示什么。这一次render()方法中的this.state.date就不一样了,如此就会渲染输出更新过的时间,React也会相应的更新DOM。
一旦Clock组件从DOM中被移除,React就会调用componentWillUnmount()生命周期方法,这样计时器就停止了。

不要直接修改State,这样不会重新渲染组件,而是应该使用setState(),构造函数是唯一可以给this.state赋值的地方
this.state.comment = 'Hello';
this.setState({comment: 'Hello'});

State的更新可能是异步的
出于性能考虑,React可能会把多个setState()调用合并成一个调用。
在开始重新渲染之前React会有意地进行等待,直到所有在组件的事件处理函数内调用的setState()完成之后,这样可以通过避免不必要的重新渲染来提升性能。
因为this.props和this.state可能会异步更新,所以不要依赖他们的值来更新下一个状态。
例如此代码可能会无法更新计数器：
this.setState({counter: this.state.counter + this.props.increment});
解决方法：可以让setState()接收一个函数而不是一个对象,这个函数用上一个state作为第一个参数,将此次更新被应用时的props做为第二个参数：
this.setState((state, props) => ({counter: state.co unter + props.increment}));

</textarea>传递一个函数可以在函数内访问到当前的state的值。因为setState的调用是分批的,所以可以链式地进行更新,并确保它们是一个建立在另一个之上的,这样才不会发生冲突<textarea>
incrementCount() {
  this.setState((state) => ({count: state.count + 1})) // 在更新的时候读取 `state`,而不是 `this.state`
}

handleSomething() {
  // 假设 `this.state.count` 从 0 开始。
  this.incrementCount();
  this.incrementCount();
  this.incrementCount();
  // 如果现在在这里读取`this.state.count`,它还是会为0,但当React重新渲染该组件时它会变为3。
}

</textarea><pre>
setState什么时候是异步的？
目前在事件处理函数内部的setState是异步的。
例如如果Parent和Child在同一个click事件中都调用了setState ,这样就可以确保Child不会被重新渲染两次。取而代之的是React会将该state冲洗到浏览器事件结束的时候,再统一地进行更新,这种机制可以在大型应用中得到很好的性能提升。
这只是一个实现的细节,所以请不要直接依赖于这种机制。在以后的版本当中,React会在更多的情况下静默地使用state的批更新机制。

State的更新会被合并
当调用setState()的时候React会把提供的对象合并到当前的state。

例如state包含几个独立的变量：
constructor(props) {
  super(props);
  this.state = {posts: [], comments: []};
}
然后可以分别调用setState()来单独地更新它们：
componentDidMount() {
  fetchPosts().then(response => this.setState({ posts: response.posts })});
  fetchComments().then(response => this.setState({ comments: response.comments }));
}
这里的合并是浅合并,所以this.setState({comments})完整保留了this.state.posts,但完全替换了this.state.comments。

数据是向下流动的
不管是父组件或子组件都无法知道某个组件是有状态的还是无状态的,并且它们也并不关心它是函数组件还是class组件。
这就是为什么称state为局部的或封装的的原因。除了拥有并设置了它的组件,其他组件都无法访问。
组件可以选择把它的state作为props向下传递到它的子组件中：
< h2>It is {this.state.date.toLocaleTimeString()}.< /h2>
这对于自定义组件同样适用,FormattedDate组件会在其props中接收参数date,但组件本身无法知道它是来自于Clock的state或Clock的props,还是手动输入的：
< FormattedDate date={this.state.date} />
function FormattedDate(props) {
  return < h2>It is {props.date.toLocaleTimeString()}.< /h2>;
}

这通常会被叫做“自上而下”或“单向”的数据流。任何的state总是所属于特定的组件,而且从该state派生的任何数据或UI只能影响树中“低于”它们的组件。
如果把一个以组件构成的树想象成一个props的数据瀑布的话,那么每一个组件的state就像是在任意一点上给瀑布增加额外的水源,但它只能向下流动。
在React应用中组件是有状态组件还是无状态组件属于组件实现的细节,它可能会随着时间的推移而改变,可以在有状态的组件中使用无状态的组件,反之亦然

</textarea>为了证明每个组件都是真正独立的,可以创建一个渲染三个Clock的App组件,每个Clock组件都会单独设置它自己的计时器并且更新它<textarea>
function App() {
  return (
    <div>
      <Clock />
      <Clock />
      <Clock />
    </div>
  );
}

ReactDOM.render(
  <App />,
  document.getElementById('root')
);

</textarea><pre>
【 setState() 】
setState(updater[, callback]) 
setState()将对组件state的更改排入队列,并通知React需要使用更新后的state重新渲染此组件及其子组件。这是用于更新用户界面以响应事件处理器和处理服务器数据的主要方式

将setState()视为请求而不是立即更新组件的命令。为了更好的感知性能,React会延迟调用它,然后通过一次传递更新多个组件。React并不会保证state的变更会立即生效。

setState()并不总是立即更新组件。它会批量推迟更新。这使得在调用setState()后立即读取this.state成为了隐患。为了消除隐患,请使用componentDidUpdate或setState的回调函数(setState(updater, callback)),这两种方式都可以保证在应用更新后触发。如需基于之前的stat 来设置当前的state,请阅读下述关于参数updater的内容。

除非shouldComponentUpdate()返回false,否则setState()将始终执行重新渲染操作。如果可变对象被使用,且无法在shouldComponentUpdate()中实现条件渲染,那么仅在新旧状态不一时调用setState()可以避免不必要的重新渲染

参数一为带有形式参数的updater函数：
(state, props) => stateChange
state是对应用变化时组件状态的引用。当然它不应直接被修改。应该使用基于state和props构建的新对象来表示变化。例如根据props.step来增加state：
this.setState((state, props) => {
  return {counter: state.counter + props.step};
});
updater函数中接收的state和props都保证为最新。updater的返回值会与state进行浅合并。

setState()的第二个参数为可选的回调函数,它将在setState完成合并并重新渲染组件后执行。通常建议使用componentDidUpdate()来代替此方式。

setState()的第一个参数除了接受函数外,还可以接受对象类型：
setState(stateChange[, callback])
stateChange 会将传入的对象浅层合并到新的state中,例如调整购物车商品数：
this.setState({quantity: 2})
这种形式的setState()也是异步的,并且在同一周期内会对多个setState进行批处理。例如如果在同一周期内多次设置商品数量增加,则相当于：
Object.assign(
  previousState,
  {quantity: state.quantity + 1},
  {quantity: state.quantity + 1},
  ...
)
后调用的setState()将覆盖同一周期内先调用setState的值,因此商品数仅增加一次。如果后续状态取决于当前状态,建议使用updater函数的形式代替：
this.setState((state) => {
  return {quantity: state.quantity + 1};
});

</textarea>
</div>

<div id="event">
<h4>事件处理</h4><pre>
React元素的事件处理和DOM元素的很相似,但有一点语法上的不同:
React事件的命名采用小驼峰式(camelCase),而不是纯小写。
使用JSX语法时需要传入一个函数作为事件处理函数,而不是一个字符串。

传统的HTML：
< button onclick="activateLasers()">Activate Lasers< /button>
在React中略微不同：
< button onClick={activateLasers}>Activate Lasers< /button>

在React中另一个不同点是不能通过返回false的方式阻止默认行为,必须显式的使用preventDefault

</textarea><textarea>
// 传统的HTML中阻止链接默认打开一个新页面：
<a href="#" onclick="console.log('The link was clicked.'); return false">Click me</a>

// 在React中可能是这样的：
function ActionLink() {
  function handleClick(e) {
    e.preventDefault();
    console.log('The link was clicked.');
  }

  return (
    <a href="#" onClick={handleClick}>Click me</a>
  );
}

</textarea><pre>
e是一个合成事件对象,React根据W3C规范来定义这些合成事件,所以不需要担心跨浏览器的兼容性问题
使用React时一般不需要使用addEventListener为已创建的DOM元素添加监听器,事实上只需要在该元素初始渲染的时候添加监听器即可。

当使用class语法定义一个组件时,通常的做法是将事件处理函数声明为class中的方法。

必须谨慎对待JSX回调函数中的this,在js中class的方法默认不会绑定this。如果忘记绑定this.handleClick并把它传入了onClick,当调用这个函数的时候this的值为undefined。
这并不是React特有行为;这其实与js函数工作原理有关。通常情况下如果没有在方法后面添加()例如onClick={this.handleClick},应该为这个方法绑定this。

</textarea><textarea>
// Toggle组件会渲染一个让用户切换开关状态的按钮
class Toggle extends React.Component {
  constructor(props) {
    super(props);
    this.state = {isToggleOn: true};
    this.handleClick1 = this.handleClick1.bind(this);  // 为了在回调中使用`this`,这个绑定是必不可少的
  }

  handleClick1() {
    console.log('this is:', this);
    this.setState(state => ({isToggleOn: !state.isToggleOn}));  // 箭头函数不用花括号返回对象时需用括号包裹
  } 

  handleClick2() {
    console.log('this is:', this);
  }

  // class fields语法确保`handleClick`内的`this`已被绑定
  handleClick3 = (e) => {
    console.log('this is:', this);
    console.log(e, e.target)
  }

  render() {
    return (
      <div>
        <button onClick={this.handleClick1}>{this.state.isToggleOn ? 'ON' : 'OFF'}</button>
        <button onClick={this.handleClick2.bind(this)}>Function.prototype.bind</button>
        <button onClick={(e) => this.handleClick2(e)}>在回调中使用箭头函数</button>
        <button onClick={this.handleClick3}>箭头函数</button>
      </div>
    )
  }
}

ReactDOM.render(
  <Toggle />,
  document.getElementById('root')
);

</textarea><pre>
onClick={(e) => this.handleClick2(e)}语法问题在于每次渲染时都会创建不同的回调函数。在大多数情况下这没什么问题,但如果该回调函数作为prop传入子组件时,这些组件可能会进行额外的重新渲染。通常建议在构造器中绑定或使用class fields语法来避免这类性能问题。

向事件处理程序传递参数
通常会为事件处理函数传递额外的参数,如id是要删除那一行的ID,以下通过箭头函数和Function.prototype.bind两种方式都可以向事件处理函数传递参数：
< button onClick={(e) => this.deleteRow(id, e)}>Delete Row< /button>
< button onClick={this.deleteRow.bind(this,id)}>Delete Row< /button>

在这两种情况下,React的事件对象e会被作为第二个参数传递。如果通过箭头函数的方式,事件对象必须显式的进行传递,而通过bind的方式,事件对象以及更多的参数将会被隐式的进行传递。

如何将事件处理器(比如onClick)传递给组件？
可以将事件处理器和其他函数作为props传递给子组件：
< button onClick={this.handleClick}>
如果需要在事件处理器中访问父组件,还需要为该函数绑定组件实例

如何为函数绑定组件实例？
有以下几种方式可以确保函数可以访问组件属性,比如 this.props 和 this.state,这取决于使用的语法和构建步骤。

</textarea><textarea>
// 在构造函数中绑定(ES2015)
class Foo extends Component {
  constructor(props) {
    super(props);
    this.handleClick = this.handleClick.bind(this);
  }
  handleClick() {
    console.log('Click happened');
  }
  render() {
    return <button onClick={this.handleClick}>Click Me</button>;
  }
}

// class属性
class Foo extends Component {
  handleClick = () => {
    console.log('Click happened');
  }
  render() {
    return <button onClick={this.handleClick}>Click Me</button>;
  }
}

// 在Render中的绑定,在render方法中使用Function.prototype.bind会在每次组件渲染时创建一个新的函数,可能会影响性能
class Foo extends Component {
  handleClick() {
    console.log('Click happened');
  }
  render() {
    return <button onClick={this.handleClick.bind(this)}>Click Me</button>;
  }
}

// 在Render中使用箭头函数,在render方法中使用箭头函数也会在每次组件渲染时创建一个新的函数,这会破坏基于恒等比较的性能优化
class Foo extends Component {
  handleClick() {
    console.log('Click happened');
  }
  render() {
    return <button onClick={ () => this.handleClick() }>Click Me</button>;
  }
}

</textarea><pre>
可以在render方法中使用箭头函数吗？
一般来说是可以的,并且使用箭头函数是向回调函数传递参数的最简单的办法。
但是如果遇到了性能问题,一定要进行优化

为什么绑定是必要的？
在js中以下两种写法是不等价的：
obj.method();
var method = obj.method;
method();
bind方法确保了第二种写法与第一种写法相同
使用React,通常只需要绑定传递给其他组件的方法。例如button onClick={this.handleClick}是在传递this.handleClick,所以需要绑定它。但没有必要绑定render方法或生命周期方法：并没有将它们传递给其他的组件

</textarea>为什么我的函数每次组件渲染时都会被调用？<textarea>
确保在传递一个函数给组件时,没有调用这个函数：
render() {
  // Wrong: handleClick is called instead of passed as a reference!
  return <button onClick={this.handleClick()}>Click Me</button>
}
正确做法是,传递函数本身(不带括号)：
render() {
  // Correct: handleClick is passed as a reference!
  return <button onClick={this.handleClick}>Click Me</button>
}

</textarea><pre>
如何传递参数给事件处理器或回调？
可以使用箭头函数包裹事件处理器,并传递参数:
< button onClick={ () => this.handleClick(id) } />
以上代码和调用 .bind 是等价的：
< button onClick={this.handleClick.bind(this, id)} />

</textarea><textarea>
// 通过箭头函数传递参数
const A = 65 // ASCII character code

class Alphabet extends React.Component {
  constructor(props) {
    super(props);
    this.handleClick = this.handleClick.bind(this);
    this.state = {
      justClicked: null,
      letters: Array.from({length: 26}, (_, i) => String.fromCharCode(A + i))
    };
  }
  handleClick(letter) {
    this.setState({ justClicked: letter });
  }
  render() {
    return (
      <div>
        Just clicked: {this.state.justClicked}
        <ul>
          {this.state.letters.map(letter => <li key={letter} onClick={ () => this.handleClick(letter) }>{letter}</li>)}
        </ul>
      </div>
    )
  }
}

// 通过data-attributes传递参数
// 同样的,也可以使用DOM API来存储事件处理器需要的数据。如果需要优化大量元素或使用依赖于React.PureComponent相等性检查的渲染树,请考虑使用此方法
const A = 65 // ASCII character code

class Alphabet extends React.Component {
  constructor(props) {
    super(props);
    this.handleClick = this.handleClick.bind(this);
    this.state = {
      justClicked: null,
      letters: Array.from({length: 26}, (_, i) => String.fromCharCode(A + i))
    };
  }

  handleClick(e) {
    this.setState({
      justClicked: e.target.dataset.letter
    });
  }

  render() {
    return (
      <div>
        Just clicked: {this.state.justClicked}
        <ul>
          {this.state.letters.map(letter => <li key={letter} data-letter={letter} onClick={this.handleClick}>{letter}</li> )}
        </ul>
      </div>
    )
  }
}

</textarea><pre>
怎样阻止函数被调用太快或者太多次？
如果有一个onClick或onScroll这样的事件处理器,想要阻止回调被触发的太快,那么可以限制执行回调的速度,可以通过以下几种方式做到这点：
节流：基于时间的频率来进行抽样更改 (例如 _.throttle)
防抖：一段时间的不活动之后发布更改 (例如 _.debounce)
requestAnimationFrame 节流：基于requestAnimationFrame的抽样更改 (例如raf-schd)

_.debounce、_.throttle和raf-schd都提供了一个cancel方法来取消延迟回调。需要在componentWillUnmount中调用该方法,或者对代码进行检查来保证在延迟函数有效期间内组件始终挂载

比较throttle和debounce的可视化页面: http://demo.nimius.net/debounce_throttle/

节流
节流阻止函数在给定时间窗口内被调不能超过一次。下面这个例子会节流 “click”事件处理器,使其每秒钟的只能调用一次

</textarea><textarea>
import throttle from 'lodash.throttle';

class LoadMoreButton extends React.Component {
  constructor(props) {
    super(props);
    this.handleClick = this.handleClick.bind(this);
    this.handleClickThrottled = throttle(this.handleClick, 1000);
  }

  componentWillUnmount() {
    this.handleClickThrottled.cancel();
  }

  render() {
    return <button onClick={this.handleClickThrottled}>Load More</button>;
  }

  handleClick() {
    this.props.loadMore();
  }
}

</textarea><pre>
防抖
防抖确保函数不会在上一次被调用之后一定量的时间内被执行。当必须进行一些费时的计算来响应快速派发的事件时(比如鼠标滚动或键盘事件时),防抖是非常有用的。下面这个例子以 250ms 的延迟来改变文本输入

</textarea><textarea>
import debounce from 'lodash.debounce';

class Searchbox extends React.Component {
  constructor(props) {
    super(props);
    this.handleChange = this.handleChange.bind(this);
    this.emitChangeDebounced = debounce(this.emitChange, 250);
  }

  componentWillUnmount() {
    this.emitChangeDebounced.cancel();
  }

  render() {
    return (<input type="text" onChange={this.handleChange} placeholder="Search..." defaultValue={this.props.value} />);
  }

  handleChange(e) {
    // React pools events, so we read the value before debounce.
    // Alternately we could call `event.persist()` and pass the entire event.
    // For more info see reactjs.org/docs/events.html#event-pooling
    this.emitChangeDebounced(e.target.value);
  }

  emitChange(value) {
    this.props.onChange(value);
  }
}
  
</textarea><pre>
requestAnimationFrame节流
requestAnimationFrame是在浏览器中排队等待执行的一种方法,它可以在呈现性能的最佳时间执行。一个函数被requestAnimationFrame放入队列后将会在下一帧触发。浏览器会努力确保每秒60帧(60fps)。然而如果浏览器无法确保,那么自然会限制每秒的帧数。例如某个设备可能只能处理每秒30帧,所以每秒只能得到30帧。使用requestAnimationFrame来节流是一种有用的技术,它可以防止在一秒中进行60帧以上的更新。如果一秒钟内完成100次更新则会为浏览器带来额外的负担,而用却户无法感知到这些工作。
使用这个方法时只能获取某一帧中最后发布的值

</textarea><textarea>
import rafSchedule from 'raf-schd';

class ScrollListener extends React.Component {
  constructor(props) {
    super(props);
    this.handleScroll = this.handleScroll.bind(this);

    // Create a new function to schedule updates.
    this.scheduleUpdate = rafSchedule(
      point => this.props.onScroll(point)
    );
  }

  handleScroll(e) {
    // When we receive a scroll event, schedule an update.
    // If we receive many updates within a frame, we'll only publish the latest value.
    this.scheduleUpdate({ x: e.clientX, y: e.clientY });
  }

  componentWillUnmount() {
    // Cancel any pending updates since we're unmounting.
    this.scheduleUpdate.cancel();
  }

  render() {
    return (
      <div style={{ overflow: 'scroll' }} onScroll={this.handleScroll} >
        <img src="/my-huge-image.jpg" />
      </div>
    );
  }
}

</textarea>
</div>

<div id="render">
<h4>条件渲染</h4><pre>
在React中可以创建不同的组件来封装各种需要的行为,然后依据应用的不同状态,可以只渲染对应状态下的部分内容。
React中的条件渲染和js中的一样,使用js运算符if或条件运算符去创建元素来表现当前的状态,然后让React根据它们来更新UI
如果条件变得过于复杂,那应该考虑如何提取组件

</textarea><textarea>
function UserGreeting(props) {
  return <h1>Welcome back!</h1>;
}

function GuestGreeting(props) {
  return <h1>Please sign up.</h1>;
}

// Greeting组件会根据用户是否登录来决定显示上面的哪一个组件,根据isLoggedIn的值来渲染不同的问候语
function Greeting(props) { 
  if (props.isLoggedIn) return <UserGreeting />;
  return <GuestGreeting />;
}

ReactDOM.render(
  <Greeting isLoggedIn={false} />,  // Try changing to isLoggedIn={true}:
  document.getElementById('root')
);

function LoginButton(props) {
  return (<button onClick={props.onClick}>Login</button>);
}

function LogoutButton(props) {
  return (<button onClick={props.onClick}>Logout</button>);
}

// 创建一个名叫LoginControl的有状态的组件,根据当前的状态来渲染LoginButton或LogoutButton,同时它还会渲染上一个示例中的Greeting
class LoginControl extends React.Component {
  constructor(props) {
    super(props);
    this.handleLoginClick = this.handleLoginClick.bind(this);
    this.handleLogoutClick = this.handleLogoutClick.bind(this);
    this.state = {isLoggedIn: false};
  }

  handleLoginClick() {
    this.setState({isLoggedIn: true});
  }

  handleLogoutClick() {
    this.setState({isLoggedIn: false});
  }

  render() {
    const {isLoggedIn} = this.state;
    let button;
    if (isLoggedIn) {
      button = <LogoutButton onClick={this.handleLogoutClick} />;
    } else {
      button = <LoginButton onClick={this.handleLoginClick} />;
    }

    return (
      <div>
        <Greeting isLoggedIn={isLoggedIn} />
        {button}
      </div>
    );
  }
}

ReactDOM.render(
  <LoginControl />,
  document.getElementById('root')
);

</textarea>声明一个变量并使用if语句进行条件渲染是不错的方式,以下是几种在JSX中内联条件渲染的方法<textarea>
// 1、与运算符&&,通过花括号包裹代码可以在JSX中嵌入任何表达式,包括js中的逻辑与(&&)运算符,它可以很方便地进行元素的条件渲染。
function Mailbox(props) {
  const unreadMessages = props.unreadMessages;
  return (<div>{unreadMessages.length > 0 && <h2>You have {unreadMessages.length} unread messages.</h2>}</div>);
}

const messages = ['React', 'Re: React', 'Re:Re: React'];
ReactDOM.render(
  <Mailbox unreadMessages={messages} />,
  document.getElementById('root')
);

// 2、三目运算符
render() {
  const isLoggedIn = this.state.isLoggedIn;
  return (<div>The user is <b>{isLoggedIn ? 'currently' : 'not'}</b> logged in</div>);
}

render() {
  const isLoggedIn = this.state.isLoggedIn;
  return (
    <div>
      {isLoggedIn ? (<LogoutButton onClick={this.handleLogoutClick} />) : (<LoginButton onClick={this.handleLoginClick} />)}
    </div>
  );
}

</textarea><pre>
阻止组件渲染
在极少数情况下可能希望能隐藏组件,即使它已经被其他组件渲染。若要完成此操作可以让render方法直接返回null,而不进行任何渲染。
在组件的render方法中返回null并不会影响组件的生命周期,例如下面示例中componentDidUpdate依然会被调用

</textarea><textarea>
// WarningBanner会根据prop中warn的值来进行条件渲染。如果warn的值是false,那么组件则不会渲染:
function WarningBanner(props) {
  if (!props.warn) return null;
  return (<div className="warning">Warning!</div>);
}

class Page extends React.Component {
  constructor(props) {
    super(props);
    this.state = {showWarning: true};
    this.handleToggleClick = this.handleToggleClick.bind(this);
  }

  handleToggleClick() {
    this.setState(state => ({showWarning: !state.showWarning}));
  }

  render() {
    return (
      <div>
        <WarningBanner warn={this.state.showWarning} />
        <button onClick={this.handleToggleClick}>{this.state.showWarning ? 'Hide' : 'Show'}</button>
      </div>
    );
  }
}

ReactDOM.render(
  <Page />,
  document.getElementById('root')
);

</textarea>
</div>

<div id="list">
<h4>列表 & Key</h4><pre>
渲染多个组件
可以通过使用{}在JSX内构建一个元素集合

</textarea><textarea>
// 使用js中的map()方法来遍历numbers数组,将数组中的每个元素变成li标签,最后将得到的数组赋值给listItems
const numbers = [1, 2, 3, 4, 5];
const listItems = numbers.map((number) => <li>{number}</li>);
// 把整个listItems插入到ul元素中,然后渲染进DOM
ReactDOM.render(
  <ul>{listItems}</ul>,
  document.getElementById('root')
);

</textarea><pre>
在map()方法中的元素需要设置key属性
没有指定key运行代码,将会看到一个警告a key should be provided for list items
key帮助React识别哪些元素改变了,比如被添加或删除,因此应当给数组中的每一个元素赋予一个确定的标识
一个元素的key最好是这个元素在列表中拥有的一个独一无二的字符串,通常使用数据中的id来作为元素的key
当元素没有确定id的时候,万不得已可以使用元素索引index作为key
如果列表项目的顺序可能会变化,不建议使用索引来用作key值,因为这样做会导致性能变差,还可能引起组件状态的问题。如果选择不指定显式的key值,那么React将默认使用索引用作为列表项目的key值

</textarea>重构成一个组件,这个组件接收numbers数组作为参数并输出一个元素列表<textarea>
function NumberList(props) {
  const numbers = props.numbers;
  const listItems = numbers.map((number) => <li key={number.toString()}>{number}</li>);
  return (<ul>{listItems}</ul>);
}

const numbers = [1, 2, 3, 4, 5];
ReactDOM.render(
  <NumberList numbers={numbers} />,
  document.getElementById('root')
);

</textarea><pre>
用key提取组件
元素的key只有放在就近的数组上下文中才有意义,比方提取出一个ListItem组件,应把key保留在数组中的这个ListItem元素上,而不是放在ListItem组件中的li元素上

</textarea><textarea>
function ListItem(props) {
  return <li>{props.value}</li>;  // 正确！这里不需要指定key
}

function NumberList(props) {
  const numbers = props.numbers;
  const listItems = numbers.map((number) =>
    <ListItem key={number.toString()} value={number} />  // 正确！key应该在数组的上下文中被指定
  );
  return (<ul>{listItems}</ul>);
}

const numbers = [1, 2, 3, 4, 5];
ReactDOM.render(
  <NumberList numbers={numbers} />,
  document.getElementById('root')
);

</textarea><pre>
key只是在兄弟节点之间必须唯一
数组元素中使用的key在其兄弟节点之间应该是独一无二的,然而它们不需要是全局唯一的。当生成两个不同的数组时可以使用相同的key值

</textarea><textarea>
function Blog(props) {
  const sidebar = (<ul>{props.posts.map((post) => <li key={post.id}>{post.title}</li>)}</ul>);
  const content = props.posts.map((post) =>
    <div key={post.id}>
      <h3>{post.title}</h3>
      <p>{post.content}</p>
    </div>
  );
  return (
    <div>{sidebar}<hr />{content}</div>
  );
}

const posts = [
  {id: 1, title: 'Hello World', content: 'Welcome to learning React!'},
  {id: 2, title: 'Installation', content: 'You can install React from npm.'}
];
ReactDOM.render(
  <Blog posts={posts} />,
  document.getElementById('root')
);

</textarea>
</div>

<div id="form">
<h4>表单</h4><pre>
React中HTML表单元素的工作方式和其他的DOM元素有些不同,这是因为表单元素通常会保持一些内部的state

</textarea><textarea>
<form>
  <label>名字:<input type="text" name="name" /></label>
  <input type="submit" value="提交" />
</form>

</textarea><pre>
此表单具有默认的HTML表单行为,即在用户提交表单后浏览到新页面。如果在React中执行相同的代码它依然有效。但大多数情况下使用js函数可以很方便的处理表单的提交,同时还可以访问用户填写的表单数据,实现这种效果的标准方式是使用“受控组件”。

受控组件
在HTML中表单元素如input、textarea和select之类的表单元素通常自己维护state,并根据用户输入进行更新。而在React中可变状态(mutable state)通常保存在组件的state属性中,并且只能通过使用setState()来更新。

可以把两者结合起来,使React的state成为唯一数据源。渲染表单的React组件还控制着用户输入过程中表单发生的操作。被React以这种方式控制取值的表单输入元素就叫做“受控组件”

例如如果想让输入框在提交时打印出名称,可以将表单写为受控组件：
由于在表单元素上设置了value属性,因此显示的值将始终为this.state.value,这使得React的state成为唯一数据源。由于handlechange在每次按键时都会执行并更新React的state,因此显示的值将随着用户输入而更新。
对于受控组件来说,每个state突变都有一个相关的处理函数,这使得修改或验证用户输入变得简单

</textarea><textarea>
class CommentForm extends React.Component {
  constructor(props) {
    super(props);
    this.state = {value: ''};
    this.handleChange = this.handleChange.bind(this);
    this.handleSubmit = this.handleSubmit.bind(this);
  }

  handleChange(event) {
    this.setState({value: event.target.value.toUpperCase()});
  }

  handleSubmit(event) {
    alert('留言内容: ' + this.state.value);
    event.preventDefault();
  }

  render() {
    return (
      <form className="p-5" onSubmit={this.handleSubmit}>
        <div className="form-group">
          <label>留言内容</label>
          <input className="form-control" type="text" value={this.state.value} onChange={this.handleChange} placeholder="请输入内容" />
        </div>
        <input type="submit" className="btn btn-primary" value="提交" />
      </form>
    );
  }
}

</textarea><pre>
textarea标签
HTML中textarea元素通过其子元素即标签之间的文本定义其文本
而React中textarea使用value属性代替,这样可以使得使用textarea的表单和使用单行input的表单非常类似：

</textarea><textarea>
class EssayForm extends React.Component {
  constructor(props) {
    super(props);
    this.state = {value: '请撰写一篇关于你喜欢的 DOM 元素的文章.'};  // this.state.value 初始化于构造函数中,因此文本区域默认有初值
    this.handleChange = this.handleChange.bind(this);
    this.handleSubmit = this.handleSubmit.bind(this);
  }

  handleChange(event) {
    this.setState({value: event.target.value});
  }

  handleSubmit(event) {
    alert('提交的文章: ' + this.state.value);
    event.preventDefault();
  }

  render() {
    return (
      <form onSubmit={this.handleSubmit}>
        <label>文章:< textarea value={this.state.value} onChange={this.handleChange} /></label>
        <input type="submit" value="提交" />
      </form>
    );
  }
}

</textarea><pre>
select标签
HTML中select创建下拉列表标签

</textarea><textarea>
<select>
  <option value="grapefruit">葡萄柚</option>
  <option value="lime">酸橙</option>
  <option selected value="coconut">椰子</option>
  <option value="mango">芒果</option>
</select>

</textarea><pre>
由于selected属性的缘故,椰子选项默认被选中。React并不会使用selected属性,而是在根select标签上使用value属性。这在受控组件中更便捷,因为只需要在根标签中更新它

</textarea>可以将数组传递到value属性中以支持在select标签中选择多个选项<textarea>
<select multiple={true} value={['B', 'C']}>

class FlavorForm extends React.Component {
  constructor(props) {
    super(props);
    this.state = {value: 'coconut'};
    this.handleChange = this.handleChange.bind(this);
    this.handleSubmit = this.handleSubmit.bind(this);
  }

  handleChange(event) {
    this.setState({value: event.target.value});
  }

  handleSubmit(event) {
    alert('你喜欢的风味是: ' + this.state.value);
    event.preventDefault();
  }

  render() {
    return (
      <form onSubmit={this.handleSubmit}>
        <label>选择喜欢的风味:
          <select value={this.state.value} onChange={this.handleChange}>
            <option value="grapefruit">葡萄柚</option>
            <option value="lime">酸橙</option>
            <option value="coconut">椰子</option>
            <option value="mango">芒果</option>
          </select>
        </label>
        <input type="submit" value="提交" />
      </form>
    );
  }
}

</textarea><pre>
文件input标签
在HTML中input type=“file”允许用户从存储设备中选择一个或多个文件,将其上传到服务器,或通过使用js的File API进行控制。因为它的value只读,所以它是React中的一个非受控组件

处理多个输入
当需要处理多个input元素时可以给每个元素添加name属性,并让处理函数根据event.target.name的值选择要执行的操作。

</textarea><textarea>
class Reservation extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      isGoing: true,
      numberOfGuests: 2
    };
    this.handleInputChange = this.handleInputChange.bind(this);
  }
  
  // 由于setState()自动将部分state合并到当前state,只需调用它更改部分state即可
  handleInputChange(event) {
    const target = event.target;
    const value = target.type === 'checkbox' ? target.checked : target.value;
    const name = target.name;
    this.setState({[name]: value});  // 使用了ES6计算属性名称的语法更新给定输入名称对应的state值
    /*
    等同 ES5:
    var partialState = {};
    partialState[name] = value;
    this.setState(partialState);
     */
  }

  render() {
    return (
      <form>
        <label>参与:
          <input name="isGoing" type="checkbox" checked={this.state.isGoing} onChange={this.handleInputChange} />
        </label>
        <br />
        <label>来宾人数:
          <input name="numberOfGuests" type="number" value={this.state.numberOfGuests} onChange={this.handleInputChange} />
        </label>
      </form>
    );
  }
}

</textarea><pre>
受控输入空值
在受控组件上指定value的prop可以防止用户更改输入。如果指定了value,但输入仍可编辑,则可能是意外地将value设置为undefined或null。

</textarea>输入最初被锁定,但在短时间延迟后变为可编辑<textarea>
ReactDOM.render(<input value="hi" />, mountNode);

setTimeout(function() {
  ReactDOM.render(<input value={null} />, mountNode);
}, 1000);

</textarea><pre>
受控组件的替代品
有时使用受控组件会很麻烦,因为需要为数据变化的每种方式都编写事件处理函数,并通过一个React组件传递所有的输入state。当将之前的代码库转换为React或将React应用程序与非React库集成时可能会令人厌烦。在这些情况下可能希望使用非受控组件,这是实现输入表单的另一种方式
非受控组件将数据隐藏在DOM中

</textarea><textarea>
class CommentForm extends React.Component {
  constructor(props) {
    super(props);
    this.handleSubmit = this.handleSubmit.bind(this);
  }

  handleSubmit(event) {
    alert('留言内容: ' + this.textInput.value);
    event.preventDefault();
  }

  render() {
    return (
      <form className="p-5" onSubmit={this.handleSubmit}>
        <div className="form-group">
          <label>留言内容</label>
          <input ref={(textInput) => {this.textInput = textInput}} className="form-control" placeholder="请输入内容" />
        </div>
        <input type="submit" className="btn btn-primary" value="提交" />
      </form>
    );
  }
}

</textarea><pre>
成熟的解决方案
如果想寻找包含验证、追踪访问字段及处理表单提交的完整解决方案,使用Formik是不错的选择,然而它也是建立在受控组件和管理state的基础上

</textarea>
</div>

<div id="lifting_state_up">
<h4>状态提升 lifting state up</h4><pre>
通常多个组件需要反映相同的变化数据时建议将共享状态提升到最近的共同父组件中去
React中将多个组件中需要共享的state向上移动到它们的最近共同父组件中,便可实现共享state,这就是所谓的“状态提升”

实例：留言
CommentList.js 父组件通过props传递
CommentBox.js 通过事件带参数通知父组件更新状态,父组件更新导致所有子组件自动同步更新
App.js state:{comments:[]}

</textarea><textarea>
// 创建计算水在给定温度下是否沸腾的温度计算器即BoilingVerdict组件,接受celsius温度作为prop,并据此打印出该温度是否足以将水煮沸的结果。
function BoilingVerdict(props) {
  if (props.celsius >= 100) return <p>The water would boil.</p>;
  return <p>The water would not boil.</p>;
}

// 创建名为Calculator的组件,渲染一个用于输入温度的input,并将其值保存在this.state.temperature,它根据当前输入值渲染BoilingVerdict组件。
class Calculator extends React.Component {
  constructor(props) {
    super(props);
    this.handleChange = this.handleChange.bind(this);
    this.state = {temperature: ''};
  }

  handleChange(e) {
    this.setState({temperature: e.target.value});
  }

  render() {
    const temperature = this.state.temperature;
    return (
      <div>
        Enter temperature in Celsius
        <input value={temperature} onChange={this.handleChange} />
        <BoilingVerdict celsius={parseFloat(temperature)} />
      </div>
    )
  }
}

</textarea><pre>
新需求
在已有摄氏温度输入框的基础上,提供华氏度的输入框,并保持两个输入框的数据同步。
先从Calculator组件中抽离出TemperatureInput组件,然后为其添加一个新的type prop,它可以是"celsius"或"fahrenheit"：
现在有了两个输入框,但当在其中一个输入温度时,另一个并不会更新。另外也不能通过Calculator组件展示BoilingVerdict组件的渲染结果,因为Calculator组件并不知道隐藏在TemperatureInput组件中的当前温度是多少

状态提升
目前两个TemperatureInput组件均在各自内部的state中相互独立地保存着各自的数据,希望两个输入框内的数值彼此能够同步,当更新摄氏度输入框内的数值时,华氏度输入框内应当显示转换后的华氏温度,反之亦然。
状态提升,将TemperatureInput组件中的state移动至Calculator组件,如果Calculator组件拥有了共享的state,它将成为两个温度输入框中当前温度的“数据源”,它能够使得两个温度输入框的数值彼此保持一致。由于两个TemperatureInput组件的props均来自共同的父组件Calculator,因此两个输入框中的内容将始终保持一致。

TemperatureInput组件移除自身的state,通过使用this.props.temperature替代this.state.temperature来读取温度数据。当想要响应数据改变时需要调用Calculator组件提供的this.props.onTemperatureChange(),而不再使用this.setState()。
onTemperatureChange的prop和temperature的prop一样,均由父组件Calculator提供。它通过修改父组件自身的内部state来处理数据的变化,进而使用新的数值重新渲染两个输入框

Calculator组件把当前输入的temperature和scale保存在组件内部的state中。这个state就是从两个输入框组件中“提升”而来的,并且它将用作两个输入框组件的共同“数据源”。这是为了渲染两个输入框所需要的所有数据的最小表示。
例如当在摄氏度输入框中键入37时,Calculator组件中的state将会是{temperature: '37',scale: 'c'}
如果之后修改华氏度的输入框中的内容为212时,Calculator组件中的state将会是{temperature: '212',scale: 'f'}
可以存储两个输入框中的值,但这并不是必要的。只需要存储最近修改的温度及其计量单位即可,根据当前的temperature和scale就可以计算出另一个输入框的值
由于两个输入框中的数值由同一个state计算而来,因此它们始终保持同步
现在无论编辑哪个输入框中的内容,Calculator组件中的this.state.temperature和this.state.scale均会被更新,其中一个输入框保留用户的输入并取值,另一个输入框始终基于这个值显示转换后的结果。

</textarea><textarea>
function BoilingVerdict(props) {
  if (props.celsius >= 100) return <p>The water would boil.</p>;
  return <p>The water would not boil.</p>;
}

class TemperatureInput extends React.Component {
  handleChange(e) {
    this.props.onTemperatureChange(e.target.value);
  }

  render() {
    const {temperature, type} = this.props
    return (<div>Enter temperature in {type} <input value={temperature} onChange={this.handleChange.bind(this)} /></div>);
  }
}

class Calculator extends React.Component {
  constructor(props) {
    super(props);
    this.state = {temperature: '', type: 'celsius'};
  }
  // 转换函数,在摄氏度与华氏度之间相互转换的函数,仅做数值转换
  toCelsius(fahrenheit){
    return (fahrenheit - 32) * 5 / 9
  }
  toFahrenheit(celsius){
    return (celsius * 9 / 5) + 32
  }
  // 该函数接受字符串类型的temperature和转换函数作为参数并返回一个字符串,将使用它来依据一个输入框的值计算出另一个输入框的值。
  tryConvert(temperature, convert) {
    const input = parseFloat(temperature);
    if (Number.isNaN(input)) return '';   // 当输入temperature的值无效时函数返回空字符串
    const output = convert(input);
    const rounded = Math.round(output * 1000) / 1000;  // 返回保留三位小数并四舍五入后的转换结果
    return rounded.toString();
  }

  handleCelsiusChange(temperature) {
    this.setState({type: 'celsius', temperature});
  }

  handleFahrenheitChange(temperature) {
    this.setState({type: 'fahrenheit', temperature});
  }

  render() {
    const {type, temperature} = this.state
    const celsius = type === 'fahrenheit' ? this.tryConvert(temperature, this.toCelsius) : temperature;
    const fahrenheit = type === 'celsius' ? this.tryConvert(temperature, this.toFahrenheit) : temperature;
    
    // 渲染两个独立的温度输入框组件
    return (
      <div>
        <TemperatureInput type="celsius" temperature={celsius} onTemperatureChange={this.handleCelsiusChange.bind(this)} />
        <TemperatureInput type="fahrenheit" temperature={fahrenheit} onTemperatureChange={this.handleFahrenheitChange.bind(this)} />
        <BoilingVerdict celsius={parseFloat(celsius)} />
      </div>
    );
  }
}

ReactDOM.render(
  <Calculator />,
  document.getElementById('root')
);

</textarea><pre>
梳理一下当对输入框内容进行编辑时会发生些什么：
React会调用DOM中input的onChange方法,即TemperatureInput组件的handleChange方法,handleChange方法会调用this.props.onTemperatureChange(),并传入新输入的值作为参数。其props诸如onTemperatureChange之类均由父组件Calculator提供。
起初渲染时,用于摄氏度输入的子组件TemperatureInput中onTemperatureChange方法为Calculator组件中的handleCelsiusChange方法,而用于华氏度输入的子组件TemperatureInput中的onTemperatureChange方法为Calculator组件中的handleFahrenheitChange方法。因此无论哪个输入框被编辑都会调用Calculator组件中对应的方法。
在这些方法内部Calculator组件通过使用新的输入值与当前输入框对应的温度计量单位来调用this.setState()进而请求React重新渲染自己本身。
React调用Calculator组件的render方法得到组件的UI呈现。温度转换在这时进行,两个输入框中的数值通过当前输入温度和其计量单位来重新计算获得。
React使用Calculator组件提供的新props分别调用两个TemperatureInput子组件的render方法来获取子组件的UI呈现。
React调用BoilingVerdict组件的render方法,并将摄氏温度值以组件props方式传入。
React DOM根据输入值匹配水是否沸腾,并将结果更新至DOM。刚刚编辑的输入框接收其当前值,另一个输入框内容更新为转换后的温度值。
得益于每次的更新都经历相同的步骤,两个输入框的内容才能始终保持同步

在React应用中任何可变数据应当只有一个相对应的唯一“数据源”。通常state都是首先添加到需要渲染数据的组件中去。然后如果其他组件也需要这个state,那么可以将它提升至这些组件的最近共同父组件中。应当依靠自上而下的数据流,而不是尝试在不同组件间同步state。

虽然提升state方式比双向绑定方式需要编写更多的“样板”代码,但带来的好处是排查和隔离bug所需的工作量将会变少。由于“存在”于组件中的任何state,仅有组件自己能够修改它,因此bug的排查范围被大大缩减了。此外也可以使用自定义逻辑来拒绝或转换用户的输入。

如果某些数据可以由props或state推导得出,那么它就不应该存在于state中。举个例子,本例中没有将celsiusValue和fahrenheitValue一起保存,而是仅保存了最后修改的temperature和它的scale。这是因为另一个输入框的温度值始终可以通过这两个值以及组件的render()方法获得。这使得我们能够清除输入框内容,亦或是,在不损失用户操作的输入框内数值精度的前提下对另一个输入框内的转换数值做四舍五入的操作。
当在UI中发现错误时,可以使用React开发者工具来检查问题组件的props,并且按照组件树结构逐级向上搜寻,直到定位到负责更新state的那个组件。这使得你能够追踪到产生bug的源头

</textarea>
</div>

<div id="context">
<h4>Context</h4><pre>
react是通过props属性由上而下(由父及子)进行单向传递数据,但这种做法对于某些类型的属性而言是极其繁琐的(例如：地区偏好,UI主题),这些属性是应用程序中许多组件都需要的。
context提供了在组件中共享此类值的方法,无需为每层组件手动添加props就能在组件树间进行数据传递,不必显式地通过组件树的逐层传递props。
Context设计目的是为了共享那些对于一个组件树而言是全局的数据,例如当前认证的用户、主题或首选语言
不要仅仅为了避免在几个层级下的组件传递props而使用context

</textarea><textarea>
// 通过一个theme属性手动调整一个按钮组件的样式
class App extends React.Component {
  render() {
    return <Toolbar theme="dark" />;
  }
}

function Toolbar(props) {
  // Toolbar组件接受一个额外的“theme”属性,然后传递给ThemedButton组件。
  // 如果应用中每一个单独的按钮都需要知道theme的值,这会是件很麻烦的事,因为必须将这个值层层传递所有组件。
  return (<div><ThemedButton theme={props.theme} /></div>);
}

class ThemedButton extends React.Component {
  render() {
    return <Button theme={this.props.theme} />;
  }
}

</textarea>使用context可以避免通过中间元素传递props,Context可以无须明确地传遍每一个组件就能将值深入传递进组件树<textarea>
// 为当前的theme创建一个context,light为默认值
const ThemeContext = React.createContext('light');

class App extends React.Component {
  render() {
    // 使用一个Provider来将当前的theme传递给以下的组件树,无论多深,任何组件都能读取这个值,这个例子将dark作为当前的值传递下去。
    return (
      <ThemeContext.Provider value="dark">
        <Toolbar />
      </ThemeContext.Provider>
    );
  }
}

// 中间的组件再也不必指明往下传递theme了
function Toolbar(props) {
  return (<div><ThemedButton /></div>);
}

class ThemedButton extends React.Component {
  // 指定contextType读取当前的theme context,React会往上找到最近的theme Provider,然后使用它的值,这个例子当前的theme值为dark
  static contextType = ThemeContext;
  render() {
    return <Button theme={this.context} />;
  }
}

</textarea>切换页面主题<textarea>
// src/theme-context.js
import React from 'react'
const ThemeContext = React.createContext()
export default ThemeContext

// app.js
import React, { Component } from 'react'
import logo from './logo.svg'
import './App.css'
import ThemeContext from './theme-context'
import ThemedBar from './components/ThemedBar'

const themes = {
  light: {
    className: 'btn btn-primary',
    bgcolor: '#eee',
    color: '#000'
  },
  dark: {
    className: 'btn btn-light',
    bgcolor: '#22222',
    color: '#fff'
  },
}
class App extends React.Component {
  constructor(props){
    super(props)
    this.state = { theme: 'light' }
  }
  changeTheme(theme){
    this.setState({theme: theme})
  }
  render() {
    return (
      <ThemeContext.provider value={themes[this.state.theme]}>
        <div className='App'>
          <header className='App-header'>
            <img src={logo} className='App-logo' alt='logo' />
            <h1 className='App-title'>welcome to react</h1>
            <a href='#theme-switcher' className='btn btn-light' onClick={ ()=>{this.changeTheme('light')} }>浅色主题</a>
            <a href='#theme-switcher' className='btn btn-secondary' onClick={ ()=>{this.changeTheme('dark')} }>深色主题</a>
          </header>
          <ThemedBar />
        </div>
      </ThemeContext.provider>
    )
  }
}
// src/components/ThemedBar.js
import React from 'react'
import ThemeContext from '../theme-context'
const ThemedBar = () => {
  return (
    <ThemeContext.Consumer>
      {
        theme => {
          console.log(theme)
          return (
            <div className='alert mt-5' style={{backgroundColor: theme.bgcolor, color: theme.color}}>样式区域
              <button className={theme.className}>样式按钮</button>
            </div>
          )
        }
      }
    </ThemeContext.Consumer>
  )
}
export default ThemedBar

</textarea><pre>
Context主要应用场景在于很多不同层级的组件需要访问同样一些的数据,请谨慎使用,因为这会使得组件的复用性变差。
如果只是想避免层层传递一些属性,组件组合(component composition)有时候是一个比context更好的解决方案。

考虑这样一个Page组件,它层层向下传递user和avatarSize属性,从而深度嵌套的Link和Avatar组件可以读取到这些属性

</textarea><textarea>
<Page user={user} avatarSize={avatarSize} />
// ... 渲染出 ...
<PageLayout user={user} avatarSize={avatarSize} />
// ... 渲染出 ...
<NavigationBar user={user} avatarSize={avatarSize} />
// ... 渲染出 ...
<Link href={user.permalink}>
  <Avatar user={user} size={avatarSize} />
</Link>

</textarea><pre>
如果在最后只有Avatar组件真的需要user和avatarSize,那么层层传递这两个props就显得非常冗余。而且一旦Avatar组件需要更多从来自顶层组件的props,还得在中间层级一个一个加上去,这将会变得非常麻烦。

一种无需context的解决方案是将Avatar组件自身传递下去,因而中间组件无需知道user或avatarSize等props

</textarea><textarea>
function Page(props) {
  const {user, avatarSize} = props.user;
  const userLink = (
    <Link href={user.permalink}>
      <Avatar user={user} size={avatarSize} />
    </Link>
  );
  return <PageLayout userLink={userLink} />;
}

// 现在有这样的组件：
<Page user={user} avatarSize={avatarSize} />
// ... 渲染出 ...
<PageLayout userLink={...} />
// ... 渲染出 ...
<NavigationBar userLink={...} />
// ... 渲染出 ...
{props.userLink}

</textarea><pre>
这种变化下只有最顶部的Page组件需要知道Link和Avatar组件是如何使用user和avatarSize的。
这种对组件的控制反转减少了在应用中要传递的props数量,这在很多场景下会使得代码更加干净,对根组件有更多的把控。但这并不适用于每一个场景：这种将逻辑提升到组件树的更高层次来处理会使得这些高层组件变得更复杂,并且会强行将低层组件适应这样的形式
而且组件并不限制于接收单个子组件,可能会传递多个子组件,甚至会为这些子组件(children)封装多个单独的“接口(slots)”

</textarea><textarea>
function Page(props) {
  const {user, avatarSize} = props.user;
  const content = <Feed user={user} />;
  const topBar = (
    <NavigationBar>
      <Link href={user.permalink}>
        <Avatar user={user} size={avatarSize} />
      </Link>
    </NavigationBar>
  );
  return (
    <PageLayout topBar={topBar} content={content} />
  );
}

</textarea><pre>
这种模式足够覆盖很多场景了,在这些场景下需要将子组件和直接关联的父组件解耦。如果子组件需要在渲染前和父组件进行一些交流,可以进一步使用render props。

但有的时候在组件树中很多不同层级的组件需要访问同样的一批数据。Context能让你将这些数据向组件树下所有的组件进行“广播”,所有的组件都能访问到这些数据,也能访问到后续的数据更新。使用context的通用的场景包括管理当前的locale,theme,或者一些缓存数据,这比替代方案要简单的多。

【 Context API】
React.createContext
const MyContext = React.createContext(defaultValue);
创建一个Context对象。当React渲染一个订阅了这个Context对象的组件,这个组件会从组件树中离自身最近的那个匹配的Provider中读取到当前的context值。
只有当组件所处的树中没有匹配到Provider时,其defaultValue参数才会生效。这有助于在不使用Provider包装组件的情况下对组件进行测试
将undefined传递给Provider的value时,消费组件的defaultValue不会生效。

Context.Provider
< MyContext.Provider value={/* 某个值 */}>
每个Context对象都会返回一个Provider React组件,它允许消费组件订阅context的变化。
Provider接收一个value属性,传递给消费组件。一个Provider可以和多个消费组件有对应关系。多个Provider也可以嵌套使用,里层的会覆盖外层的数据。
当Provider的value值发生变化时,它内部的所有消费组件都会重新渲染。Provider及其内部consumer组件都不受制于shouldComponentUpdate函数,因此当consumer组件在其祖先组件退出更新的情况下也能更新。
通过新旧值检测来确定变化,使用了与Object.is相同的算法。
当传递对象给value时,检测变化的方式会导致一些问题

</textarea><textarea>
Class.contextType
class MyClass extends React.Component {
  componentDidMount() {
    let value = this.context;  /* 在组件挂载完成后,使用MyContext组件的值来执行一些有副作用的操作 */
  }
  componentDidUpdate() {
    let value = this.context;
  }
  componentWillUnmount() {
    let value = this.context;
  }
  render() {
    let value = this.context;  /* 基于MyContext组件的值进行渲染 */
  }
}
MyClass.contextType = MyContext;

</textarea><pre>
挂载在class上的contextType属性会被重赋值为一个由React.createContext()创建的Context对象。这能让你使用this.context来消费最近Context上的那个值。你可以在任何生命周期中访问到它,包括render函数中

</textarea><textarea>
Context.Consumer
<MyContext.Consumer>
  {value => /* 基于context值进行渲染*/}
</MyContext.Consumer>

</textarea><pre>
这里React组件也可以订阅到context变更,这能让你在函数式组件中完成订阅context。
这需要函数作为子元素(function as a child,详见render props)这种做法,这个函数接收当前的context值,返回一个React节点。传递给函数的value值等同于往上组件树离这个context最近的Provider提供的value值。如果没有对应的Provider,value参数等同于传递给createContext()的defaultValue。

Context.displayName
context对象接受一个名为displayName的property,类型为字符串。React DevTools使用该字符串来确定context要显示的内容。

</textarea><textarea>
// 下述组件在DevTools中将显示为MyDisplayName：
const MyContext = React.createContext(/* some value */);
MyContext.displayName = 'MyDisplayName';

<MyContext.Provider> // "MyDisplayName.Provider" 在 DevTools 中
<MyContext.Consumer> // "MyDisplayName.Consumer" 在 DevTools 中

</textarea><pre>
动态Context
对于上面的theme例子,使用动态值(dynamic values)后更复杂的用法

</textarea><textarea>
// theme-context.js
export const themes = {
  light: {
    foreground: '#000000',
    background: '#eeeeee',
  },
  dark: {
    foreground: '#ffffff',
    background: '#222222',
  },
};

export const ThemeContext = React.createContext(
  themes.dark // 默认值
);

// themed-button.js
import {ThemeContext} from './theme-context';
export default class ThemedButton extends React.Component {
  render() {
    let props = this.props;
    let theme = this.context;
    return (<button {...props} style={{backgroundColor: theme.background}} />);
  }
}
ThemedButton.contextType = ThemeContext;

// app.js
import {ThemeContext, themes} from './theme-context';
import ThemedButton from './themed-button';

// 一个使用ThemedButton的中间组件
function Toolbar(props) {
  return (<ThemedButton onClick={props.changeTheme}>Change Theme</ThemedButton>);
}

class App extends React.Component {
  constructor(props) {
    super(props);
    this.state = { theme: themes.light };

    this.toggleTheme = () => {
      this.setState(state => ({theme: state.theme === themes.dark ? themes.light : themes.dark}));
    };
  }

  render() {
    // 在ThemeProvider内部的ThemedButton按钮组件使用state中的theme值,而外部的组件使用默认的 theme 值
    return (
      <Page>
        <ThemeContext.Provider value={this.state.theme}>
          <Toolbar changeTheme={this.toggleTheme} />
        </ThemeContext.Provider>
        <Section>
          <ThemedButton />
        </Section>
      </Page>
    );
  }
}
ReactDOM.render(<App />, document.root);

</textarea><pre>
在嵌套组件中更新Context
从一个在组件树中嵌套很深的组件中更新context是很有必要的。在这种场景下可以通过context传递一个函数,使得consumers组件更新context

</textarea><textarea>
// theme-context.js
// 确保传递给 createContext 的默认值数据结构是调用的组件(consumers)所能匹配的！
export const ThemeContext = React.createContext({
  theme: themes.dark,
  toggleTheme: () => {},
});

// theme-toggler-button.js
import {ThemeContext} from './theme-context';

function ThemeTogglerButton() {
  // Theme Toggler 按钮不仅仅只获取 theme 值,它也从 context 中获取到一个 toggleTheme 函数
  return (
    <ThemeContext.Consumer>
      {({theme, toggleTheme}) => (
        <button onClick={toggleTheme} style={{backgroundColor: theme.background}}>Toggle Theme</button>
      )}
    </ThemeContext.Consumer>
  );
}
export default ThemeTogglerButton;

// app.js
import {ThemeContext, themes} from './theme-context';
import ThemeTogglerButton from './theme-toggler-button';

class App extends React.Component {
  constructor(props) {
    super(props);

    this.toggleTheme = () => {
      this.setState(state => ({
        theme: state.theme === themes.dark ? themes.light : themes.dark,
      }));
    };

    // State 也包含了更新函数,因此它会被传递进 context provider。
    this.state = {
      theme: themes.light,
      toggleTheme: this.toggleTheme,
    };
  }

  render() { // 整个state都被传递进provider
    return (
      <ThemeContext.Provider value={this.state}>
        <Content />
      </ThemeContext.Provider>
    );
  }
}

function Content() {
  return (<div><ThemeTogglerButton /></div>);
}

ReactDOM.render(<App />, document.root);

</textarea><pre>
消费多个Context
为了确保context快速进行重渲染,React需要使每一个consumers组件的context在组件树中成为一个单独的节点

</textarea><textarea>
// Theme context,默认的 theme 是 “light” 值
const ThemeContext = React.createContext('light');

// 用户登录 context
const UserContext = React.createContext({name: 'Guest'});

class App extends React.Component {
  render() {
    const {signedInUser, theme} = this.props;
    // 提供初始context值的App组件
    return (
      <ThemeContext.Provider value={theme}>
        <UserContext.Provider value={signedInUser}>
          <Layout />
        </UserContext.Provider>
      </ThemeContext.Provider>
    );
  }
}

function Layout() {
  return (
    <div>
      <Sidebar />
      <Content />
    </div>
  );
}

// 一个组件可能会消费多个context
function Content() {
  return (
    <ThemeContext.Consumer>
      {theme => (
        <UserContext.Consumer>
          {user => (
            <ProfilePage user={user} theme={theme} />
          )}
        </UserContext.Consumer>
      )}
    </ThemeContext.Consumer>
  );
}

</textarea><pre>
如果两个或更多的context值经常被一起使用,那可能要考虑一下另外创建自己的渲染组件,以提供这些值。

注意事项
因为context会使用参考标识(reference identity)来决定何时进行渲染,这里可能会有一些陷阱,当provider的父组件进行重渲染时,可能会在consumers组件中触发意外的渲染。举个例子,当每一次Provider重渲染时,以下的代码会重渲染所有下面的consumers组件,因为value属性总是被赋值为新的对象：

</textarea><textarea>
class App extends React.Component {
  render() {
    return (
      <Provider value={{something: 'something'}}>
        <Toolbar />
      </Provider>
    );
  }
}

// 为了防止这种情况,将value状态提升到父节点的state里：
class App extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      value: {something: 'something'},
    };
  }

  render() {
    return (
      <Provider value={this.state.value}>
        <Toolbar />
      </Provider>
    );
  }
}

</textarea>
</div>

<div id="error">
<h4>错误边界 Error Boundaries</h4><pre>
过去组件内的js错误会导致React的内部状态被破坏,并且在下一次渲染时产生可能无法追踪的错误。这些错误基本上是由较早的其他代码(非React组件代码)错误引起的,但React并没有提供一种在组件中优雅处理这些错误的方式,也无法从错误中恢复。部分UI的js错误不应该导致整个应用崩溃,为了解决这个问题,React16引入错误边界的概念

错误边界是一种React组件,这种组件可以捕获并打印发生在其子组件树任何位置的js错误,并且会渲染出备用UI,而不是渲染那些崩溃了的子组件树。错误边界在渲染期间、生命周期方法和整个组件树的构造函数中捕获错误。

错误边界无法捕获以下场景中产生的错误：
事件处理
异步代码,如setTimeout或requestAnimationFrame回调函数
服务端渲染
它自身抛出来的错误,并非它的子组件

如果一个class组件中定义了static getDerivedStateFromError()或componentDidCatch()这两个生命周期方法中的任意一  或两个时,那么它就变成一个错误边界。当抛出错误后使用static getDerivedStateFromError()渲染备用UI,使用componentDidCatch()打印错误信息。

</textarea><textarea>
class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error) {
    return { hasError: true };  // 更新state使下一次渲染能够显示降级后的UI
  }

  componentDidCatch(error, errorInfo) {
    logErrorToMyService(error, errorInfo);  // 同样可以将错误日志上报给服务器
  }

  render() {
    if (this.state.hasError) {
      return <h1>Something went wrong.</h1>;  // 可以自定义降级后的UI并渲染
    }
    return this.props.children; 
  }
}

// 然后可以将它作为一个常规组件去使用
<ErrorBoundary>
  <MyWidget />
</ErrorBoundary>

</textarea><pre>
错误边界的工作方式类似于js的catch{},不同的地方在于错误边界只针对React组件,只有class组件才可以成为错误边界组件。大多数情况下只需要声明一次错误边界组件,并在整个应用中使用它。
错误边界仅可以捕获其子组件的错误,它无法捕获其自身的错误。如果一个错误边界无法渲染错误信息,则错误会冒泡至最近的上层错误边界,这也类似于js中catch{}的工作机制。

错误边界应该放置在哪？
错误边界的粒度由自己决定,可以将其包装在最顶层的路由组件并为用户展示一个“Something went wrong”的错误信息,就像服务端框架经常处理崩溃一样,也可以将单独的部件包装在错误边界以保护应用其他部分不崩溃

未捕获错误(Uncaught Errors)的新行为
这一改变具有重要意义,自React16起任何未被错误边界捕获的错误将会导致整个React组件树被卸载。

我们对这一决定有过一些争论,但根据经验,把一个错误的UI留在那比完全移除它要更糟糕。例如在类似Messenger的产品中,把一个异常的UI展示给用户可能会导致用户将信息错发给别人。同样对于支付类应用而言显示错误的金额也比不呈现任何内容更糟糕。
此变化意味着当你迁移到React16时,可能会发现一些已存在应用中但未曾注意到的崩溃,增加错误边界能够让应用发生异常时提供更好的用户体验。
例如Facebook Messenger将侧边栏、信息面板、聊天记录以及信息输入框包装在单独的错误边界中。如果其中的某些UI组件崩溃,其余部分仍然能够交互。
鼓励使用JS错误报告服务或自行构建,这样能了解关于生产环境中出现的未捕获异常,并将其修复。

组件栈追踪
在开发环境下React16会把渲染期间发生的所有错误打印到控制台,即使该应用意外的将这些错误掩盖。除了错误信息和js栈外,React16还提供了组件栈追踪,可以准确地查看发生在组件树内的错误信息,也可以在组件栈追踪中查看文件名和行号,这一功能在Create React App项目中默认开启

try/catch仅能用于命令式代码(imperative code),然而React组件是声明式的并且具体指出什么需要被渲染
错误边界保留了React的声明性质,其行为符合预期。例如即使一个错误发生在componentDidUpdate方法中,并且由某一个深层组件树的setState引起,其仍然能够冒泡到最近的错误边界。

关于事件处理器
错误边界无法捕获事件处理器内部的错误。
React不需要错误边界来捕获事件处理器中的错误。与render方法和生命周期方法不同,事件处理器不会在渲染期间触发。因此如果它们抛出异常,React仍然能够知道需要在屏幕上显示什么。

如果需要在事件处理器内部捕获错误,使用普通的try/catch语句：

</textarea><textarea>
class MyComponent extends React.Component {
  constructor(props) {
    super(props);
    this.state = { error: null };
    this.handleClick = this.handleClick.bind(this);
  }

  handleClick() {
    try {
      // 执行操作,如有错误则会抛出
    } catch (error) {
      this.setState({ error });
    }
  }

  render() {
    if (this.state.error) return <h1>Caught an error.</h1>
    return <div onClick={this.handleClick}>Click Me</div>
  }
}

</textarea>
</div>

<div id="hoc">
<h4>高阶组件(HOC, higher Order Component)</h4><pre>
高阶函数
如果一个函数操作其他函数,即将其他函数作为参数或将函数作为返回值,将其称为高阶函数,如setTimeout\setInterval\sort\filter

高阶组件是接收React组件作为输入,输出一个新的React组件的函数。高阶组件让代码更具有复用性、逻辑性与抽象特征。可以对render方法作劫持,也可以控制props与state
新组件类继承子React.component类,对传入的组件进行一系列操作,从而产生一个新的组件,达到增强组件的作用
高阶组件是React中用于复用组件逻辑的一种高级技巧。HOC自身不是React API的一部分,它是一种基于React的组合特性而形成的设计模式。
const EnhancedComponent = higherOrderComponent(WrappedComponent);
组件是将props转换为UI,而高阶组件是将组件转换为另一个组件。
应用场景：有公用代码,公用的功能,那个可以使用高阶组件抽取公共部分
HOC在React的第三方库中很常见,例如Redux的connect和Relay的createFragmentContainer。

操作props
访问ref
抽取state
封装组件

实现高阶组件的两种方法
1、属性代理(props proxy)。属性组件通过被包裹的React组件来操作props。
2、反向代理(inheritance inversion)。高阶组件继承于被包裹的React组件。

【 属性代理 】
属性代理是常见高阶组件的实现方法
属性代理：在render方法中返回传入WrappedComponent的React组件,这样就可以通过高阶组件来传递props,这种方法即为属性代理

</textarea><textarea>
const MyContainer = (WrappedComponent) => {
  return class extends Component {
    render() {
      return <WrappedComponent {...props} />
    }
  }
}
export default MyContainer;

const MyContainer = WrappedComponent => 
  class A extends Component{
    constructor(props){
      super(props)
      this.state = {value: ''}
    }
    render(){
      return (<div><WrappedComponent /></div>)
    }
  }
export default MyContainer

</textarea><pre>
原始组件想要具备高阶组件对它的修饰即要调用高阶组件如B组件调用高阶组件A,有两种方法
1、函数调用

</textarea><textarea>
export default MyContainer;
class MyComponent extends Component {
}
export default MyContainer(MyComponent);

import React, { Component } from 'react'
import A from './A'
class B extends Components{
  render(){
    return (< div>< h2>B组件< /h2>< /div>)
  }
}
export default A(B)

</textarea><pre>
2、装饰器模式
ES7添加了decorator的属性,可以通过decorator来转换,以此简化高阶组件的调用

</textarea><textarea>
@MyContainer
class MyComponent extends Component {
}
export default MyComponent;

import React, { Component } from 'react'
import A from './A'
@A
class B extends Components{
  render(){
    return (< div>< h2>B组件< /h2>< /div>)
  }
}
export default B

</textarea>组件调用<textarea>
import React, { Component } from 'react'
import A form './A'
@A
class B extends Component{
  constructor(props){
    super(props)
    this.state = {}
  }
  render(){
    return (
      <div>
        value: {this.props.value}<br/>
        <input type="text" onChange={this.props.onChange} />
      </div>
    )
  }
}
export default B

</textarea><pre>
这样组件就可以一层层地作为参数被调用,原始组件就具备了高阶组件对它的修饰,这样保持了单个组件封装性的同时还保留了易用性。
生命周期：didmount -> HOC didmount -> (HOCs didmount) ->(HOCs will unmount) -> Hoc will unmount -> unmount

</textarea>react-create-app默认不支持装饰器,要想支持必须安装以下依赖,并且配置babel<textarea>
"devDependencies":{
  "@babel/plugin-proposal-decorators": "^7.1.2",
  "babel-plugin=transform-decorators-legacy": "^1.3.5"
}

"babel": {
  "plugins": [
    "@babel/plugin-proposal-decorators",
    {"legacy": true}
  ]
}

</textarea><pre>
功能上,高阶组件可以控制props、通过refs使用引用、抽象state和使用其他元素包裹WrappedComponent。

控制props
可以读取、增加、编辑或移除从WrappedComponent传进来的props,但要小心删除与编辑重要的props,应尽量对高阶组件的props作新的命名以防止混淆

</textarea>当调用该高阶组件时就可以使用text这个新的props了<textarea>
const MyContainer = (WrappedComponent) => {
  return class extends Component {
    render() {
      const newProps = { text: newText };
      return <WrappedComponent {...props} {...newProps} />
    }
  }
}
export default MyContainer;

</textarea><textarea>
import React, { Component } from 'react'
const MyContainer = WrappedComponent => 
  class A extends Componets{
    static displayName = `{Hoc(${getDisplayName(WrappedComponent)})}`
    constructor(props){
      super(props)
      this.state = {value: ''}
      this.onChange = this.onChange.bind(this)
    }
    onChange(e){
      this.setState({e.target.value})
    }
    render(){
      const newProps = {
        name: "guoba",
        value: this.state.value,
        onChange: this.onChange
      }
      return (<div><WrappedComponent {...this.props} {...newProps} /></div>)
    }
  }

function getDisplayName(WrappedComponent){
  return WrappedComponent.displayName || WrappedComponent.name || "Component"
}
export default MyContainer

</textarea><pre>
通过refs使用引用
在高阶组件中可以接受refs使用WrappedComponent的引用。

</textarea>当WrappedComponent被渲染时ref回调函数就会被执行,这样就会拿到一份WrappedComponent实例的引用,可以方便地读取或增加实例的props,并调用实例的方法<textarea>
const MyContainer = (WrappedComponent) => {
  return class extends Component {
    ref = (view) => { view.mentod() }
    render() {
      const props = Object.assign({}, this.props, {ref: this.ref});
      return <WrappedComponent {...props} />
    }
  }
}
export default MyContainer;

</textarea><pre>
抽象state
可以通过WrappedComponent提供的props和回调函数抽象state。将原组件抽象为展示型组件,分离内部状态

</textarea><textarea>
const MyContainer = (WrappedComponent) => {
  return class extends Component {
    constructor(props){
      super(props);
      this.state = { name: '' };
    }

    onNameChange(text) {
      this.setState({ name: text });
    }

    render() {
      const newProps =  {
        name: this.state.name,
        onChangeText: {this.onNameChange}
      }
      return <WrappedComponent {...this.props} {...newProps} />
    }
  }
}
export default MyContainer;

// 使用
@MyContainer
class MyComponent extends Component {
  render() {
    return <TextInput {...this.props.name} />
  }
}

// 使用其他元素包裹WrappedComponent
export default LoginPleaseMixin;
const MyContainer = (WrappedComponent) => {
  return class exrends PureComponent {
    render() {
      return (<View><WrappedComponent /></View>);
    }
  }
}
export default MyContainer;

</textarea><pre>
【 反向继承 】
反向继承是另一种构建高阶组件的方法

</textarea><textarea>
const MyContainer = (WrappedComponent) => {
  return class extends WrappedComponent {
    render() {
      return super.render();
    }
  }
}
export default MyContainer;

</textarea><pre>
高阶组件返回的组件继承于WrappedComponent,因为被动地继承了WrappedComponent,所有的调用都会反向。
通过继承WrappedComponent来实现,方法可以通过super来顺序调用。因为依赖于继承的机制,HOC的调用顺序和队列是一样的：
didmount -> HOC didmount -> (HOCs didmount) -> will unmount -> HOC will unmount -> (HOCs will unmount)
在反向继承方法中,高阶组件可以使用WrappedComponent引用,这意味着它可以使用WrappedComponent的state、props、生命周期和render方法,但他不能保证完整的子组件树被解析。

</textarea><textarea>
import React, { Component } from 'react'
const modifyPropsHOC = WrappedComponent => 
  class Newcomponent extends WrappedComponent{
    render(){
      const el = super.render()
      const newStyle = {
        color: el.type === 'div' ? 'green' : 'red'
      }
      const newProps = {...this.props, newStyle}
      return React.cloneElement(el, newProps, el.props.children)
    }
  }
export default modifyPropsHOC

</textarea><pre>
渲染劫持
渲染劫持指的就是高阶组件可以控制WrappedComponent的渲染过程,并渲染各种各样的结果。可以在这个过程中在任何React元素输出的结果中读取、增加、修改、删除props,或读取或修改React元素树、或条件显示元素树,又或是用样式控制包裹元素树。
反向继承不能保证完整的子组件树被解析,这意味着将限制渲染劫持功能。但如果元素树包裹了函数类型的React组件就不能操作组件的子组件。
可以做各种各样的事,甚至可以反转元素树,或是改变元素树中的props

</textarea>渲染劫持和条件劫持<textarea>
import React, { Component } from 'react'
const modifyPropsHOC = WrappedComponent => 
  class Newcomponent extends WrappedComponent{
    render(){
      const el = super.render()
      const newStyle = { color: el.type === 'div' ? 'green' : 'red' }
      const newProps = {...this.props, newStyle}
      if(this.props.login) return React.cloneElement(el, newProps, el.props.children)
      return null
    }
  }
export default modifyPropsHOC

</textarea>条件渲染<textarea>
const MyContainer = (WrappedComponent) => {
 return class extends WrappedComponent {
    render() {
      if (this.props.loggIn) return super.render();
      return null;
    }
  }
}
export default MyContainer;

</textarea>对render输出结果进行修改<textarea>
const MyContainer = (WrappedComponent) => {
  return class extends WrappedComponent {
    render() {
      const elementsTree = super.render();
      let newProps = {};
      if (elementsTree && elementsTree.type === 'input') newProps = {value: 'may the force be with you'};
      const props = Object.assign({}, elementsTree.props, newProps);
      const newElementsTree = React.cloneElement(elementsTree, props, elementsTree.props.children);
      return newElementsTree;
    }
  }
}
export default MyContainer;

</textarea><pre>
控制state
高阶组件可以读取、修改或删除WrappedComponent实例中的state,如果需要的话也可以增加state。但这样做可能让WrappedComponent组件内部状态变得一团糟。大部分的高阶组件都应该限制读取或增加state,尤其是后者,可以通过重新命名state,以防止混淆

</textarea><textarea>
const MyContainer = (WrappedComponent) => {
  return class extends WrappedComponent {
    render() {
      return (
        <View>
          <Text>{JSON.stringify(this.props)}</Text>
          <Text>{JSON.stringify(this.state)}</Text>
          {super.render()}
        </View>
      );
    }
  }
}
export default MyContainer;

</textarea><pre>
【 组件命名 】
当包裹一个高阶组件时,失去了原始的WrappedComponent的displayName,而组件名字是方便开发与调试的重要属性。

</textarea><textarea>
HOC.displayName = `HOC{${getDisplayName(WrappedComponent)}}`;
class HOC extends ... {
  static displayName = `{Hoc(${getDisplayName(WrappedComponent)})}`
  function getDisplayName(WrappedComponent) {
    return WrappedComponent.displayName || WrappedComponent.name || 'Component';
  }
}

</textarea><pre>
高阶组件命名
当包裹一个高阶组件时,失去了原始的WrappedComponent的displayName,在页面上审查原素会看到调用的组件被“newcomponent”包裹,方便调试

</textarea><textarea>
import React, { Component } from 'react'
const modifyPropsHOC = WrappedComponent => 
  class Newcomponent extends WrappedComponent{
    static displayName = `Newcomponent(${getDisplayName(WrappedComponent)})`
    render(){
      const el = super.render()
      const newStyle = {
        color: el.type === 'div' ? 'green' : 'red'
      }
      const newProps = {...this.props, newStyle}
      return React.cloneElement(el, newProps, el.props.children)
    }
  }
function getDisplayName(WrappedComponent){
  return WrappedComponent.displayName || WrappedComponent.name || "Component"
}
export default modifyPropsHOC

</textarea><pre>
【 组件参数 】
调用高阶组件时需要传入一些参数,可以用简单方式实现。

</textarea><textarea>
function HOCFactoryFactory(...params) {
  return function HOCFactory(WrappedComponent) {
    return class HOC extends Component {
      render() {
        return <WrappedComponent {...this.props} />
      }
    }
  }
}

使用：
HOCFactoryFactory(params)(WrappedComponent)
或者
@HOCFactoryFactory(params)
class WrappedComponent extends Component {
}

</textarea><pre>
【 使用HOC解决横切关注点问题 】
组件是React中代码复用的基本单元,但某些模式并不适合传统组件。

</textarea><textarea>
// CommentList组件订阅外部数据源用以渲染评论列表
class CommentList extends React.Component {
  constructor(props) {
    super(props);
    this.handleChange = this.handleChange.bind(this);
    this.state = {
      comments: DataSource.getComments()  // DataSource是个全局范围内的数据源变量
    };
  }

  componentDidMount() {
    DataSource.addChangeListener(this.handleChange);  // 订阅更改
  }

  componentWillUnmount() {
    DataSource.removeChangeListener(this.handleChange);  // 清除订阅
  }

  handleChange() {
    this.setState({comments: DataSource.getComments()});  // 当数据源更新时更新组件状态
  }

  render() {
    return (<div>{this.state.comments.map((comment) => (<Comment comment={comment} key={comment.id} />))}</div>);
  }
}

// 编写用于订阅单个博客帖子的组件,该帖子遵循类似的模式
class BlogPost extends React.Component {
  constructor(props) {
    super(props);
    this.handleChange = this.handleChange.bind(this);
    this.state = {
      blogPost: DataSource.getBlogPost(props.id)
    };
  }

  componentDidMount() {
    DataSource.addChangeListener(this.handleChange);
  }

  componentWillUnmount() {
    DataSource.removeChangeListener(this.handleChange);
  }

  handleChange() {
    this.setState({blogPost: DataSource.getBlogPost(this.props.id)});
  }

  render() {
    return <TextBlock text={this.state.blogPost} />;
  }
}

CommentList和BlogPost不同,它们在DataSource上调用不同的方法,且渲染不同的结果,但它们的大部分实现都是一样的：
在挂载时向DataSource添加一个更改侦听器。
在侦听器内部当数据源发生变化时调用setState。
在卸载时删除侦听器。

在一个大型应用程序中这种订阅DataSource和调用setState的模式将一次又一次地发生。需要一个抽象允许在一个地方定义这个逻辑,并在许多组件之间共享它,这正是高阶组件擅长的地方。

对于订阅了DataSource的组件如CommentList和BlogPost,可以编写一个创建组件函数。该函数将接受一个子组件作为它的其中一个参数,该子组件将订阅数据作为prop。调用函数withSubscription,第一个参数是被包装组件。第二个参数通过DataSource和当前的props返回需要的数据。

</textarea>当渲染CommentListWithSubscription和BlogPostWithSubscription时,CommentList和BlogPost将传递一个data prop,其中包含从DataSource检索到的最新数据<textarea>
// 此函数接收一个组件,并返回另一个组件
function withSubscription(WrappedComponent, selectData) {
  return class extends React.Component {
    constructor(props) {
      super(props);
      this.handleChange = this.handleChange.bind(this);
      this.state = {data: selectData(DataSource, props)};
    }

    componentDidMount() {
      DataSource.addChangeListener(this.handleChange);  // 负责订阅相关的操作
    }

    componentWillUnmount() {
      DataSource.removeChangeListener(this.handleChange);
    }

    handleChange() {
      this.setState({data: selectData(DataSource, this.props)});
    }

    render() {
      return <WrappedComponent data={this.state.data} {...this.props} />;   // 并使用新数据渲染被包装的组件,可能还会传递其他属性
    }
  };
}

const CommentListWithSubscription = withSubscription(
  CommentList,
  (DataSource) => DataSource.getComments()
);

const BlogPostWithSubscription = withSubscription(
  BlogPost,
  (DataSource, props) => DataSource.getBlogPost(props.id)
);

</textarea><pre>
HOC不会修改传入的组件,也不会使用继承来复制其行为。相反HOC通过将组件包装在容器组件中来组成新组件。HOC是纯函数,没有副作用。
被包装组件接收来自容器组件的所有prop,同时也接收一个新的用于render的data prop。HOC不需要关心数据的使用方式或原因,而被包装组件也不需要关心数据是怎么来的。
因为withSubscription是一个普通函数,可以根据需要对参数进行增添或删除。例如可能希望使data prop的名称可配置,以进一步将HOC与包装组件隔离开来。或者可以接受一个配置shouldComponentUpdate的参数,或者一个配置数据源的参数。因为HOC可以控制组件的定义方式,这一切都变得有可能。

与组件一样,withSubscription和包装组件之间的契约完全基于之间传递的props。这种依赖方式使得替换HOC变得容易,只要它们为包装的组件提供相同的prop即可,例如需要改用其他库来获取数据的时候这一点很有用。

【 不要改变原始组件,使用组合 】
不要试图在HOC中修改组件原型或以其他方式改变它

</textarea><textarea>
function logProps(InputComponent) {
  InputComponent.prototype.componentWillReceiveProps = function(nextProps) {
    console.log('Current props: ', this.props);
    console.log('Next props: ', nextProps);
  };
  return InputComponent;  // 返回原始的input组件,暗示它已经被修改
}
const EnhancedComponent = logProps(InputComponent);  // 每次调用logProps时增强组件都会有log输出

</textarea><pre>
这样做会产生一些不良后果,其一是输入组件再也无法像HOC增强之前那样使用了。更严重的是,如果再用另一个同样会修改componentWillReceiveProps的HOC增强它,那么前面的HOC就会失效！同时这个HOC也无法应用于没有生命周期的函数组件。
修改传入组件的HOC是一种糟糕的抽象方式。调用者必须知道他们是如何实现的,以避免与其他HOC发生冲突。

HOC不应该修改传入组件,而应该使用组合的方式,通过将组件包装在容器组件中实现功能：

</textarea><textarea>
function logProps(WrappedComponent) {
  return class extends React.Component {
    componentWillReceiveProps(nextProps) {
      console.log('Current props: ', this.props);
      console.log('Next props: ', nextProps);
    }
    render() {
      return <WrappedComponent {...this.props} />;  // 将input组件包装在容器中,而不对其进行修改
    }
  }
}

</textarea><pre>
该HOC与上文中修改传入组件的HOC功能相同,同时避免了出现冲突的情况。它同样适用于class组件和函数组件。而且因为它是一个纯函数,它可以与其他HOC组合,甚至可以与其自身组合。

HOC与容器组件模式之间有相似之处。容器组件担任分离将高层和低层关注的责任,由容器管理订阅和状态,并将prop传递给处理渲染UI。HOC使用容器作为其实现的一部分,可以将HOC视为参数化容器组件。

【 约定：将不相关的props传递给被包裹的组件 】
HOC为组件添加特性。自身不应该大幅改变约定。HOC返回的组件与原组件应保持类似的接口。
HOC应该透传与自身无关的props。大多数HOC都应该包含一个类似于下面的render方法,这种约定保证了HOC的灵活性以及可复用性。

</textarea><textarea>
render() {
  // 过滤掉非此HOC额外的props,且不要进行透传
  const { extraProp, ...passThroughProps } = this.props;  
  // 将props注入到被包装的组件中,通常为state的值或实例方法。
  const injectedProp = someStateOrInstanceMethod;
  // 将props传递给被包装组件
  return (<WrappedComponent injectedProp={injectedProp} {...passThroughProps} />);
}

</textarea><pre>
【 约定：最大化可组合性 】
并不是所有的HOC都一样,有时候它仅接受一个参数,也就是被包裹的组件：
const NavbarWithRouter = withRouter(Navbar);
HOC通常可以接收多个参数,比如在Relay中HOC额外接收了一个配置对象用于指定组件的数据依赖：
const CommentWithRelay = Relay.createContainer(Comment, config);

最常见的HOC签名如下：
const ConnectedComment = connect(commentSelector, commentActions)(CommentList); // React Redux的`connect`函数
// connect是一个函数,它的返回值为另外一个函数。
const enhance = connect(commentListSelector, commentListActions);
// 返回值为HOC,它会返回已经连接Redux store的组件
const ConnectedComment = enhance(CommentList);
换句话说,connect是一个返回高阶组件的高阶函数

这种形式可能看起来令人困惑或不必要,但它有一个有用的属性。像connect函数返回的单参数HOC具有签名Component => Component。 输出类型与输入类型相同的函数很容易组合在一起。
// 而不是这样...
const EnhancedComponent = withRouter(connect(commentSelector)(WrappedComponent))
// 可以编写组合工具函数,compose(f, g, h) 等同于 (...args) => f(g(h(...args)))
const enhance = compose( withRouter, connect(commentSelector) )  // 这些都是单参数的HOC
const EnhancedComponent = enhance(WrappedComponent)
(同样的属性也允许connect和其他HOC承担装饰器的角色,装饰器是一个实验性的js提案。)
许多第三方库都提供了compose工具函数,包括lodash (比如lodash.flowRight), Redux和Ramda。

【 约定：包装显示名称以便轻松调试 】
HOC创建的容器组件会与任何其他组件一样,会显示在React Developer Tools中。为了方便调试,请选择一个显示名称,以表明它是HOC的产物。
最常见的方式是用HOC包住被包装组件的显示名称,比如高阶组件名为withSubscription,并且被包装组件的显示名称为CommentList,显示名称应该为WithSubscription(CommentList)：

</textarea><textarea>
function withSubscription(WrappedComponent) {
  class WithSubscription extends React.Component {/* ... */}
  WithSubscription.displayName = `WithSubscription(${getDisplayName(WrappedComponent)})`;
  return WithSubscription;
}

function getDisplayName(WrappedComponent) {
  return WrappedComponent.displayName || WrappedComponent.name || 'Component';
}

</textarea><pre>
【 注意事项 】
不要在render方法中使用HOC
React的diff算法(称为协调)使用组件标识来确定它是应该更新现有子树还是将其丢弃并挂载新子树。如果从render返回的组件与前一个渲染中的组件相同(===),则React通过将子树与新子树进行区分来递归更新子树。如果它们不相等,则完全卸载前一个子树。
通常不需要考虑这点,但对HOC来说这一点很重要,因为这代表着不应在组件的render方法中对一个组件应用HOC,这不仅仅是性能问题,重新挂载组件会导致该组件及其所有子组件的状态丢失

</textarea><textarea>
render() {
  // 每次调用render函数都会创建一个新的EnhancedComponent
  // EnhancedComponent1 !== EnhancedComponent2
  const EnhancedComponent = enhance(MyComponent);
  // 这将导致子树每次渲染都会进行卸载和重新挂载的操作
  return <EnhancedComponent />;
}

</textarea><pre>
如果在组件之外创建HOC,这样一来组件只会创建一次,因此每次render时都会是同一个组件,一般来说这跟预期表现是一致的。
在极少数情况下需要动态调用HOC,可以在组件的生命周期方法或其构造函数中进行调用。

务必复制静态方法
有时在React组件上定义静态方法很有用,例如Relay容器暴露了一个静态方法getFragment以方便组合GraphQL片段。
但当将HOC应用于组件时,原始组件将使用容器组件进行包装,这意味着新组件没有原始组件的任何静态方法。

// 定义静态函数
WrappedComponent.staticMethod = function() {/*...*/}
// 现在使用HOC
const EnhancedComponent = enhance(WrappedComponent);
// 增强组件没有staticMethod
typeof EnhancedComponent.staticMethod === 'undefined' // true

为了解决这个问题,可以在返回之前把这些方法拷贝到容器组件上：
function enhance(WrappedComponent) {
  class Enhance extends React.Component {/*...*/}
  // 必须准确知道应该拷贝哪些方法
  Enhance.staticMethod = WrappedComponent.staticMethod;
  return Enhance;
}

但要这样做需要知道哪些方法应该被拷贝。可以使用hoist-non-react-statics自动拷贝所有非React静态方法:
import hoistNonReactStatic from 'hoist-non-react-statics';
function enhance(WrappedComponent) {
  class Enhance extends React.Component {/*...*/}
  hoistNonReactStatic(Enhance, WrappedComponent);
  return Enhance;
}

除了导出组件,另一个可行的方案是再额外导出这个静态方法。
// 使用这种方式代替...
MyComponent.someFunction = someFunction;
export default MyComponent;

// ...单独导出该方法...
export { someFunction };

// ...并在要使用的组件中,import它们
import MyComponent, { someFunction } from './MyComponent.js';

Refs不会被传递
虽然高阶组件的约定是将所有props传递给被包装组件,但这对于refs并不适用。那是因为ref实际上并不是一个prop,就像key一样,它是由React专门处理的。如果将ref添加到HOC的返回组件中,则ref引用指向容器组件,而不是被包装组件。
这个问题的解决方案是通过使用React.forwardRef API

</textarea>【 Tabbar 】<textarea>
// Tabbar.js
import React, { Component } from "react";
import { Link } from "react-router-dom";
import "./index.less";
const tabbarArr = [
  {img: "icon-home", text: "首页", link: "/home"},
  {img: "icon-fenlei",text: "分类",link: "/category"},
  {img: "icon-shoutibao",text: "拼购",link: "/pingou"},
  {img: "icon-gouwuche",text: "购物车",link: "/car"},
  {img: "icon-yonghu",text: "我的",link: "/user"}
];
const Tabbar = WrappedComponent =>
  class Tabbar extends Component {
    constructor(props) {
      super(props);
      this.state = {activeIndex: 0};
    }

    render() {
      const url = window.location.href;
      return (
        <div className="container">
          <div className="content">
            <WrappedComponent />
          </div>
          <div className="tabbar">
            <div className="tabbar-content">
              {tabbarArr.map((item, index) => {
                return (
                  <Link to={item.link} className={"tabbar-item" + (url.indexOf(item.link) > 0 ? " active" : "")} key={index}>
                    <div className={"iconfont " + item.img} />
                    <div>{item.text}</div>
                  </Link>
                );
              })}
            </div>
          </div>
        </div>
      );
    }
  };
export default Tabbar;

// Home.js
import React, { Component } from "react";
import Tabbar from "../components/Tabbar";
@Tabbar
class Home extends Component {
  render() {
    return (
      <div>
        <img src={require("../static/images/home.jpeg")} className="bg" alt="首页" />
      </div>
    );
  }
}
export default Home;

</textarea>
</div>

<div id="render_props">
<h4>Render Props</h4><pre>
render prop是一种在React组件之间使用一个值为函数的prop共享代码的简单技术,使用render prop的库有React Router、Downshift及Formik
具有render prop的组件接受一个函数,该函数返回一个React元素并调用它而不是实现自己的渲染逻辑。

</textarea><textarea>
<DataProvider render={data => (
  <h1>Hello {data.target}</h1>
)}/>

</textarea><pre>
【 使用Render Props来解决横切关注点(Cross-Cutting Concerns)】
组件是React代码复用的主要单元,但如何分享一个组件封装到其他需要相同state组件的状态或行为并不总是很容易

</textarea>以下组件跟踪Web应用程序中的鼠标位置<textarea>
class MouseTracker extends React.Component {
  constructor(props) {
    super(props);
    this.state = { x: 0, y: 0 };
  }

  handleMouseMove(event) {
    this.setState({x: event.clientX, y: event.clientY});
  }

  render() {
    return (
      <div style={{ height: '100%' }} onMouseMove={this.handleMouseMove.bind(this)}>
        <h1>移动鼠标!</h1>
        <p>当前的鼠标位置是 ({this.state.x}, {this.state.y})</p>
      </div>
    );
  }
}

</textarea><pre>
现在的问题是：如何在另一个组件中复用这个行为？若另一个组件需要知道鼠标位置,能否封装这一行为以便轻松地与其他组件共享它,现在尝试重构一部分代码使其能够在Mouse组件中封装需要共享的行为。

</textarea><textarea>
class Mouse extends React.Component {
  constructor(props) {
    super(props);
    this.state = { x: 0, y: 0 };
  }

  handleMouseMove(event) {
    this.setState({x: event.clientX, y: event.clientY});
  }

  render() {
    return (
      <div style={{ height: '100%' }} onMouseMove={this.handleMouseMove.bind(this)}>
        {/* 但如何渲染p标签以外的东西? */}
        <p>The current mouse position is ({this.state.x}, {this.state.y})</p>
      </div>
    );
  }
}

class MouseTracker extends React.Component {
  render() {
    return (
      <div>
        <h1>移动鼠标!</h1>
        <Mouse />
      </div>
    );
  }
}

</textarea><pre>
现在Mouse组件封装了所有关于监听mousemove事件和存储鼠标(x,y)位置的行为,但其仍不是真正的可复用。
假设有一个Cat组件可以呈现一张在屏幕上追逐鼠标的猫的图片。或许会使用< Cat mouse={{ x, y }} prop 来告诉组件鼠标的坐标以让它知道图片应该在屏幕哪个位置。

</textarea><textarea>
// 尝试在Mouse内部的渲染方法渲染Cat组件
class Cat extends React.Component {
  render() {
    const mouse = this.props.mouse;
    return (<div style={{width:'10px',height:'10px',background:'red',position:'absolute',left: mouse.x,top: mouse.y}} />);
  }
}

class MouseWithCat extends React.Component {
  constructor(props) {
    super(props);
    this.handleMouseMove = this.handleMouseMove.bind(this);
    this.state = { x: 0, y: 0 };
  }

  handleMouseMove(event) {
    this.setState({x: event.clientX, y: event.clientY});
  }

  render() {
    return (
      <div style={{ height: '300px' }} onMouseMove={this.handleMouseMove}>
        {/* 可以在这里换掉p标签的Cat组件,但是接着需要创建一个单独的MouseWithSomethingElse组件,每次需要使用它时,MouseWithCat组件是不是真的可以重复使用 */}
        <Cat mouse={this.state} />
      </div>
    );
  }
}

class MouseTracker extends React.Component {
  render() {
    return (
      <div>
        <h1>移动鼠标!</h1>
        <MouseWithCat />
      </div>
    );
  }
}

</textarea><pre>
这种方法适用于特定用例,但还没有达到以可复用的方式真正封装行为的目标。现在每当想要鼠标位置用于不同的用例时须创建一个新的组件,本质上是另一个MouseWithCat,它专门为该用例呈现一些东西
这也是render prop的来历:可提供一个带有函数prop的Mouse组件,它能够动态决定什么需要渲染的,而不是将Cat硬编码到Mouse组件里,并有效地改变它的渲染结果。

</textarea><textarea>
  class Cat extends React.Component {
    render() {
      const mouse = this.props.mouse;
      return (<div style={{width:'10px',height:'10px',background:'red',position:'absolute',left: mouse.x,top: mouse.y}} />);
    }
  }
  
  class Mouse extends React.Component {
    constructor(props) {
      super(props);
      this.state = { x: 0, y: 0 };
    }
  
    handleMouseMove(event) {
      this.setState({x: event.clientX, y: event.clientY});
    }
  
    render() {
      return (
        <div style={{ height: '300px' }} onMouseMove={this.handleMouseMove.bind(this)}>
          {/*
            Instead of providing a static representation of what <Mouse> renders,
            use the `render` prop to dynamically determine what to render.
          */}
          {this.props.render(this.state)}
        </div>
      );
    }
  }
  
  class MouseTracker extends React.Component {
    render() {
      return (
        <div>
          <h1>移动鼠标!</h1>
          <Mouse render={mouse => (<Cat mouse={mouse} />)}/>
        </div>
      );
    }
  }

</textarea><pre>
现在提供了一个render方法让Mouse能够动态决定什么需要渲染,而不是克隆Mouse组件然后硬编码来解决特定的用例。
更具体地说,render prop是一个用于告知组件需要渲染什么内容的函数prop。
这项技术使共享行为非常容易。要获得这个行为,只要渲染一个带有render prop的Mouse组件就能够告诉它当前鼠标坐标(x, y)要渲染什么。

关于render prop一个有趣的事情是可以使用带有render prop的常规组件来实现大多数高阶组件(HOC)。例如如果更喜欢使用withMouseHOC而不是Mouse组件,可以使用带有render prop的常规Mouse轻松创建一个,因此可以将任一模式与render prop一起使用。

</textarea>使用具有render prop的普通组件创建HOC<textarea>
function withMouse(Component) {
  return class extends React.Component {
    render() {
      return (
        <Mouse render={mouse => (<Component {...this.props} mouse={mouse} />)}/>
      );
    }
  }
}

</textarea><pre>
使用Props而非rende
重要的是要记住render prop是因为模式才被称为render prop,不一定要用名为render的prop来使用这种模式。任何被用于告知组件需要渲染什么内容的函数prop在技术上都可以被称为“render prop”

</textarea>也可以简单地使用children prop<textarea>
<Mouse children={mouse => (
  <p>鼠标的位置是 {mouse.x},{mouse.y}</p>
)}/>

</textarea>children prop并不真正需要添加到JSX元素的“attributes”列表中。相反,可以直接放置到元素的内部<textarea>
<Mouse>
  {mouse => (
    <p>鼠标的位置是 {mouse.x},{mouse.y}</p>
  )}
</Mouse>

</textarea><pre>
由于这一技术的特殊性,在设计一个类似的API时或许会要直接地在propTypes里声明children的类型应为一个函数。
Mouse.propTypes = {
  children: PropTypes.func.isRequired
};

</textarea>
</div>

<div id="fragments">
<h4>Fragments</h4><pre>
React中的一个常见模式是一个组件返回多个元素。Fragments允许将子列表分组,而无需向DOM添加额外节点。

</textarea><textarea>
render() {
  return (
    <React.Fragment>
      <ChildA />
      <ChildB />
    </React.Fragment>
  );
}

// 一种常见模式是组件返回一个子元素列表
class Table extends React.Component {
  render() {
    return (
      <table>
        <tr><Columns /></tr>
      </table>
    );
  }
}

// 如果在Columns的render()中使用父div,则生成的HTML即<tr><div><td>Hello</td><td>World</td></div></tr>无效
class Columns extends React.Component {
  render() {
    return (<div><td>Hello</td><td>World</td></div>);
  }
}

Fragments解决了这个问题,可以正确的输出< Table />
// <tr><td>Hello</td><td>World</td></tr>
class Columns extends React.Component {
  render() {
    return (
      <React.Fragment>
        <td>Hello</td><td>World</td>
      </React.Fragment>
    );
  }
}

// 短语法: 可以使用一种新的简短的语法来声明Fragments,它看起来像空标签,可以像使用任何其他元素一样使用<> </>,除了它不支持key或属性
class Columns extends React.Component {
  render() {
    return (
      <>
        <td>Hello</td>
        <td>World</td>
      </>
    );
  }
}

</textarea><pre>
带key的Fragments
使用显式React.Fragment语法声明的片段可能具有key。一个使用场景是将一个集合映射到一个Fragments数组
key是唯一可以传递给Fragment的属性。未来可能会添加对其他属性的支持,例如事件。

</textarea><textarea>
function Glossary(props) {
  return (
    <dl>
      {props.items.map(item => (
        <React.Fragment key={item.id}>  // 没有`key`,React 会发出一个关键警告
          <dt>{item.term}</dt>
          <dd>{item.description}</dd>
        </React.Fragment>
      ))}
    </dl>
  );
}

</textarea>
</div>

<div id="hook">
<h4>hook</h4><pre>
Hook是React16.8的新增特性,它可以在不编写class的情况下使用state及其他的React特性

Hook完全可选,无需重写任何已有代码就可以在一些组件中尝试Hook
Hook 100%向后兼容的,Hook不包含任何破坏性改动。
没有计划从React中移除class
Hook不会影响对React概念的理解,相反Hook为已知的React概念提供了更直接的API：props、state、context、refs及生命周期

【 使用hook的动机 】
1、在组件之间复用状态逻辑很难
React没有提供将可复用性行为附加到组件的途径(例如把组件连接到store)。如果使用过React一段时间,也许会熟悉一些解决此类问题的方案,比如render props和高阶组件。但这类方案需要重新组织组件结构,这可能会很麻烦,使代码难以理解。如果在React DevTools中观察过React应用,会发现由providers、consumers、高阶组件、render props等其他抽象层组成的组件会形成嵌套地狱。尽管可以在DevTools过滤掉它们,但这说明了一个更深层次的问题：React需要为共享状态逻辑提供更好的原生途径。
可以使用Hook从组件中提取状态逻辑,使得这些逻辑可以单独测试并复用。Hook使你在无需修改组件结构的情况下复用状态逻辑。这使得在组件间或社区内共享Hook变得更便捷。

2、复杂组件变得难以理解
经常维护的一些组件起初很简单,但逐渐会被状态逻辑和副作用充斥,每个生命周期常包含一些不相关的逻辑。例如组件常在componentDidMount和componentDidUpdate中获取数据,但同一个componentDidMount中可能也包含很多其它的逻辑,如设置事件监听,而之后需在componentWillUnmount中清除。相互关联且需要对照修改的代码被进行了拆分,而完全不相关的代码却在同一个方法中组合在一起。如此很容易产生bug,并且导致逻辑不一致。

在多数情况下,不可能将组件拆分为更小的粒度,因为状态逻辑无处不在,这也给测试带来了一定挑战,同时这也是很多人将React与状态管理库结合使用的原因之一。但这往往会引入了很多抽象概念,需要在不同的文件之间来回切换,使得复用变得更加困难。

为了解决这个问题,Hook将组件中相互关联的部分拆分成更小的函数(比如设置订阅或请求数据),而并非强制按照生命周期划分。还可以使用reducer来管理组件的内部状态,使其更加可预测。
将在使用Effect Hook中对此展开更多讨论。

3、难以理解的class
除了代码复用和代码管理会遇到困难外,class是学习React的一大屏障,必须去理解js中this的工作方式,这与其他语言存在巨大差异,还不能忘记绑定事件处理器。没有稳定的语法提案,这些代码非常冗余。大家可以很好地理解props、state和自顶向下的数据流,但对class却一筹莫展。即便在有经验的React开发者之间,对于函数组件与class组件的差异也存在分歧,甚至还要区分两种组件的使用场景。

class组件会无意中鼓励开发者使用一些让优化措施无效的方案。class也给目前的工具带来了一些问题,例如class不能很好的压缩,并且会使热重载出现不稳定的情况,因此想提供一个使代码更易于优化的API。

为了解决这些问题,Hook使你在非class的情况下可以使用更多的React特性。从概念上讲React组件一直更像是函数。而Hook则拥抱了函数,同时也没有牺牲React的精神原则。Hook提供了问题的解决方案,无需学习复杂的函数式或响应式编程技术

【 什么是Hook 】
Hook是一些可以在函数组件里钩入React state及生命周期等特性的函数。Hook不能在class组件中使用,这使得不使用class也能使用React
React内置了一些像useState这样的Hook,也可以创建自己的Hook来复用不同组件之间的状态逻辑

【 State Hook 】
这个例子用来显示一个计数器。点击按钮计数器的值就会增加：

</textarea><textarea>
// 在函数组件中没有this,所以不能分配或读取this.state,直接在组件中调用useState Hook
import React, { useState } from 'react';
function Example(props) {
  const [count, setCount] = useState(0);  // 数组解构,声明一个叫count的state变量
  return (
    <div>
      <p>You clicked {count} times</p> // 读取State,同class中this.state.count
      <button onClick={() => setCount(count + 1)}>Click me</button> // 更新State,同class中this.setState()
    </div>
  );
}

const Example = (props) => {
  const [count, setCount] = useState(0);  // 数组解构,声明一个叫count的state变量
  return (
    <div>
      <p>You clicked {count} times</p> // 读取State,同class中this.state.count
      <button onClick={() => setCount(count + 1)}>Click me</button> // 更新State,同class中this.setState()
    </div>
  );
}

// 等价的class示例
class Example extends React.Component {
  constructor(props) {
    super(props);
    this.state = {count: 0}; // 在构造函数中设置this.state为{ count: 0 }来初始化count state为0
  }

  render() {
    return (
      <div>
        <p>You clicked {this.state.count} times</p>
        <button onClick={() => this.setState({ count: this.state.count + 1 })}>Click me</button>
      </div>
    );
  }
}

</textarea><pre>
这里的useState就是一个Hook。通过在函数组件里调用它来给组件添加一些内部state。一般来说在函数退出后变量就会消失,但React会在重复渲染时保留这个state。useState会返回一对值：当前状态和一个更新当前状态的函数,可以在事件处理函数中或其他一些地方调用这个函数。它类似class组件的this.setState,但它不会把新的state和旧的state进行合并。这与class里面this.state.count和this.setState类似,唯一区别就是需要成对的获取它们
useState唯一的参数就是初始state,不同于this.state,可以按照需要使用数字或字符串对其进行赋值,而不一定是对象。在上面的例子中计数器是从零开始的,所以初始state就是0,这个初始state参数只有在第一次渲染时会被用到。

声明使用多个state变量
可以在一个组件中多次使用State Hook,如果想要在state中存储两个不同的变量,只需调用useState()两次即可
不必使用多个state变量。State变量可以很好地存储对象和数组,因此仍然可以将相关数据分为一组。然而不像class中的this.setState,更新state变量总是替换它而不是合并它

</textarea><textarea>
function ExampleWithManyStates() {
  const [age, setAge] = useState(42);
  const [fruit, setFruit] = useState('banana');
  const [todos, setTodos] = useState([{ text: 'Learn Hooks' }]);

  function handleOrangeClick() {
    setFruit('orange');  // 和this.setState({ fruit: 'orange' })类似
  }
}

</textarea><pre>
【 Effect Hook 】
在React组件中执行数据获取、设置订阅或手动修改更新React组件中的DOM,这些操作统一称为“副作用”或“作用”。
useEffect就是一个Effect Hook,给函数组件增加了操作副作用的能力,它跟class组件中的componentDidMount、componentDidUpdate和componentWillUnmount生命周期方法具有相同的用途,只不过被合并成了一个API,可以把useEffect Hook看做componentDidMount,componentDidUpdate和componentWillUnmount这三个函数的组合

在React组件中有两种常见副作用操作：需要清除的和不需要清除的

无需清除的effect
有时只想在React更新DOM之后运行一些额外的代码,如发送网络请求、手动变更DOM、记录日志,这些都是常见的无需清除的操作。因为执行完这些操作之后就可以忽略他们了。对比一下使用class和Hook都是怎么实现这些副作用的。

使用class的示例
在React的class组件中render函数是不应该有任何副作用的,一般来说在这里执行操作太早了,基本上都希望在React更新DOM之后才执行操作。

</textarea><textarea>
class Example extends React.Component {
  constructor(props) {
    super(props);
    this.state = {count: 0};
  }

  componentDidMount() {
    document.title = `You clicked ${this.state.count} times`;
  }

  componentDidUpdate() {
    document.title = `You clicked ${this.state.count} times`;
  }

  render() {
    return (
      <div>
        <p>You clicked {this.state.count} times</p>
        <button onClick={() => this.setState({ count: this.state.count + 1 })}>Click me</button>
      </div>
    );
  }
}

</textarea><pre>
在这个class中需要在两个生命周期函数中编写重复的代码,这是因为很多情况下希望在组件加载和更新时执行同样的操作。从概念上说希望它在每次渲染之后执行,但React的class组件没有提供这样的方法。即使提取出一个方法,还是要在两个地方调用它。
这就是为什么在React class中把副作用操作放到componentDidMount和componentDidUpdate函数中

</textarea>使用useEffect hook执行相同的操作<textarea>
import React, { useState, useEffect } from 'react';

function Example() {
  const [count, setCount] = useState(0);  // 声明count state变量

  // 相当于componentDidMount和componentDidUpdate,告诉React需要使用effect,传递函数给useEffect Hook
  // 可以在effect中获取到最新的count值或其他props,因为他在函数的作用域内,Hook使用了js的闭包机制
  useEffect(() => {  
    document.title = `You clicked ${count} times`;  // 使用浏览器的API更新页面标题
  });

  return (
    <div>
      <p>You clicked {count} times</p>
      <button onClick={() => setCount(count + 1)}>Click me</button>
    </div>
  );
}

</textarea><pre>
当React渲染组件时会保存已使用的effect,并在更新完DOM后执行它。这个过程在每次渲染时都会发生,包括首次渲染,React保证了每次运行effect的同时,DOM都已经更新完毕
通过使用这个Hook,可以告诉React组件需要在渲染后执行某些操作。React会保存传递的函数effect,并且在执行DOM更新之后调用它。在这个effect中设置了document的title属性,不过也可以执行数据获取或调用其他命令式的API。

传递给useEffect的函数在每次渲染中都会有所不同,这是刻意为之的。事实上这正是可以在effect中获取最新的count的值,而不用担心其过期的原因。每次重新渲染都会生成新的effect,替换掉之前的。某种意义上讲effect更像是渲染结果的一部分,每个effect属于一次特定的渲染

与componentDidMount或componentDidUpdate不同,使用useEffect调度的effect不会阻塞浏览器更新屏幕,这让应用看起来响应更快。大多数情况下effect不需要同步地执行,在个别情况下如测量布局有单独的useLayoutEffect Hook使用,其API与useEffect相同

需要清除的effect
有一些副作用是需要清除的,如订阅外部数据源。这种情况下清除工作是非常重要的,可以防止引起内存泄露
在React class中通常会在componentDidMount中设置订阅,并在componentWillUnmount中清除它
通过使用Hook可以把组件内相关的副作用组织在一起(例如创建订阅及取消订阅),而不要把它们拆分到不同的生命周期函数里。
副作用函数可以通过返回一个函数来指定如何“清除”副作用

ChatAPI模块允许订阅好友的在线状态。以下是如何使用class订阅和显示该状态
componentDidMount和componentWillUnmount之间相互对应。使用生命周期函数迫使拆分这些逻辑代码,即使这两部分代码都作用于相同的副作用

</textarea><textarea>
class FriendStatus extends React.Component {
  constructor(props) {
    super(props);
    this.state = { isOnline: null };
  }

  componentDidMount() {
    ChatAPI.subscribeToFriendStatus(this.props.friend.id, this.handleStatusChange.bind(this));
  }

  componentWillUnmount() {
    ChatAPI.unsubscribeFromFriendStatus(this.props.friend.id, this.handleStatusChange.bind(this));
  }

  handleStatusChange(status) {
    this.setState({ isOnline: status.isOnline });
  }

  render() {
    if (this.state.isOnline === null) return 'Loading...';
    return this.state.isOnline ? 'Online' : 'Offline';
  }
}

</textarea>使用副作用函数来订阅好友的在线状态,并通过取消订阅来进行清除操作<textarea>
import React, { useState, useEffect } from 'react';

function FriendStatus(props) {
  const [isOnline, setIsOnline] = useState(null);  

  function handleStatusChange(status) {
    setIsOnline(status.isOnline);
  }

  useEffect(() => {  
    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);
    return () => {
      ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);
    };
  });

  if (isOnline === null) return 'Loading...';
  return isOnline ? 'Online' : 'Offline';
}

</textarea><pre>
由于添加和删除订阅的代码的紧密性,所以useEffect的设计是在同一个地方执行。如果effect返回一个函数,React将会在执行清除操作时调用它
在这个示例中React会在组件销毁时取消对ChatAPI的订阅,然后在后续渲染时重新执行副作用函数。如果传给ChatAPI的props.friend.id没有变化,也可以告诉React跳过重新订阅

为什么要在effect中返回一个函数？ 
这是effect可选的清除机制,每个effect都可以返回一个清除函数,如此可以将添加和移除订阅的逻辑放在一起,它们都属于effect的一部分。

React何时清除effect？ 
React会在组件卸载的时候执行清除操作,effect在每次渲染的时候都会执行,这就是为什么React会在执行当前effect之前对上一个effect进行清除

使用多个Effect实现关注点分离
使用Hook其中一个目的就是要解决class中生命周期函数经常包含不相关的逻辑,但又把相关逻辑分离到了几个不同方法中的问题。下述代码是将前述示例中的计数器和好友在线状态指示器逻辑组合在一起的组件：

</pre><textarea>
class FriendStatusWithCounter extends React.Component {
  constructor(props) {
    super(props);
    this.state = { count: 0, isOnline: null };
    this.handleStatusChange = this.handleStatusChange.bind(this);
  }

  componentDidMount() {
    document.title = `You clicked ${this.state.count} times`;
    ChatAPI.subscribeToFriendStatus(this.props.friend.id,this.handleStatusChange);
  }

  componentDidUpdate() {
    document.title = `You clicked ${this.state.count} times`;
  }

  componentWillUnmount() {
    ChatAPI.unsubscribeFromFriendStatus(this.props.friend.id,this.handleStatusChange);
  }

  handleStatusChange(status) {
    this.setState({isOnline: status.isOnline});
  }

</textarea><pre>
设置document.title的逻辑被分割到componentDidMount和componentDidUpdate中,订阅逻辑又被分割到componentDidMount和componentWillUnmount中,而且componentDidMount中同时包含了两个不同功能的代码。
那么Hook如何解决这个问题呢？就像可以使用多个state的Hook一样,也可以使用多个effect,这会将不相关逻辑分离到不同的effect中
Hook允许按照代码的用途分离他们,而不是像生命周期函数那样。React将按照effect声明的顺序依次调用组件中的每一个effect

</pre><textarea>
function FriendStatusWithCounter(props) {
  const [count, setCount] = useState(0);
  useEffect(() => {
    document.title = `You clicked ${count} times`;
  });

  const [isOnline, setIsOnline] = useState(null);
  useEffect(() => {
    function handleStatusChange(status) {
      setIsOnline(status.isOnline);
    }

    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);
    return () => {
      ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);
    };
  });
  // ...
}

</textarea><pre>
为什么每次更新的时候都要运行Effect
为什么effect的清除阶段在每次重新渲染时都会执行,而不是只在卸载组件的时候执行一次,这个设计可以帮助创建bug更少的组件。

一个用于显示好友是否在线的FriendStatus组件。从class中props读取friend.id,然后在组件挂载后订阅好友的状态,并在卸载组件的时候取消订阅
componentDidMount() {
  ChatAPI.subscribeToFriendStatus(this.props.friend.id, this.handleStatusChange);
}
componentWillUnmount() {
  ChatAPI.unsubscribeFromFriendStatus(this.props.friend.id, this.handleStatusChange);
}

但当组件已经显示在屏幕上时,friend prop发生变化时会发生什么？组件将继续展示原来的好友状态,这是一个bug。而且还会因为取消订阅时使用错误的好友ID导致内存泄露或崩溃的问题。忘记正确地处理componentDidUpdate是React应用中常见的bug来源

在class组件中需要添加componentDidUpdate来解决这个问题：
componentDidUpdate(prevProps) {
  // 取消订阅之前的friend.id
  ChatAPI.unsubscribeFromFriendStatus(prevProps.friend.id,this.handleStatusChange);
  // 订阅新的friend.id
  ChatAPI.subscribeToFriendStatus(this.props.friend.id,this.handleStatusChange);
}

</textarea>使用Hook的版本：<textarea>
function FriendStatus(props) {
  // ...
  useEffect(() => {
    // ...
    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);
    return () => {
      ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);
    };
  });

</textarea><pre>
它并不会受到此bug影响,虽然没有对它做任何改动
并不需要特定的代码来处理更新逻辑,因为useEffect默认就会处理。它会在调用一个新的effect之前对前一个effect进行清理。为了说明这一点,下面按时间列出一个可能会产生的订阅和取消订阅操作调用序列：

// Mount with { friend: { id: 100 } } props
ChatAPI.subscribeToFriendStatus(100, handleStatusChange);     // 运行第一个 effect

// Update with { friend: { id: 200 } } props
ChatAPI.unsubscribeFromFriendStatus(100, handleStatusChange); // 清除上一个 effect
ChatAPI.subscribeToFriendStatus(200, handleStatusChange);     // 运行下一个 effect

// Update with { friend: { id: 300 } } props
ChatAPI.unsubscribeFromFriendStatus(200, handleStatusChange); // 清除上一个 effect
ChatAPI.subscribeToFriendStatus(300, handleStatusChange);     // 运行下一个 effect

// Unmount
ChatAPI.unsubscribeFromFriendStatus(300, handleStatusChange); // 清除最后一个 effect
此默认行为保证了一致性,避免了在class组件中因为没有处理更新逻辑而导致常见的bug

通过跳过Effect进行性能优化
在某些情况下每次渲染后都执行清理或执行effect可能会导致性能问题。在class组件中可以通过在componentDidUpdate中添加对prevProps或prevState的比较逻辑解决：
componentDidUpdate(prevProps, prevState) {
  if (prevState.count !== this.state.count) document.title = `You clicked ${this.state.count} times`;
}

这是很常见的需求,所以它被内置到了useEffect的Hook API中。如果某些特定值在两次重渲染之间没有发生变化,可以通知React跳过对effect的调用,只要传递数组如[count]作为useEffect的第二个可选参数即可：

useEffect(() => {
  document.title = `You clicked ${count} times`;
}, [count]); // 仅在count更改时更新

如果count的值是5,而且组件重渲染的时候count还是等于5,React将对前一次渲染的[5]和后一次渲染的[5]进行比较。因为数组中的所有元素都是相等的(5===5),React会跳过这个effect,这就实现了性能的优化。
当渲染时,如果count的值更新成了6,React将会把前一次渲染时的数组[5]和这次渲染的数组[6]中的元素进行对比。这次因为5!==6,React就会再次调用effect。如果数组中有多个元素,即使只有一个元素发生变化,React也会执行effect。

</textarea>对于有清除操作的effect同样适用<textarea>
useEffect(() => {
  function handleStatusChange(status) {
    setIsOnline(status.isOnline);
  }

  ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);
  return () => {
    ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);
  };
}, [props.friend.id]); // 仅在props.friend.id发生变化时重新订阅

</textarea><pre>
如果要使用此优化方式,请确保数组中包含了所有外部作用域中会随时间变化并且在effect中使用的变量,否则代码会引用到先前渲染中的旧变量

如果想执行只运行一次的effect(仅在组件挂载和卸载时执行),可以传递一个空数组[]作为第二个参数,这就告诉React effect不依赖于props或state中的任何值,所以它永远都不需要重复执行,这并不属于特殊情况,它依然遵循依赖数组的工作方式。
如果传入了一个空数组[],effect内部的props和state就会一直拥有其初始值。尽管传入[]作为第二个参数更接近大家更熟悉的componentDidMount和componentWillUnmount思维模式,但有更好的方式来避免过于频繁的重复调用effect。除此之外记得React会等待浏览器完成画面渲染之后才会延迟调用useEffect,因此会使得额外操作很方便。

【 useContext 】
useContext不使用组件嵌套就可以订阅React的Context

const value = useContext(MyContext);
接收一个React.createContext返回的context对象并返回该context的当前值,当前的context值由上层组件中距离当前组件最近的MyContext.Provider的value prop决定。

当组件上层最近的MyContext.Provider更新时,该Hook会触发重渲染,并使用最新传递给MyContext provider的context value值。即使祖先使用React.memo或shouldComponentUpdate,也会在组件本身使用useContext时重新渲染。
调用了useContext的组件总会在context值变化时重新渲染。如果重渲染组件的开销较大,可以通过使用memoization来优化。

useContext(MyContext)相当于class组件中的static contextType = MyContext或MyContext.Consumer
useContext(MyContext)只是能够读取context的值及订阅context的变化,仍然需要在上层组件树中使用MyContext.Provider来为下层组件提供context。

</textarea><textarea>
function Example() {
  const locale = React.useContext(LocaleContext);
  const theme = React.useContext(ThemeContext);
  // ...
}

</textarea><textarea>
const themes = {
  light: {
    foreground: "#000000",
    background: "#eeeeee"
  },
  dark: {
    foreground: "#ffffff",
    background: "#222222"
  }
};

const ThemeContext = React.createContext(themes.light);

function App() {
  return (
    <ThemeContext.Provider value={themes.dark}>
      <Toolbar />
    </ThemeContext.Provider>
  );
}

function Toolbar(props) {
  return (
    <div>
      <ThemedButton />
    </div>
  );
}

function ThemedButton() {
  const theme = useContext(ThemeContext);
  return (
    <button style={{ background: theme.background, color: theme.foreground }}>I am styled by theme context!</button>
  );
}

</textarea><pre>
【 useReducer 】
useReducer可以通过reducer来管理组件本地的复杂state

const [state, dispatch] = useReducer(reducer, initialArg, init);
useState的替代方案,接收一个形如(state, action) => newState的reducer,并返回当前的state以及与其配套的dispatch方法
在某些场景下useReducer会比useState更适用,例如state逻辑较复杂且包含多个子值,或者下一个state依赖于之前的state等。并且使用useReducer还能给那些会触发深更新的组件做性能优化,因为可以向子组件传递dispatch而不是回调函数

</textarea>用reducer重写useState的计数器<textarea>
import React, { useState, useEffect, useReducer } from 'react';

const initialState = {count: 0};

function reducer(state, action) {
  switch (action.type) {
    case 'increment': return {count: state.count + 1};
    case 'decrement': return {count: state.count - 1};
    default: throw new Error();
  }
}

export default function Counter() {
  const [state, dispatch] = useReducer(reducer, initialState);
  return (
    <>
      Count: {state.count}
      <button onClick={ () => dispatch({type: 'decrement'}) }>-</button>
      <button onClick={ () => dispatch({type: 'increment'}) }>+</button>
    </>
  );
}

</textarea></pre>

React会确保dispatch函数的标识是稳定的,并且不会在组件重新渲染时改变,这就是为什么可以安全地从useEffect或useCallback的依赖列表中省略dispatch。

指定初始state
有两种不同初始化useReducer state的方式,可以根据使用场景选择其中的一种。将初始state作为第二个参数传入useReducer是最简单的方法：
const [state, dispatch] = useReducer(reducer, {count: initialCount});

React不使用state = initialState这一由Redux推广开来的参数约定。有时候初始值依赖于props,因此需要在调用Hook时指定。如果特别喜欢上述的参数约定,可以通过调用useReducer(reducer, undefined, reducer)来模拟Redux的行为,但不鼓励这么做。

惰性初始化
可以选择惰性地创建初始state。为此需要将init函数作为useReducer的第三个参数传入,这样初始state将被设置为init(initialArg)。
这么做可以将用于计算state的逻辑提取到reducer外部,这也为将来对重置state的action做处理提供了便利：

</textarea><textarea>
function init(initialCount) {
  return {count: initialCount};
}

function reducer(state, action) {
  switch (action.type) {
    case 'increment': return {count: state.count + 1};
    case 'decrement': return {count: state.count - 1};
    case 'reset': return init(action.payload);
    default: throw new Error();
  }
}

function Counter({initialCount}) {
  const [state, dispatch] = useReducer(reducer, initialCount, init);
  return (
    <>
      Count: {state.count}
      <button onClick={ () => dispatch({type: 'reset', payload: initialCount}) }>Reset</button>
      <button onClick={ () => dispatch({type: 'decrement'}) }>-</button>
      <button onClick={ () => dispatch({type: 'increment'}) }>+</button>
    </>
  );
}

</textarea><pre>
跳过dispatch
如果Reducer Hook的返回值与当前state相同,React将跳过子组件的渲染及副作用的执行。React使用Object.is比较算法来比较state
React可能仍需要在跳过渲染前再次渲染该组件。不过由于React不会对组件树的“深层”节点进行不必要的渲染,所以大可不必担心。如果在渲染期间执行了高开销的计算,则可以使用useMemo来进行优化。

【 useRef 】
const refContainer = useRef(initialValue);
useRef返回一个可变的ref对象,其.current属性被初始化为传入的参数initialValue,返回的ref对象在组件的整个生命周期内保持不变。

</textarea>一个常见的用例便是命令式地访问子组件<textarea>
function TextInputWithFocusButton() {
  const inputEl = useRef(null);
  const onButtonClick = () => {
    inputEl.current.focus();  // `current`指向已挂载到DOM上的文本输入元素
  };
  return (
    <>
      <input ref={inputEl} type="text" />
      <button onClick={onButtonClick}>Focus the input</button>
    </>
  );
}

</textarea><pre>
本质上useRef就像是可以在其.current属性中保存一个可变值的“盒子”。
ref这一种访问DOM的主要方式。如果将ref对象以< div ref={myRef} />形式传入组件,则无论该节点如何改变,React都会将ref对象的.current属性设置为相应的DOM节点。
然而useRef()比ref属性更有用,它可以很方便地保存任何可变值,其类似于在class中使用实例字段的方式。
这是因为它创建的是一个普通Javascript对象。而useRef()和自建一个{current: ...}对象的唯一区别是,useRef会在每次渲染时返回同一个ref对象。

当ref对象内容发生变化时,useRef并不会通知你。变更.current属性不会引发组件重新渲染。如果想要在React绑定或解绑DOM节点的ref时运行某些代码,则需要使用回调ref来实现。

【 useMemo 】
const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);
返回一个memoized值。
把“创建”函数和依赖项数组作为参数传入useMemo,它仅会在某个依赖项改变时才重新计算memoized值,这种优化有助于避免在每次渲染时都进行高开销的计算。
传入useMemo的函数会在渲染期间执行,不要在这个函数内部执行与渲染无关的操作,诸如副作用这类的操作属于 useEffect 的适用范畴,而不是 useMemo。
如果没有提供依赖项数组,useMemo在每次渲染时都会计算新的值。

可以把useMemo作为性能优化的手段,但不要把它当成语义上的保证。将来React可能会选择“遗忘”以前的一些memoized值,并在下次渲染时重新计算它们,比如为离屏组件释放内存。先编写在没有useMemo的情况下也可以执行的代码,之后再在代码中添加useMemo,以达到优化性能的目的。

依赖项数组不会作为参数传给“创建”函数。虽然从概念上来说它表现为：所有“创建”函数中引用的值都应该出现在依赖项数组中。未来编译器会更加智能,届时自动创建数组将成为可能。

【 useCallback 】

</textarea><textarea>
const memoizedCallback = useCallback(
  () => {
    doSomething(a, b);
  },
  [a, b],
);

</textarea><pre>
返回一个memoized回调函数。
把内联回调函数及依赖项数组作为参数传入useCallback,它将返回该回调函数的memoized版本,该回调函数仅在某个依赖项改变时才会更新。当把回调函数传递给经过优化的并使用引用相等性去避免非必要渲染(例如shouldComponentUpdate)的子组件时,它将非常有用。

useCallback(fn, deps) 相当于 useMemo(() => fn, deps)。

依赖项数组不会作为参数传给回调函数。虽然从概念上来说它表现为：所有回调函数中引用的值都应该出现在依赖项数组中。未来编译器会更加智能,届时自动创建数组将成为可能。

【 Hook使用规则 】
Hook就是Js函数,但使用它们会有两个额外的规则,同时React提供了linter插件来自动执行这些规则。这些规则乍看起来会有一些限制和令人困惑,但是要让Hook正常工作,它们至关重要。
1、只能在函数最外层调用Hook,不要在循环、条件判断或子函数中调用。
2、只能在React的函数组件中调用Hook,不要在其他js函数中调用,还有一个地方可以调用Hook,就是自定义的Hook中

【 自定义Hook 】
有时候想要在组件之间重用一些状态逻辑。目前为止有两种主流方案来解决这个问题：高阶组件和render props。自定义Hook可以在不增加组件的情况下达到同样的目的。

</textarea><textarea>
// 该组件用于显示好友的在线状态,通过调用useState和useEffect的Hook来订阅一个好友的在线状态
import React, { useState, useEffect } from 'react';

function FriendStatus(props) {
  const [isOnline, setIsOnline] = useState(null);

  useEffect(() => {
    function handleStatusChange(status) {
      setIsOnline(status.isOnline);
    }

    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);
    return () => {
      ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);
    };
  });

  if (isOnline === null) return 'Loading...';
  return isOnline ? 'Online' : 'Offline';
}

// 假设聊天应用中有一个联系人列表,当用户在线时需要把名字设置为绿色。可以把上面类似的逻辑复制并粘贴到FriendListItem组件中来,但这并不是理想的解决方案,希望在FriendStatus和FriendListItem之间共享重用这个订阅逻辑

import React, { useState, useEffect } from 'react';

function FriendListItem(props) {
  const [isOnline, setIsOnline] = useState(null);

  useEffect(() => {
    function handleStatusChange(status) {
      setIsOnline(status.isOnline);
    }

    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);
    return () => {
      ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);
    };
  });

  return (<li style={{ color: isOnline ? 'green' : 'black' }}>{props.friend.name}</li>);
}

</textarea><pre>
提取自定义Hook
当在两个函数之间共享逻辑时,会把它提取到第三个函数中。而组件和Hook都是函数,所以也同样适用这种方式。
自定义Hook是一个函数,其名称以“use”开头,函数内部可以调用其他的Hook。 例如下面的useFriendStatus是第一个自定义的Hook,它将friendID作为参数,并返回该好友是否在线,目标是在 FriendStatus 和 FriendListItem组件中去除重复的逻辑,即：这两个组件都想知道好友是否在线

此处并未包含任何新的内容,逻辑是从上述组件拷贝来的。与组件中一致,请确保只在自定义Hook的顶层无条件地调用其他Hook。

与React组件不同的是,自定义Hook不需要具有特殊的标识。可以自由的决定它的参数是什么,以及它应该返回什么(如果需要的话)。换句话说,它就像一个正常的函数。但它的名字应该始终以use开头,这样可以一眼看出其符合Hook的规则。

此处useFriendStatus的Hook目的是订阅某个好友的在线状态,这就是需要将friendID作为参数,并返回这位好友的在线状态的原因。

</textarea><textarea>
import React, { useState, useEffect } from 'react';

function useFriendStatus(friendID) {
  const [isOnline, setIsOnline] = useState(null);

  function handleStatusChange(status) {
    setIsOnline(status.isOnline);
  }

  useEffect(() => {
    ChatAPI.subscribeToFriendStatus(friendID, handleStatusChange);
    return () => {
      ChatAPI.unsubscribeFromFriendStatus(friendID, handleStatusChange);
    };
  });

  return isOnline;
}

// 现在可以在两个组件中使用它：
function FriendStatus(props) {
  const isOnline = useFriendStatus(props.friend.id);
  if (isOnline === null) return 'Loading...';
  return isOnline ? 'Online' : 'Offline';
}

function FriendListItem(props) {
  const isOnline = useFriendStatus(props.friend.id);
  return (
    <li style={{ color: isOnline ? 'green' : 'black' }}>
      {props.friend.name}
    </li>
  );
}

</textarea><pre>
这两个组件的state是完全独立的。Hook是一种复用状态逻辑的方式,它不复用state本身。事实上Hook的每次调用都有一个完全独立的state,因此可以在单个组件中多次调用同一个自定义Hook。
每次调用Hook都会获取独立的state。由于直接调用了useFriendStatus,从React的角度来看,组件只是调用了useState和useEffect,可以在一个组件中多次调用useState和useEffect,它们是完全独立的。

自定义Hook更像是一种约定而不是功能。如果函数的名字以“use”开头并调用其他Hook,就说这是一个自定义Hook。useSomething的命名约定可以让linter插件在使用Hook的代码中找到bug。

可以创建涵盖各种场景的自定义Hook,如表单处理、动画、订阅声明、计时器等场景

【 提示：在多个Hook之间传递信息 】
由于Hook本身就是函数,因此可以在它们之间传递信息。
将使用聊天程序中的另一个组件来说明这一点。这是一个聊天消息接收者的选择器,它会显示当前选定的好友是否在线:

</textarea><textarea>
const friendList = [
  { id: 1, name: 'Phoebe' },
  { id: 2, name: 'Rachel' },
  { id: 3, name: 'Ross' },
];

function ChatRecipientPicker() {
  const [recipientID, setRecipientID] = useState(1);
  const isRecipientOnline = useFriendStatus(recipientID);

  return (
    <>
      <Circle color={isRecipientOnline ? 'green' : 'red'} />
      <select value={recipientID} onChange={e => setRecipientID(Number(e.target.value))}>
        {friendList.map(friend => (
          <option key={friend.id} value={friend.id}>{friend.name}</option>
        ))}
      </select>
    </>
  );
}

</textarea><pre>
将当前选择的好友ID保存在recipientID状态变量中,并在用户从select中选择其他好友时更新这个state。
由于useState提供了recipientID状态变量的最新值,因此可以将它作为参数传递给自定义的useFriendStatus Hook：

const [recipientID, setRecipientID] = useState(1);
const isRecipientOnline = useFriendStatus(recipientID);
 
如此可以让我们知道当前选中的好友是否在线。当我们选择不同的好友并更新recipientID状态变量时,useFriendStatus Hook将会取消订阅之前选中的好友,并订阅新选中的好友状态。

【 useYourImagination() 】
自定义Hook解决了以前在React组件中无法灵活共享逻辑的问题。可以创建涵盖各种场景的自定义Hook,如表单处理、动画、订阅声明、计时器等。更重要的是,创建自定义Hook就像使用React内置的功能一样简单。

尽量避免过早地增加抽象逻辑。既然函数组件能够做的更多,那么代码库中函数组件的代码行数可能会剧增,这属于正常现象,不必立即将它们拆分为Hook。但仍鼓励能通过自定义Hook寻找可能,以达到简化代码逻辑,解决组件杂乱无章的目的。

例如,有个复杂的组件包含大量以特殊的方式来管理的内部状态。useState并不会使得集中更新逻辑变得容易,因此可能更愿意使用redux中的reducer来编写。

</textarea><textarea>
function todosReducer(state, action) {
  switch (action.type) {
    case 'add':
      return [...state, {
        text: action.text,
        completed: false
      }];
    // ... other actions ...
    default:
      return state;
  }
}

</textarea><pre>
Reducers非常便于单独测试,且易于扩展,以表达复杂的更新逻辑。如有必要,可以将它们分成更小的reducer。但可能还享受着React内部state带来的好处,或者可能根本不想安装其他库。
那么为什么不编写一个useReducer的Hook,使用reducer的方式来管理组件的内部state呢？其简化版本可能如下所示：

</textarea><textarea>
function useReducer(reducer, initialState) {
  const [state, setState] = useState(initialState);

  function dispatch(action) {
    const nextState = reducer(state, action);
    setState(nextState);
  }

  return [state, dispatch];
}

// 在组件中使用它,让reducer驱动它管理state：
function Todos() {
  const [todos, dispatch] = useReducer(todosReducer, []);

  function handleAddClick(text) {
    dispatch({ type: 'add', text });
  }

  // ...
}

在复杂组件中使用reducer管理内部state的需求很常见,已经将useReducer的Hook内置到React中,搭配其他内置的Hook一起使用

</textarea>
</div>

<div id="code_splite">
<h4>代码分割</h4><pre>
打包
大多数React应用都会使用Webpack、Rollup或Browserify这类的构建工具来打包文件。打包是一个将文件引入并合并到一个单独文件的过程,最终形成一个bundle。接着在页面上引入该bundle,整个应用即可一次性加载
如果正在使用Create React App、Next.js、Gatsby或者类似的工具,会拥有一个可以直接使用的Webpac 配置来进行打包工作

代码分割
打包是个非常棒的技术,但随着应用增长,代码包也将随之增长,尤其是在整合了体积巨大的第三方库的情况下。你需要关注你代码包中所包含的代码,以避免因体积过大而导致加载时间过长。

为了避免搞出大体积的代码包,在前期就思考该问题并对代码包进行分割是个不错的选择。代码分割是由诸如Webpack、Rollup和Browserify(factor-bundle)这类打包器支持的一项技术,能够创建多个包并在运行时动态加载。
对应用进行代码分割能够帮助“懒加载”当前用户所需要的内容,能够显著地提高应用性能。尽管并没有减少应用整体的代码体积,但可以避免加载用户永远不需要的代码,并在初始加载的时候减少所需加载的代码量

import()
在应用中引入代码分割的最佳方式是通过动态import()语法。

使用之前：
import { add } from './math';
console.log(add(16, 26));
使用之后：
import("./math").then(math => console.log(math.add(16, 26))});

当Webpack解析到该语法时会自动进行代码分割。如果使用 Create React App,该功能已开箱即用,可以立刻使用该特性。Next.js也已支持该特性而无需进行配置。
当使用Babel时,要确保Babel能够解析动态import语法而不是将其进行转换。对于这一要求需要babel-plugin-syntax-dynamic-import插件

React.lazy()
React.lazy函数能像渲染常规组件一样处理动态引入的组件

使用之前：
import OtherComponent from './OtherComponent';
使用之后：
const OtherComponent = React.lazy(() => import('./OtherComponent'));
此代码将会在组件首次渲染时自动导入包含OtherComponent组件的包。

React.lazy接受一个函数,这个函数需要动态调用import()。它必须返回一个Promise,该Promise需要resolve一个defalut export的React组件。
然后应在Suspense组件中渲染lazy组件,如此使得可以使用在等待加载lazy组件时做优雅降级(如loading指示器等)。

</textarea><textarea>
const OtherComponent = React.lazy(() => import('./OtherComponent'));

function MyComponent() {
  return (
    <div>
      <Suspense fallback={<div>Loading...</div>}>
        <OtherComponent />
      </Suspense>
    </div>
  );
}

</textarea><pre>
fallback属性接受任何在组件加载过程中想展示的React元素。可以将Suspense组件置于懒加载组件之上的任何位置,甚至可以用一个Suspense组件包裹多个懒加载组件。

</textarea><textarea>
const OtherComponent = React.lazy(() => import('./OtherComponent'));
const AnotherComponent = React.lazy(() => import('./AnotherComponent'));

function MyComponent() {
  return (
    <div>
      <Suspense fallback={<div>Loading...</div>}>
        <section>
          <OtherComponent />
          <AnotherComponent />
        </section>
      </Suspense>
    </div>
  );
}

</textarea><pre>
异常捕获边界(Error boundaries)
如果模块加载失败如网络问题,它会触发一个错误。可以通过异常捕获边界技术来处理这些情况,以显示良好的用户体验并管理恢复事宜。

</textarea><textarea>
import MyErrorBoundary from './MyErrorBoundary';
const OtherComponent = React.lazy(() => import('./OtherComponent'));
const AnotherComponent = React.lazy(() => import('./AnotherComponent'));

const MyComponent = () => (
  <div>
    <MyErrorBoundary>
      <Suspense fallback={<div>Loading...</div>}>
        <section>
          <OtherComponent />
          <AnotherComponent />
        </section>
      </Suspense>
    </MyErrorBoundary>
  </div>
);

</textarea><pre>
基于路由的代码分割
决定在哪引入代码分割需要一些技巧,需要确保选择的位置能够均匀地分割代码包而不会影响用户体验。
一个不错的选择是从路由开始。大多数网络用户习惯于页面之间能有个加载切换过程。也可以选择重新渲染整个页面,这样用户就不必在渲染的同时再和页面上的其他元素进行交互。

</textarea><textarea>
// 应用中使用React.lazy和React Router这类的第三方库来配置基于路由的代码分割。
import { BrowserRouter as Router, Route, Switch } from 'react-router-dom';
import React, { Suspense, lazy } from 'react';

const Home = lazy(() => import('./routes/Home'));
const About = lazy(() => import('./routes/About'));

const App = () => (
  <Router>
    <Suspense fallback={<div>Loading...</div>}>
      <Switch>
        <Route exact path="/" component={Home}/>
        <Route path="/about" component={About}/>
      </Switch>
    </Suspense>
  </Router>
);

</textarea><pre>
命名导出(Named Exports)
React.lazy目前只支持默认导出(default exports)。如果想被引入的模块使用命名导出(named exports),可以创建一个中间模块来重新导出为默认模块。这能保证tree shaking不会出错,并且不必引入不需要的组件。

// ManyComponents.js
export const MyComponent = /* ... */;
export const MyUnusedComponent = /* ... */;
// MyComponent.js
export { MyComponent as default } from "./ManyComponents.js";
// MyApp.js
import React, { lazy } from 'react';
const MyComponent = lazy(() => import("./MyComponent.js"));

</pre>
</div>

<div id="redux">
<h3>redux</h3><pre>
https://unpkg.com/redux@latest/dist/redux.min.js

为什么要用redux
在React中数据在组件中是单向流动的,数据从一个方向通过props父组件流向子组件,所以两个非父子组件之间通信就相对麻烦,redux的出现就是为了解决state里面的数据问题

Redux设计理念
Redux是将整个应用状态存储到一个地方store,里面保存着一个状态树store tree,组件可以派发(dispatch)行为(action)给store,而不是直接通知其他组件,组件内部通过订阅store中的状态state来刷新自己的视图

Redux的设计思想
1、Web应用是一个状态机,视图与状态是一一对应的。
2、所有的状态,保存在一个对象里面

为什么需要状态管理？
对于SPA应用来说,前端所需要管理的状态越来越多,需要查询、更新、传递的状态也越来越多,如果让每个组件都存储自身相关的状态,理论上来讲不会影响应用的运行,但在开发及后续维护阶段将花费大量精力去查询状态的变化过程,在多组合组件通信或客户端与服务端有较多交互过程中往往需要去更新、维护并监听每一个组件的状态,在这种情况下如果有一种可以对状态做集中管理的地方会更好,状态管理好比是一个集中的配置箱,当需要更新状态的时候仅对这个黑箱进行输入,而不用去关心状态是如何分发到每一个组件内部的,这可以让开发者将精力更好的放在业务逻辑上。

但状态管理并不是必需品,当UI层比较简单、没有较多的交互去改变状态的场景下,使用状态管理方式反倒会让项目变的复杂。Redux的发明者Dan Abramov就说过：“只有遇到React实在解决不了的问题才需要Redux”。

一般在以下场景下或许需要使用状态管理机制去维护应用：
用户操作较为繁琐,导致组件间需要有状态依赖关系,如根据多筛选条件来控制其他组件的功能。
客户端权限较多且有不同的使用方式,如管理层、普通层级等。
客户端与服务端有大量交互,例如请求信息实时性要求较高导致需要保证鲜活度。
前端数据缓存部分较多,如记录用户对表单的提交前操作、分页控制等

不需要使用Redux的情况:
用户的使用方式非常简单
用户之间没有协作
不需要与服务器大量交互,也没有使用 WebSocket
视图层(View)只从单一来源获取数据

Redux的适用场景：多交互、多数据源
用户的使用方式复杂
不同身份的用户有不同的使用方式(比如普通用户和管理员)
多个用户之间可以协作
与服务器大量交互,或者使用了WebSocket
View要从多个来源获取数据

从组件角度看可以考虑使用Redux的场景
某个组件的状态,需要共享
某个状态需要在任何地方都可以拿到
一个组件需要改变全局状态
一个组件需要改变另一个组件的状态
发生上面情况时,如果不使用Redux或其他状态管理工具,不按照一定规律处理状态的读写,代码很快就会变成一团乱麻。需要一种机制,可以在同一个地方查询状态、改变状态、传播状态的变化

Redux应用的三大原则
1、单一数据源
可以把Redux的状态管理理解成一个唯一的全局对象,整个应用所有的状态都在全局对象store下进行统一配置,这样做也是为了做统一管理,便于调试与维护。

2、State是只读的
与React的setState相似,直接改变组件的state是不会触发render进行渲染组件的。同样在Redux中唯一改变state的方法就是触发action,action是一个用于描述发生了什么的关键词,而具体使action在state上更新生效的是reducer,用来描述事件发生的详细过程,reducer充当了发起一个action连接到state的桥梁。这样做的好处是当开发者试图去修改状态时Redux会记录这个动作是什么类型的、具体完成了什么功能等(更新、传播过程),在调试阶段可以为开发者提供完整的数据流路径。

3、Reducer必须是一个纯函数
Reducer用来描述action如何改变state,接收旧的state和action,返回新的state。Reducer内部的执行操作必须是无副作用的,不能对state进行直接修改,当状态发生变化时需要返回一个全新的对象代表新的state。这样做的好处是状态的更新是可预测的,另外这与Redux的比较分发机制相关,阅读Redux判断状态更新的源码部分(combineReducers)发现Redux是对新旧state直接用==来进行比较,也就是浅比较,如果直接在state对象上进行修改,那么state所分配的内存地址其实是没有变化的,“==”是比较对象间的内存地址,因此Redux将不会响应更新。之所以这样处理是避免对象深层次比较所带来的性能损耗(需要递归遍历比较)。

【 基本概念 】
Store
Store就是保存数据的地方,可以把它看成一个容器,整个应用只能有一个Store
Redux提供createStore函数接受另一个函数作为参数用来生成Store对象
import { createStore } from 'redux';
const store = createStore(fn);

State
Store对象包含所有数据,如果想得到某个时点的数据就要对Store生成快照,这种时点的数据集合就叫做State
当前时刻的State可以通过store.getState()拿到。
import { createStore } from 'redux';
const store = createStore(fn);
const state = store.getState();
Redux规定一个State对应一个View,只要State相同View就相同,知道State就知道View是什么样,反之亦然

Action
State变化导致View的变化,但用户接触不到State,只能接触到View,所以State的变化必须是View导致的。Action就是View发出的通知,表示State应该要发生变化
Action是一个对象,其中的type属性是必须的,表示Action的名称,其他属性可以自由设置。
Action描述当前发生的事情。改变State的唯一办法就是使用Action,它会运送数据到Store

// Action的名称是ADD_TODO,它携带的信息是字符串Learn Redux
const action = { type: 'ADD_TODO', payload: 'Learn Redux' };

Action Creator
View要发送多少种消息就会有多少种Action。如果都手写会很麻烦。可以定义一个函数来生成Action,这个函数就叫Action Creator,下面实例中addTodo函数就是一个Action Creator

const ADD_TODO = '添加 TODO';
const addTodo = (text) => { type: ADD_TODO, text }
const action = addTodo('Learn Redux');

store.dispatch()
store.dispatch()是View发出Action的唯一方法。
store.dispatch接受一个Action对象作为参数,将它发送出去

import { createStore } from 'redux';
const store = createStore(fn);
store.dispatch({ type: 'ADD_TODO', payload: 'Learn Redux' });

结合Action Creator,这段代码可以改写如下
store.dispatch(addTodo('Learn Redux'));

Reducer
Store收到Action后必须给出一个新的State,这样View才会发生变化,这种State的计算过程就叫做Reducer。
Reducer是一个函数,它接受当前State和Action作为参数,返回一个新的State。

</pre><textarea>
const reducer = function (state, action) {
  // ...
  return new_state;
};

整个应用的初始状态可以作为State的默认值
const defaultState = 0;
const reducer = (state = defaultState, action) => {
  switch (action.type) {
    case 'ADD':
      return state + action.payload;
    default: 
      return state;
  }
};

const state = reducer(1, {
  type: 'ADD',
  payload: 2
});

</textarea><pre>
实际应用中Reducer函数不用手动调用,store.dispatch方法会触发Reducer的自动执行。为此Store需要知道Reducer函数,做法就是在生成Store的时候将Reducer传入createStore方法。

import { createStore } from 'redux';
const store = createStore(reducer);

createStore接受Reducer作为参数,生成一个新的Store。以后每当store.dispatch发送过来一个新的Action就会自动调用Reducer得到新的State

为什么这个函数叫做Reducer呢？因为它可以作为数组的reduce方法的参数,下面的例子,一系列Action对象按照顺序作为一个数组。

// 数组actions表示依次有三个Action,分别是加0、1和2,数组的reduce方法接受Reducer函数作为参数就可以直接得到最终的状态3
const actions = [
  { type: 'ADD', payload: 0 },
  { type: 'ADD', payload: 1 },
  { type: 'ADD', payload: 2 }
];
const total = actions.reduce(reducer, 0); // 3

纯函数
Reducer函数最重要的特征是它是一个纯函数,即只要是同样的输入必定得到同样的输出。

纯函数是函数式编程的概念,必须遵守以下一些约束。
不得改写参数
不能调用系统I/O的API
不能调用Date.now()或Math.random()等不纯的方法,因为每次会得到不一样的结果

由于Reducer是纯函数,可以保证同样的State必定得到同样的View。但也正因为这一点,Reducer函数里面不能改变State,必须返回一个全新的对象

</pre><textarea>
// State是一个对象
function reducer(state, action) {
  return Object.assign({}, state, { thingToChange });
  // 或者
  return { ...state, ...newState };
}

// State是一个数组
function reducer(state, action) {
  return [...state, newItem];
}

</textarea><pre>
最好把State对象设成只读,没法改变它,要得到新的State唯一办法就是生成一个新对象。这样的好处是任何时候与某个View对应的State总是一个不变的对象

store.subscribe()
Store允许使用store.subscribe方法设置监听函数,一旦State发生变化就自动执行这个函数。
只要dispatch 一个action, 应用的状态发生改变,subscribe中的回调就会执行,确保获取到最新的state.

import { createStore } from 'redux';
const store = createStore(reducer);
store.subscribe(listener);

显然只要把View的更新函数(对于React项目就是组件的render方法或setState方法)放入listen就会实现View的自动渲染。

store.subscribe方法返回一个函数,调用这个函数就可以解除监听。

let unsubscribe = store.subscribe(() => console.log(store.getState()));
unsubscribe();

【 Store的实现 】
createStore函数接受reducer和intialState作为参数,然后返回一个store对象,这个对象有getState(), subscribe(), dispatch()方法

import { createStore } from 'redux';
let { subscribe, dispatch, getState } = createStore(reducer);

createStore方法还可接受第二个参数表示State的最初状态即整个应用的状态初始值,这通常是服务器给出的,如果提供了这个参数它会覆盖Reducer函数的默认初始值
let store = createStore(todoReducer, window.STATE_FROM_SERVER)

</textarea>createStore方法生成Store的一个简单实现<textarea>
const createStore = (reducer) => {
  let state;
  let listeners = [];

  const getState = () => state;

  const dispatch = (action) => {
    state = reducer(state, action);
    listeners.forEach(listener => listener());
  };

  const subscribe = (listener) => {
    listeners.push(listener);
    return () => {
      listeners = listeners.filter(l => l !== listener);
    }
  };

  dispatch({});

  return { getState, dispatch, subscribe };
};

</textarea><pre>
Reducer函数的拆分
Reducer函数负责生成State。由于整个应用只有一个State对象,包含所有数据,对于大型应用来说这个State必然十分庞大,导致Reducer函数也十分庞大

</textarea><textarea>
const chatReducer = (state = defaultState, action = {}) => {
  const { type, payload } = action;
  switch (type) {
    case ADD_CHAT: return Object.assign({}, state, { chatLog: state.chatLog.concat(payload) });
    case CHANGE_STATUS: return Object.assign({}, state, { statusMessage: payload });
    case CHANGE_USERNAME: return Object.assign({}, state, { userName: payload });
    default: return state;
  }
};

// 三种Action分别改变State的三个属性,这三个属性之间没有联系,可以把Reducer函数拆分。不同的函数负责处理不同属性,最终合并成一个大的Reducer即可
// Reducer函数被拆成了三个小函数,每一个负责生成对应的属性
const chatReducer = (state = defaultState, action = {}) => {
  return {
    chatLog: chatLog(state.chatLog, action),
    statusMessage: statusMessage(state.statusMessage, action),
    userName: userName(state.userName, action)
  }
};

</textarea><pre>
Reducer拆分之后就易读易写多了,而且这种拆分与React应用的结构相吻合：一个React根组件由很多子组件构成,这就是说子组件与子Reducer完全可以对应。
Redux提供了一个combineReducers方法,用于Reducer的拆分,只要定义各个子Reducer函数,然后用这个方法将它们合成一个大的Reducer函数
该函数根据State的key去执行相应的子Reducer,并将返回结果合并成一个大的State对象

</textarea><textarea>
import { combineReducers } from 'redux';

const chatReducer = combineReducers({
  chatLog,
  statusMessage,
  userName
})

export default todoApp;

</textarea>这种写法有一个前提,就是State的属性名必须与子Reducer同名。如果不同名就要采用下面的写法<textarea>
const reducer = combineReducers({
  a: doSomethingWithA,
  b: processB,
  c: c
})
// 等同于
function reducer(state = {}, action) {
  return {
    a: doSomethingWithA(state.a, action),
    b: processB(state.b, action),
    c: c(state.c, action)
  }
}

</textarea>combineReducer的简单实现<textarea>
const combineReducers = reducers => {
  return (state = {}, action) => {
    return Object.keys(reducers).reduce(
      (nextState, key) => {
        nextState[key] = reducers[key](state[key], action);
        return nextState;
      },
      {} 
    );
  };
};

</textarea><pre>
可以把所有子Reducer放在一个文件里面后统一引入

import { combineReducers } from 'redux'
import * as reducers from './reducers'
const reducer = combineReducers(reducers)

</textarea>Redux源码<textarea>
let createStore = (reducer) => {
  let state;          //获取状态对象
  let listeners = []; //存放所有的监听函数

  let getState = () => state;
  
  //提供一个方法供外部调用派发action
  let dispath = (action) => {
    state = reducer(state, action); //调用管理员reducer得到新的state
    listeners.forEach(l => l())   //执行所有的监听函数
  }

  //订阅状态变化事件,当状态改变发生之后执行监听函数
  let subscribe = (listener) => {
    listeners.push(listener);
    return () => {
      listeners = listeners.filter((l) => l != listener)
    }
  }

  dispath();
  return {getState, dispath, subscribe}
}

var reducer = (state = 0, action) => {
  if (!action) return state;
  console.log(action);
  switch (action.type) {
    case 'INCREMENT': return state + 1;
    case 'DECREMENT': return state - 1;
    default: return state;
  }
}

<div id="counter"></div>
<button id="addBtn">+</button>
<button id="minusBtn">-</button>

var store = createStore(reducer);
store.subscribe(function () {
  document.querySelector('#counter').innerHTML = store.getState();
});

document.querySelector('#addBtn').addEventListener('click', function () {
  store.dispatch({type: 'INCREMENT'});
});
document.querySelector('#minusBtn').addEventListener('click', function () {
  store.dispatch({type: 'DECREMENT'});
});

//传入一个renducers管理组,返回的是一个renducer,通过combineReducers方法将多个子Reducer合并成一个大的函数
let combineReducers = (renducers) => {
  return function(state={}, action={}){
    let newState={};
    for(var attr in renducers){
      newState[attr]=renducers[attr](state[attr],action)
    }
    return newState;
  }
}

export {createStore,combineReducers};

</textarea>实例<textarea>
// Redux提供createStore函数用来生成Store
import {createStore} from 'redux'
const store=createStore(fn);

// state即store存储的数据,store可拥有多个state,Redux规定一个state对应一个View,只要state相同view就一样,反之也一样,可通过store.getState()获取
const state=store.getState()

// state的改变会导致View的变化,但在redux中不能直接操作state即不能使用this.setState来操作,用户只能接触到View。在Redux中提供了一个Action对象来告诉Store需要改变state。Action中type属性是必须的,其他的可以根据需求自由设置,payload是携带的数据,Action描述当前发生的事情,这是改变state的唯一的方式
const action={
  type:'ADD_TODO',
  payload:'redux_demo'
}

// store.dispatch()是view发出Action的唯一办法,store.dispatch接收一个Action作为参数,将它发送给store通知store来改变state
store.dispatch({
  type:'ADD_TODO',
  payload:'redux_demo'
})

// Reducer
// Store收到Action以后,必须给出一个新的state,这样view才会发生变化,这种state的计算过程就叫做Reducer。
// Reducer是一个纯函数,接收Action和当前state作为参数,返回一个新的state
// Reducer必须是一个纯函数即函数返回的结果必须由参数state和action决定,而且不产生任何副作用,也不能修改state和action对象
const reducer = (state,action) => {
  switch(action.type){
    case ADD_TODO:
      return newstate;
    default:
      return state
  }
}

</textarea><pre>
【 Redux的工作流程 】
用户发出Action,Reducer函数算出新的State,View重新渲染

首先,用户发出Action
store.dispatch(action);

然后,Store自动调用Reducer,并且传入两个参数：当前State和收到的Action,Reducer返回新的State
let nextState = todoReducer(previousState, action);

State一旦有变化,Store就会调用监听函数。
store.subscribe(listener);  // 设置监听函数

listener可以通过store.getState()得到当前状态,如果使用的是React,这时可以触发重新渲染View。
function listerner() {
  let newState = store.getState();
  component.setState(newState);   
}

</textarea>redux实现简单的计数器<textarea>
<div>
  counter: <span id="value">0</span>
  <button id="increment">+</button>
  <button id="decrement">-</button>
</div>

function counterReducer(state, action) {
  if (typeof state === 'undefined') return 0
  switch (action.type) {
    case 'INCREMENT': return state + 1
    case 'DECREMENT': return state - 1
    default: return state
  }
}

var store = Redux.createStore(counterReducer)
var valueEl = document.getElementById('value')

function render() {
  valueEl.innerHTML = store.getState().toString()
}

render()
store.subscribe(render)

document.getElementById('increment').addEventListener('click', ()=>{store.dispatch({ type: 'INCREMENT' })})
document.getElementById('decrement').addEventListener('click', ()=>{store.dispatch({ type: 'DECREMENT' })})

</textarea>react + redux实现简单的计数器<textarea>
const Counter = ({ value, onIncrement, onDecrement }) => (
  <div>
    <h1>{value}</h1>
    <button onClick={onIncrement}>+</button>
    <button onClick={onDecrement}>-</button>
  </div>
);

const reducer = (state = 0, action) => {
  switch (action.type) {
    case 'INCREMENT': return state + 1;
    case 'DECREMENT': return state - 1;
    default: return state;
  }
};

const store = Redux.createStore(reducer);

const render = () => {
  ReactDOM.render(
    <Counter
      value={store.getState()}
      onIncrement={() => store.dispatch({type: 'INCREMENT'})}
      onDecrement={() => store.dispatch({type: 'DECREMENT'})}
    />,
    document.getElementById('root')
  );
};

render();
store.subscribe(render);

</textarea>
</pre>

<div id="redux_middleware_async">
<h4>redux的中间件和异步操作</h4><pre>
Action发出以后Reducer立即算出State,这叫做同步;Action发出以后过一段时间再执行Reducer,这就是异步。
同步操作:每当dispatch action时state会被立即更新
怎么才能让Reducer在异步操作结束后自动执行呢？这就要用到新的工具：中间件middleware

在redux哪个环节添加功能
(1)Reducer：纯函数,只承担计算State的功能,不合适承担其他功能,也承担不了,因为理论上纯函数不能进行读写操作。
(2)View：与State一一对应,可以看作State的视觉层,也不合适承担其他功能。
(3)Action：存放数据的对象即消息的载体,只能被别人操作,自己不能进行任何操作。
只有发送Action的这个步骤即store.dispatch()方法可以添加功能
比如要添加日志功能,把Action和State打印出来,可以对store.dispatch进行如下改造,对store.dispatch进行了重定义,在发送Action前后添加了打印功能。这就是中间件的雏形
中间件就是一个函数,对store.dispatch方法进行了改造,在发出Action和执行Reducer这两步之间添加了其他功能。

</pre><textarea>
let next = store.dispatch;
store.dispatch = function dispatchAndLog(action) {
  console.log('dispatching', action);
  next(action);
  console.log('next state', store.getState());
}

</textarea><pre>
Redux的核心概念其实很简单：将需要修改的state都存入到store里,发起一个action用来描述发生了什么,用reducers描述action如何改变state tree。创建store的时候需要传入reducer,真正能改变store中数据的是store.dispatch API。
dispatch一个action之后,到达reducer之前,进行一些额外的操作就需要用到middleware。可以利用Redux middleware来进行日志记录、创建崩溃报告、调用异步接口或者路由等,换言之,中间件都是对store.dispatch()的增强

中间件的用法
日志中间件redux-logger模块

</textarea><textarea>
import { applyMiddleware, createStore } from 'redux';
import createLogger from 'redux-logger';
const logger = createLogger();

const store = createStore(
  reducer,
  applyMiddleware(logger) // applyMiddleware是Redux的原生方法,作用是将所有中间件组成一个数组,依次执行
);

</textarea><pre>
redux-logger提供一个生成器createLogger,可以生成日志中间件logger,然后将它放在applyMiddleware方法之中,传入createStore方法就完成了store.dispatch()的功能增强

createStore方法可以接受整个应用的初始状态作为参数,那样的话applyMiddleware就是第三个参数了。
const store = createStore(reducer, initial_state, applyMiddleware(logger));

中间件的次序有讲究
const store = createStore(reducer, applyMiddleware(thunk, promise, logger));
applyMiddleware方法的三个参数就是三个中间件。有的中间件有次序要求,使用前要查一下文档,比如logger就一定要放在最后,否则输出结果会不正确

</textarea>applyMiddleware的源码<textarea>
// 所有中间件被放进了一个数组chain,然后嵌套执行,最后执行store.dispatch。中间件内部(middlewareAPI)可以拿到getState和dispatch这两个方法
export default function applyMiddleware(...middlewares) {
  return (createStore) => (reducer, preloadedState, enhancer) => {
    var store = createStore(reducer, preloadedState, enhancer);
    var dispatch = store.dispatch;
    var chain = [];

    var middlewareAPI = {
      getState: store.getState,
      dispatch: (action) => dispatch(action)
    };
    chain = middlewares.map(middleware => middleware(middlewareAPI));
    dispatch = compose(...chain)(store.dispatch);

    return {...store, dispatch}
  }
}

</textarea><pre>
【 redux异步操作 】
同步操作只要发出一种Action即可,异步操作的差别是它要发出三种Action。
操作发起时的Action
操作成功时的Action
操作失败时的Action

以向服务器取出数据为例,三种Action可以有两种不同的写法。
// 写法一：名称相同,参数不同
{ type: 'FETCH_POSTS' }
{ type: 'FETCH_POSTS', status: 'error', error: 'Oops' }
{ type: 'FETCH_POSTS', status: 'success', response: { ... } }

// 写法二：名称不同
{ type: 'FETCH_POSTS_REQUEST' }
{ type: 'FETCH_POSTS_FAILURE', error: 'Oops' }
{ type: 'FETCH_POSTS_SUCCESS', response: { ... } }

除了Action种类不同,异步操作的State也要进行改造,反映不同的操作状态
let state = {
  // ... 
  isFetching: true,      // 是否在抓取数据
  didInvalidate: true,   // 数据是否过时
  lastUpdated: 'xxxxxxx' // 上一次更新时间
};

异步操作的思路
操作开始时送出一个Action,触发State更新为"正在操作"状态,View重新渲染
操作结束后,再送出一个Action,触发State更新为"操作结束"状态,View再一次重新渲染

【 redux-thunk中间件 】
异步操作至少要送出两个Action：用户触发第一个Action,这个跟同步操作一样;如何才能在操作结束时系统自动送出第二个Action呢？奥妙就在Action Creator之中。

redux-thunk最重要的思想就是可以接受一个返回函数的action creator。如果这个action creator返回的是一个函数就执行它,如果不是就按照原来的next(action)执行。正因为这个action creator可以返回一个函数,那么就可以在这个函数中执行一些异步的操作

</pre><textarea>
class AsyncApp extends Component {
  componentDidMount() {
    const { dispatch, selectedPost } = this.props
    dispatch(fetchPosts(selectedPost))
  }

// 上面代码是一个异步组件的例子。componentDidMount方法加载成功后dispatch方法送出了一个Action,向服务器要求数据fetchPosts(selectedSubreddit),这里的fetchPosts就是Action Creator
const fetchPosts = postTitle => (dispatch, getState) => {
  dispatch(requestPosts(postTitle));
  return fetch(`/some/API/${postTitle}.json`)
    .then(response => response.json())
    .then(json => dispatch(receivePosts(postTitle, json)));
  };
};

// 使用方法一
store.dispatch(fetchPosts('reactjs'));
// 使用方法二
store.dispatch(fetchPosts('reactjs')).then(() =>
  console.log(store.getState())
);

</textarea><pre>
fetchPosts是一个Action Creator(动作生成器),返回一个函数,这个函数执行后先发出一个Action(requestPosts(postTitle)),然后进行异步操作。拿到结果后,先将结果转成JSON格式,然后再发出一个Action(receivePosts(postTitle, json))

(1)fetchPosts返回了一个函数,而普通的Action Creator默认返回一个对象。
(2)返回的函数的参数是dispatch和getState这两个Redux方法,普通的Action Creator的参数是Action的内容。
(3)在返回的函数之中,先发出一个Action(requestPosts(postTitle)),表示操作开始。
(4)异步操作结束之后,再发出一个Action(receivePosts(postTitle, json)),表示操作结束。

这样的处理就解决了自动发送第二个Action的问题,但又带来了一个新的问题,Action是由store.dispatch方法发送的,而store.dispatch方法正常情况下参数只能是对象,不能是函数,这时就要使用中间件redux-thunk。

</textarea><textarea>
import { createStore, applyMiddleware } from 'redux';
import thunk from 'redux-thunk';
import reducer from './reducers';

const store = createStore(
  reducer,
  applyMiddleware(thunk)
);

</textarea><pre>
上面代码使用redux-thunk中间件,改造store.dispatch,使得后者可以接受函数作为参数。
因此异步操作的第一种解决方案就是写出一个返回函数的Action Creator,然后使用redux-thunk中间件改造store.dispatch。

</textarea><pre>
【 redux-promise中间件 】
既然Action Creator可以返回函数,当然也可以返回其他值。另一种异步操作的解决方案就是让Action Creator返回一个Promise对象,这就需要使用redux-promise中间件。

</textarea><textarea>
import { createStore, applyMiddleware } from 'redux';
import promiseMiddleware from 'redux-promise';
import reducer from './reducers';

const store = createStore(reducer, applyMiddleware(promiseMiddleware)); 

// 这个中间件使得store.dispatch方法可以接受Promise对象作为参数,这时Action Creator有两种写法。
// 写法一,返回值是一个Promise对象。
const fetchPosts = (dispatch, postTitle) => new Promise(function (resolve, reject) {
  dispatch(requestPosts(postTitle));
  return fetch(`/some/API/${postTitle}.json`)
    .then(response => {
      type: 'FETCH_POSTS',
      payload: response.json()
    });
});

// 写法二,Action对象的payload属性是一个Promise对象。这需要从redux-actions模块引入createAction方法,并且写法也要变成下面这样。
import { createAction } from 'redux-actions';

class AsyncApp extends Component {
  componentDidMount() {
    const { dispatch, selectedPost } = this.props
    // 发出同步 Action
    dispatch(requestPosts(selectedPost));
    // 发出异步 Action
    dispatch(createAction(
      'FETCH_POSTS', 
      fetch(`/some/API/${postTitle}.json`)
        .then(response => response.json())
    ));
  }

// 上面代码中,第二个dispatch方法发出的是异步Action,只有等到操作结束这个Action才会实际发出。createAction的第二个参数必须是一个Promise对象。

</textarea>redux-promise的源码<textarea>
export default function promiseMiddleware({ dispatch }) {
  return next => action => {
    if (!isFSA(action)) {
      return isPromise(action)
        ? action.then(dispatch)
        : next(action);
    }

    return isPromise(action.payload)
      ? action.payload.then(
          result => dispatch({ ...action, payload: result }),
          error => {
            dispatch({ ...action, payload: error, error: true });
            return Promise.reject(error);
          }
        )
      : next(action);
  };
}

</textarea><pre>
从上面代码可以看出,如果Action本身是一个Promise,它resolve以后的值应该是一个Action对象,会被dispatch方法送出(action.then(dispatch)),但reject以后不会有任何动作;如果Action对象的payload属性是一个Promise对象,那么无论resolve和reject,dispatch方法都会发出Action。

</textarea>
</div>

<div id="react_redux">
<h4>react-redux库</h4><pre>
React-Redux是Redux的官方React绑定专用的库,它能够使React组件从Redux store中读取数据,并且向store分发actions以更新数据
这个库是可以选用的,实际项目中应该权衡一下是直接使用Redux还是使用React-Redux。后者虽然提供了便利,但是需要掌握额外的API,并且要遵守它的组件拆分规范

安装
npm install --save redux react-redux

【 UI组件和容器组件 】
React-Redux将所有组件分成两大类：UI组件(presentational component)和容器组件(container component),UI组件负责UI的呈现,容器组件负责管理数据和逻辑

UI组件有以下几个特征
只负责UI的呈现,不带有任何业务逻辑
没有状态(即不使用this.state这个变量)
所有数据都由参数(this.props)提供
不使用任何Redux的API

下面就是一个UI组件的例子
const Title = value => < h1>{value}< /h1>;
因为不含有状态,UI组件又称为"纯组件",即它纯函数一样,纯粹由参数决定它的值。

容器组件
容器组件的特征恰恰相反
负责管理数据和业务逻辑,不负责UI的呈现
带有内部状态
使用Redux的API

如果一个组件既有UI又有业务逻辑,将它拆分成下面的结构：外面是一个容器组件,里面包了一个UI组件。前者负责与外部的通信,将数据传给后者,由后者渲染出视图。

React-Redux规定所有的UI组件都由用户提供,容器组件则是由React-Redux自动生成,即用户负责视觉层,状态管理则全部交给它

【 connect() 】
React-Redux提供connect方法把组件和store连接起,通过connect方法可以从Redux store中读取数据,以及当store更新后重新读取数据

定义业务逻辑需要给出下面两方面的信息
(1)输入逻辑：外部的数据(即state对象)如何转换为UI组件的参数
(2)输出逻辑：用户发出的动作如何变为Action对象,从UI组件传出去。

connect方法接受两个参数：mapStateToProps和mapDispatchToProps,它们定义了UI组件的业务逻辑,前者负责输入逻辑,即将state映射到UI组件的参数(props),后者负责输出逻辑,即将用户对UI组件的操作映射成Action。

1、mapStateToProp
将store state中的部分组件需要的数据注入组件的props,该函数的第一个参数常命名为state表示接收整个store state,返回对象的key对应组件props中的状态props,对象的值用来判断组件是否需要重新渲染
mapStateToProps会订阅Store,每当store state变化就自动调用执行,重新计算UI组件的参数即状态props,从而触发UI组件的重新渲染
mapStateToProp第二个参数可选,常命名为ownProps,代表容器组件的props对象,此时如果容器组件的参数发生变化也会引发UI组件重新渲染。
如果组件需要根据自身的props数据以从store中检索出数据时可以传入第二个参数ownProps,这个参数将包含所有传递给由connect生成的包装组件的props
connect方法可以省略mapStateToProps参数,此时UI组件就不会订阅Store,就是说Store的更新不会引起UI组件的更新

建议使用selector方法去封装抽取state树中的特定位置的值。Memoized selector方法也在提高应用性能上起到了关键作用

在一些高级场景中可能需要更多地对于渲染性能的控制,mapStateToProps也可以返回一个方法。在这种情况下返回的方法会做为一个特定组件实例的最终的mapStateToProps。这样一来就可以对每个实例进行memoization,但大部分应用根本不需要这样做

mapStateToProps方法应该足够快
一旦store改变了,所有被连接组件中的所有的mapStateToProps方法都会运行,因此mapStateToProps方法一定要足够快,这也意味着缓慢的mapStateToProps方法会成为应用的一个潜在瓶颈。
作为“重塑数据”想法的一部分,mapStateToProps方法经常需要以各种方式来转化数据(比如过滤数组,遍历IDs数组映射到对应的对象,或从Immutable.js对象中抽取纯js值)。这些转化的开销通常很高昂,不仅表现在运行转化操作的开销上,也表现在判断最终是否要更新组件上。如果的确需要考虑性能问题了,那么要确保这些转化只发生在所输入的值发生变化的时候。

mapStateToProps方法应该纯净且同步
正如Redux Reducer,一个mapStateToProps方法应该是100%纯净的并且是同步的。他应该仅接受state及ownProps作为参数,然后以props形式返回组件所需要的数据,不应该触发任何异步操作,如AJAX请求数据,方法也不能声明为async形式。

仅在需要时返回新的对象引用
React-Redux进行浅比较来检查mapStateToProps的结果是否改变了。返回一个新对象或数组引用十分容易操作,但会造成你的组件在数据没变的情况下也重新渲染。
很多常见的操作都会返回新对象或数组引用：
创建新的数组：使用someArray.map()或者someArray.filter()
合并数组：array.concat
截取数组：array.slice
复制值：Object.assgin
使用扩展运算符：{...oldState,...newData}
把这些操作放在memeoized selector functions中确保它们只在输入值变化后运行。这样也能够确保如果输入值没有改变,mapStateToProps仍然返回与之前的相同值,然后connect就能够跳过重渲染过程。

仅在数据改变时运行开销大的操作
转化数据经常开销很大(并且通常会创建一个新的对象引用)。为了使你的mapStateToProps方法足够快,你应该仅在相关数据改变时重新运行这些复杂的转化。
有下面几种形式来达到这样的目的：
一些转化可以在action创建函数或者reducer中运算,然后可以把转化过的数据储存在store中
转换也可以在组件的render()生命周期中完成
如果转化必须要在mapStateToProps方法中完成,那么建议使用memoized selector functions以确保转化仅发生在输入的数据变化时。

声明参数的数量影响行为
当仅有(state)时,每当根store state对象不同了,函数就会运行。
当有(state,ownProps)两个参数时,每当store state不同、或每当包装props变化时,函数都会运行。
这意味着不应该增加ownProps参数,除非实在是需要它,否则mapStateToProps函数会比它实际需要运行次数运行更多次。

2、mapDispatchToProps
将更新store state的方法注入组件的props,对应组件中的事件处理函数,即dispatch(action),action携带store中要更新的数据,返回对象的key对应组件props中的事件props,对象的值通常是一个调用后能分发action的函数。
作为第二个传入connect的参数,mapDispatchToProps可以实现向store中分发acions
定义了哪些用户的操作应该当作Action传给Store,可以是一个函数或对象
 
(1)如果是一个函数,一旦该组件被创建就会被调用。接收dispatch作为一个参数,并返回一个能够使用dispatch来分发actions的若干函数组成的对象
在React组件中分发Redux actions的过程都十分类似:定义action创建函数,把它包装在形如(…args) => dispatch(actionCreator(…args))的另一个函数,然后把那个包装函数作为props 传递给你的组件

(2)如果是一个action creators构成的对象,每一个action creator将会转化为一个prop function并会在调用时自动分发actions,建议使用这种形式。
如果传递了一个由action creators构成的对象,而不是函数,connect会在内部自动调用bindActionCreators
React-Redux自动为你做:dispatch => bindActionCreators(mapDispatchToProps, dispatch);
每个mapDispatchToProps对象的字段都被假设为一个action创建函数
组件不再接收dispatch作为一个prop,dispatch并没有注入到组件

将mapDispatchToProps定义为一个函数能更灵活地定义组件能够接收到的函数以及这些函数如何分发actions,对dispatch和ownProps(可选)都具有访问权限,可以借此机会编写连接组件的自定义函数。

dispatch是Redux store实例的一个方法,会通过store.dispatch来分发一个action,这也是唯一触发一个state变化的途径
使用React-Redux后组件就不再需要直接和store打交道了,connect会完成这件任务
React-Redux提供了两种可以分发actions的方式：
默认地,一个已连接组件可以接收props.dispatch然后自己分发actions,如果定义了mapDispatchToProps被连接组件就不再接收到dispatch了
connect能够接收一个mapDispatchToProps作为第二个参数,这将让你能够创建dispatch调用方法,然后把这些方法作为props传递给组件。
提供一个mapDispatchToProps参数能够让你指明你的组件所实际需要分发的那些actions,它允许提供action分发函数作为props,这样一来就不用再进行props.dispatch(() => increment())调用,可以直接props.increment()

这么做是出于下面几个原因：

1、更加声明式的
把分发逻辑封装到函数中使得整个实现更加声明式。分发一个action然后让Redux store处理数据流,表现出了如何实现这一行为而不仅仅是只关心它做了什么。
单击按钮后分发一个action也许是个不错的例子。把一个button直接连接从概念上来讲有点说不通,button也没有dispatch引用。
// button需要有意识地 "dispatch"
< button onClick={() => dispatch({ type: "SOMETHING" })} />
// button看起来不像在 "dispatch",
< button onClick={doSomething} />
一旦把所有的action creators使用函数封装起来之后,组件就不需要再dispatch了。因此如果定义了mapDispatchToProps被连接组件就不再接收到dispatch了。

2、把action分发逻辑向子(未连接)组件传递
此外现在也能够向下传递action分发函数给子组件(可能尚未连接),这样就能够使更多的组件分发actions,且它们对Redux也是无感知的。
// 把toggleTodo传递给子组件,让Todo能分发toggleTodo action
const TodoList = ({ todos, toggleTodo }) => < div>{todos.map(todo => (< Todo todo={todo} onClick={toggleTodo} />))}< /div>
这就是React-Redux的connect所做的工作——封装与Redux Store对话的逻辑,并且不再需要操心,也应该在代码实现中充分利用这一点。

</textarea>通常可以以下面这种方式调用connect方法<textarea>
import { connect } from "react-redux";
import { increment, decrement, reset } from "./actionCreators";

const TodoComponent = ...

// 从state中处理的一些数据,以及可选的ownProps
const mapStateToProps = (state, ownProps) => {
  return {
    a : 42,
    todos : state.todos,
    filter : state.visibilityFilter
  }
};

const getVisibleTodos = (todos, filter) => {
  switch (filter) {
    case 'SHOW_ALL': return todos
    case 'SHOW_COMPLETED': return todos.filter(t => t.completed)
    case 'SHOW_ACTIVE': return todos.filter(t => !t.completed)
    default: throw new Error('Unknown filter: ' + filter)
  }
}
const mapStateToProps = (state) => ({todos: getVisibleTodos(state.todos, state.visibilityFilter)})}

// 容器组件的代码
<FilterLink filter="SHOW_ALL">All</FilterLink>
const mapStateToProps = (state, ownProps) => {
  return {
    active: ownProps.filter === state.visibilityFilter
  }
}

// 不需要把ownProps中的值再添加入mapStateToProps返回的对象中,connect会自动的把这些不同源的prop合并为一个最终的prop集
function mapStateToProps(state, ownProps) {
  const { visibilityFilter } = state;
  const { id } = ownProps;
  const todo = getTodoById(state, id);
  return { todo, visibilityFilter };
};

// 通常是action creators构成的对象
const mapDispatchToProps = { increment, decrement, reset };

// 如果mapDispatchToProps是一个对象,它的每个键名也是对应UI组件的同名参数,键值应该是一个函数会被当作Actioncreator,返回Action会由Redux自动发出
const mapDispatchToProps = {
  onClick: (filter) => {type: 'SET_VISIBILITY_FILTER', filter: filter};
}

// 如果mapDispatchToProps是一个函数,会得到dispatch和ownProps(容器组件的props对象)两个参数。返回一个对象,该对象的每个键值对都是一个映射,定义了UI组件的参数怎样发出Action  
const mapDispatchToProps = dispatch => {
  return {
    // 分发纯action对象或action创建函数的返回值
    increment: () => dispatch({ type: "INCREMENT" }),
    decrement: () => dispatch({ type: "DECREMENT" }),
    reset: () => dispatch({ type: "RESET" })
  };
};

// 也可能需要把一些参数转发给你的action创建函数
const mapDispatchToProps = dispatch => {
  return {
    onClick: event => dispatch(trackClick(event)),  // 直接转发参数
    onReceiveImpressions: (...impressions) => dispatch(trackImpressions(impressions)) // 间接转发参数
  };
};

// 如果在dispatch()中使用了action创建函数(区别于纯对象形式的action),通常约定字段名与action创建函数的名称相同
const increment = () => ({ type: "INCREMENT" });
const decrement = () => ({ type: "DECREMENT" });
const reset = () => ({ type: "RESET" });
const mapDispatchToProps = dispatch => {
  return {
    // 分发由action creators创建的actions
    increment: () => dispatch(increment()),
    decrement: () => dispatch(decrement()),
    reset: () => dispatch(reset())
  };
};
// mapDispatchToProps的函数返回值会合并到组件props中去,能够直接调用它们来分发action。
function Counter({ count, increment, decrement, reset }) {
  return (
    <div>
      <button onClick={decrement}>-</button>
      <span>{count}</span>
      <button onClick={increment}>+</button>
      <button onClick={reset}>reset</button>
    </div>
  );
}

const mapDispatchToProps = ( dispatch, ownProps ) => {
  return {
    onClick: () => {
      dispatch({
        type: 'SET_VISIBILITY_FILTER',
        filter: ownProps.filter
      });
    }
  };
}

// mapDispatchToProps函数是可以接收两个参数的,第一个是dispatch,传递给连接组件的props即为mapDispatchToProps的第二个参数,然后在组件接收到新的props后会重新调用。这意味着应该在组件props改变阶段重新把新的props绑定到action分发函数中去,而不是在组件重新渲染阶段进行。

// 在组件re-rendering阶段绑定
<button onClick={() => this.props.toggleTodo(this.props.todoId)} />;

// 在props改变阶段绑定
const mapDispatchToProps = (dispatch, ownProps) => {
  toggleTodo: () => dispatch(toggleTodo(ownProps.todoId));
};

const connectToStore = connect(
  mapStateToProps,
  mapDispatchToProps
);
const ConnectedComponent = connectToStore(Component);

// connect返回一个新的函数,可以接收一个待包装的组件,返回一个已经包装、连接过store的组件
export default connect(
  mapStateToProps,
  mapDispatchToProps
)(Counter);

const VisibleTodoList = connect()(TodoList);

// TodoList组件负责渲染todos列表,因此他需要从store中读取数据,通过调用connect方法,并向其中传入mapStateToProps参数从而提供给组件所需要的部分来自store数据
export default connect(mapStateToProps)(TodoList);

// AddTod组件要能够触发store的变化增加新的todos,因此他要能够向store dispatch actions,连接store后AddTodo的事件处理函数中就可执行this.props.addTodo(this.state.input),即能够分发action从而改变store
export default connect(
  null,
  { addTodo_actionCreator }
)(AddTodo);

</textarea><pre>
常见的调用connect的方式
1、不订阅store并且不注入action创建函数
如果调用connect方法不传入任何参数,那么组件将会：
在store改变时不能够重新渲染
接收一个props.dispatch方法以便手动分发actions
export default connect()(MyComponent);
export default connect(null, null)(MyComponent);

一旦以这种方式连接了组件,组件就会接收props.dispatch,可以用它来向store中分发actions。

</pre><textarea>
function Counter({ count, dispatch }) {
  return (
    <div>
      <button onClick={() => dispatch({ type: "DECREMENT" })}>-</button>
      <span>{count}</span>
      <button onClick={() => dispatch({ type: "INCREMENT" })}>+</button>
      <button onClick={() => dispatch({ type: "RESET" })}>reset</button>
    </div>
  );
}

</textarea><pre>
2、订阅store但不注入action创建函数
如果调用connect方法并且只传入了mapStateToProps方法,组件将会：
订阅mapStateToProps从store中提取的部分值,当这些值改变时会重新渲染
接收一个props.dispatch以便手动分发actions
const mapStateToProps = state => state.partOfState;
export default connect(mapStateToProps)(MyComponent);

3、不订阅store但注入action创建函数
如果调用connect方法并只传入mapDispatchToProps参数,组件将会：
store改变时不重新渲染
以props形式接收每个通过mapDispatchToProps注入的action创建函数,能够在调用后自动分发actions
import { addTodo } from "./actionCreators";
export default connect(
  null,
  { addTodo }
)(MyComponent);

4、订阅store并且注入action创建函数
如果在connect方法中传入了mapStateToProps和mapDispatchToProps,组件将会：
订阅mapStateToProps从store中提取的部分值,当这些值改变时会重新渲染
以props形式接收每个你通过mapDispatchToProps注入的action创建函数,能够在调用后自动分发actions
import * as actionCreators from "./actionCreators";
const mapStateToProps = state => state.partOfState;
export default connect(
  mapStateToProps,
  actionCreators
)(MyComponent);

【 使用bindActionCreators定义mapDispatchToProps函数 】
手动封装mapDispatchToProps函数实在是繁琐,所以Redux提供了一个函数简化这个操作。
bindActionCreators将值为action creators的对象转化为同键名的新对象,但将每个action creators封装到一个dispatch调用中,以便可以直接调用它们
由bindActionCreators生成的包装函数会自动转发它们所有的参数,所以不需要在手动操作了

bindActionCreators接收两个参数：
一个函数(action creator)或一个对象(每个属性为一个action creator)
dispatch

</pre><textarea>
import { bindActionCreators } from "redux";
const increment = () => ({ type: "INCREMENT" });
const decrement = () => ({ type: "DECREMENT" });
const reset = () => ({ type: "RESET" });
// 绑定一个action creator,返回 (...args) => dispatch(increment(...args))
const boundIncrement = bindActionCreators(increment, dispatch);

// 绑定一个action creators构成的object
const boundActionCreators = bindActionCreators({ increment, decrement, reset }, dispatch);
// 返回值：
// {
//   increment: (...args) => dispatch(increment(...args)),
//   decrement: (...args) => dispatch(decrement(...args)),
//   reset: (...args) => dispatch(reset(...args)),
// }

</textarea>在mapDispatchToProps中使用bindActionCreators函数<textarea>
import { bindActionCreators } from "redux";
function mapDispatchToProps(dispatch) {
  return bindActionCreators({ increment, decrement, reset }, dispatch);
}

// 组件能接收到props.increment, props.decrement, props.reset
connect(
  null,
  mapDispatchToProps
)(Counter);

</textarea><pre>
手动注入dispatch
如果提供了mapDispatchToProps,组件将不再接收到默认的dispatch。但你可以通过在mapDispatchToProps的return中添加dispatch把它重新注入你的组件。多数情况下,你不需要这么做。

</pre><textarea>
import { bindActionCreators } from "redux";
function mapDispatchToProps(dispatch) {
  return {
    dispatch,
    ...bindActionCreators({ increment, decrement, reset }, dispatch)
  };
}

</textarea><pre>
【 Provider组件 】
connect方法生成容器组件以后,需要让容器组件拿到state对象才能生成UI组件的参数。
一种解决方法是将state对象作为参数传入容器组件,但这样做比较麻烦,尤其是容器组件可能在很深的层级,一级级将state传下去就很麻烦。
React-Redux提供Provider组件能够使整个app访问到Redux store中的数据,Provider在根组件外面包了一层,这样一来App的所有子组件就默认都可以拿到state了

</pre><textarea>
import { Provider } from 'react-redux'
import { createStore } from 'redux'
import todoReducer from './reducers'
import App from './components/App'

let store = createStore(todoReducer);

render(
  <Provider store={store}>
    <App />
  <Provider>,
  document.getElementById('root')
)

</textarea>源码: Provider的原理是React组件的context属性<textarea>
class Provider extends Component {
  getChildContext() {
    return {
      store: this.props.store
    };
  }
  render() {
    return this.props.children;
  }
}

Provider.childContextTypes = {
  store: React.PropTypes.object
}

// 上面代码中store放在了上下文对象context上面,然后子组件就可以从context拿到store,代码大致如下,React-Redux自动生成的容器组件的代码,就类似下面这样,从而拿到store
class VisibleTodoList extends Component {
  componentDidMount() {
    const { store } = this.context;
    this.unsubscribe = store.subscribe(() =>
      this.forceUpdate()
    );
  }

  render() {
    const props = this.props;
    const { store } = this.context;
    const state = store.getState();
    // ...
  }
}

VisibleTodoList.contextTypes = {
  store: React.PropTypes.object
}

</textarea>【 实例：计数器 】<textarea>
// 这个纯UI组件的计数器组件有两个参数：value和onIncreaseClick,前者需要从state计算得到,后者需要向外发出Action
class Counter extends Component {
  render() {
    const { value, onIncreaseClick } = this.props
    return (
      <div>
        <span>{value}</span>
        <button onClick={onIncreaseClick}>Increase</button>
      </div>
    )
  }
}

// 接着定义value到state的映射,以及onIncreaseClick到dispatch的映射。
function mapStateToProps(state) {
  return {
    value: state.count
  }
}

function mapDispatchToProps(dispatch) {
  return {
    onIncreaseClick: () => dispatch(increaseAction)
  }
}

// Action Creator
const increaseAction = { type: 'increase' }

// 使用connect方法生成容器组件
const App = connect(
  mapStateToProps,
  mapDispatchToProps
)(Counter)

// 定义这个组件的Reducer
function counterReducer(state = { count: 0 }, action) {
  const count = state.count
  switch (action.type) {
    case 'increase': return { count: count + 1 }
    default: return state
  }
}

// 生成store对象,并使用Provider在根组件外面包一层。
import { loadState, saveState } from './localStorage';

const persistedState = loadState();
const store = createStore(counterReducer, persistedState);

store.subscribe(throttle(() => {
  saveState({
    todos: store.getState().todos,
  })
}, 1000))

ReactDOM.render(
  <Provider store={store}>
    <App />
  </Provider>,
  document.getElementById('root')
);

</textarea><pre>
【 React-Router路由库 】
使用React-Router的项目与其他项目没有不同之处,也是使用Provider在Router外面包一层,毕竟Provider的唯一功能就是传入store对象。

</pre><textarea>
const Root = ({ store }) => (
  <Provider store={store}>
    <Router>
      <Route path="/" component={App} />
    </Router>
  </Provider>
);

</textarea><pre>
【 todoList实例 】
用到的React UI组件如下：
TodoApp：我们应用的入口组件,它render出AddTodo,TodoList和VisibilityFilters组件
AddTodo：允许用户在点击Add Todo按钮后,向todo list中加入一个新的待办项：
 - 使用一个受控input监听onChange事件以设置state
 - 当用户单击Add Todo按钮后,该组件dispatch一个action,向store中添加一个新的待办项。(这个action是我们由React-Redux提供的)
TodoList：渲染出待办项列表的组件：
 - 当一个VisibilityFilter被选择后,能够渲染出所匹配的待办项列表
Todo：仅负责渲染单个todo待办项：
 - 渲染出待办项的内容,通过横贯线表示该项已被完成
 - 触发onClick事件后,dispatch一个能切换完成状态的action
VisibilityFilters：渲染一个filters集合：_all_,_complete_ 以及 _incomplete_。单击每一项能够筛选匹配的todos:
 - 从父组件接收一个activeFilter属性以表示当前用户选择的过滤条件。选中的filter会显示出下划线。
 - 能够dispatch名为setFilter的action以更新已选过滤条件
constants：保存app所有需要的常量数据
最后,index将app渲染到DOM中

应用的Redux部分遵循Redux官方文档建议模式进行搭建：
Store：
 - todos：标准化的todos的reducer。包含了byIds的待办项map对象结构,和一个包含了所有待办项id的allIds数组
 - visibilityFilters：简单的字符串all, completed, or incomplete.
Action Creators：
 - addTodo：创建增添待办项的action。接收一个string变量content,返回ADD_TODO类型的action,及一个payload对象(包含了自增的id和content属性)
 - toggleTodo：创建一个切换待办项的action。只接收一个number类型的变量id,返回TOGGLE_TODO类型action以及仅含id属性的payload对象。
 - setFilter：创建设置app当前过滤条件的action。接收一个string类型变量filter返回一个SET_FILTER类型action即包含filter自身的payload对象。
Reducers
 - todos reducer：
 - - 在接收到`ADD_TODO` action时,将`id`追加到`allIds`数组,并且更新`byIds`
 - - 在接收到`TOGGLE_TODO` action时,切换`completed`状态
 - VisibilityFilters reducer：在接收到SET_FILTERaction 时负责更新VISIBILITY_FILTERS状态
Action Types
 - 使用一个actionTypes.js文件来保存所有的action types常量,以便复用
Selectores
 - getTodoList：从todos store中返回allIds列表
 - getTodoById：通过id查询store中的todo项
 - getTodos：接收allIds数组中的所有id,找到每一个对应的byIds中的todo,返回最终的todos数组
 - getTodosByVisibilityFilter：根据筛选条件过滤todos

</pre>
</ div>

<div id="react-router">
<h3>React Router</h3><pre>
React Router是完整的React路由解决方案,React Router保持UI与URL同步,拥有简单的API与强大的功能例如代码缓冲加载、动态路由匹配及建立正确的位置过渡处理

React项目的可用的路由库是React-Router,它也分为：
react-router 核心组件
react-router-dom 应用于浏览器端的路由库(单独使用包含了react-router的核心部分),DOM bindings for React Router
react-router-native 应用于native端的路由

npm install --save react-router-dom
https://unpkg.com/react-router/umd/react-router.min.js 在unpkg上构建UMD格式

</textarea><textarea>
import React from "react";
import { BrowserRouter as Router, Switch, Route, Link } from "react-router-dom";

const Home = () => (<div><h2>Home</h2></div>)
const About = () => (<div><h2>About</h2></div>)
const Dashboard = () => (<div><h2>Dashboard</h2></div>)

//  A <Switch> looks through all its children <Route> elements and renders the first one whose path matches the current URL. Use a <Switch> any time you have multiple routes, but you want only one of them to render at a time

export default function BasicExample() {
  return (
    <Router>
      <div>
        <ul>
          <li><Link to="/">Home</Link></li>
          <li><Link to="/about">About</Link></li>
          <li><Link to="/dashboard">Dashboard</Link></li>
        </ul>
        <hr />
        <Switch>
          <Route exact path="/"><Home /></Route>
          <Route path="/about"><About /></Route>
          <Route path="/dashboard"><Dashboard /></Route>
        </Switch>
      </div>
    </Router>
  );
}

</textarea><textarea>
import React, { Component } from 'react';
import { HashRouter as Router, Link, Route } from 'react-router-dom';

const Home = () => (<div><h2>Home</h2></div>)
const About = () => (<div><h2>About</h2></div>)
const Dashboard = () => (<div><h2>Dashboard</h2></div>)

class App extends Component {
  render() {
    return (
      <Router>
        <div className="App">
          <Link to="/">Home</Link>
          <Link to="/About">About</Link>
          <Link to="/dashboard">dashboard</Link>
          <hr/>
          <Route path="/" exact component={Home}></Route>
          <Route path="/about" component={About}></Route>
          <Route path="/Dashboard" component={Dashboard}></Route>
        </div>
      </Router>
    )
  }
}
export default App;

</textarea>URL Parameters - useParams<textarea>
// Params are placeholders in the URL that begin with a colon, like the `:id` param defined in the route in this example. A similar convention is used for matching dynamic segments in other popular web frameworks like Rails and Express.

import React from "react";
import {BrowserRouter as Router,Switch,Route,Link,useParams} from "react-router-dom";

export default function ParamsExample() {
  return (
    <Router>
      <div>
        <h2>Accounts</h2>
        <ul>
          <li><Link to="/netflix">Netflix</Link></li>
          <li><Link to="/zillow-group">Zillow Group</Link></li>
          <li><Link to="/yahoo">Yahoo</Link></li>
          <li><Link to="/modus-create">Modus Create</Link></li>
        </ul>

        <Switch>
          <Route path="/:id" children={<Child />} />
        </Switch>
      </div>
    </Router>
  );
}

function Child() {
  let { id } = useParams();  // use the `useParams` hook here to access the dynamic pieces of the URL
  return (<div><h3>ID: {id}</h3></div>);
}

</textarea>Nesting嵌套 - useRouteMatch<textarea>
// Since routes are regular React components, they may be rendered anywhere in the app, including in child elements.
// This helps when it's time to code-split your app into multiple bundles because code-splitting a React Router app is the same as code-splitting any other React app.

import React from "react";
import {BrowserRouter as Router,Switch,Route,Link,useParams,useRouteMatch} from "react-router-dom";

export default function NestingExample() {
  return (
    <Router>
      <div>
        <ul>
          <li><Link to="/">Home</Link></li>
          <li><Link to="/topics">Topics</Link></li>
        </ul>
        <hr />
        <Switch>
          <Route exact path="/"><Home /></Route>
          <Route path="/topics"><Topics /></Route>
        </Switch>
      </div>
    </Router>
  );
}

function Home() {
  return (<div><h2>Home</h2></div>);
}

function Topics() {
  // The `path` lets us build <Route> paths that are relative to the parent route, while the `url` lets us build relative links.
  console.log(useRouteMatch())  // {path: "/topics", url: "/topics", isExact: false, params: {}}
  let { path, url } = useRouteMatch();

  return (
    <div>
      <h2>Topics</h2>
      <ul>
        <li><Link to={`${url}/rendering`}>Rendering with React</Link></li>
        <li><Link to={`${url}/components`}>Components</Link></li>
        <li><Link to={`${url}/props-v-state`}>Props v. State</Link></li>
      </ul>

      <Switch>
        <Route exact path={path}><h3>Please select a topic.</h3></Route>
        <Route path={`${path}/:topicId`}><Topic /></Route>
      </Switch>
    </div>
  );
}

function Topic() {
  // The <Route> that rendered this component has a path of `/topics/:topicId`. The `:topicId` portion of the URL indicates a placeholder that we can get from `useParams()`.
  let { topicId } = useParams();

  return (<div><h3>{topicId}</h3></div>);
}

</textarea>Redirects (Auth) - location.state<textarea>
// This example has 3 pages: a public page, a protected page, and a login screen. In order to see the protected page, you must first login. Pretty standard stuff.
// First, visit the public page. Then, visit the protected page. You're not yet logged in, so you are redirected to the login page. After you login, you are redirected back to the protected page.
// Notice the URL change each time. If you click the back button at this point, would you expect to go back to the login page? No! You're already logged in. Try it out, and you'll see you go back to the page you visited just *before* logging in, the public page.

import React from "react";
import {BrowserRouter as Router,Switch,Route,Link,Redirect,useHistory,useLocation} from "react-router-dom";

const fakeAuth = {
  isAuthenticated: false,
  authenticate(cb) {
    fakeAuth.isAuthenticated = true;
    setTimeout(cb, 100); // fake async
  },
  signout(cb) {
    fakeAuth.isAuthenticated = false;
    setTimeout(cb, 100);
  }
};

export default function AuthExample() {
  return (
    <Router>
      <div>
        <AuthButton />
        <ul>
          <li><Link to="/public">Public Page</Link></li>
          <li><Link to="/protected">Protected Page</Link></li>
        </ul>

        <Switch>
          <Route path="/public"><PublicPage /></Route>
          <Route path="/login"><LoginPage /></Route>
          <PrivateRoute path="/protected"><ProtectedPage /></PrivateRoute>
        </Switch>
      </div>
    </Router>
  );
}

// A wrapper for <Route> that redirects to the login screen if you're not yet authenticated.
function PrivateRoute({ children, ...rest }) {
  return (
    <Route {...rest} render={
      ({location }) => fakeAuth.isAuthenticated ? children : <Redirect to={{ pathname: "/login", state: { from: location } }} />
    />
  );
}

const PublicPage = () => <h3>Public</h3>
const ProtectedPage = () => <h3>Protected</h3>

function LoginPage() {
  let history = useHistory();
  let location = useLocation();

  let { from } = location.state || { from: { pathname: "/" } };
  let login = () => { fakeAuth.authenticate(() => { history.replace(from) })};

  return (
    <div>
      <p>You must log in to view the page at {from.pathname}</p>
      <button onClick={login}>Log in</button>
    </div>
  );
}

function AuthButton() {
  let history = useHistory();
  return fakeAuth.isAuthenticated ? (
    <p>
      Welcome!{" "}
      <button onClick={() => { fakeAuth.signout(() => history.push("/")) }} > Sign out </button>
    </p>
  ) : (
    <p>You are not logged in.</p>
  );
}

</textarea>Custom Link - match<textarea>
// create a custom Link that renders something special when the URL is the same as the one the Link points to

import React from "react";
import {BrowserRouter as Router,Switch,Route,Link,useRouteMatch} from "react-router-dom";

export default function CustomLinkExample() {
  return (
    <Router>
      <div>
        <OldSchoolMenuLink activeOnlyWhenExact={true} to="/" label="Home" />
        <OldSchoolMenuLink to="/about" label="About" />
        <hr />
        <Switch>
          <Route exact path="/"><Home /></Route>
          <Route path="/about"><About /></Route>
        </Switch>
      </div>
    </Router>
  );
}

function OldSchoolMenuLink({ label, to, activeOnlyWhenExact }) {
  let match = useRouteMatch({ path: to, exact: activeOnlyWhenExact });

  return (
    <div className={match ? "active" : ""}>
      {match && "> "}
      <Link to={to}>{label}</Link>
    </div>
  );
}

const Home = () => (<div><h2>Home</h2></div>)}
const About = () => (<div><h2>About</h2></div>)}

</textarea>Preventing Transitions - Prompt<textarea>
import React, { useState } from "react";
import {BrowserRouter as Router,Switch,Route,Link,Prompt} from "react-router-dom";

// Sometimes you want to prevent the user from navigating away from a page. The most common use case is when they have entered some data into a form but haven't submitted it yet, and you don't want them to lose it.

export default function PreventingTransitionsExample() {
  return (
    <Router>
      <ul>
        <li><Link to="/">Form</Link></li>
        <li><Link to="/one">One</Link></li>
        <li><Link to="/two">Two</Link></li>
      </ul>

      <Switch>
        <Route path="/" exact children={<BlockingForm />} />
        <Route path="/one" children={<h3>One</h3>} />
        <Route path="/two" children={<h3>Two</h3>} />
      </Switch>
    </Router>
  );
}

function BlockingForm() {
  let [isBlocking, setIsBlocking] = useState(false);

  return (
    <form
      onSubmit={event => {
        event.preventDefault();
        event.target.reset();
        setIsBlocking(false);
      }}
    > 
      {/*表单开始输入但没有提交时点击其他链接会弹窗提示是否跳转*/}
      <Prompt when={isBlocking} message={location => `Are you sure you want to go to ${location.pathname}` } />
      <p>
        Blocking?{" "}
        {isBlocking ? "Yes, click a link or the back button" : "Nope"}
      </p>
      <p>
        <input size="50" placeholder="type something to block transitions" onChange={event => { setIsBlocking(event.target.value.length > 0) }} />
      </p>
      <p>
        <button>Submit to stop blocking</button>
      </p>
    </form>
  );
}

</textarea>No Match (404) - Route path="*"<textarea>
import React from "react";
import {BrowserRouter as Router,Route,Link,Switch,Redirect,useLocation} from "react-router-dom";

// use the last Route in a Switch as a kind of "fallback" route, to catch 404 errors.
// There are a few useful things to note about this example:
// - A Switch renders the first child Route that matches
// - A Redirect may be used to redirect old URLs to new ones
// - A <Route path="*"> always matches

export default function NoMatchExample() {
  return (
    <Router>
      <div>
        <ul>
          <li><Link to="/">Home</Link></li>
          <li><Link to="/old-match">Old Match, to be redirected</Link></li>
          <li><Link to="/will-match">Will Match</Link></li>
          <li><Link to="/will-not-match">Will Not Match</Link></li>
          <li><Link to="/also/will/not/match">Also Will Not Match</Link></li>
        </ul>
        <Switch>
          <Route exact path="/"><Home /></Route>
          <Route path="/old-match"><Redirect to="/will-match" /></Route>
          <Route path="/will-match"><WillMatch /></Route>
          <Route path="*"><NoMatch /></Route>
        </Switch>
      </div>
    </Router>
  );
}

const Home = () => <h3>Home</h3>
const WillMatch = () => <h3>Matched!</h3>

function NoMatch() {
  let location = useLocation();
  return (<div><h3>No match for <code>{location.pathname}</code></h3></div>);
}

</textarea>Recursive Paths<textarea>
import React from "react";
import {BrowserRouter as Router,Switch,Route,Link,Redirect,useParams,useRouteMatch} from "react-router-dom";

// Sometimes you don't know all the possible routes for your application up front; for example, when building a file-system browsing UI or determining URLs dynamically based on data. In these situations, it helps to have a dynamic router that is able to generate routes as needed at runtime.
// This example lets you drill down into a friends list recursively, viewing each user's friend list
// along the way. As you drill down, notice each segment being added to the URL. You can copy/paste this link to someone else and they will see the same UI. Then click the back button and watch the last segment of the URL disappear along with the last friend list.

export default function RecursiveExample() {
  return (
    <Router>
      <Switch>
        <Route path="/:id"><Person /></Route>
        <Route path="/"><Redirect to="/0" /></Route>
      </Switch>
    </Router>
  );
}

function Person() {
  let { url } = useRouteMatch();
  let { id } = useParams();
  let person = find(parseInt(id));

  return (
    <div>
      <h3>{person.name}’s Friends</h3>
      <ul>
        {person.friends.map(id => (
          <li key={id}><Link to={`${url}/${id}`}>{find(id).name}</Link></li>
        ))}
      </ul>

      <Switch>
        <Route path={`${url}/:id`}>
          <Person />
        </Route>
      </Switch>
    </div>
  );
}

const PEEPS = [
  { id: 0, name: "Michelle", friends: [1, 2, 3] },
  { id: 1, name: "Sean", friends: [0, 3] },
  { id: 2, name: "Kim", friends: [0, 1, 3] },
  { id: 3, name: "David", friends: [1, 2] }
];

const find = (id) => PEEPS.find(p => p.id === id)

</textarea>Sidebar - routes array<textarea>
import React from "react";
import {BrowserRouter as Router,Switch,Route,Link} from "react-router-dom";

// Each logical "route" has two components, one for the sidebar and one for the main area. We want to
// render both of them in different places when the path matches the current URL.

// We are going to use this route config in 2 spots: once for the sidebar and once in the main
// content section. All routes are in the same order they would appear in a <Switch>.
const routes = [
  {
    path: "/",
    exact: true,
    sidebar: () => <div>home!</div>,
    main: () => <h2>Home</h2>
  },{
    path: "/bubblegum",
    sidebar: () => <div>bubblegum!</div>,
    main: () => <h2>Bubblegum</h2>
  },{
    path: "/shoelaces",
    sidebar: () => <div>shoelaces!</div>,
    main: () => <h2>Shoelaces</h2>
  }
];

export default function SidebarExample() {
  return (
    <Router>
      <div style={{ display: "flex" }}>
        <div style={{ padding: "10px", width: "40%", background: "#f0f0f0" }}>
          <ul style={{ listStyleType: "none", padding: 0 }}>
            <li><Link to="/">Home</Link></li>
            <li><Link to="/bubblegum">Bubblegum</Link></li>
            <li><Link to="/shoelaces">Shoelaces</Link></li>
          </ul>
          {/* You can render a <Route> in as many places as you want in your app. It will render along with any other <Route>s that also match the URL. So, a sidebar or breadcrumbs or anything else that requires you to render multiple things in multiple places at the same URL is nothing more than multiple <Route>s.*/}
          <Switch>
            {routes.map((route, index) => <Route key={index} path={route.path} exact={route.exact} children={<route.sidebar />} />)}
          </Switch>
        </div>
        
        {/* Render more <Route>s with the same paths as above, but different components this time.*/}
        <div style={{ flex: 1, padding: "10px" }}>
          <Switch>
            {routes.map((route, index) => <Route key={index} path={route.path} exact={route.exact} children={<route.main />} />)}
          </Switch>
        </div>
      </div>
    </Router>
  );
}

</textarea>Animated Transitions<textarea>
import "./packages/react-router-dom/examples/Animation/styles.css";
import React from "react";
import { TransitionGroup, CSSTransition } from "react-transition-group";
import {BrowserRouter as Router,Switch,Route,Link,Redirect,useLocation,useParams} from "react-router-dom";

export default function AnimationExample() {
  return (
    <Router>
      <Switch>
        <Route exact path="/"><Redirect to="/hsl/10/90/50" /></Route>
        <Route path="*"><AnimationApp /></Route>
      </Switch>
    </Router>
  );
}

function AnimationApp() {
  let location = useLocation();

  return (
    <div style={styles.fill}>
      <ul style={styles.nav}>
        <NavLink to="/hsl/10/90/50">Red</NavLink>
        <NavLink to="/hsl/120/100/40">Green</NavLink>
        <NavLink to="/rgb/33/150/243">Blue</NavLink>
        <NavLink to="/rgb/240/98/146">Pink</NavLink>
      </ul>

      <div style={styles.content}>
        <TransitionGroup>
          {/* This is no different than other usage of <CSSTransition>, just make sure to pass `location` to `Switch` so it can match the old location as it animates out. */}
          <CSSTransition key={location.key} classNames="fade" timeout={300} >
            <Switch location={location}>
              <Route path="/hsl/:h/:s/:l" children={<HSL />} />
              <Route path="/rgb/:r/:g/:b" children={<RGB />} />
            </Switch>
          </CSSTransition>
        </TransitionGroup>
      </div>
    </div>
  );
}

function NavLink(props) {
  return (
    <li style={styles.navItem}>
      <Link {...props} style={{ color: "inherit" }} />
    </li>
  );
}

function HSL() {
  let { h, s, l } = useParams();

  return (
    <div style={{ ...styles.fill, ...styles.hsl, background: `hsl(${h}, ${s}%, ${l}%)` }} >
      hsl({h}, {s}%, {l}%)
    </div>
  );
}

function RGB() {
  let { r, g, b } = useParams();

  return (
    <div style={{ ...styles.fill, ...styles.rgb, background: `rgb(${r}, ${g}, ${b})` }}>
      rgb({r}, {g}, {b})
    </div>
  );
}

const styles = {};

styles.fill = {
  position: "absolute",
  left: 0,
  right: 0,
  top: 0,
  bottom: 0
};

styles.content = {
  ...styles.fill,
  top: "40px",
  textAlign: "center"
};

styles.nav = {
  padding: 0,
  margin: 0,
  position: "absolute",
  top: 0,
  height: "40px",
  width: "100%",
  display: "flex"
};

styles.navItem = {
  textAlign: "center",
  flex: 1,
  listStyleType: "none",
  padding: "10px"
};

styles.hsl = {
  ...styles.fill,
  color: "white",
  paddingTop: "20px",
  fontSize: "30px"
};

styles.rgb = {
  ...styles.fill,
  color: "white",
  paddingTop: "20px",
  fontSize: "30px"
};

</textarea>Route Config - RouteWithSubRoutes<textarea>
// Some folks find value in a centralized route config.
// A route config is just data. React is great at mapping data into components, and <Route> is a component.
// Our route config is just an array of logical "routes" with `path` and `component` props, ordered the same way you'd do inside a `<Switch>`.

import React from "react";
import {BrowserRouter as Router,Switch,Route,Link} from "react-router-dom";

const routes = [
  {
    path: "/sandwiches",
    component: Sandwiches
  },
  {
    path: "/tacos",
    component: Tacos,
    routes: [
      {
        path: "/tacos/bus",
        component: Bus
      },{
        path: "/tacos/cart",
        component: Cart
      }
    ]
  }
];

export default function RouteConfigExample() {
  return (
    <Router>
      <div>
        <ul>
          <li><Link to="/tacos">Tacos</Link></li>
          <li><Link to="/sandwiches">Sandwiches</Link></li>
        </ul>

        <Switch>
          {routes.map((route, i) => <RouteWithSubRoutes key={i} {...route} />)}
        </Switch>
      </div>
    </Router>
  );
}

// A special wrapper for <Route> that knows how to handle "sub"-routes by passing them in a `routes` prop to the component it renders.
function RouteWithSubRoutes(route) {
  return (
    <Route
      path={route.path}
      render={props => <route.component {...props} routes={route.routes} />} // pass the sub-routes down to keep nesting
    />
  );
}

const Sandwiches = () => <h2>Sandwiches</h2>
const Bus = () => <h3>Bus</h3>
const Cart = () => <h3>Cart</h3>

function Tacos({ routes }) {
  return (
    <div>
      <h2>Tacos</h2>
      <ul>
        <li><Link to="/tacos/bus">Bus</Link></li>
        <li><Link to="/tacos/cart">Cart</Link></li>
      </ul>

      <Switch>
        {routes.map((route, i) => (
          <RouteWithSubRoutes key={i} {...route} />
        ))}
      </Switch>
    </div>
  );
}

</textarea>Modal Gallery<textarea>
// This example shows how to render two different screens (or the same screen in a different context) at the same URL, depending on how you got there.
// Click the "featured images" and see them full screen. Then "visit the gallery" and click on the colors. Note the URL and the component are the same as before but now we see them inside a modal on top of the gallery screen.

import React from "react";
import {BrowserRouter as Router,Switch,Route,Link,useHistory,useLocation,useParams} from "react-router-dom";

export default function ModalGalleryExample() {
  return (
    <Router>
      <ModalSwitch />
    </Router>
  );
}

// This piece of state is set when one of the gallery links is clicked. The `background` state is the location that we were at when one of the gallery links was clicked. If it's there,
// use it as the location for the <Switch> so we show the gallery in the background, behind the modal.

function ModalSwitch() {
  let location = useLocation();
  let background = location.state && location.state.background;

  return (
    <div>
      <Switch location={background || location}>
        <Route exact path="/" children={<Home />} />
        <Route path="/gallery" children={<Gallery />} />
        <Route path="/img/:id" children={<ImageView />} />
      </Switch>

      {/* Show the modal when a background page is set */}
      {background && <Route path="/img/:id" children={<Modal />} />}
    </div>
  );
}

const IMAGES = [
  { id: 0, title: "Dark Orchid", color: "DarkOrchid" },
  { id: 1, title: "Lime Green", color: "LimeGreen" },
  { id: 2, title: "Tomato", color: "Tomato" },
  { id: 3, title: "Seven Ate Nine", color: "#789" },
  { id: 4, title: "Crimson", color: "Crimson" }
];

const Thumbnail = ({ color }) => <div style={{ width: 50, height: 50, background: color }} />
const Image = ({ color }) => <div style={{width: "100%",height: 400,background: color}}/>

function Home() {
  return (
    <div>
      <Link to="/gallery">Visit the Gallery</Link>
      <h2>Featured Images</h2>
      <ul>
        <li><Link to="/img/2">Tomato</Link></li>
        <li><Link to="/img/4">Crimson</Link></li>
      </ul>
    </div>
  );
}

function Gallery() {
  let location = useLocation();

  return (
    <div>
      {IMAGES.map(i => (
        <Link
          key={i.id}
          to={{
            pathname: `/img/${i.id}`,
            state: { background: location }  // This is the trick! This link sets the `background` in location state.
          }}
        >
          <Thumbnail color={i.color} />
          <p>{i.title}</p>
        </Link>
      ))}
    </div>
  );
}

function ImageView() {
  let { id } = useParams();
  let image = IMAGES[parseInt(id, 10)];
  if (!image) return <div>Image not found</div>;

  return (
    <div>
      <h1>{image.title}</h1>
      <Image color={image.color} />
    </div>
  );
}

function Modal() {
  let history = useHistory();
  let { id } = useParams();
  let image = IMAGES[parseInt(id, 10)];
  if (!image) return null;

  let back = e => {
    e.stopPropagation();
    history.goBack();
  };

  return (
    <div
      onClick={back}
      style={{ position: "absolute", top: 0, left: 0, bottom: 0, right: 0, background: "rgba(0, 0, 0, 0.15)"}}
    >
      <div
        className="modal"
        style={{position: "absolute", background: "#fff", top: 25, left: "10%", right: "10%", padding: 15, border: "2px solid #444"}}
      >
        <h1>{image.title}</h1>
        <Image color={image.color} />
        <button type="button" onClick={back}>Close</button>
      </div>
    </div>
  );
}

</textarea>StaticRouter Context - StaticRouter: A Router that never changes location.<textarea>
// This example renders a route within a StaticRouter and populates its staticContext, which it then prints out. In the real world you would use the StaticRouter for server-side rendering:
/*
import express from "express";
import ReactDOMServer from "react-dom/server";
const app = express()
app.get('*', (req, res) => {
  let staticContext = {}
  let html = ReactDOMServer.renderToString(
    <StaticRouter location={req.url} context={staticContext}>
      <App /> (includes the RouteStatus component below e.g. for 404 errors)
    </StaticRouter>
  );
  res.status(staticContext.statusCode || 200).send(html);
});
app.listen(process.env.PORT || 3000);
*/

import React, { Component } from "react";
import { StaticRouter as Router, Route } from "react-router-dom";

function RouteStatus(props) {
  return (
    <Route
      render={({ staticContext }) => {
        {/* we have to check if staticContext exists because it will be undefined if rendered through a BrowserRouter*/}
        if (staticContext) staticContext.statusCode = props.statusCode;
        return <div>{props.children}</div>;
      }}
    />
  );
}

function PrintContext(props) {
  return <p>Static context: {JSON.stringify(props.staticContext)}</p>;
}

export default class StaticRouterExample extends Component {
  // This is the context object that we pass to the StaticRouter. It can be modified by routes to provide additional information for the server-side render
  staticContext = {};

  render() {
    return (
      <Router location="/foo" context={this.staticContext}>
        <div>
          <RouteStatus statusCode={404}>
            <p>Route with statusCode 404</p>
            <PrintContext staticContext={this.staticContext} />
          </RouteStatus>
        </div>
      </Router>
    );
  }
}

</textarea>Query Parameters - URLSearchParams<textarea>
// React Router does not have any opinions about how you should parse URL query strings.
// If you use simple key=value query strings and do not need to support IE 11, you can use the browser's built-in URLSearchParams API.
// If your query strings contain array or object syntax, you'll probably need to bring your own query parsing function.

import React from "react";
import {BrowserRouter as Router,Link,useLocation} from "react-router-dom";

export default function QueryParamsExample() {
  return (
    <Router>
      <QueryParamsDemo />
    </Router>
  );
}

// A custom hook that builds on useLocation to parse the query string for you.
function useQuery() {
  return new URLSearchParams(useLocation().search);
}

function QueryParamsDemo() {
  let query = useQuery();

  return (
    <div>
      <div>
        <h2>Accounts</h2>
        <ul>
          <li><Link to="/account?name=netflix">Netflix</Link></li>
          <li><Link to="/account?name=zillow-group">Zillow Group</Link></li>
          <li><Link to="/account?name=yahoo">Yahoo</Link></li>
          <li><Link to="/account?name=modus-create">Modus Create</Link></li>
        </ul>

        <Child name={query.get("name")} />
      </div>
    </div>
  );
}

function Child({ name }) {
  return (
    <div>
      {name ? (
        <h3>The <code>name</code> in the query string is &quot;{name} &quot; </h3>
      ) : (
        <h3>There is no name in the query string</h3>
      )}
    </div>
  );
}
  

</textarea>
</div>

<div id="router_routers">
<h4>routers</h4>
路由的基本概念
现在的React Router版本中已不需要路由配置,现在一切皆组件。

ReactRouter中提供了以下三大类组件：
routers, like < BrowserRouter> and < HashRouter>,所有路由组件共用的底层接口组件,它是路由规则制定的最外层的容器
route matchers, like < Route> and < Switch>,路由规则匹配,并显示当前的规则对应的组件
navigation, like < Link>, < NavLink>, and < Redirect>,路由跳转的组件

当然每个组件下又会有几种不同的子类组件实现,比如Router组件就针对不同功能和平台对应用：
< BrowserRouter> 浏览器的路由组件
< HashRouter> URL格式为Hash路由组件
< MemoryRouter> 内存路由组件
< NativeRouter> Native的路由组件
< StaticRouter> 地址不改变的静态路由组件

At the core of every React Router application should be a router component. For web projects, react-router-dom provides < BrowserRouter> and < HashRouter> routers. The main difference between the two is the way they store the URL and communicate with your web server.

A BrowserRouter uses regular URL paths. These are generally the best-looking URLs, but they require your server to be configured correctly. Specifically, your web server needs to serve the same page at all URLs that are managed client-side by React Router. Create React App supports this out of the box in development, and comes with instructions on how to configure your production server as well.

A HashRouter stores the current location in the hash portion of the URL, so the URL looks something like http://example.com/#/your/page. Since the hash is never sent to the server, this means that no special server configuration is needed.

MemoryRouter 
主要用在ReactNative这种非浏览器的环境中,因此直接将URL的history保存在了内存中。 

StaticRouter
主要用于服务端渲染。

【 BrowserRouter组件 】
BrowserRouter主要在浏览器WEB应用中使用,它利用HTML5的history API来同步URL和UI的变化。当点击了程序中的一个链接之后,BrowserRouter就会找出与这个URL匹配的Route,并将他们对应的组件渲染出来。BrowserRouter是用来管理组件的,那么它当然要被放在最顶级的位置,而应用程序的组件就作为它的一个子组件而存在

BrowserRouter组件提供的属性:

children: node
渲染单一子组件(元素)

1、basename: 字符串类型,路由器的默认根路径
< BrowserRouter basename="/admin"/>
  < Link to="/home"/> // 被渲染为< a href="/admin/home">
< /BrowserRouter>

2、forceRefresh: 布尔类型,在导航的过程中整个页面是否刷新,true表示导航过程中整个页面将会刷新,只有当浏览器不支持HTML5的history API时才设置为true
const supportsHistory = 'pushState' in window.history
< BrowserRouter forceRefresh={!supportsHistory}/>

3、getUserConfirmation: 函数类型,当导航需要确认时执行的函数,默认window.confirm
const getConfirmation = (message, callback) => {
  const allowTransition = window.confirm(message)
  callback(allowTransition)
}
< BrowserRouter getUserConfirmation={getConfirmation}/>

4、keyLength: 数字类型,location.key的长度,默认6
< BrowserRouter keyLength={12}/>

</textarea><textarea>
import React from "react";
import ReactDOM from "react-dom";
import { BrowserRouter } from "react-router-dom";

const App = () => <h1>Hello React Router</h1>;

ReactDOM.render(
  <BrowserRouter>
    <App />
  </BrowserRouter>,
  document.getElementById("root")
);

</textarea><pre>
【 HashRouter 】
HashRouter使用URL的hash(例如：window.location.hash)来保持UI和URL的同步。
使用hash的方式记录导航历史不支持location.key和location.state。以前的版本为这种行为提供了shim,但仍有一些问题无法解,任何依赖此行为的代码或插件都将无法正常使用。由于该技术仅用于支持传统的浏览器,因此用于浏览器时可以使用< BrowserHistory>代替。
跟BrowserRouter类似,它也有：basename、getUserConfirmation、children属性,而且是一样的

hashType: string
window.location.hash使用的hash类型有如下几种：
"slash" - 默认,后面跟一个斜杠,例如 #/ 和 #/sunshine/lollipops
"noslash" - 后面没有斜杠,例如# 和 #sunshine/lollipops
"hashbang" - Google风格的"ajax crawlable",例如#!/ 和 #!/sunshine/lollipops

【 StaticRouter组件 】
A Router that never changes location.This can be useful in server-side rendering scenarios when the user isn’t actually clicking around, so the location never actually changes. Hence, the name: static. It’s also useful in simple tests when you just need to plug in a location and make assertions on the render output.Here’s an example node server that sends a 302 status code for < Redirect>s and regular HTML for other requests:

</pre><textarea>
import http from "http";
import React from "react";
import ReactDOMServer from "react-dom/server";
import { StaticRouter } from "react-router";

http
  .createServer((req, res) => {
    const context = {};  // This context object contains the results of the render
    const html = ReactDOMServer.renderToString(
      <StaticRouter location={req.url} context={context}>
        <App />
      </StaticRouter>
    );

    if (context.url) {   // context.url will contain the URL to redirect to if a <Redirect> was used
      res.writeHead(302, {Location: context.url});
      res.end();
    } else {
      res.write(html);
      res.end();
    }
  })
  .listen(3000);

</textarea><pre>
basename: string
The base URL for all locations. A properly formatted basename should have a leading slash, but no trailing slash.

</pre><textarea>
<StaticRouter basename="/calendar">
  <Link to="/today"/> // renders <a href="/calendar/today">
</StaticRouter>

</textarea><pre>
location: string
The URL the server received, probably req.url on a node server.

</pre><textarea>
<StaticRouter location={req.url}>
  <App />
</StaticRouter>

</textarea><pre>
location: object
A location object shaped like { pathname, search, hash, state }

</pre><textarea>
<StaticRouter location={{ pathname: "/bubblegum" }}>
  <App />
</StaticRouter>

</pre><textarea>
context: object
A plain JavaScript object. During the render, components can add properties to the object to store information about the render.

</pre><textarea>
const context = {}
<StaticRouter context={context}>
  <App />
</StaticRouter>

</textarea><pre>
When a <Route> matches, it will pass the context object to the component it renders as the staticContext prop. Check out the Server Rendering guide for more information on how to do this yourself.After the render, these properties can be used to to configure the server’s response.
  
if (context.status === "404") {
  // ...
}

children: node
The child elements to render.Note: On React < 16 you must use a single child element since a render method cannot return more than one element. If you need more than one element, you might try wrapping them in an extra <div>.

【 withRouter高阶组件 】
You can get access to the history object’s properties and the closest <Route>'s match via the withRouter higher-order component. 
withRouter will pass updated match, location, and history props to the wrapped component whenever it renders.

</pre><textarea><pre>
import React from "react";
import PropTypes from "prop-types";
import { withRouter } from "react-router";

class ShowTheLocation extends React.Component {
  static propTypes = {
    match: PropTypes.object.isRequired,
    location: PropTypes.object.isRequired,
    history: PropTypes.object.isRequired
  };

  render() {
    const { match, location, history } = this.props;
    return <div>You are now at {location.pathname}</div>;
  }
}

// Create a new component that is "connected" (to borrow redux terminology) to the router.
const ShowTheLocationWithRouter = withRouter(ShowTheLocation);

</textarea><pre>
withRouter does not subscribe to location changes like React Redux’s connect does for state changes. Instead, re-renders after location changes propagate(传播) out from the Router component. This means that withRouter does not re-render on route transitions unless its parent component re-renders.Static Methods and PropertiesAll non-react specific static methods and properties of the wrapped component are automatically copied to the "connected" component.

wrappedComponentRef: func
A function that will be passed as the ref prop to the wrapped component.

</pre><textarea>
class Container extends React.Component {
  componentDidMount() {
    this.component.doSomething();
  }

  render() {
    return (<MyComponent wrappedComponentRef={c => (this.component = c)} />);
  }
}

</pre>withRouter + ownProps<textarea>
import React, { Component } from 'react'
import PropTypes from 'prop-types'
import { connect } from 'react-redux'
import { withRouter } from 'react-router-dom'
import { loadUser, loadStarred } from '../actions'
import User from '../components/User'
import Repo from '../components/Repo'
import List from '../components/List'

const loadData = ({ login, loadUser, loadStarred }) => {
  loadUser(login, [ 'name' ])
  loadStarred(login)
}

class UserPage extends Component {
  static propTypes = {
    login: PropTypes.string.isRequired,
    user: PropTypes.object,
    starredPagination: PropTypes.object,
    starredRepos: PropTypes.array.isRequired,
    starredRepoOwners: PropTypes.array.isRequired,
    loadUser: PropTypes.func.isRequired,
    loadStarred: PropTypes.func.isRequired
  }

  componentDidMount() {
    loadData(this.props)
  }

  componentDidUpdate(prevProps) {
    if (prevProps.login !== this.props.login) {
      loadData(this.props)
    }
  }

  handleLoadMoreClick = () => {
    this.props.loadStarred(this.props.login, true)
  }

  renderRepo([ repo, owner ]) {
    return (<Repo repo={repo} owner={owner} key={repo.fullName} />)
  }

  render() {
    const { user, login } = this.props
    if (!user) return <h1><i>Loading {login}{"'s profile..."}</i></h1>

    const { starredRepos, starredRepoOwners, starredPagination } = this.props
    return (
      <div>
        <User user={user} />
        <hr />
        <List renderItem={this.renderRepo}
              items={zip(starredRepos, starredRepoOwners)}
              onLoadMoreClick={this.handleLoadMoreClick}
              loadingLabel={`Loading ${login}'s starred...`}
              {...starredPagination} />
      </div>
    )
  }
}

const mapStateToProps = (state, ownProps) => {
  console.log(ownProps)  // {history: {…}, location: {…}, match: {…}, staticContext: undefined}
  const login = ownProps.match.params.login.toLowerCase()

  const { pagination: { starredByUser }, entities: { users, repos } } = state

  const starredPagination = starredByUser[login] || { ids: [] }
  const starredRepos = starredPagination.ids.map(id => repos[id])
  const starredRepoOwners = starredRepos.map(repo => users[repo.owner])

  return {
    login,
    starredRepos,
    starredRepoOwners,
    starredPagination,
    user: users[login]
  }
}

export default withRouter(connect(mapStateToProps, {
  loadUser,
  loadStarred
})(UserPage))

</textarea><pre>
【 generatePath() 】
The generatePath function can be used to generate URLs to the routes. Internally the path-to-regexp library is used.

import { generatePath } from "react-router";
generatePath("/user/:id/:entity(posts|comments)", {id: 1, entity: "posts"});  // Will return /user/1/posts

Results of compiling paths into regular expressions are cached, so there is no overhead on generating multiple paths with the same pattern.

pattern: string
generatePath takes 2 arguments. The first one is a pattern provided as a path attribute to the Route component.

params: object
The second argument is an object with corresponding params for the pattern to use.If provided params and path don’t match, an error will be thrown:
generatePath("/user/:id/:entity(posts|comments)", { id: 1 });  // TypeError: Expected "entity" to be defined

</pre>
</div>

<div id="router_navigation">
<h4>navigation</h4><pre>
【 Redirect组件 】
当这个组件被渲染时location会被重写为Redirect的to指定的新location,一个用途是登录重定向,比如用户点登录并验证通过后将页面跳转到个人主页。

</textarea><textarea>
<Redirect to="/new"/>

// to: string
<Route exact path="/">
  {loggedIn ? <Redirect to="/dashboard" /> : <PublicHomePage />}
</Route>

// to: object
// The state object can be accessed via this.props.location.state in the redirected-to component. This new referrer key (which is not a special name) would then be accessed via this.props.location.state.referrer in the Login component pointed to by the pathname '/login'
<Redirect
  to={{
    pathname: "/login",
    search: "?utm=your+face",
    state: { referrer: currentLocation }
  }}
/>

// push: bool
// When true, redirecting will push a new entry onto the history instead of replacing the current one.
<Redirect push to="/somewhere/else" />

// from: string
A pathname to redirect from. Any valid URL path that path-to-regexp@^1.7.0 understands. All matched URL parameters are provided to the pattern in to. Must contain all parameters that are used in to. Additional parameters not used by to are ignored.Note: This can only be used to match a location when rendering a <Redirect> inside of a <Switch>
<Switch>
  <Redirect from='/old-path' to='/new-path' />
  <Route path='/new-path'>
    <Place />
  </Route>
</Switch>

// Redirect with matched parameters
<Switch>
  <Redirect from='/users/:id' to='/users/profile/:id'/>
  <Route path='/users/profile/:id'><Profile /></Route>
</Switch>

// exact: bool
// Match from exactly; equivalent to Route.exact.Note: This can only be used in conjunction with from to exactly match a location when rendering a <Redirect> inside of a <Switch>. See <Switch children> for more details.
<Switch>
  <Redirect exact from="/" to="/home" />
  <Route path="/home"><Home /></Route>
  <Route path="/about"><About /></Route>
</Switch>

// strict: bool
// Match from strictly; equivalent to Route.strict.Note: This can only be used in conjunction with from to strictly match a location when rendering a <Redirect> inside of a <Switch>. See <Switch children> for more details.
<Switch>
  <Redirect strict from="/one/" to="/home" />
  <Route path="/home"><Home /></Route>
  <Route path="/about"><About /></Route>
</Switch>

// sensitive: bool
// Match from case sensitive; equivalent to Route.sensitive

</textarea><pre>
【 Link组件 】
Link指明组件的位置。Link使用声明式的方式为应用程序提供导航功能,定义的Link最终会被渲染成一个a标签

属性：to
需要跳转到的路径(pathname)或地址(location),指明目标组件的路径,可以直接使用一个字符串,也可以传入一个对象,或function
A function to which current location is passed as an argument and which should return location representation as a string or as an object

</textarea><textarea>
import { Link } from 'react-router-dom'
<Link to="/about">About</Link>
<Link to="/courses?sort=name" />

// 字符串参数
<Link to="/query">查询</Link>

// 对象参数
<Link to={{
  pathname: '/query',
  search: '?key=name',
  hash: '#hash',
  state: { fromDashboard: true }
}}>查询</Link>

// function
<Link to={location => ({ ...location, pathname: "/courses" })} />
<Link to={location => `${location.pathname}?sort=name`} />

</textarea><pre>
属性：replace: bool, 默认false
true表示点击链接后将使用新地址替换掉访问历史记录里面的原地址,否则将在原有访问历史记录的基础上添加一个新的纪录。
< Link to="/courses" replace />

innerRef: function
As of React Router 5.1, if you are using React 16 you should not need this prop because we forward the ref to the underlying <a>. Use a normal ref instead.Allows access to the underlying ref of the component.

</pre><textarea>
<Link
  to="/"
  innerRef={node => {
    // `node` refers to the mounted DOM element
    // or null when unmounted
  }}
/>

</textarea><pre>
innerRef: RefObject
As of React Router 5.1, if you are using React 16 you should not need this prop because we forward the ref to the underlying <a>. Use a normal ref instead.Get the underlying ref of the component using React.createRef.

let anchorRef = React.createRef()
< Link to="/" innerRef={anchorRef} />

【 NavLink组件 】
NavLink是一个特殊的Link,可以使用activeClassName来设置Link被选中时被附加的class,使用activeStyle来配置被选中时应用的样式,activeClassName默认active。此外还有一个exact属性,此属性要求location完全匹配(地址栏中的URl和这个Link的to指定的location相匹配)才会附加class和style

< NavLink to={'/'} exact activeClassName='selected'>Home</ NavLink>  // 选中后被添加class selected
< NavLink to={'/gallery'} activeStyle={{color:red}}>Gallery</ NavLink>  // 选中后被附加样式color:red

属性
to 可以是字符串或者对象,同Link组件
exact 布尔类型,完全匹配时才会被附件class和style
activeStyle Object类型
activeClassName 字符串类型
strict: bool类型,当值为true时在确定位置是否与当前URL匹配时将考虑位置pathname后的斜线。

【 Switch组件 】
Renders the first child Route or Redirect that matches the location, ignores all others
you should put Routes with more specific (typically longer) paths before less-specific ones
If no Route matches, the Switch renders nothing (null).

这与只使用一堆< Route>有什么不同？
< Switch>的独特之处是独它仅仅渲染一个路由。相反地,每一个包含匹配地址(location)的< Route>都会被渲染

</textarea><textarea>
<Route path="/about" component={About}/>
<Route path="/:user" component={User}/>
<Route component={NoMatch}/>

如果现在的URL是/about,那么About、User、NoMatch都会被渲染,因为它们都与路径(path)匹配。这种设计允许以多种方式将多个Route组合到应用程序中,例如侧栏(sidebars),面包屑(breadcrumbs),bootstrap tabs等。但有时只想选择一个< Route>来渲染。如果现在处于/about,也不希望匹配/:user或显示"404"页面,以下是使用Switch的方法来实现：
现在如果处于/about,Switch将开始寻找匹配的Route。<Route path="/about"/>将被匹配,Switch将停止寻找匹配并渲染About。如果处于/michael,User将被渲染。

import { Switch, Route } from 'react-router'
<Switch>
  <Route exact path="/" component={Home}/>
  <Route path="/about" component={About}/>
  <Route path="/:user" component={User}/>
  <Route component={NoMatch}/>
</Switch>

这对于过渡动画也是起作用的,因为匹配的Route在与前一个相同的位置被渲染。
<Fade>
  <Switch>
    {/* 这里只会有一个子节点 */}
    <Route/>
    <Route/>
  </Switch>
</Fade>

<Fade>
  <Route/>
  <Route/>
  {/* 这里总是有两个子节点,一个可能会渲染为null, 使计算过渡增加了一点麻烦 */}    
</Fade>

</textarea><textarea>
import React from "react";
import ReactDOM from "react-dom";
import { BrowserRouter as Router, Switch, Route } from "react-router-dom";

function App() {
  return (
    <div>
      <Switch>
        {/* If the current URL is /about, this route is rendered while the rest are ignored */}
        <Route path="/about"><About /></Route>

        {/* The more specific path="/contact/:id" comes before path="/contact" so that route will render when viewing an individual contact */}
        <Route path="/contact/:id"><Contact /></Route>
        <Route path="/contact"><AllContacts /></Route>

        {/* If none of the previous routes render anything, this route acts as a fallback. A route with path="/" will *always* match the URL because all URLs begin with a /. So that's why we put this one last of all */}
        <Route path="/"><Home /></Route>
      </Switch>
    </div>
  );
}

ReactDOM.render(
  <Router>
    <App />
  </Router>,
  document.getElementById("root")
);

</textarea><pre>
【 Prompt组件 】
Used to prompt the user before navigating away from a page. When your application enters a state that should prevent the user from navigating away (like a form is half-filled out), render a Prompt

</pre><textarea>
<Prompt
  when={formIsHalfFilledOut}
  message="Are you sure you want to leave?"
/>

message: string
The message to prompt the user with when they try to navigate away.

<Prompt message="Are you sure you want to leave?" />

message: func
Will be called with the next location and action the user is attempting to navigate to. Return a string to show a prompt to the user or true to allow the transition.

<Prompt message={location => location.pathname.startsWith("/app") ? true : `Are you sure you want to go to ${location.pathname}?`}/>

when: bool
Instead of conditionally rendering a <Prompt> behind a guard, you can always render it but pass when={true} or when={false} to prevent or allow navigation accordingly.
  
<Prompt when={formIsHalfFilledOut} message="Are you sure?" />

</textarea>
</div>

<div id="router_route">
<h4>route</h4><pre>
【 Route组件 】
Route是react-route最重要的组件,作用是当location与Route的path匹配时渲染Route中的Component。如果有多个Route匹配则这些Route的Component都会被渲染。

</pre><textarea>
import React from "react";
import ReactDOM from "react-dom";
import { BrowserRouter as Router, Route } from "react-router-dom";

ReactDOM.render(
  <Router>
    <div>
      <Route exact path="/">
        <Home />
      </Route>
      <Route path="/news">
        <NewsFeed />
      </Route>
    </div>
  </Router>,
  node
);

</textarea><pre>
属性
path: string | string[]
Any valid URL path or array of paths that path-to-regexp@^1.7.0 understands.Routes without a path always match.
< Route path="/users/:id" component={User} />
< Route path={["/users/:id", "/profile/:id"]} component={User} />

strict: bool
< Route strict path="/one/" component={About} />>

exact属性
与Link类似,作用也是要求location与Route的path绝对匹配。

// 当location形如http://location/时Home就会被渲染,因为"/"会匹配所有的URL,所以这里设置一个exact来强制绝对匹配。
< Route exact path="/" component={Home}/>
< Route path="/about" component={About}/>

Route的三种渲染方式

</pre>1、component: 这是最常用也最容易理解的方式,给什么就渲染什么<textarea>
// All route props (match, location and history) are available to User
function User(props) {
  return <h1>Hello {props.match.params.username}!</h1>;
}

ReactDOM.render(
  <Router>
    <Route path="/user/:username" component={User} />
  </Router>,
  node
);

</textarea>2、render: render的类型是function,Route会渲染这个function的返回值,因此它的作用就是附加一些额外的逻辑<textarea>
<Route path="/home" render={() => {
  console.log('额外的逻辑');
  return (<div>Home</div>);
}}/>

// convenient inline rendering
ReactDOM.render(
  <Router>
    <Route path="/home" render={() => <div>Home</div>} />
  </Router>,
  node
);

// wrapping/composing
// You can spread routeProps to make them available to your rendered Component
function FadingRoute({ component: Component, ...rest }) {
  return (
    <Route
      {...rest}
      render={routeProps => (
        <FadeIn>
          <Component {...routeProps} />
        </FadeIn>
      )}
    />
  );
}

ReactDOM.render(
  <Router>
    <FadingRoute path="/cool" component={Something} />
  </Router>,
  node
);

</textarea><pre>
3、children: 这是最特殊的渲染方式
同render类似,是一个function,不同在于它会被传入一个match参数来表示这个Route的path和location匹配上没有。
第二个特殊的地方在于,即使path没有匹配上也可以将它渲染出来,秘诀就在于可以根据match参数来决定在匹配的时候渲染什么,不匹配的时候又渲染什么。

The children render prop receives all the same route props as the component and render methods, except when a route fails to match the URL, then match is null. This allows you to dynamically adjust your UI based on whether or not the route matches.

</textarea><textarea>
// 在匹配时容器的calss是light,Home会被渲染,在不匹配时容器的calss是dark,About会被渲染
<Route path='/home' children={({ match }) => (
  <div className={match ? 'light' : 'dark'}>
    {match ? <Home/>:<About>}
  </div>
)}/>

function ListItemLink({ to, ...rest }) {
  return (
    <Route
      path={to}
      children={({ match }) => (
        <li className={match ? "active" : ""}>
          <Link to={to} {...rest} />
        </li>
      )}
    />
  );
}

ReactDOM.render(
  <Router>
    <ul>
      <ListItemLink to="/somewhere" />
      <ListItemLink to="/somewhere-else" />
    </ul>
  </Router>,
  node
);

// This could also be useful for animations
<Route
  children={({ match, ...rest }) => (
    {/* Animate will always render, so you can use lifecycles to animate its child in and out */}
    <Animate>
      {match && <Something {...rest}/>}
    </Animate>
  )}
/>

</textarea><pre>
component、render、children三种渲染方式所有路由中指定的组件将被传入以下三个props
1、match
A match object contains information about how a < Route path> matched the URL. match objects contain the following properties:
params - (object) Key/value pairs parsed from the URL corresponding to the dynamic segments of the path,即路径参数,通过解析URL中动态的部分获得的键值对
isExact - (boolean) true if the entire URL was matched (no trailing characters),当为true时整个URL都需要匹配
path - (string) The path pattern used to match. Useful for building nested < Route>s,用来做匹配的路径格式。在需要嵌套< Route>的时候用到
url - (string) The matched portion of the URL. Useful for building nested < Link>s,URL匹配的部分,在需要嵌套< Link>的时候会用到

You’ll have access to match objects in various places:
Route component as this.props.match
Route render as ({ match }) => ()
Route children as ({ match }) => ()
withRouter as this.props.match
matchPath as the return value

If a Route does not have a path, and therefore always matches, you’ll get the closest parent match. Same goes for withRouter.

</textarea><textarea>
export default function RouteConfigExample() {
  return (
    <Router>
      <Link to='/p/1'>p1</Link>
      <Link to='/p/2'>p2</Link>
      <Link to='/p/3'>p3</Link>
      <Route path='/p/:id' render={(props)=> {
        console.log(props)
        {/*
          {
            history: {
              length: 14
              action: "POP"
              location: {pathname: "/p/1", search: "", hash: "", state: undefined, key: "g9fdvi"}
              createHref: ƒ createHref(location)
              push: ƒ push(path, state)
              replace: ƒ replace(path, state)
              go: ƒ go(n)
              goBack: ƒ goBack()
              goForward: ƒ goForward()
              block: ƒ block(prompt)
              listen: ƒ listen(listener)
            }
            location: {pathname: "/p/1", search: "", hash: "", state: undefined, key: "g9fdvi"}
            match: {
              path: "/p/:id"
              url: "/p/1"
              isExact: true
              params: {id: "1"}
            }
            staticContext: undefined
          }
        */}
        return <h3>当前文章ID: {props.match.params.id}</h3>
      }}/>
    </Router>
  );
}

2、location
Location是指当前的位置,下一步打算去的位置,或是你之前所在的位置,形式大概就像这样：

{
  key: 'ac3df4', // 在使用hashHistory时没有key
  pathname: '/somewhere'
  search: '?some=search-string',
  hash: '#howdy',
  state: {fromDashboard: true}
}

使用以下几种方式来获取location对象：
在Route component中以this.props.location的方式获取,
在Route render中以({ location }) => ()的方式获取,
在Route children中以({ location }) => ()的方式获取,
在withRouter中以this.props.location的方式获取。
也可以在history.location中获取location对象,但是别那么写,因为history是可变的

location对象不会发生改变,因此可在生命周期的钩子中使用location对象来查看当前页面的位置是否发生改变,这种技巧在获取远程数据及使用动画时非常有用。

componentWillReceiveProps(nextProps) {
  if (nextProps.location !== this.props.location) {
    // 已经跳转了！
  }
}

通常只需要给一个字符串当做location,但当需要添加一些location的状态时,可以对象的形式使用location,并且当需要多个UI,而这些UI取决于历史时,例如弹出框(modal),使用location对象会有很大帮助。

</textarea><textarea>
// 通常只需要这样使用location
<Link to="/somewhere"/>

// 但同样可以这么用
const location = {
  pathname: '/somewhere',
  state: { fromDashboard: true }
}

<Link to={location}/>
<Redirect to={location}/>
history.push(location)
history.replace(location)

</textarea><pre>
3、history
History是React Router的两大重要依赖之一(除去React本身),在不同的JS环境中history以多种形式实现了对于session历史的管理。

术语：
「browser history」 - history在DOM上的实现,经常使用于支持HTML5 history API的浏览器端
「hash history」 - history在DOM上的实现,经常使用于旧版本浏览器端
「memory history」 - 一种存储于内存的history实现,经常用于测试或是非DOM环境如React Native

history对象通常会具有以下属性和方法：
length -( number 类型)指的是history堆栈的数量。
action -( string 类型)指的是当前的动作(action),例如PUSH,REPLACE及POP
location -( object类型)是指当前的位置(location),location会具有如下属性：
location.pathname -( string 类型)URL路径。
location.search -( string 类型)URL中的查询字符串(query string)。
location.hash -( string 类型)URL的hash分段。
location.state -( string 类型)是指location中的状态,例如在push(path, state)时,state会描述什么时候location被放置到堆栈中等信息。这个state只会出现在browser history和memory history的环境里。
push(path, [state]) -( function 类型)在hisotry堆栈顶加入一个新的条目。
replace(path, [state]) -( function 类型)替换在history堆栈中的当前条目。
go(n) -( function 类型)将history对战中的指针向前移动n 。
goBack() -( function 类型)等同于go(-1) 。
goForward() -( function 类型)等同于go(1) 。
block(prompt) -( function 类型)阻止跳转

</pre>
</div>

<div id="router_hook">
<h4>hooks(React >= 16.8)</h4><pre>
React Router ships with a few hooks that let you access the state of the router and perform navigation from inside your components

useHistory
useLocation
useParams
useRouteMatch

</textarea><textarea>
// useHistory
// access to the history instance
import { useHistory } from "react-router-dom";
function HomeButton() {
  let history = useHistory();
  return (<button type="button" onClick={ ()=>{history.push("/home")} }>Go home</button>);
}

// useLocation
// returns the location object that represents the current URL. returns a new location whenever the URL changes
import React from "react";
import ReactDOM from "react-dom";
import {BrowserRouter as Router,Switch,useLocation} from "react-router-dom";
function usePageViews() {
  let location = useLocation();
  React.useEffect(() => {
    ga.send(["pageview", location.pathname]);
  }, [location]);
}
function App() {
  usePageViews();
  return <Switch>...</Switch>;
}
ReactDOM.render(<Router><App /></Router>, node);

// useParams
// returns an object of key/value pairs of URL parameters. Use it to access match.params of the current Route
import React from "react";
import ReactDOM from "react-dom";
import {BrowserRouter as Router,Switch,Route,useParams} from "react-router-dom";
function BlogPost() {
  let { slug } = useParams();
  return <div>Now showing post {slug}</div>;
}

ReactDOM.render(
  <Router>
    <Switch>
      <Route exact path="/"><HomePage /></Route>
      <Route path="/blog/:slug"><BlogPost /></Route>
    </Switch>
  </Router>,
  node
);

// useRouteMatch
// attempts to match the current URL in the same way that a Route would. It’s mostly useful for getting access to the match data without actually rendering a Route
// instead of
import { Route } from "react-router-dom";
function BlogPost() {
  return (
    <Route path="/blog/:slug" render={({ match }) => {
        // Do whatever you want with the match...
        return <div />;
      }}
    />
  );
}
// you can just
import { useRouteMatch } from "react-router-dom";
function BlogPost() {
  let match = useRouteMatch("/blog/:slug");
  // Do whatever you want with the match...
  return <div />;
}

</textarea>
</div>

<div id="router_ssr">
<h4>react服务端渲染ssr</h4><pre>
提高首屏加载速度和方便SEO
但增加了项目的复杂程度,提高维护成本,如果非必须,尽量不要用服务端渲染

服务端渲染的基本流程
用户请求过来时在服务端生成一个希望看到的网页内容的HTML字符串,返回给浏览器去展示。
浏览器拿到了这个HTML之后渲染出页面,但并没有事件交互,这时候浏览器发现HTML中加载了一些js文件(也就是浏览器端渲染的js)就直接去加载。
加载好并执行完以后,事件就会被绑定上了,这时候页面被浏览器端接管了,也就是到了js渲染页面的过程。

需要实现的目标：
React组件服务端渲染
路由的服务端渲染
保证服务端和浏览器的数据唯一
css的服务端渲染(样式直出)

一般的渲染方式
服务端渲染：服务端生成html字符串,发送给浏览器进行渲染。
浏览器端渲染：服务端返回空的html文件,内部加载js,完全由js完成页面的渲染

react 服务端渲染的条件
react-router4.x 与koa2.x 路由实现同构
redux 初始数据同构

整体思路
需要两个端：服务端、浏览器端(浏览器渲染的部分)
第一： 打包浏览器端代码
第二： 打包服务端代码并启动服务
第三： 用户访问,服务端读取浏览器端打包好的index.html文件为字符串,将渲染好的组件、样式、数据塞入html字符串,返回给浏览器
第四： 浏览器直接渲染接收到的html内容,并且加载打包好的浏览器端js文件,进行事件绑定,初始化状态数据,完成同构

【 React组件的服务端渲染 】
一个最简单的React服务端渲染的过程。
要进行服务端渲染的话那必然得需要一个根组件来负责生成HTML结构

import React from 'react';
import ReactDOM from 'react-dom';
ReactDOM.hydrate(< Container />, document.getElementById('root'));

这里用ReactDOM.render也是可以的,只不过hydrate会尽量复用接收到的服务端返回的内容,来补充事件绑定和浏览器端其他特有的过程

引入浏览器端需要渲染的根组件,利用react的renderToString API进行渲染

</pre><textarea>
import { renderToString } from 'react-dom/server'
import Container from '../containers'
// 产生html
const content = renderToString(< Container/>)
const html = `
    < html>
      < body>${content}< /body>
    < /html>
`
res.send(html)

</textarea><pre>
这里renderToString也可以替换成renderToNodeStream,区别在于前者是同步地产生HTML,也就是如果生成HTML用了1000毫秒就会在1000毫秒之后才将内容返回给浏览器,显然耗时过长。而后者则是以流的形式,将渲染结果塞给response对象,就是出来多少就返回给浏览器多少,可以相对减少耗时

React之所以可以做到服务端渲染是因为ReactDOM提供了服务端渲染的API
renderToString把一个react元素转换成带reactid的html字符串。
renderToStaticMarkup转换成不带reactid的html字符串,如果是静态文本,用这个方法会减少大批的reactid.
这两个方法的存在实际上可以把react看做是一个模板引擎,解析jsx语法变成普通的html字符串。

可以调用这两个API实现传入ReactComponent返回对应的html字符串到客户端,浏览器端接收到这段html以后不会重新去渲染DOM树,只是去做事件绑定等操作,这样就提高了首屏加载的性能。

【 路由的服务端渲染 】
一般应用不可能只有一个页面,肯定会有react-router-dom的路由跳转,但这是浏览器端渲染时候的用法,在做服务端渲染时需要将BrowserRouter替换为StaticRouter

服务端渲染与客户端渲染的不同之处在于其路由是没有状态的,所以需要通过一个无状态的router组件来包裹APP,通过服务端请求的url来匹配到具体的路由数组和其相关属性。所以在客户端使用BrowserRouter,服务端则使用无状态的StaticRouter。

BrowserRouter使用HTML5提供的history API (pushState, replaceState和popstate事件) 来保持UI和URL的同步。
StaticRouter是一个不会改变URL地址的router组件

</pre><textarea>
import { createServer } from 'http'
import { StaticRouter } from 'react-router-dom'
createServer((req, res) => {
  const html = renderToString(
    <StaticRouter location={req.url} context={{}} >
      <Container />
    <StaticRouter/>
  )
})

</textarea><pre>
StaticRouter要接收两个属性:
location: StaticRouter会根据这个属性自动匹配对应的React组件,所以才会实现刷新页面,服务端返回的对应路由的组与浏览器端保持一致
context: 一般用来传递一些数据,相当于一个载体,样式的服务端渲染的时候会用到

</pre><textarea>
// 服务端路由配置
// 把koa的路由url传入StaticRouter,后者会根据url自动匹配对应的React组件,这样就能实现刷新页面服务端返回的对应路由组件与客户端一致
import { createServer } from 'http'
import React from 'react'
import ReactDOMServer from 'react-dom/server'
import { StaticRouter } from 'react-router'
import App from './App'

createServer((req, res) => {
  const context = {}
  const html = ReactDOMServer.renderToString(
    <StaticRouter location={req.url} context={context}>
      <App/>
    </StaticRouter>
  )

  if (context.url) {
    res.writeHead(301, {Location: context.url})
    res.end()
  } else {
    res.write(`
      < !doctype html>
      <div id="app">${html}</div>
    `)
    res.end()
  }
}).listen(3000)

// 客户端路由配置
import ReactDOM from 'react-dom'
import { BrowserRouter } from 'react-router-dom'
import App from './App'

ReactDOM.render((
  <BrowserRouter>
    <App/>
  </BrowserRouter>
), document.getElementById('app'))

</textarea><pre>
【 Redux服务端同构 】
处理步骤如下：
1 根据对应的服务端请求API得到对应的异步方法获取到异步数据。
2 使用异步数据生成一个初始化的store const store = createStore(counterApp, preloadedState),
3 然后调用const finalState = store.getState()方法获取到store的初始化state
4 将初始的initState作为参数传递到客户端
5 客户端初始化的时候回去判断window.INITIAL_STATE是否有数据,如果有则作为初始数据重新生成一个客户端的store

</pre><textarea>
// 服务端
<html>
  <head>
    <title>Redux Universal Example</title>
  </head>
  <body>
    <div id="root">${html}</div>
    <script>window.__INITIAL_STATE__ = ${JSON.stringify(finalState)}</script>
    <script src="/static/bundle.js"></script>
  </body>
</html>    

 // 客户端
 ...
 // 通过服务端注入的全局变量得到初始 state
 const preloadedState = window.__INITIAL_STATE__
 
 // 使用初始state创建Redux store
 const store = createStore(counterApp, preloadedState)
 
 render(
  <Provider store={store}>
    <App />
  </Provider>,
  document.getElementById('root')
)

</textarea><pre>
这个基本上就是一个标准的redux同构流程, 其实更多的官方是在提供一种标准化的思路,可以顺着这个做更多的优化。
首先并不需要直接通过API作为映射 服务端和客户端各搞一套异步加载的方法,这样显得非常冗余。
react-router包里面提供了react-router-config主要用于静态路由配置。
提供的matchRoutes API可以根据传入的url返回对应的路由数组,可以通过这个方法在服务端直接访问到对应的React组件。 

如果要从路由中直接获取异步方法,有很多类似的同构方案,主要有两种方式
一种是直接在路由中增加一个thunk方法,通过这个方法直接去获取初始化的异步数据,优点是比较明确直观,直接在路由层就把这个事情解决了。
第二种是利用class的静态方法,可以通过路由访问到组件的类下面的static方法,这样就直接可以在容器组件内部同时声明服务端初始化方法和客户端初始化方法了,这样处理的层级放到了组件里面,更能体现组件的独立性

</pre><textarea><pre>
// 采用第二种方法
/**
 * 渲染服务端路由
 */
module.exports.render = async(ctx,next) =>{
  const { store ,history} = getCreateStore(ctx);
  const branch = matchRoutes(router, ctx.req.url);
  const promises = branch.map(({route}) => {
      const fetch = route.component.fetch;
      return fetch instanceof Function ? fetch(store) : Promise.resolve(null)
  });
  await Promise.all(promises).catch((err)=>{
      console.log(err);
  }); 

  const html = ReactDOMServer.renderToString(
      <Provider store={store}>
        <StaticRouter location={ctx.url} context={{}}>
            <App/>
        </StaticRouter>
      </Provider>
    )
    let initState=store.getState();
    const body =  layout(html,initState);
  ctx.body =body;
}

// 对应容器组件提供了一个静态的fetch方法
class Home extends Component {
  ...
  static fetch(store){
        return store.dispatch(fetchBookList({page:1,size:20}))
  }
}

// 这是actions
/**
 * 获取书籍目录
 * @param {*} param 
 */
export const fetchBookList = (params) => {
  return async (dispatch, getState) => {
    await axios.get(api.url.booklist, {
        params: params
    }).then((res) => {
        dispatch(booklist(res.data.result));
    }).catch((err) => {

    })
  }
}

</textarea><pre>
首先通过matchRoutes拿到当前路由下所有的路由,再对其遍历得到有关一个异步方法的Promise数组,这里所谓的异步方法就是actions中的异步方法。由于在服务端也初始化的store所以可以直接在服务端调用actions,这里需要给容器组件的static方法传入store ,这样就可以通过store.dispatch(fetchBookList({page:1,size:20}))调用actions了。
上面的方法得到了一个Promise数组,使用Promise.all将异步全部执行,这个时候实际上store的运行跟客户端是一样的。在异步的过程中将初始数据全部写入了store中,所以通过store.getState()就可以拿到初始化数据了。客户端的初始化跟Redux官方例子是一样的,直接判断是否传入初始化state,如果传入就做为初始化数据。
服务端的初始化异步和客户端的初始化异步如何避免重复,这里直接先获取store中的对应初始数据 ,看是否存在,如果不存在再进行加载。

到这一步已经可以实现刷新页面异步数据服务端处理,不刷新页面前端处理,一个基本的同构方案主体就出来了,剩下的就是一些优化项和一些项目定制性的东西了。

【 Redux服务端同构 】
数据的预获取以及脱水与注水是服务端渲染的难点。

首屏渲染的网页一般要去请求外部数据,希望在生成HTML之前去获取到这个页面需要的所有数据,然后塞到页面中去,这个过程叫做“脱水”(Dehydrate),生成HTML返回给浏览器。浏览器拿到带着数据的HTML去请求浏览器端js,接管页面,用这个数据来初始化组件,这个过程叫“注水”(Hydrate),完成服务端与浏览器端数据的统一。

为什么要这么做呢？试想一下,假设没有数据的预获取,直接返回一个没有数据只有固定内容的HTML结构,会有什么结果呢？
第一：由于页面内没有有效信息,不利于SEO。
第二：由于返回的页面没有内容,但浏览器端JS接管页面后去请求数据、渲染数据,页面会闪一下,用户体验不好。

使用Redux来管理状态,因为有服务端代码和浏览器端代码,那么就分别需要两个store来管理服务端和浏览器端的数据。

组件的配置
组件要在服务端渲染的时候去请求数据,可以在组件上挂载一个专门发异步请求的方法如loadData,接收服务端的store作为参数,然后store.dispatch去扩充服务端的store。

</pre><textarea>
class Home extends React.Component {
  componentDidMount() {
    this.props.callApi()
  }
  render() {
    return <div>{this.props.state.name}</div>
  }
}
Home.loadData = store => {
  return store.dispatch(callApi())
}
const mapState = state => state
const mapDispatch = {callApi}
export default connect(mapState, mapDispatch)(Home)

</textarea><pre>
路由的改造
因为服务端要根据路由判断当前渲染哪个组件,可以在这个时候发送异步请求,所以路由也需要配置一下来支持loadData方法。服务端渲染的时候路由的渲染可以使用react-router-config库,用法如下(重点关注在路由上挂载loadData方法):

</pre><textarea>
import { BrowserRouter } from 'react-router-dom'
import { renderRoutes } from 'react-router-config'
import Home from './Home'
export const routes = [
  {
    path: '/',
    component: Home,
    loadData: Home.loadData,
    exact: true,
  }
]
const Routers = <BrowserRouter>
    {renderRoutes(routes)}
<BrowserRouter/>

</textarea><pre>
服务端获取数据
到了服务端,需要判断匹配的路由内的所有组件各自都有没有loadData方法,有就去调用,传入服务端的store,去扩充服务端的store。
同时还要注意到,一个页面可能是由多个组件组成的,会发各自的请求,也就意味着要等所有的请求都发完,再去返回HTML。

</pre><textarea>
import serverRender from './render'
import { matchRoutes } from 'react-router-config'
import { routes } from '../routes'
import serverStore from "../store/serverStore"

const app = express()
app.get('*', (req, res) => {
  const context = {css: []}
  const store = serverStore()
  const matchedRoutes = matchRoutes(routes, req.path)  // 用matchRoutes方法获取匹配到的路由对应的组件数组
  const promises = []
  // 把每个loadData都包了一个promise是为了容错,一旦有一个请求出错,那么下边Promise.all方法则不会执行,所以包一层promise的目的是即使请求出错,也会resolve,不会影响到Promise.all方法,也就是说只有请求出错的组件会没数据,而其他组件不会受影响
  for (const item of matchedRoutes) {
    if (item.route.loadData) {
      const promise = new Promise((resolve, reject) => {
        item.route.loadData(store).then(resolve).catch(resolve)
      })
      promises.push(promise)
    }
  }
  // 所有请求响应完毕,将被HTML内容发送给浏览器
  Promise.all(promises).then(() => {
    // 将生成html内容的逻辑封装成了一个函数,接收req, store, context
    res.send(serverRender(req, store, context))
  })
})

</textarea><pre>
注入数据
请求已经发出去了,并且在组件的loadData方法中也扩充了服务端的store,那么可以从服务端的数据取出来注入到要返回给浏览器的HTML中了。

</pre><textarea>
const serverRender = (req, store, context) => {
  // 读取客户端生成的HTML
  const template = fs.readFileSync(process.cwd() + '/public/static/index.html', 'utf8')
  const content = renderToString(
    <Provider store={store}>
      <StaticRouter location={req.path} context={context}>
        <Container/>
      </StaticRouter>
    </Provider>
  )
  // 注入数据
  const initialState = `<script>
    window.context = {
      INITIAL_STATE: ${JSON.stringify(store.getState())}
    }
</script>`
  return template.replace('<!--app-->', content)
    .replace('<!--initial-state-->', initialState)
}

</textarea></pre>
浏览器端用服务端获取到的数据初始化store
经过上边的过程已经可以从window.context中拿到服务端预获取的数据了,此时需要做的事就是用这份数据去初始化浏览器端的store,保证两端数据的统一。

</pre><textarea>
import { createStore, applyMiddleware, compose } from 'redux'
import thunk from 'redux-thunk'
import rootReducer from '../reducers'

const defaultStore = window.context && window.context.INITIAL_STATE
const clientStore = createStore(
  rootReducer,
  defaultStore,// 利用服务端的数据初始化浏览器端的store
  compose(
    applyMiddleware(thunk),
    window.devToolsExtension ? window.devToolsExtension() : f=>f
  )
)

</textarea><pre>
至此服务端渲染的数据统一问题就解决了,再来回顾一下整个流程：
用户访问路由,服务端根据路由匹配出对应路由内的组件数组
循环数组,调用组件上挂载的loadData方法,发送请求,扩充服务端store
所有请求完成后,通过store.getState,获取到服务端预获取的数据,注入到window.context中
浏览器渲染返回的HTML,加载浏览器端js,从window.context中取数据来初始化浏览器端的store,渲染组件

【 样式的服务端渲染 】
以上所做的事情只是让网页的内容经过了服务端的渲染,但样式要在浏览器加载css后才会加上,所以最开始返回的网页内容没有样式,页面依然会闪一下。为了解决这个问题,需要让样式也一并在服务端渲染的时候返回。

首先,服务端渲染的时候,解析css文件不能使用style-loader了,要使用isomorphic-style-loader。
{
test: /\.css$/,
use: ['isomorphic-style-loader','css-loader','postcss-loader'],
}

如何在服务端获取到当前路由内的组件样式呢？做路由的服务端渲染时用到了StaticRouter,它会接收一个context对象,这个context对象可以作为一个载体来传递一些信息
思路就是在渲染组件的时候在组件内接收context对象,获取组件样式放到context中,服务端拿到样式,插入到返回的HTML中的style标签中。

</pre>组件是如何读取样式<textarea>
import style from './style/index.css'
class Index extends React.Component {
    componentWillMount() {
      if (this.props.staticContext) {
        const css = styles._getCss()
        this.props.staticContext.css.push(css)
      }
    }
}

</textarea><pre>
在路由内的组件可以在props里接收到staticContext,也就是通过StaticRouter传递过来的context,
isomorphic-style-loader提供了_getCss()方法读取到css样式,然后放到staticContext里。
不在路由之内的组件,可以通过父级组件,传递props的方法,或者用react-router的withRouter包裹一下

其实这部分提取css的逻辑可以写成高阶组件,这样就可以做到复用了

</pre><textarea>
import React, { Component } from 'react'

export default (DecoratedComponent, styles) => {
  return class NewComponent extends Component {
    componentWillMount() {
      if (this.props.staticContext) {
        const css = styles._getCss()
        this.props.staticContext.css.push(css)
      }
    }
    render() {
      return <DecoratedComponent {...this.props}/>
    }
  }
}

</textarea>在服务端,经过组件的渲染之后,context中已经有内容了,这时候把样式处理一下,返回给浏览器,就可以做到样式的服务端渲染了<textarea>
const serverRender = (req, store) => {
  const context = {css: []}
  const template = fs.readFileSync(process.cwd() + '/public/static/index.html', 'utf8')
  const content = renderToString(
    <Provider store={store}>
      <StaticRouter location={req.path} context={context}>
        <Container/>
      </StaticRouter>
    </Provider>
  )
  // 经过渲染之后,context.css内已经有了样式
  const cssStr = context.css.length ? context.css.join('\n') : ''
  const initialState = `<script>
    window.context = {
      INITIAL_STATE: ${JSON.stringify(store.getState())}
    }
</script>`
  return template.replace('<!--app-->', content)
    .replace('server-render-css', cssStr)
    .replace('<!--initial-state-->', initialState)
}

</textarea><pre>
至此,服务端渲染就全部完成了。

React的服务端渲染,最好的解决方案就是Next.js。如果应用没有SEO优化的需求,又或者不太注重首屏渲染的速度,那么尽量就不要用服务端渲染,因为会让项目变得复杂。此外除了服务端渲染,SEO优化的办法还有很多,比如预渲染(pre-render)

</pre>
</div>

<div id="dva">
<h4>Dvajs</h4><pre>
dva是基于redux和redux-saga的数据流方案,然后为了简化开发体验,dva还额外内置了react-router和fetch,所以也可以理解为一个轻量级的应用框架

特性
易学易用,仅有6个api,对redux用户尤其友好,配合umi使用后更是降低为0 API
elm概念,通过reducers, effects和subscriptions组织model
插件机制,比如dva-loading可以自动处理loading状态,不用一遍遍地写showLoading和hideLoading
支持HMR,基于babel-plugin-dva-hmr实现components、routes和models的 HMR

安装dva-cli
$ npm install dva-cli -g
$ dva -v
dva-cli version 0.9.1

创建新应用
安装完dva-cli之后就可以在命令行里访问到 dva 命令。现在可以通过 dva new 创建新应用。
$ dva new dva-quickstart  // 创建dva-quickstart目录,包含项目初始化目录和文件,并提供开发服务器、构建脚本、数据mock服务、代理服务器等功能。
$ cd dva-quickstart
$ npm start               // 启动开发服务器,在浏览器里打开http://localhost:8000会看到dva的欢迎界面

使用antd
$ npm install antd babel-plugin-import --save  // babel-plugin-import是用来按需加载antd的脚本和样式
编辑.webpackrc使babel-plugin-import插件生效(dva-cli基于roadhog实现build和dev)
{
+  "extraBabelPlugins": [
+    ["import", { "libraryName": "antd", "libraryDirectory": "es", "style": "css" }]
+  ]
}

</pre><textarea>
1、定义路由
写个应用来先显示产品列表。首先第一步是创建路由,路由可以想象成是组成应用的不同页面。
新建 route component routes/Products.js,内容如下：
import React from 'react';
const Products = (props) => (
  <h2>List of Products</h2>
);
export default Products;

添加路由信息到路由表,编辑router.js :
+ import Products from './routes/Products';
...
+ <Route path="/products" exact component={Products} />
然后在浏览器里打开 http://localhost:8000/#/Products

2、编写UI Component
随着应用的发展,会需要在多个页面分享UI元素或在一个页面使用多次,在dva里可以把这部分抽成component
编写一个 ProductList component,这样就能在不同的地方显示产品列表了

// components/ProductList.js
import React from 'react';
import PropTypes from 'prop-types';
import { Table, Popconfirm, Button } from 'antd';

const ProductList = ({ onDelete, products }) => {
  const columns = [{
    title: 'Name',
    dataIndex: 'name',
  }, {
    title: 'Actions',
    render: (text, record) => {
      return (
        <Popconfirm title="Delete?" onConfirm={() => onDelete(record.id)}>
          <Button>Delete</Button>
        </Popconfirm>
      );
    },
  }];
  return (
    <Table dataSource={products} columns={columns} />
  );
};

ProductList.propTypes = {
  onDelete: PropTypes.func.isRequired,
  products: PropTypes.array.isRequired,
};

export default ProductList;

3、定义Model
完成UI后开始处理数据和逻辑。
dva通过model的概念把一个领域的模型管理起来,包含同步更新state的reducers,处理异步逻辑的effects,订阅数据源的subscriptions

// model models/products.js
export default {
  namespace: 'products',    // 表示在全局state上的key
  state: [],                // 初始值,在这里是空数组
  reducers: {               // 等同于redux里的reducer,接收action,同步更新state
    'delete'(state, { payload: id }) {
      return state.filter(item => item.id !== id);
    },
  },
};

然后在index.js里载入他：
+ app.model(require('./models/products').default);

4、connect起来
到这里已经单独完成了model和component,dva提供了connect方法将他们串联起来,这个connect就是react-redux的connect

// routes/Products.js
import React from 'react';
import { connect } from 'dva';
import ProductList from '../components/ProductList';

const Products = ({ dispatch, products }) => {
  function handleDelete(id) {
    dispatch({
      type: 'products/delete',
      payload: id,
    });
  }
  return (
    <div>
      <h2>List of Products</h2>
      <ProductList onDelete={handleDelete} products={products} />
    </div>
  );
};

// export default Products;
export default connect(({ products }) => ({
  products,
}))(Products);

5、最后还需要一些初始数据让这个应用run起来

// index.js
+ const app = dva({
+   initialState: {
+     products: [
+       { name: 'dva', id: 1 },
+       { name: 'antd', id: 2 },
+     ],
+   },
+ });

6、构建应用
完成开发并且在开发环境验证之后就需要部署给用户了
$ npm run build  // 打包所有的资源,包含JavaScript, CSS, web fonts, images, html等,然后可以在dist/目录下找到这些文件

</textarea><pre>
【 dva基本概念 】
数据流向
数据的改变发生通常是通过用户交互行为或者浏览器行为(如路由跳转等)触发的,当此类行为会改变数据的时候可以通过 dispatch 发起一个 action,如果是同步行为会直接通过 Reducers 改变 State ,如果是异步行为(副作用)会先触发 Effects 然后流向 Reducers 最终改变 State,所以在 dva 中,数据流向非常清晰简明,并且思路基本跟开源社区保持一致

</pre>dva应用的最简结构<textarea>
// 创建应用
const app = dva();

// 注册Model
app.model({
  namespace: 'count',
  state: 0,
  reducers: {
    add(state) { return state + 1 },
  },
  effects: {
    *addAfter1Second(action, { call, put }) {
      yield call(delay, 1000);
      yield put({ type: 'add' });
    },
  },
});

// 注册视图
app.router(() => <ConnectedApp />);

// 启动应用
app.start('#root');

</textarea><textarea>
app.model({
  namespace: 'count',
  state: {
    record: 0,
    current: 0,
  },
  reducers: {
    add(state) {
      const newCurrent = state.current + 1;
      return { ...state,
        record: newCurrent > state.record ? newCurrent : state.record,
        current: newCurrent,
      };
    },
    minus(state) {
      return { ...state, current: state.current - 1};
    },
  },
  effects: {
    *add(action, { call, put }) {
      yield call(delay, 1000);
      yield put({ type: 'minus' });
    },
  },
  subscriptions: {
    keyboardWatcher({ dispatch }) {
      key('⌘+up, ctrl+up', () => { dispatch({type:'add'}) });
    },
  },
});

</textarea><pre>
Model对象的属性
namespace: 当前 Model 的名称。整个应用的 State,由多个小的 Model 的 State 以 namespace 为 key 合成
state: 该Model当前的状态。数据保存在这里,直接决定了视图层的输出
reducers: Action处理器,处理同步动作,用来算出最新的State
effects：Action处理器,处理异步动作

1、State
type State = any
State表示Model的状态数据,通常表现为一个js对象,当然它可以是任何值;操作的时候每次都要当作不可变数据(immutable data)来对待,保证每次都是全新对象,没有引用关系,这样才能保证State的独立性,便于测试和追踪变化。
在dva中可以通过dva的实例属性_store看到顶部的state数据,但通常很少会用到:

const app = dva();
console.log(app._store); // 顶部的 state 数据

2、Action
type AsyncAction = any
Action是一个普通js对象,它是改变State的唯一途径。无论是从UI事件、网络回调,还是WebSocket等数据源所获得的数据,最终都会通过dispatch函数调用一个action,从而改变对应的数据。action必须带有type属性指明具体的行为,其它字段可自定义,如果要发起一个action需要使用dispatch函数;注意dispatch是在组件connect Models以后,通过props传入的。
dispatch({ type: 'add' });

3、dispatch函数
type dispatch = (a: Action) => Action
dispatching function是一个用于触发action的函数,action是改变State的唯一途径,但它只描述了一个行为,而dipatch可以看作是触发这个行为的方式,而Reducer则是描述如何改变数据的。
在dva中connect Model的组件通过props可以访问到dispatch,可以调用Model中的Reducer或Effects,常见的形式如：

dispatch({
  type: 'user/add', // 如果在 model 外调用,需要添加 namespace
  payload: {}, // 需要传递的信息
});

4、Reducer
type Reducer<S, A> = (state: S, action: A) => S
Reducer(也称为 reducing function)函数接受两个参数：之前已经累积运算的结果和当前要被累积的值,返回的是一个新的累积结果。该函数把一个集合归并成一个单值。
Reducer的概念来自于是函数式编程,很多语言中都有reduce API,如在js中：
[{x:1},{y:2},{z:3}].reduce(function(prev, next){
    return Object.assign(prev, next);
})
//return {x:1, y:2, z:3}
在dva中reducers聚合积累的结果是当前model的state对象。通过actions中传入的值,与当前reducers中的值进行运算获得新的值也就是新的state。Reducer必须是纯函数,所以同样的输入必然得到同样的输出,它们不应该产生任何副作用,并且每一次的计算都应该使用immutable data,这种特性简单理解就是每次操作都是返回一个全新的数据(独立,纯净),所以热重载和时间旅行这些功能才能够使用。

Reducer是Action处理器,用来处理同步操作,可以看做是state的计算器。作用是根据Action从上一个State算出当前State

</pre><textarea>
// count +1
function add(state) { return state + 1; }

// 往 [] 里添加一个新 todo
function addTodo(state, action) { return [...state, action.payload]; }

// 往 { todos: [], loading: true } 里添加一个新 todo,并标记 loading 为 false
function addTodo(state, action) {
  return {
    ...state,
    todos: state.todos.concat(action.payload),
    loading: false
  };
}

</textarea><pre>
5、Effect
Effect被称为副作用,在应用中最常见的就是异步操作。它来自于函数编程的概念,之所以叫副作用是因为它使得函数变得不纯,同样的输入不一定获得同样的输出。
dva为了控制副作用的操作,底层引入了redux-sagas做异步流程控制,由于采用了generator的相关概念,所以将异步转成同步写法,从而将effects转为纯函数

effext是Action处理器,处理异步动作,基于Redux-saga实现。Effect指的是副作用。根据函数式编程,计算以外的操作都属于Effect,典型的就是I/O操作、数据库读写
Effect 是一个 Generator 函数,内部使用 yield 关键字,标识每一步的操作(不管是异步或同步)

dva提供多个effect函数内部的处理函数
call：执行异步函数,调用异步逻辑,支持promise 
put：发出一个Action,类似于dispatch
select: 从state里获取数据

import Taro from '@tarojs/taro';
const baseUrl = process.env.NODE_ENV === 'production' ? 'https://xin.kavil.com.cn' : 'http://localhost:8360';

export default (options: IOption = { method: 'GET', data: {}, url: '' }) => {
  Taro.showLoading({title: '加载中'});
  console.log(`${new Date().toLocaleString()}【${options.url} 】【请求】`, options.data);
  for (const key in options.data) {
    options.data.hasOwnProperty(key) && (options.data[key] === undefined || options.data[key] == null) && delete options.data[key];
  }
  return Taro.request({
    url: baseUrl + options.url,
    data: { ...options.data },
    header: { 'x-token': Taro.getStorageSync('token'), 'Content-Type': 'application/json' },
    method: options.method.toUpperCase(),
  }).then(res => {
    setTimeout(() => { Taro.hideLoading()  }, 100);
    const { statusCode, data } = res;
    if (statusCode >= 200 && statusCode < 300) {
      console.log(`${new Date().toLocaleString('zh', { hour12: false })}【${options.url} 】【返回】`, res.data);
      if (data.errno !== 0) {
        if (data.errno === 401) {
          console.log(401, '未登录');
        } else {
          Taro.showModal({ title: '错误提示', content: res.data.errmsg || res.data.errno, showCancel: false });
        }
      }
      return data;
    } else {
      Taro.showModal({ title: '错误提示', content: `网络请求错误,请重试`, showCancel: false });
      return;
    }
  });
};

const bindPhone = data => Request({ url: '/user/bindPhone', method: 'POST', data });

export default {
  namespace: 'common',
  state: {
    userInfo: {},
    token: Taro.getStorageSync('token'),
    launchInfo: JSON.parse(Taro.getStorageSync('launchInfo') || '{}'),
    wxLoginCode: null,
    cityId: 1720, // 渝水区
    uploadSign: {},
    formIdArr: [],
  },

  effects: {
    *BindPhone({ payload }, { call, put, select }) {
      const res = yield call(Api.bindPhone, { ...payload, code: (yield Taro.login()).code });
      if (res && res.errno === 0) {
        const { userInfo } = yield select(state => state.common);
        yield put({
          type: 'save',
          payload: {
            userInfo: { ...userInfo, mobile: res.data },
          },
        });
      }
      return res;
    }
  },
  reducers: {
    save(state, { payload }) {
      return { ...state, ...payload };
    },
  },
};

</textarea><pre>
6、Subscription
Subscriptions是一种从源获取数据的方法,它来自于elm。
Subscription语义是订阅,用于订阅一个数据源,然后根据条件dispatch需要的action。数据源可以是当前的时间、服务器的websocket连接、keyboard输入、geolocation变化、history路由变化等

</pre><textarea>
import key from 'keymaster';
...
app.model({
  namespace: 'count',
  subscriptions: {
    keyEvent({dispatch}) {
      key('⌘+up, ctrl+up', () => { dispatch({type:'add'}) });
    },
  }
});

</textarea><pre>
7、Router
这里的路由通常指前端路由,由于应用现在通常是单页应用,所以需要前端代码来控制路由逻辑,通过浏览器提供的History API可以监听浏览器url的变化,从而控制路由相关操作。
dva实例提供了router方法来控制路由,使用的是react-router。

import { Router, Route } from 'dva/router';
app.router(({history}) =>
  <Router history={history}>
    <Route path="/" component={HomePage} />
  </Router>
);

</pre><pre>
8、Route Components
在组件设计方法中提到过Container Components,在dva中通常将其约束为Route Components,因为在dva中通常以页面维度来设计Container Components。
所以在dva中通常需要connect Model的组件都是Route Components,组织在/routes/目录下,而/components/目录下则是纯组件(Presentational Components)。

9、错误处理

</pre><textarea>
#全局错误处理
dva里effects和subscriptions的抛错全部会走onError hook,所以可以在onError里统一处理错误,然后effects里的抛错和reject的promise就都会被捕获到了。

const app = dva({
  onError(e, dispatch) {
    console.log(e.message);
  },
});

#本地错误处理
如果需要对某些effects的错误进行特殊处理,需要在effect内部加try catch

app.model({
  effects: {
    *addRemote() {
      try {
        // Your Code Here
      } catch(e) {
        console.log(e.message);
      }
    },
  },
});

</textarea><pre>
10、dva-loading插件
dva-loading插件是对异步才作用的;该插件是对reducers新增state数据(loading对象),所以在页面应该导入对应的数据(也就是loading数据),对其进行操作

$ npm install dva-loading --save

import createLoading from 'dva-loading';
const app = dva();
app.use(createLoading(opts));

const isFetch = props.loading.effects['users/user/fetch'];

@connect(({ common, loading, cart }) => ({
  ...common,
  ...cart,
  userInfoLoading: loading.effects['common/getUserInfo'],
  loginLoading: loading.effects['common/login'],
}))

当引入dva-loading插件之后,reducers中的state新增了loading对象,loading对象中有三个变量,effects、global、models
当发送一个异步请求时loading值的变化

请求前,loading为：
laoding: {
  effects: {}
  global: false
  models: {}
}

请求中,loading为：
loading： {
  effects: {users/user/fetch: true}  // effects的key为dispatch的type值,value为true;
  global: true
  models: {users: true}  // models的key为namespace值,value为true;
}

请求完成,loading为：
loading： {
  effects: {users/user/fetch: false}  // effects的key为dispatch的type值,value为false
  global: false
  models: {users: false}  // models的key为namespace值,value为false
}

</pre>【 dva taro 】<textarea>
import { create } from 'dva-core';
import createLoading from 'dva-loading';
import models from './models';

let app;
let store;
let dispatch;

function createApp(opt) {
  // opt.onAction = [createLogger()];  redux日志
  opt.onError = err => {
    Taro.hideLoading();
    Taro.showToast({ title: '服务器错误', image: sadImg });
  };
  app = create(opt);
  app.use(createLoading({}));

  // 适配支付宝小程序
  if (Taro.getEnv() === Taro.ENV_TYPE.ALIPAY) {
    global = {};
  }
  if (!global.registered) opt.models.forEach(model => app.model(model));
  global.registered = true;

  app.start();

  store = app._store;
  app.getStore = () => store;
  dispatch = store.dispatch;
  app.dispatch = dispatch;
  return app;
}

const dvaApp = createApp({
  initialState: {},
  models: models,
});
const store = dvaApp.getStore();

</textarea>
</div>

<div id="Web_Components">
<h3>Web Components</h3><pre>
组件是前端的发展方向,现在流行的 React 和 Vue 都是组件框架。
谷歌由于掌握了 Chrome 浏览器,一直在推动浏览器的原生组件,即 Web Components API。相比第三方框架,原生组件简单直接,符合直觉,不用加载任何外部模块,代码量小。目前,它还在不断发展,但已经可用于生产环境。

user-card这种自定义的HTML标签称为自定义元素(custom element)。根据规范,自定义元素的名称必须包含连词线,用与区别原生的HTML元素,所以user-card不能写成usercard


</textarea>http://www.ruanyifeng.com/blog/2019/08/web_components.html<textarea>
<user-card
  image="https://semantic-ui.com/images/avatar2/large/kristy.png"
  name="User Name"
  email="yourmail@some-email.com"
></user-card>

// 组件的样式应该与代码封装在一起,只对自定义元素生效,不影响外部的全局样式
<template id="userCardTemplate">
  <style>
   :host {
     display: flex;
     align-items: center;
     width: 450px;
     height: 180px;
     background-color: #d4d4d4;
     border: 1px solid #d5d5d5;
     box-shadow: 1px 1px 5px rgba(0, 0, 0, 0.1);
     border-radius: 3px;
     overflow: hidden;
     padding: 10px;
     box-sizing: border-box;
     font-family: 'Poppins', sans-serif;
   }
   .image {
     flex: 0 0 auto;
     width: 160px;
     height: 160px;
     vertical-align: middle;
     border-radius: 5px;
   }
   .container {
     box-sizing: border-box;
     padding: 20px;
     height: 160px;
   }
   .container > .name {
     font-size: 20px;
     font-weight: 600;
     line-height: 1;
     margin: 0;
     margin-bottom: 5px;
   }
   .container > .email {
     font-size: 12px;
     opacity: 0.75;
     line-height: 1;
     margin: 0;
     margin-bottom: 15px;
   }
   .container > .button {
     padding: 10px 25px;
     font-size: 12px;
     border-radius: 5px;
     text-transform: uppercase;
   }
  </style>
  
  <img class="image">
  <div class="container">
    <p class="name"></p>
    <p class="email"></p>
    <button class="button">Follow John</button>
  </div>
</template>

<script>
// 自定义元素需要使用js定义一个类,所有user-card元素都会是UserCard类的实例  
class UserCard extends HTMLElement {
  constructor() {
    super();
    // 自定义元素的this.attachShadow()方法开启 Shadow DOM,不希望用户能够看到user-card的内部代码,Web Component允许内部代码隐藏起来,这叫做Shadow DOM,即这部分DOM默认与外部DOM隔离,内部任何代码都无法影响外部。
    // this.attachShadow()方法的参数{ mode: 'closed' },表示 Shadow DOM 是封闭的,不允许外部访问
    var shadow = this.attachShadow( { mode: 'closed' } );
    
    var templateElem = document.getElementById('userCardTemplate');
    var content = templateElem.content.cloneNode(true);
    content.querySelector('img').setAttribute('src', this.getAttribute('image'));
    content.querySelector('.container>.name').innerText = this.getAttribute('name');
    content.querySelector('.container>.email').innerText = this.getAttribute('email');

    shadow.appendChild(content);
  }
}
// 使用浏览器原生的customElements.define()方法告诉浏览器user-card元素与这个类关联
window.customElements.define('user-card', UserCard);

</script>

</textarea>
</div>

<div id="ts">
<h3>typescript online: https://www.typescriptlang.org/play/</h3><pre>
安装TypeScript有两种主要的方式来获取TypeScript工具：
通过npm: npm install -g typescript
安装Visual Studio的TypeScript插件

tsc greeter.ts  // 输出结果为一个greeter.js文件

TypeScript里的类型注解是一种轻量级的为函数或变量添加约束的方式
TypeScript提供了静态的代码分析,它可以分析代码结构和提供的类型注解。
尽管有错误,greeter.js文件还是被创建了,就算代码里有错误,仍然可以使用TypeScript。但在这种情况下TypeScript会警告代码可能不会按预期执行

基本类型和扩展类型
Typescript与Javascript共享相同的基本类型,但有一些额外的类型: 元组Tuple、枚举enum、Any、never、object与Void

let u: undefined = undefined
let n: null = null
let isDone: boolean = false;

// 数字,二、八、十六进制都支持
let decLiteral: number = 6;
let hexLiteral: number = 0xf00d;
let binaryLiteral: number = 0b1010;
let octalLiteral: number = 0o744;

// 字符串,单双引号都行
let name: string = 'bob';
let sentence: string = `hello, my name is ${ name }`;

// 数组
let list: number[] = [1,2,3];       // 在元素类型后面接上[],表示由此类型元素组成的一个数组
let list: Array<number> = [1,2,3];  // 使用数组泛型,Array<元素类型>

【 元组 】
元组类型允许表示一个已知元素数量和类型的数组,各元素的类型不必相同

定义一对值分别为string和number类型的元组。
let x: [string, number];  // Declare a tuple type
x = ['hello', 10];   // Initialize it OK
x = [10, 'hello']; // Initialize it incorrectly Error

当访问一个已知索引的元素,会得到正确的类型：
console.log(x[0].substr(1)); // OK
console.log(x[1].substr(1)); // Error, 'number' does not have 'substr'

当访问一个越界的元素,会使用联合类型替代：
x[3] = 'world';  // OK, 字符串可以赋值给(string | number)类型
console.log(x[5].toString()); // OK, 'string' 和 'number' 都有 toString
x[6] = true;     // Error, 布尔不是(string | number)类型

元组Tuple作为有组织的数组,需要以正确的顺序预定义数据类型
const messyArray = [' something', 2, true, undefined, null];
const tuple: [number, string, string] = [24, "Indrek" , "Lasn"];

如果不遵循为元组预设排序的索引规则,那么Typescript会警告
let tuple: [number, string, string]
tuple = ["indrek", 24, "lash"]  // tuple第一项应为number类型

【 枚举 enum 】
enum类型是对JS标准数据类型的一个补充。像C#等其它语言一样,使用枚举类型可以为一组数值赋予友好的名字。

enum Color {Red, Green, Blue}
let c: Color = Color.Green;
console.log(c)  // 1

默认从0开始为元素编号,也可以手动的指定成员的数值,例如将上面的例子改成从1开始编号：
enum Color {Red = 1, Green, Blue}
let c: Color = Color.Green;

全部都采用手动赋值：
enum Color {Red = 1, Green = 2, Blue = 4}
let c: Color = Color.Green;

枚举类型提供的一个便利是可以由枚举的值得到它的名字,例如知道数值为2,但不确定它映射到Color里的哪个名字,可以查找相应的名字
let colorName: string = Color[2];
console.log(colorName); // 输出'Green'因为上面代码里它的值是2

另一个很好的例子是使用枚举来存储应用程序状态
enum AppStates { hasErrors, isFetching, isUserLoggedIn, doesUserHaveProfileImage }

【 Any 】
有时想要为那些在编程阶段还不清楚类型的变量指定一个类型,这些值可能来自于动态的内容,比如来自用户输入或接入第三方代码库,这种情况下不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查,那么可以使用any类型来标记这些变量
就是什么类型都行,当无法确认在处理什么类型时可以用这个。但要慎重使用,用多了就失去使用Ts的意义。

let person: any = "前端攻城狮"
person = 25
person = true

let list: any[] = [1, true, "free"];
list[1] = 100;

【 Void 】
void类型与any类型相反,表示没有任何类型,当一个函数没有返回值时通常会见到其返回值类型是void

在Typescript中必须在函数中定义返回类型
function sayMyName(name: string): string {
  return name;
}

若没有返回值则会报错,可以将其返回值定义为void,此时将无法return
function myCallBack(name: string): void {
  console.log(name)
}

声明一个void类型的变量没有什么大用,因为你只能为它赋予undefined和null：
let unusable: void = undefined;

【 Never 】
never类型表示那些永不存在的值的类型,例如never类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型,变量也可能是never类型,当它们被永不为真的类型保护所约束时。

never类型是任何类型的子类型,也可以赋值给任何类型；然而,没有类型是never的子类型或可以赋值给never类型(除了never本身之外)。 即使 any也不可以赋值给never。

// 返回never的函数必须存在无法达到的终点
function error(message: string): never {
  throw new Error(message);
}
const showError = () => error('generic error message')
showError()

// 推断的返回值类型为never
function fail() {
  return error("Something failed");
}

// 返回never的函数必须存在无法达到的终点
function infiniteLoop(): never {
  while (true) {
  }
}

【 Object 】
object表示非原始类型,即除number,string,boolean,symbol,null或undefined之外的类型。
使用object类型就可以更好的表示像Object.create这样的API

declare function create(o: object | null): void;

create({ prop: 0 }); // OK
create(null); // OK

create(42); // Error
create("string"); // Error
create(false); // Error
create(undefined); // Error

【 类型断言 type assertions 】
类型断言好比其它语言里的类型转换,但不进行特殊的数据检查和解构。 它没有运行时的影响,只是在编译阶段起作用。 TypeScript会假设程序员,已经进行了必须的检查。

可以用来手动指定一个值的类型。有两种写法,尖括号和as,在TypeScript里使用JSX时只有as语法断言是被允许的。

let someValue: any = "this is a string";
let strLength: number = (<string>someValue).length;
let strLength: number = (someValue as string).length;

使用例子有：
当TypeScript不确定一个联合类型的变量到底是哪个类型的时候,只能访问此联合类型的所有类型里共有的属性或方法：

function getLength(something: string | number): number {
 return something.length;
}
// index.ts(2,22): error TS2339: Property 'length' does not exist on type 'string | number'.
// Property 'length' does not exist on type 'number'.

如果访问长度将会报错,而有时候确实需要在还不确定类型的时候就访问其中一个类型的属性或方法,此时需要断言才不会报错：

function getLength(something: string | number): number {
  if ((<string>something).length) {
    return (<string>something).length;
  } else {
    return something.toString().length;
  }
}

【 函数 】
函数是JS应用程序的基础,它帮助实现抽象层、模拟类、信息隐藏和模块。在TS里虽然已经支持类、命名空间和模块,但函数仍然是主要的定义行为的地方。TypeScript为JavaScript函数添加了额外的功能

// Named function
function add(x, y) {
  return x + y;
}

// Anonymous function
let myAdd = function(x, y) { return x + y; };

// 给每个参数添加类型之后再为函数本身添加返回值类型,TypeScript能够根据返回语句自动推断出返回值类型,因此通常省略它
function add(x: number, y: number): number {
  return x + y;
}
let myAdd = function(x: number, y: number): number { return x + y; };

【 接口 】
TypeScript的核心原则之一是对值所具有的结构进行类型检查,在TypeScript里接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约

function printLabel(labelledObj: { label: string }) {
  console.log(labelledObj.label);
}
let myObj = { size: 10, label: "Size 10 Object" };
printLabel(myObj);

类型检查器会查看printLabel的调用,printLabel有一个参数,并要求这个对象参数有一个名为label类型为string的属性,传入的对象参数实际上会包含很多属性,但是编译器只会检查那些必需的属性是否存在,并且其类型是否匹配,然而有些时候TypeScript却并不会这么宽松

使用接口来描述：必须包含一个label属性且类型为string：
interface LabelledValue {
  label: string;
}

function printLabel(labelledObj: LabelledValue) {
  console.log(labelledObj.label);
}

let myObj = {size: 10, label: "Size 10 Object"};
printLabel(myObj);

在这里并不能像在其它语言里一样,说传给printLabel的对象实现了这个接口,只会去关注值的外形,只要传入的对象满足上面提到的必要条件,那么它就是被允许的。

还有一点值得提的是,类型检查器不会去检查属性的顺序,只要相应的属性存在并且类型也是对的就可以

可选属性
interface SquareConfig {
  color?: string;
  width?: number;
}

function createSquare(config: SquareConfig): {color: string; area: number} {
  let newSquare = {color: "white", area: 100};
  config.color && newSquare.color = config.color;
  config.width && newSquare.area = config.width * config.width;
  return newSquare;
}
let mySquare = createSquare({color: "black"});

只读属性
interface Point {
  readonly x: number;
  readonly y: number;
}
let p1: Point = { x: 10, y: 20 };
p1.x = 5;  // error!

TypeScript具有ReadonlyArray<T>类型,它与Array<T>相似,只是把所有可变方法去掉了,因此可以确保数组创建后再也不能被修改：
let a: number[] = [1, 2, 3, 4];
let ro: ReadonlyArray<number> = a;
ro[0] = 12;      // error!
ro.push(5);      // error!
ro.length = 100; // error!
a = ro;          // error! 就算把整个ReadonlyArray赋值到一个普通数组也是不可以的,但可以用类型断言重写a = ro as number[];

readonly vs const
最简单判断该用readonly还是const的方法是看要把它做为变量使用还是做为一个属性。 做为变量使用的话用const,若做为属性则使用readonly

函数类型
接口能够描述JavaScript中对象拥有的各种各样的外形。 除了描述带有属性的普通对象外,接口也可以描述函数类型。

为了使用接口表示函数类型,我们需要给接口定义一个调用签名。 它就像是一个只有参数列表和返回值类型的函数定义。参数列表里的每个参数都需要名字和类型。

interface SearchFunc {
  (source: string, subString: string): boolean;
}

这样定义后可以像使用其它接口一样使用这个函数类型的接口。 下例展示了如何创建一个函数类型的变量,并将一个同类型的函数赋值给这个变量。

let mySearch: SearchFunc;
mySearch = function(source: string, subString: string) {
  let result = source.search(subString);
  return result > -1;
}

对于函数类型的类型检查来说,函数的参数名不需要与接口里定义的名字相匹配。 比如,我们使用下面的代码重写上面的例子：

let mySearch: SearchFunc;
mySearch = function(src: string, sub: string): boolean {
  let result = src.search(sub);
  return result > -1;
}

函数的参数会逐个进行检查,要求对应位置上的参数类型是兼容的。 如果你不想指定类型,TypeScript的类型系统会推断出参数类型,因为函数直接赋值给了 SearchFunc类型变量。 函数的返回值类型是通过其返回值推断出来的(此例是 false和true)。 如果让这个函数返回数字或字符串,类型检查器会警告我们函数的返回值类型与 SearchFunc接口中的定义不匹配。

let mySearch: SearchFunc;
mySearch = function(src, sub) {
  let result = src.search(sub);
  return result > -1;
}

使用接口来描述一个拥有firstName和lastName字段的对象。 在TypeScript里只在两个类型内部的结构兼容那么这两个类型就是兼容的,这就允许在实现接口时候只要保证包含了接口要求的结构就可以,而不必明确地使用implements语句。

</pre><textarea>
interface Person {
  firstName: string;
  lastName: string;
}

function greeter(person: Person) {
  return "Hello, " + person.firstName + " " + person.lastName;
}

let user = { firstName: "Jane", lastName: "User" };

document.body.innerHTML = greeter(user);

</textarea>TypeScript支持JavaScript的新特性,比如支持基于类的面向对象编程<textarea>
class Student {
  fullName: string;
  constructor(public firstName, public middleInitial, public lastName) {  // 在构造函数的参数上使用public等同于创建了同名的成员变量
    this.fullName = firstName + " " + middleInitial + " " + lastName;
  }
}

interface Person {
  firstName: string;
  lastName: string;
}

function greeter(person : Person) {
  return "Hello, " + person.firstName + " " + person.lastName;
}

let user = new Student("Jane", "M.", "User");

document.body.innerHTML = greeter(user);

</textarea><pre>
【 泛型：Generics 】
软件工程的一个主要部分就是构建组件,构建的组件不仅需要具有明确的定义和统一的接口,同时也需要组件可复用。支持现有的数据类型和将来添加的数据类型的组件为大型软件系统的开发过程提供很好的灵活性。
在C#和Java中可以使用"泛型"来创建可复用的组件,并且组件可支持多种数据类型,这样便可以让用户根据自己的数据类型来使用组件。

创建第一个使用泛型的例子identity函数,这个函数会返回任何传入它的值

不用泛型的话,这个函数可能是下面这样：
function identity(arg: number): number {
  return arg;
}
或者使用any类型来定义函数：
function identity(arg: any): any {
  return arg;
}
使用any类型会导致这个函数可以接收任何类型的arg参数,这样就丢失了一些信息：传入的类型与返回的类型应该是相同的。如果传入一个数字,只知道任何类型的值都有可能被返回。

因此需要一种方法使返回值的类型与传入参数的类型是相同的,这里使用了类型变量,它是一种特殊的变量,只用于表示类型而不是值。
function identity<T>(arg: T): T {
  return arg;
}

给identity添加了类型变量T,T帮助捕获用户传入的类型如number,之后就可以使用这个类型,之后再次使用了T当做返回值类型。现在可以知道参数类型与返回值类型是相同的了,这允许我跟踪函数里使用的类型的信息。
把这个版本的identity函数叫做泛型,因为它可以适用于多个类型。 不同于使用any,它不会丢失信息,像第一个例子那像保持准确性,传入数值类型并返回数值类型。

定义了泛型函数后可以用两种方法使用
第一种是传入所有的参数,包含类型参数：
let output = identity<string>("myString");  // type of output will be 'string'
这里明确的指定了T是string类型,并做为一个参数传给函数,使用了<>括起来而不是()。

第二种方法更普遍,利用了类型推论 -- 即编译器会根据传入的参数自动地帮助确定T的类型：
let output = identity("myString");  // type of output will be 'string'
没必要使用尖括号(<>)来明确地传入类型；编译器可以查看myString的值,然后把T设置为它的类型。 类型推论帮助保持代码精简和高可读性。如果编译器不能够自动地推断出类型的话,只能像上面那样明确的传入T的类型,在一些复杂的情况下,这是可能出现的。

使用泛型变量
使用泛型创建像identity这样的泛型函数时,编译器要求你函数体必须正确的使用这个通用的类型,必须把这些参数当做是任意或所有类型。

想同时打印出arg的长度,很可能会这样做：
function loggingIdentity<T>(arg: T): T {
  console.log(arg.length);  // Error: T doesn't have .length
  return arg;
}
如果这么做,编译器会报错说使用了arg的.length属性,但没有地方指明arg具有这个属性。这些类型变量代表的是任意类型,所以使用这个函数的人可能传入的是个数字,而数字是没有.length属性的。

现在假设我们想操作T类型的数组而不直接是T,由于操作的是数组,所以.length属性是应该存在的,可以像创建其它数组一样创建这个数组：

function loggingIdentity<T>(arg: T[]): T[] {
  console.log(arg.length);  // Array has a .length, so no more error
  return arg;
}

泛型函数loggingIdentity接收类型参数T和参数arg,它是个元素类型是T的数组,并返回元素类型是T的数组。如果传入数字数组,将返回一个数字数组,因为此时T的的类型为number。这可以把泛型变量T当做类型的一部分使用,而不是整个类型,增加了灵活性。

也可以这样实现上面的例子：
function loggingIdentity<T>(arg: Array<T>): Array<T> {
  console.log(arg.length);  // Array has a .length, so no more error
  return arg;
}

创建泛型接口
interface GenericIdentityFn {
  <T>(arg: T): T;
}

function identity<T>(arg: T): T {
  return arg;
}

let myIdentity: GenericIdentityFn = identity;
一个相似的例子,可能想把泛型参数当作整个接口的一个参数,这样就能清楚的知道使用的具体是哪个泛型类型(比如Dictionary<string>而不只是Dictionary),这样接口里的其它成员也能知道这个参数的类型了。

interface GenericIdentityFn<T> {
  (arg: T): T;
}

function identity<T>(arg: T): T {
  return arg;
}

let myIdentity: GenericIdentityFn<number> = identity;

泛型类
泛型类看上去与泛型接口差不多,泛型类使用( <>)括起泛型类型,跟在类名后面

class GenericNumber<T> {
  zeroValue: T;
  add: (x: T, y: T) => T;
}
let myGenericNumber = new GenericNumber<number>();
myGenericNumber.zeroValue = 0;
myGenericNumber.add = function(x, y) { return x + y; };

1. 泛型方法
在TypeScript里声明泛型方法有以下两种方式：

function gen_func1<T>(arg: T): T {
 return arg;
}
// 或者
let gen_func2: <T>(arg: T) => T = function (arg) {
 return arg;
}

调用方式也有两种：
gen_func1<string>('Hello world');
gen_func2('Hello world');   // 第二种调用方式可省略类型参数,因为编译器会根据传入参数来自动识别对应的类型。

2. 泛型与Any
Ts的特殊类型Any在具体使用时可以代替任意类型,咋一看两者好像没啥区别,其实不然：

// 方法一：带有any参数的方法,因为any可以代替任意类型,所以该方法在传入参数不是数组或带有length属性对象时会抛出异常
function any_func(arg: any): any {
  console.log(arg.length);
  return arg;
}
// 方法二：Array泛型方法,定义了参数类型是Array的泛型类型,肯定会有length属性,所以不会抛出异常
function array_func<T>(arg: Array<T>): Array<T> {
  console.log(arg.length);
  return arg;
}

3. 泛型类型
泛型接口：
interface Generics_interface<T> {
 (arg: T): T;
}
 
function func_demo<T>(arg: T): T {
 return arg;
}
let func1: Generics_interface<number> = func_demo;
func1(123);   // 正确类型的实际参数
func1('123'); // 错误类型的实际参数

自定义类型：Interface vs Type alias
Interface,国内翻译成接口。
Type alias,类型别名。

1、相同点
1.1、都可以用来描述一个对象或函数：

interface User {
 name: string
 age: number
}
type User = {
 name: string
 age: number
};
interface SetUser {
 (name: string, age: number): void;
}
type SetUser = (name: string, age: number): void;

1.2、都允许拓展(extends)：
interface和type都可以拓展,并且两者并不是相互独立的,也就是说interface可以extends type, type也可以extends interface,虽然效果差不多,但是两者语法不同。

// interface extends interface
interface Name { 
 name: string; 
}
interface User extends Name { 
 age: number; 
}

// type extends type
type Name = { 
 name: string; 
}
type User = Name & { age: number };

// interface extends type
type Name = { 
 name: string; 
}
interface User extends Name { 
 age: number; 
}

// type extends interface
interface Name { 
 name: string; 
}
type User = Name & { 
 age: number; 
}

2、不同点
2.1、type可以而interface不行

2.1.1、type可以声明基本类型别名,联合类型,元组等类型
// 基本类型别名
type Name = string
// 联合类型
interface Dog {
 wong();
}
interface Cat {
 miao();
}
type Pet = Dog | Cat
// 具体定义数组每个位置的类型
type PetList = [Dog, Pet]

2.1.2、type语句中还可以使用typeof获取实例的类型进行赋值
// 想获取一个变量的类型时使用typeof
let div = document.createElement('div');
type B = typeof div

其他骚操作
type StringOrNumber = string | number; 
type Text = string | { text: string }; 
type NameLookup = Dictionary<string, Person>; 
type Callback<T> = (data: T) => void; 
type Pair<T> = [T, T]; 
type Coordinates = Pair<number>; 
type Tree<T> = T | { left: Tree<T>, right: Tree<T> };

2.2、interface可以而type不行
2.2.1、interface能够声明合并

interface User {
  name: string
  age: number
}
interface User {
  sex: string
}
/*
User 接口为 {
  name: string
  age: number
  sex: string 
}
*/

2.2.2、interface有可选属性和只读属性

可选属性
接口里的属性不全都是必需的。有些是只在某些条件下存在,或者根本不存在。例如给函数传入的参数对象中只有部分属性赋值了。带有可选属性的接口与普通的接口定义差不多,只是在可选属性名字定义的后面加一个?符号。如下所示
interface Person {
 name: string;
 age?: number;
 gender?: number;
}

只读属性
这个属性是不可写的,对象属性只能在对象刚刚创建的时候修改其值,可以在属性名前用readonly来指定只读属性
interface User {
 readonly loginName: string;
 password: string;
}
上面的例子说明,当完成User对象的初始化后loginName就不可以修改了。

【 实现与继承：implements vs extends 】
extends是ES6里面的类继承,implement,实现。与C#或Java里接口的基本作用一样,TypeScript也能够用它来明确的强制一个类去符合某种契约

// implement基本用法：
interface IDeveloper {
 name: string;
 age?: number;
}
// OK
class dev implements IDeveloper {
 name = 'Alex';
 age = 20;
}
// OK
class dev2 implements IDeveloper {
 name = 'Alex';
}
// Error
class dev3 implements IDeveloper {
 name = 'Alex';
 age = '9';
}

而extends是继承父类,两者其实可以混着用：
class A extends B implements C,D,E

【 声明文件与命名空间：declare 和 namespace 】

</pre><textarea>
// shims-tsx.d.ts
import Vue, { VNode } from 'vue';
declare global {
  namespace JSX {
    // tslint:disable no-empty-interface
    interface Element extends VNode {}
    // tslint:disable no-empty-interface
    interface ElementClass extends Vue {}
    interface IntrinsicElements {
      [elem: string]: any;
    }
  }
}
// shims-vue.d.ts
declare module '*.vue' {
  import Vue from 'vue';
  export default Vue;
}

</textarea><pre>
declare：当使用第三方库时需要引用它的声明文件,才能获得对应的代码补全、接口提示等功能。

列举几个常用的：
declare var 声明全局变量
declare function 声明全局方法
declare class 声明全局类
declare enum 声明全局枚举类型
declare global 扩展全局变量
declare module 扩展模块
namespace：“内部模块”现在称做“命名空间”。module X { 相当于现在推荐的写法 namespace X {}

【 访问修饰符：private、public、protected 】
默认为public
当成员被标记为private时,它就不能在声明它的类的外部访问
protected和private类似,但是,protected成员在派生类中可以访问

</pre><textarea>
class Animal {
  private name: string;
  constructor(theName: string) {
    this.name = theName;
  }
}
let a = new Animal('Cat').name; //错误,‘name’是私有的

class Animal {
  protected name: string;
  constructor(theName: string) {
    this.name = theName;
  }
}
class Rhino extends Animal {
  constructor() {
    super('Rhino');
  }
  getName() {
    console.log(this.name) // 此处的name就是Animal类中的name
  }
}

</textarea><pre>
【 可选参数 ( ?: ) 】
function buildName(firstName: string, lastName?: string) {
  return firstName + ' ' + lastName
}
buildName("firstName", "lastName", "lastName")  // 错误演示
buildName("firstName")  // 正确演示
buildName("firstName", "lastName")  // 正确演示

【 非空断言操作符(!.) 】
能确定变量值一定不为空时使用。与可选参数 不同的是,非空断言操作符不会防止出现 null 或 undefined。
let s = e!.name; // 断言e是非空并访问name属性

</pre>
</div>

<div id="rn">
<h3>移动端 react native</h3><pre>
ReactNative可以基于目前大热的开源JavaScript库React.js来开发iOS和Android原生App。而且React Native已经用于生产环境——Facebook Groups iOS 应用就是基于它开发的
React Native的原理是在JavaScript中用React抽象操作系统原生的UI组件，代替DOM元素来渲染，比如以View取代div，以Image替代img等。
在幕后，React Native在主线程之外，在另一个背景线程里运行JavaScript引擎，两个线程之间通过一批量化的async消息协议来通信（有一个专门的React插件）。
UI方面React Native提供跨平台的类似Flexbox的布局系统，还支持CSS子集。可以用JSX或普通JS语言，还有CoffeeScript和TypeScript来开发
更好的是，由于基于Web技术，开发起来可以像在浏览器里那样随时在仿真程序中查看应用运行情况，刷新一下就行，无需编译，爽吧。
  
React Native比起标准Web开发或原生开发能够带来的三大好处：
手势识别：基于Web技术（HTML5/JavaScript）构建的移动应用经常被抱怨缺乏及时响应。而基于原生UI的React Native能避免这些问题从而实现实时响应。
原生组件：使用HTML5/JavaScript实现的组件比起原生组件总是让人感觉差一截，而React Native由于采用了原生UI组件自然没有此问题。
样式和布局：iOS、Android和基于Web的应用各自有不同的样式和布局机制。React Native通过一个基于FlexBox的布局引擎在所有移动平台上实现了一致的跨平台样式和布局方案。

安卓模拟器调出 Dev Setting: adb shell input keyevent 82
yarn react-native start

<h4>taro rn</h4>
Taro移动端的开发基于Facebook的开源项目React Native,目前是项目依赖中固定React Native版本为0.55.4

$ yarn dev:rn
$ npm run dev:rn
$ taro build --type rn --watch
$ npx taro build --type rn --watch
将Taro代码编译为React Native代码（默认输出在rn_temp目录下）,并启动Metro Server（可以看成是webpack run devserver --port 8081）打包rn_temp下的js。
然后进入taro-native-shell目录（建议和Taro项目平级）,通过react-native run-android|ios启动,或者通过对应的Android Studio/Xcode启动应用,启动后应用可以看成是一个浏览器,会从8081端口加载js并渲染

React Native端必须采用Flex布局,并且样式选择器仅支持类选择器,且不支持组合器,不支持伪类及伪元素
样式上H5最为灵活,小程序次之,RN弱,统一多端样式即是对齐短板,也就是要以RN的约束来管理样式,同时兼顾小程序的限制,核心可以用三点来概括：
使用Flex布局、基于BEM写样式、采用style属性覆盖组件样式
RN中View标签默认主轴方向是column,如果不将其他端改成与RN一致,就需要在所有用到display: flex的地方都显式声明主轴方向
flex在RN中只能为整数值
Taro使用PostCSS单位转换插件postcss-pxtransform会将px转换为React Native的pt
在reactNative写样式的时候宽、高padding等值不能是字符串,改成数字即可,marginLeft: Taro.pxTransform(50), width: Taro.pxTransform(80)

样式的条件编译
假设目录中同时存在index.scss和index.rn.scss,当在JS文件中引用样式文件：import './index.scss'时,RN平台会找到并引入index.rn.scss,其他平台会引入index.scss,方便大家书写跨端样式,更好地兼容RN

样式代码的条件编译
为了方便大家书写样式跨端的样式代码,添加了样式条件编译的特性,多个平台之间可以使用空格隔开

指定平台保留：
/*  #ifdef  %PLATFORM%  */
样式代码
/*  #endif  */

指定平台剔除：
/*  #ifndef  %PLATFORM%  */
样式代码
/*  #endif  */

内置环境变量
process.env.TARO_ENV用于判断当前编译类型,目前有weapp / swan / alipay / h5 / rn / tt / qq / quickapp 八个取值,可以通过这个变量来书写对应一些不同环境下的代码,在编译时会将不属于当前编译类型的代码去掉,只保留当前编译类型下的代码,例如想在微信小程序和 H5 端分别引用不同资源
if (process.env.TARO_ENV === 'weapp') {
  require('path/to/weapp/name')
} else if (process.env.TARO_ENV === 'h5') {
  require('path/to/h5/name')
}
同时也可以在JSX中使用,决定不同端要加载的组件
render () {
  return (
    < View>
      {process.env.TARO_ENV === 'weapp' && < ScrollViewWeapp />}
      {process.env.TARO_ENV === 'h5' && < ScrollViewH5 />}
    < /View>
  )
}

config: Config = {
  "pages": preval`
    module.exports=(function() {
      if (process.env.TARO_ENV === 'weapp') {
        return [ '/pages/index/index' ]
      }
      if (process.env.TARO_ENV === 'swan') {
        return [ '/pages/indexswan/indexswan' ]
      }
    })()
  `
}

文字要包在Text组件里面,否则不显示。
Error: Unexpected token type: word Failed to parse declaration "transform: translate(-50%, -50%)"
input{ flex: 1; padding: 0; }
伪类选择器、组合选择器会被react native忽略
border-top-style、white-space、text-overflow无效
400 700 normal bold之外的fontweight在android上的react native无效
position:fixed React Native不支持
Animation和transform React Native动画不支持
React Native与H5小程序的Flex布局相关属性的默认值有差异
box-shadow支持得并不好,仅ios支持且支持程度有限
CSS属性简写Shorthands:仅接受React Native支持的值。例如background只接受一种颜色backgroundColor,因为React Native的Background仅支持backgroundColor属性
border{Top,Right,Bottom,Left}不支持,因为borderStyle不能应用于单个边框,不支持针对某一边设置style,即border-bottom-style会报错
那么border-bottom: 1px就需要写成如下形式：border: 0 style color; border-bottom-width: 1px;
# 使用sass
@mixin border($dir, $width, $style, $color) {
  border: 0 $style $color;
  @each $d in $dir {
    #{border-#{$d}-width}: $width;
  }
}
React Native不支持background-image,使用Image组件,配合Flex布局,基本可以实现大部分需求

</pre>
</div>

</main>

<ol>
  <li><a href="#top">顶部</a></li>
  <li><a href="#taro">taro</a></li>
  <li><a href="#react">react</a></li>
  <li><a href="#jsx">jsx</a></li>
  <li><a href="#element">element</a></li>
  <li><a href="#component_props">component_props</a></li>
  <li><a href="#props_children">props_children</a></li>
  <li><a href="#ref">ref</a></li>
  <li><a href="#state_lifecycle">state_lifecycle</a></li>
  <li><a href="#event">event</a></li>
  <li><a href="#render">render</a></li>
  <li><a href="#list">list</a></li>
  <li><a href="#form">form</a></li>
  <li><a href="#lifting_state_up">状态提升</a></li>
  <li><a href="#context">context</a></li>
  <li><a href="#error">error</a></li>
  <li><a href="#hoc">hoc</a></li>
  <li><a href="#render_props">render_props</a></li>
  <li><a href="#fragments">fragments</a></li>
  <li><a href="#hook">hook</a></li>
  <li><a href="#code_splite">code_splite</a></li>
  <li>
    <a href="#redux">redux ▼</a>
    <ul>
      <li><a href="#redux_middleware_async">middleware_async</a></li>
      <li><a href="#react_redux">react_redux</a></li>
      <li><a href="#dva">dva</a></li>
    </ul>
  </li>
  <li>
    <a href="#react-router">react-router ▼</a>
    <ul>
      <li><a href="#router_routers">routers</a></li>
      <li><a href="#router_navigation">navigation</a></li>
      <li><a href="#router_route">route</a></li>
      <li><a href="#router_hook">hook</a></li>
      <li><a href="#router_ssr">ssr</a></li>
    </ul>
  </li>
  <li><a href="#Web_Components">Web Components</a></li>
  <li><a href="#ts">ts</a></li>
  <li><a href="#rn">react native</a></li>
  <li>
    <a href="#todo">todo ▼</a>
    <ul>
      <li><a href="#todo">todo</a></li>
      <li><a href="#todo">todo</a></li>
    </ul>
  </li>
</ol>

<script src="vendors/jquery-3.3.1.min.js"></script>
<script src="vendors/public.js"></script>
</body>
</html>