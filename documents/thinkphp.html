<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>ThinkPHP</title>
<link href="vendors/public.css" rel="stylesheet" type="text/css">
<link rel="stylesheet" href="vendors/SyntaxHighlighter/shCoreDefault.css"/>
</head>
<body>
<a name="top"></a>
<h1>THINKPHP <small>百度传课职坐标,W3C</small></h1>
<main>
<nav>
	<ul>
		<li class="home">
	      <a href="#" onclick="location = location.hostname == 'localhost' ? '../' : './';return false;">STUDY</a>
	    </li>
		<li class="it"><a href="javascript:;">ThinkPHP</a></li>
	</ul>
</nav>

<p><b><a href="https://www.kancloud.cn/manual/thinkphp5/118003" target="_blank">thinkphp5.0开发手册</a></b></p>

<h2>Thinkphp v5.0.20</h2><pre>
【 常用常量 】
查看已部署的thinkphp版本：echo THINK_VERSION;

define('THINK_VERSION', '5.0.9');
define('DS', DIRECTORY_SEPARATOR);
defined('THINK_PATH') or define('THINK_PATH', __DIR__ . DS);
defined('APP_PATH') or define('APP_PATH', dirname($_SERVER['SCRIPT_FILENAME']) . DS);
defined('ROOT_PATH') or define('ROOT_PATH', dirname(realpath(APP_PATH)) . DS);
defined('VENDOR_PATH') or define('VENDOR_PATH', ROOT_PATH . 'vendor' . DS);

tp5             项目根目录        ROOT_PATH
tp5/application 应用目录          APP_PATH
tp5/thinkphp    框架核心目录      THINK_PATH
tp5/exend       应用扩展目录      EXTEND_PATH
tp5/vendor      Composer扩展目录  VENDOR_PATH

【 助手函数helper 】
abort       中断执行并发送HTTP状态码
action      调用控制器类的操作
cache       缓存管理
config      获取和设置配置参数
controller  实例化控制器
cookie      Cookie管理
db          实例化数据库类
debug       调试时间和内存占用
dump        浏览器友好的变量输出
exception   抛出异常处理
halt        变量调试输出并中断执行
import      导入所需的类库
input       获取输入数据,支持默认值和过滤
json        JSON数据输出
jsonp       JSONP数据输出
lang        获取语言变量值
load_trait  快速导入Traits PHP5.5以上无需调用
model       实例化Model
redirect    重定向输出
request     实例化Request对象
response    实例化Response对象
session     Session管理
trace       记录日志信息
token       生成表单令牌输出
url         Url生成
validate    实例化验证器
vendor      快速导入第三方框架类库
view        渲染模板输出
widget      渲染输出Widget
xml         XML数据输出

【 命名规范 】
ThinkPHP5遵循PSR-2命名规范和PSR-4自动加载规范,并且注意如下规范：

目录和文件
目录使用小写+下划线;
类库、函数文件统一以.php为后缀;
类的文件名均以命名空间定义,并且命名空间的路径和类库文件所在路径一致;
类文件采用驼峰法命名(首字母大写),其它文件采用小写+下划线命名;
类名和类文件名保持一致,统一采用驼峰法命名(首字母大写);

函数和类、属性命名
类的命名采用驼峰法(首字母大写),例如 User、UserType,默认不需要添加后缀,例如UserController应该直接命名为User;
函数的命名使用小写字母和下划线(小写字母开头)的方式,例如 get_client_ip;
方法的命名使用驼峰法(首字母小写),例如 getUserName;
属性的命名使用驼峰法(首字母小写),例如 tableName、instance;
以双下划线“__”打头的函数或方法作为魔术方法,例如 __call 和 __autoload;

常量和配置
常量以大写字母和下划线命名,例如 APP_PATH和 THINK_PATH;
配置参数以小写字母和下划线命名,例如 url_route_on 和url_convert;

数据表和字段
数据表和字段采用小写加下划线方式命名,字段名不要以下划线开头,例如think_user表和user_name字段,不建议使用驼峰和中文作为数据表字段命名。

应用类库命名空间规范
应用类库的根命名空间统一为app(不建议更改,可以设置app_namespace配置参数更改,V5.0.8版本开始使用APP_NAMESPACE常量定义);
例如：app\index\controller\Index和app\index\model\User。

请避免使用PHP保留字(http://php.net/manual/zh/reserved.keywords.php )作为常量、类名和方法名及命名空间的命名,否则会造成系统错误。

【 目录结构 】
project  应用部署目录
├─application           应用目录(可设置)
│  ├─common             公共模块目录(可更改),默认是禁止直接访问的,一般用于放置一些公共的类库用于其他模块的继承
│  ├─index              模块目录(可更改)
│  │  ├─config.php      模块配置文件
│  │  ├─common.php      模块函数文件
│  │  ├─controller      控制器目录
│  │  ├─model           模型目录
│  │  ├─view            视图目录
│  │  └─ ...            更多类库目录
│  ├─command.php        命令行工具配置文件
│  ├─common.php         应用公共(函数)文件
│  ├─config.php         应用(公共)配置文件
│  ├─database.php       数据库配置文件
│  ├─tags.php           应用行为扩展定义文件
│  └─route.php          路由配置文件
├─extend                扩展类库目录(可定义)
├─public                WEB部署目录(对外访问目录)
│  ├─static             静态资源存放目录(css,js,image)
│  ├─index.php          应用入口文件
│  ├─router.php         快速测试文件,用于php自带webserver支持,切换到public目录后php -S localhost:8888 router.php
│  └─.htaccess          用于apache的重写
├─runtime               应用的运行时目录(可写,可设置),mac或linux环境须确保runtime目录有可写权限
├─vendor                第三方类库目录(Composer)
├─thinkphp              框架系统目录
│  ├─lang               语言包目录
│  ├─library            框架核心类库目录
│  │  ├─think           Think类库包目录
│  │  └─traits          系统Traits目录
│  ├─tpl                系统模板目录
│  ├─.htaccess          用于apache的重写
│  ├─.travis.yml        CI定义文件
│  ├─base.php           基础定义文件
│  ├─composer.json      composer定义文件
│  ├─console.php        控制台入口文件
│  ├─convention.php     惯例配置文件
│  ├─helper.php         助手函数文件(可选)
│  ├─LICENSE.txt        授权说明文件
│  ├─phpunit.xml        单元测试配置文件
│  ├─README.md          README 文件
│  └─start.php          框架引导文件
├─build.php             自动生成定义文件(参考)
├─composer.json         composer定义文件
├─LICENSE.txt           授权说明文件
├─README.md             README文件
├─think                 命令行入口文件

目录结构和名称是可以改变的,尤其是应用的目录结构,这取决于入口文件和配置参数。
由于TP5.0的架构设计对模块的目录结构保留了很多的灵活性,尤其是对于用于存储的目录具有高度的定制化,因此上述的目录结构仅供建议参考。

</pre>
</div>

<div id="framework">
<h2>框架</h2><pre>
框架是程序结构代码的集合,而不是业务逻辑代码。集合中包含了很多类、函数和功能类包,按照一定的标准组成的功能体系,体系有很多设计模式如MVC

MVC设计模式
强制性的使应用程序的输入、处理、输出分开,三个核心部件各自处理自己的任务
model模型:处理数据和业务逻辑,数据库操作模型(类)
view视图:通过布局向用户展示数据,模板页面
controller控制器:接收用户请求,并调用相应的模型处理

传统设计模式 model -> view
mvc设计模式 model <-> controller <-> view
model类,view类,controller类,入口文件引入MVC文件,然后根据get参数来判断使用的controller和方法

TP5.0应用基于MVC(模型-视图-控制器)的方式来组织。
视图是用户看到并与之交互的界面,视图一般是由HTML元素组成的页面,TP中的View文件夹。
模型是操作数据库数据与执行业务逻辑的容器,模型返回的数据格式是固定的,它为多个视图提供数据,被多个视图重用,减少代码的重复性,TP中的Model文件夹。
控制器是接受用户的输入然后去调用模型、渲染视图完成用户需求,通常控制器只接收请求并决定调用哪个模型方法处理请求然后选择哪个视图来渲染数据,TP中的Controller文件夹。

</pre><img src="image/mvc.png"/><pre>
5.0的URL访问受路由决定,如果关闭路由或没有匹配路由的情况下则是基于：
http://serverName/index.php/模块/控制器/操作/参数/值…

【 入口文件 】
用户请求的PHP文件,负责处理一个请求的生命周期,最常见的入口文件就是index.php,有时候也会为了某些特殊的需求而增加新的入口文件,例如给后台模块单独设置的一个入口文件admin.php或一个控制器程序入口think

单一入口框架
在一个网站中所有的请求都是指向一个脚本文件,结构更规范、安全,控制更灵活
单一入口文件使控制器下的方法都是相对于index.php文件所在的目录,所以创建目录时没有设置前缀的话都是在index.php所在的目录
$dir="Data/Qrcode/".$time .'/'. $com;
if(!file_exists($dir)){
    mkdir($dir,0777,true);
}

【 应用 】
应用在ThinkPHP中是一个管理系统架构及生命周期的对象,由系统的\think\App类完成,应用通常在入口文件中被调用和执行,具有相同的应用目录(APP_PATH)的应用被认为是同一个应用,但一个应用可能存在多个入口文件。
应用具有自己独立的配置文件、公共(函数)文件。

【 模块 】
一个典型的应用是由多个模块组成的,默认采用多模块的支持,这些模块通常都是应用目录下面的一个子目录,每个模块都有自己独立的配置文件、公共文件和类库文件。
tp5.0支持单一模块架构设计,如果应用下面只有一个模块,那么这个模块的子目录可以省略,并且在应用配置文件中修改：
'app_multi_module' => false,

调整应用目录的结构为如下：
├─application        应用目录(可设置)
│  ├─controller      控制器目录
│  ├─model           模型目录
│  ├─view            视图目录
│  ├─ ...            更多类库目录
│  ├─common.php      函数文件
│  ├─route.php       路由配置文件
│  ├─database.php    数据库配置文件
│  └─config.php      配置文件

如果只有一个模块的话可以进行模块绑定,方法是应用的入口文件中添加如下代码：
// 绑定当前访问到index模块
define('BIND_MODULE','index');
绑定后URL访问地址则变成：
http://serverName/index.php/控制器/操作/[参数名/参数值...]
访问的模块是index模块。

同时单一模块设计下的应用类库的命名空间也有所调整
app\index\controller\Index -> app\controller\Index
app\index\model\User -> app\model\User
更多的URL简化和定制还可以通过URL路由功能实现。

如果应用比较简单,模块和控制器都只有一个,那么可以在应用公共文件中绑定模块和控制器
// 绑定当前访问到index模块的index控制器
define('BIND_MODULE','index/index');
设置后URL访问地址则变成：
http://serverName/index.php/操作/[参数名/参数值...]
访问的模块是index模块,控制器是Index控制器。

所有模块的命名空间均以app作为根命名空间(可配置更改),以app\模块名开头
// index模块的Index控制器类
app\index\controller\Index
// index模块的User模型类
app\index\model\User

其中app可以通过定义的方式更改,例如在应用配置文件中修改：
'app_namespace' => 'application',
那么index模块的类库命名空间则变成：
application\index\controller\Index
application\index\model\User

【 控制器 】
每个模块拥有独立的MVC类库及配置文件,一个模块下面有多个控制器负责响应请求,而每个控制器其实就是一个独立的控制器类。
控制器主要负责请求的接收,并调用相关的模型处理,最终通过视图输出,严格来说控制器不应该过多的介入业务逻辑处理。
事实上5.0中控制器是可以被跳过的,通过路由可以直接把请求调度到某个模型或其他的类进行处理。
5.0的控制器类比较灵活,可以无需继承任何基础类库。

一个典型的Index控制器类如下：
namespace app\index\controller;

class Index{
    public function index(){
        return 'hello,thinkphp!';
    }
}

【 操作 】
一个控制器包含多个操作(方法),操作方法是一个URL访问的最小单元。
操作方法可以不使用任何参数,如果定义了一个非可选参数则该参数必须通过用户请求传入,如果是URL请求则通常是$_GET或$_POST方式传入

下面是一个典型的Index控制器的操作方法定义,包含了两个操作方法：
namespace app\index\controller;

class Index{
    public function index(){
        return 'index';
    }

    public function hello($name){
        return 'Hello,'.$name;
    }
}

【 模型 】
模型类通常完成实际的业务逻辑和数据封装,并返回和格式无关的数据。
模型类并不一定要访问数据库,而且在5.0的架构设计中只有进行实际的数据库查询操作时才会进行数据库的连接,是真正的惰性连接。
TP的模型层支持多层设计,可以对模型层进行更细化的设计和分工,例如把模型层分为逻辑层/服务层/事件层等

【 视图 】
控制器调用模型类后返回的数据通过视图组装成不同格式的输出。视图根据不同的需求来决定调用模板引擎进行内容解析后输出还是直接输出
视图通常会有一系列的模板文件对应不同的控制器和操作方法,并且支持动态设置模板目录。

【 驱动 】
系统很多的组件都采用驱动式设计,从而可以更灵活的扩展,驱动类的位置默认是放入核心类库目录下面,也可以重新定义驱动类库的命名空间而改变驱动的文件位置。

【 行为 】
行为(Behavior)是在预先定义好的一个应用位置执行的一些操作,所以行为通常是和某个位置相关,行为的执行时间依赖于绑定到了哪个位置上。

要执行行为,首先要在应用程序中进行行为侦听：
// 在app_init位置侦听行为
\think\Hook::listen('app_init');

然后对某个位置进行行为绑定,一个位置上如果绑定了多个行为的,按照绑定的顺序依次执行,除非遇到中断。
// 绑定行为到app_init位置
\think\Hook::add('app_init','\app\index\behavior\Test');

【 命名空间 】
TP5采用PHP的命名空间进行类库文件的设计和规划,并且符合PSR-4的自动加载规范
TP5采用命名空间方式定义和自动加载类库文件,有效的解决了多模块和Composer类库之间的命名空间冲突问题,并且实现了更加高效的类库自动加载机制

命名空间：相同的类名,函数名,const定义的常量;对define定义的同名常量无效
namespace app\index\controller;
use name1;              //引入命名空间,调用空间的元素时仍然需要加命名空间
use \think\Controller;  //引入命名空间的类,调用类属性和方法时不再需要加命名空间,可直接使用,完全限定名称访问命名空间方式,相对于绝对路径,从根目录开始
class Index extends \think\Controller{  };

namespace前不能有任何实际的内容
header("content-type:text/html;charset=utf-8");

没有指定命名空间即公共空间,会首先访问当前命名空间,如果要访问公共空间前面加\即根目录
当前命名空间没有的元素会自动去公共空间查找,公共空间的优先级最低

如果需要调用PHP内置的类库或第三方没有使用命名空间的类库,记得在实例化类库的时候加上\
// 错误的用法
$class = new stdClass();
$xml  =  new SimpleXmlElement($xmlstr);
// 正确的用法
$class = new \stdClass();
$xml  =  new \SimpleXmlElement($xmlstr);

在TP5.0中只需要给类库正确定义所在的命名空间,并且命名空间的路径与类库文件的目录一致,那么就可以实现类的自动加载,从而实现真正的惰性加载。
例如\think\cache\driver\File类的定义为：
namespace think\cache\driver;
class File{ }
如果实例化该类的话应该是：
$class = new \think\cache\driver\File();
系统会自动加载该类对应路径的类文件,其所在的路径是thinkphp/library/think/cache/driver/File.php

根命名空间(类库包)
根命名空间是一个关键的概念,以\think\cache\driver\File类为例,think就是一个根命名空间,其对应的初始命名空间目录就是系统的类库目录(thinkphp/library/think),可以简单的理解一个根命名空间对应了一个类库包。

系统内置的几个根命名空间(类库包)如下：
think 系统核心类库 thinkphp/library/think
traits 系统Trait类库 thinkphp/library/traits
app 应用类库 application

如果需要增加新的根命名空间,有两种方式：手动注册新的根命名空间或把类库包目录放入EXTEND_PATH目录(默认extend,可配置,自动注册)
如类文件位于extend/my/Test.php,可以直接实例化和调用：
$Test = new \my\Test();
$Test->sayHello();
如果在应用入口文件中重新定义了EXTEND_PATH常量的话,还可以改变\my\Test类文件的位置
define('EXTEND_PATH','../vendor/');
那么\my\Test类文件的位置就变成了/vendor/my/File.php

手动注册的方式注册新的根命名空间
在应用公共文件中添加下面的代码：
\think\Loader::addNamespace('my','../application/extend/my/');
如果要同时注册多个根命名空间,可以使用：
\think\Loader::addNamespace([
    'my'  => '../application/extend/my/',
    'org' => '../application/extend/org/',
]);
也可以直接在应用的配置文件中添加配置,系统会在应用执行的时候自动注册。
'root_namespace' => [
    'my'  => '../application/extend/my/',
    'org' => '../application/extend/org/',
]

</pre>

<h3>通过URL重写隐藏应用的入口文件index.php</h3><pre>
index.php入口文件放置到项目根目录
1.修改入口文件
define('APP_PATH', __DIR__.'/application/');  //应用目录
require './thinkphp/start.php';               // 加载框架引导文件
2.public/.htaccess跟随入口文件放置到项目根目录下,保持和入口文件同级目录
3.模板文件中资源(image/css/js)是相对于入口文件定位
4.模板常量随着入口文件位置不同会有差别,具体测试,可以在配置文件中定义模板替换常量

</pre><pre class="php">
< VirtualHost *:80>
  DocumentRoot "/home/www/tp5/public"   # 把DocumentRoot修改为本机tp5/public所在目录
  ServerName tp5.com                    # 修改本机的hosts文件把tp5.com指向本地127.0.0.1
< /VirtualHost>

</pre><pre>
【 apache配置 】
httpd.conf配置文件中加载了mod_rewrite.so模块
AllowOverride None 将None改为 All
把下面的内容保存为.htaccess文件放到应用入口文件的同级目录下

</pre><pre class="php">
< IfModule mod_rewrite.c>
Options +FollowSymlinks -Multiviews
RewriteEngine on

RewriteCond %{REQUEST_FILENAME} !-d
RewriteCond %{REQUEST_FILENAME} !-f
RewriteRule ^(.*)$ index.php?/$1 [QSA,PT,L]
< /IfModule>

</pre><pre>
【 nginx配置 】
Nginx低版本是不支持PATHINFO的,但可以通过在Nginx.conf中配置转发规则实现：

location / {
  // ...
  if (!-e $request_filename) {
    rewrite  ^(.*)$  /index.php?s=/$1  last;
    break;
  }
}
其实内部是转发到了TP提供的兼容URL,利用这种方式可以解决其他不支持PATHINFO的WEB服务器环境。
如果应用安装在二级目录,Nginx的伪静态方法设置如下,其中youdomain是所在的目录名称。
location /youdomain/ {
    if (!-e $request_filename){
        rewrite  ^/youdomain/(.*)$  /youdomain/index.php?s=/$1  last;
    }
}

原来的访问URL：
http://serverName/index.php/模块/控制器/操作/[参数名/参数值...]
设置后可以采用下面的方式访问：
http://serverName/模块/控制器/操作/[参数名/参数值...]

如果没有修改服务器的权限,可以在index.php入口文件做修改,这不是正确的做法,并且不一定成功,视服务器而定,只是在框架执行前补全$_SERVER['PATH_INFO']参数
$_SERVER['PATH_INFO'] = $_SERVER['REQUEST_URI' ];

</pre>nginx配置<pre class="php">
server {
    listen 80;
    server_name local.tp5.com;
    access_log /data/wwwlogs/local.tp5.com_nginx.log combined;
    index index.html index.htm index.php;
    root /data/wwwroot/edutp5/public;       # 项目根目录下的public目录设置为Document root

    if (!-e $request_filename) {
       rewrite  ^(.*)$  /index.php?s=/$1  last;
       break;
    }

    location ~ \.php {
      #fastcgi_pass remote_php_ip:9000;
      fastcgi_pass unix:/dev/shm/php-cgi.sock;
      fastcgi_index index.php;
      include fastcgi_params;
      set $real_script_name $fastcgi_script_name;
      if ($fastcgi_script_name ~ "^(.+?\.php)(/.+)$") { // URL重写规则,省去URL中的index.php
          set $real_script_name $1;
          #set $path_info $2;
      }
      fastcgi_param SCRIPT_FILENAME $document_root$real_script_name;
      fastcgi_param SCRIPT_NAME $real_script_name;
      #fastcgi_param PATH_INFO $path_info;
    }
}

location / {
  root /var/www;
  index index.html index.htm index.php;
  if (!-e $request_filename) {
    rewrite ^/index.php(.*)$ /index.php?s=$1 last;
    rewrite ^(.*)$ /index.php?s=$1 last;
    break;
  }
}

location ~ \.php {
  fastcgi_pass   127.0.0.1:9000;
  fastcgi_index  index.php;
  #先加载默认后解析赋值
  include        fastcgi_params;
  #正则解析路径
  fastcgi_split_path_info ^((?U).+\.php)(/?.+)$;
  fastcgi_param  PATH_INFO        $fastcgi_path_info;
  fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;
}

</pre>

<h3>TP5.0应用请求的生命周期及整个执行流程</h3><pre>
tp5生命周期：入口文件->引导文件->注册自动加载->注册错误和异常机制->应用初始化->URL访问检测->路由检测->分发请求->响应输出->应用结束

1、入口文件
用户发起的请求都会经过应用的入口文件,通常是public/index.php文件,也可以更改或增加新的入口文件。
入口文件位置的设计是为了让应用部署更安全,public目录为web可访问目录,其他的文件都可以放到非WEB访问目录下面
TP采用单一入口模式进行项目部署和访问,无论完成什么功能,一个应用都有一个统一(但不一定是唯一)的入口,应该说所有应用都是从入口文件开始的,并且不同应用的入口文件是类似的

入口文件主要完成：
定义框架路径、项目路径(可选)
定义系统相关常量(可选)
载入框架入口文件(必须)

一般入口文件以定义一些常量为主,通常不在应用入口文件中加入过多的代码,尤其是和业务逻辑相关的代码。
入口文件中还可以定义一些系统变量,用于相关的绑定操作(通常用于多个入口的情况)
给APP_PATH定义绝对路径会提高系统的加载效率

// 应用入口文件
// 定义项目路径
define('APP_PATH', __DIR__ . '/../application/');
// 加载框架引导文件
require __DIR__ . '/../thinkphp/start.php';

2、引导文件
接下来就是执行框架的引导文件,start.php文件是系统默认引导文件,在引导文件中会依次执行下面操作：
加载系统常量定义;
加载环境变量定义文件;
注册自动加载机制;
注册错误和异常处理机制;
加载惯例配置文件;
执行应用;

start.php引导文件首先会调用base.php基础引导文件,某些特殊需求下面可能直接在入口文件中引入基础引导文件,该引导文件和start.php的区别是不会主动执行应用,而是需要自己进行应用执行

// 定义应用目录
define('APP_PATH', __DIR__ . '/../application/');
// 加载框架基础引导文件
require __DIR__ . '/../thinkphp/base.php';
// 添加额外的代码
// ...
// 执行应用
\think\App::run()->send();

3、注册自动加载
系统会调用Loader::register()方法注册自动加载所有符合规范的类库,包括Composer依赖加载的第三方类库
TP5.0真正实现了按需加载,所有类库采用自动加载机制,并且支持类库映射和composer类库的自动加载。
自动加载的实现由think\Loader类库完成,自动加载规范符合PHP的PSR-4

系统的自动加载由下面主要部分组成：
注册系统的自动加载方法 \think\Loader::autoload
注册系统命名空间定义
加载类库映射文件(如果存在)
如果存在Composer安装,则注册**Composer**自动加载
注册extend扩展目录

一个类库的自动加载检测顺序为：可以看到定义类库映射的方式是最高效的
是否定义类库映射;
PSR-4自动加载检测;
PSR-0自动加载检测;

类库映射
遵循命名空间定义规范的话,基本上可以完成类库的自动加载了,但是如果定义了较多的命名空间的话效率会有所下降,所以可以给常用的类库定义类库映射。命名类库映射相当于给类文件定义了一个别名,效率会比命名空间定位更高效,例如：
Loader::addClassMap('think\Log',LIB_PATH.'think\Log.php');
Loader::addClassMap('org\util\Array',LIB_PATH.'org\util\Array.php');
也可以利用addClassMap方法批量导入类库映射定义,例如：
$map = [
    'think\Log'     =>  LIB_PATH.'think\Log.php',
    'org\util\array'=>  LIB_PATH.'org\util\Array.php'
];
Loader::addClassMap($map);
虽然通过类库映射的方式注册的类可以不强制要求对应命名空间目录,但是仍然建议遵循PSR-4规范定义类库和目录

4、注册错误和异常机制
执行Error::register()注册错误和异常处理机制。

由三部分组成：
应用关闭方法：think\Error::appShutdown
错误处理方法：think\Error::appError
异常处理方法：think\Error::appException

注册应用关闭方法是为了便于拦截一些系统错误。
在整个应用请求的生命周期过程中,如果抛出了异常或严重错误均会导致应用提前结束,并响应输出异常和错误信息。

5、应用初始化
执行应用的第一步操作就是对应用进行初始化,包括：
加载应用(公共)配置;
加载扩展配置文件(由extra_config_list定义);
加载应用状态配置;
加载别名定义;
加载行为定义;
加载公共(函数)文件;
注册应用命名空间;
加载扩展函数文件(由extra_file_list定义);
设置默认时区;
加载系统语言包;

6、URL访问检测
应用初始化完成后就会进行URL的访问检测,包括PATH_INFO检测和URL后缀检测。

tp5.0的URL访问必须是PATH_INFO方式(包括兼容方式)的URL地址,其中PATH_INFO的分隔符是可以设置的
http://serverName/index.php/index/index/hello/val/value
所以如果环境只能支持普通方式的URL参数访问,那么必须使用兼容模式访问
http://serverName/index.php(或其它应用入口文件)?s=/模块/控制器/操作/[参数名/参数值...]
http://serverName/index.php?s=/index/index/hello&val=value
必要的时候可以通过某种方式,省略URL里面的模块和控制器。

如果是命令行下面访问入口文件的话,则通过
$php index.php index/index/hello/val/value...
获取到正常的$_SERVER['PATH_INFO']参数后才能继续。

tp5.0取消了URL模式的概念,并且普通模式的URL访问不再支持,但参数可以支持普通方式传值
>php index.php 模块/控制器/操作?参数名=参数值&...

默认URL不区分大小写,即URL里面的模块/控制器/操作名会自动转换为小写,控制器在最后调用的时候会转换为驼峰法处理
在这种URL不区分大小写情况下要访问驼峰法的控制器类则需要使用：
http://localhost/index.php/Index/blog_test/read
如果希望URL访问严格区分大小写,可以在应用配置文件中设置：
// 关闭URL中控制器和操作名的自动转换
'url_convert' => false,
一旦关闭自动转换,URL地址中的控制器名就变成大小写敏感了,例如前面的访问地址就要写成：
http://localhost/index.php/Index/BlogTest/read
但下面的URL访问依然是有效的：
http://localhost/index.php/Index/blog_test/read
下面的URL访问则无效：
http://localhost/index.php/Index/blogtest/read

路由规则中定义的路由地址是按照控制器名的实际名称定义(区分大小写)

7、路由检测
如果开启了url_route_on参数就会首先进行URL的路由检测。
如果一旦检测到匹配的路由,根据定义的路由地址会注册到相应的URL调度。

tp5.0的路由地址支持如下方式：
路由到模块/控制器/操作;
路由到外部重定向地址;
路由到控制器方法;
路由到闭包函数;
路由到类的方法;

路由地址可能会受域名绑定的影响。
如果关闭路由或路由检测无效则进行默认的模块/控制器/操作的分析识别。

如果在应用初始化的时候指定了应用调度方式,那么路由检测是可选的。
可以使用 \think\App::dispatch() 进行应用调度,例如：
App::dispatch(['type' => 'module', 'module' => 'index/index']);

8、分发请求
在完成了URL检测和路由检测之后,路由器会分发请求到对应的路由地址,这也是应用请求的生命周期中最重要的一个环节。
在这一步骤中完成应用的业务逻辑及数据返回。
建议统一使用return返回数据,而不是echo输出,如非必要不要使用exit或die中断执行。
直接echo输出的数据将无法进行自动转换响应输出的便利。

下面是系统支持的分发请求机制,可以根据情况选择：
1> 模块/控制器/操作
这是默认的分发请求机制,系统会根据URL或路由地址来判断当前请求的模块、控制器和操作名,并自动调用相应的访问控制器类,执行操作对应的方法
该机制下面,首先会判断当前模块,并进行模块的初始化操作(和应用的初始化操作类似),模块的配置参数会覆盖应用的尚未生效的配置参数。

支持模块映射、URL参数绑定到方法以及操作绑定到类等一些功能。

2> 控制器方法
和前一种方式类似,只是无需判断模块、控制器和操作,直接分发请求到一个指定的控制器类的方法,因此没有进行模块的初始化操作。

3> 外部重定向
可以直接分发请求到一个外部的重定向地址,支持指定重定向代码,默认为301重定向。

4> 闭包函数
路由地址定义的时候可以直接采用闭包函数,完成一些相对简单的逻辑操作和输出。

5> 类的方法
除了以上方式外,还支持分发请求到类的方法,包括：
静态方法： 'blog/:id'=>'\org\util\Blog::read'
类的方法：'blog/:id'=>'\app\index\controller\Blog@read'

9、响应输出
控制器的所有操作方法都是return返回而不是直接输出,系统会调用Response::send方法将最终的应用返回的数据输出到页面或客户端,并自动转换成default_return_type参数配置的格式。所以应用执行的数据输出只需要返回一个正常的PHP数据即可。

新版的控制器输出采用Response类统一处理,而不是直接在控制器中进行输出,通过设置default_return_type或动态设置不同类型的Response输出就可以自动进行数据转换处理,一般只需要在控制器中返回字符串或数组即可,例如如果配置'default_return_type'=>'json',那么控制器方法return的数组会自动转换为json格式并返回

指定输出某种类型的数据
核心支持的数据类型包括view、xml、json和jsonp,其他类型的需要自己扩展
return json(['data'=>$data,'code'=>1,'message'=>'操作完成']);
return xml(['data'=>$data,'code'=>1,'message'=>'操作完成']);

10、应用结束
事实上在应用的数据响应输出之后,应用并没真正的结束,系统会在应用输出或中断后进行日志保存写入操作。
系统的日志包括用户调试输出的和系统自动生成的日志,统一会在应用结束的时候进行写入操作,而日志的写入操作受日志初始化的影响。

</pre>
</div>

<div id="config">
<h2>配置</h2><pre>
TP提供了灵活的全局配置功能,采用最有效率的PHP返回数组方式定义,支持惯例配置、公共配置、模块配置、扩展配置、场景配置、环境变量配置和动态配置。
对于有些简单的应用无需配置任何配置文件,而对于复杂的要求还可以扩展自己的独立配置文件。
系统的配置参数是通过静态变量全局存取的,存取方式简单高效。
配置功能由\think\Config类完成
系统默认的配置文件目录就是应用目录(APP_PATH),并分为应用配置(整个应用有效)和模块配置(仅针对该模块有效)

如果不希望配置文件放到应用目录下面,可以在入口文件中定义独立的配置目录,添加CONF_PATH常量定义即可
// 定义配置文件目录和应用目录同级
define('CONF_PATH', __DIR__.'/../config/');

配置目录下面的结构类似如下：
├─application         应用目录
├─config              配置目录
│  ├─config.php       应用配置文件
│  ├─database.php     数据库配置文件
│  ├─route.php        路由配置文件
│  ├─index            index模块配置文件目录
│  │  ├─config.php    index模块配置文件
│  │  └─database.php  index模块数据库配置文件

模块可以有自己的配置文件,独立配置文件即扩展配置(文件名为配置项)和场景配置文件,入口文件自定义的配置文件优先级高于应用配置
模块默认独立配置文件：数据库database.php和验证validate.php

加载其他位置的配置文件:必须是在控制器方法中动态加载
1.PHP文件
\think\Config::load(APP_PATH,'完整文件名');          //使用绝对路径加载,默认返回数组
2.ini xml json文件
\think\Config::parse(APP_PATH,'完整文件名','.ini');  //使用绝对路径加载,默认返回数组

【 配置文件格式 】
支持多种格式的配置格式,但最终都是解析为PHP数组的方式

1.默认 数组键值对
2.ini名值对 入口文件：define('CONF_EXT','.ini')  ;注释部分,该配置文件夹内的.php的配置文件全部失效
3.xml标签对 入口文件：define('CONF_EXT','.xml')
4.json对象属性名值对 入口文件：define('CONF_EXT','.json') 必须双引号
5.yaml配置格式

【 扩展配置目录 】
在应用配置目录或模块配置目录下面增加extra子目录,下面的配置文件都会自动加载,无需任何配置
扩展配置文件的文件名(不含后缀)就是配置参数名,并且会和应用配置文件中的参数进行合并

【 场景配置 】
动态配置,不同环境下不同的应用场景加载不同的配置文件使用不同配置项,场景配置文件和应用配置文件config.php是一样的定义。

如配置数据库,在公司和家里分别设置不同的数据库测试环境
在应用配置文件中配置'app_status'=>'office',那么就会自动加载该状态对应的配置文件(默认位于application/office.php)
回家后修改定义为'app_status'=>'home',那么就会自动加载该状态对应的配置文件(位于application/home.php)

【 动态配置 设置配置项 】
1.类方法
\think\Config::set('配置参数','参数值')
\think\Config::set(数组)
\think\Config::set('配置参数',数组) 二级配置
2.助手函数
Config('配置参数','参数值')
Config(数组)
Config('配置参数',数组) 二级配置

【 读取配置项 】
系统不支持二级以上的配置参数读取,需要手动分步骤读取

1.类方法\think\Config::get('配置参数') 参数为空则获取全部配置项
2.助手函数config('配置参数')
dump(Config::get());
dump(config());

$config = [
    'user' => ['type' => 1, 'name' => 'thinkphp',
    'db' => ['type' => 'mysql', 'user' => 'root', 'password' => '',],
];
Config::set($config);           // 设置配置参数
echo Config::get('user.type');  // 读取二级配置参数
echo config('user.type');       // 使用助手函数

【 判断配置项是否存在 】
1.类方法\think\Config::has('配置参数') 返回布尔
2.助手函数Config('?配置参数')

【 配置优先级 】
应用的配置文件是自动加载的,加载的顺序如下,后面的配置会覆盖之前的同名配置
->惯例配置     thinkphp/convention.php
->应用配置     application/config.php
->应用扩展配置 扩展配置文件直接放入application/extra目录会自动加载
->应用场景配置
->模块配置     application/当前模块名/config.php
->模块扩展配置
->模块场景配置
->动态配置

惯例重于配置是系统遵循的一个重要思想,按照大多数的使用对常用参数进行了默认配置。所以对于应用的配置文件,往往只需要配置和惯例配置不同的或新增的配置参数,如果完全采用默认配置甚至可以不需要定义任何配置文件

【 配置项作用域 】
配置参数支持作用域的概念,默认所有参数都在同一个系统默认作用域下面。如果配置参数需要用于不同的项目或相互隔离,那么就可以使用作用域功能,作用域的作用好比是配置参数的命名空间一样

Config::load('my_config.php','','user');      // 导入my_config.php中的配置参数并纳入user作用域
Config::parse('my_config.ini','ini','test');  // 解析并导入my_config.ini中的配置参数,读入test作用域
Config::set('user_type',1,'user');            // 设置user_type参数,并纳入user作用域
Config::set($config,'test');                  // 批量设置配置参数,并纳入test作用域
echo Config::get('user_type','user');         // 读取user作用域的user_type配置参数
dump(Config::get('','user'));                 // 读取user作用域下面的所有配置参数
dump(config('',null,'user'));                 // 同上
Config::has('user_type','test');              // 判断在test作用域下面是否存在user_type参数

可以使用range方法切换当前配置文件的作用域
Config::range('test');

【 环境变量配置 】
在开发过程中可以在应用根目录下面的.env来模拟环境变量配置,.env文件中的配置参数定义格式采用ini方式
app_debug = true
app_trace = true

如果部署环境单独配置了环境变量,那么请删除.env配置文件,避免冲突。
环境变量配置的参数会全部转换为大写,值为null,no和false等效于"",值为yes和true等效于"1"
TP5.0默认的环境变量前缀是PHP_,也可以通过改变ENV_PREFIX常量来重新设置

环境变量不支持数组参数,如果需要使用数组参数可以,使用下划线分割定义配置参数名：
database_username =  root
database_password =  123456
或使用
[database]
username =  root
password =  123456

var_dump($_ENV);  // 返回空数组

Env::get('email') 和 $_ENV['PHP_EMAIL']区别
Env::get('email')是直接根据.env配置文件中的配置读取的,即使.env中没有这个环境变量也会输出null
$_ENV['PHP_EMAIL']则要加前缀,否则找不到的话也会报错,因为tp5框架会自动给环境变量的配置加上前缀

获取环境变量的值可以使用下面的两种方式获取：
\think\Env::get('database.username');
\think\Env::get('database.password');
// 同时下面的方式也可以获取
\think\Env::get('database_username');
\think\Env::get('database_password');

可以支持默认值
// 获取环境变量 如果不存在则使用默认值root
\think\Env::get('database.username','root');
可以直接在应用配置中使用环境变量,例如：
return ['hostname'  =>  \think\Env::get('hostname','127.0.0.1'),];
环境变量中设置的app_debug和app_trace参数会自动生效(优先于应用的配置文件),其它参数则必须通过Env::get方法才能读取。

</pre>
</div>

<div id="route">
<h2>url和路由</h2><pre>
TP5.0采用单一入口模式访问应用,对应用的所有请求都定向到应用的入口文件,系统会从URL参数中解析当前请求的模块、控制器和操作
默认采用的URL规则是http://server/module/controller/action/param/value/...

tp5已经不再支持传统URL模式
tp5URL访问默认采用PATH_INFO方式：不区分大小写
http://域名/入口文件index.php/模块module/控制器controller/操作action/参数键/参数值/参数键值对
PATH_INFO兼容模式：
http://域名/入口文件index.php?s=/模块module/控制器controller/操作action&参数键值对

默认URL地址中的控制器和操作名是不区分大小写的
如果控制器是驼峰的如HelloWorld控制器,URL访问地址应该是：http://serverName/index.php/index/hello_world/index
如果希望严格区分大小写访问或支持驼峰法进行控制器访问,可以在应用配置文件中设置：
'url_convert' => false,   // 关闭URL自动转换(支持驼峰访问控制器)

【 设置URL分隔符 】
如果需要改变URL地址中的pathinfo参数分隔符,只需要在应用配置文件application/config.php中设置：
// 设置pathinfo分隔符
'pathinfo_depr' => '-',
路由规则定义'hello/[:name]$' => 'index/hello'无需做任何改变就可以访问下面的地址：
http://tp5.com/hello/thinkphp -> http://tp5.com/hello-thinkphp

【 默认模块、默认控制器、默认操作 】
namespace app\index\controller;
class Index{
  public function index(){
    return 'index';
  }
  public function hello($name = 'World'){
    return 'Hello,' . $name . '!';
  }
}

如果直接访问入口文件的话,由于URL中没有模块、控制器和操作,因此系统会访问默认模块(index)下面的默认控制器(Index)的默认操作(index),因此下面的访问是等效的：
http://tp5.com/index.php
http://tp5.com/index.php/index/index/index

如果要访问控制器的hello方法则需要使用完整的URL地址
http://tp5.com/index.php/index/index/hello/name/thinkphp
由于name参数为可选参数,因此也可以使用
http://tp5.com/index.php/index/index/hello

</pre>

<h3>url模式</h3><pre>
TP5.0的路由支持三种方式的URL解析规则。

一、普通模式
关闭路由,完全使用默认的PATH_INFO方式URL：
'url_route_on'  =>  false,
路由关闭后不会解析任何路由规则,采用默认的PATH_INFO模式访问URL：
http://serverName/index.php/module/controller/action/param/value/...
但仍然可以通过操作方法的参数绑定、空控制器和空操作等特性实现URL地址的简化。

可设置url_param_type配置参数来改变pathinfo模式下参数获取方式,默认是按名称成对解析,支持按照顺序解析变量,只需要更改为：
// 按照顺序解析变量
'url_param_type' => 1,
按顺序绑定参数的话,操作方法的参数只能使用URL pathinfo变量,而不能使用get或者post变量

参数传入
通过操作方法的参数绑定功能可以实现自动获取URL的参数

</pre><pre class="php">
namespace app\index\controller;
class Index{
  public function index(){
    return 'index';
  }
  public function hello($name = 'World', $city = 'china'){
    return 'Hello,' . $name . '!';
  }
}
http://example.com/index/index/hello                          // url中没传入参数值则使用参数的默认值
http://example.com/index/index/hello/name/thinkphp/city/usa   // 使用url传入的参数
http://example.com/index/index/hello/thinkphp/usa             // 配置url_param_type使用url传入的参数

</pre><pre>
二、混合模式 - 框架默认惯例配置
开启路由,并使用路由定义+默认PATH_INFO方式的混合：
'url_route_on'  =>  true,
'url_route_must'=>  false,
该方式只需要对需要定义路由规则的访问地址定义路由规则,其它的仍然按照第一种普通模式的PATH_INFO模式访问URL。

三、强制模式
开启路由,并设置必须定义路由才能访问,没有配置路由规则的地址都是不能访问的：
'url_route_on' => true,
'url_route_must' => true,
这种方式必须严格给每一个访问地址定义路由规则(包括首页),配置'index/index/index' =>'index/index/index'都可以,否则将抛出异常。

首页的路由规则采用/定义即可,例如下面把网站首页路由输出Hello,world!
Route::get('/',function(){
    return 'Hello,world!';
});

</pre>

<h3>路由</h3><pre>
路由功能由\think\Route类完成,作用是简化URL访问地址并根据定义的路由类型做出正确的解析
路由把用户不同的请求分发到对应的URL地址上,根据事先定义的路由规则检验URL请求,确定执行或拒绝
路由规则是用户最终用来访问的URL地址,而不是原始URL地址,可自定义,隐藏原来的URL地址,使访问更安全,地址更优雅

TP5.0的路由规则定义是从根目录开始,而不是基于模块名的。
tp5.0的路由是针对应用而不是针对模块,因此路由的设置也是针对应用下面的所有模块

</pre>如果希望不同的模块区分不同的设置(如某些模块需要关闭路由,某些模块需要强制路由等),需要给该模块增加单独的入口文件,并作如下修改：<pre class="php">
define('APP_PATH', __DIR__ . '/../application/');  // 定义项目路径
require __DIR__ . '/../thinkphp/base.php';  // 加载框架基础文件
\think\Route::bind('admin');  // 绑定当前入口文件到admin模块
\think\App::route(false);  // 关闭admin模块的路由
\think\App::run()->send();  // 执行应用

</pre>

<h4>注册路由规则</h4><pre>
路由规则注册可以采用方法动态单个和批量注册,也可以直接定义路由定义文件的方式进行集中注册
定义路由规则后,原来的URL地址将会失效,变成非法请求

【 动态注册路由规则 】
路由定义采用\think\Route类的rule方法注册,通常是在应用的路由配置文件application/route.php进行注册,自定义配置文件之后原应用配置文件失效
Route::rule('路由表达式','路由地址','请求类型','路由参数(数组)','变量规则(数组)'); 可以使用空数组占位

use think\Route;
Route::rule('new/:id','index/News/read');   # 注册路由规则到index模块的News控制器的read操作
访问http://serverName/new/5会自动路由到http://serverName/index/news/read/id/5,且原来的访问地址会自动失效。

路由表达式支持定义命名标识,路由命名标识必须唯一,定义后可以用于URL的快速生成
Route::rule(['new','new/:id'],'index/News/read');   // 定义new路由命名标识

可以在rule方法中指定请求类型,表示只有在该类型的请求下才有效,不指定的话默认为任何请求类型
Route::rule('new/:id','News/update','POST');   // 表示定义的路由规则在POST请求下才有效。
Route::rule('new/:id','News/read','GET|POST'); // 定义get和post请求支持的路由规则

请求类型(必须大写)包括：
类型    描述
GET     GET请求
POST    POST请求
PUT     PUT请求
DELETE  DELETE请求
*       任何请求类型

系统提供了为不同的请求类型定义路由规则的简化方法
Route::get('new/:id','News/read');      // 定义GET请求路由规则
Route::post('new/:id','News/update');   // 定义POST请求路由规则
Route::put('new/:id','News/update');    // 定义PUT请求路由规则
Route::delete('new/:id','News/delete'); // 定义DELETE请求路由规则
Route::any('new/:id','News/read');      // 所有请求都支持的路由规则

【 批量注册路由规则 】
批量注册路由规则可以使用两种方式,包括方法注册和路由配置定义
Route::rule([
  '路由规则1'=>'路由地址和参数',
  '路由规则2'=>['路由地址和参数','匹配参数(数组)','变量规则(数组)'],
],'','请求类型','匹配参数(数组)','变量规则');

如果在外面和规则里面同时传入了匹配参数和变量规则的话,路由规则定义里面的最终生效,但请求类型参数以最外层决定
Route::rule([
    'new/:id'  =>  'News/read',
    'blog/:id' =>  ['Blog/update',['ext'=>'shtml'],['id'=>'\d{4}']],  // 路由规则定义里面的最终生效
    ...
],'','GET',['ext'=>'html'],['id'=>'\d+']);

批量注册GET路由
Route::get([
    'new/:id'  =>  'News/read',
    'blog/:id' =>  ['Blog/edit',[],['id'=>'\d+']]
]);
// 效果等同于
Route::rule([
    'new/:id'  =>  'News/read',
    'blog/:id' =>  ['Blog/edit',[],['id'=>'\d+']]
],'','GET');

Route::rule(['new/:id'=>'News/read','blog/:name'=>'Blog/detail']);
Route::get(['new/:id'=>'News/read','blog/:name'=>'Blog/detail']);
Route::post(['new/:id'=>'News/update','blog/:name'=>'Blog/detail']);
注册多个路由规则后系统会依次遍历注册过的满足请求类型的路由规则,一旦匹配到正确的路由规则后则开始调用控制器的操作方法,后续规则就不再检测。

【 定义路由配置文件 】
除了支持动态注册,也可以直接在应用目录下面的route.php最后通过返回数组的方式直接定义路由规则
路由配置文件定义的路由规则效果和使用any注册路由规则一样
由于检测机制问题,动态注册的性能比路由配置要高一些,尤其是多种请求类型混合定义的时候

return [
    'new/:id'   => 'News/read',
    'blog/:id'   => ['Blog/update',['method' => 'post|put'], ['id' => '\d+']],
];

return [
  '__pattern__' => [  // 全局变量规则定义
    'id' => '\d+',
  ],
  'user/index' => 'index/user/index',
  'user/create' => 'index/user/create',
  'user/add' => 'index/user/add',
  'user/add_list' => 'index/user/addList',
  'user/update/:id' => 'index/user/update',
  'user/delete/:id' => 'index/user/delete',
  'user/:id' => 'index/user/read',
];

路由动态注册和配置定义的方式可以共存
use think\Route;
Route::rule('hello/:name','index/index/hello');
return [
    'new/:id'   => 'News/read',
    'blog/:id'   => ['Blog/update',['method' => 'post|put'], ['id' => '\d+']],
];

默认只会加载一个路由配置文件route.php,如需定义多个路由文件可以修改route_config_file配置参数
// 定义路由配置文件(数组)
'route_config_file' =>  ['route', 'route1', 'route2'],

</pre>

<h4>路由表达式</h4><pre>
路由表达式统一使字符串定义,采用规则定义的方式。正则路由定义功能已经废除,改由变量规则定义完成。

规则表达式通常包含静态地址和动态地址或两种地址的结合
每个参数中以“:”开头的参数都表示动态变量,并且会自动绑定到操作方法的对应参数
'/'                    => 'index',             // 首页访问路由
'my'                   => 'Member/myinfo',     // 静态地址路由
'blog/:id'             => 'Blog/read',         // 静态地址和动态地址结合
'new/:year/:month/:day'=> 'News/read',         // 静态地址和动态地址结合
':user/:blog_id'       => 'Blog/read',         // 全动态地址
'blog/:year/[:month]'  => 'Blog/archive',      // [:month]变量用[ ]包含起来后就表示该变量是路由匹配的可选变量

采用可选变量定义后,之前需要定义两个或多个路由规则才能处理的情况可以合并为一个路由规则
可选参数只能放到路由规则的最后,如果在中间使用了可选参数的话后面的变量都会变成可选参数
以上定义路由规则后,下面的URL访问地址都可以被正确的路由匹配：
http://serverName/index.php/blog/2015
http://serverName/index.php/blog/2015/12

对blog-＜year＞-＜month＞这样的非正常规范需要使用<变量名>这样的变量定义方式,而不是:变量名方式
'blog-＜year＞-＜month＞' => ['blog/archive', ['method' => 'get'], ['year' => '\d{4}','month' => '\d{2}']],

【 完全匹配 】
规则匹配检测时只对URL从头开始匹配,只要URL地址包含了定义的路由规则就会匹配成功,如果希望完全匹配可以在路由表达式最后使用$符号
'hello/[:name]' => 'index/hello',           // 所有hello开头的并且带参数的访问都会匹配
'hello/[:name]$' => 'index/hello',          // 路由参数name为可选
http://serverName/hello                     // 正确匹配
http://serverName/hello/thinkphp            // 正确匹配
http://serverName/hello/thinkphp/val/value  // 不会匹配

'new/:cate$'=> 'News/category',
http://serverName/index.php/new/info    // 会匹配成功
http://serverName/index.php/new/info/2  // 不会匹配成功
如果采用'new/:cate'=> 'News/category',方式定义则两种方式的URL访问都可以匹配成功

如果希望所有的路由定义都是完全匹配的话,可以直接配置
'route_complete_match'  =>  true,       // 开启路由定义的全局完全匹配
当开启全局完全匹配的时候,如果个别路由不需要使用完整匹配,可以添加路由参数覆盖定义：
Route::rule('new/:id','News/read','GET|POST',['complete_match' => false]);

</pre>

<h4>路由地址 - 用户用路由规则访问页面时真实跳转到的地址</h4><pre>
如果开启了url_route_on参数则会进行URL路由检测

路由地址表示定义的路由表达式最终需要路由到的地址以及一些需要的额外参数,支持下面5种方式定义：
方式1：路由到模块/控制器  '[模块/控制器/操作]?额外参数1=值1&额外参数2=值2...'
方式2：路由到重定向地址   '外部地址'(默认301重定向) 或 ['外部地址','重定向代码']
方式3：路由到控制器的方法 '@[模块/控制器/]操作方法'
方式4：路由到类的方法     '\完整的命名空间类::静态方法' 或 '\完整的命名空间类@动态方法'
方式5：路由到闭包函数     闭包函数定义(支持参数传入)

1、路由到模块/控制器/操作
最常用的一种路由方式,把满足条件的路由规则路由到相关的模块、控制器和操作,然后由App类调度执行相关的操作。
同时会进行模块的初始化操作,包括配置读取、公共文件载入、行为定义载入、语言包载入等

路由地址的格式为：
[模块/控制器/]操作?参数1=值1&参数2=值2...
解析规则是从操作开始解析,然后解析控制器,最后解析模块
'blog/:id'=>'blog/read',          // 路由到默认或绑定的模块,如index
'blog/:id'=>'index/blog/read',    // 指定路由到index模块

Blog类定义如下：
namespace app\index\controller;
class Blog {
    public function read($id){
        return 'read:'.$id;
    }
}

路由地址中支持多级控制器,使用下面的方式进行设置：
'blog/:id'=>'index/group.blog/read'  // 表示路由到控制器类index/controller/group/Blog

Blog类定义如下：
namespace app\index\controller\group;
class Blog {
    public function read($id){
        return 'read:'.$id;
    }
}

路由到动态的模块、控制器或操作,如果关闭路由功能默认也会按照定义的规则对URL进行解析调度
':action/blog/:id' => 'index/blog/:action'  // action变量的值作为操作方法传入
':c/:a'=> 'index/:c/:a'                     // 变量传入index模块的控制器和操作方法
Route::rule(':version/news/:id', 'api/:version.news/read');   // 多级控制器,restful版本控制,/controller/v1

额外参数
在这种方式路由跳转的时候支持额外传入参数对
额外参数指的是不在URL里面的参数,隐式传入需要的操作中,有时候能够起到一定的安全防护作用
'blog/:id'=>'blog/read?status=1&app_id=5',
上面的路由规则定义中额外参数status和app_id参数都是URL里面不存在的,属于隐式传值,当然并不一定需要用到,只是在需要的时候可以使用。

2、路由到操作方法
路由地址的格式为：@[模块/控制器/]操作
类似第一种,本质的区别是直接执行某个控制器类的方法,而不需要去解析模块/控制器/操作,同时也不会去初始化模块(配置文件和公共文件加载)
通常这种方式下面,由于没有定义当前模块名、当前控制器名和当前方法名,从而导致视图的默认模板规则失效,所以这种情况下如果使用了视图模板渲染则必须传入明确的参数,设置完整模板文件的路径。

定义路由'blog/:id'=>'@index/blog/read'后系统会直接执行Loader::action('index/blog/read');
相当于直接调用 \app\index\controller\blog类的read方法。

Blog类定义如下：
namespace app\index\controller;
class Blog {
    public function read($id){
        return 'read:'.$id;
    }
}

3、路由到类的方法
路由地址的格式为(动态方法)：\类的命名空间\类名@方法名
或(静态方法)             \类的命名空间\类名::方法名

这种方式更进一步,可以支持执行任何类的方法,而不仅仅是执行控制器的操作方法
'blog/:id'=>'\app\index\service\Blog@read',            // 执行的是 \app\index\service\Blog类的read方法
'blog/:id'=>'\app\index\service\Blog::read',           // 支持执行某个静态方法
'blog/:id'=>'\app\index\service\Blog::read?status=1',  // 传入额外的参数作为方法的参数调用(用于参数绑定)

4、路由到重定向地址,外部地址适用于网站迁移
重定向的外部地址必须以“/”或http开头的地址。
如果路由地址以“/”或“http”开头则会认为是一个重定向地址或外部地址
路由地址采用重定向地址时如果要引用动态变量,直接使用动态变量即可

'blog/:id'=>'/blog/read/id/:id'
'blog/:id'=>'blog/read'
虽然都是路由到同一个地址,但前者采用的是301重定向的方式路由跳转,这种方式的好处是URL可以比较随意(包括可以在URL里面传入更多的非标准格式的参数),而后者只是支持模块和操作地址

如果希望avatar/123重定向到/member/avatar/id/123_small的话,只能使用：
'avatar/:id'=>'/member/avatar/id/:id_small'

采用重定向到外部地址通常对网站改版后的URL迁移过程非常有用
'blog/:id'=>'http://blog.thinkphp.cn/read/:id'
表示当前网站的blog/123地址会直接重定向到http://blog.thinkphp.cn/read/123

5、路由到闭包函数 ,网站更新时可使用
闭包即函数中的函数,方法中的方法,函数嵌套
Route::rule('路由规则',function([参数]){
  //闭包函数代码
});

</pre>

<h4>路由匹配参数</h4><pre>
路由匹配参数是指可以设置一些路由匹配的条件参数,主要用于验证当前的路由规则是否有效
这些路由匹配参数可以混合使用,只要有任何一条参数检查不通过,当前路由就不会生效,继续检测后面的路由规则

method            请求类型检测,支持多个请求类型
ext               URL后缀检测,支持匹配多个后缀
deny_ext          URL禁止后缀检测,支持匹配多个后缀
https             检测是否https请求,支持false
domain            域名检测
before_behavior   前置行为(检测)
after_behavior    后置行为(执行)
callback          自定义检测方法
merge_extra_vars  合并额外参数
bind_model        绑定模型
cache             请求缓存
param_depr        路由参数分隔符
ajax              Ajax检测,支持false
pjax              Pjax检测,支持false

请求类型
如果指定请求类型注册路由的话无需设置method请求类型参数
如果使用了rule或any方法注册路由或使用路由配置定义文件的话,可以单独使用method参数进行请求类型检测。
Route::any('new/:id','News/read',['method'=>'get']);      // 检测路由规则仅GET请求有效
Route::any('new/:id','News/read',['method'=>'get|post']); // 检测路由规则仅GET和POST请求有效

URL后缀即及设置禁止访问的URL后缀
ext和deny_ext参数设置空分别表示不允许任何后缀以及必须使用后缀访问。
Route::get('new/:id','News/read',['ext'=>'html']);        // 定义GET请求路由规则 并设置URL后缀为html的时候有效
Route::get('new/:id','News/read',['ext'=>'shtml|html']);  // 支持匹配多个后缀
Route::get('new/:id','News/read',['deny_ext'=>'png|gif']);// 定义GET请求路由规则并禁止URL后缀为png和gif的访问

域名检测,可设置白名单
Route::get('new/:id','News/read',['domain'=>'example.cn']); // 完整域名检测,只在example.cn访问时路由有效
Route::get('new/:id','News/read',['domain'=>'news']);       // 子域名检测

HTTPS检测
Route::get('new/:id','News/read',['https'=>true]);          // 支持检测当前是否HTTPS访问

前置行为检测
支持使用行为对路由进行检测是否匹配,行为方法返回false表示当前路由规则无效
Route::get('user/:id','index/User/read',['before_behavior'=>'\app\index\behavior\UserCheck']);
行为类定义如下：
namespace app\index\behavior;
class UserCheck{
    public function run(){
        if('user/0'==request()->url()){
            return false;
        }
    }
}

后置行为执行
可以为某个路由或某个分组路由定义后置行为执行,表示当路由匹配成功后执行的行为类的run方法,参数是路由地址,可以动态改变
Route::get('user/:id','User/read',['after_behavior'=>'\app\index\behavior\ReadInfo']);
行为类定义如下：
namespace app\index\behavior;
use app\index\model\User;
class ReadInfo {
    public function run(){
      $id = request()->route('id');
      request()->user = User::get($id);
    }
}

Callback检测
也可以支持使用函数检测路由,如是否存在某个配置项,公共方法common.php中的回调函数返回false则表示当前路由规则无效
Route::get('new/:id','News/read',['callback'=>'my_check_fun']);

合并额外参数
通常用于完整匹配的情况,如果有额外的参数则合并作为变量值,例如：
Route::get('new/:name$','News/read',['merge_extra_vars'=>true]);
http://serverName/new/thinkphp/hello会被匹配到,并且name变量的值为thinkphp/hello。

路由绑定模型
可以在当前路由匹配后绑定模型,后面则通过方法的对象自动注入来获取
Route::get('new/:name$','News/read',['bind_model'=>['User','name']]);

缓存路由请求
可以对当前的路由请求进行缓存处理
Route::get('new/:name$','News/read',['cache'=>3600]);  // 表示对当前路由请求缓存3600秒

配置文件中添加路由匹配参数
return [
    'blog/:id'   => ['Blog/update',['method' => 'post','ext'=>'html|shtml']],
];

</pre>

<h4>路由变量规则</h4><pre>
TP5.0支持在规则路由中为变量用正则的方式指定变量规则,弥补了动态变量无法限制具体的类型问题,并且支持全局规则设置

全局变量规则
设置全局变量规则,全部路由有效
Route::pattern('name','\w+');  // 设置name变量规则
Route::pattern([               // 支持批量添加
    'name'  =>  '\w+',
    'realname' => '[a-zA-Z]+',
    'id'    =>  '\d+',
    'year'  =>  '\d{4}'
    'statu'   => '0|1'
]);

'__pattern__' => [             // return方式设置
    'name' => '\w+',
],

局部变量规则
局部变量规则仅在当前路由有效
如果一个变量同时定义了全局规则和局部规则,局部规则会覆盖全局变量的定义
Route::get('new/:name','News/read',[],['name'=>'\w+']);  // 定义GET请求路由规则 并设置name变量规则

完整URL规则
__url__ 变量规则对整个URL进行规则检查
Route::get('new/:id','News/read',[],['__url__'=>'new\/\w+$']);  // 定义GET请求路由规则 并设置完整URL变量规则

组合变量
如果路由规则比较特殊,可以在路由定义的时候使用组合变量
Route::get('item-＜name＞-＜id＞','product/detail',[],['name'=>'\w+','id'=>'\d+']);

组合变量的优势是路由规则中没有固定的分隔符,可以随意组合需要的变量规则
Route::get('item＜name＞＜id＞','product/detail',[],['name'=>'[a-zA-Z]+','id'=>'\d+']);
Route::get('item@＜name＞-＜id＞','product/detail',[],['name'=>'\w+','id'=>'\d+']);
Route::get('item-＜name＞<＜d?＞','product/detail',[],['name'=>'[a-zA-Z]+','id'=>'\d+']); // 使用可选变量

</pre>

<h3>资源路由</h3><pre>
设置RESTFul请求的资源路由方式：
Route::resource('blog','index/blog');
或在路由配置文件中使用__rest__添加资源路由定义：
return [
    // 定义资源路由
    '__rest__'=>[
        'blog'=>'index/blog',   // 指向index模块的blog控制器
    ],
    // 定义普通路由
    'hello/:id'=>'index/hello',
]

设置后会自动注册7个路由规则：
标识    请求类型  生成路由规则  对应操作方法(默认)  描述
index   GET      blog          index            显示列表
create  GET      blog/create   create           新增页面
save    POST     blog          save             保存内容
read    GET      blog/:id      read             查看内容
edit    GET      blog/:id/edit edit             编辑页面
update  PUT      blog/:id      update           更新内容
delete  DELETE   blog/:id      delete           删除

Route::get('blog','index/blog');

只需要为Blog控制器创建以上对应的操作方法就可以支持下面的URL访问：
http://serverName/blog/
http://serverName/blog/128
http://serverName/blog/28/edit

Blog控制器中的对应方法如下：
namespace app\index\controller;
class Blog {
    public function index(){}
    public function read($id){}
    public function edit($id){}
}

【 可以改变默认的id参数名 】
Route::resource('blog','index/blog',['var'=>['blog'=>'blog_id']]);
控制器的方法定义需要调整如下：
namespace app\index\controller;
class Blog {
    public function index(){}
    public function read($blog_id){}
    public function edit($blog_id){}
}

【 在定义资源路由时限定执行的方法(标识) 】
Route::resource('blog','index/blog',['only'=>['index','read','edit','update']]); // 只允许四个操作
Route::resource('blog','index/blog',['except'=>['index','delete']]);              // 排除index和delete操作

资源路由的标识不可更改,但生成的路由规则和对应操作方法可以修改。
Route::rest('create',['GET', '/add','add']);  // 改某个资源路由标识的对应操作
设置之后URL访问http://serverName/blog/create 变成 http://serverName/blog/add,创建blog页面的对应的操作方法也变成了add。

支持批量更改
Route::rest([
    'save'   => ['POST', '', 'store'],
    'update' => ['PUT', '/:id', 'save'],
    'delete' => ['DELETE', '/:id', 'destory'],
]);

【 资源路由的嵌套 】
Route::resource('blog.comment','index/comment');
就可以访问如下地址：
http://serverName/blog/128/comment/32
http://serverName/blog/128/comment/32/edit
生成的路由规则分别是：
blog/:blog_id/comment/:id
blog/:blog_id/comment/:id/edit

Comment控制器对应的操作方法如下：
namespace app\index\controller;
class Comment{
    public function edit($id,$blog_id){}
}

edit方法中的参数顺序可以随意,但参数名称必须满足定义要求,如果需要改变其中的变量名,可以使用：
// 更改嵌套资源路由的blog资源的资源变量名为blogId
Route::resource('blog.comment','index/comment',['var'=>['blog'=>'blogId']]);
Comment控制器对应的操作方法改变为：
namespace app\index\controller;
class Comment{
    public function edit($id,$blogId){}
}

</pre>

<h3>快捷路由</h3><pre>
快捷路由允许快速给控制器注册路由,并且针对不同的请求类型可以设置方法前缀
Route::controller('user','index/User');  // 给User控制器设置快捷路由

User控制器定义如下：
namespace app\index\controller;
class User {
    public function getInfo(){}
    public function getPhone(){}
    public function postInfo(){}
    public function putInfo(){}
    public function deleteInfo(){}
}

可以通过下面的URL访问
get http://localhost/user/info
get http://localhost/user/phone
post http://localhost/user/info
put http://localhost/user/info
delete http://localhost/user/info

</pre>

<h3>路由别名</h3><pre>
路由别名功能可以使用一条规则,批量定义一系列的路由规则。

快速注册同一控制器下的所有方法,不支持变量规则
1.动态方法 Route::alias('规则名称','模块/控制器',[路由参数]);
2.静态数组 return [ '__alias__' => ['规则名称','模块/控制器',[路由参数]] ];

使用user可以访问index模块的User控制器的所有操作
Route::alias('user','index/User');    // user别名路由到index/User控制器

在路由配置文件route.php中定义
return [ '__alias__' =>  ['user'=>'index/User',], ];

然后可以直接通过URL地址访问User控制器的操作,如果URL参数绑定方式使用按顺序绑定的话,URL地址可以进一步简化
http://serverName/index.php/user/add
http://serverName/index.php/user/edit/id/5
http://serverName/index.php/user/read/id/5

Route::alias('action','index/index',['ext'=>'html','allow'=>'index,sayhello','except'=>'saybye']);
别名是action,index模块下的index控制器下的所有方法,扩展名必须是html,允许和不允许使用的方法
输入：www.example.com/action/sathello.html

路由别名可以指向任意一个有效的路由地址
Route::alias('user','\app\index\controller\User');  // user路由别名指向User控制器类

路由别名不支持变量类型和路由条件判断,单纯只是为了缩短URL地址,并且在定义的时候需要注意避免和路由规则产生混淆。

【 给路由别名设置路由匹配参数 】
Route::alias('user','index/user',['ext'=>'html']);  // user别名路由到index/user控制器
或在路由配置文件中使用：
return [ '__alias__' =>  [ 'user'  =>  ['index/user',['ext'=>'html']], ], ];

【 操作方法黑白名单 】
路由别名的操作方法支持白名单或黑名单机制
Route::alias('user','index/user',[                 // user别名路由到index/user控制器
  'ext'=>'html',
  'allow'=>'index,read,edit,delete',               // 使用白名单机制
]);
Route::alias('user','index/user',[
  'ext'=>'html',
  'except'=>'save,delete',                         // 使用黑名单机制
]);
Route::alias('user','index/user',[
  'ext'=>'html',
  'allow'=>'index,save,delete',
  'method'=>['index'=>'GET','save'=>'POST','delete'=>'DELETE'],  // 设置操作方法的请求类型
]);

</pre>

<h3>路由分组</h3><pre>
路由分组功能允许把相同前缀的路由定义合并分组,这样可以提高路由匹配的效率,不必每次都去遍历完整的路由规则。

'blog/:id'   => ['Blog/read', ['method' => 'get'], ['id' => '\d+']],
'blog/:name' => ['Blog/read', ['method' => 'post']],

合并到一个blog分组
'[blog]'    => [
    ':id'   => ['Blog/read', ['method' => 'get'], ['id' => '\d+']],
    ':name' => ['Blog/read', ['method' => 'post']],
],

使用Route类的group方法进行注册
动态方法Route::group('分组名称',[路由地址,[路由参数],[变量规则])

Route::group('blog',[
    ':id'   => ['Blog/read', ['method' => 'get'], ['id' => '\d+']],
    ':name' => ['Blog/read', ['method' => 'post']],
]);

给分组路由定义一些公用的路由设置参数
Route::group('blog',[
    ':id'   => ['Blog/read', [], ['id' => '\d+']],
    ':name' => ['Blog/read', [],
],['method'=>'get','ext'=>'html']);

使用闭包方式注册路由分组
Route::group('blog',function(){
    Route::any(':id','blog/read',[],['id'=>'\d+']);
    Route::any(':name','blog/read',[],['name'=>'\w+']);
},['method'=>'get','ext'=>'html']);

仅仅是用于对一些路由规则设置一些公共的路由参数
Route::group(['method'=>'get','ext'=>'html'], function(){
    Route::any('blog/:id','blog/read',[],['id'=>'\d+']);
    Route::any('blog/:name','blog/read',[],['name'=>'\w+']);
});

虚拟分组:根据相同的路由参数进行分组
think\Route::group(['name' => 'demo','method' => 'get'],[
  ':id'   =>['index/user/demo1',[],['id'   => '\d{2,4}']],
  ':name' =>['index/user/demo2',[],['name' => '[a-zA-Z]+']],
  ':isok' =>['index/user/demo3',[],['id'   => '0|1']],
]);

虚拟分组简化
think\Route::group(['name' => 'demo','method' => 'get','prefix' => 'index/user/'],[
  ':id'   =>['demo1',[],['id'   => '\d{2,4}']],
  ':name' =>['demo2',[],['name' => '[a-zA-Z]+']],
  ':isok' =>['demo3',[],['id'   => '0|1']],
]);

路由虚拟分组再次简化
think\Route::group('demo',[
  ':id'   =>'demo1',
  ':name' =>'demo2',
  ':isok' =>'demo3',
  ],['method' => 'get',
     'prefix' => 'index/user/'
  ],['id' => '\d{2,4}',
     'name' => '[a-zA-Z]+',
     'id'   => '0|1'
  ]);

路由分组嵌套
Route::group(['method'=>'get','ext'=>'html'],function(){
    Route::group('blog',function(){
        Route::any('blog/:id','blog/read',[],['id'=>'\d+']);
        Route::any('blog/:name','blog/read',[],['name'=>'\w+']);
    }
});

</pre>

<h3>MISS路由</h3><pre>
全局MISS路由
MISS路由功能指在没有匹配到所有的路由规则后执行一条设定的路由,只需要在路由配置文件中定义：
return [
    'new/:id'   => 'News/read',
    'blog/:id'  => ['Blog/update',['method' => 'post|put'], ['id' => '\d+']],
    '__miss__'  => 'public/miss',
];

或使用miss方法注册路由
Route::miss('public/miss');   // 当没有匹配到所有的路由规则后会路由到public/miss路由地址

【 分组MISS路由 】
分组支持独立的MISS路由
return [
    '[blog]' =>  [
        'edit/:id'  => ['Blog/edit',['method' => 'get'], ['id' => '\d+']],
        ':id'       => ['Blog/read',['method' => 'get'], ['id' => '\d+']],
        '__miss__'  => 'blog/miss',
    ],
    'new/:id'   => 'News/read',
    '__miss__'  => 'public/miss',
];

Route::group('blog',function(){
    Route::rule(':id','blog/read',[],['id'=>'\d+']);
    Route::rule(':name','blog/read',[],['name'=>'\w+']);
    Route::miss('blog/miss');
},['method'=>'get','ext'=>'html']);

</pre>

<h3>闭包支持</h3><pre>
闭包定义
可以使用闭包的方式定义一些特殊需求的路由,而不需要执行控制器的操作方法
Route::get('hello', function(){
    return 'hello,world!';
});

参数传递
闭包定义的时候支持参数传递,规则路由中定义的动态变量的名称就是闭包函数中的参数名称,不分次序
Route::get('hello/:name', function($name){
    return 'Hello,'.$name;
});

因此如果访问的URL地址是http://serverName/hello/thinkphp,则浏览器输出的结果是Hello,thinkphp

</pre>

<h3>路由绑定</h3><pre>
可以在路由配置文件中使用路由绑定简化URL或路由规则的定义,绑定支持如下方式：

1、绑定到模块/控制器/操作
把当前的URL绑定到模块/控制器/操作,最多支持绑定到操作级别

Route::bind('index');            // 绑定当前的URL到index模块
Route::bind('index/blog');       // 绑定当前的URL到index模块的blog控制器
Route::bind('index/blog/read');  // 绑定当前的URL到index模块的blog控制器的read操作

该方式针对路由到模块/控制器/操作有效,假如绑定到了index模块的blog控制器,访问URL从
http://serverName/index/blog/read/id/5可以简化成http://serverName/read/id/5
如果定义了路由Route::get('index/blog/:id','index/blog/read');那么访问URL就变成了http://serverName/5

2、绑定到命名空间
绑定到命名空间和类之后,不会进行模块的初始化工作
把当前的URL绑定到某个指定的命名空间
Route::bind('\app\index\controller','namespace');
只需要通过http://serverName/blog/read/id/5就可以直接访问\app\index\controller\Blog类的read方法。

3、绑定到类
把当前的URL直接绑定到某个指定的类
Route::bind('\app\index\controller\Blog','class');
只需要通过http://serverName/read/id/5就可以直接访问 \app\index\controller\Blog类的read方法。

【 入口文件绑定模块或控制器 】
如果需要给某个入口文件绑定模块,如api.php入口文件绑定某个模块,限制该入口文件只能访问这个模块,可以使用下面两种方式：

1、常量定义
只需要入口文件添加BIND_MODULE系统常量,即可把当前入口文件绑定到指定的模块或控制器
define('APP_PATH', __DIR__ . '/../application/'); // 定义应用目录
define('BIND_MODULE','index'); // 绑定到index模块
require __DIR__ . '/../thinkphp/start.php'; // 加载框架引导文件

// 将当前访问绑定模块/控制器/操作,url可以省略相应的模块或模块控制器,但是将会无法访问其他控制器方法
define('BIND_MODULE','index'); //模块级,,传入的index.php后面的参数会当作控制器而不是模块
define('BIND_MODULE','index/demo'); //控制器级
localhost/api.php/apiCtroller/apifunction
localhost/api.php/api/apiCtroller/apifunction会报错控制器api不存在

2、自动入口绑定
入口文件和应用中模块自动绑定,自动访问与入口文件同名的模块
如果入口文件都是对应实际的模块名,那么可以使用入口文件自动绑定模块的功能,只需要在应用配置文件中添加：
'auto_bind_module'  =>  true, // 开启入口文件自动绑定模块
当重新添加一个public/demo.php入口文件,内容和public/index.php一样：
define('APP_PATH', __DIR__ . '/../application/');  // 定义应用目录
require __DIR__ . '/../thinkphp/start.php';  // 加载框架引导文件
但其实访问demo.php的时候其实已经自动绑定到了demo模块。

【 绑定模型 】
路由规则和分组绑定模型数据
自动给当前路由绑定id为当前路由变量值的User模型数据,即自动读取user表中id为路由规则中的变量id的值的数据
Route::rule('hello/:id','index/index/hello','GET',[
  'ext' => 'html',
  'bind_model' => ['user' => '\app\index\model\User',],
]);

在application/index/controller新建一个Hello.php
namespace app\index\controller;
class Hello extends \think\Controller{
    public function index(){
        return $this->request->user;
    }
}

可以定义模型数据的查询条件,即增加限制条件,限制条件的变量要和数据表中字段对应,否则会报相应错误
Route::rule('hello/:name/:id','index/index/hello','GET',[
  'ext'         =>  'html',
  'bind_model'  =>  [
      'user'  =>  ['\app\index\model\User','id&name']  // 表示查询id和name的值等于当前路由变量的模型数据
    ],
]);

也可以使用闭包来返回模型对象数据
Route::rule('hello/:id','index/index/hello','GET',[
  'ext'         =>  'html',
  'bind_model'  =>  [
      'user'  =>  function($param){                    // 闭包函数的参数就是当前请求的URL变量信息
          $model = new \app\index\model\User;
          return $model->where($param)->find();
        }
    ],
]);

在控制器中可以通过request()->user或使用依赖注入获取
绑定的模型可以直接在控制器的架构方法或操作方法中自动注入,具体可以参考请求章节的依赖注入。

</pre>

<h3>域名路由</h3><pre>
TP支持完整域名、子域名和IP部署的路由和绑定功能,同时还可以起到简化URL的作用。
要启用url域名部署路由功能,首先需要开启'url_domain_deploy'=>true
如果域名后缀比较特殊如com.cn或net.cn之类的域名,需要配置'url_domain_root'=>'thinkphp.com.cn'

定义域名部署规则支持两种方式：动态注册和配置定义。

【 动态注册 】
在应用的公共文件或配置文件中动态注册域名部署规则
Route::domain('blog','blog');                // blog子域名绑定到blog模块
Route::domain('blog','blog?var=thinkphp');   // 绑定时添加默认参数,隐式传入$_GET['var']='thinkphp'变量
Route::domain('admin.thinkphp.cn','admin');  // 完整域名绑定到admin模块
Route::domain('114.23.4.5','admin');         // IP绑定到admin模块

URL访问规则由原来的URL访问
http://www.thinkphp.cn/blog/article/read/id/5
blog子域名绑定后变成
http://blog.thinkphp.cn/article/read/id/5

直接绑定到控制器
Route::domain('blog','index/blog');          // blog子域名绑定到index模块的blog控制器
URL访问地址变化为：
// 原来的URL访问
http://www.thinkphp.cn/index/blog/read/id/5
// 绑定到blog子域名访问
http://blog.thinkphp.cn/read/id/5

绑定到命名空间
Route::domain('blog','\app\blog\controller');           // blog子域名绑定命名空间

绑定到类
Route::domain('blog','@\app\blog\controller\Article');  // blog子域名绑定到类

直接把域名绑定到闭包函数
Route::domain('blog',function(){                        // blog子域名绑定闭包函数
    echo 'hello';
    return ['bind'=>'module','module'=>'blog'];
});

域名绑定到闭包函数其实是一种劫持,可以在闭包函数里面动态注册其它的绑定机制或注册新的路由
Route::domain('www', function(){
    // 动态注册域名的路由规则
    Route::rule('new/:id', 'index/news/read');
    Route::rule(':user', 'index/user/info');
});
如果不希望继续,可以直接在闭包函数里面中止执行。
Route::domain('blog',function(){  // blog子域名绑定到闭包函数
    exit('hello');
});

把域名绑定到一系列指定的路由规则
Route::domain('blog',[
    // 动态注册域名的路由规则
    ':id' => ['blog/read',['method'=>'GET'],['id'=>'\d+']],
    ':name'=>'blog/read',
]);

使用配置文件配置把域名绑定到一系列指定的路由规则
return [
    '__domain__'=>[
        'blog'      => [
            // 动态注册域名的路由规则
            ':id' => ['blog/read',['method'=>'GET'],['id'=>'\d+']],
            ':name'=>'blog/read',
        ],
    ],
]

【 泛域名部署规则 】
目前只支持二级域名和三级域名的泛域名部署
在配置传入参数的时候,如果需要使用当前的泛域名作为参数,可以直接设置为“*”即可。

Route::domain('*','book?name=*');            // 绑定泛二级域名域名到book模块
下面的URL访问都会直接访问book模块,并且可以直接通过$_GET['name']变量获取当前的泛域名
http://hello.thinkphp.cn
http://quickstart.thinkphp.cn

Route::domain('*.user','user?name=*');      // 三级泛域名部署,绑定泛三级域名到user模块
访问URL地址http://hello.user.thinkphp.cn的同时,除了会访问user模块之外,还会默认传入 $_GET['name'] = 'hello'

【 配置文件定义方式 】
除了动态注册之外,还支持直接在路由配置文件中定义域名部署规则
return [
    '__domain__'=>[
        'blog'      => 'blog',
        // 泛域名规则建议在最后定义
        '*.user'    =>  'user',
        '*'         => 'book',
    ],
]

</pre>

<h3>URL生成</h3><pre>
TP5支持路由URL地址的统一生成,且支持所有的路由方式及完美解决了路由地址的反转解析,无需再为路由定义和变化而改变URL生成
URL地址生成不会检测路由的有效性,只是按照给定的路由地址和参数生成符合条件的路由规则
定义路由规则之后可以通过Url类来方便的生成实际的URL地址(路由地址)

URL生成使用\think\Url::build()方法或使用系统提供的助手函数url(),参数一致：
\think\Url::build('地址表达式',['参数'],['URL后缀'],['域名'])
url('地址表达式',['参数'],['URL后缀'],['域名'])
{:url('地址表达式',['参数'],['URL后缀'],['域名'])}  // 模板文件中生成url地址

地址表达式和参数
对使用不同的路由地址方式,地址表达式的定义有所区别
Route::rule('blog/:id','index/blog/read');            // 路由规则
url('index/blog/read','id=5&name=thinkphp');          // 生成URL地址/tp5/blog/5/name/thinkphp.html
url('index/blog/read',['id'=>5,'name'=>'thinkphp']);  // 生成URL地址/tp5/blog/5/name/thinkphp.html
url('blog/8');                                        // 直接使用路由规则来生成URL地址/tp5/blog/8.html

不配置路由时生成的url地址
url('index/blog/read','id=5&name=thinkphp');          // /tp5/index/blog/read/id/5/name/thinkphp.html'
url('index/blog/read',['id'=>5,'name'=>'thinkphp']);  // /tp5/index/blog/read/id/5/name/thinkphp.html'

1、使用模块/控制器/操作生成url
路由方式是路由到模块/控制器/操作时,生成方法的第一个参数必须和路由定义的路由地址保持一致,不在路由规则里面的变量会直接使用普通URL参数的方式

url('index/blog/read','id=5&name=thinkphp');
生成URL地址/index.php/blog/5/name/thinkphp.html
如果环境支持REWRITE,那么生成的URL地址会变为：/blog/5/name/thinkphp.html
如果配置了'url_common_param'=>true,那么生成的URL地址变为：/index.php/blog/5.html?name=thinkphp

2、使用控制器的方法生成url
'blog/:id' => '@index/blog/read'        // 配置方式定义路由,动态注册的方式一样有效,路由地址是采用控制器的方法
url('@index/blog/read','id=5');         // 使用助手函数url生成index模块blog控制器的read操作的URL访问地址
那么自动生成的URL地址变为：/index.php/blog/5.html

3、使用类的方法生成
如果路由地址是到类的方法,需要首先给路由定义命名标识,然后使用标识快速生成URL地址。
Route::rule(['blog','blog/:id'],'\app\index\controller\blog@read');  // 路由规则：路由地址是路由到类的方法
url('blog?id=5');        // 生成index模块 blog控制器的read操作 URL访问地址
那么自动生成的URL地址变为：/index.php/blog/5.html

4、直接使用路由规则生成URL地址
'blog/:id' => 'index/blog/read'   // 路由规则
Url::build('/blog/5');
自动生成的URL地址为：/index.php/blog/5.html

5、生成方法的第一个参数一定要和路由定义的路由地址保持一致,如果路由地址特殊,例如使用闭包定义的话则需要手动给路由指定标识
// 添加hello路由标识
Route::rule(['hello','hello/:name'], function($name){
  return 'Hello,'.$name;
});
// 根据路由标识快速生成URL
Url::build('hello', 'name=thinkphp');
Url::build('hello', ['name' => 'thinkphp']);

【 URL后缀 】
默认系统会自动读取url_html_suffix配置参数作为URL后缀(默认为html),如果设置了：
'url_html_suffix'=>'shtml'自动生成的URL地址为/index.php/blog/5.shtml
如果设置了多个URL后缀支持则会取第一个后缀来生成URL地址
'url_html_suffix'=>x'html|shtml'自动生成的URL地址为/index.php/blog/5.html

指定URL后缀生成
url('index/blog/read','id=5','shtml');

【 域名生成 】
默认生成的URL地址是不带域名的,如果采用了多域名部署或希望生成带有域名的URL地址的话就需要传入第四个参数,该参数有两种用法：

1、自动生成域名
url('index/blog/read','id=5','shtml',true);
第四个参数传入true表示自动生成域名,如果开启了url_domain_deploy还会自动识别匹配当前URL规则的域名。

例如注册了域名路由信息如下：
Route::domain('blog','index/blog'); URL地址生成为：http://blog.thinkphp.cn/read/id/5.shtml

2、指定域名
url('index/blog/read','id=5','shtml','blog');
url('index/blog/read','id=5','shtml','blog.thinkphp.cn');  // 传入完整的域名
生成的URL地址为：http://blog.thinkphp.cn/read/id/5.shtml

也可以直接在第一个参数里面传入域名
url('index/blog/read@blog','id=5');
url('index/blog/read@blog.thinkphp.cn','id=5');

【 生成URL锚点 】
生成URL的锚点可以直接在URL地址参数中使用：锚点和域名一起使用的时候,注意锚点在前面,域名在后面
url('index/blog/read#anchor@blog','id=5');
生成的URL地址为：http://blog.thinkphp.cn/read/id/5.html#anchor

【 生成url时隐藏或加上入口文件index.php 】
生成的URL地址中加上index.php或去掉index.php大多数时候系统会自动判断
如果发现自动生成的地址有问题,可以直接在调用build方法之前调用root方法,root方法只需要调用一次即可
\think\Url::root('/index.php');               // 加上index.php
\think\Url::build('index/blog/read','id=5');
\think\Url::root('/');                        // 隐藏index.php
\think\Url::build('index/blog/read','id=5');

</pre>
</div>

<div id="controller">
<h2>控制器</h2><pre>
tp5控制器可以无需继承任何基础类,也可以继承官方封装的\think\controller类或其他的控制器类
namespace app\index\controller;
class Index{
  public function index(){
    return 'index';
  }
}

控制器类文件的实际位置是application\index\controller\Index.php
控制器类可以无需继承任何类,命名空间默认以app为根命名空间。
控制器的根命名空间可以设置,例如在应用配置文件中修改：V5.0.8+版本app_namespace配置参数改为APP_NAMESPACE常量在入口文件中定义
// 修改应用类库命名空间
'app_namespace' => 'application',

则实际的控制器类应该更改定义如下：只是命名空间改变了,但实际的文件位置和文件名并没有改变。
namespace application\index\controller;
class Index{
  public function index(){
    return 'index';
  }
}

</pre><pre class="php">
//渲染模板文件
namespace app\index\controller;
use think\View;
class Index{
	public function index(){
		$view = new View();
		return $view->fetch('index');
	}
}

//使用助手函数view渲染模板文件
namespace app\index\controller;
class Index{
	public function index(){
		return view('index');
	}
}

//如果继承了think\Controller类的话,可以直接调用think\View及think\Request类的方法
namespace app\index\controller;
use think\Controller;
class Index extends Controller{
	public function index(){
		$this->assign('domain',$this->request->url(true)); // 获取包含域名的完整URL地址
		return $this->fetch('index');
	}
}

</pre><pre>
【 return渲染输出 】
默认控制器的输出全部采用return的方式,无需进行任何的手动输出,系统会自动完成渲染内容的输出。
默认控制器的返回输出不会做任何的数据处理,但可以设置输出格式,并进行自动的数据转换处理,前提是控制器的输出数据必须采用return的方式返回

默认控制器在ajax请求会对返回类型自动转换,默认为json
配置输出类型'default_return_type' => 'html',这种情况下ajax请求不会对返回内容进行转换

return 'hello';
return json_encode($data);
return ['name'=>'thinkphp','status'=>1];
return view();

【 控制器初始化方法 _initialize()只有一个下划线_ 】
_initialize()不是php类中的函数,php类的构造函数只有__construct()

如果控制器类继承了\think\Controller类,可以定义控制器初始化方法_initialize,在该控制器的任何方法调用之前首先执行,后再执行__construct

1、\think\Controller的__construct()方法会自动调用子类的_initialize(),如果子类重写了__construct()方法,那么子类的__construct()会覆盖父类的__construct(),子类只会执行自身的__construct()而不会执行父类的__construct(),除非在子类的__construct()方法中执行parent::__construct()

2、子类的子类的_initialize()会覆盖子类的_initialize()方法,所以子类的子类要执行子类的_initialize()方法必须在子类的子类的_initialize()方法中执行parent::_initialize

</pre>\think\Controller<pre class="php">
public function __construct(Request $request = null){
    if(is_null($request)) {
        $request = Request::instance();
    }
    $this->view = View::instance(Config::get('template'), Config::get('view_replace_str'));
    $this->request = $request;

    // 控制器初始化
    $this->_initialize();

    // 前置操作方法
    if ($this->beforeActionList) {
        foreach ($this->beforeActionList as $method => $options) {
            is_numeric($method) ? $this->beforeAction($options) : $this->beforeAction($method, $options);
        }
    }
}

// 初始化
protected function _initialize(){
}

</pre><pre>
【 前置操作 】
可以为某个或某些操作指定前置执行的操作方法,设置beforeActionList属性可以指定某个方法为其他方法的前置操作,数组键名为需要调用的前置方法名,无值的话为当前控制器下所有方法的前置方法。

</pre><pre class="php">
namespace app\index\controller;
use think\Controller;

class Index extends Controller{
    protected $beforeActionList = [
        'first',
        'second' =>  ['except'=>'hello'],     // 表示这些方法不使用前置方法
        'three'  =>  ['only'=>'hello,data'],  // 表示只有这些方法使用前置方法。
    ];

    protected function first(){ echo 'first<br/>'; }
    protected function second(){ echo 'second<br/>'; }
    protected function three(){ echo 'three<br/>'; }
    public function hello(){ return 'hello'; }
    public function data(){ return 'data'; }
}

</pre><pre>
【 页面跳转 】
\think\Controller类内置两个跳转方法success和error,用于页面跳转提示
thinkphp\library\traits\controller\jump
success($msg = '', $url = null, $data = '', $wait = 3, array $header = [])  //$header发送的Header信息
error($msg = '', $url = null, $data = '', $wait = 3, array $header = [])

</pre><pre class="php">
namespace app\index\controller;
use app\index\model\User;

class Index extends \think\Controller{
    public function index(){
        $User = new User;             //实例化User模型对象
        $result = $User->save($data);
        if($result){
            $this->success('新增成功', 'User/list'); //设置成功后跳转页面的地址
        } else {
            $this->error('新增失败');  //错误页面的默认跳转页面是返回前一页,通常不需要设置
        }
    }
}

</pre><pre>
跳转地址是可选的
success方法的默认跳转地址是$_SERVER["HTTP_REFERER"]
error方法的默认跳转地址是javascript:history.back(-1);即返回前一页,通常不需要设置。
默认的等待时间都是3秒

success和error方法都可以对应的模板,默认的设置是两个方法对应的模板都是：
THINK_PATH . 'tpl/dispatch_jump.tpl'

配置文件可以改变默认的模板：
//默认错误跳转对应的模板文件
'dispatch_error_tmpl' => APP_PATH . 'tpl/dispatch_jump.tpl',
//默认成功跳转对应的模板文件
'dispatch_success_tmpl' => APP_PATH . 'tpl/dispatch_jump.tpl',

也可以使用项目内部的模板文件
//默认错误跳转对应的模板文件
'dispatch_error_tmpl' => 'public/error',
//默认成功跳转对应的模板文件
'dispatch_success_tmpl' => 'public/success',

模板文件可以使用模板标签,并且可以使用下面的模板变量：
$data 要返回的数据
$msg  页面提示信息
$code 返回的code
$wait 跳转等待时间 单位为秒
$url  跳转页面地址

error方法会自动判断当前请求是否属于Ajax请求,如果属于Ajax请求则会自动转换为default_ajax_return配置的格式返回信息。 success在Ajax请求下不返回信息,需要开发者自行处理。

ajax提交数据
return $this->error('请先登录','login/index');
自动返回格式为{code: 0,msg: "错误信息",data: "",url: "",wait: 3}

return $this->success('成功信息');
自动返回格式为{code: 1,msg: "成功信息",data: "",url: "进入地址",wait: 3}

</pre><pre>
【 重定向 】
\think\Controller类的redirect方法可以实现页面的重定向功能,参数用法和Url::build方法的用法一致
跳转和重定向的URL地址不需要再使用url方法进行生成,会自动调用,否则会导致多次生成而出现两个重复的URL后缀

redirect($url, $params = [], $code = 302, $with = [])

$this->redirect('News/category',['cate_id'=>2]);  //重定向到News模块的Category操作,重定向后会改变当前的URL地址
$this->redirect('http://thinkphp.cn/blog/2',302); //重定向到指定的URL地址并且使用302

$this->redirect('News/category',['cate_id'=>2],302,['data'=>'hello']); // 重定向时通过session闪存数据传值

redirect('News/category')->remember();            // 记住当前的URL后跳转
redirect()->restore();                            // 跳转到上次记住的URL

【 空操作 】
系统在找不到指定的操作方法时会定位到空操作( _empty )方法来执行,因此可以实现错误页面和一些URL的优化

</pre><pre class="php">
namespace app\index\controller;
class City{
	public function _empty($name){
		return $this->showCity($name);     //把所有城市的操作解析到city方法
	}
	protected function showCity($name){  //注意 showCity方法 本身是 protected 方法
		return '当前城市' . $name;          //和$name这个城市相关的处理
	}
}
访问：http://serverName/index/city/shanghai/

</pre>

<pre>
【 空控制器 】
当系统找不到指定的控制器时,系统会尝试定位空控制器(Error),因此可以用来定制错误页面和进行URL的优化

</pre><pre class="php">
//Error.php文件如下：
namespace app\index\controller;
use think\Request;
class Error{
	public function index(Request $request){ //根据当前控制器名来判断要执行那个城市的操作
		$cityName = $request->controller();
		return $this->city($cityName);
	}
	protected function city($name){          //注意city方法本身是protected方法
		return '当前城市' . $name;              //和$name这个城市相关的处理
	}
}
//访问：http://serverName/index/shanghai/

</pre><pre>
【 分层控制器 】
通过URL访问的控制器为访问控制器层(Controller)或主控制器,访问控制器是由\think\App类负责调用和实例化的,无需手动实例化
URL解析和路由后会把当前的URL地址解析到[ 模块/控制器/操作 ],其实也就是执行某个控制器类的某个操作方法
tp5的控制器可以不需要继承任何基类,可定义一个公共的控制器基础类来被继承,也可通过控制器扩展来完成不同的功能(例如Restful实现)。
如果不经过路由访问的话,URL中的控制器名会首先强制转为小写,然后再解析为驼峰法实例化该控制器

除访问控制器外,还可定义其他分层控制器类,这些分层控制器是不能够被URL访问直接调用到的,只能在访问控制器、模型类的内部或视图模板文件中调用

</pre>定义Blog事件控制器<pre class="php">
namespace app\index\event;
class Blog{
	public function insert(){
		return 'insert';
	}
	public function update($id){
		return 'update:'.$id;
	}
	public function delete($id){
		return 'delete:'.$id;
	}
}

// 定义完成后实例化并调用方法
$event = \think\Loader::controller('Blog', 'event');
//或使用助手函数$event = controller('Blog', 'event');
echo $event->update(5); // 输出 update:5
echo $event->delete(5); // 输出 delete:5

//支持跨模调用,实例化Admin模块的Blog控制器类,并执行update方法
$event = controller('Admin/Blog', 'event');
echo $event->update(5); // 输出 update:5

//还可以直接调用分层控制器类的某个方法,也可以直接使用助手函数action()
echo \think\Loader::action('Blog/update', ['id' => 5], 'event');  // 输出 update:5
echo action('Blog/update', ['id' => 5], 'event');                 // 使用助手函数,输出 update:5

</pre>利用分层控制器的机制,可以实现Widget(在模板中调用分层控制器)<pre class="php">
//定义index\widget\Blog控制器类
namespace app\index\widget;
class Blog {
	public function header(){
		return 'header';
	}
	public function left(){
		return 'left';
	}
	public function menu($name){
		return 'menu:'.$name;
	}
}

//使用助手函数action()在模板文件值直接调用app\index\widget\Blog分层控制器
{:action('Blog/header', '', 'widget')}
{:action('Blog/menu', ['name' => 'think'], 'widget')}

//或使用助手函数widget()简化widget控制器的调用
{:widget('Blog/header')}
{:widget('Blog/menu', ['name' => 'think'])}

</pre><pre>
【 多级控制器 控制器分组 】
新版支持任意层次级别的控制器,并且支持路由,对应的视图为分组名的同名目录下的视图模板
Route::rule(':version/news/:id', 'api/:version.news/read');   // 多级控制器,restful版本控制,/controller/v1
http://domain/模块名/分组名.控制器名/方法名

</pre><pre class="php">
namespace app\index\controller\one;
class Blog extends \think\Controller{
    public function index(){
        return $this->fetch();
    }
    public function add(){
        return $this->fetch();
    }
    public function edit($id){
        return $this->fetch();
    }
}

</pre><pre>
该控制器类的文件位置为：application/index/controller/one/Blog.php
访问地址可以使用http://serverName/index.php/index/one.blog/index

如果要在路由定义中使用多级控制器,可以使用：
\think\Route::get('blog/add','index/one.Blog/add');

【 自动定位控制器 】
如果使用了多级控制器的话,可设置controller_auto_search参数开启自动定位控制器,便于URL访问,例如首先在配置文件中添加：
'controller_auto_search' => true,

然后定义控制器如下：
namespace app\index\controller\one;
class Blog extends \think\Controller{
    public function index(){
        return $this->fetch();
    }
    public function add(){
        return $this->fetch();
    }
    public function edit($id){
        return $this->fetch('edit:'.$id);
    }
}

可以直接访问下面的URL地址了：
http://serverName/index.php/index/one/Blog

</pre>
</div>

<div id="request">
<h2>请求</h2><pre>
Request对象是从客户端向服务器发出请求,作用是与客户端交互,收集客户端的Form、Cookies、超链接、url参数,收集服务器端的环境变量,然后通过Request对象的相关方法来获取这些数据,Request的各种方法主要用来处理客户端浏览器提交的请求中的各项参数和选项

Request对象的一个主要职责是统一和更安全地获取当前的请求信息,需要避免直接操作$_GET、$_POST、$_REQUEST、$_SESSION、$_COOKIE、$_FILES等全局变量,而是统一使用Request对象提供的方法来获取请求变量

【 Request对象 】
1、使用\think\Request类获取当前的请求信息
$request = Request::instance();

2、控制器类继承了think\Controller
namespace app\index\controller;
use think\Controller;
class Index extends Controller{
  public function hello($name = 'World'){
    echo 'url: ' . $this->request->url() . '<br/>';
    return 'Hello,' . $name . '！';
  }
}

3、使用Request对象自动注入请求对象的方式来获取变量,如果没有继承think\Controller的话
namespace app\index\controller;
use think\Request;
class Index{
  public function hello(Request $request, $name = 'World'){  // request参数是系统自动注入的,而不需要通过URL请求传入
    echo 'url: ' . $request->url() . '<br/>';
    return 'Hello,' . $name . '！';
  }
}

4、助手函数request(),助手函数可以不调用use \think\Request;
$request = request();

【 给Request请求对象动态绑定属性 】
可以给Request请求对象绑定属性,方便全局调用,例如可以在公共控制器中绑定当前登录的用户模型到请求对象,然后在其它的控制器中就可以直接使用

</pre><pre class="php">
namespace app\index\controller;
use app\index\model\User;
use think\Controller;
use think\Request;
use think\Session;
class Base extends Controller{
  public function _initialize(){
    $user = User::get(Session::get('user_id'));
    Request::instance()->bind('user',$user);
  }
}

namespace app\index\controller;
use app\index\controller\Base;
use think\Request;
class Index extends Base{
  public function index(Request $request){
    echo $request->user->id;
    echo $request->user->name;
  }
}

</pre><pre>
【 获取请求信息 】
获取URL信息
url、baseUrl、baseFile、root方法如果传入true,表示获取包含域名的地址

$request = request();             // http://localhost/tp5020/public/index/index/req
var_dump($request->domain());     // 获取当前域名, string 'http://localhost'
var_dump($request->baseFile());   // 入口文件即当前的SCRIPT_NAME, string '/tp5020/public/index.php'
var_dump($request->url());        // 获取当前URL地址,不含域名, string '/tp5020/public/index/index/req'
var_dump($request->url(true));    // 含域名的完整URL, string 'http://localhost/tp5020/public/index/index/req'
var_dump($request->baseUrl());    // 模块控制器操作后缀url, string '/tp5020/public/index/index/req'
var_dump($request->root());       // 获取root地址,可设置, string '/tp1111111111111111111111111111111111111 5020/public'
var_dump($request->root(true));   // 包含域名的root地址, string 'http://localhost/tp5020/public'
var_dump($request->pathinfo());   // 获取PATH_INFO信息,可设置, string 'index/index/req'
var_dump($request->path());       // 不含后缀的PATH_INFO信息, string 'index/index/req'
var_dump($request->ext());        // 后缀, string ''
var_dump($request->scheme());     // 获取当前请求的scheme
var_dump($request->host());       // 获取当前URL的host地址
var_dump($request->port());       // 获取当前URL的port号
var_dump($request->protocol());   // 获取当前请求的SERVER_PROTOCOL
var_dump($request->remotePort()); // 获取当前请求的REMOTE_PORT

设置请求信息
如果某些环境下面获取的请求信息有误,可以手动设置这些信息参数：
$request->root('index.php');
$request->pathinfo('index/index/hello');

获取请求参数
$request->method()                    //请求方法
$request->type()                      //资源类型,如HTML
$request->ip()                        //访问ip
var_export($request->isAjax(), true)  //是否AJax请求
dump($request->param());              //获取请求参数
dump($request->only(['name']));       //获取请求参数,仅包含name
dump($request->except(['name']));     //获取请求参数,排除name

获取http头信息
$info = Request::instance()->header();
echo $info['user-agent'];
echo $info['accept'];
echo $info['accept-encoding'];

HTTP请求头信息的名称不区分大小写,并且_会自动转换为-,所以下面的写法都是等效的
$agent = Request::instance()->header('user-agent');
$agent = Request::instance()->header('User-Agent');
$agent = Request::instance()->header('USER_AGENT');

echo $_SERVER['HTTP_REFERER'];      //不存在时会报错,不存在或未定义HTTP_REFERER
echo request()->header('referer');  //不存在时为空,不会报错

设置/获取 模块/控制器/操作名称
controller方法获取的是驼峰命名的实际的控制器名,其它都是小写返回
$request->module();
$request->controller();
$request->action();
$request->module('module_name');     // 设置模块名称值需要向module方法中传入名称即可,同样使用于设置控制器名称和操作名称

获取路由和调度信息
dump($request->route());             // 路由信息
dump($request->routeInfo());         // 路由信息
dump($request->dispatch());          // 调度信息

设置路由规则
return [
  'hello/:name' =>['index/hello',[],['name'=>'\w+']],
];
访问http://tp5.com/hello/thinkphp
路由信息：
array (size=4)
  'rule' => string 'hello/:name' (length=11)
  'route' => string 'index/hello' (length=11)
  'pattern' =>
    array (size=1)
      'name' => string '\w+' (length=3)
  'option' =>
    array (size=0)
      empty
调度信息：
array (size=2)
  'type' => string 'module' (length=6)
  'module' =>
    array (size=3)
      0 => null
      1 => string 'index' (length=5)
      2 => string 'hello' (length=5)

【 检测输入变量 】
检测变量是否设置
$request->has('id','get');
$request->has('name','post');
或使用助手函数
input('?get.id');
input('?post.name');

【 变量获取 】
变量获取使用\think\Request类的如下方法及参数
变量类型方法('变量名/变量修饰符','默认值','过滤方法')

变量类型方法：除了file方法之外,其它方法都支持默认值和过滤方法
param   获取当前请求的变量,可以获取pathinfo中的参数,包含以下全部变量
get     获取$_GET变量,无法获取pathinfo中的参数
post    获取$_POST变量
put     获取PUT变量
delete  获取DELETE变量
session 获取$_SESSION变量
cookie  获取$_COOKIE变量
request 获取$_REQUEST变量
server  获取$_SERVER变量
env     获取$_ENV变量
route   获取路由(URL)变量,路由规则中冒号开头的变量(包括PATHINFO)
patch   获取PATCH请求变量
file    获取$_FILES变量即上传文件信息

获取PARAM变量
系统推荐使用param方法统一获取当前请求变量,该方法最大的优势是不需要区分当前请求类型而使用不同的全局变量或方法,并且可以满足大部分的参数需求,会自动识别判断当前的请求类型来获取变量,param方法会把当前请求类型的参数和PATH_INFO变量以及GET请求合并,包括了路由变量
路由变量指的是路由规则里面定义的变量或PATH_INFO 地址中的变量,路由变量无法使用get方法或$_GET变量获取

param方法获取的参数会自动,以POST请求为例的话,参数的优先级别为：
路由变量 > 当前请求变量($_POST变量) > $_GET变量

$request->param('name'); // 获取当前请求的name变量
$request->param();       // 获取当前请求的所有变量(经过过滤)可以获取pathinfo中的参数
$request->param(false);  // 获取当前请求的所有变量(原始数据)
$request->param(true);   // 获取当前请求的所有变量(包含上传文件)

助手函数input函数默认就采用PARAM变量读取获取所有变量
input('变量名/变量修饰符','默认值','过滤方法')
input('param.name');
input('param.');
或
input('name');       // 获取name变量
input();             // 获取所有请求变量

</pre>param方法支持变量的过滤和默认值<pre class="php">
namespace app\index\controller;
use think\Request;
class Index{
  public function hello(Request $request){
    echo 'name:'.$request->param('name','World','strtolower');
    echo 'test:'.$request->param('test','thinkphp','strtoupper');
  }
}

</pre><pre>
Request::instance()->get('name'); // 获取get变量
Request::instance()->get();       // 获取所有的get变量(经过过滤的数组) 无法获取pathinfo中的参数
Request::instance()->get(false);  // 获取所有的get变量(原始数组)
input('get.id');
input('get.name');
input('get.');

Request::instance()->post('name'); // 获取某个post变量
Request::instance()->post();       // 获取经过过滤的全部post变量
Request::instance()->post(false);  // 获取全部的post原始变量
input('post.name');
input('post.');

Request::instance()->put('name');  // 获取某个put变量
Request::instance()->put();        // 获取全部的put变量(经过过滤)
Request::instance()->put(false);   // 获取全部的put原始变量
input('put.name');
input('put.');

Request::instance()->request('id');  // 获取某个request变量
Request::instance()->request();      // 获取全部的request变量(经过过滤)
Request::instance()->request(false); // 获取全部的request原始变量数据
input('request.id');
input('request.');

Request::instance()->server('PHP_SELF'); // 获取某个server变量
Request::instance()->server();           // 获取全部的server变量
input('server.PHP_SELF');
input('server.');

Request::instance()->session('user_id'); // 获取某个session变量,Request类内部调用Session::get()
Request::instance()->session();          // 获取全部的session变量
input('session.user_id');
input('session.');

Request::instance()->cookie('user_id'); // 获取某个cookie变量
Request::instance()->cookie();          // 获取全部的cookie变量
input('cookie.user_id');
input('cookie.');

input('route.');                        // 获取路由参数

dump(request()->file('image'));         // 获取上传文件信息
dump(input('file.image'));              // 获取上传文件信息

Request::instance()->only('id,name');            //获取部分变量
Request::instance()->only(['id','name']);
Request::instance()->only(['id','name'],'get');  // 只获取GET请求的id和name变量
Request::instance()->only(['id','name'],'post'); // 只获取POST请求的id和name变量

Request::instance()->except('id,name');          //排除部分变量
Request::instance()->except(['id','name'],'get');

【 更改请求变量的值 】
Request::instance()->get(['id'=>10]);              // 更改GET变量
Request::instance()->post(['name'=>'thinkphp']);   // 更改POST变量

尽量避免直接修改$_GET或$_POST数据,同时也不能直接修改param变量,例如下面的操作是无效的：
Request::instance()->param(['id'=>10]);  // 更改请求变量

【 变量修饰符 】
input('get.id/d');     //修饰符d强制转换为整数类型
input('post.name/s');  //修饰符s强制转换为字符串类型
input('post.ids/a');   //修饰符a强制转换为数组类型
input('post.isok/b');  //修饰符b强制转换为布尔类型
input('post.price/f');  //修饰符f强制转换为浮点类型
Request::instance()->get('id/d');

input('get.id',100,intval)  //默认值100,强制过滤转换成整数
input('get.name',100,trim)  //默认值为空,强制过滤左右的空格

【 变量过滤 】
框架默认没有设置任何过滤规则,可以配置文件中设置全局的过滤规则：
'default_filter' => 'htmlspecialchars', // 默认全局过滤方法,用逗号分隔

使用Request对象进行全局变量的获取过滤,过滤方式包括函数、方法过滤以及PHP内置的Types of filters
Request::instance()->filter('htmlspecialchars');
Request::instance()->filter(['strip_tags','htmlspecialchars']),

Request::instance()->get('name','','htmlspecialchars');            // 获取get变量时用函数过滤
Request::instance()->param('username','','strip_tags');            // 获取param变量时用函数过滤
Request::instance()->post('name','','org\Filter::safeHtml');       // 获取post变量并用org\Filter类的safeHtml方法过滤
Request::instance()->param('username','','strip_tags,strtolower'); // 获取param变量并依次调用strip_tags、strtolower函数过滤

Request对象还支持PHP内置提供的Filter ID过滤、
Request::instance()->post('email','',FILTER_VALIDATE_EMAIL);
框架对FilterID做了转换支持,因此也可以使用字符串的方式
Request::instance()->post('email','','email');
采用字符串方式定义FilterID的时候,系统会自动进行一次filter_id调用转换成Filter常量。
具体的字符串根据filter_list函数的返回值来定义。
采用Filter ID进行过滤的话,如果不符合过滤要求的话会返回false,因此需要配合默认值来确保最终的值符合规范。
Request::instance()->post('email','',FILTER_VALIDATE_EMAIL); // 表示如果不是规范的email地址的话返回空字符串

如果当前不需要进行任何过滤的话可以使用
// 获取get变量,并且不进行任何过滤,即使设置了全局过滤
Request::instance()->get('name','',null);

【 判断请求类型 】
在很多情况下需要判断当前操作的请求类型是GET、POST、PUT、DELETE或HEAD,一方面可以针对请求类型作出不同的逻辑处理,另外一方面有些情况下面需要验证安全性,过滤不安全的请求。

ThinkPHP5.0取消了用于判断请求类型的系统常量(如IS_GET,IS_POST等),统一采用think\Request类处理请求类型

通过注入请求对象的功能,可以更简单的实现

返回布尔值
if (request()->isGet()) echo "当前为 GET 请求";  // 助手函数

if (Request::instance()->isGet()) echo "当前为GET请求";
if (Request::instance()->isPost()) echo "当前为POST请求";
if (Request::instance()->isPut()) echo "当前为PUT请求";
if (Request::instance()->isDelete()) echo "当前为DELETE请求";
if (Request::instance()->isAjax()) echo "当前为Ajax请求";
if (Request::instance()->isPjax()) echo "当前为Pjax请求";
if (Request::instance()->isHead()) echo "当前为HEAD请求";
if (Request::instance()->isPatch()) echo "当前为PATCH请求";
if (Request::instance()->isOptions()) echo "当前为OPTIONS请求";
if (Request::instance()->isMobile()) echo "当前为手机访问";
if (Request::instance()->isCli()) echo "当前为cli";
if (Request::instance()->isCgi()) echo "当前为cgi";

【 请求伪装 】
请求类型伪装
支持请求类型伪装,可以在POST表单里面提交_method变量,传入需要伪装的请求类型,例如：

＜form method="post" action=""＞
  ＜input type="text" name="name" value="Hello"＞
  ＜input type="hidden" name="_method" value="PUT" ＞
  ＜input type="submit" value="提交"＞
＜/form＞

提交后的请求类型会被系统识别为PUT请求,可以设置为任何合法的请求类型,包括GET、POST、PUT和DELETE等。

如果需要改变伪装请求的变量名,可以修改应用配置文件：
// 表单请求类型伪装变量
'var_method' => '_m',

AJAX/PJAX伪装
http://localhost/index?_ajax=1   // 可以对请求进行AJAX请求伪装
http://localhost/index?_pjax=1   // PJAX请求伪装

如果需要改变伪装请求的变量名,可以修改应用配置文件：
// 表单ajax伪装变量
'var_ajax'               => '_a',
// 表单pjax伪装变量
'var_pjax'               => '_p',

_ajax和_pjax可以通过GET/POST/PUT等请求变量伪装。

【 伪静态 】
URL伪静态通常是为了满足更好的SEO效果,TP支持伪静态URL设置,可通过设置url_html_suffix参数随意在URL的最后增加想要的静态后缀,具有相同的执行效果,而不会影响当前操作的正常执行

'url_html_suffix' => 'shtml'
把http://serverName/Home/Blog/read/id/1 变成 http://serverName/Home/Blog/read/id/1.shtml

默认伪静态的设置为html,如果设置伪静态后缀为空字符串'url_html_suffix'=>''则支持所有的静态后缀访问

以下url都可以正常访问
http://serverName/index/blog/3.html
http://serverName/index/blog/3.shtml
http://serverName/index/blog/3.xml
http://serverName/index/blog/3.pdf

可以在控制器的操作方法中获取当前访问的伪静态后缀
$ext = Request::instance()->ext();

如果希望支持多个伪静态后缀,可以直接设置如下：
// 多个伪静态后缀设置 用|分割
'url_html_suffix' => 'html|shtml|xml'
当访问 http://serverName/Home/blog/3.pdf 的时候会报系统错误。

如果要关闭伪静态访问,可以设置
// 关闭伪静态后缀访问
'url_html_suffix' => false,

关闭伪静态访问后,不再支持伪静态方式的URL访问,并且伪静态后缀将会被解析为最后一个参数的值,例如：
http://serverName/index/blog/read/id/3.html  // 最终的id参数的值将会变成 3.html

【 方法注入 】
如果需要在Request请求对象中添加自己的方法,可以使用Request对象的方法注入功能,例如：
Request::hook('user','getUserInfo');   // 通过hook方法注入动态方法

getUserInfo函数定义如下
function getUserInfo(Request $request, $userId){
    // 根据$userId获取用户信息
    return $info;
}

接下来可以直接在控制器中使用：
public function index(){
    $info = Request::instance()->user($userId);
}

【 属性注入 】
可以动态注入当前Request对象的属性
Request::instance()->bind('user',new User);  // 动态绑定属性
Request::instance()->user = new User;  // 动态绑定属性
Request::instance()->user;  // 获取绑定的属性

如果控制器注入请求对象的话,也可以直接使用
$this->request->user;
或使用助手函数：
request()->user;

【 操作方法参数绑定 】
方法参数绑定是把URL地址或路由地址中的变量作为操作方法的参数直接传入

1、按名称绑定
参数绑定方式默认是按照变量名进行绑定

namespace app\index\Controller;
class Blog{
    public function read($id){
        return 'id='.$id;
    }
    public function archive($year='2016',$month='01'){
        return 'year='.$year.'&month='.$month;
    }
}

URL的访问地址分别是：
http://serverName/index.php/index/blog/read/id/5
http://serverName/index.php/index/blog/archive/year/2016/month/06
两个URL地址中的id参数和year和month参数会自动和read操作方法以及archive操作方法的同名参数绑定。

变量名绑定不一定由访问URL决定,路由地址也能起到相同的作用

按照变量名进行参数绑定的参数必须和URL中传入的变量名称一致,但是参数顺序不需要一致
http://serverName/index.php/index/blog/archive/month/06/year/2016
和上面的访问结果是一致的

如果用户访问的URL地址是http://serverName/index.php/index/blog/read/
那么会抛出下面的异常提示：参数错误:id
报错的原因很简单,因为在执行read操作方法的时候,id参数是必须传入参数的,但方法无法从URL地址中获取正确的id参数信息。由于不能相信用户的任何输入,因此建议给read方法的id参数添加默认值

始终给操作方法的参数定义默认值是一个避免报错的好办法

2、按顺序绑定
还支持按照URL的参数顺序进行绑定的方式,参数的顺序不能随意调整,合理规划URL参数的顺序绑定对简化URL地址可以起到一定的帮助。

在配置文件中添加配置参数如下：
// URL参数方式改成顺序解析
'url_param_type' => 1,

接下来访问下面的URL地址：
http://serverName/index.php/index/blog/read/5
http://serverName/index.php/index/blog/archive/2016/06

按顺序绑定参数的话,操作方法的参数只能使用URL pathinfo变量,而不能使用get或post变量。
参数绑定有一个特例,如果操作方法中定义有Request对象作为参数的话,无论参数位置在哪里都会自动注入,而不需要进行参数绑定。

3、构造方法参数绑定
可以对构造函数进行参数绑定,当前请求的路由变量可以自动绑定到构造函数的参数

namespace app\index\Controller;
class Blog{
  protected $name;
  public function __construct($name = null){
      $this->name = $name;
    }
}

如果访问http://localhost/index/index/index/name/thinkphp
当前请求的路由变量name的值thinkphp会自动传入架构方法的name变量。

【 依赖注入 控制反转 】
TP的依赖注入是一种较为轻量的实现,无需任何的配置,并且主要针对访问控制器进行依赖注入。可以在控制器的构造函数或操作方法中类型声明任何(对象类型)依赖,这些依赖会被自动解析并注入到控制器实例或方法中

自动注入请求对象
1、构造方法注入
在控制器的架构方法中会自动注入当前请求对象

namespace app\index\controller;
use think\Request;
class Index{
  protected $request;
  public function __construct(Request $request){
    $this->request = $request;
  }
  public function hello(){
      return 'Hello,' . $this->request->param('name') . '！';
  }
}

2、操作方法注入
控制器的操作方法中如果需要调用请求对象Request的话,可以在方法中定义Request类型的参数,并且参数顺序无关,例如：

namespace app\index\controller;
use think\Request;
class Index{
  public function hello(Request $request){
    return 'Hello,' . $request->param('name') . '！';
  }
}

访问URL地址的时候无需传入request参数,系统会自动注入当前的Request对象实例到该参数。

如果继承了系统的Controller类的话,也可以直接调用request属性,例如：
namespace app\index\controller;
use think\Controller;
class Index extends Controller{
    public function hello(){
        return 'Hello,'.$this->request->param('name');
    }
}

其它对象自动注入
从5.0.1版本开始,控制器的架构方法和操作方法支持任意对象的自动注入。

1、架构方法注入
namespace app\index\controller;
use app\index\model\User;
use think\Request;
class Index{
  protected $request;
  protected $user;
  public function __construct(Request $request, User $user){
    $this->request = $request;
    $this->user = $user;
  }
}

对于已经进行了绑定(属性注入)的对象即可自动完成依赖注入,如果没有进行对象绑定的话会自动实例化一个新的对象示例传入(如果类定义有instance方法则会自动调用instance方法进行实例化)。
架构方法的依赖注入不影响其它类型的参数绑定。

2、操作方法注入
把User模型绑定到当前请求对象：
Request::instance()->bind('user', \app\index\model\User::get(1));
然后就可以在操作方法中进行对象参数的自动注入,代码：
namespace app\index\controller;
use app\index\model\User;
use think\Controller;
class Index extends Controller{
  public function hello(User $user){
    return 'Hello,'.$user->name;
  }
}

如果没有事先在Request对象中进行对象绑定的话,调用hello方法的时候user参数会自动实例化,相当于完成了下面的绑定操作：
Request::instance()->bind('user', new \app\index\model\User);
对象自动注入不影响原来的参数绑定。

3、invoke方法自动调用
5.0.2版本开始,如果依赖注入的类有定义一个可调用的静态invoke方法,则会自动调用invoke方法完成依赖注入的自动实例化。

invoke方法的参数是当前请求对象实例,例如：
namespace app\index\model;
use think\Model;
class User extends Model{
  public static function invoke(Request $request){
    $id = $request->param('id');
    return User::get($id);
  }
}

【 请求缓存 】
5.0.1以上版本支持请求缓存功能,支持对请求地址设置缓存访问,并设置有效期

请求缓存仅对GET请求有效,有两种方式可以设置请求缓存：

1、路由参数
可以在路由规则里面定义cache参数开启当前路由规则的请求缓存,例如：
Route::get('new/:id','News/read',['cache'=>3600]);  // 定义GET请求路由规则并设置3600秒的缓存
第二次访问相同的路由地址时会自动获取请求缓存的数据响应输出,并发送304状态码。

默认请求缓存的标识为当前访问的pathinfo地址,可以定义请求缓存的标识
Route::get('new/:id','News/read',[
  'cache' =>  [ 'new/:id/:page',3600]   // 定义GET请求路由规则并设置3600秒的缓存
]);
:id、:page表示使用当前请求的param参数进行动态标识替换,也就是根据id和page变量进行3600秒的请求缓存。

如果cache参数传入false,则表示关闭当前路由的请求缓存(即使开启全局请求缓存)。

请求缓存设置支持缓存标签参数
Route::get('new/:id','News/read',[
  'cache' =>  [ 'new/:id/:page',3600,'news']  // 定义GET请求路由规则 并设置3600秒的缓存
]);

2、动态设置
可以在app_begin行为里面动态设置请求缓存
Request::instance()->cache('blog/:id',3600);  // 表示对blog/:id定义的动态访问地址进行3600秒的请求缓存。

变量支持当前的请求变量(也就是param方法的所有变量)。

可以使用当前的URL地址作为缓存标识
Request::instance()->cache('__URL__',600);

支持对某个URL后缀的请求进行缓存
Request::instance()->cache('[html]',600);
表示对所有的html后缀访问(GET)请求进行10分钟的缓存。

支持缓存标签设置
Request::instance()->cache('blog/:id',600,'blog');

V5.0.4+版本开始可以在模块配置中单独设置开启请求缓存。
路由中设置的请求缓存依然有效并且优先。

请求缓存自动判断,只需要在配置文件中开启：
'request_cache' =>  true,            // 会自动根据当前请求URL地址(只针对GET请求类型)进行请求缓存,全局缓存有效期为3600秒
'request_cache_expire'  =>  3600,
'request_cache_except' => [          // 设置排除规则,设置的规则为不使用请求缓存的地址(不支持变量)开头部分
  '/blog/index',
  '/user/member'
],

</pre>
</div>

<div id="response">
<h2>response</h2><pre>
响应对象Response用于动态响应客户端请求,控制发送给用户的信息,通常用于输出数据给客户端
TP5的Response响应对象由think\Response类或子类完成,App::run()返回一个Response对象实例,最终调用Response对象的send方法完成输出。

【 自动输出 】
大多数情况不需要关注Response对象本身,只需要在控制器的操作方法中return返回数据即可,系统会根据default_return_type和default_ajax_return配置决定响应输出的类型,默认输出Html,可以设置为json、xml
默认的自动响应输出会自动判断是否AJAX请求,如果是的话会自动输出default_ajax_return配置的输出类型。

</pre><pre class="php">
namespace app\index\controller;
class Index{
    public function hello(){
        return ['name' => 'thinkphp', 'status' => '1'];
    }
}

</pre><pre>
【 手动输出 】
在必要的时候可以手动控制输出类型和参数

默认支持的输出类型包括：
输出类型      助手函数    对应Response类
HTML输出      response   \think\Response
渲染模板输出   view       \think\response\View
JSON输出      json       \think\response\Json
JSONP输出     jsonp      \think\response\Jsonp
XML输出       xml        \think\response\Xml
页面重定向    redirect   \think\response\Redirect

每一种输出类型对应一个Response子类,response()函数对应Response基类,也可在应用中自定义Response子类满足特殊需求的输出
这些助手函数的返回值都是Response类或子类的对象实例,所以后续可以调用Response基类或当前子类的相关方法

public static function create($data = '', $type = '', $code = 200, array $header = [], $options = [])

json助手函数
function json($data = [], $code = 200, $header = [], $options = []){
    return \think\Response::create($data, 'json', $code, $header, $options);
}

response助手函数
function response($data = [], $code = 200, $header = [], $type = 'html'){
    return \think\Response::create($data, $type, $code, $header);
}

</pre><pre class="php">
namespace app\index\controller;
class Index{
  public function hello(){
    $data = ['name'=>'thinkphp','status'=>'1'];

    return \think\Response::create($data, 'json');  // 指定json输出类型
    return json($data);                             // 使用系统提供的助手函数输出json,不受配置参数设置的影响
    return json($data, 201);                        // 返回其它的状态码,默认发送的http状态码是200
    return json($data, 201, ['Cache-control' => 'no-cache,must-revalidate']); // 发送更多的响应头信息
    return json($data)->code(201)->header(['Cache-control' => 'no-cache,must-revalidate']); // 链式调用
    return response('Hello,ThinkPHP!');             // 只需要输出一个html格式的内容
  }
}

</pre>

<h4>动态控制响应内容的输出类型</h4><pre class="php">
public function getinfo($type='json'){
  if(!in_array($type, ['json','jsonp','xml'])) $type='json';
  config('default_return_type',$type);   //控制器内部方法内动态配置使数组转换成输出类型为json
  $res=['id' => 1,'name' => 'berlin','works' =>['one' => 'iter','two' => 'cfer',]];
  return $res;
}

</pre><pre>
【 设置数据 】
Response基类提供了data方法用于设置响应数据。
response()->data($data);
json()->data($data);

data方法设置的只是原始数据,并不一定是最终的输出数据,最终的响应输出数据会根据当前的Response响应类型做自动转换的
json()->data($data);  // 最终的输出数据就是json_encode($data)转换后的数据。
如果要获取当前响应对象实例的实际输出数据可以使用getContent方法。

【 设置状态码 】
Response基类提供code方法用于设置响应数据,一般是直接在调用助手函数的时候直接传入状态码,和在后面链式调用code方法等效
除了redirect函数的默认返回状态码是302之外,其它方法没有指定状态码都是返回200状态码
如果要获取当前响应对象实例的状态码的值,可以使用getCode方法。
json($data,201);
view($data,401);
json($data)->code(201);

【 设置头信息 】
可以使用Response类的header设置响应的头信息
json($data)->code(201)->header(['Cache-control' => 'no-cache,must-revalidate']);

header方法支持两种方式设置,传入数组表示批量设置,传入两个参数时第一个参数表示头信息名,第二个参数表示头信息的值
// 单个设置
header('Cache-control', 'no-cache,must-revalidate');
// 批量设置
header([
  'Cache-control' => 'no-cache,must-revalidate',
  'Last-Modified' => gmdate('D, d M Y H:i:s') . ' GMT',
]);

除了header方法之外,Response基类还提供了常用头信息的快捷设置方法：
lastModified    设置Last-Modified头信息
expires         设置Expires头信息
eTag            设置ETag头信息
cacheControl    设置Cache-control头信息
contentType     设置Content-Type头信息

每个Response子类都有默认的contentType信息,一般无需设置。
可以使用getHeader方法获取当前响应对象实例的头信息。

【 设置额外参数 】
有时响应输出需要设置一些额外的参数,json输出时需要设置json_encode方法的额外参数,jsonp输出的时候需要设置jsonp_handler等参数,这些都可以使用options方法来进行处理

json($data)->options('json_encode_param',JSON_PRETTY_PRINT);

传入数组作为参数
jsonp($data)->options([
  'var_jsonp_handler'     => 'callback',
  'default_jsonp_handler' => 'jsonpReturn',
  'json_encode_param'     => JSON_PRETTY_PRINT,
]);

【 重定向 】
如果需要进行一些简单的页面操作提示或重定向,引入traits\controller\Jump就可以使用相关页面跳转和重定向方法
如果控制器类是继承的\think\Controller的话,系统已经自动引入了\traits\controller\Jump,无需再次引入

</pre><pre class="php">
// 当页面传入name参数为thinkphp的时候跳转到欢迎页面,其它情况则跳转到一个guest页面
namespace app\index\controller;
class Index{
  use \traits\controller\Jump;           // 引入了一个Jump trait
  public function index($name=''){
    if ('thinkphp' == $name) {
      $this->success('欢迎使用ThinkPHP5.0','hello');
    } else {
      $this->error('错误的name','guest');
    }
  }
  public function hello(){
    return 'Hello,ThinkPHP!';
  }
  public function guest(){
    return 'Hello,Guest!';
  }
}

// 页面重定向跳转
namespace app\index\controller;
class Index{
  use \traits\controller\Jump;
  public function index($name=''){
    if ('thinkphp' == $name) {
      $this->redirect('http://thinkphp.cn');
    } else {
      $this->success('欢迎使用ThinkPHP','hello');
    }
  }
  public function hello(){
    return 'Hello,ThinkPHP!';
  }
}

</pre><pre>
在任何时候(即使没有引入Jump trait的话)都可以使用系统提供的助手函数redirect函数进行重定向
redirect函数和控制器的redirect方法的参数顺序有所区别

</pre><pre class="php">
namespace app\index\controller;
class Index{
    public function hello(){
        return redirect('http://thinkphp.cn');  // 使用redirect助手函数进行重定向
    }
}

</pre><pre>
【 重定向传参 】
站内重定向支持URL组装,有两种方式组装URL：
第一种是直接使用完整地址(/打头),这种方式会保持原来地址不做任何转换
redirect('/index/index/hello/name/thinkphp');

第二种方式是使用params方法配合,系统内部会自动判断并调用url助手函数进行地址生成
redirect('hello')->params(['name'=>'thinkphp']);
redirect(url('hello',['name'=>'thinkphp']));      // 等效

with方法进行重定向隐式传值,使用的是Session方式隐式传值,并且仅在下一次请求有效,再次访问重定向的地址时无效

</pre><pre class="php">
namespace app\index\controller;
class Index{
    public function index(){
        return redirect('hello')->with('name', 'thinkphp');
    }
    public function hello(){
        $name = session('name');
        return 'hello,' . $name;
    }
}

</pre><pre>
【 记住请求地址 】
重定向时为了便于跳转回来需要记住当前请求地址,可以使用remember方法记住重定向之前的请求地址。

第一次访问index操作的时候会重定向到hello操作并记住当前请求地址,然后操作完成后到restore方法,restore方法则会自动重定向到之前记住的请求地址,完成一次重定向的回归,回到原点,再次刷新页面又可以继续执行

</pre><pre class="php">
namespace app\index\controller;
class Index{
    public function index(){
        if (session('?complete')) {         // 判断session完成标记是否存在
            session('complete', null);      // 删除session
            return '重定向完成,回到原点!';
        } else {
            return redirect('hello')->with('name', 'thinkphp')->remember();  // 记住当前地址并重定向
        }
    }
    public function hello(){
        $name = session('name');
        return 'hello,' . $name . '! <br/><a href="/index/index/restore">点击回到来源地址</a>';
    }

    public function restore(){
        session('complete', true);     // 设置session标记完成
        return redirect()->restore();  // 跳回之前的来源地址
    }
}

</pre>
</div>

<div id="db">
<h2>数据库</h2>
<h3>Db类数据库操作</h3><pre>
TP内置了抽象数据库访问层,把不同的数据库操作封装起来,只需要使用公共的Db类进行操作,而无需针对不同的数据库写不同的代码和底层实现,Db类会自动调用相应的数据库驱动来处理。采用PDO方式,目前包含了Mysql、SqlServer、PgSQL、Sqlite等数据库的支持。

tp5数据查询由低到高分三个层次：
1. 数据库原生查询(SQL查询);
2. 数据库链式查询(查询构造器);
3. 模型的对象化查询;

【 配置数据库连接信息 】
配置参数,默认支持的数据库连接信息：

参数名            默认值             描述
type              无                数据库类型
hostname          127.0.0.1         数据库地址
database          无                数据库名称
username          无                数据库用户名
password          无                数据库密码
hostport          无                数据库端口号
dsn               无                数据库连接dsn信息
params            空                数据库连接参数
charset           utf8              数据库编码
prefix            无                数据库的表前缀
debug             false             是否调试模式
deploy            0                 数据库部署方式:0 集中式(单一服务器),1 分布式(主从服务器)
rw_separate       false             数据库读写是否分离,主从式有效
master_num        1                 读写分离后主服务器数量
slave_no          无                指定从服务器序号
fields_strict     true              是否严格检查字段是否存在
resultset_type    array             数据集返回类型
auto_timestamp    false             自动写入时间戳字段
sql_explain       false             是否需要进行SQL性能分析,开启调试有效
query             think\db\Query    指定查询对象
builder           无                指定数据库Builder对象

1、配置文件
常用的配置方式是在应用目录或模块目录下的database.php中添加配置参数

type参数表示数据库类型,支持命名空间完整定义,不带命名空间定义则默认采用\think\db\connector作为命名空间,如果使用应用自己扩展的数据库驱动,例如配置数据库的连接器采用\org\db\Mysql类作为数据库连接驱动：
'type'  => '\org\db\Mysql'

支持Mysql的断线重连机制默认关闭
如果使用的是长连接或命令行,在超出一定时间后数据库连接会断开,这时需要开启断线重连才能确保应用不中断。
在数据库配置文件中设置： 'break_reconnect' => true,
开启后系统会自动判断数据库断线并尝试重新连接。大多数情况下都能自动识别,V5.1.6+版本以上如果在一些特殊的情况下或某些数据库驱动的断线标识错误还没有定义,支持在break_match_str配置中加入数据库错误信息关键词
'break_match_str' => ['error with']  // 断线标识字符串

params参数配置任何PDO支持的连接参数
可针对不同的连接需要添加数据库的连接参数,内置采用的参数包括如下：
PDO::ATTR_CASE              => PDO::CASE_NATURAL,
PDO::ATTR_ERRMODE           => PDO::ERRMODE_EXCEPTION,
PDO::ATTR_ORACLE_NULLS      => PDO::NULL_NATURAL,
PDO::ATTR_STRINGIFY_FETCHES => false,
PDO::ATTR_EMULATE_PREPARES  => false,

在database中设置的params参数中的连接配置将会和内置的设置参数合并
'params' => [
    \PDO::ATTR_PERSISTENT   => true,                 // 使用长连接
    \PDO::ATTR_CASE         => \PDO::CASE_LOWER,     // 返回数据库的小写列名
],

2、方法配置
可以在调用Db类的时候动态定义连接信息

Db::connect([
  'type' => 'mysql',
  'dsn' => '',
  'hostname' => '127.0.0.1',
  'database' => 'thinkphp',
  'username' => 'root',
  'password'  => '',
  'hostport' => '',
  'params' => [],
  'charset' => 'utf8',
  'prefix' => 'think_',
]);

或使用字符串方式连接数据库,但可能无法定义某些参数,例如前缀和连接参数
数据库类型://用户名:密码@数据库地址:数据库端口/数据库名#字符集
$db = Db::connect('mysql://root:1234@127.0.0.1:3306/thinkphp#utf8');

如果已经在应用配置文件(不是数据库配置文件)中配置了额外的数据库连接信息,例如：

//数据库配置1
'db_config1' => [
  'type' => 'mysql',
  'hostname' => '127.0.0.1',
  'database' => 'thinkphp',
  'username' => 'root',
  'password' => '',
  'charset' => 'utf8',
  'prefix' => 'think_',
],
//数据库配置2
'db_config2' => 'mysql://root:1234@localhost:3306/thinkphp#utf8';

可以改成
$db = Db::connect('db_config1');
$db = Db::connect('db_config2');

3、模型类定义
如果在某个模型类里面定义了connection属性则该模型操作的时候会自动连接给定的数据库连接,而不是配置文件中设置的默认连接信息,通常用于某些数据表位于当前数据库连接之外的其它数据库

TP的数据库连接是惰性的,所以并不是在实例化的时候就连接数据库,而是在有实际的数据操作的时候才会去连接数据库。

</pre><pre class="php">
//在模型里单独设置数据库连接信息
namespace app\index\model;
use think\Model;
class User extends Model{
  protected $connection = [
    'type'        => 'mysql',
    'dsn'         => '',
    'hostname'    => '127.0.0.1',
    'database'    => 'thinkphp',
    'username'    => 'root',
    'password'    => '',
    'hostport'    => '',
    'params'      => [],
    'charset'     => 'utf8',
    'prefix'      => 'think_',
  ];

  // 也可以采用DSN字符串方式定义,在模型里单独设置数据库连接信息
  protected $connection = 'mysql://root:1234@127.0.0.1:3306/thinkphp#utf8';

  // 并且支持直接使用数据库连接的配置名称,在模型里单独设置数据库连接信息
  protected $connection = 'db_config1';
}

</pre><pre>
【 数据库调试模式 】
无论应用是否部署模式,数据库有自己独立的调试模式开关,数据库配置参数中的debug参数就是数据库调试模式的开关,默认关闭
'debug' => true,  // 数据库调试模式

数据库调试模式开启后可以支持下列行为：
记录SQL日志;
分析SQL性能;
支持SQL监听;
由于上述行为不可避免会产生额外的开销,因此对性能存在不大的影响,因为所有的日志是最终统一一次性写入,而且可以设置为某个用户才写入日志。

在生产模式下面必须关闭应用调试模式(app_debug),否则会暴露服务器敏感信息,但开启数据库调试模式并不会对外暴露任何安全信息

【 监听sql 】
开启数据库的调试模式可以对数据库执行的任何SQL操作进行监听,默认如果没有注册任何监听操作的话,这些SQL执行会被根据不同的日志类型记录到日志中。

Db::listen(function($sql, $time, $explain){
    echo $sql. ' ['.$time.'s]';  // 记录SQL
    dump($explain);              // 查看性能分析结果
});

master参数用于标记当前的主从查询
Db::listen(function ($sql, $time, $explain, $master) {
    echo $sql . ' [' . $time . 's] ' . ($master ? 'master' : 'slave');  // 记录SQL
    dump($explain);   // 查看性能分析结果
});

【 getTableInfo获取表信息 】
信息类型包括fields、type、bind,pk,以数组的形式展示,可以指定某个信息进行获取
Db::getTableInfo('think_user');             // 获取`think_user`表所有信息
Db::getTableInfo('think_user', 'fields');   // 获取`think_user`表所有字段
Db::getTableInfo('think_user', 'type');     // 获取`think_user`表所有字段的类型
Db::getTableInfo('think_user', 'pk');       // 获取`think_user`表的主键

</pre>

<h3>原生查询</h3><pre>
配置数据库连接信息后就可以直接使用数据库运行原生SQL操作了,Db类支持query(查询操作)和execute(写入操作)方法进行原生SQL查询操作,并且支持参数绑定

query方法用于执行SQL查询操作,如果数据非法或查询错误则返回false,否则返回查询结果数据集(同select方法)或空数组
如果采用了分布式数据库并且设置了读写分离,query方法始终是在读服务器执行,因此query方法对应的都是读操作,而不管SQL语句是什么
$result = Db::query('select * from think_data where id = 5');
$result = Db::query('show tables from demo');

execute方法用于更新和写入数据的sql操作,如果数据非法或查询错误则返回false,否则返回影响的记录数。
如果采用了分布式数据库并且设置读写分离,execute方法始终是在写服务器执行,因此execute方法对应的都是写操作,而不管SQL语句是什么
$result = Db::execute('insert into think_data (id, name ,status) values (5, "thinkphp",1)');
$result = Db::execute('update think_data set name = "framework" where id = 5 ');
$result = Db::execute('delete from think_data where id = 5 ');
$result = Db::execute('TRUNCATE table think_data');

参数绑定机制让数据库操作更安全
Db::query('select * from think_user where id=?', [8]);
Db::execute('insert into think_user (id, name) values (?, ?)', [8,'thinkphp']);

命名占位符绑定
Db::query('select * from think_user where id=:id', ['id'=>8]);
Db::execute('insert into think_user (id, name) values (:id, :name)', ['id'=>8,'name'=>'thinkphp']);

进行数据库查询时支持切换数据库(配置)进行查询
Db::connect($config)->query('select * from think_user where id=:id',['id'=>8]);
$config是一个单独的数据库配置,支持数组和字符串,也可以是一个数据库连接的配置参数名

$db = Db::connect($config);
$db->query('select * from think_data where id = 1');

</pre>

<h3>查询构造器</h3><pre>
除了原生查询外,5.0还提供了数据库查询构造器,可以更方便执行数据库操作,查询构造器基于PDO实现,对不同的数据库驱动都是统一的语法
TP5.0查询构造器使用PDO参数绑定,以保护应用程序免于SQL注入,因此传入的参数不需额外转义特殊字符

查询构造器包含以下内容
查询数据
添加数据
更新数据
删除数据
查询表达式
链式操作
聚合查询
时间查询
高级查询
视图查询
JSON字段
子查询
原生查询

</pre>

<h3>查询数据</h3><pre>
如果数据表没有使用表前缀功能,那么name和table方法的一样的效果
在find和select方法之前可以使用所有的链式操作方法。
默认find和select方法返回的都是数组,find使用limit 1
find方法用于查找满足条件第一个记录,如果查询成功返回一个一维数组,没有满足条件则默认返回null,也支持设置是否抛出异常
select方法用于查询数据集,如果查询成功返回一个二维数组,没有满足条件的话则返回空数组,也支持设置是否需要抛出异常

【 table方法必须指定完整的数据表名 】
table方法不会改变数据库的连接,所以要确保当前连接的用户有权限操作相应的数据库和数据表。
一般情况下操作模型的时候系统能够自动识别当前对应的数据表,所以使用table方法的情况通常是为了：
1、切换操作的数据表,切换数据表后系统会自动重新获取切换后的数据表的字段缓存信息
2、对多表进行操作;

Db::table('think_user')->where('id',1)->find();                // 查询一个数据,find方法查询结果不存在返回null
Db::table('think_user')->where('status',1)->select();          // 查询数据集,select方法查询结果不存在返回空数组
Db::table('db_name.think_user')->where('status>1')->select();  // 在table方法中指定数据库
Db::table('__USER__')->where('status>1')->select(); //简化数据表前缀的传入,自动获取当前模型对应的数据表前缀来生成think_user数据表名

对多表进行操作
Db::field('user.name,role.title')
  ->table('think_user user,think_role role')
  ->limit(10)
  ->select();

为了尽量避免因为表名和mysql的关键字冲突,可以建议使用数组方式定义
Db::field('user.name,role.title')
  ->table(['think_user'=>'user','think_role'=>'role'])
  ->limit(10)
  ->select();

【 name方法已设置了表前缀 】
Db::name('user')->where('id',1)->find();
Db::name('user')->where('status',1)->select();

【 助手函数db() 】
db('user')->where('id',1)->find();
db('user')->where('status',1)->select();

第二参数为数据库连接参数,空表示采用配置文件,第三参数false表示使用同一个数据库连接,而不是每次重新连接
使用db助手函数默认每次都会重新连接数据库,Db::name或Db::table方法都是单例的
db('user',[],false)->where('id',1)->find();
db('user',[],false)->where('status',1)->select();

【 JSON类型数据查询 】
db('user')->where('info$.email','thinkphp@qq.com')->find(); // 查询JSON类型字段,info字段为json类型

【 使用Query对象查询对象或闭包查询 】
$query = new \think\db\Query();
$query->table('think_user')->where('status',1);
Db::find($query);
Db::select($query);

直接使用闭包函数查询
Db::select(function($query){
    $query->table('think_user')->where('status',1);
});

【 字段查询value() 】
db('user')->where('id',1)->value('name'); //查询name字段的值,返回一个变量,而不是数组,结果不存在则返回null

【 列查询column() 】
db('user')->where('status',1)->column('name');      // 返回数组,结果不存在则返回空数组
db('user')->where('status',1)->column('name','id'); // 指定索引

【 数据集分批处理 chunk(100, function) 】
chunk方法一次获取结果集的一小块,然后填充每一小块数据到要处理的闭包,该方法在编写处理大量数据库记录时非常有用,例如查询所有的数据并导出到excel

//从数据集中每次取100条纪录交给闭包函数处理
db('user')->where('score','>',80)->chunk(100, function($users) {
	foreach ($users as $user) {
		return false;  //通过从闭包函数中返回false来中止对数据集的处理
	}
});

db('user')->chunk(100, 'myUserIterator');  //交给回调方法myUserIterator处理

chunk方法的处理默认是根据主键查询,如果不希望使用主键进行查询或没有主键则需要指定查询的排序字段,但必须是唯一的,如uid
Db::table('think_user')->chunk(100, function($users) {
    // 处理结果集...
    return false;
},'create_time');

chunk方法支持指定处理数据的顺序
Db::table('think_user')->chunk(100, function($users) {
    // 处理结果集...
    return false;
},'create_time', 'desc');

【 主从查询 】
如果使用了分布式数据库,那么默认查询操作都是在从数据库中进行,在一些特殊的情况下需要从主库读取数据,可以使用：
$data = ['foo' => 'bar', 'bar' => 'foo'];
Db::table('think_user')->insert($data);
Db::name('user')->master()->where('id',1)->find();

支持一旦某个表写入了数据,那么当前请求的后续查询操作都可以自动从主库读取,需要在数据库配置文件中增加下面的配置参数：
'read_master' =>  true,  // 从主库读取数据

如果只需要对某个表进行操作可以使用readMaster方法。
$data = ['foo' => 'bar', 'bar' => 'foo'];
Db::table('think_user')->readMaster()->insert($data); // 后续所有关于该数据表的查询都会走主库

也可以让后续所有数据表的查询都走主库
$data = ['foo' => 'bar', 'bar' => 'foo'];
Db::table('think_user')->readMaster(true)->insert($data);  // 后续所有数据表的查询都会走主库

</pre>

<h3>添加数据</h3><pre>
$data = ['foo' => 'bar', 'bar' => 'foo'];
Db::table('think_user')->insert($data);  // 返回添加成功的条数
Db::name('user')->insert($data);         // database.php配置数据库前缀(prefix)则可以直接使用Db类的name方法提交数据

db('user')->insert($data);
$userId = db('user')->getLastInsID();    //返回新增数据的自增主键

db('user')->insertGetId($data);          //新增数据成功并返回新增数据的自增主键

$data = [
	['foo' => 'bar', 'bar' => 'foo'],
	['foo' => 'bar1', 'bar' => 'foo1'],
	['foo' => 'bar2', 'bar' => 'foo2']
];
db('user')->insertAll($data);            // 添加多条数据,返回添加成功的条数

快捷更新方法data,可以配合insert使用
db('data')->data(['name'=>'tp','score'=>1000])->insert();

</pre>

<h3>更新数据</h3><pre>
db('user')->where('id', 1)->update(['name' => 'thinkphp']);  //返回影响数据的条数,没有修改任何数据则返回0
db('user')->update(['name' => 'thinkphp','id'=>1]);          //数据中包含主键

更新的数据需要使用SQL函数或其它字段
Db::table('think_user')
->where('id', 1)
->update([
    'login_time'  => ['exp','now()'],
    'login_times' => ['exp','login_times+1'],
]);

V5.0.18+版本开始是数组中使用exp查询和更新的话,必须改成下面的方式：
db('user')
->where('id', 1)
->update([
  'login_time'  => Db::raw('now()'),
  'login_times' => Db::raw('login_times+1'),
]);

db('user')->where('id',1)->setField('name', 'thinkphp'); //更新某个字段的值,返回影响数据的条数,没修改返回0

自增或自减一个字段的值,返回影响数据的条数,setInc/setDec支持延时更新
db('user')->where('id', 1)->setInc('score');     // score 字段加 1
db('user')->where('id', 1)->setInc('score', 5);  // score 字段加 5
db('user')->where('id', 1)->setDec('score');     // score 字段减 1
db('user')->where('id', 1)->setDec('score', 5);  // score 字段减 5
db('user')->where('id', 1)->setInc('score', 1, 10); //延迟10s自增1

链式操作
db('data')
->where('id',1)
->inc('read')
->dec('score',3)
->exp('name','UPPER(name)')
->update();

</pre>

<h3>删除数据</h3><pre>
delete方法返回影响数据的条数,没有删除返回 0

// 根据主键删除
db('user')->delete(1);
db('user')->delete([1,2,3]);
// 条件删除
db('user')->where('id',1)->delete();
db('user')->where('id','<',10)->delete();

</pre>

<h3>条件查询方法</h3><pre>
$map['id'] = ['>',1];                               //表达式查询
$map['mail'] = ['like','%thinkphp@qq.com%'];
db('user')->where($map)->select();

db('user')->where('type=1 AND status=1')->select();          //字符串条件
db('user')->where("id=:id and name=:name")->bind(['id'=>[1,\PDO::PARAM_INT],'name'=>'thinkphp'])->select();//配合预处理机制

db('user')->where('name','like','%thinkphp')->where('status',1)->find();
db('user')->where('name&title','like','%thinkphp')->find();  // 快捷查询

db('user')->where('name','like','%thinkphp')->whereOr('title','like','%thinkphp')->find();
db('user')->where('name|title','like','%thinkphp')->find();  // 快捷查询

【 快捷查询 】
Db::table('think_user')
  ->where('name|title','like','thinkphp%')
  ->where('create_time&update_time','>',0)
  ->find();
SELECT * FROM `think_user` WHERE ( `name` LIKE 'thinkphp%' OR `title` LIKE 'thinkphp%' ) AND ( `create_time` > 0 AND `update_time` > 0 ) LIMIT 1

【 where whereOr混合查询 】
$result = db('user')->where(function ($query) {
  $query->where('id', 1)->whereor('id', 2);
})->whereOr(function ($query) {
  $query->where('name', 'like', 'think')->whereOr('name', 'like', 'thinkphp');
})->select();
SELECT * FROM `think_user` WHERE (`id` = 1 OR `id` = 2) OR (`name` LIKE 'think' OR `name` LIKE 'thinkphp')

where('字段名','表达式','查询条件');
whereOr('字段名','表达式','查询条件');

表达式 		    含义
eq、= 		      等于,where('id','eq',100); where('id','=',100); where('id',100);
neq、<>	      不等于
lt、< 		      小于
elt、<= 	      小于等于
gt、> 		      大于,where('score','>',80)
egt、>= 	      大于等于
[not] like		模糊查询,where('name','like',['%think','php%']), where('name','like',['%think','php%'],'OR');
[not] between (不在)区间查询,where('id','between','1,8') ==where('id','between',[1,8]);
[not] in 		  (不在)IN查询,查询条件支持字符串或数组,where('id','not in','1,5,8');==where('id','not in',[1,5,8])
[not] null 		 查询字段是否是NULL where('title','null');  字段值为字符串'not null':where('name','=','not null');
[not] exists 	   EXISTS查询
exp 			       表达式查询,支持SQL语法 where('id','in','1,3,8')==where('id','exp',' IN (1,3,8) ')
< time 			     时间比较
> time 			     时间比较
between time     时间比较
notbetween time  时间比较

【 区间查询 】
区间查询是一种同一字段多个查询条件的简化写法,区间查询的查询条件必须使用数组定义方式,支持所有的查询表达式

Db::table('think_user')
  ->where('name',['like','thinkphp%'],['like','%thinkphp'])
  ->where('id',['>',0],['<>',10],'or')
  ->find();
SELECT * FROM `think_user` WHERE ( `name` LIKE 'thinkphp%' AND `name` LIKE '%thinkphp' ) AND ( `id` > 0 OR `id` <> 10 ) LIMIT 1

【 批量查询 】
db('user')
  ->where([
    'name' => ['like','thinkphp%'],
    'title' => ['like','%thinkphp'],
    'id' => ['>',0],
    'status'=> 1
  ])
  ->select();

【 闭包查询 】
Db::table('think_user')->select(function($query){
    $query->where('name','thinkphp')->whereOr('id','>',10);
});

【 使用Query对象查询 】
如果使用Query对象的话,select方法之前调用的任何的链式操作都是无效
也可以事先封装Query对象,并传入select方法

$query = new \think\db\Query;
$query->name('user')->where('name','like','%think%')->where('id','>',10)->limit(10);
Db::select($query);

【 混合查询 】
可以结合前面提到的所有方式进行混合查询

Db::table('think_user')
  ->where('name',['like','thinkphp%'],['like','%thinkphp'])
  ->where(function($query){
      $query->where('id',['<',10],['>',100],'or');
  })
  ->select();

【 字符串条件查询 】
对于一些实在复杂的查询,也可以直接使用原生SQL语句进行查询

Db::table('think_user')
  ->where('id > 0 AND name LIKE "thinkphp%"')
  ->select();

为了安全起见可以对字符串查询条件使用参数绑定,避免注入
Db::table('think_user')
  ->where('id > :id AND name LIKE :name ',['id'=>0, 'name'=>'thinkphp%'])
  ->select();

TP支持对同一个字段多次调用查询条件
Db::table('think_user')
  ->where('name','like','%think%')
  ->where('name','like','%php%')
  ->where('id','in',[1,5,80,50])
  ->where('id','>',10)
  ->find();

【 快捷方法 】
whereNull       查询字段是否为Null
whereNotNull    查询字段是否不为Null
whereIn         字段IN查询
whereNotIn      字段NOT IN查询
whereBetween    字段BETWEEN查询
whereNotBetween 字段NOT BETWEEN查询
whereLike       字段LIKE查询
whereNotLike    字段NOT LIKE查询
whereExists     EXISTS条件查询
whereNotExists  NOT EXISTS条件查询
whereExp        表达式查询

【 时间查询 】
第三个参数可以传入任何有效的时间表达式,会自动识别时间字段类型,支持的时间类型包括timestamps、datetime、date和int
where('create_time','<= time','2016-1-1');
where('create_time','> time','2016-1-1');
where('create_time','between time',['2015-1-1','2016-1-1']);

db('user')->whereTime('birthday', '>=', '1970-10-1')->select();
db('user')->whereTime('birthday', 'between', ['1970-10-1', '2000-10-1'])->select();
db('user')->whereTime('birthday', 'not between', ['1970-10-1', '2000-10-1'])->select();

db('blog')->whereTime('create_time', 'today')->select();     // 获取今天的博客
db('blog')->whereTime('create_time', 'yesterday')->select(); // 获取昨天的博客
db('blog')->whereTime('create_time', 'week')->select();      // 获取本周的博客
db('blog')->whereTime('create_time', 'last week')->select(); // 获取上周的博客
db('blog')->whereTime('create_time', 'month')->select();     // 获取本月的博客
db('blog')->whereTime('create_time', 'last month')->select();// 获取上月的博客
db('blog')->whereTime('create_time', 'year')->select();      // 获取今年的博客
db('blog')->whereTime('create_time', 'last year')->select(); // 获取去年的博客

db('blog')->whereTime('create_time', 'd')->select();         // 获取今天的博客
db('blog')->whereTime('create_time', 'w')->select();         // 获取本周的博客
db('blog')->whereTime('create_time', 'm')->select();         // 获取本月的博客
db('blog')->whereTime('create_time', 'y') ->select();        // 获取今年的博客

db('blog')->whereTime('create_time','-2 hours')->select();   // 查询两个小时内的博客

</pre>

<h3>链式操作</h3><pre>
select方法必须放到最后,因为select方法并不是链式操作方法,链式操作的方法调用顺序没有先后
所有CURD方法都可以使用链式操作,链式操作在完成查询后会自动清空链式操作的所有传值,即链式操作的结果不会带入后面的其它查询

db('user')
  ->where('status',1)
  ->order('create_time')
  ->limit(10)
  ->select();

Db::table('think_user')
  ->where('status',1)
  ->where('id',1)
  ->delete();

系统支持的链式操作方法有：
所有的连贯操作都返回当前的模型实例对象(this),其中带*标识的表示支持多次调用

连贯操作       作用                            支持的参数类型
where*        用于AND查询                      字符串、数组和对象
whereOr*      用于OR查询                       字符串、数组和对象
wheretime*    用于时间日期的快捷查询            字符串
table         用于定义要操作的数据表名称        字符串和数组
alias         用于给当前数据表定义别名          字符串
field*        用于定义要查询的字段(支持字段排除)字符串和数组
order*        用于对结果排序                    字符串和数组
limit         用于限制查询结果数量              字符串和数字
page          用于查询分页(内部会转换成limit)  字符串和数字
group         用于对查询的group支持             字符串
having        用于对查询的having支持            字符串
join*         用于对查询的join支持              字符串和数组
union*        用于对查询的union支持             字符串、数组和对象
view*         用于视图查询                      字符串、数组
distinct      用于查询的distinct支持            布尔值
lock          用于数据库的锁机制                布尔值
cache         用于查询缓存                      支持多个参数
relation*     用于关联查询                      字符串
with*         用于关联预载入                    字符串、数组
bind*         用于数据绑定操作                  数组或多个参数
comment       用于SQL注释                       字符串
force         用于数据集的强制索引               字符串
master        用于设置主服务器读取数据           布尔值
strict        用于设置是否严格检测字段名是否存在  布尔值
sequence      用于设置Pgsql的自增序列名          字符串
failException 用于设置没有查询到数据是否抛出异常  布尔值
partition     用于设置分表信息                   数组 字符串

【 alias 】
alias用于设置当前数据表的别名,便于使用其他的连贯操作例如join方法等

db('user')->alias('a')->join('__DEPT__ b ','b.uid= a.id')->select();
SELECT * FROM think_user a INNER JOIN think_dept b ON b.uid= a.id

db('user')->alias(['think_user'=>'user','think_dept'=>'dept'])->join('think_dept','dept.uid= user.id')->select();
SELECT * FROM think_user a INNER JOIN think_dept b ON b.uid= a.id

【 field 】
db('user')->field('id,title')->select();            // SELECT id,title FROM think_user
db('user')->field(['id','title'])->select();
db('user')->field('id,nickname as name')->select(); // 给字段设置别名,SELECT id,nickname as name FROM table
db('user')->field(['id','nickname'=>'name'])->select();
db('user')->select();                               // 获取所有字段数据
db('user')->field('*')->select();                   // 获取所有字段数据,同上
db('user')->field(true)->select();                  // 获取所有字段名称
db('user')->field('id,SUM(score)')->select();       // 使用SQL函数,SELECT id,SUM(score) FROM table

字段排除功能不支持跨表和join操作
db('user')->field('content',true)->select();        //排除content字段,使用TRUE参数
db('user')->field('user_id,content',true)->select();
db('user')->field(['user_id','content'],true)->select();

field方法结合insert方法完成表单提交的字段合法检测,只希望用户提交表单中的title、email、content三个合法字段
db('user')->field('title,email,content')->insert($data);

在开启数据表字段严格检查的情况下,提交了非法字段会抛出异常,可以在数据库设置文件中设置：
// 关闭严格字段检查
'fields_strict' =>  false,

系统还提供了fieldRaw方法,用于更安全的指定字段,尤其是使用了SQL函数的情况
db('user')->fieldRaw('title,email,content,max(score) as max_score')->insert($data);

【 order limit 】
order($field,'desc/asc')
db('user')->where('status=1')->order('id desc')->limit(5)->select();
db('user')->where('status=1')->order('id desc,status')->limit(5)->select();
db('user')->where('status=1')->order(['order','id'=>'desc'])->select(); // 字段和mysql关键字冲突时用数组

当order排序中使用了SQL函数时使用orderRaw方法替代order
db('user')->where('status=1')->orderRaw('rand()')->limit(5)->select();

db('user')->where('score=100')->limit(3)->update(['level'=>'A']); // 也可用于写操作,更新满足要求的3条数据
db('article')->limit(10,25)->select();     //分页查询,从10开始的25条纪录
db('article')->limit('10,25')->select();

【 page分页查询 】
page方法是thinkphp为分页查询定义的方法,不需要计算每个分页数据的起始位置,page方法内部会自动计算
比limit方法安全,不会因为参数错误而报错

db('article')->limit('0,10')->select();  // 查询第一页数据,每页十条数据
db('article')->limit('10,10')->select(); // 查询第二页数据

db('article')->page('1,10')->select();   // 查询第一页数据,每页十条数据
db('article')->page(2,10)->select();     // 查询第二页数据,同limit的用法支持2个参数的写法

db('article')->limit(25)->page(3)->select();  // limit和page结合,当page方法只有一个值传入的时候,表示第几页
db('article')->page(3,25)->select();          // 同上

【 group 】
连贯操作方法之一,通常用于结合合计函数,根据一个或多个列对结果集进行分组

db('user')->field('user_id,username,max(score)')->group('user_id')->select();
SELECT user_id,username,max(score) FROM think_score GROUP BY user_id

对多个字段分组
db('user')->field('user_id,test_time,username,max(score)')->group('user_id,test_time')->select();
SELECT user_id,test_time,username,max(score) FROM think_score GROUP BY user_id,test_time

【 having方法 】
连贯操作之一,用于配合group方法完成从分组的结果中筛选(通常是聚合条件)数据

db('user')->field('username,max(score)')->group('user_id')->having('count(test_time)>3')->select();
SELECT username,max(score) FROM think_score GROUP BY user_id HAVING count(test_time)>3

【 join 】
连贯操作方法之一,用于根据两个或多个表中的列之间的关系从这些表中查询数据

INNER JOIN: 等同于JOIN(默认的JOIN类型),如果表中有至少一个匹配则返回行
LEFT JOIN: 即使右表中没有匹配,也从左表返回所有的行
RIGHT JOIN: 即使左表中没有匹配,也从右表返回所有的行
FULL JOIN: 只要其中一个表中存在匹配就返回行

object join ( mixed join [, mixed $condition = null [, string $type = 'INNER']] )

join参数要关联的(完整)表名以及别名,支持三种写法：
写法1：[ '完整表名或子查询'=>'别名' ]
写法2：'完整表名 别名'
写法3：'不带数据表前缀的表名'

condition参数关联条件,可以为字符串或数组,为数组时每一个元素都是一个关联条件。
type参数关联类型,可以为:INNER、LEFT、RIGHT、FULL,不区分大小写,默认INNER。

返回值模型对象

//联表查询代替关联模型,如果两表存在相同的字段可以用feild()限制获取的字段
$blog=db('blog')
  ->join('cate','blog.cateid = cate.id','left')
  ->feild(blog.bid,blog.title,blog.pic,blog.click,blog.time,cate.catename)
  ->select();

以下三种写法等同
db('artist')
  ->alias('a')
  ->join('think_work w','a.id = w.artist_id')
  ->join('think_card c','a.card_id = c.id')
  ->select();

db('artist')
  ->alias('a')
  ->join('__WORK__ w','a.id = w.artist_id')
  ->join('__CARD__ c','a.card_id = c.id')
  ->select();

$join = [
  ['think_work w','a.id=w.artist_id'],
  ['think_card c','a.card_id=c.id'],
];
db('user')->alias('a')->join($join)->select();

表名也可以是一个子查询
$subsql = db('work')->where(['status'=>1])->field('artist_id,count(id) count')->group('artist_id')->buildSql();
db('user')->alias('a')->join([$subsql=> 'w'], 'a.artist_id = w.artist_id')->select();
因buildSql返回的语句带有(),所以这里不需要在两端再加上()。

【 UNION操作 】
用于合并两个或多个SELECT语句的结果集,每个union方法相当于一个独立的SELECT语句
UNION内部的SELECT语句必须拥有相同数量的列。列也必须拥有相似的数据类型。同时每条SELECT语句中的列的顺序必须相同

Db::field('name')
	->table('think_user_0')
	->union('SELECT name FROM think_user_1')
	->union('SELECT name FROM think_user_2')
	->select();

Db::field('name')
	->table('think_user_0')
	->union(['SELECT name FROM think_user_1','SELECT name FROM think_user_2'])
	->select();

Db::field('name')   		//闭包用法
	->table('think_user_0')
	->union(function($query){
		$query->field('name')->table('think_user_1');
	})
	->union(function($query){
		$query->field('name')->table('think_user_2');
	})
	->select();

支持UNION ALL操作
Db::field('name')
  ->table('think_user_0')
  ->union('SELECT name FROM think_user_1',true)
  ->union('SELECT name FROM think_user_2',true)
  ->select();

Db::field('name')
  ->table('think_user_0')
  ->union(['SELECT name FROM think_user_1','SELECT name FROM think_user_2'],true)
  ->select();

【 distinct方法 】
用于返回唯一不同的值

db('user')->distinct(true)->field('user_login')->select();  // 返回user_login字段不同的数据
SELECT DISTINCT user_login FROM think_user

【 Lock方法 】
用于数据库的锁机制,如果在查询或执行操作的时候使用就会自动在生成的SQL语句最后加上FOR UPDATE或FOR UPDATE NOWAIT(Oracle数据库)。
Db::name('user')->where('id',1)->lock(true)->find();

lock方法支持传入字符串用于一些特殊的锁定要求
Db::name('user')->where('id',1)->lock('lock in share mode')->find();

【 cache方法 】
用于查询缓存操作,是连贯操作方法之一,可以用于select、find 、value和column方法及其衍生方法
使用cache方法后在缓存配置的有效期之内不会再次进行数据库查询操作,而是直接获取缓存中的数据

db('user')->where('id=5')->cache(true)->find();

db('user')->cache(true,60)->find();  // 默认缓存有效期由缓存配置决定,但cache方法可以单独指定,等效于下
db('user')->cache(60)->find();

db('user')->cache('key',60)->find(); // 指定查询缓存的标识可以使得查询缓存更有效率
$data = \think\Cache::get('key');    // 然后在外部就可以通过\think\Cache类直接获取查询缓存的数据

db('user')->cache('key',60,'tagName')->find(); // 设置缓存标签

缓存自动更新
缓存自动更新是指一旦数据更新或删除后会自动清理缓存,下次获取的时候会自动重新缓存

删除或更新数据时可以使用cache方法手动更新清除缓存
db('user')->cache('user_data')->select([1,3,5]);
db('user')->cache('user_data')->update(['id'=>1,'name'=>'thinkphp']);
db('user')->cache('user_data')->select([1,5]);
最后查询的数据不会受第一条查询缓存的影响,确保查询和更新或删除使用相同的缓存标识才能自动清除缓存。

如果使用find方法并且使用主键查询的情况,不需要指定缓存标识,会自动清理缓存
db('user')->cache(true)->find(1);
db('user')->update(['id'=>1,'name'=>'thinkphp']);
db('user')->cache(true)->find(1);
最后查询的数据会是更新后的数据。

【 comment方法 】
用于在生成的SQL语句中添加注释内容

db('score')->comment('查询考试前十名分数')
  ->field('username,score')
  ->limit(10)
  ->order('score desc')
  ->select();

SELECT username,score FROM think_score ORDER BY score desc LIMIT 10 /* 查询考试前十名分数*/

【 fetchSql方法 】
用于直接返回SQL而不是执行查询,适用于任何的CURD操作方法

$result = db('user')->fetchSql(true)->find(1);
输出result结果为： SELECT * FROM think_user where id = 1

【 force方法 】
用于数据集的强制索引操作
db('user')->force('user')->select();  // 对查询强制使用user索引,user必须是数据表实际创建的索引名称

【 bind方法 】
用于手动参数绑定,大多数情况无需进行手动绑定,系统会在查询和写入数据的时候自动使用参数绑定。

// 用于查询
Db::table('think_user')
  ->where('id',':id')
  ->where('name',':name')
  ->bind(['id'=>[10,\PDO::PARAM_INT],'name'=>'thinkphp'])
  ->select();

// 用于写入
Db::table('think_user')
  ->bind(['id'=>[10,\PDO::PARAM_INT],'email'=>'thinkphp@qq.com','name'=>'thinkphp'])
  ->where('id',':id')
  ->update(['name'=>':name','email'=>':email']);

【 partition方法 】
用于数据库水平分表

partition($data, $field, $rule);
$data  分表字段的数据
$field 分表字段的名称
$rule  分表规则
不要使用任何SQL语句中会出现的关键字当表名、字段名,例如order等,会导致数据模型拼装SQL语句语法错误。

// 用于写入
$data = [
  'user_id'   => 110,
  'user_name' => 'think'
];

$rule = [
  'type' => 'mod', // 分表方式
  'num'  => 10     // 分表数量
];

Db::name('log')
  ->partition(['user_id' => 110], "user_id", $rule)
  ->insert($data);

// 用于查询
Db::name('log')
  ->partition(['user_id' => 110], "user_id", $rule)
  ->where(['user_id' => 110])
  ->select();

【 strict方法 】
用于设置是否严格检查字段名
Db::name('user')->strict(false)->insert($data);  // 关闭字段严格检查

系统默认值是由数据库配置参数fields_strict决定,因此修改数据库配置参数可以进行全局的严格检查配置,如下：
'fields_strict' => false,  // 关闭严格检查字段是否存在
如果开启字段严格检查的话,在更新和写入数据库的时候一旦存在非数据表字段的值则会抛出异常。

【 failException 】
设置查询数据为空时是否需要抛出异常,如果不传入任何参数,默认为开启,用于select和find方法
Db::name('blog')->where(['status' => 1])->failException()->select();  // 数据不存在的话直接抛出异常
Db::name('blog')->where(['status' => 1])->failException(false)->select();  // 数据不存在返回空数组不抛异常

或可以使用更方便的查空报错
Db::name('blog')->where(['status' => 1])->selectOrFail();  // 查询多条
Db::name('blog')->where(['status' => 1])->findOrFail();  // 查询单条

</pre>

<h3>聚合查询 用于统计数据</h3><pre>
count 统计数量,参数是要统计的字段名(可选)
max   获取最大值,参数是要统计的字段名(必须)
min   获取最小值,参数是要统计的字段名(必须)
avg   获取平均值,参数是要统计的字段名(必须)
sum   获取总分,参数是要统计的字段名(必须)

db('user')->count();               // 统计用户总数
db('user')->count('id');           // 根据字段统计
db('user')->max('score');          // 获取用户的最大积分
db('user')->where('score>0')->min('score');  // 获取积分大于0的用户最小积分
db('user')->avg('score');          // 获取用户的平均积分
db('user')->sum('score');          // 统计所有用户的总积分

</pre>

<h3>视图查询</h3><pre>
视图查询可以实现不依赖数据库视图的多表查询,并不需要数据库支持视图,是JOIN方法的推荐替代方法,但仅仅支持查询操作
视图查询无需调用table和join方法,并且在调用where和order方法的时候只需要使用字段名而不需要加表名。

Db::view('User', 'id,name')
  ->view('Profile', 'truename,phone,email', 'Profile.user_id=User.id')
  ->view('Score', 'score', 'Score.user_id=Profile.id')
  ->where('score', '>', 80)
  ->select();

// SELECT User.id,User.name,Profile.truename,Profile.phone,Profile.email,Score.score FROM think_user User INNER JOIN think_profile Profile ON Profile.user_id=User.id INNER JOIN think_socre Score ON Score.user_id=Profile.id WHERE Score.score > 80

默认使用INNER join查询,如果需要更改可以使用：
Db::view('User', 'id,name')
  ->view('Profile', 'truename,phone,email', 'Profile.user_id=User.id', 'LEFT')
  ->view('Score', 'score', 'Score.user_id=Profile.id', 'RIGHT')
  ->where('score', '>', 80)
  ->select();

// SELECT User.id,User.name,Profile.truename,Profile.phone,Profile.email,Score.score FROM think_user User LEFT JOIN think_profile Profile ON Profile.user_id=User.id RIGHT JOIN think_socre Score ON Score.user_id=Profile.id WHERE Score.score > 80

可以使用别名：
Db::view('User', ['id' => 'uid', 'name' => 'account'])
  ->view('Profile', 'truename,phone,email', 'Profile.user_id=User.id')
  ->view('Score', 'score', 'Score.user_id=Profile.id')
  ->where('score', '>', 80)
  ->select();

// SELECT User.id AS uid,User.name AS account,Profile.truename,Profile.phone,Profile.email,Score.score FROM think_user User INNER JOIN think_profile Profile ON Profile.user_id=User.id INNER JOIN think_socre Score ON Score.user_id=Profile.id WHERE Score.score > 80

可以使用数组的方式定义表名以及别名
Db::view(['think_user' => 'member'], ['id' => 'uid', 'name' => 'account'])
  ->view('Profile', 'truename,phone,email', 'Profile.user_id=member.id')
  ->view('Score', 'score', 'Score.user_id=Profile.id')
  ->where('score', '>', 80)
  ->select();

// SELECT member.id AS uid,member.name AS account,Profile.truename,Profile.phone,Profile.email,Score.score FROM think_user member INNER JOIN think_profile Profile ON Profile.user_id=member.id INNER JOIN think_socre Score ON Score.user_id=Profile.id WHERE Score.score > 80

</pre><pre class="php">
$uid = db('oauth_access_tokens')->where("access_token",$_GET['access_token'])->value("user_id");
$data = db("oauth_users")->where("user_id", $uid)->find();
print_r($data);

$data = \think\Db::view('oauth_users', 'user_id, username, avatar')
  ->view('oauth_access_tokens', 'user_id', 'oauth_access_tokens.user_id=oauth_users.user_id')
  ->where('oauth_access_tokens.access_token', $_GET['access_token'])
  ->find();
print_r($data);

// 以上都输出
Array(
  [user_id] => 1
  [username] => berlin
  [password] => 123123
  [avatar] => http://www.dahouduan.com/wp-content/uploads/2017/11/avatar.jpg
)

</pre>

<h3>子查询</h3><pre>
使用前两种方法需要自行添加括号

1、select方法的参数为false的时候表示不进行查询只是返回构建SQL
$subQuery = db('user')->field('id,name')->where('id','>',10)->select(false);
SELECT `id`,`name` FROM `think_user` WHERE `id` > 10

2、fetchSql方法表示不进行查询而只是返回构建的SQL语句,并且不仅仅支持select,而是支持所有的CURD查询
$subQuery = db('user')->field('id,name')->where('id','>',10)->fetchSql(true)->select();
SELECT `id`,`name` FROM `think_user` WHERE `id` > 10

3、buildSql 构造子查询,会自动添加括号
$subQuery = db('user')->field('id,name')->where('id','>',10)->buildSql();
( SELECT `id`,`name` FROM `think_user` WHERE `id` > 10 )
db($subQuery.' a')->where('a.name','like','thinkphp')->order('id','desc')->select();
SELECT * FROM ( SELECT `id`,`name` FROM `think_user` WHERE `id` > 10 ) a WHERE a.name LIKE 'thinkphp' ORDER BY `id` desc

4、使用闭包构造子查询
IN/NOT IN和EXISTS/NOT EXISTS之类的查询可以直接使用闭包作为子查询

Db::table('think_user')
  ->where('id','IN',function($query){
      $query->table('think_profile')->where('status',1)->field('id');
  })
  ->select();

SELECT * FROM `think_user` WHERE `id` IN ( SELECT `id` FROM `think_profile` WHERE `status` = 1 )

Db::table('think_user')
  ->where(function($query){
      $query->table('think_profile')->where('status',1);
  },'exists')
  ->find();

SELECT * FROM `think_user` WHERE EXISTS ( SELECT * FROM `think_profile` WHERE `status` = 1 )

V5.0.9+版本开始,比较运算也支持使用闭包子查询

</pre>

<h3>查询事件</h3><pre>
tp5支持数据库的CURD操作事件
before_select事件： select查询前回调
before_find事件：   find查询前回调
after_insert事件：  insert操作成功后回调
after_update事件：  update操作成功后回调
after_delete事件：  delete操作成功后回调

注册数据库查询事件
Query::event('after_insert','callback');
Query::event('before_select',function($options,$query){
  // 事件处理
  return $result;
});

</pre>

<h3>事务操作 InnoDB引擎</h3><pre>
使用transaction方法操作数据库事务,当发生异常会自动回滚,在事务操作的时候确保数据库连接是相同的

自动控制事务处理
Db::transaction(function(){
	Db::table('user')->find(1);
	Db::table('user')->delete(1);
});

手动控制事务
Db::startTrans();  // 启动事务
try{
	Db::table('user')->find(1);
	Db::table('user')->delete(1);
	Db::commit();  // 提交事务
} catch (\Exception $e) {
	Db::rollback();  // 回滚事务
}

</pre>

<h3>存储过程</h3><pre>
$result = Db::query('call sp_query(8)');  // 调用数据库存储过程sp_query,返回的是一个二维数组

使用参数绑定或命名绑定
$result = Db::query('call sp_query(?)',[8]);
$result = Db::query('call sp_query(:id)',['id'=>8]);

</pre>

<h3>分布式数据库</h3><pre>
TP内置了分布式数据库的支持,包括主从式数据库的读写分离,但分布式数据库必须是相同的数据库类型。

分布式数据库配置定义
return [
  'deploy'   =>  1,  // 启用分布式数据库
  'type'     => 'mysql',  // 数据库类型
  'hostname' => '192.168.1.1,192.168.1.2',  // 服务器地址
  'database' => 'demo',  // 数据库名
  'username' => 'root',  // 数据库用户名
  'password' => '',  // 数据库密码
  'hostport' => '',  // 数据库连接端口
]

连接的数据库个数取决于hostname定义的数量,所以即使是两个相同的IP也需要重复定义,但其他的参数如果存在相同的可以不用重复定义,例如：
'hostport'=>'3306,3306' 和 'hostport'=>'3306' 等效。

可设置分布式数据库的读写是否分离,默认读写不分离i每台服务器都可以进行读写操作,主从式数据库需要设置读写分离'rw_separate' => true,
读写分离时默认第一个数据库配置是主服务器的配置信息,负责写入数据
如果设置了master_num参数则可以支持多个主服务器写入,其它的都是从数据库的配置信息,负责读取数据,数量不限制。每次连接从服务器并且进行读取操作时系统会随机进行在从服务器中选择。

slave_no可以设置某个服务器进行读操作。
如果从数据库连接错误会自动切换到主数据库连接。

调用模型的CURD操作时,系统会自动判断当前执行的方法的读操作还是写操作,如果用的是原生SQL,那么需要注意系统的默认规则： 写操作必须用模型的execute方法,读操作必须用模型的query方法,否则会发生主从读写错乱

主从数据库的数据同步工作不在框架实现,需要数据库考虑自身的同步或复制机制。

</pre>
</div>

<div id="model">
<h2>模型</h2>
<p><a href="http://localhost/tp509/public/index.php/admin/flink/addflink.html">实例：tp509添加友情链接</a></p>
<h3>数据库抽象层和模型 tp5数据库架构</h3><pre>
TP5的数据访问层是基于PHP内置的PDO对象实现,所有的数据库查询都使用了PDO的预处理和参数绑定机制
对数据表的CURD操作,除了select和存储过程调用使用query方法之外,其它的操作都使用execute方法

1、Db类
TP5操作数据库的入口类,作用是为连接数据库做准备,只需要在database.php里填写相应的配置即可。
框架并不依赖Db类,该类的存在只是为了简化数据库抽象层的操作而提供的一个工厂类,所有的数据库操作都是经过Db类调用,并且Db类是一个静态类,但Db类自身只有一个公共方法connect

2、Connection类
TP5的连接器类,连接类的基类是think\db\Connection
因为TP5支持四种数据库(Mysql,Pgsql,Sqlite,Sqlsrv),所以TP5封装了一个类来提供统一的调用接口来支持连接数据库,这里的连接是惰性连接,只有在执行SQL的时候才会真正连接
模型可以单独设置数据库连接;如果使用统一的数据库配置,模型使用的连接对象是相同的;

3、Query类
查询器,数据访问层核心只有一个唯一的查询类：think\db\Query,因为不同数据库的SQL语句不同,所以封装了一个Query类来提供统一的接口,以实现不同数据库的CURD操作。查询器是TP5数据访问层的核心,它连接了Connection和Builder。
模型使用的查询对象是独立的,可以使用自定义的查询对象

4、Builder类
生成器,主要是把Query的查询参数生成相应的sql语句,然后把其返回给Connection供其使用。生成类一般不需要自己调用,而是由查询类自动调用的

</pre>

<h3>模型的定义</h3><pre>
TP5.0的模型是一种对象-关系映射(Object Relation Mapping,简称ORM )的封装,并且提供了简洁的ActiveRecord实现。
模型指数据模型,通过ORM对象关系映射的方式,把对资源(数据表)的操作进行的封装(分层或抽象),目的实现清晰的项目结构,提高代码的复用率
一个模型类默认对应关系型数据库中的一个表,但有可能有多个,而模型类的一个实例对应表中的一行记录

ORM的基本特性就是表映射到类,记录映射到对象,字段映射到对象属性。模型是一种对象化的操作封装,而不是简单的CURD操作,简单的CURD操作直接使用Db类即可,模型类和Db类的区别主要在于对象的封装,Db类的查询默认返回的是数组或集合,而模型类返回的是当前的模型对象实例或集合,模型是比Db类更高级的数据封装,支持模型关联、模型事件

Db和模型的存在只是TP5.0架构设计中的职责和定位不同,Db负责的只是数据(表)访问,模型负责的是数据处理和业务逻辑,业务逻辑应当封装到具体模型中,并由控制器来调用,模型的数据底层操作仍然是数据库抽象访问层,而且是自动的
Db和模型最明显的一个区别就是Db查询返回的数据类型为数组(没有业务逻辑的数据数组已经足够),而模型的查询返回类型的是模型对象实例

模型类实现了ArrayAccess接口,因此一样可以使用数组方式操作对象

数据表字段(不需要,会自动获取,并支持缓存机制)
数据表前缀(不支持,模型不关心前缀)
一般数据表和数据库连接不需要定义,数据处理逻辑和业务逻辑才是模型定义的重点
建议数据表的命名不使用前缀设计,表前缀其实已经是一种过时的设计了,很多时候跨库的设计比表前缀的设计来的更灵活和实用

模型的CURD操作最终调用的还是Db类的操作,区别在于使用了ActiveRecord模式和单独做了一层封装而已
除了模型自己的方法操作外,还可以调用Db类的所有查询方法,也就是说Db类的CURD操作方法都可以在模型类中被调用
模型通常会继承think\Model或子类,虚拟模型除外;
模型名和数据表名也不是直接对应关系;
尽管一个空模型和使用Db类无异,但意义不同;
业务逻辑应当封装到具体模型中,并由控制器来调用;

【 模型定义 】
模型定义阶段要达成的目的：
定义数据表(默认就是模型类名)
定义数据表主键(默认会自动获取)
定义数据库连接(默认使用数据库配置)
定义数据处理逻辑(包括属性和方法)
定义业务逻辑(方法)

模型会自动对应一个数据表,规范是：数据库前缀+当前的模型类名(不含命名空间)
因为模型类命名是驼峰法,所以获取实际的数据表的时候会自动转换为小写+下划线命名的数据表名称
模型类的命名规则是除去表前缀的数据表名称,采用驼峰法命名,并且首字母大写
User => think_user
UserType => think_user_type

在模型内部不要使用$this->name的方式来获取数据,使用$this->getAttr('name')替代

</pre>定义一个User模型类<pre class="php">
namespace app\index\model;
use think\Model;

class User extends Model	{
	protected $table = 'think_user';  // 设置数据表的完整名称,也可自动识别
  protected $name = 'member';       // 设置数据表(不含前缀)
	protected $pk = 'uid';            // 默认主键为自动识别,也可以设置属性
	protected $connection = [	        // 设置数据库连接属性,也可配置定义
		'type' => 'mysql',              // 数据库类型
		'hostname' => '127.0.0.1',      // 服务器地址
		'database' => 'thinkphp',       // 数据库名
		'username' => 'root',           // 数据库用户名
		'password' => '',               // 数据库密码
		'charset' => 'utf8',            // 数据库编码默认采用utf8
		'prefix' => 'think_',           // 数据库表前缀
		'debug' => false,               // 数据库调试模式
	];
}

</pre>

<h3>模型的调用</h3><pre>
模型类可以使用静态调用或实例化调用两种方式

静态调用
$user = User::get(1);
$user->name = 'thinkphp';
$user->save();

关键词new实例化模型
$user = new User;

使用Loader类实例化(单例)
$user = Loader::model('User');

使用助手函数model实例化模型(Loader::model)
$user = model('User');
$user->name= 'thinkphp';
$user->save();

【 获取/设置模型数据 】
模型外部获取模型数据        $model->name  # name属性
模型内部获取模型数据         $this->getAttr('name')
模型内部获取(原始)模型数据    $this->getData('name')
getData和getAttr方法的区别:前者是原始数据,后者是经过读取器处理的数据,如果没有定义数据读取器则两个方法的结果相同

对应的设置模型数据的方式也有三种：
模型外部设置模型数据              $model->name='thinkphp'
模型内部设置模型数据(经过修改器) $this->setAttr('name','thinkphp')
模型内部设置模型数据              $this->data('name','thinkphp')
data和setAttr方法的区别:前者是赋值最终数据,后者赋值的数据还会经过修改器处理,如果没有定义修改器则两个方法的结果相同

</pre>

<h3>模型的初始化</h3><pre>
模型初始化方法通常用于注册模型的事件操作
与控制器的初始化不同的是,模型的初始化是重写Model的initialize
也可以使用静态init方法,并且只在第一次实例化的时候执行,并且方法内需要注意静态调用的规范

</pre><pre class="php">
namespace app\index\model;
class User extends \think\Model	{
	protected function initialize(){
		parent::initialize();             // 调用Model的initialize方法
		//TODO:自定义的初始化
	}
}

namespace app\index\model;
class User extends \think\Model	{
	protected static function init(){
		//TODO:自定义的初始化内容
	}
}

</pre>

<h3>模型增删改查操作</h3><pre>
【 TP5数据库的访问有三种方法 】
1、原生sql语句
Db::query('select * from think_user where id=?',[8]);
Db::execute('insert into think_user (id, name) values (?, ?)',[8,'thinkphp']);

2、查询构造器
$user = Db::table('user')->find(1);   // 查询操作
echo $user['name'];                   // 取值操作
echo $user['email'];
$user['name']  = 'topthink';          // 设置操作
$user['email'] = 'thinkphp@qq.com';
Db::table('user')->update($user);     // 更新操作

3、模型操作
$user = User::get(1);                 // 查询操作
echo $user->name;                     // 取值操作
echo $user->email;
$user->name  = 'topthink';            // 设置操作
$user->email = 'thinkphp@qq.com';
$user->save();                        // 更新操作

这里是在模型的外部,也就是控制器里的取值和设置操作,但在模型内部是使用如下方式：
echo $user->getData('name');               // 取值操作
echo $user->getData('email');
echo $user->data('name', 'SpawN');         // 设置操作
echo $user->data('email', '123@qq.com');

【 模型的CURD操作 】
模型的CURD操作最终调用的还是Db类的操作,区别在于使用了ActiveRecord模式和单独做了一层封装而已
除了模型自己的方法操作外,还可以调用Db类的所有方法,也就是说Db类的CURD操作方法都可以在模型类中被调用。
模型类和Db类的查询返回类型是完全不同的,即便是调用同一个方法查询;
模型类封装的静态方法本质上还是调用的动态方法,只是为了方便不同的需求场景;模型对象的查询操作尽量使用静态方法调用;
查询构造器的用法在模型类中没有变化,并且还做了一些增强来支持模型的CURD封装方法。
所有的链式方法都可以直接被模型类静态调用,而且一样不分先后次序,而且模型类不需要调用table方法来指定数据表名称,因为模型已经有自己的对应数据表规则

1、创建
Db用法：
Db::table('user')->insert(['name' => 'spawn','email' => '123@qq.com']);

模型用法:
$user = new User;
$user->save(['name' => 'spawn','email' => '123@qq.com']);  // 返回影响的记录数
或者静态
$user = User::create(['name' => 'sapwn','email' => '123@qq.com']); // 返回模型对象实例,可以直接调用方法

2、读取
find和select是查询构造器的方法,get和all是模型的方法。但模型又是基于查询构造器的,所以模型可以调用find和select方法,但查询构造器不能调用get和all方法

Db：
$user = Db::table('user')->where('id', 1)->find();    // 查询单个记录,返回数组
$user = Db::table('user')->where('id > 1')->select(); // 根据条件查询多个记录,返回数组

模型：
$user = User::get(1);  // 查询单个记录,模型对象实例
$user = User::all();   // 根据主键查询多个记录,包含模型对象实例的数组或者数据集

3、更新
模型的更新操作是只更新有变化的数据,性能比较好

Db：
Db::table('user')->where('id', 1)->update(['name' => 'haha','email' => 'heihei@qq.com']);

模型:
$user = User::get(1);
$user->save(['name' => 'haha','email' => 'heihei@qq.com']);  // 返回影响的记录数
或者静态
User::update(['name'  => 'topthink','email' => 'topthink@qq.com',], ['id' => 1]);  // 返回模型对象实例

4、删除
Db：
Db::table('user')->delete(1);

模型:
$user = User::get(1);
$user->delete();  // 返回影响的记录数
或者静态
User::destory(1); // // 返回影响的记录数

</pre>

<h4>新增</h4><pre>
默认模型实例执行save操作都是执行的数据库insert操作,如果需要save执行数据库的update操作,请确保在save方法之前调用isUpdate方法,isUpdate(true/false)显式的指定当前调用save方法是新增操作还是更新操作
$user->isUpdate()->save();

【 静态方法create 】
create方法可以传入数组或标准对象,返回当前模型的对象实例
$user = User::create(['name'  =>  'thinkphp','email' =>  'thinkphp@qq.com']);
echo $user->name;
echo $user->email;
echo $user->id;     // 获取自增ID

【 添加一条数据 】
save方法新增数据,返回写入的记录数

第一种是实例化模型对象后赋值并保存：
$user        = new User;
$user->name  = 'thinkphp';
$user->email = 'thinkphp@qq.com';
$user->save();
echo $user->id;       // 获取自增ID,获取模型的主键
echo $user->user_id;  // 获取自增ID,主键不是id,而是user_id

在同一个模型实例里多次新增数据则使用isUpdate(false)
$user           = new User;
$user->name     = 'thinkphp';
$user->email    = 'thinkphp@qq.com';
$user->save();
$user->name     = 'onethink';
$user->email    = 'onethink@qq.com';
$user->isUpdate(false)->save();   // 第二次开始必须使用isUpdate(false)的方式新增

使用data方法批量赋值：
$user = new User;
$user->data(['name'  =>  'thinkphp','email' =>  'thinkphp@qq.com' ]);
$user->save();

直接在实例化的时候传入数据
$user = new User(['name'  =>  'thinkphp','email' =>  'thinkphp@qq.com']);
$user->save();

过滤非数据表字段的数据
$user = new User($_POST);
$user->allowField(true)->save();    // 只允许更新数据表字段数据,过滤post数组中的非数据表字段数据

通过外部提交赋值给模型,并且希望指定某些字段写入
$user = new User($_POST);
$user->allowField(['name','email'])->save();  // post数组中只有name和email字段会写入

// 获取当前用户对象
$user = User::get(request()->session('user_id'));
// 只允许更新用户的nickname和address数据
$user->allowField(['nickname', 'address'])->data(requst()->param(), true)->save()
// 只允许更新数据表字段数据
$user->allowField(true)->data(requst()->param(), true)->save();

不必每次都调用allowField方法,可以直接在模型类里面设置field属性
protected $field = ['name', 'nickname', 'email', 'address'];
protected $field = ['id' => 'int','create_time' => 'int','update_time' => 'int','name','title',  'content'];

【 saveAll添加多条数据 批量新增 】
saveAll方法新增数据返回类型受模型的resultSetType属性影响返回的是包含新增模型(带自增ID)的数据集(数组)或数据集对象
saveAll方法新增数据默认会自动识别数据是新增还是更新操作,当数据中存在主键时会认为是更新操作

$user = new User;
$list = [
  ['name'=>'thinkphp','email'=>'thinkphp@qq.com'],
  ['name'=>'onethink','email'=>'onethink@qq.com']
];
$user->saveAll($list);

带主键数据批量更新
$user = new User;
$list = [
  ['id'=>1, 'name'=>'thinkphp', 'email'=>'thinkphp@qq.com'],
  ['id'=>2, 'name'=>'onethink', 'email'=>'onethink@qq.com'],
];
$user->saveAll($list, false);

【 助手函数 】
系统提供了model助手函数用于快速实例化模型,并且使用单例实现

$user = model('User');
$user->data(['name'  =>  'thinkphp', 'email' =>  'thinkphp@qq.com']);  // 模型对象赋值
$user->save();

批量新增：
$user = model('User');
$list = [
    ['name'=>'thinkphp','email'=>'thinkphp@qq.com'],
    ['name'=>'onethink','email'=>'onethink@qq.com']
];
$user->saveAll($list);

</pre><pre class="php">
namespace app\index\controller;
use app\index\model\User as UserModel;
class User{
  // 新增用户数据
  public function add(){
    $user = new UserModel;
    $user->nickname = '流年';
    $user->email = 'thinkphp@qq.com';
    $user->birthday = strtotime('1977-03-05');
    if ($user->save()) {
      return '用户[ ' . $user->nickname . ':' . $user->id . ' ]新增成功';
    } else {
      return $user->getError();
    }
  }

  // 新增用户数据
  public function add2(){
    $user['nickname'] = '看云';
    $user['email'] = 'kancloud@qq.com';
    $user['birthday'] = strtotime('2015-04-02');
    if ($result = UserModel::create($user)) {
      return '用户[ ' . $result->nickname . ':' . $result->id . ' ]新增成功';
    } else {
      return '新增出错';
    }
  }

  // 批量新增用户数据
  public function addList(){
    $user = new UserModel;
    $list = [
      ['nickname' => '张三', 'email' => 'zhanghsan@qq.com', 'birthday' => strtotime('1988-01-15')],
      ['nickname' => '李四', 'email' => 'lisi@qq.com', 'birthday' => strtotime('1990-09-19')],
    ];
    if ($user->saveAll($list)) {
      return '用户批量新增成功';
    } else {
      return $user->getError();
    }
  }

}

</pre>

<h4>更新</h4><pre>
动态更新,返回影响的记录数
$user = User::get(1);
$user->save(['name'  => 'topthink','email' => 'topthink@qq.com',]);

查找并更新
$user = User::get(1);
$user->name  = 'thinkphp';
$user->email = 'thinkphp@qq.com';
$user->save();

直接更新数据,
$user = new User;
$user->save(['name'  => 'thinkphp','email' => 'thinkphp@qq.com'],['id' => 1]); // save方法第二个参数为更新条件

更新数据时过滤非数据表字段的数据
$user = new User();
$user->allowField(true)->save($_POST,['id' => 1]);  // 过滤post数组中的非数据表字段数据

通过外部提交赋值给模型,并且希望指定某些字段写入
$user = new User();
$user->allowField(['name','email'])->save($_POST, ['id' => 1]);  // post数组中只有name和email字段会写入

【 批量更新数据 】
可以使用saveAll方法批量更新数据
批量更新仅能根据主键值进行更新,其它情况使用foreach遍历更新

$user = new User;
$list = [
    ['id'=>1, 'name'=>'thinkphp', 'email'=>'thinkphp@qq.com'],
    ['id'=>2, 'name'=>'onethink', 'email'=>'onethink@qq.com']
];
$user->saveAll($list);

强制进行数据更新操作而不是新增操作,尤其适合于复合主键的情况

$user = new User;
$list = [
    ['id'=>1, 'name'=>'thinkphp', 'email'=>'thinkphp@qq.com'],
    ['id'=>2, 'name'=>'onethink', 'email'=>'onethink@qq.com']
];
$user->isUpdate()->saveAll($list);

【 通过数据库Db类更新数据 】
必要的时候也可以使用数据库对象来直接更新数据,但这样就无法使用模型的事件功能。

$user = new User;
$user->where('id', 1)->update(['name' => 'thinkphp']);

传入update的数据包含主键时可以无需使用where方法
$user = new User;
$user->update(['id' => 1, 'name' => 'thinkphp']);

【 静态方法更新数据,返回模型对象实例,不先读取对应的数据 】
User::where('id', 1)->update(['name' => 'thinkphp']);
User::update(['id' => 1, 'name' => 'thinkphp']);
User::update(['name'  => 'topthink','email' => 'topthink@qq.com',], ['id' => 1]);

【 闭包更新,通过闭包函数使用更复杂的更新条件 】
$user = new User;
$user->save(['name' => 'thinkphp'],function($query){
    $query->where('status', 1)->where('id', '>', 10);  // 更新status值为1 并且id大于10的数据
});

【 自动识别 】
模型的新增和更新方法都是save方法,系统有一套默认的规则来识别当前的数据需要更新还是新增
实例化模型后调用save方法表示新增;
查询数据后调用save方法表示更新;
save方法传入更新条件后表示更新;

默认查询模型数据后返回的模型实例执行save操作都是执行的数据库update操作,如果需要实例化执行save执行数据库的insert操作,请确保在save方法之前调用isUpdate方法,显式的指定当前调用save方法是新增操作还是更新操作
$user->isUpdate(false)->save();

不要在一个模型实例里面做多次更新,会导致部分重复数据不再更新,正确的方式应该是先查询后更新或使用模型类的update方法更新。
ActiveRecord模式的更新数据方式需要首先读取对应的数据,如果需要更高效的方法可以UserModel::update($userdata)
如果调用save方法进行多次数据写入的时候,第二次save方法的时候必须使用isUpdate(false),否则会视为更新数据。

显式更新数据：
$user = new User;  // 实例化模型
$user->isUpdate(true)->save(['id' => 1, 'name' => 'thinkphp']);  // 显式指定更新数据操作

显式新增数据：
$user = User::get(1);
$user->name = 'thinkphp';
$user->isUpdate(false)->save();  // 显式指定当前操作为新增操作

</pre><pre class="php">
namespace app\index\controller;
use app\index\model\User as UserModel;
class User{
  // 对查询出来的数据进行更新操作
  public function update($id){
    $user = UserModel::get($id);
    $user->nickname = '刘晨';
    $user->email = 'liu21st@gmail.com';
    if (false !== $user->save()) {
      return '更新用户成功';
    } else {
      return $user->getError();
    }
  }

  // 更新用户数据,不先读取对应的数据
  public function update($id){
    $user['id'] = (int) $id;
    $user['nickname'] = '刘晨';
    $user['email'] = 'liu21st@gmail.com';
    $result = UserModel::update($user);
    return '更新用户成功';
  }

}

</pre>

<h4>删除</h4><pre>
1.实例化后调用delete方法,根据主键删除模型数据
$user = User::get(1);
$user->delete();

2.直接调用静态方法,根据主键删除
当destroy方法传入空值(包括空字符串和空数组)的时候不会做任何的数据删除操作,但传入0则是有效的
User::destroy(1);
User::destroy('1,2,3');
User::destroy([1,2,3]);

3.条件删除
User::destroy(['status' => 0]);
User::destroy(function($query){ $query->where('id','>',10); });  //使用闭包删除
User::where('id','>',10)->delete();                              //通过数据库类的查询条件删除

</pre><pre class="php">
namespace app\index\controller;
use app\index\model\User as UserModel;
class User{
  // 删除用户数据
  public function delete($id){
    $user = UserModel::get($id);
    if ($user) {
      $user->delete();
      return '删除用户成功';
    } else {
      return '删除的用户不存在';
    }
  }

  // 删除用户数据
  public function delete($id){
    $result = UserModel::destroy($id);
    return $result ? '删除用户成功' : '删除的用户不存在';
  }

}

</pre>

<h4>查询</h4><pre>
get 或 find 方法返回的是当前模型的对象实例,可以使用模型的方法
all 或 select 方法返回的是一个包含模型对象的二维数组或数据集对象
value 和 column 方法返回的不再是一个模型对象实例,而是单纯的值或某个列的数组

如果是在模型内部不要使用$this->name的方式来获取数据,而要使用$this->getAttr('name')替代

【 自定义数据集对象 】
支持在模型中单独设置查询数据集的返回对象的名称(默认是数组)
resultSetType字段为空则使用数组作为数据集返回类型,设置为collection则表示使用think\Collection作为返回对象名,也可以设置自定义的数据集对象名称(使用完整的命名空间定义)

数据集的优势：
数据更对象化
关联操作更方便
数据集本身可以单独定义独立的业务方法

// database.php中设置数据集返回类型
'resultset_type'  => 'collection',

// 模型中设置模型的数据集返回类型
namespace app\index\model;
use think\Model;
class User extends Model{
  protected $resultSetType = 'collection';  // 设置返回数据集的对象名
}

【 查询操作 】
1.获取单个数据
模型的get方法用于获取数据表的数据并返回当前的模型对象实例,通常只需要传入主键作为参数,如果没有传入任何值的话则表示获取第一条数据
模型的get方法和Db类的find方法返回结果的区别在于,Db类默认返回的只是数组,而模型的get方法查询返回的一定是当前的模型对象实例
但系统为模型实现了ArrayAccess接口,因此仍然可以通过数组的方式访问对象实例

public static function get($data, $with = [], $cache = false)

$user = User::get(1);						             //根据主键查询
echo $user->name;

$user = User::get(['name' => 'thinkphp']);   // 使用数组查询

$user = User::get(function($query){          // 使用闭包查询
	$query->where('name', 'thinkphp');
});
echo $user->name;

$user = new User();                         //实例化模型之后调用查询方法
$user->where('name', 'thinkphp')->find();

2.获取多个数据
$list = User::all('1,2,3');          // 根据主键获取多个数据
$list = User::all([1,2,3]);          // 使用数组
$list = User::all(['status'=>1]);    // 使用数组查询
$list = User::all(function($query){  // 使用闭包查询支持更多的连贯操作,包括排序、数量限制等
	$query->where('status', 1)->limit(3)->order('id', 'asc');
});
foreach($list as $key=>$user){
	echo $user->name;
}

$user = new User();                 //实例化模型后调用查询方法
$user->where('name', 'thinkphp')->limit(10)->order('id', 'desc')->select();

3.获取某个字段或某个列的值
User::where('id',10)->value('score');          // 获取某个用户的积分
User::where('status',1)->column('name');       // 获取某个列的所有值,返回一维数组
User::where('status',1)->column('name','id');  // 以id为索引的name列数据一维数组
User::where('status',1)->column('id,name');
User::where('status',1)->column('*', 'id');    // 返回以主键为索引的数据集,返回二维数组

4.动态查询方法
$user = User::getByName('thinkphp');           // 根据name字段查询用户
$user = User::getByEmail('thinkphp@qq.com');   // 根据email字段查询用户

5.通过Query类查询或使用数据库的查询方法进行更复杂的查询,返回的查询结果是当前模型对应的对象或包含模型对象的数据集
User::where('id','>',10)->select();
User::where('name','thinkphp')->find();

6.数据分批处理
User::chunk(100, function($users){
	foreach($users as $user){
		// 处理user模型对象
	}
});

7.查询缓存,get方法和all方法的第二个参数表示是否使用查询缓存或设置缓存标识。
$user = User::get(1, true);
$list = User::all('1,2,3', true);

8.在模型中也可以调用数据库的聚合方法进行查询
静态调用：
User::count();
User::where('status','>',0)->count();
User::where('status',1)->avg('score');
User::max('score');

动态调用：
$user = new User;
$user->count();
$user->where('status','>',0)->count();
$user->where('status',1)->avg('score');
$user->max('score');

【 主库读取 】
如果采用分布式数据库,如果写入数据后立刻进行该数据的读取,将会导致数据读取失败,原因是数据库同步尚未完成。
规范的解决方案是在写入数据后,不要马上从从库读取,而应该调用master方法读取主库。

$user        = new User;
$user->name  = 'thinkphp';
$user->email = 'thinkphp@qq.com';
$user->save();
$user->master()->get($user->id);  // 从主库读取数据

可以在数据库配置文件中设置
// 主库写入后从主从库读取
'read_master' => true
设置开启后,一旦模型写入数据,那么该请求后续的模型读取操作都会自动读取主库。

或可以在完成主库写入操作后,执行下模型类的readMaster方法
$user           = new User;
$user->name     = 'thinkphp';
$user->email    = 'thinkphp@qq.com';
$user->readMaster()->save();     // 后续该模型的操作从主库读取数据

也可以支持后续所有模型的查询都在主库
$user           = new User;
$user->name     = 'thinkphp';
$user->email    = 'thinkphp@qq.com';
$user->readMaster(true)->save();  // 后续该模型的操作从主库读取数据

注意上述设置和方法仅对模型查询有效,直接调用Db类查询无效。

</pre><pre class="php">
namespace app\index\controller;
use app\index\model\User as UserModel;
class User{
  // 读取用户数据
  public function read($id=''){
    $user = UserModel::get($id);
    echo $user->nickname . '<br/>';
    echo $user->email . '<br/>';
    echo date('Y/m/d', $user->birthday) . '<br/>';
    // 系统为模型实现了 ArrayAccess 接口,因此仍然可以通过数组的方式访问对象实例
    echo $user['nickname'] . '<br/>';
    echo $user['email'] . '<br/>';
    echo date('Y/m/d', $user['birthday']) . '<br/>';
  }

  // 根据email读取用户数据
  public function read(){
    $user = UserModel::getByEmail('thinkphp@qq.com');
    echo $user->nickname . $user->email . date('Y/m/d', $user->birthday) . '<br/>';
  }

  // 根据nickname读取用户数据,传入数组作为查询条件
  public function read(){
    $user = UserModel::get(['nickname'=>'流年']);
    echo $user->nickname . $user->email . date('Y/m/d', $user->birthday) . '<br/>';
  }

  // 根据nickname读取用户数据,更复杂的查询则可以使用查询构建器来完成
  public function read(){
    $user = UserModel::where('nickname', '流年')->find();
    echo $user->nickname . $user->email . date('Y/m/d', $user->birthday) . '<br/>';
  }

  // 获取用户数据列表
  public function readall(){
    $list = UserModel::all();
    foreach ($list as $user) {
      echo $user->nickname . $user->email . date('Y/m/d', $user->birthday) . '<br/>';
      echo '----------------------------------<br/>';
    }
  }

  // 获取用户数据列表,传入数组条件查询
  public function readall(){
    $list = UserModel::all(['status'=>1]);
    foreach ($list as $user) {
      echo $user->nickname . $user->email . date('Y/m/d', $user->birthday) . '<br/>';
      echo '----------------------------------<br/>';
    }
  }

  // 获取用户数据列表,使用数据库的查询构建器完成更多的条件查询
  public function index(){
    $list = UserModel::where('id','<',3)->select();
    foreach ($list as $user) {
      echo $user->nickname . $user->email . date('Y/m/d', $user->birthday) . '<br/>';
      echo '----------------------------------<br/>';
    }
  }

}

</pre>

<h4>模型的获取器方法 - 修改和创造输出的字段</h4><pre>
获取器的作用是在获取数据的字段值后自动进行处理
读取器方法的命名规范是：get + 属性名的驼峰命名+ Attr
getBirthdayAttr读取器读取的是birthday属性,而getUserBirthdayAttr读取器读取的则是user_birthday属性

场景包括：
时间日期字段的格式化输出;
集合或枚举类型的输出;
数字状态字段的输出;
组合字段的输出;

</pre><pre class="php">
namespace app\index\model;
class User extends \think\Model{
  // birthday读取器方法用于读取User模型的birthday属性的值,该方法会在读取birthday属性值的时候自动触发执行
  protected function getBirthdayAttr($birthday){
    return date('Y-m-d', $birthday);
  }

  // status读取器,对状态数字值转换为字符串,$value表示status的字段值
  public function getStatusAttr($value){
    $status = [-1=>'删除',0=>'禁用',1=>'正常',2=>'待审核'];
    return $status[$value];
  }

  // user_birthday读取器,读取数据表中不存在的属性
  protected function getUserBirthdayAttr($value,$data){  // 获取器方法的第二个参数传入的是当前的所有数据数组
    return date('Y-m-d', $data['birthday']);
  }

  public function getStatusTextAttr($value,$data){
    $status = [-1=>'删除',0=>'禁用',1=>'正常',2=>'待审核'];
    return $status[$data['status']];
  }
}

$user = User::get(1);
echo $user->status;              // 输出“正常”
echo $user->status_text;         // 可以直接使用status_text字段的值了,输出“正常”
echo $user->birthday;
echo $user->user_birthday;
dump($user->toArray());          // 获取全部获取器数据
echo $user->status;              // 通过获取器获取字段
echo $user->getData('status');   // 获取原始字段数据
dump($user->getData());          // 获取全部原始数据

</pre>

<h4>模型的修改器方法</h4><pre>
修改器的作用是可以在数据赋值的时候自动进行转换处理
修改器方法的命名规范是：set + 属性名的驼峰命名+ Attr

修改器的使用场景和读取器类似：
时间日期字段的转换写入;
集合或枚举类型的写入;
数字状态字段的写入;
某个字段涉及其它字段的条件或者组合写入;

定义了修改器之后会在下列情况下触发：
模型对象赋值;
调用模型的data方法,并且第二个参数传入true;
调用模型的save方法,并且传入数据;
显式调用模型的setAttr方法;
定义了该字段的自动完成;

</pre><pre class="php">
class User extends \think\Model{
  public function setNameAttr($value){
    return strtolower($value);
  }

  // birthday修改器,字符串格式转换为时间戳(整型)格式
  protected function setBirthdayAttr($value){
    return strtotime($value);
  }
}

$user = new User();
$user->name = 'THINKPHP';  // 实际保存到数据库中的时候会转为小写
$user->birthday = '1977-03-05';
$user->save();
echo $user->name;          // thinkphp
echo $user->birthday;      // 输出时间戳(整型)格式

</pre><pre>
和读取器不同,修改器的属性必须是数据表中存在的字段,否则修改器的值仅仅能作为数据辅助作用。
protected function setUserTokenAttr($value, $data){  //这里传入的data可能已经过了其它的修改器操作,并非原始的数据
  return md5($data['name'] . $data['birthday']);
}

也可以进行序列化字段的组装：
class User extends Model{
  public function setNameAttr($value,$data){ // 修改器方法的第二个参数会自动传入当前的所有数据数组
    return serialize($data);
  }
}

调用模型的data方法传入第二个参数true触发修改器
$user = new User();
$data['name'] = 'THINKPHP';
$data['email'] = 'thinkphp@qq.com';
$user->data($data, true);
$user->save();
echo $user->name;   // thinkphp

使用save方法触发修改器
$user = new User();
$data['name'] = 'THINKPHP';
$data['email'] = 'thinkphp@qq.com';
$user->save($data);
echo $user->name;   // thinkphp

</pre>

<h4>类型转换</h4><pre>
数据库查询默认取出来的数据都是字符串类型,给字段设置类型自动转换会在写入和读取的时候自动进行类型转换处理,不需定义任何修改器和读取器
对于简单的数据格式转换之类的处理,设置类型转换比定义修改器和读取器更加方便

</pre><pre class="php">
class User extends Model{
    protected $type = [
        'status'    =>  'integer',
        'score'     =>  'float',
        'birthday'  =>  'datetime',
        'info'      =>  'array',
        'deleteTime'=>  'timestamp',  // delete_time字段
    ];
}

$user = new User;
$user->status = '1';
$user->score = '90.50';
$user->birthday = '2015/5/1';
$user->info = ['a'=>1,'b'=>2];
$user->save();
var_dump($user->status);   // int 1
var_dump($user->score);    // float 90.5;
var_dump($user->birthday); // string '2015-05-01 00:00:00'
var_dump($user->info);     // array (size=2) 'a' => int 1  'b' => int 2

</pre><pre>
类型转换支持的类型设置包括：
integer   整型
float     浮点型
boolean   布尔型
array     设置为强制转换为array类型,系统会自动把数组编码为json格式字符串写入数据库,取出来的时候会自动解码。
object    在写入的时候会自动编码为json字符串,输出的时候会自动转换为stdclass对象。
serialize 指定为序列化类型,数据会自动序列化写入,并且在读取的时候自动反序列化。
json      指定为json类型,数据会自动json_encode写入,并且在读取的时候自动json_decode处理。
datetime  和timestamp类似,区别在于写入和读取数据的时候都会自动处理成时间字符串Y-m-d H:i:s的格式。
timestamp 指定为时间戳字段类型(整型),该字段的值在写入时候会自动使用strtotime生成对应的时间戳,输出的时候会自动转换为dateFormat属性定义的时间字符串格式,默认的格式为Y-m-d H:i:s,如果希望改变其他格式可以定义如下：

</pre><pre class="php">
class User extends Model{
    protected $dateFormat = 'Y/m/d';
    protected $type = [
        'status'    =>  'integer',
        'score'     =>  'float',
        'birthday'  =>  'timestamp',
    ];
}

或在类型转换定义的时候使用：
class User extends Model{
    protected $type = [
        'status'    =>  'integer',
        'score'     =>  'float',
        'birthday'  =>  'timestamp:Y/m/d',
    ];
}

$user = User::find(1);
echo $user->birthday;   // 2015/5/1

</pre>

<h4>时间戳 - 自动时间字段create_time和update_time</h4><pre>
对于固定的时间戳和时间日期型的字段,比如文章的创建时间、修改时间等字段,还有比设置类型转换更简单的方法,尤其是所有的数据表统一处理的话,只需要配置开启自动写入时间戳字段即可

系统支持自动写入创建和更新的时间戳字段,字段名默认创建时间字段为create_time,更新时间字段为update_time,支持的字段类型包括timestamp/datetime/int。

数据表中create_time和update_time字段类型必须和auto_timestamp设置相同
mysql> alter table `news` add `create_time` timestamp not null default current_timestamp after `delete_time`;
mysql> alter table `news` add `update_time` timestamp not null default current_timestamp after `create_time`;

两种方式配置
1、在数据库配置文件中添加全局设置：
// 开启自动写入时间戳字段
'auto_timestamp' => true,              // true默认识别时间字段为整型int类型
'auto_timestamp' => 'datetime',        // datetime默认识别时间字段为整型datetime类型

2、直接在单独的模型类里面设置：
protected $autoWriteTimestamp = true;
protected $autoWriteTimestamp = 'datetime';

写入数据的时候系统会自动写入create_time和update_time字段,而不需要定义修改器
$user = new User();
$user->name = 'THINKPHP';
$user->save();
echo $user->create_time; // 输出类似 2016-10-12 14:20:10
echo $user->update_time; // 输出类似 2016-10-12 14:20:10

如果数据表字段不是默认值的话,可以按照下面的方式定义：
class User extends Model{
  // 定义类型转换
  protected $type = [
    'birthday' => 'timestamp:Y/m/d',
  ];
  // 定义时间戳字段名
  protected $createTime = 'create_at';
  protected $updateTime = 'update_at';
}

$user = new User();
$user->name = 'THINKPHP';
$user->save();
echo $user->create_at; // 输出类似 2016-10-12 14:20:10
echo $user->update_at; // 输出类似 2016-10-12 14:20:10

如果只需要使用create_time字段而不需要自动写入update_time,则可以单独设置关闭某个字段
class User extends Model{
  protected $updateTime = false;         // 关闭自动写入update_time字段
}

如果不需要任何自动写入的时间戳字段的话,可以关闭时间戳自动写入功能,生成的数据已经没有自动写入时间戳了,而是数据库默认值写入
class User extends Model{
  protected $autoWriteTimestamp = false;  // 关闭自动写入时间戳
}

如果是关闭全局的自动时间写入,则可以使用：
// 关闭全局自动写入时间字段
'auto_timestamp' => false,

</pre>

<h4>数据自动完成</h4><pre>
数据自动完成指在不需要手动赋值的情况下对字段的值进行处理后写入数据库。要理清“修改器”与“自动完成”的关系
数据自动完成是依赖修改器的,不支持使用函数或其它回调来自动完成,但可以支持固定值
定义了数据自动完成后不需要手动设置属性,一旦使用手动设置的话自动完成就会忽略,以避免产生多次处理的数据混乱

系统支持auto、insert和update三个属性
auto 新增及更新的时候自动完成的属性数组
insert 仅新增的时候自动完成的属性数组
update 仅更新的时候自动完成的属性数组

自动完成属性里面一般来说仅需要定义属性的名称,然后配合修改器或类型转换来一起完成,如果写入的是一个固定的值就无需使用修改器

</pre><pre class="php">
namespace app\index\model;
use think\Model;
class User extends Model{
    // 定义类型转换
    protected $type = ['birthday' => 'timestamp:Y/m/d',];

    // 定义自动完成的属性
    protected $auto = [];
    protected $insert = ['ip','status' => 1];
    protected $update = ['login_ip'];

    protected function setIpAttr(){
        return request()->ip();
    }
}

// 在新增数据的时候会对ip和status字段自动完成或处理。
$user = new User;
$user->name = 'ThinkPHP';
$user->save();
echo $user->name;     // thinkphp
echo $user->status;   // 1

// 在保存操作的时候会自动完成ip字段的赋值。
$user = User::find(1);
$user->name = 'THINKPHP';
$user->save();
echo $user->name;     // thinkphp
echo $user->ip;       // 127.0.0.1

</pre>如果status属性的值不是固定的,而是需要条件判断,那么可以定义修改器来配合自动完成<pre class="php">
namespace app\index\model;
class User extends \think\Model{
  // 定义类型转换
  protected $type = ['birthday' => 'timestamp:Y/m/d',];

  // 定义自动完成的属性
  protected $insert = ['status'];

  // status属性修改器
  protected function setStatusAttr($value, $data){
    return '流年' == $data['nickname'] ? 1 : 2;
  }

  // status属性读取器
  protected function getStatusAttr($value){
    $status = [-1 => '删除', 0 => '禁用', 1 => '正常', 2 => '待审核'];
    return $status[$value];
  }
}

</pre>

<h4>逻辑删除 软删除</h4><pre>
在实际项目中,对数据频繁使用删除操作会导致性能问题,因此不推荐直接物理删除数据,而是用逻辑删除替代(软删除)
软删除的作用就是把数据加上删除标记,而不是真正的删除,同时也便于需要的时候进行数据的恢复。

软删除功能需要在数据表中添加delete_time字段,deleteTime属性用于定义软删除标记字段,TP5的软删除功能使用时间戳类型(数据表默认值为Null),用于记录数据的删除时间,格式为2018-08-15 23:30:10。
mysql> alter table `news` add `delete_time` timestamp null default null after `author_id`;
模型中需要设置protected $autoWriteTimestamp = 'timestamp';
可以用类型转换指定软删除字段的类型,建议数据表的所有时间字段统一一种类型

要使用软删除功能,需要引入SoftDelete trait,例如User模型按照下面的定义就可以使用软删除功能：

namespace app\index\model;
use think\Model;
use traits\model\SoftDelete;
class User extends Model{
    use SoftDelete;
    protected $deleteTime = 'delete_time';
}

User::destroy(1);      // 软删除
User::destroy(1,true); // 真实删除
$user = User::get(1);
$user->delete();       // 软删除
$user->delete(true);   // 真实删除

默认查询的数据不包含软删除数据,如果需要包含软删除的数据可以使用下面的方式查询：
User::withTrashed()->find();
User::withTrashed()->select();

如果仅仅需要查询软删除的数据可以使用：
User::onlyTrashed()->find();
User::onlyTrashed()->select();

如果模型定义了base基础查询,请确保添加软删除的基础查询条件

</pre>

<h4>只读字段</h4><pre>
只读字段用来保护某些特殊的字段值不被更改,这个字段的值一旦写入就无法更改,当执行更新方法之前会自动过滤掉只读字段的值,避免更新到数据库

namespace app\index\model;
use think\Model;
class User extends Model{
  protected $readonly = ['name','email'];  // 定义当前模型的name和email字段为只读字段
}

$user = User::get(5);
$user->name = 'TOPThink';
$user->email = 'Topthink@gmail.com';
$user->address = '上海静安区';
$user->save();

由于对name和email字段设置了只读,因此只有address字段的值被更新了,而name和email的值仍然还是更新之前的值

</pre>

<h4>条件查询(内部)</h4><pre>
查询操作应当是静态调用,更新和删除操作则是动态方法调用
模型查询的原则应当是每个模型对象实例操作一个唯一记录,对于数据集来说这个原则也不变,只是每个数据集对象实例则包含多个模型对象实例而已

$this->where('name', 'thinkphp')->find();   // 查询单个记录
$this->getByName('thinkphp');               // 调用动态查询方法
$this->where('id', '>', 0)->limit(10)->order('id desc')->select();  // 查询数据集
$this->where('status', 0)->delete();        // 删除数据

</pre>

<h4>查询范围</h4><pre>
对于一些常用的查询条件,可以封装成查询范围来进行方便的调用
命名范围方法之前不能调用查询的连贯(链式)操作方法,查询范围方式必须首先被调用。
如果在查询范围方法后面调用了其他的链式查询方法,则只能使用find或select查询

查询范围的方法的第一个参数必须是查询对象,并且支持多个额外参数

</pre><pre class="php">
// 对模型的查询和写入操作进行封装
namespace app\index\model;
use think\Model;
class User extends Model{
  protected function scopeThinkphp($query){
    $query->where('name','thinkphp')->field('id,name');
  }
  protected function scopeAge($query){
    $query->where('age','>',20)->limit(10);
  }
  protected function scopeAgeAbove($query, $lowest_age = 18){  // 支持额外参数,scope驼峰命名
    $query->where('age','>',$lowest_age)->limit(10);
  }
}

User::scope('thinkphp')->find();       // 查找name为thinkphp的用户
User::scope('age')->select();          // 查找年龄大于20的10个用户
User::scope('ageAbove', 20)->select(); // 参数支持
User::scope('thinkphp,age')->select(); // 查找name为thinkphp的用户并且年龄大于20的10个用户

直接使用闭包函数进行查询,闭包里面支持所有的链式操作方法
User::scope(function($query){
  $query->where('age','>',20)->limit(10);
})->select();

支持动态调用的方式
$user = new User;
$user->thinkphp()->get();        // 查找name为thinkphp的用户
$user->age()->all();             // 查找年龄大于20的10个用户
$user->thinkphp()->age()->all(); // 查找name为thinkphp的用户并且年龄大于20的10个用户

支持多次调用scope方法,并且可以追加新的查询及链式操作
生成的sql:SELECT * FROM `think_user` WHERE `name` = 'thinkphp' AND `age` > 20 ORDER BY `id` desc

// 根据查询范围获取用户数据列表
public function index(){
  $list = UserModel::scope('thinkphp')
    ->scope('age')
    ->scope(function ($query) {
      $query->order('id', 'desc');
    })
    ->all();
  foreach ($list as $user) {
    echo $user->nickname . '<br/>';
  }
}

</pre><pre>
【 全局查询范围 】
如果所有查询都需要一个基础的查询范围,每次查询都会自动带上全局查询范围的查询条件,可以在模型类里面定义一个静态的base方法

namespace app\index\model;
class User extends \think\ModelModel{
  protected function base($query){  // 定义全局的查询范围
    $query->where('status',1);
  }
}

$user = User::get(1);  // 最终的查询条件会是status = 1 AND id = 1

动态关闭/开启全局查询访问
User::useGlobalScope(false)->get(1);  // 关闭全局查询范围
User::useGlobalScope(true)->get(2);   // 开启全局查询范围

</pre>

<h4>模型分层</h4><pre>
TP支持模型的分层,除了Model层之外可以根据项目的需要设计和创建其他的模型层。
通常不同的分层模型仍然是继承系统的\think\Model类或其子类,所以其基本操作和Model类的操作是一致的。

例如在index模块的设计中需要区分数据层、逻辑层、服务层等不同的模型层,可以在模块目录下面创建model、logic和service目录,把对用户表的所有模型操作分成三层：
数据层：app\index\model\User   用于定义数据相关的自动验证和自动完成和数据存取接口
逻辑层：app\index\logic\User   用于定义用户相关的业务逻辑
服务层：app\index\service\User 用于定义用户相关的服务接口等

三个模型层的定义如下：

// app\index\model\User.php
namespace app\index\model;
use think\Model;
class User extends Model{
}
实例化方法：\think\Loader::model('User')

// Logic类：app\index\logic\User.php
namespace app\index\logic;
use think\Model;
class User extends Model{
}
实例化方法：\think\Loader::model('User','logic');

// Service类：app\index\service\User.php
namespace app\index\service;
use think\Model;
class User extends Model{
}
实例化方法：\think\Loader::model('User','service');

</pre>

<h4>模型输出 数组访问和转换 - toArray方法</h4><pre>
模型对象支持数组方式访问

$user = User::find(1);
echo $user->name ;          // 有效
echo $user['name']          // 同样有效
$user->name = 'thinkphp';   // 有效
$user['name'] = 'thinkphp'; // 同样有效
$user->save();

【 toArray方法将当前的模型实例输出为数组 】
$user = User::find(1);
dump($user->toArray());                                         // 模型的数据已经经过了读取器方法处理
dump($user->hidden(['create_time','update_time'])->toArray());  // 设置不输出的字段属性
dump($user->visible(['id','name','email'])->toArray());         // 设置允许输出的属性
dump($user->append(['status_text'])->toArray()); // 数组输出的字段值会经过获取器的处理,也可以支持追加其它获取器定义(不在数据表字段列表中)的字段

如果是数据集查询的话有两种情况,由于默认的数据集返回结果的类型是数组,因此无法调用toArray方法,必须先转成数据集对象然后再使用toArray方法,系统提供了一个collection助手函数实现数据集对象的转换

$list = User::all();
if($list) {
    $list = collection($list)->toArray();
}

如果设置了模型的数据集返回类型的话,则可以简化使用
namespace app\index\model;
use think\Model;
class User extends Model{
  protected $resultSetType = 'collection';
}

$list = User::all();
$list = $list->toArray();

【 追加关联模型的属性 】
支持追加一对一关联模型的属性到当前模型

$user = User::find(1);
dump($user->appendRelationAttr('profile',['email','nickname'])->toArray());
profile是关联定义方法名,email和nickname是Profile模型的属性

【 支持关联属性 】
模型的visible、hidden和append方法支持关联属性操作,同样支持数据集对象

$user = User::get(1,'profile');
// 隐藏profile关联属性的email属性
dump($user->hidden(['profile'=>['email']])->toArray());
// 或使用
dump($user->hidden(['profile.email'])->toArray());

</pre>

<h4>模型输出 JSON序列化 - toJson方法</h4><pre>
可调用模型的toJson方法对模型对象进行JSON序列化,使用方法和toArray类似,并且调用toJson序列化之前同样支持hidden、visible、append和appendRelationAttr方法

$user = User::get(1);
echo $user->toJson();
echo json_encode(User::get(1));  // 模型对象可以直接被JSON序列化
echo User::get(1);               // 直接echo 一个模型对象,输出结果同上
echo $user->hidden(['create_time','update_time'])->toJson();  // 设置无需输出的字段
echo $user->visible(['id','name','email'])->toJson();         // 设置允许输出的属性
echo $user->append(['status_text'])->toJson();                // 追加其它的字段

【 追加关联模型的属性 】
支持追加一对一关联模型的属性到当前模型

$user = User::find(1);
echo $user->appendRelationAttr('profile',['email','nickname'])->toJson();
profile是关联定义方法名,email和nickname是Profile模型的属性。

</pre>

<h3>模型事件</h3><pre>
模型事件指在进行模型的写入操作时触发的操作行为,包括模型的save方法和delete方法。
模型事件只可以在调用模型的方法才能生效,使用查询构造器通过Db类操作是无效的
支持before_delete、after_delete、before_write、after_write、before_update、after_update、before_insert、after_insert事件行为

使用方法
User::event('before_insert', function ($user) {
  if ($user->status != 1) {
    return false;
  }
});

注册的回调方法支持传入一个参数(当前的模型对象实例),并且before_write、before_insert、 before_update 、before_delete事件方法如果返回false则不会继续执行。

支持给一个位置注册多个回调方法
User::event('before_insert', function ($user) {
  if ($user->status != 1) {
    return false;
  }
});
// 注册回调到beforeInsert函数
User::event('before_insert', 'beforeInsert');

可以在模型类的init方法里面统一注册模型事件
namespace app\index\model;
use think\Model;
class User extends Model{
  protected static function init(){
    User::event('before_insert', function ($user) {
      if ($user->status != 1) {
        return false;
      }
    });
    self::event('before_insert', function ($user) {  // 调用当前模型

    }
  }
}

【 快捷注册 】
系统提供了内置的事件注册的快捷方法

namespace app\index\model;
use think\Model;
class User extends Model{
  protected static function init(){
    User::beforeInsert(function ($user) {
      if ($user->status != 1) {
        return false;
      }
    });
  }
}

</pre>

<h3>关联模型</h3><pre>
TP5.0的关联采用了对象化的操作模式,无需继承不同的模型类,只是把关联定义成一个方法,并且直接通过当前模型对象的属性名获取定义的关联数据

关联关系包括下面三种：
一对一关联 ：ONE_TO_ONE,包括HAS_ONE和相对的BELONGS_TO
一对多关联 ：ONE_TO_MANY,包括HAS_MANY和相对的BELONGS_TO
多对多关联 ：MANY_TO_MANY,BELONGS_TO_MANY
关联关系必然有一个参照表

要进行模型的关联操作,必须同时定义好当前模型和关联模型

</pre>

<h4>一对一关联</h4><pre>
一个用户都有一份个人资料,每个公司都有一个营业执照

hasOne('关联模型名','关联外键','主键名','别名定义','join类型');
默认的外键是：当前模型名_id,主键则是自动获取
join默认是inner

belongsTo('关联模型名','关联外键','关联模型主键','别名定义','join类型');

</pre><pre class="php">
DROP TABLE IF EXISTS `think_user`;
CREATE TABLE IF NOT EXISTS `think_user` (
  `id` int(6) UNSIGNED NOT NULL AUTO_INCREMENT,
  `nickname` varchar(25) NOT NULL,
  `name` varchar(25) NOT NULL,
  `password` varchar(50) NOT NULL,
  `create_time` int(11) UNSIGNED NOT NULL,
  `update_time` int(11) UNSIGNED NOT NULL,
  `status` tinyint(1) DEFAULT 0,
  PRIMARY KEY (`id`)
) ENGINE=MyISAM DEFAULT CHARSET=utf8;

DROP TABLE IF EXISTS `think_profile`;
CREATE TABLE IF NOT EXISTS `think_profile` (
  `id` int(6) UNSIGNED NOT NULL AUTO_INCREMENT,
  `truename` varchar(25) NOT NULL,
  `birthday` int(11) NOT NULL,
  `address` varchar(255) DEFAULT NULL,
  `email` varchar(255) DEFAULT NULL,
  `user_id` int(6) UNSIGNED NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=MyISAM DEFAULT CHARSET=utf8;

# User模型的profile方法就是一个关联定义方法,方法名可以随意命名,但要避免和User模型对象的字段属性冲突
namespace app\index\model;
class User extends \think\Model{
  protected $autoWriteTimestamp = true;  // 开启自动写入时间戳
  protected $insert = ['status' => 1];   // 定义自动完成的属性

  // 定义关联方法,用户HAS ONE档案关联
  public function profile(){
    return $this->hasOne('Profile');     // User模型一对一关联Profile模型
  }

  // 默认使用的是user_id作为外键关联,如果不是的话则需要在关联定义的时候指定
  // field()定义需要查询的字段,如果使用的是join方式的关联不支持指定field字段
  public function profile1(){
    return $this->hasOne('Profile','uid')->field('id,name,email');
  }
}

</pre><pre>
通常关联模型和当前模型都是相同的命名空间,如果关联模型在不同的命名空间需要指定完整的类名
return $this->hasOne('\app\admin\Profile');   // 关联admin模块下面的模型对象

关联查询时默认使用当前模型的名称(小写)作为数据表别名,可以指定查询使用的数据表别名
return $this->hasOne('Profile','user_id','id',['user'=>'member','profile'=>'info']); // 用户HASONE档案关联

要进行模型的关联操作必须同时定义好关联模型
如果关联操作都是基于User模型的话,Profile模型中并不需要定义关联方法

</pre><pre class="php">
namespace app\index\model;
class Profile extends \think\Model{
  protected $type = [
    'birthday' => 'timestamp:Y-m-d',
  ];
}

</pre>如果需要基于Profile模型来进行关联操作,则需要在Profile模型中定义对应的BELONGS_TO关联<pre class="php">
namespace app\index\model;
use think\Model;
class Profile extends Model{
  protected $type = [
    'birthday' => 'timestamp:Y-m-d',
  ];
  public function user(){
    // 档案 BELONGS TO 关联用户
    return $this->belongsTo('User');
  }
}

</pre><pre>
【 关联写入 】
关联模型的写入调用了关联方法profile(),该方法返回的是一个Relation对象,执行save方法会自动传入当前模型User的主键作为关联键值,所以不需要手动传入Profile模型的user_id属性

</pre>写入关联数据<pre class="php">
namespace app\index\controller;
use app\index\model\Profile;
use app\index\model\User as UserModel;
class User{
  // 关联新增数据
  public function add(){
    $user = new UserModel;
    $user->name = 'thinkphp';
    $user->password = '123456';
    $user->nickname = '流年';
    if ($user->save()) {
       $profile = new Profile;
      $profile->truename = '刘晨';
      $profile->birthday = '1977-03-05';
      $profile->address = '中国上海';
      $profile->email = 'thinkphp@qq.com';

      $user->profile()->save($profile);  // $profile也可以直接使用数组而不是Profile对象
      return '用户新增成功';
    } else {
      return $user->getError();
    }
  }
}

</pre>关联新增:系统会自动把当前模型的主键传入profile模型<pre class="php">
$user = User::get(1);
$user->profile()->save(['email' => 'thinkphp']);

</pre><pre>
【 关联查找 】
一对一的关联查询很简单,直接把关联对象当成属性来用即可
关联方法的命名规范是驼峰法,而关联属性则一般是小写+下划线的方式,系统在获取的时候会自动转换对应,读取user_profile关联属性则对应的关联方法应该是userProfile。

</pre><pre class="php">
public function read($id){
  $user = UserModel::get($id);
  echo $user->name;
  echo $user->nickname';
  echo $user->profile->truename;
  echo $user->profile->email;     // 输出Profile关联模型的email属性

  // 使用hasWhere方法根据关联表的查询条件查询当前模型的数据
  $user = User::hasWhere('profile',['email'=>'thinkphp@qq.com'])->find();
  echo $user->name;
}

</pre><pre>
【 关联预载入 】
以上关联查询时只有在获取关联对象( $user->profile )的时候才会进行实际的关联查询,缺点是会可能进行多次查询,但可以使用预载入查询来提高查询性能,对于一对一关联来说只需要进行一次查询即可获取关联对象数据

</pre><pre class="php">
public function read($id){
  $user = UserModel::get($id,'profile');   // get方法使用第二个参数就表示进行关联预载入查询
  echo $user->name;
  echo $user->nickname;
  echo $user->profile->truename;
  echo $user->profile->email;
}

</pre><pre>
【 绑定属性到父模型 】
可以在定义关联的时候使用bind方法绑定属性到父模型
namespace app\index\model;
class User extends \think\Model{
    public function profile(){
        return $this->hasOne('Profile','uid')->bind('nickname,email');

        // 或使用数组的方式指定绑定属性别名
        return $this->hasOne('Profile','uid')->bind([
            'email',
            'truename'  => 'nickname',
            'profile_id'  => 'id',
        ]);
    }
}

然后使用关联预载入查询的时候可以使用
$user = User::get(1,'profile');
echo $user->email;        // 输出Profile关联模型的email属性
echo $user->profile_id;

绑定关联属性不影响原有关联属性的读取,绑定关联模型的属性支持读取器。
如果不是预载入查询请使用模型的appendRelationAttr方法追加属性。

</pre>【 更新关联数据 】<pre class="php">
public function update($id){
  $user = UserModel::get($id);
  $user->name = 'framework';
  if ($user->save()) {
    $user->profile->email = 'liu21st@gmail.com';
    $user->profile->save();
    // 或
    $user->profile->save(['email' => 'thinkphp']);
    return '更新成功';
  } else {
    return $user->getError();
  }
}

</pre>【 删除关联数据 】<pre class="php">
public function delete($id){
  $user = UserModel::get($id);
  if ($user->delete()) {
    $user->profile->delete();
    return '删除成功';
  } else {
    return $user->getError();
  }
}

</pre><pre>
【 在Profile模型中定义一个相对的关联关系 】
namespace app\index\model;
class Profile extends \think\Model{
	public function user(){
		return $this->belongsTo('User','uid');  // 默认的关联外键是user_id,如果不是则需要在第二个参数定义
	}
}

$profile = Profile::get(1);
echo $profile->user->account;   // 根据档案资料来获取用户模型的信息,输出User关联模型的属性

【 关联自动写入】
可以使用together方法更方便的进行关联自动写入操作

写入
$blog = new Blog;
$blog->name = 'thinkphp';
$blog->title = 'ThinkPHP5关联实例';
$content = new Content;
$content->data = '实例内容';
$blog->content = $content;
$blog->together('content')->save();

更新
$blog = Blog::get(1);                // 查询
$blog->title = '更改标题';
$blog->content->data = '更新内容';
$blog->together('content')->save();  // 更新当前模型及关联模型

删除
$blog = Blog::get(1);                 // 查询
$blog->together('content')->delete(); // 删除当前及关联模型

如果不想这么麻烦每次调用together方法,也可以直接在模型类中定义relationWrite属性,但必须是数组方式。不过考虑到模型的独立操作的可能性,并不建议。

</pre>

<h4>一对多关联</h4><pre>
一对多关联的情况也比较常见,如一片文章有多个评论、每个作者写有多本书
hasMany('关联模型名','外键名','主键名',['模型别名定义']);

</pre>【 模型定义 】<pre class="php">
DROP TABLE IF EXISTS `think_book`;
  CREATE TABLE IF NOT EXISTS `think_book` (
  `id` int(8) UNSIGNED NOT NULL AUTO_INCREMENT,
  `title` varchar(255) NOT NULL,
  `publish_time` int(11) UNSIGNED DEFAULT NULL,
  `create_time` int(11) UNSIGNED NOT NULL,
  `update_time` int(11) UNSIGNED NOT NULL,
  `status` tinyint(1) NOT NULL,
  `user_id` int(6) UNSIGNED NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=MyISAM DEFAULT CHARSET=utf8;

namespace app\index\model;
use think\Model;
class User extends Model{
  protected $autoWriteTimestamp = true;  // 开启自动写入时间戳
  protected $insert = ['status' => 1];   // 定义自动完成的属性

  // 定义关联方法
  public function profile(){
    return $this->hasOne('Profile');
  }

  // 定义关联,在User模型类添加Book关联
  public function books(){
    return $this->hasMany('Book');
  }

  // 定义关联,在User模型类添加Book关联
  public function books(){
    return $this->hasMany('Book','uid')            // 定义外键的名称
                ->field('id,title,publish_time');  // 指定查询字段
  }
}

# Book模型类定义
namespace app\index\model;
class Book extends \think\Model{
  protected $type = ['publish_time' => 'timestamp:Y-m-d'];
  protected $autoWriteTimestamp = true;  // 开启自动写入时间戳
  protected $insert = ['status' => 1];   // 定义自动完成的属性

  # 如果需要定义对应的关联则可以使用belongsTo方法定义关联方法
  public function user(){
    return $this->belongsTo('User');
  }
}

</pre>【 新增关联数据 】<pre class="php">
public function addBook(){
  $user = UserModel::get(1);
  $book = new Book;
  $book->title = 'ThinkPHP5快速入门';
  $book->publish_time = '2016-05-06';
  $user->books()->save($book);
  return '添加Book成功';
}

public function addBook(){
  $user = UserModel::find(1);
  $user->books()->save(["title"=>'ThinkPHP5快速入门', 'publish_time'=>'2016-05-06']);
  return '添加Book成功';
}

</pre>批量增加关联数据<pre class="php">
public function addBook(){
  $user = UserModel::get(1);
  $books = [
    ['title' => 'TP5快速入门', 'publish_time' => '2016-05-06'],
    ['title' => 'TP5开发手册', 'publish_time' => '2016-03-06'],
  ];
  $user->books()->saveAll($books);
  return '添加Book成功';
}

</pre><pre>
【 关联查询,获取关联数据 】
可以直接调用模型的属性获取全部关联数据

</pre><pre class="php">
public function read(){
  $user = UserModel::get(1);
  echo $user->name;           // 获取User对象的name属性
  $books = $user->books;      // 获取User对象的Book关联对象,即获取该作者的所有书籍
  dump($books);
  $books = $user->books()->where('status',1)->select(); // 执行关联的Book对象的查询即条件搜索,获取状态为1的关联数据
  dump($books);
  $book = $user->books()->getByTitle('ThinkPHP5快速入门'); // 获取作者写的某本书
  dump($book);
}

</pre>一对多查询同样可以使用预载入查询,一对多预载入查询会在原先延迟查询的基础上增加一次查询,可以解决典型的N+1次查询问题<pre class="php">
public function read(){
  $user = UserModel::get(1,'books');
  $books = $user->books;
  dump($books);
}

</pre>还可以根据关联数据来查询当前模型数据<pre class="php">
public function read(){
  $user = UserModel::has('books')->select();            // 查询有写过书的作者列表
  $user = UserModel::has('books', '>=', 3)->select();   // 查询写过三本书以上的作者
  $user = UserModel::hasWhere('books', ['title'=>'TP5快速入门'])->select(); // 查询写过ThinkPHP5快速入门的作者
  // hasWhere方法的fields参数用于指定返回的字段列表
  $user = UserModel::hasWhere('books',['status'=>1],'id,name')->select(); // 查询书籍状态正常的作者
}

</pre>【 关联更新 】<pre class="php">
public function update($id){
  $user = UserModel::get($id);
  $book = $user->books()->getByTitle('ThinkPHP5开发手册');
  $book->title = 'ThinkPHP5快速入门';
  $book->save();
}

</pre>或者使用查询构建器的update方法进行更新(但可能无法触发关联模型的事件)<pre class="php">
public function update($id){
  $user = UserModel::get($id);
  $user->books()->where('title', 'ThinkPHP5快速入门')->update(['title' => 'ThinkPHP5开发手册']);
}

</pre>【 关联删除 】 <pre class="php">
public function delete($id){
  $user = UserModel::get($id);
  // 删除部分关联数据
  $book = $user->books()->getByTitle('ThinkPHP5开发手册');
  $book->delete();

  // 删除所有的关联数据
  if($user->delete()){
    $user->books()->delete();
  }
}

</pre>

<h4>远程一对多</h4><pre>
远程一对多关联用于定义有跨表的一对多关系,例如：每个城市有多个用户,每个用户有多个话题,城市和话题之间并无关联

关联定义
hasManyThrough('关联模型名','中间模型名','外键名','中间模型关联键名','当前模型主键名');

定义了City关联模型就可以直接通过远程一对多关联获取每个城市的多个话题,远程一对多关联需要同时存在Topic和User模型

namespace app\index\model;
use think\Model;
class City extends Model{
    public function topics(){
        return $this->hasManyThrough('Topic','User');
    }
}

关联查询,获取关联数据
$city = City::get(1);
dump($city->topics);    // 获取同城的所有话题
dump($city->topics()->where('topic.status',1)->select());  // 也可以进行条件搜索,需要带上模型名作为前缀

</pre>

<h4>多对多关联</h4><pre>
用户和角色就是一种多对多的关系,一个用户会有多个角色,同时一个角色也会包含多个用户

belongsToMany('关联模型名','中间表名称','关联外键名','关联模型主键/当前模型关联键名',['模型别名定义'])

</pre><pre class="php">
DROP TABLE IF EXISTS `think_role`;
CREATE TABLE IF NOT EXISTS `think_role` (
  `id` int(5) UNSIGNED NOT NULL AUTO_INCREMENT,
  `name` varchar(25) NOT NULL,
  `title` varchar(50) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=MyISAM DEFAULT CHARSET=utf8;

# 多对多关联通常一定会有一个中间表,也称为枢纽表,所以需要创建一个用户角色的中间表
DROP TABLE IF EXISTS `think_access`;
CREATE TABLE IF NOT EXISTS `think_access` (
  `user_id` int(6) UNSIGNED NOT NULL,
  `role_id` int(5) UNSIGNED NOT NULL
) ENGINE=MyISAM DEFAULT CHARSET=utf8;

</pre><pre>
【 定义关联 】
对于枢纽表并不需要创建模型类,在多对多关联关系中,并不需要直接操作枢纽表

</pre><pre class="php">
namespace app\index\model;
class User extends \think\Model{
  protected $autoWriteTimestamp = true;  // 开启自动写入时间戳
  protected $insert = ['status' => 1];   // 定义自动完成的属性

  // 定义一对一关联
  public function profile(){
    return $this->hasOne('Profile');
  }

  // 定义一对多关联
  public function books(){
    return $this->hasMany('Book');
  }

  // 定义多对多关联,给User模型添加多对多关联方法定义,用户BELONGS_TO_MANY角色
  public function roles(){
    return $this->belongsToMany('Role', 'think_access');
  }

  // 多对多关联中间表名无需添加表前缀,并支持定义中间表模型
  public function roles(){
      return $this->belongsToMany('Role','\app\index\model\Access');
  }
}

# Role模型定义
namespace app\index\model;
class Role extends \think\Model{
  public function user(){
    // 角色BELONGS_TO_MANY用户
    return $this->belongsToMany('User', 'think_access');
  }
}

</pre><pre>
【 新增关联数据 】
增加关联数据会自动写入中间表数据

</pre>给用户增加还没创建过的edit角色<pre class="php">
public function add(){
  $user = UserModel::getByNickname('张三');
  $user->roles()->save(['name' => 'editor', 'title' => '编辑']);  // 新增用户角色并自动写入中间表
  return '用户角色新增成功';
}

# 批量新增用户的角色
public function add(){
  $user = UserModel::getByNickname('张三');
  $user->roles()->saveAll([
    ['name' => 'leader', 'title' => '领导'],
    ['name' => 'admin', 'title' => '管理员'],
  ]);
  return '用户角色新增成功';
}

</pre>给用户增加已存在eidt角色,只需要用attach方法单独增加中间表的关联数据<pre class="php">
public function add(){
  $user = UserModel::getByNickname('张三');
  $role = Role::getByName('editor');
  $user->roles()->attach($role);   // 添加中间表数据,attach方法返回为Pivot对象
  return '用户角色添加成功';
}

# 或者直接使用角色Id添加关联数据
public function add(){
  $user = UserModel::getByNickname('张三');
  // 单独更新中间表数据
  $user->roles()->attach(1);
  // 传入中间表的额外属性
  $user->roles()->attach(1,['remark'=>'test']);
  return '用户角色添加成功';
}

# 只新增中间表数据
$user = User::get(1);
$user->roles()->save(1);  // 仅增加关联的中间表数据
// 或
$role = Role::get(1);
$user->roles()->save($role);

// 批量增加关联数据
$user->roles()->saveAll([1,2,3]);

</pre><pre>
【 删除关联数据 】
如需解除用户的admin角色,可以使用detach方法单独删除关联的中间表数据,而不会删除关联模型数据

</pre><pre class="php">
// 关联删除数据
public function delete(){
  $user = UserModel::get(2);
  $role = Role::getByName('admin');

  // 删除关联数据,但不删除关联模型数据
  $user->roles()->detach($role);

  // 删除中间表数据
  $user->roles()->detach([1,2,3]);

  return '用户角色删除成功';
}

</pre>如有必要也可以删除中间表的同时删除关联模型,如解除用户的edit角色并同时删除edit角色身份<pre class="php">
// 关联删除数据
public function delete(){
  $user = UserModel::getByNickname('张三');
  $role = Role::getByName('editor');
  // 删除关联数据 并同时删除关联模型数据
  $user->roles()->detach($role,true);
  return '用户角色删除成功';
}

</pre>【 关联查询 】<pre class="php">
// 关联查询,获取用户张三的所有角色
public function read(){
  $user = UserModel::getByNickname('张三');
  dump($user->roles);
}

</pre>同样支持对多对多关联使用预载入查询<pre class="php">
public function read(){
  $user = UserModel::get(2,'roles');  // 预载入查询
  dump($user->roles);
}

</pre>获取中间表数据<pre class="php">
$user = User::get(1);
$roles = $user->roles;
foreach($roles as $role){
    dump($role->pivot);    // 获取中间表数据
}

</pre>

<h4>多态关联</h4><pre>
【 多态一对多关联 】
多态关联允许一个模型在单个关联定义方法中从属一个以上其它模型,例如用户可以评论书和文章,但评论表通常都是同一个数据表的设计,多态一对多关联关系就是为了满足类似的使用场景而设计。

关联表的数据表结构：
article
  id - integer
  title - string
  content - text

book
  id - integer
  title - string

comment
  id - integer
  content - text
  commentable_id - integer
  commentable_type - string

comment表中的commentable_id和commentable_type字段称之为多态字段,commentable_id用于存放书或文章的id主键,而commentable_type用于存放所属模型的类型,通常的设计是多态字段有一个公共的前缀(如commentable),当然也支持设置完全不同的字段名例如使用data_id和type

【 多态关联定义 】
morphMany('关联模型名','多态字段信息','多态类型');
1、关联模型名(必须)：关联的模型名称,可以使用模型名如Comment或完整的命名空间模型名如app\index\model\Comment
2、多态字段信息(可选)：支持两种方式定义,如果是字符串表示多态字段的前缀,多态字段使用 多态前缀_type和多态前缀_id,如果是数组,表示使用['多态类型字段名','多态ID字段名'],默认为当前的关联方法名作为字段前缀。
3、多态类型(可选)：当前模型对应的多态类型,默认为当前模型名,可以使用模型名如Article或完整的命名空间模型名如app\index\model\Article

morphTo('多态字段信息',['多态类型别名']);
多态字段信息(可选)：支持两种方式定义 如果是字符串表示多态字段的前缀,多态字段使用 多态前缀_type和多态前缀_id,如果是数组,表示使用['多态类型字段名','多态ID字段名'],默认为当前的关联方法名作为字段前缀
多态类型别名(可选)：数组方式定义

</pre><pre class="php">
文章模型：
namespace app\index\model;
use think\Model;
class Article extends Model{
    public function comments(){   // 获取所有针对文章的评论
        return $this->morphMany('Comment', 'commentable');
    }
}

书籍模型：书籍模型的设置方法同文章模型一致,区别在于多态类型不同,但由于多态类型默认会取当前模型名,因此不需要单独设置。
namespace app\index\model;
use think\Model;
class Book extends Model{
    public function comments(){   // 获取所有针对书籍的评论
        return $this->morphMany('Comment', 'commentable');
    }
}

评论模型的关联定义：
namespace app\index\model;
use think\Model;
class Comment extends Model{
    public function commentable(){  // 获取评论对应的多态模型
        return $this->morphTo();
    }
}

自定义多态关联的类型字段
默认TP会使用模型名作为多态表的类型区分,例如Comment属于Article或Book,commentable_type的默认值可以分别是Article或Book 。可以通过定义多态的时候传入参数来对数据库进行解耦。
public function commentable(){
    return $this->morphTo('commentable',[
        'book'  =>  'app\index\model\Book',
        'post'  =>  'app\admin\model\Article',
    ]);
}

获取多态关联
一旦数据表及模型被定义则可以通过模型来访问关联,例如要访问某篇文章的所有评论则可以简单的使用comments动态属性：
$article = Article::get(1);
foreach ($article->comments as $comment) {
    dump($comment);
}

也可以从多态模型的多态关联中,通过访问调用morphTo的方法名称来获取拥有者,也就是此例子中Comment模型的commentable方法。所以可以使用动态属性来访问这个方法,Comment模型的commentable关联会返回Article或Book模型的对象实例,这取决于评论所属模型的类型
$comment = Comment::get(1);
$commentable = $comment->commentable;

</pre><pre>
【 多态一对一关联 】
多态一对一相比多态一对多关联的区别是动态的一对一关联,比如个人和团队表,而无论个人还是团队都有一个头像需要保存但都会对应同一个头像表

morphOne('关联模型名','多态字段信息','多态类型');
关联模型名(必须)：关联的模型名称,可以使用模型名(如Member)或完整的命名空间模型名(如app\index\model\Member)。
多态字段信息(可选)：支持两种方式定义 如果是字符串表示多态字段的前缀,多态字段使用 多态前缀_type和多态前缀_id,如果是数组,表示使用['多态类型字段名','多态ID字段名'],默认为当前的关联方法名作为字段前缀。
多态类型(可选)：当前模型对应的多态类型,默认为当前模型名,可以使用模型名(如Member)或完整的命名空间模型名(如app\index\model\Member)。

理解了多态一对多关联后,多态一对一关联其实就很容易理解了,区别就是当前模型和动态关联的模型之间的关联属于一对一关系。

member
  id - integer
  name - string

team
  id - integer
  name - string

avatar
  id - integer
  avatar - string
  imageable_id - integer
  imageable_type - string

</pre><pre class="php">
会员模型：
namespace app\index\model;
use think\Model;
class Member extends Model{
    public function avatar(){    // 获取用户的头像
        return $this->morphOne('Avatar', 'imageable');
    }
}

团队模型：
namespace app\index\model;
use think\Model;
class Team extends Model{
    public function avatar(){    // 获取团队的头像
        return $this->morphOne('Avatar', 'imageable');
    }
}

头像模型的关联定义：
namespace app\index\model;
use think\Model;
class Avatar extends Model{
    public function imageable(){  获取头像对应的多态模型
        return $this->morphTo();
    }
}

</pre>

<h4>动态属性</h4><pre>
模型对象的关联属性可以直接作为当前模型对象的动态属性进行赋值或取值操作(延迟查询),虽然该属性并非数据表字段

namespace app\index\model;
use think\Model;
class User extends Model{
    public function profile(){
        return $this->hasOne('Profile');
    }
}

$user = User::find(1);                 // 查询模型数据
dump($user->profile);                  // 获取动态属性
$user->profile->phone = '1234567890';  // 给关联模型属性赋值
$user->profile->save();                // 保存关联模型数据

在获取动态属性profile的同时,模型会通过定义的关联方法去查询关联对象的数据并赋值给该动态属性,这是一种关联数据的“惰性加载”,只有真正访问关联属性的时候才会进行关联查询。

当有大量的关联数据需要查询的时候,一般都会考虑选择关联预载入的方式

</pre>

<h4>关联预载入</h4><pre>
关联查询的预查询载入功能,主要解决了N+1次查询的问题

例如下面的查询如果有3个记录,会执行4次查询：
$list = User::all([1,2,3]);
foreach($list as $user){
    dump($user->profile);   // 获取用户关联的profile模型数据
}

如果使用关联预查询功能,对于一对一关联来说,只有一次查询,对于一对多关联的话就可以变成2次查询,有效提高性能。
$list = User::with('profile')->select([1,2,3]);
foreach($list as $user){
    dump($user->profile);   // 获取用户关联的profile模型数据
}

支持预载入多个关联
$list = User::with('profile,book')->select([1,2,3]);

也可以支持嵌套预载入
$list = User::with('profile.phone')->select([1,2,3]);
foreach($list as $user){
    dump($user->profile->phone);  // 获取用户关联的phone模型
}

支持使用数组方式定义嵌套预载入,例如下面的预载入要同时获取用户的Profile关联模型的Phone、Job和Img子关联模型数据：
$list = User::with(['profile'=>['phone','job','img']])->select([1,2,3]);
foreach($list as $user){
    // 获取用户关联
    dump($user->profile->phone);
    dump($user->profile->job);
    dump($user->profile->img);
}

可以在模型的get和all方法中使用预载入,和使用select方法是等效的：
$list = User::all([1,2,3],'profile,book');

指定属性查询
$list = User::field('id,name')->with(['profile'=>function($query){$query->field('email,phone');}])->select([1,2,3]);
foreach($list as $user){
    dump($user->profile);  // 获取用户关联的profile模型数据
}

关联预载入名称是关联方法名,支持传入方法名的小写和下划线定义方式,例如如果关联方法名是userProfile和userBook的话：
$list = User::with('userProfile,userBook')->select([1,2,3]);
等效于：
$list = User::with('user_profile,user_book')->select([1,2,3]);

一对一关联预载入支持两种方式：JOIN方式(一次查询)和IN方式(两次查询),如果要使用IN方式关联预载入,在关联定义方法中添加
namespace app\index\model;
use think\Model;
class User extends Model{
    public function profile(){
        return $this->hasOne('Profile')->setEagerlyType(1);  // 设置预载入查询方式为IN方式
    }
}

默认使用IN查询方式,如果需要改为JOIN查询方式,使用
return $this->hasOne('Profile')->setEagerlyType(0);  // 设置预载入查询方式为JOIN方式

【 延迟预载入 】
有些情况下需要根据查询出来的数据来决定是否需要使用关联预载入,当然关联查询本身就能解决这个问题,因为关联查询是惰性的,不过用预载入的理由也很明显,性能具有优势。

延迟预载入仅针对多个数据的查询,因为单个数据的查询用延迟预载入和关联惰性查询没有任何区别,所以不需要使用延迟预载入。

如果数据集查询返回的是数据集对象,可以使用调用数据集对象的load实现延迟预载入：
$list = User::all([1,2,3]);   // 查询数据集
$list->load('cards');         // 延迟预载入
foreach($list as $user){
    dump($user->cards);       // 获取用户关联的card模型数据
}

如果数据集查询返回的是数组,系统提供了一个load_relation助手函数可以完成同样的功能。
$list = User::all([1,2,3]);            // 查询数据集
$list = load_relation($list,'cards');  // 延迟预载入
foreach($list as $user){
    dump($user->cards);                // 获取用户关联的card模型数据
}

</pre>

<h4>关联统计</h4><pre>
有时并不需要获取关联数据,而只是希望获取关联数据的统计(关联统计仅针对一对多或多对多的关联关系),这个时候可以使用withCount方法进行制定关联的统计。
关联统计功能会在模型的对象属性中自动添加一个以“关联方法名+_count”为名称的动态属性来保存相关的关联统计数据

$list = User::withCount('cards')->select([1,2,3]);
foreach($list as $user){
    echo $user->cards_count;  // 获取用户关联的card关联统计
}

如果需要对关联统计进行条件过滤,可以使用
$list = User::withCount(['cards'=>function($query){
    $query->where('status',1);
}])->select([1,2,3]);
foreach($list as $user){
    echo $user->cards_count;  // 获取用户关联的card关联统计
}

一对一关联关系使用关联统计是无效的,一般可以用exists查询来判断是否存在关联数据。

支持给关联统计指定统计属性名,例如：
$list = User::withCount(['cards'=>'card_count'])->select([1,2,3]);
foreach($list as $user){
    echo $user->card_count;  // 获取用户关联的card关联统计
}

</pre>
</div>

<div id="view">
<h2>视图</h2><pre>
视图功能由\think\View类配合视图驱动(模板引擎)类一起完成,目前的内置模板引擎包含PHP原生模板和Think模板引擎

</pre>
<h3>视图实例化</h3><pre>
1.如果控制器继承了\think\Conroller类则无需实例化视图类,直接调用控制器基类封装的关于视图类的方法
如果调用View类的其他方法,可以直接使用$this->view对象
return $this->fetch();     渲染模板输出
return $this->display();   渲染内容输出,字符串中的html标签会被解析
return $this->assign();    模板变量赋值
return $this->engine();    初始化模板引擎

return $this->assign('user','berlin');
return $this->fetch('hello',['name'=>'thinkphp','a'=>'a','b'=>'b']);  // 渲染输出时传入模板变量

渲染内容
display方法直接解析内容而不通过模板文件,渲染的内容中一样可以使用模板引擎的相关标签
return $this->display($content, $vars);
return $this->display('＜h1＞这是{$user}要输出的{$type}字符串＜/h1＞',['type' => '测试']);

2.助手函数view,无论是否继承think\Controller类助手函数都可以使用,不适用于内容渲染输出
return view('[模板文件]'[,'模板变量(数组)'][,模板替换(数组)]);
return view();
return view('hello',['name'=>'thinkphp']);
return view('', ['user' => $user], ['__PUBLIC__' => '/static']);

3.直接实例化视图类,实例化时可以传入模板引擎相关配置
$view = new View();
return $view->fetch('hello',['name'=>'thinkphp']);

</pre>

<h3>模板引擎初始化</h3><pre>
视图的模板文件可以支持不同的解析规则,默认无需手动初始化模板引擎。

【 配置文件 】
在应用配置文件中配置template参数即可
调用视图类进行操作或使用view助手函数的时候会自动实例化相关的模板引擎并传入参数

'template'         => [
  'type'         => 'Think',        // 模板引擎类型,支持php和think,支持扩展
  'view_path'    => './template/',  // 模板路径
  'view_suffix'  => 'html',         // 模板后缀
  'view_depr'    => DS,             // 模板文件名分隔符
  'tpl_begin'    => '{',            // 模板引擎普通标签开始标记
  'tpl_end'      => '}',            // 模板引擎普通标签结束标记
  'taglib_begin' => '{',            // 标签库标签开始标记
  'taglib_end'   => '}',            // 标签库标签结束标记
],

【 视图根目录 】
视图文件的根目录默认情况下位于模块的view目录,每个模块的视图目录可以通过模板参数view_path自定义。

view_base模板引擎参数可以用于定义全局的视图根目录,然后模块作为子目录。

【 调用engine方法初始化 】
视图类也提供了engine方法对模板解析引擎进行初始化或切换不同的模板引擎
return $this->engine('php')->fetch();  // 表示当前视图的模板文件使用原生php进行解析

【 使用第三方模板引擎 】
官方扩展库中提供了一个类似于angularjs语法的模板引擎think-angular

</pre>

<h3>模板变量赋值</h3><pre>
除了系统变量和配置参数输出无需赋值外,其他变量如果需要在模板中输出必须首先进行模板赋值操作

</pre>绑定数据到模板输出的几种方式<pre class="php">
1、assign方法
namespace index\app\controller;
class Index extends \think\Controller{
	public function index(){
		$this->assign('name','ThinkPHP');   // 模板变量赋值
		$this->assign('email','thinkphp@qq.com');
		$this->assign([                     // 或批量赋值
			'name' => 'ThinkPHP',
			'email' => 'thinkphp@qq.com'
		]);
		return $this->fetch('index');       // 模板输出
	}
}

class Index extends \think\Controller{
  public function index(){
    $view = new View();
    $data['name'] = 'ThinkPHP';         // 数组变量
    $data['email'] = 'thinkphp@qq.com';
    $view->assign('data',$data);
  }
}

在模板中的输出方式：
Name：{$data.name}
Email：{$data.email}
或
Name：{$data['name']}
Email：{$data['email']}

2、传入参数方法,fetch及display均可传入模版变量
namespace app\index\controller;
class Index extends \think\Controller{
	public function index(){
		return $this->fetch('index', ['name' => 'ThinkPHP', 'email' => 'thinkphp@qq.com']);
	}
}

namespace app\index\controller;
class Index extends \think\Controller{
	public function index(){
		$content = '{$name}-{$email}';
		return $this->display($content, ['name' => 'ThinkPHP', 'email' => 'thinkphp@qq.com']);
	}
}

public function index2(){
  $this->assign('user','berlin');
  return $this->display('＜h1＞这是{$user}要输出的{$type}字符串＜/h1＞',['type' => '测试']);
}

使用助手函数view渲染输出
return view('index', ['name'  => 'ThinkPHP', 'email' => 'thinkphp@qq.com']);

3、share方法
支持在任何地方使用静态方法进行模板变量赋值,全局静态模板变量最终会和前面使用方法赋值的模板变量合并
think\View::share('name','value');
think\View::share(['name1'=>'value','name2'=>'value2']);  // 批量赋值

4、对象赋值
class Index extends \think\Controller{
	public function index(){
		$view = $this->view;
		$view->name = 'ThinkPHP';
		$view->email = 'thinkphp@qq.com';
		return $view->fetch('index');
	}
}

class Index extends \think\Controller{
  public function index(){
    $view = new View();
    $view->name = 'thinkphp';    // 给模板变量赋值
    $view->person = ["name"=>"Tom","age"=>"23"];
    return $view->fetch();
  }
}

模板内容：Hello,{$name}！
模板编译后结果：Hello,<?php echo($name);?>！
运行的时候就会在模板中显示： Hello,ThinkPHP！

</pre>

<h3>模板渲染</h3><pre>
渲染输出不需要写模板文件的路径和后缀,这里面的控制器和操作并不一定需要有实际对应的控制器和操作,只是一个目录名称和文件名称,例如项目里面可能根本没有Public控制器,更没有Public控制器的menu操作,但一样可以使用return $this->fetch('public/menu');输出这个模板文件

渲染模板最常用的是继承系统的控制器基类后调用fetch方法,调用格式：
fetch('[模板文件]'[,'模板变量(数组)'])

模板文件的写法
1.不带任何参数
return $this->fetch();
系统按照默认规则自动定位当前操作的模板文件,当前模块/默认视图目录/当前控制器(小写)/当前操作(小写+下划线).html
默认的模板文件名规可以配置template.auto_rule的值为2设置全小写规则。
如果有更改模板引擎的view_depr设置(假设'view_depr'=>'_')则上面的自动定位规则变成：
当前模块/默认视图目录/当前控制器(小写)_当前操作(小写).html

2.[模块@][控制器/][操作]
常用写法,支持跨模块,表示模板的目录路径
return $this->fetch('admin@member/edit');  // 跨模块渲染模板
return $this->fetch('edit');               // 表示调用当前控制器下面的edit模板
return $this->fetch('member/read');        // 表示调用Member控制器下面的read模板。
$this->fetch('/menu');     // 从视图根目录开始读取模板,表示读取的模板是当前模块/默认视图目录/menu.html

【 渲染完整模板文件名 】
return $this->fetch('./template/public/menu.html');
return $view->fetch('./template/public/menu.html');   //模板文件位置是相对于应用的入口文件
return $this->fetch('./template/public/menu.tpl');    // 支持其他的后缀文件,只要该文件是一个实际存在的模板文件
这种方式需要带模板路径和后缀指定一个完整的模板文件位置,这里的template/public目录是位于当前项目入口文件位置下面

</pre>

<h3>模板输出替换:不需要花括号,直接使用</h3><pre>
要使全局替换生效,确保控制器类继承think\Controller或使用view助手函数渲染输出

</pre>支持对视图输出的内容进行字符替换<pre class="php">
namespace index\app\controller;
class Index extends \think\Controller{
    public function index(){
        $this->assign('name','thinkphp');
        return $this->fetch('index',[],['__PUBLIC__'=>'/public/']);
    }
}

</pre>如果需要全局替换的话,可以直接在配置文件中添加,然后就可以直接使用<pre class="php">
'view_replace_str'  =>  [
    '__PUBLIC__'=>'/public/',
    '__ROOT__' => '/',
]
'view_replace_str'  => [
    '__ROOT__'=>str_replace('/index.php','',\think\Request::instance()->root()),
    '__APP__'=>\think\Request::instance()->root(),
    '__STATIC__'=>str_replace('/index.php','',\think\Request::instance()->root()).'/static'
],

</pre><pre>
助手函数view也支持全局配置参数view_replace_str的设置,如果需要设置不同的替换参数,可以使用：
return view('index',['name'=>'thinkphp'],['__PUBLIC__'=>'/public/']);
在渲染模板或内容输出的时候就会自动根据设置的替换规则自动替换。

【 系统默认的替换输出 】
\think\view类中有定义,可以重新配置
__URL__      /tp509/public/index/index    当前模块控制器
__STATIC__   /tp509/public/static         public下的static文件夹
__JS__       /tp509/public/static/js
__CSS__      /tp509/public/static/css
__ROOT__     /tp509/public

//三种等效,但利用配置方便统一修改
{js href="../../../../public/static/index/js/jquery-3.1.1.js" /}
{css href="/tp509/public/static/index/css/base.css" /}
{css href="__PUBLIC__static/index/css/mb.css" /}      //配置

</pre>
</div>

<div id="tpl">
<h2>模板</h2>
<h3>使用内置的模板引擎来定义模板文件</h3><pre>
TP内置了一个基于XML的性能卓越的模板引擎,这是一个专门为TP服务的内置模板引擎,使用了XML标签库技术的编译型模板引擎,支持两种类型的模板标签,使用了动态编译和缓存技术,而且支持自定义标签库
每个模板文件在执行过程中都会生成一个编译后的缓存文件,其实就是一个可以运行的PHP文件。

内置的模板引擎支持普通标签和XML标签方式两种标签定义,分别用于不同的目的：
普通标签 主要用于输出变量和做一些基本的操作
XML标签 主要完成一些逻辑判断、控制和循环输出,并且可扩展

支持XML标签库和普通标签的混合定义;
支持直接使用PHP代码书写;
支持文件包含;
支持多级标签嵌套;
支持布局模板功能;
一次编译多次运行,编译和运行效率非常高;
模板文件和布局模板更新,自动更新模板缓存;
系统变量无需赋值直接输出;
支持多维数组的快速输出;
支持模板变量的默认值;
支持页面代码去除Html空白;
支持变量组合调节器和格式化功能;
允许定义模板禁用函数和禁用PHP语法;
通过标签库方式扩展。

默认的模板文件定义规则是：
视图目录/控制器名(小写)/操作名(小写)+模板后缀
默认的视图目录是模块的view目录,框架的默认视图文件后缀是.html

【 模板标签 】
模板文件可以包含普通标签和标签库标签,标签的定界符都可以重新配置

以 { 和 } 作为开始和结束标识,不能有空格和换行
1.普通标签用于变量输出和模板注释。
2.标签库标签用于模板变量输出、文件包含、条件控制、循环输出等功能,而且完全可以自己扩展功能;
5.0版本的标签库默认定界符和普通标签一样使用{和},是为了便于在编辑器里面编辑不至于报错

更改普通标签的起始标签和结束标签,可以更改下面的配置参数：
'template'  => [
  'type'      => 'think',    // 模板引擎
  'tpl_begin' =>    '<{',    // 普通标签开始标记
  'tpl_end'   =>    '}>'     // 普通标签结束标记
],

【 变量输出 】
字符串：{$name}
数组：{$data.name}  {$data['name']}
对象：{$data:name}  {$data->name}

【 系统变量输出 以{$Think打头 】
普通的模板变量需要首先赋值后才能在模板中输出,但系统变量可以直接在模板中输出
支持输出$_SERVER、$_ENV、$_POST、$_GET、$_REQUEST、$_SESSION和$_COOKIE变量

{$Think.server.script_name}
{$Think.session.user_id}
{$Think.cookie.name}
{$Think.get.pageNumber}
{$Think.post.pageNumber}
{$Think.request.pageNumber}

【 常量输出 】
{$Think.const.APP_PATH}
{$Think.APP_PATH}

【 配置输出 】
{$Think.config.default_module}

【 输出语言变量】
{$Think.lang.page_error}
{$Think.lang.var_error}

【 输出Request请求对象的方法参数 】
{$Request.方法名.参数}但只支持方法的第一个参数

{$Request.get.id}                  // 调用Request对象的get方法,传入参数为id
{$Request.param.name}              // 调用Request对象的param方法,传入参数为name
{$Request.param.user.nickname}     // 调用Request对象的param方法,传入参数为user.nickname
{$Request.root}                    // 调用Request对象的root方法
{$Request.root.true}               // 调用Request对象的root方法,并且传入参数true
{$Request.path}                    // 调用Request对象的path方法
{$Request.module}                  // 调用Request对象的module方法
{$Request.controller}              // 调用Request对象的controller方法
{$Request.action}                  // 调用Request对象的action方法
{$Request.ext}                     // 调用Request对象的ext方法
{$Request.host}                    // 调用Request对象的host方法
{$Request.ip}                      // 调用Request对象的ip方法
{$Request.header.accept-encoding}  // 调用Request对象的header方法
{$Request.header.referer}          // 上一个url

【 使用函数 】
变量输出使用的函数可以支持内置的PHP函数或用户自定义函数,甚至是静态方法
逗号分隔参数,变量是第一参数则可以省略###

{$data.name|md5}
{$create_time|date="y-m-d",###}                      //###标识变量位置,参数是函数的第一参数则不需要标识
{$data.name|substr=0,3}=={$data.name|substr=###,0,3} //编译后 echo (substr($data['name'],0,3));
{$name|md5|strtoupper|substr=0,3}                    //截取前三位,支持多函数过滤,从左到右过滤
{:substr(strtoupper(md5($name)),0,3)}
class="a{:mt_rand(1,5)}"

【 使用默认值 】
{$user.nickname|default="这家伙很懒,什么也没留下"}
{$Think.get.name|getName|default="名称为空"}      //系统变量,函数,默认值

【 使用运算符,不再支持常规函数用法 】
可以对模板输出使用运算符,包括对“+”“-” “*” “/” “%” “自增自减”的支持

{$user.score+10}
{$user['score']+10}
{$user['score']*$user['level']}
{$user['score']+myFun($user['level'])}
{$user['score']|myFun*10}          //错误的

【 三元运算符 】
{$status? '正常' : '错误'}
{$info['status']? $info['msg'] : $info['error']}
{$info.status? $info.msg : $info.error }
{$varname ?: 'no'}          // 解析后的php代码：echo $varname ? $varname : 'no';
{$varname.aa ?? 'xxx'}      // 解析后的php代码：echo isset($varname['aa']) ? $varname['aa'] : '默认值';
{$varname?='xxx'}           // 解析后的php代码：if(!empty($name)) echo 'xxx';

【 原样输出 】
用literal标签来防止模板标签被解析: {literal} Hello,{$name}！ {/literal}
literal标签还可以用于页面的JS代码外层,确保JS代码中的某些用法和模板引擎不产生混淆。
总之,所有可能和内置模板引擎的解析规则冲突的地方都可以使用literal标签处理。

配置'view_replace_str'替换参数会替换掉literal标签内的内容,可配置'template.tpl_replace_string'避免替换掉literal标签内的内容。

【 模板注释 】
模板注释在生成编译缓存文件后会自动删除,这一点和Html的注释不同
{/* 注释内容 */ }
{// 注释内容 }

【 php标签 】
{php}echo 'Hello,world!';{/php}
<?php  echo 'Hello,world!';  ?>

</pre>

<h3>模板布局</h3><pre>
TP的模板引擎内置了布局模板功能支持,可以方便的实现模板布局以及布局嵌套功能

【 1、全局配置方式 】
采用这种布局方式的情况下,一旦模板文件或布局模板文件发生修改都会导致模板重新编译

'template' => [                          //模板配置项
	'layout_on' => true,                   //首先开启,默认是不开启
	'layout_name' => 'layout/layoutname',  //设置布局入口文件名,默认为layout
	'layout_item' => '{__REPLACE__}'       //一个布局模板同时只能有一个特定替换字符串,默认{__CONTENT__}
]

layoutname.html模板的写法：
{include file="public/header" /}
{__CONTENT__}
{include file="public/footer" /}

namespace app\index\controller;
class User extends think\Controller{
	public function add(){
		return $this->fetch('add');
	}
}

渲染流程：
1.首先会渲染 application/index/view/layout/layoutname.html 模板
2.读取layoutname模板之后会再解析user/add.html模板文件,并把解析后的内容替换到layout布局模板文件的{__CONTENT__}特定字符串

如果某些页面不需要使用布局模板功能,可以在模板文件开头加上 {__NOLAYOUT__} 字符串

【 2、模板标签模式 】
这种布局模板不需要在配置文件中设置参数,也不需要开启layout_on,直接在模板文件中指定布局模板即可,相关的布局模板调整也在模板中进行
一个模板文件中只能使用一个布局模板,如果模板文件中没有使用任何layout标签则表示当前模板不使用任何布局

1.首先关闭前面的layout_on设置,否则可能出现布局循环
2.在模板文件头部添加布局标签
{layout name="layout" /}    // 表示当前模板文件需要使用layout.html布局模板文件
或{layout name="Layout/newlayout" replace="[__REPLACE__]" /}

【 3、使用内置的layout方法控制模板布局 】
namespace app\index\controller;
class User extends think\Controller{
	public function add(){
		$this->view->engine->layout(true);                //参数true采用默认的layout布局模板
		return $this->fetch('add');
	}
  public function add1(){
    $this->view->engine->layout('Layout/newlayout');   // 指定布局模板名称
    return $this->fetch('add1');
  }
  public function add2(){
    $this->view->engine->layout(false);                // false表示临时关闭当前模板的布局功能
    return $this->fetch('add2');
  }
  public function add3(){
    $this->view->engine->layout('layout','[__REPLACE__]');   // 动态使用布局
    return $this->fetch('add3');
  }
}

</pre>

<h3>模板继承</h3><pre>
模板继承是一项更加灵活的模板布局方式,模板继承不同于模板布局,可以说是在模板布局的上层
模板可以定义一个基础模板或布局,并且其中定义相关的区块(block),然后继承(extend)该基础模板的子模板中就可以对基础模板中定义的区块进行重载定义
模板继承的优势其实是设计基础模板中的区块(block)和子模板中替换这些区块

//block标签中可以包含任何模板内容,包括其他标签和变量
{block name="title"}＜title＞{$web_title}＜/title＞{/block}
{block name="include"}{include file="Public:header" /}{/block}  //区块中加载外部文件

</pre><pre class="php">
1.base.html基础模板：
< html>
< head>
< meta http-equiv="Content-Type" content="text/html; charset=utf-8">
< title>{block name="title"}标题{/block}< /title>
< /head>
< body>
{block name="menu"}菜单{/block}
{block name="left"}左边分栏{/block}
{block name="main"}主内容{/block}
{block name="right"}右边分栏{/block}
{block name="footer"}底部{/block}
< /body>
< /html>

2.然后在子模板即当前操作的入口模板中使用继承：
如果没有对基础模板中的区块进行重载定义则表示沿用基础模板中的区块定义

{extend name="base" /}
{block name="title"}{$title}{/block}
{block name="menu"}
	< a href="/" >首页< /a>
	< a href="/info/" >资讯< /a>
	< a href="/bbs/" >论坛< /a>
{/block}

{block name="left"}{/block}    //定义了一个空的区块,则表示删除基础模板中的该区块内容

{block name="main"}
	{volist name="list" id="vo"}
	< a href="/new/{$vo.id}">{$vo.title}< /a>< br/>
	{$vo.content}
	{/volist}
{/block}

{block name="right"}
	最新资讯：
	{volist name="news" id="new"}
	< a href="/new/{$new.id}">{$new.title}< /a>< br/>
	{/volist}
{/block}

{block name="footer"}
	{__block__}@ThinkPHP 版权所有  //表示引用所继承模板对应区块的内容到这个位置,最终合并内容
{/block}

</pre><pre>
extend标签的用法和include标签一样,也可以加载其他模板：
{extend name="Public:base" /}
或使用绝对文件路径加载
{extend name="./Template/Public/base.html" /}

在当前子模板中只能定义基础模板中已经定义的区块而不能定义其他的模板内容,否则将会直接忽略
模板可以多级继承,比如B继承了A,而C又继承了B,最终C中的区块会覆盖B和A中的同名区块,但C和B中的区块必须是A中已定义过的。
子模板中的区块定义顺序是随意的,模板继承的用法关键在于基础模板如何布局和设计规划了,如果结合原来的布局功能则会更加灵活。

</pre>

<h3>标签库</h3><pre>
内置的模板引擎除了支持普通变量的输出之外,更强大的地方在于标签库功能
标签库分为内置和扩展标签库,内置标签库是Cx标签库,无须导入

标签库类似于Java的Struts中的JSP标签库,每一个标签库是一个独立的标签库文件,标签库中的每一个标签完成某个功能,采用XML标签方式,包括开放标签和闭合标签

【 导入标签库 】
{taglib name="html" /}
{taglib name="html,article" /}

导入标签库后就可以使用标签库中定义的标签了
{article:read name="hello" id="data" }  //article标签库中read标签
	{$data.id}:{$data.title}
{/article:read}

内置标签库可以简化模板中标签的使用,所以还可以把其他的标签库定义为内置标签库(前提是多个标签库没有标签冲突的情况)
'taglib_build_in'=>'cx,article'

配置后上面的标签用法就可以改为：
{read name="hello" id="data" }
  {$data.id}:{$data.title}
{/read}

【 标签库预加载 】
在应用或模块的配置文件中添加'taglib_pre_load' => 'article,html'就不再需要taglib标签来导入标签库操作

</pre>
</div>

<div id="tag">
<h3>内置标签</h3><pre>
变量输出使用普通标签就足够了,但要完成其他的控制、循环和判断功能就需要借助模板引擎的标签库功能了,系统内置标签库的所有标签无需引入标签库即可直接使用

【 include标签 包含文件 】
在当前模版文件中包含其他的模版文件使用include标签,包含的模板文件中不能再使用模板布局或模板继承
包含模版文件并不会自动调用控制器的方法,也就是说包含的其他模版文件中的变量赋值需要在当前操作中完成

{include file='模版文件1,模版文件2,...' /}

1.使用模版表达式：模块@控制器/操作
{include file="public/header" /}              // 包含头部模版header
{include file="public/menu" /}                // 包含菜单模版menu
{include file="blue/public/menu" /}           // 包含blue主题下面的menu模版
{include file="public/header,public/menu" /}  // 一次包含多个模版

2.使用模版文件(包含完整路径),路径以 项目目录/public/ 路径下为起点
{include file="../application/view/default/public/header.html" /}

3.传入参数
无论使用什么方式包含外部模板,Include标签支持在包含文件的同时传入参数

{include file="Public/header" title="$title" keywords="开源WEB开发框架" /}
header.html文件里面使用title和keywords变量,title标签包含[title],meta标签name="keywords" content="[keywords]"
上面title参数传入的是个变量$title,模板内的[title]最终会替换成$title的值,当然$title这个变量必须要存在

包含文件中可以再使用include标签包含别的文件,但注意不要形成A包含A,或A包含B而B又包含A这样的死循环

由于模板解析的特点,从入口模板开始解析,如果外部模板有所更改,模板引擎并不会重新编译模板,除非在调试模式下或缓存已经过期。如果部署模式下修改了包含的外部模板文件后,需要把模块的缓存目录清空,否则无法生效

【 资源文件加载 】
传统方式
＜script type='text/javascript' src='/static/js/common.js'＞
＜link rel="stylesheet" type="text/css" href="/static/css/style.css" /＞

{load href="/static/js/common.js" /}
{load href="/static/css/style.css" /}

{load href="/static/js/common.js,/static/css/style.css" /}

{js href="/static/js/common.js" /}
{css href="/static/css/style.css" /}

【 volist标签 循环输出 】
常用于查询数据集的结果输出

$list = User::all();
$this->assign('list',$list);

{volist name="list" id="vo" empty="暂时没有数据"}    // id可以自定义
	{$vo.id}:{$vo.name}＜br/＞
{/volist}

{volist name="list" id="vo" offset="5" length='10'}  //从第5开始,到15
	{$vo.name}
{/volist}

{volist name="list" id="vo" mod="2" }          //当前的循环次数对2取余
	{$mod}									   //输出0 1 0 1
	{eq name="mod" value="1"}{$vo.name}{/eq}     //偶数记录
{/volist}

{volist name="list" id="vo" mod="5" }          //控制一定记录的换行
	{$vo.name}
	{eq name="mod" value="4"}＜br/＞{/eq}
{/volist}

empty属性不支持直接传入html语法,但可以支持变量输出
$this->assign('empty','＜span class="empty"＞没有数据＜/span＞');
$this->assign('list',$list);
{volist name="list" id="vo" empty="$empty" }   //empty属性不支持HTML语法,但是支持变量
	{$vo.id}|{$vo.name}
{/volist}

{volist name="list" id="vo" key="k" }   //输出循环变量
	{$k}.{$vo.name}
{/volist}

{volist name="list" id="vo" }           //没有指定key属性是默认为循环变量 i
	{$i}.{$vo.name}					              //$i 表示第几次循环,输出1 2 3
{/volist}

{volist name="list" id="vo" }           //输出数组的索引,和循环变量不同的是,这个key是由数据本身决定,而不是循环控制的
	{$key}.{$vo.name}
{/volist}

{volist name=":fun('arg')" id="vo"}     //直接使用函数设定数据集,而不需要在控制器中给模板变量赋值传入数据集变量
	{$vo.name}
{/volist}

标签嵌套
{volist name="list" id="vo"}
  {volist name="vo['sub']" id="sub"}
    {$sub.name}
  {/volist}
{/volist}

</pre><pre class="html">
<volist name="art" id="vo" empty="暂时没有数据">
    <dl class="content">
      <dt><h2>{$vo.id}.{$vo.title}</h2></dt>
      <dd>{$vo.content}</dd>
    </dl>
    <hr>
  </volist>
<h2>标签外使用变量：{$vo['id']+1}</h2>

</pre><pre>
【 foreach标签 比volist更简单的循环输出 】
{foreach $list as $vo}
	{$vo.id}:{$vo.name}
{/foreach}

{foreach name="list" item="vo"}            //item为循环变量
	{$vo.id}:{$vo.name}
{/foreach}

{foreach name="list" item="vo" }           //输出索引
	{$key}|{$vo}
{/foreach}

{foreach name="list" item="vo" key="k" }   //定义索引的变量名
	{$k}|{$vo}
{/foreach}

【 for标签 循环输出 】
comparison默认lt,name默认i,step默认1
{for start="开始值" end="结束值" comparison="" step="步进值" name="循环变量名" }{/for}

{for start="1" end="100"}
	{$i}
{/for}

【 比较标签 】
用于简单的变量比较,可以和esle标签一起使用

eq equal 		    等于
neq  notequal   不等于
gt 				      大于
egt 			      大于等于
lt 				      小于
elt 			      小于等于
heq 			      恒等于
nheq		        不恒等于

{比较标签 name="变量" value="值/变量/常量"} 内容 {/比较标签}
{eq name="name" value="value"}  相等 {else/}  不相等 {/eq}
{compare name="name" value="5" type="eq"}value{/compare}

{eq name="name" value="value"} value {/eq}                     //name变量的值等于value就输出value
{eq name="vo.name" value="5"} {$vo.name} {/eq}                 //vo对象或数组
{eq name="vo['name']" value="5"} {$vo.name} {/eq}              //vo对象或数组
{eq name="vo:name|strlen" value="5"}{$vo.name}{/eq}            //使用函数
{eq name="vo:name" value="$a"}{$vo.name}{/eq}                  //比较标签的值使用变量
{eq name="Think.get.name" value="value"}相等{else/}不相等{/eq}  //系统变量

【 if标签 】
复杂的条件判断
由于if标签的condition属性里面基本上使用的是php语法,尽可能使用判断标签和Switch标签会更加简洁,原则上能够用switch和比较标签解决的尽量不用if标签完成。因为switch和比较标签可以使用变量调节器和系统变量。如果某些特殊的要求下面,IF标签仍然无法满足要求的话可以使用原生php代码或PHP标签来直接书写代码

{if condition="($name == 1) OR ($name > 100) "} value1
{elseif condition="$name eq 2"/}value2
{else /} value3
{/if}

{if condition="strtoupper($user['name']) neq 'THINKPHP'"}ThinkPHP  //condition属性使用PHP代码
{else /} other Framework
{/if}

condition属性可以支持点语法和对象语法,例如自动判断user变量是数组还是对象
{if condition="$user.name neq 'ThinkPHP'"}ThinkPHP
{else /} other Framework
{/if}

或知道user变量是对象
{if condition="$user:name neq 'ThinkPHP'"}ThinkPHP
{else /} other Framework
{/if}

简介写法：
{if condition="表达式"}
{if (表达式)}
{if 表达式}

【 switch标签 】
break属性,表示是否需要break,默认是会自动添加break,break=0表示不需要

{switch name="变量" }
	{case value="值1" break="0或1"}输出内容1{/case}  // 默认是会自动添加break,如果不要break设置break=0
	{case value="值2"}输出内容2{/case}
	{default /}默认情况
{/switch}

{switch name="User.level"}
  {case value="1"}value1{/case}
  {case value="2"}value2{/case}
  {default /}default
{/switch}

{switch name="Think.get.userId|abs"}   //使用系统变量和函数
	{case value="1|2"}admin{/case}
	{default /}default
{/switch}

{switch name="Think.get.type"}         //多条件判断
	{case value="gif|png|jpg"}图像格式{/case}
	{default /}其他格式
{/switch}

{switch name="User.userId"}            //value属性使用变量时不再支持多条件判断
	{case value="$adminId"}admin{/case}
	{case value="$memberId"}member{/case}
	{default /}default
{/switch}

简介写法：
{switch $User.userId}
	{case $adminId}admin{/case}
	{case $memberId}member{/case}
{/switch}

【 范围判断 】
in notin between notbetween
{range name="id" value="1,2,3" type="in"} 输出内容1 {/range}

{in name="id" value="1,2,3"} id在范围内 {/in}
{in name="id" value="1,2,3"} id在范围内 {else/} id不在范围内 {/in}
{in name="Think.get.id" value="1,2,3"} $_GET['id'] 在范围内  {/in} //系统变量
{in name="id" value="$range"} id在范围内 {/in}           //$range变量可以是数组或逗号分隔的字符串
{in name="id" value="$Think.post.ids"} id在范围内 {/in}

{between name="id" value="1,10"} 输出内容1 {else/} 输出内容2 {/between}
{between name="id" value="1,3,10"} 输出内容1 {/between}  // value只需要一个区间范围,即只支持两个值,后面的值无效
{between name="id" value="A,Z"} 输出内容1 {/between}     // 支持字符串判断
{between name="Think.post.id" value="1,5"} 输出内容1 {/between}  // name属性可以直接使用系统变量
{between name="id" value="$range"} 输出内容1 {/between}          // value属性也可以使用变量,可以是字符串或数组
{between name="id" value="$Think.get.range"} 输出内容1 {/between}// value还支持系统变量

【 present标签 】
用于判断某个变量是否已经定义

{present name="name"} name已经赋值 {/present}
{notpresent name="name"} name还没有赋值 {/notpresent}
{present name="name"} name已经赋值 {else /} name还没有赋值 {/present}
{present name="Think.get.name"} $_GET['name']已经赋值  {/present}  //系统变量

【 empty标签 】
用于判断某个变量是否为空

{empty name="name"} name为空值 {/empty}
{notempty name="name"} name不为空 {/notempty}
{empty name="name"} name为空 {else /} name不为空 {/empty}
{empty name="Think.get.name"} $_GET['name']为空值 {/empty} //系统变量

【 defined标签 】
用于判断某个常量是否有定义,name属性的值要注意严格大小写

{defined name="NAME"} NAME常量已经定义 {/defined}
{notdefined name="NAME"} NAME常量未定义 {/notdefined}
{defined name="NAME"} NAME常量已经定义 {else /} NAME常量未定义 {/defined}

【 原生PHP 】
如果设置了tpl_deny_php参数为true,就不能在模板中使用原生的PHP代码,但是仍然支持PHP标签输出
PHP标签内不能嵌套其他tp标签

{php}echo 'Hello,world!';{/php}
<?php echo 'Hello,world!'; ?>

【 定义变量或常量标签 】
{assign name="var" value="123" /}              //定义变量
{assign name="Think.get.id" value="123" /}     //系统变量,表示在模板中给$_GET['id']赋值123
{assign name="var" value="$val" /}             //value属性支持变量
{assign name="var" value="$Think.get.name" /}  //value属性支持系统变量

{define name="MY_DEFINE_NAME" value="3" /}     //定义常量
{define name="MY_DEFINE_NAME" value="$name" /}
{define name="MY_DEFINE_NAME" value="$Think.get.name" /}

</pre>
</div>


<div id="page">
<h3>分页功能</h3><pre>
TP5.0内置分页实现,要给数据添加分页输出功能可以直接在Db类查询的时候调用paginate方法
分页功能会自动生成带有总分页数据和上下页码,如要简洁分页只有上下页功能只需paginate(10,true)

</pre>分页实例1<pre class="php">
$users = Db::name('user')->where('status',1)->paginate(10);   // 查询状态为1的用户数据 并且每页显示10条数据
$this->assign('users', $usesr);                               // 把分页数据赋值给模板变量list
$this->assign('count', count($users));
return $this->fetch();                                        // 渲染模板输出

//模板文件分页输出代码
< div>
  < h2>用户列表({$count})< /h2>
  < ul>
    {volist name='users' id='user'}
      < li> {$user.nickname}< /li>
    {/volist}
  < /ul>
< /div>
{$user->render()}

</pre>User模型,分页实例2,支持传入总记录数而不会自动进行总数计算<pre class="php">
$users = User::where('status',1)->paginate(10,100);  // 查询状态为1的用户数据 并且每页显示10条数据,总记录数100
$page = $users->render();                            // 获取分页显示
$this->assign('users', $users);                      // 模板变量赋值
$this->assign('page', $page);
return $this->fetch();                               // 渲染模板输出

//模板文件中分页输出代码
< div>
  < ul>
    {volist name='users' id='user'}
      < li> {$user.nickname}< /li>
    {/volist}
  < /ul>
< /div>
{$page}

</pre>User模型,分页实例3<pre class="php">
public function index(){
  $users = UserModel::paginate(3);                 // 分页输出列表 每页显示3条数据
  $this->assign('users',$users);
  return $this->fetch();
}

//模板文件分页输出代码
< div>
  < h2>用户列表({$users->total()})< /h2>
  < ul>
    {volist name='users' id='user'}
      < li> {$user.nickname}< /li>
    {/volist}
  < /ul>
< /div>
{$user->render()}

</pre>默认生成的分页输出是完整分页功能,带总分页数据和上下页码,分页样式只需要通过样式修改即可,完整分页默认生成的分页输出代码为<pre class="html">
< ul class="pagination">
  < li>< a href="?page=1">& laquo;< /a>< /li>
  < li>< a href="?page=1">1< /a>< /li>
  < li class="active">< span>2< /span>< /li>
  < li class="disabled">< span>& raquo;< /span>< /li>
< /ul>

</pre><pre>
【 分页后数据处理 】
支持分页类后数据直接each遍历处理,方便修改分页后的数据,而不是只能通过模型的获取器来补充字段。

$list = User::where('status',1)->paginate()->each(function($item, $key){
    $item->nickname = 'think';
});

如果是Db类操作分页数据的话,each方法的闭包函数中需要使用返回值
$list = Db::name('user')->where('status',1)->paginate()->each(function($item, $key){
    $item['nickname'] = 'think';
    return $item;
});

【 简洁分页 】
由于简洁分页模式不需要查询总数据数,因此可以提高查询性能。
如果仅仅需要输出一个仅仅只有上下页的分页输出,可以使用下面的简洁分页代码：

</pre><pre class="php">
$list = User::where('status',1)->paginate(10,true);  // 查询状态为1的用户数据 并且每页显示10条数据
$this->assign('list', $list);                        // 把分页数据赋值给模板变量list
return $this->fetch();                               // 渲染模板输出

简洁分页模式的输出代码为：
< ul class="pager">
  < li>< a href="?page=1">& laquo;< /a>< /li>
  < li class="disabled">< span>& raquo;< /span>< /li>
< /ul>

</pre><pre>
【 分页参数 】
list_rows   每页数量
page        当前页
path        url路径
query       url额外参数
fragment    url锚点
var_page    分页变量
type        分页类名

分页参数的设置方式有两种
1、在配置文件中定义
//分页配置
'paginate'     => [
  'type'     => 'bootstrap',  // type属性支持命名空间,如\org\page\bootstrap
  'var_page' => 'page',
],

2、在调用分页方法的时候传入
$list = Db::name('user')->where('status',1)->paginate(10,true,[
    'type'     => 'bootstrap',
    'var_page' => 'page',
]);

</pre>
</div>

<div id="cache">
<h3>\think\Cache类提供缓存功能支持</h3><pre>
【 设置 】
缓存支持采用驱动方式,所以缓存在使用之前需要进行连接操作即缓存初始化操作。

$options = [
  'type'  =>  'File',                      // 缓存类型为File
  'expire'=>  0,                           // 缓存有效期为永久有效
  'prefix'=>  'think',                     // 缓存前缀(默认为空)
  'path'  =>  APP_PATH.'runtime/cache/',   // 指定缓存目录
];
Cache::connect($options);

或通过定义配置参数的方式,在应用配置文件中添加：
'cache'  => [
  'type'   => 'File',
  'path'   => CACHE_PATH,
  'prefix' => '',
  'expire' => 0,
],

支持的缓存类型包括file、memcache、wincache、sqlite、redis和xcache。

【 使用 】
缓存初始化之后就可以进行相关缓存操作了。
如果通过配置文件方式定义缓存参数的话,可以无需手动进行缓存初始化操作,可以直接进行缓存读取和设置等操作

设置缓存
设置成功返回true,否则返回false
Cache::set('name',$value,3600);  // 缓存有效期一个小时
Cache::set('name',$value,new DateTime('2017-10-1 12:00'));  // 缓存有效期支持指定过期时间

缓存自增自减
针对数值类型的缓存数据可以使用自增自减操作
Cache::inc('name');    // name自增(步进值为1)
Cache::inc('name',3);  // name自增(步进值为3)
Cache::dec('name');    // name自减(步进值为1)
Cache::dec('name',3);  // name自减(步进值为3)

获取缓存数据
dump(Cache::get('name'));     // 如果name值不存在则默认返回false
dump(Cache::get('name',''));  // 支持指定默认值,表示如果name值不存在则返回空字符串

删除缓存
Cache::rm('name');

获取并删除缓存
Cache::pull('name');           // 如果name值不存在则返回null

清空缓存
Cache::clear();

不存在则写入缓存数据后返回
Cache::remember('name',function(){
  return time();
});

获取缓存对象
可以获取缓存对象,并且调用驱动类的高级方法
$cache = Cache::init();
$handler = $cache->handler();  // 获取缓存对象句柄

【 助手函数cache 】
$options = [
  'type'   => 'File',
  'expire' => 0,
  'path'   => APP_PATH . 'runtime/cache/',
];

cache($options);                  // 缓存初始化,不进行缓存初始化的话默认使用配置文件中的缓存配置
cache('name', $value, 3600);      // 设置缓存数据
var_dump(cache('name'));          // 获取缓存数据
cache('name', NULL);              // 删除缓存数据
cache('test', $value, $options);  // 设置缓存的同时并且进行参数设置

【 缓存标签 】
支持给缓存数据打标签
Cache::tag('tag')->set('name1','value1');
Cache::tag('tag')->set('name2','value2');

批量设置缓存标签
Cache::set('name1','value1');
Cache::set('name2','value2');
Cache::tag('tag',['name1','name2']);

清除tag标签的缓存数据
Cache::clear('tag');

【 同时使用多个缓存类型 】
cache.type配置为complex之后,就可以缓存多个缓存类型和缓存配置,每个缓存配置的方法和之前一样,并且可以给相同类型的缓存类型(使用不同的缓存标识)配置不同的缓存配置参数

</pre><pre class="php">
'cache' =>  [
  'type'  =>  'complex',                   // 使用复合缓存类型
  'default'   =>  [                        // 默认使用的缓存
      'type'   => 'File',                  // 驱动方式
      'path'   => CACHE_PATH,              // 缓存保存目录
  ],
  'file'   =>  [                           // 文件缓存
      'type'   => 'file',                  // 驱动方式
      'path'   => RUNTIME_PATH . 'file/',  // 设置不同的缓存保存目录
  ],
  'redis'   =>  [                          // redis缓存
      'type'   => 'redis',                 // 驱动方式
      'host'       => '127.0.0.1',         // 服务器地址
  ],
],


当使用Cache::set('name', 'value');Cache::get('name');时,其实使用的是default缓存标识的缓存配置,如果需要切换到其它的缓存标识操作,可以使用：
Cache::store('file')->set('name','value');   // 切换到file操作
Cache::get('name');
Cache::store('redis')->set('name','value');  // 切换到redis操作
Cache::get('name');

</pre>
</div>

<div id="cmd">
<h2>命令行工具</h2><pre>
TP5.0支持Console应用,通过命令行的方式执行一些URL访问不方便或安全性较高的操作
TP5.0开始增加了一个命令行工具think,并且内置了一些指令,可以帮助开发者在开发或运维阶段执行一些指令
命令行工具需要在命令行下面执行,请先确保php.exe已经加入了系统环境变量。

应用的命令行入口文件是应用根目录的think文件,其内容如下：
// 定义项目路径
define('APP_PATH', './application/');
// 加载框架命令行引导文件
require './thinkphp/console.php';

console命令的执行格式一般为：
>php think 指令(区分大小写) 参数

系统自带命令
build             自动生成目录和文件
help              帮助
list              指令列表
clear             清除缓存指令
make:controller   创建控制器文件
make:model        创建模型文件
optimize:autoload 生成类库映射文件
optimize:config   生成配置缓存文件
optimize:route    生成路由缓存文件
optimize:schema   生成数据表字段缓存文件

【 命令行生成模块test 】
1、首先需要在application目录下面创建一个build.php定义文件
return [
  // 定义test模块的自动生成
  'test' => [
    '__dir__' => ['controller', 'model', 'view'],
    'controller' => ['User', 'UserType'],
    'model' => ['User', 'UserType'],
    'view' => ['index/index', 'index/test'],
  ],
];

2、然后在命令行下面,执行php think build
test
├─controller         // 类文件没继承\think\Controller
│ ├─Index.php        // 自动生成
│ ├─User.php
│ └─UserType.php
├─model               // 类文件继承\think\Model
│ ├─User.php
│ └─UserType.php
├─view
│ └─index
│   ├─index.html
│   └─test.html
└─common.php          // 自动生成

【 make指令单独生成某个应用类库文件 】
默认生成的控制器类是属于资源控制器,并且继承了\think\Controller

> php think make:controller test/Blog          # 自动为test模块生成一个Blog控制器文件
> php think make:controller test/New --plain   # 生成空控制器继承\think\Controller
> php think make:model test/Blog               # 生成一个空的模型文件,继承\think\Model

【 生成类库映射文件 】
在生成类库文件之后,强烈建议使用命令行生成类库映射文件,可以提高自动加载的性能：
>php think optimize:autoload
执行完毕会在RUNTIME_PATH目录下面生成一个classmap.php文件,包括了系统和应用的所有类库文件的映射列表

【 生成路由缓存文件 】
如果应用定义了大量的路由规则,那么建议在实际部署后生成路由缓存文件,可以免去路由注册的开销,从而改善路由的检测效率
>php think optimize:route
执行完毕会在RUNTIME_PATH目录下面生成一个route.php文件,包括了应用的所有路由规则定义列表。

路由缓存文件只会缓存在application/route.php文件中配置和动态注册的路由规则,因此请确保没有在其它的文件中进行路由的注册。

【 生成数据表字段缓存文件 】
如果希望提高查询的性能,可以通过生成字段缓存来减少查询
>php think optimize:schema
执行完会在RUNTIME_PATH目录下面创建schema目录,然后在该目录下按照database.table.php的文件命名生成数据表字段缓存文件。

也可以指定数据库生成字段缓存(必须有用户权限),例如下面指定生成demo数据库下面的所有数据表的字段缓存信息。
php think optimize:schema --db demo

还可以读取模块的模型类来生成数据表字段缓存(这个适合多数据库连接的情况)
php think optimize:schema --module index
会读取index模块的模型来生成数据表字段缓存。

如果模型类没有继承think\Model或者是抽象类的话,不会生成对应模型的字段缓存。
更新数据表字段缓存也是同样的方式,每次执行都会重新生成缓存。如果需要单独更新某个数据表的缓存,可以使用：
php think optimize:schema --table think_user
支持指定数据库名称
php think optimize:schema --table demo.think_user

【 指令扩展 】
命令行的作用远不止生成文件这么简单,同时应用也可以很方便的扩展自己的指令

扩展一个用于清理缓存目录的指令clear
最新版本已经内置clear指令了,下面的示例可以直接使用内置的clear指令进行学习和测试
该指令并不会删除目录,仅仅删除目录下面(包括子目录)的文件

首先创建一个指令类app\console\Clear
一个合法的指令类,没有固定的目录和命名空间要求,但必须继承think\console\command\Command或其子类,并且定义configure和execute两个方法

namespace app\console;
use think\console\command\Command;
use think\console\Input;
use think\console\input\Option;
use think\console\Output;
class Clear extends Command{
  protected function configure(){
    // 指令配置
    $this
    ->setName('clear')
    ->addOption('path', 'd', Option::VALUE_OPTIONAL, 'path to clear', null)
    ->setDescription('Clear runtime file');
  }
  protected function execute(Input $input, Output $output){
    $path = $input->getOption('path') ?: RUNTIME_PATH;
    $files = scandir($path);
    if ($files) {
      foreach ($files as $file) {
        if ('.' != $file && '..' != $file && is_dir($path . $file)) {
          array_map('unlink', glob($path . $file . '/*.*'));
        } elseif (is_file($path . $file)) {
          unlink($path . $file);
        }
      }
    }
    $output->writeln("Clear Successed");
  }
}

然后在application目录下面的command.php(如果不存在则创建)文件中添加如下内容：
return [
  '\app\console\Clear',
];
表示给应用增加一个命令行 Clear 指令,我们可以用 list 指令来验证是否已经成功注册 Clear 指令：
>php think list

测试下该指令：
>php think clear

clear指令还定义了一个 --path 参数用于指定目录,下面是一个指定目录删除文件的用法,我们仅仅需
要删除日志文件：
>php think clear --path d:\www\tp5\runtime\log\
Clear Successed
--path 参数还有一个简化用法 -d
>php think clear -d d:\www\tp5\runtime\log\

【 命令行调试 】
命令行一旦执行错误,只能看到简单的错误信息,如果需要调试详细的Trace信息可以使用-v参数来显示
>php think clear -v

【 命令行颜色支持 】
为了让命令行工具更加有趣,think命令行支持颜色输出,并且内置了几种颜色样式,还可自定义颜色样式输出

</pre>添加一个color指令用于演示颜色输出效果<pre class="php">
namespace app\console;
use think\console\command\Command;
use think\console\Input;
use think\console\Output;
use think\console\output\formatter\Style;
class Color extends Command{
  protected function configure(){
    $this->setName('color')->setDescription('Show Color text');
  }
  protected function execute(Input $input, Output $output){
    // 输出info样式
    $output->writeln("<info>this is info</info>");
    // 输出error样式
    $output->writeln("<error>this is error</error>");
    // 输出comment样式
    $output->writeln("<comment>this is comment</comment>");
    // 输出question样式
    $output->writeln("<question>this is question</question>");
    // 输出highlight样式
    $output->writeln("<highlight>this is highlight</highlight>");
    // 输出warning样式
    $output->writeln("<warning>this is warning</warning>");
    // 输出混合样式
    $output->writeln("this is <info>info</info>, this is <error>error</error>,this is <comment>comment</comment>,this is <question>question</question>,this is <highlight> highlight</highlight>, this is <warning>warning</warning>");
    // 自定义输出样式
    $output->getFormatter()->setStyle('custom', new Style('black', 'white'));
    $output->writeln("<custom>this is style</custom>");
  }
}

</pre><pre>
command.php 定义修改如下：
return [
  '\app\console\Clear',
  '\app\console\Color',
];

然后执行下面的指令：
>php think color

【 调用命令 】
在代码里面可以直接调用执行命令行的某个命令

namespace app\index\controller;
use think\Console;
class Index{
  public function index(){
    // 调用命令行的指令
    $output = Console::call('make:model',['index/Blog']);
    return $output->fetch();
  }
}

Console::call方法的第一个参数就是指令名称,后面的第二个参数是一个数组,表示调用的参数。
如果要创建一个demo模块的话,应该是Console::call('build',['--module', 'demo']);

当访问http://tp5.com页面会输出Model created successfully.
可以在 application/index/model/ 目录下面发现已经生成了一个 Blog 模型文件。
再次刷新页面的话,会看到页面输出Model already exists!表示模型已经创建过了,无需再次创建。

使用 Console::call 方法调用指令执行不会看到最终的输出结果,需要使用fetch方法获取输出信息,一旦发生错误,则会抛出异常。

</pre>
</div>

<div id="session">
<h3>session</h3><pre>
如果没有使用Session类进行Session操作的话如直接操作$_SESSION,必须手动初始化或直接调用session_start()方法进行session初始化

默认支持的session设置参数包括：
type            session类型
expire          session过期时间
prefix          session前缀
auto_start      是否自动开启
use_trans_sid   是否使用use_trans_sid
var_session_id  请求session_id变量名
id              session_id
name            session_name
path            session保存路径
domain          session cookie_domain
use_cookies     是否使用cookie
cache_limiter   session_cache_limiter
cache_expire    session_cache_expire

Session初始化
TP5.0中使用\think\Session类进行Session相关操作,Session会在第一次调用Session类时按照配置的参数自动初始化,然后无需任何操作就可以直接调用Session类的相关方法

'session' => [
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
],

应用下面的不同模块需要不同的session参数,那么可以在模块配置文件中重新设置
'session' => [
  'prefix' => 'module',
  'type' => '',
  'auto_start' => true,
],
或调用init方法进行初始化：
Session::init([
  'prefix' => 'module',
  'type' => '',
  'auto_start' => true,
]);

【 session操作 】
Session::set('name','thinkphp');          // 赋值(当前作用域)
Session::set('name','thinkphp','think');  // 赋值think作用域

Session::has('name');             // 判断(当前作用域)是否赋值
Session::has('name','think');     // 判断think作用域下面是否赋值

Session::get('name');             // 取值(当前作用域),如果name的值不存在返回null
Session::get('name','think');     // 取值think作用域

Session::delete('name');          // 删除(当前作用域)
Session::delete('name','think');  // 删除think作用域下面的值

Session::prefix('think');         // 指定当前作用域

Session::pull('name');            // 取值并删除

Session::clear();                 // 清除session(当前作用域)
Session::clear('think');          // 清除think作用域

Session::flash('name','value');   // 闪存数据,设置session并在下一次请求之前有效

Session::flush();                 // 提前清除当前请求有效的数据,清除当前请求有效的session

支持session的二维数组操作
Session::set('name.item','thinkphp');
Session::has('name.item');
Session::get('name.item');
Session::delete('name.item');

助手函数session完成相同的功能
session([ // 初始化session
  'prefix' => 'module',
  'type' => '',
  'auto_start' => true,
]);

session('name', 'thinkphp');            // 赋值(当前作用域)
session('name', 'thinkphp', 'think');   // 赋值think作用域
session('?name');                       // 判断(当前作用域)是否赋值
session('name');                        // 取值(当前作用域)
session('name', '', 'think');           // 取值think作用域
session('name', null);                  // 删除(当前作用域)
session(null);                          // 清除session(当前作用域)
session(null, 'think');                 // 清除think作用域

【 Session驱动 】
支持指定Session驱动,配置文件如下：

</pre><pre class="php">
'session' => [
  'prefix'     => 'module',
  'type'       => 'redis',      // 使用redis作为session类型
  'auto_start' => true,
  'host'       => '127.0.0.1',  // redis主机
  'port'       => 6379,         // redis端口
  'password'   => '',           // 密码
]

</pre>

<h3>cookie</h3><pre>
TP采用think\Cookie类提供Cookie支持

初始化
Cookie::init(['prefix'=>'think_','expire'=>3600,'path'=>'/']);  // cookie初始化
Cookie::prefix('think_');  // 指定当前前缀

支持的参数及默认值：
'prefix'    => '',     // cookie名称前缀
'expire'    => 0,      // cookie保存时间
'path'      => '/',    // cookie保存路径
'domain'    => '',     // cookie有效域名
'secure'    => false,  // cookie启用安全传输
'httponly'  => '',     // httponly设置
'setcookie' => true,   // 是否使用 setcookie

Cookie::set('name','value',3600); // 设置Cookie 有效期为 3600秒
Cookie::set('name','value',['prefix'=>'think_','expire'=>3600]);  // 设置cookie 前缀为think_
Cookie::set('name',[1,2,3]);     // 支持数组

Cookie::has('name');             // 判断
Cookie::has('name','think_');    // 判断指定前缀的cookie值是否存在

Cookie::get('name');             // 获取
Cookie::get('name','think_');    // 获取指定前缀的cookie值

Cookie::delete('name');           // 删除cookie
Cookie::delete('name','think_');  // 删除指定前缀的cookie

Cookie::clear('think_');          // 清空指定前缀的cookie

【 cookie助手函数用于基本的cookie操作 】
cookie(['prefix' => 'think_', 'expire' => 3600]); // 初始化
cookie('name', 'value', 3600); // 设置
echo cookie('name'); // 获取
cookie('name', null); // 删除
cookie(null, 'think_'); // 清除

</pre>
</div>

<div id="upload">
<h3>上传文件</h3><pre>
TP5.0内置了一个文件处理类\think\File,内置的文件上传操作也是调用了该类进行处理的。
File类继承了PHP的SplFileObject类,因此可以调用splFileObject类所有的属性和方法
如果上传文件验证不通过则move方法返回false

</pre><pre class="php">
<form action="/index/index/upload" enctype="multipart/form-data" method="post">
<input type="file" name="image" /> <br>
<input type="submit" value="上传" />
</form>

public function upload(){
	$file = request()->file('image');    // 获取表单上传文件,例如上传了001.jpg
	 // 移动到框架应用根目录/public/uploads/目录下
	$info = $file->validate(['size'=>15678,'ext'=>'jpg,png,gif'])->move(ROOT_PATH.'public'.DS.'uploads');
	if($info){
		echo $info->getExtension();  // jpg
		echo $info->getSaveName();   // 20160820/42a79759f284b767dfcb2a0197904287.jpg
		echo $info->getFilename();   // 42a79759f284b767dfcb2a0197904287.jpg
	}else{
		echo $file->getError();
	}
}

</pre>【 多文件上传 】<pre class="html">
<form action="/index/index/upload" enctype="multipart/form-data" method="post">
  <input type="file" name="image[]" /> <br>
  <input type="file" name="image[]" /> <br>
  <input type="file" name="image[]" /> <br>
  <input type="submit" value="上传" />
</form>

public function upload(){
	$files = request()->file('image');   // 获取表单上传文件
	foreach($files as $file){
    // 移动到框架应用根目录/public/uploads/ 目录下
		$info = $file->validate(['size'=>15678,'ext'=>'jpg,png,gif'])->move(ROOT_PATH.'public'.DS.'uploads');
		if($info){
			echo $info->getExtension();    // 输出 jpg
			echo $info->getFilename();     // 输出 42a79759f284b767dfcb2a0197904287.jpg
		}else{
			echo $file->getError();
		}
	}
}
</pre><pre>
验证参数
size  上传文件的最大字节
ext   文件后缀,多个用逗号分割或数组
type  文件MIME类型,多个用逗号分割或数组
还有一个额外的自动验证规则是,如果上传的文件后缀是图像文件后缀则会检查该文件是否是一个合法的图像文件

【 使用rule方法指定上传文件的命名规则 】
默认在上传目录下面生成以当前日期为子目录,以微秒时间的md5编码为文件名的文件

move($path, $savename = true, $replace = true)
$path      保存路径
$savename  保存的文件名,默认自动生成,设置为空字符串表示保留原文件名
$replace   同名文件是否覆盖,默认会覆盖服务器上传目录下的同名文件
move方法成功的话返回一个\think\File对象

$info = $file->rule('md5')->move(ROOT_PATH . 'public' . DS . 'uploads');  //使用md5规则

系统默认上传密码规则：
date 根据日期和微秒数生成
md5  对文件使用md5_file散列生成
sha1 对文件使用sha1_file散列生成
其中md5和sha1规则会自动以散列值的前两个字符作为子目录,后面的散列值作为文件名

如需自定义命名规则可以在rule方法中传入函数或方法
$file->rule('uniqid')->move('/home/www/upload/');   // 移动到服务器的上传目录,并且使用uniqid规则

获取文件hash散列值
$file = request()->file('image');
$upload = $file->move('/home/www/upload/', '');
echo $upload->hash('sha1');
echo $upload->hash('md5');

</pre>
</div>

<div id="validate">
<h2>验证器</h2><pre>
TP5.0验证的两种方法：
1.\think\Validate类独立验证
$validate = new Validate(array $rules = [], $message = [], $field = []);

</pre><pre class="php">
$rules = [                                       // 验证规则
  'name'=>'require|max:25',                      // 一个字段可以设置多个验证规则,使用|分割
  'age' => [require,'number','between'=>'1,120'] // 采用数组方式定义多个规则
  'email|邮箱'=>'email',                         // 给age字段设置中文名
];
$message = [                    //没有定义任何的验证提示信息,系统会显示默认的错误信息
	'name.require' => '名称必须',
	'name.max' => '名称最多不能超过25个字符',
  'age.require' => '年龄必须',
  'age.number' => '年龄必须是数字',
  'age.between' => '年龄必须是1-120',
	'email' => '邮箱格式错误',
];
$field = [                      //传入field参数批量设置字段的描述信息
  'name' => '名称',
  'age' => '年龄',
];

$validate = new Validate($rules,$message,$field);
$data = [ 'name' => 'thinkphp','age' => 25,'email' => 'thinkphp@qq.com' ];
if (!$validate->check($data)) {
	dump($validate->getError());
}

</pre><pre>
2.验证器
为具体的验证场景或数据表定义好验证器类,直接调用验证类的check方法验证

</pre><pre class="php">
//定义验证器
namespace app\index\validate;
use think\Validate;
class User extends Validate	{
	protected $rule = [ 'name' => 'require|max:25',	'email' => 'email',	];
	protected $message = [
		'name.require' => '名称必须',
		'name.max' => '名称最多不能超过25个字符',
		'email' => '邮箱格式错误',
	];
}

//使用验证器
$data = [ 'name'=>'thinkphp', 'email'=>'thinkphp@qq.com' ];
$validate = Loader::validate('User');  //助手函数$validate = validate('User');实例化验证器User类
if(!$validate->check($data)){
	dump($validate->getError());
}

</pre>3.继承了\think\Controller的控制器中调用控制器类提供的validate方法验证<pre class="php">
validate($data, $validate, $message = [], $batch = false, $callback = null)

$result = $this->validate(
	['name' => 'thinkphp','email' => 'thinkphp@qq.com',],  // 验证的数据
	['name' => 'require|max:25','email' => 'email',]       // 验证的规则
);
if(true !== $result){       // 验证失败 输出错误信息
	dump($result);
}

</pre>4.控制器validate方法中使用验证器<pre class="php">
$result = $this->validate($data,'User');
if(true !== $result){         // 验证失败输出错误信息
	dump($result);
}

$result = $this->validate($data,'User.edit'); //控制器validate方法中使用场景edit验证

</pre>在validate方法中还支持做一些前置的操作回调<pre class="php">
$result = $this->validate($data,'User.edit',[],[$this,'some']);
if(true !== $result){         // 验证失败 输出错误信息
    dump($result);
}

</pre><pre>
5.调用静态使用内置的规则验证单个数据,返回布尔值,错误信息需要自己处理
Validate::dateFormat('2016-03-09','Y-m-d');   // 日期格式验证
Validate::is('2016-06-03','date'); 		        // 验证是否有效的日期
Validate::is('thinkphp@qq.com','email');      // 验证是否有效邮箱地址
Validate::in('a',['a','b','c']);              // 验证是否在某个范围
Validate::gt(10,8);                           // 验证是否大于某个值
Validate::regex(100,'\d+');                   // 正则验证

批量验证：
批量验证如果验证不通过,返回的是一个错误信息的数组。
$validate = new Validate($rule, $msg);
$result = $validate->batch()->check($data);

</pre>

<h3>验证规则</h3><pre>
设置验证规则的两种方法：
1.实例化Validate类的时候传入
$rules = ['name' => 'require|max:25','age' => 'number|between:1,120',];
$rules = ['name' => ['require','max'=>25],'age' => ['number','between'=>'1,120'],];
$validate = new Validate($rules);

2.rule方法动态添加验证规则
$validate->rule('zip', '/^\d{6}$/');
$validate->rule([ 'email' => 'email', ]);

3.对某个字段使用闭包函数验证
$validate = new \think\Validate([
	'name' => function($value,$data) {  // 第一个参数是当前字段的值,第二个参数是全部数据
		return 'thinkphp'==$value;
	},
]);

4.自定义验证规则
验证方法的5个参数(验证数据,验证规则,全部数据/数组,字段名,字段描述),后3个可选

namespace app\index\validate;
class User extends \think\Validate{
	protected $rule = [	'name' => 'checkName:thinkphp',	'email' => 'checkMail:thinkphp.cn',	];
	protected $message = [ 'name' => '用户名必须',	'email' => '邮箱只能是thinkphp.cn域名',	];
	protected function checkName($value,$rule,$data){   // 自定义验证规则checkName,$value是$name的值
		return $rule == $value ? true : '名称错误';
	}
  // 验证邮箱格式是否符合指定的域名
  protected function checkMail($value, $rule){
    return 1 === preg_match('/^\w+([-+.]\w+)*@' . $rule . '$/', $value);
  }
}

$validate = Loader::validate('User');
if(!$validate->check($data)){
    dump($validate->getError());
}

自定义验证规则也支持返回动态的错误信息,只需要在验证方法里面返回错误信息字符串即可
namespace app\index\validate;
class User extends \think\Validate{
  // 验证规则
  protected $rule = [
    ['nickname', 'require|min:5', '昵称必须|昵称不能短于5个字符'],
    ['email', 'checkMail:thinkphp.cn', '邮箱格式错误'],
    ['birthday', 'dateFormat:Y-m-d', '生日格式错误'],
  ];
  // 验证邮箱格式是否符合指定的域名
  protected function checkMail($value, $rule){
    $result = preg_match('/^\w+([-+.]\w+)*@' . $rule . '$/', $value);
    if (!$result) {
      return '邮箱只能是' . $rule . '域名';
    } else {
      return true;
    }
  }
}

如果输入了一个不是 thinkphp.cn 域名的邮箱地址,会提示错误信息：邮箱只能是thinkphp.cn域名

5. 如果没有使用验证器类则支持使用extend方法扩展验证规则
$validate = new Validate(['name' => 'checkName:1']);
$validate->extend('checkName', function ($value, $rule) {
	return $rule == $value ? true : '名称错误';
});
$data = ['name' => 1];
$result = $validate->check($data);

支持批量注册验证规则
$validate = new Validate(['name' => 'checkName:1']);
$validate->extend([
    'checkName'=> function ($value, $rule) {
        return $rule == $value ? true : '名称错误';
    },
    'checkStatus'=> [$this,'checkStatus']
]);
$data   = ['name' => 1];
$result = $validate->check($data);

6.验证规则和提示信息可以分开定义,也可以一起定义
$rule = [
	['name','require|max:25','名称必须|名称最多不能超过25个字符'],
	['age','number|between:1,120','年龄必须是数字|年龄必须在1~120之间'],
	['email','email','邮箱格式错误']
];

</pre>

<h3>场景验证</h3><pre>
不同的场景,如数据库新增记录和更新时不同的场景,验证的方式和需要验证的字段可能会不同

1.可以在定义验证规则的时候定义场景,并且验证不同场景的数据
//独立验证实例
$rule = ['name' => 'require|max:25','age' => 'number|between:1,120','email' => 'email',];
$msg = [
  'name.require' => '名称必须',
  'name.max' => '名称最多不能超过25个字符',
  'age.number' => '年龄必须是数字',
  'age.between' => '年龄只能在1-120之间',
  'email' => '邮箱格式错误',
];
$data = ['name' => 'thinkphp','age' => 10,'email' => 'thinkphp@qq.com',];
$validate = new Validate($rule);
$validate->scene('edit', ['name', 'age']);			//验证edit场景,该场景定义只需要验证name和age字段
$result = $validate->scene('edit')->check($data);

//定义验证器
namespace app\index\validate;
use think\Validate;
class User extends Validate	{
	protected $rule = [ 'name' => 'require|max:25',	'email' => 'email',	];
	protected $message = [
		'name.require' => '名称必须',
		'name.max' => '名称最多不能超过25个字符',
		'email' => '邮箱格式错误',
	];
	protected $scene = [
		'edit' => ['name','age'],
	];
}
//使用验证器
$data = [ 'name'=>'thinkphp', 'email'=>'thinkphp@qq.com' ];
$validate = Loader::validate('User');  //助手函数$validate = validate('User');实例化验证器类User
if(!$validate->scene('edit')->check($data)){
	dump($validate->getError());
}

2.可以在定义场景的时候对某些字段的规则重新设置
protected $scene = [
	'edit' => ['name','age'=>'require|number|between:1,120'],
];

3.可以对场景设置一个回调方法,用于动态设置要验证的字段
$validate = new Validate($rule);
$validate->scene('edit', function($key,$data){
	return 'email'==$key && isset($data['id'])? true : false;
});
$result = $validate->scene('edit')->check($data);

</pre>

<h3>模型验证</h3><pre>
在模型中的验证方式

$User = new User;
$result = $User->validate(
	['name' => 'require|max:25','email' => 'email',],
	['name.require' => '名称必须','name.max' => '名称最多不能超过25个字符','email' => '邮箱格式错误',]
)->save($data);
if(false === $result){   // 验证失败 输出错误信息
	dump($User->getError());
}

如果使用下面的验证器类的话：
namespace app\index\validate;
use think\Validate;
class User extends Validate{
  protected $rule = ['name'  =>  'require|max:25', 'email' =>  'email'];
  protected $message = ['name.require'  =>  '用户名必须', 'email' =>  '邮箱格式错误',];
  protected $scene = [
    'add'   =>  ['name','email'],
    'edit'  =>  ['email'],
  ];
}

$User = new User;
$result = $User->validate(true)->save($data);      // 调用当前模型对应的User验证器类进行数据验证
if(false === $result){
  dump($User->getError());                       // 验证失败 输出错误信息
}

需要调用的验证器类和当前的模型名称不一致
$User = new User;
$result = $User->validate('Member')->save($data);   // 调用Member验证器类进行数据验证
if(false === $result){
  dump($User->getError());                        // 验证失败 输出错误信息
}

同样支持场景验证
$User = new User;
$result = $User->validate('Member.edit')->save($data); // 调用Member验证器类进行数据验证
if(false === $result){
  dump($User->getError());                         // 验证失败 输出错误信息
}

</pre>

<h3>系统内置验证规则</h3><pre>
max:汉字和英文,先用截取字符串

【 格式验证类 】
'name'=>'require'	    // 验证某个字段必须
'num'=>'number'       // 采用filter_var验证
'num'=>'float'        // 采用filter_var验证
'num'=>'boolean'      // 采用filter_var验证
'email'=>'email'      // 采用filter_var验证
'info'=>'array'       // 是否为数组
'accept'=>'accepted'  // 验证某个字段是否为yes,on或是1,确认"服务条款"是否同意时很有用
'date'=>'date'        // 有效日期
'name'=>'alpha'		    // 是否为字母
'name'=>'alphaNum'    // 字母 数字
'name'=>'alphaDash'   // 字母 数字 下划线 破折号
'name'=>'chs'		      // 汉字
'name'=>'chsAlpha'    // 汉字 字母
'name'=>'chsAlphaNum' // 汉字 字母 数字
'name'=>'chsDash'	    // 汉字、字母、数字和下划线_及破折号
'host'=>'activeUrl'   // 有效的域名或IP
'url'=>'url'          // 有效的url地址
'ip'=>'ip' 			      // 有效的ip地址,支持验证ipv4和ipv6格式的IP地址,采用filter_var验证
'create_time'=>'dateFormat:y-m-d'      // 指定格式的日期

【 长度和区间范围验证类 】
'num'=>'in:1,2,3'     		// 某个字段的值在范围内
'num'=>'notIn:1,2,3' 		  // 不在某个范围
'num'=>'between:1,10' 		// 区间
'num'=>'notBetween:1,10'	// 不在区间

'name'=>'length:4,25'     // 字段的值的长度在某个范围
'name'=>'length:4' 			  // 字段的值指定长度,数组数据则判断数组的长度,File对象数据则判断文件的大小
'name'=>'max:25'          // 字段的值的最大长度,数组数据则判断数组的长度,File对象数据则判断文件的大小
'name'=>'min:5'           // 字段的值的最小长度,数组数据则判断数组的长度,File对象数据则判断文件的大小

'begin_time' => 'after:2016-3-18',        // 验证某个字段的值是否在某个日期之后
'end_time' => 'before:2016-10-01',	      // 验证某个字段的值是否在某个日期之前
'expire_time' => 'expire:2016-2-1,2016-10-01', // 验证当前操作(注意不是某个值)是否在某个有效日期之内,开始和结束时间
'name' => 'allowIp:114.45.4.55',          // 验证当前请求的IP是否在某个范围,可以用于某个后台的访问权限
'name' => 'denyIp:114.45.4.55',		        // 验证当前请求的IP是否禁止访问

【 字段比较类 】
'repassword'=>'require|confirm:password'  // 验证某个字段是否和另外一个字段的值一致
'password'=>'require|confirm'			        // password和password_confirm是自动相互验证的
'name'=>'require|different:account'		    // 验证某个字段是否和另外一个字段的值不一致

'score' => 'egt:60'						  //验证是否大于等于某个值
'num'   => '>=:100'
'score' => 'gt:60'						  //验证是否大于某个值
'num'   => '>:100'
'score' => 'elt:100'					  //验证是否小于等于某个值
'num'   => '<=:100'
'score' => 'lt:100'						  //验证是否小于某个值
'num'   => '<:100'
'score' => 'eq:100'						  //验证是否等于某个值
'num'   => '=:100'
'num'   => 'same:100'

验证对比其他字段大小,数值大小对比
'price'=>'lt:market_price'            // 价格
'price'=>'<:market_price'

【 filter验证 】
'ip'=>'filter:validate_ip'    			  //支持使用filter_var进行验证

【 正则验证 】
'zip'     =>'\d{6}',
'zip'     =>'regex:\d{6}',
'accepted'=>['regex'=>'/^(yes|on|1)$/i'],  // 正则表达式中包含有|符号的话,必须使用数组方式定义

也可以实现预定义正则表达式后直接调用,例如在验证器类中定义regex属性
protected $regex = [ 'zip' => '\d{6}'];
然后就可以使用
'zip' =>  'regex:zip',

【 上传验证 】
file 	                        // 验证是否是一个上传文件
image:width,height,type   		// 验证是否是一个图像文件,width height和type都是可选,width和height必须同时定义
fileExt:允许的文件后缀 			    // 验证上传文件后缀
fileMime:允许的文件类型        // 验证上传文件类型
fileSize:允许的文件字节大小    // 验证上传文件大小

【 行为验证 】
'data'=>'behavior:\app\index\behavior\Check'  // 使用行为验证数据

【 其它验证 】
unique:table,field,except,pk
验证当前请求的字段值是否为唯一的
'name' => 'unique:user',                     // 表示验证name字段的值是否在user表(不包含前缀)中唯一
'name' => 'unique:user,account',			       // 验证其他字段
'name' => 'unique:user,account,10',	         // 排除某个主键值
'name' => 'unique:user,account,10,user_id',  // 指定某个主键值排除
'name' => 'unique:user,status^account',      // 多个字段验证唯一验证条件
'name' => 'unique:user,status=1&account='.$data['account'],   // 复杂验证条件

'password'=>'requireIf:account,1'            // 当account的值等于1的时候password必须

'password'=>'requireWith:account'		         // 当account有值的时候password字段必须

</pre>

<h3>表单令牌-防止表单重复提交：验证规则支持对表单的令牌验证</h3><pre>
1.首先需要在表单里面增加隐藏域
input type="hidden" name="__token__" value="{$Request.token}"
或{:token()}

2.验证规则中添加token验证规则
protected $rule = [
	'name' => 'require|max:25|token',
	'email' => 'email',
];

如果令牌名称不是__token__,则表单需要改为：
input type="hidden" name="__hash__" value="{$Request.token.__hash__}"
或：
{:token('__hash__')}

验证器中需要改为：
protected $rule = [
    'name'  =>  'require|max:25|token:__hash__',
    'email' =>  'email',
];

需要自定义令牌生成规则时可以调用Request类的token方法
namespace app\index\controller;
use think\Controller;
class Index extends Controller{
  public function index(){
    $token = $this->request->token('__token__', 'sha1');
    $this->assign('token', $token);
    return $this->fetch();
  }
}

然后在模板表单中使用：
input type="hidden" name="__token__" value="{$token}"

或不需要在控制器写任何代码,直接在模板中使用：
{:token('__token__', 'sha1')}

实例
protected $rule = [
  'name'  =>  'require|max:25|token',
  'password' => 'require'
  'email' =>  'email',
];

场景
1.登录：提交参数name和passowrd,还有token
2.如果现在通过email改密码的场景：提交email、password、token就有问题了,没有token验证

把$rule改一下
protected $rule = [
  'name'  =>  'require|max:25|token',
  'password' => 'require'
  'email' =>  'email|token',
];
场景2是满足了,但如果在一个更新name和email的场景下就会出现一个致命错误：令牌数据无效！

看源码后知道name后的token已经验证后清空了,但email又要验证token导致错误

解决灵活的参数提交
protected $rule = [
  'username' => 'require|email',
  'password' => 'require',
  '__token__' => 'token',
];
/*token不是默认名字时*/
protected $rule = [
  'username' => 'require|email',
  'password' => 'require',
  '__hash__' => 'token:__hash__',
];

现在只要在需要令牌验证时提交token就ok了,所有参数都可灵活组合,只要提交了token就会进行验证,

同时在配置$scene场景时
protected $scene = [
  'login' => ['username', 'password', '__token__'],
  'edit' => ['username', 'email', '__token__'],
  'passwd' => ['password', 'email'],
];
只要在需要验证的场景中增加token项就可以了

【 表单请求和验证 】

</pre><pre class="php">
namespace app\index\controller;
use think\Controller;
use think\Request;
class Index extends Controller{
  public function index(Request $request){
    $rules = ['name' => 'require|max:25', 'email' => 'email',];  // 定义表单验证规则
    $result = $this->validate($request->param(), $rules);        // 验证表单数据
    return $result ? '数据验证通过！' : '数据验证失败：' . $result;
  }
}

</pre>
</div>

<div id="behavior">
<h2>行为和钩子</h2><pre>
TP中的行为是比较抽象的概念,可想象成在应用执行过程中的一个动作。
在框架的执行流程中,路由检测是一个行为,静态缓存是一个行为,用户权限检测也是行为,大到业务逻辑,小到浏览器检测、多语言检
测等都可以当做是一个行为,甚至说给网站用户的第一次访问弹出Hello world这些都可以看成是一种行为,
把这些行为抽离出来的目的是为了不改动框架和应用,而在外围通过扩展或配置来改变或增加一些功能。

不同的行为之间具有位置共同性,比如有些行为的作用位置都是在应用执行前,有些行为都是在模板输出之后,这些行为发生作用的位置称为钩子,当应用程序运行到这个钩子的时候就会被拦截下来,统一执行相关的钩子函数或叫钩子的回调函数即行为,钩子一般可以理解插件

如用鼠标在某个窗口上双击了一次,或给某个窗口输入了一个字母A
首先发现这些事件的不是窗口,而是系统,然后系统通知窗口发生的这些事件,这时窗口的对有些事件会忽略、对有些事件会做出反应:
譬如可能对鼠标单击事件忽略,窗口想: 你单击我不要紧,累死你我不负责;但一旦谁要双击我,我会马上给你点颜色瞧瞧!
这里窗口准备要采取的行动就是提前写好的事件
用Windows的话说,窗口的事件就是系统发送给窗口的消息,窗口要采取的行动(事件代码)就是窗口的回调函数
但隔墙有耳,系统要通知给窗口的消息可能会被另一个家伙贼提前监听到,专门在这等情报的,贼知道后在窗口知道以前就采取了行动!
并且这个贼对不同的消息会采取早就准备好的不同的行动方案,对不感兴趣的消息也就无须制定相应的行动方案
这个贼就是要设置的钩子,贼的行动方案就是钩子函数或叫钩子的回调函数

一个钩子可以注册多个行为,执行到某个钩子位置后会按照注册的顺序依次执行相关的行为。但在某些特殊的情况下可以设置某个钩子只能执行一次行为,或在一个钩子的某个行为中返回false来强制终止后续的行为执行;一个行为可以同时注册到多个不同的钩子上,完全看应用的需求来设计

行为Behavior是TP扩展机制中比较关键的一项扩展,行为既可以独立调用,也可以绑定到某个标签中进行侦听,在官方提出的CBD模式中行为也占了主要的地位,可见行为在TP框架中意义非凡

行为可以做很多的事情,比如检查访问请求、权限检查、请求对象的属性和方法注入、甚至可以进行路由拦截等

在项目代码中以后可能要扩展的地方放置一个钩子函数,等需要扩展的时候把需要实现的类和函数挂载到这个钩子上就可以实现扩展
在二次开发别人写的代码时,如果有钩子机制,作者会告诉哪些地方给下了钩子,扩展时就可在不改动原代码的情况下进行一个升级扩展

系统核心设计提供了一些可能会需要的钩子,只要配置实现相应的函数就可以用,尽可能的方便应用的扩展而不必改动框架核心,按照执行顺序依次如下：
1、app_init
应用初始化标签位,在think\App.php的initCommon函数中Hook::listen('app_init');没有接收参数。

2、app_begin
应用开始标签位,在think\App.php的run函数中,在加载路由和请求信息后执行。会接收一个参数,存储的是本次请求的调度信息。

3、module_init
模块初始化标签位,在think\App.php的module函数中,在加载请求控制器之前执行,接收一个参数,存储当前请求对象实例$request

4、action_init
控制器开始标签位,在think\App.php的module函数中,在加载完控制器后,使用反射请求控制器之前执行。接收一个参数,是一个数组
,第一个元素是请求控制器实例对象,第二个函数时要执行的控制器函数名。

5、view_fileter
视图输出过滤标签位,在think\View.php的fetch函数中,接收一个参数,视图字符串。

6、app_end
应用结束标签为,在think\App.php中run函数中,Hook::listen('app_end');

7、log_write
日志write方法标签位,在调用Log::wirte记录日志之前执行。接收一个参数,要写入的日志信息。

8、response_end
响应结束标签为。在think\Response.php的send函数中,在响应客户端请求之后执行。

【 行为定义 】
行为定义通常是以一个类的方法或闭包的方式存在

钩子函数既可以单独绑定一个类,也可以绑定类中的一个方法,或直接绑定一个匿名函数
当绑定到一个类时,如果类中有run函数就直接执行run函数,如果没有run函数而有一个与钩子名一样的函数则会执行该函数。
钩子函数是驼峰式命名,并且钩子函数名的优先级大于run函数的优先级,钩子函数名和run函数同时存在的话则只会执行钩子函数名

</pre><pre class="php">
namespace app\common\behavior;
class Hello{
    public function run(){
        echo 'hello,world!';
    }
}

namespace app\common\behavior;
class Test{
  public function appInit(){         // 方法名的定义规范采用驼峰法
      echo 'app_init test';
  }
  public function appBegin(){
      echo 'app_begin test';
  }
}

</pre><pre>
闭包
一般闭包都是在绑定行为的时候直接定义,无需事先定义
可以在应用的公共文件中定义一个专门用于module_init钩子的闭包行为：
$hello = function($request, $module){
  echo 'hello,'.$module.'!';
};

</pre>

<h3>绑定行为</h3><pre>
要给钩子绑定行为有两种方式：配置绑定和动态绑定。

【 配置文件绑定行为 】
配置绑定是在应用目录或模块目录下面的tags.php文件中配置,app_init和app_begin钩子只能在应用目录下面的tags.php文件中配置,模块目录下面配置无效,而其它的钩子支持应用和模块配置,如果同时定义的话会合并后依次执行行为。
配置绑定的行为执行顺序就是配置的定义顺序

</pre><pre class="php">
return [
  'app_init'     =>   ['\app\common\behavior\Hello','\app\common\behavior\Test',],
  'app_begin'    =>   ['\app\common\behavior\Test',],
  'module_init'  =>   [function($request){
      echo 'hello,'.$request->module().'!';
  },],
];

控制器类如下：
namespace app\index\controller;
class Index{
    public function index(){
        return 'run index';
    }
}

访问http://www.example.com/后,页面输出结果为：hello,world! app_init test app_begin test hello,index! run index

修改下配置文件里面的定义顺序如下：
return [
  'app_init'     =>   ['\app\common\behavior\Test','\app\common\behavior\Hello',],
  'app_begin'    =>   ['\app\common\behavior\Test',],
  'module_init'  =>   [function($request){
      echo 'hello,'.$request->module().'!';
  },],
];

最终输出的结果变成：app_init test hello,world! app_begin test hello,index! run index

# 钩子方法传入第三个参数表示在获取到返回值后就会不再执行后续行为;
namespace app\common\behavior;
class Test{
    public function appInit(){
        echo 'app_init test';
        return false;             // app_init钩子的Test行为执行后不再继续执行后续的行为
    }
    public function appBegin(){
        echo 'app_begin test';
        return false;
    }
}

再次访问的时候输出结果就变成：app_init test app_begin test hello,index! run index

# 在模块的tags.php文件中添加行为绑定,同一钩子上的应用绑定行为和模块绑定行为同时生效
return [
    'module_init'   => [function($request){
        echo 'welcome,'.$request->module().'!';
    },],
];

再次访问后页面输出结果为：app_init test app_begin test hello,index! welcome,index! run index

# 当前模块的行为覆盖应用绑定的行为
return [
  'module_init'    =>  [function($request){
      echo 'welcome,'.$request->module().'!';
  },
  '_overlay'    =>  true,],
];

再次访问后,查看页面输出结果变成：app_init testapp_begin testwelcome,index! run index

</pre>tp5支持指定方法,包括静态方法执行行为<pre class="php">
# 给Test行为增加一个额外的方法并且也绑定到module_init钩子
namespace app\common\behavior;
class Test{
    public function appInit(){
        echo 'app_init test';
        return false;
    }
    public function appBegin(){
        echo 'app_begin test';
        return false;
    }
    public function sayHello($request){
        echo 'say hello ' . $request->module() . '!';
    }
}

module_init对应的方法名应该是moduleInit,sayHello方法和钩子名称不一致,所以在绑定行为的时候需要改为：
return [
    'module_init'    =>  [function($request){
        echo 'welcome,'.$request->module().'!';
    },
    ['\app\common\behavior\Test','sayHello'],],
    ['\app\common\behavior\Test::sayHello']      // 绑定静态方法sayHello
];

再次访问页面输出：
app_init test app_begin test hello,index! welcome,index!say hello index! run index

</pre><pre>
【 动态绑定行为 】
动态绑定是指使用Hook::add方法动态给钩子添加一个行为方法
Hook::add('钩子名称','行为定义','该行为是否优先执行');

如果行为需要在应用里面被绑定,就在应用的公共文件common.php中使用动态绑定代码
如果是模块的绑定行为,那么也可以在模块的公共文件common.php文件中使用动态绑定

// application/common.php
use think\Hook;
Hook::add('app_init', ['\app\common\behavior\Test','\app\common\behavior\Hello', ]);
Hook::add('app_begin', ['\app\common\behavior\Test', ]);
Hook::add('module_init', [function($request){
    echo 'hello,'.$request->module().'!';
  },]
);

</pre>

<h3>自定义钩子</h3><pre>
钩子的位置是事先设计好的,无论是框架还是应用的,要设置一个钩子只需要在相关的位置添加一行代码
\think\Hook::listen('钩子名称','参数(引用)','额外参数','是否一次有效返回值');
除了钩子名称之外其它参数都是可选的,第二个参数是引用传值,所以必须传入变量。

</pre><pre class="php">
// 在公共的控制器基类中添加一个controller_init钩子
namespace app\common\controller;
use think\Request;
class Base extends \think\Controller{
  protected $role;
  public function __construct(Request $request){
    $result = \think\Hook::listen('controller_init', $this, $request, true);   // 添加钩子
    if ($result){
      $this->role = $result;   // 当前角色名
    }
    parent::__construct($request);
  }
}

所有的控制器都继承app\common\controller\Base即可实现,所有的正常访问请求都会经过controller_init钩子位置,然后只需要给controller_init钩子绑定行为。

// 行为类Check定义
namespace app\common\behavior;
class Check{
  public function run($controller, $request){
    if ($request->role){
      return $request->role->name;
    }
  }
}

// 在apps/tags.php中添加配置绑定行为Check
return [
  'controller_init'   =>  ['\app\common\behavior\Check',],
];

// 定义Role类
namespace app\common;
class Role{
  public $name;
  protected $type = [1 => 'admin', 2 => 'leader', 3 => 'operator'];

  public function __construct($id){
    $this->name = $this->type[$id] ?? 'guest';
  }
}

// 在模块的common.php文件中绑定另外一个闭包行为
use think\Hook;
use app\common\Role;
Hook::add('controller_init', function($controller,$request){
    $request->bind('role',new Role($request->param('id')));  // 绑定请求对象的属性
  }, true
);

namespace app\index\controller;
use app\common\controller\Base;
class Index extends Base{
  public function index(){
    return '当前用户角色：' . $this->role;
  }
}

行为测试
访问URL http://contoso.org 页面输出显示：
当前用户角色：guest

访问URL http://contoso.org?id=1 页面输出显示：
当前用户角色：admin

访问URL http://contoso.org?id=2 页面输出显示：
当前用户角色：leader

</pre>
</div>

<div id="captcha">
<h2>验证码: 要开启URL路由</h2><pre>
首先使用Composer安装think-captcha扩展包：
composer require topthink/think-captcha

【 验证码的简单用法 】
扩展包内定义了一些常见用法方便使用

</pre>模版内验证码的显示<pre class="html">
< div>{:captcha_img()}< /div>
或
< div>< img src="{:captcha_src()}" alt="captcha" />< /div>

</pre><pre>
使用TP5的内置验证功能,添加captcha验证规则即可
$this->validate($data,[
  'captcha|验证码'=>'require|captcha'
]);

手动验证
if(!captcha_check($captcha)){
 //验证失败
};

【 验证码的自定义用法 】
如果项目未开启路由,或有实际需求可自行调用Captcha类操作

验证码的生成：
$captcha = new Captcha();
return $captcha->entry();

如果需要在一个页面中生成多个验证码的话,entry方法需要传入可标识的信息
$captcha = new Captcha();
return $captcha->entry(1);

验证码的验证：
可以用Captcha类的check方法检测验证码的输入是否正确

</pre>封装的一个验证码检测的函数<pre class="php">
// 检测输入的验证码是否正确,$code为用户输入的验证码字符串,$id多个验证码标识
function check_verify($code, $id = ''){
  $captcha = new Captcha();
  return $captcha->check($code, $id);
}

</pre><pre>
【 验证码的配置参数 】
如果使用了扩展内置的方法,务必在应用配置文件中配置,5.0.1及以上支持者在应用配置目录下面extra子目录内配置captcha.php文件

Captcha类带有默认的配置参数,支持自定义配置
参数      描述                           默认
codeSet   验证码字符集合                  略
expire    验证码过期时间(s)             1800
useZh     使用中文验证码                  false
zhSet     中文验证码字符串                略
useImgBg  使用背景图片                    false
fontSize  验证码字体大小(px)              25
useCurve  是否画混淆曲线                  true
useNoise  是否添加杂点                    true
imageH    验证码图片高度,设置为0为自动计算 0
imageW    验证码图片宽度,设置为0为自动计算 0
length    验证码位数                      5
fontttf   验证码字体,不设置是随机获取      空
bg        背景颜色                        [243, 251, 254]
reset     验证成功后是否重置               true

参数设置使用两种方式。
1、实例化传入参数：
$config =    [
  'fontSize' => 30,  // 验证码字体大小
  'length' => 3,   // 验证码位数
  'useNoise' => false,  // 关闭验证码杂点
];
$captcha = new Captcha($config);
return $captcha->entry();

2、采用动态设置的方式
$captcha = new Captcha();
$captcha->fontSize = 30;
$captcha->length   = 3;
$captcha->useNoise = false;
return $captcha->entry();

验证码字体
默认验证码的字体是随机使用扩展包内think-captcha/assets/ttfs目录下面的字体文件,可以指定验证码的字体
$captcha = new Captcha();
$captcha->fontttf = '5.ttf';
return $captcha->entry();

背景图片
验证码背景图片设置：
$captcha = new Captcha();
$captcha->useImgBg = true; // 开启验证码背景图片功能,随机使用扩展包内`think-captcha/assets/bgs`目录下面的图片
return $captcha->entry();

中文验证码
$captcha = new Captcha();
$captcha->useZh = true;  // 验证码字体使用扩展包内`think-captcha/assets/zhttfs`字体文件
return $captcha->entry();

指定验证码字符,默认的验证码字符已经剔除了易混淆的1l0o等字符
$captcha = new Captcha();
$captcha->codeSet = '0123456789';  // 设置验证码字符为纯数字
return $captcha->entry();

如果是中文验证码则可以使用zhSet参数设置
$captcha = new Captcha();
$captcha->useZh = true;
$captcha->zhSet = '们以我到他会作时要动国产的一是工就年阶义发成部民可出能方进在了不和有大这'; // 设置验证码字符
return $captcha->entry();

</pre>
</div>

<div id="img">
<h3>图像</h3><pre>
安装扩展
使用Composer安装TP5的图像处理类库：
composer require topthink/think-image

【 图像打开 】
使用open方法打开图像文件进行相关操作
$image = \think\Image::open('./image.png');

从直接获取当前请求中的文件上传对象
$image = \think\Image::open(request()->file('image'));

$width = $image->width();    // 返回图片的宽度
$height = $image->height();  // 返回图片的高度
$type = $image->type();      // 返回图片的类型
$mime = $image->mime();      // 返回图片的mime类型
$size = $image->size();      // 返回图片的尺寸数组 0 图片宽度 1 图片高度

dump($image);输出内容：
object(think\Image)[10]
  protected 'im' => resource(54, gd)
  protected 'gif' => null
  protected 'info' =>
    array (size=4)
      'width' => int 460
      'height' => int 559
      'type' => string 'jpeg' (length=4)
      'mime' => string 'image/jpeg' (length=10)

【 图像保存 】
save方法参数
pathname  	必填项,图像保存路径名称
type      	默认与原图相同,图像类型
quality   	80,图像质量
interlace 	true,是否对JPEG类型图像设置隔行扫描
设置隔行扫描的情况下在网页进行浏览时是从上到下一行一行的显示,否则图片整个显示出来,然后由模糊到清晰显示

【 裁剪图像 】
$image = \think\Image::open('./image.png');
$image->crop(300, 300)->save('./crop.png');        //将图片裁剪为300x300并保存为crop.png
$image->crop(300,300,100,30)->save('./crop.png');  //将图片裁剪为从坐标(100,30)开始300x300并保存为crop.png

【 生成缩略图 】
$image = \think\Image::open('./image.png');
$image->thumb(150, 150)->save('./thumb.png');      // 按照原比例生成一个最大为150*150的缩略图并存为thumb.png

按要求设置包括 \think\Image 的下列常量或对应的数字：
const THUMB_SCALING = 1;    缩略图等比例缩放
const THUMB_FILLED = 2;     缩略图缩放后填充类型
const THUMB_CENTER = 3;     缩略图居中裁剪
const THUMB_NORTHWEST = 4;  缩略图左上角裁剪
const THUMB_SOUTHEAST = 5;  缩略图右下角裁剪
const THUMB_FIXED = 6;      缩略图固定尺寸缩放

$image = \think\Image::open('./image.png');
$image->thumb(150,150,\think\Image::THUMB_CENTER)->save('./thumb.png'); //居中裁剪缩略图

【 图像翻转 】
默认是以x轴进行翻转
$image = \think\Image::open('./image.png');
$image->flip()->save('./filp_image.png');                      // 对图像进行以x轴进行翻转操作
$image->flip(\think\image::FLIP_Y)->save('./filp_image.png');  //Y轴翻转

【 图像旋转 】
默认是顺时针旋转90度
$image = \think\Image::open('./image.png');
$image->rotate()->save('./rotate_image.png');  // 对图像使用默认的顺时针旋转90度操作

【 添加图片文字水印 】
透明度(0~100,默认值是100

$image = \think\Image::open('./image.png');
$image->water('./logo.png')->save('water_image.png'); //图片水印,默认值是WATER_SOUTH
$image->water('./logo.png',\think\Image::WATER_SOUTHWEST,50)->save('water_image.png');  // 透明度50

text($text, $font, $size, $color = '#00000000',$locate = self::WATER_SOUTHEAST, $offset = 0, $angle = 0)
// 给原图左上角添加文字水印,入口文件目录字体,20px,color
$image->text('十年磨一剑','HYQingKongTiJ.ttf',20,'#ffffff')->save('text_image.png');

const WATER_NORTHWEST = 1;
const WATER_NORTH = 2;
const WATER_NORTHEAST = 3;
const WATER_WEST = 4;
const WATER_CENTER = 5;
const WATER_EAST = 6;
const WATER_SOUTHWEST = 7;
const WATER_SOUTH = 8;
const WATER_SOUTHEAST = 9;

文字水印参数
text   不能为空         添加的文字
font   不能为空         字体文件路径
size   不能为空         字号,单位是像素
color  #00000000        文字颜色
locate  WATER_SOUTHEAST 文字写入位置
offset  0               文字相对当前位置的偏移量
angle   0               文字倾斜角度

</pre>
</div>

<div id="phpexcel">
<h2>phpexcel</h2><pre class="php">
//composer require phpoffice/phpexcel
//实例tp509/public/admin/blog/phpexcel

use PHPExcel_IOFactory;
use PHPExcel;

public function phpexcel(){
  $PHPExcel=new PHPExcel();  //实例化phpexcel类
  $PHPSheet=$PHPExcel->getActiveSheet();  //获得当前活动的sheet的操作对象
  $PHPSheet->setTitle('demo');  //给当前活动sheet设置名称

  $PHPSheet->setCellValue('A1','姓名')->setCellValue('B1','分数');
  $PHPSheet->setCellValue('A2','张三')->setCellValue('B2','59');
  $PHPSheet->setCellValue('A3','李四')->setCellValue('B3','66');
  $PHPSheet->setCellValue('A4','王五')->setCellValue('B4','99');

  $PHPWriter=PHPExcel_IOFactory::createWriter($PHPExcel,'Excel2007');  //按照指定格式生成excel文件
  $PHPWriter->save('./static/excel/demo.xlsx');  //生成文件
}
</pre>
</div>

<div id="qrcode">
<h2>调用qrcode生成二维码</h2>
<p><b>前端js生成二维码：jquery.qrcode.min.js <a href="http://localhost/study/items/index.html" target="_blank">demo</a></b></p>

<h3>phpqrcode</h3><pre>
在线二维码api网站：http://www.topscan.com/pingtai/

将phpqrcode整合到TP框架
将phpqrcode代码压缩包内容解压到项目vendor下新建目录phpqrcode
官方文档http://phpqrcode.sourceforge.net/examples/index.php?example=026

composer类文件自动加载：
"require": {
  "endroid/qr-code": "^2.5",
  "phpqrcode/phpqrcode": "dev-master"
},
"autoload": {
  "files": ["vendor/phpqrcode/phpqrcode/phpqrcode.php"]
},
执行cmd> composer update
不再需要显式加载vendor("phpqrcode.phpqrcode");而是直接new \PHPQrcode\Qrcode\QRcode();

png($text, $outfile = false, $level = QR_ECLEVEL_L, $size = 3, $margin = 4, $saveandprint=false, $back_color = 0xFFFFFF, $fore_color = 0x000000);
$outfile参数false表示不生成图片文件,如果写上'picture.png'则会在根目录下生成一个png格式的图片文件
$level参数：控制二维码容错率,不同的参数表示二维码可被覆盖的区域百分比,默认L,可选值L(QR_ECLEVEL_L,7%)、M(QR_ECLEVEL_M,15%)、Q(QR_ECLEVEL_Q,25%)、H(QR_ECLEVEL_H,30%);利用二维维码的容错率,可以将头像放置在生成的二维码图片任何区域
$saveandprint参数：保存二维码图片并显示出来;$outfile必须传递图片路径
$back_color参数：背景颜色;
$fore_color参数：绘制二维码的颜色;
$back_color和$fore_color需要传16进制是色值,并且要把“#”替换为“0x”
例如：白色：#FFFFFF=>0xFFFFFF,黑色：#000000=>0x000000

</pre>官方实例 - base usage<pre class="php">
example_001_simple_png_output.php
include('../lib/full/qrlib.php');
QRcode::png('PHP QR Code'); // outputs image directly into browser, as PNG stream

example_002_simple_png_embedding.php
echo '< img src="example_001_simple_png_output.php" />';  // how to use image from example 001

</pre>官方实例 - business card<pre class="php">
include('../lib/full/qrlib.php');
include('config.php');

// how to build raw content - QRCode with detailed Business Card (VCard)
$tempDir = EXAMPLE_TMP_SERVERPATH;

$name         = 'John Doe';
$sortName     = 'Doe;John';
$phone        = '(049)012-345-678';
$phonePrivate = '(049)012-345-987';
$phoneCell    = '(049)888-123-123';
$orgName      = 'My Company Inc.';
$email        = 'john.doe@example.com';

// if not used,leave blank!
$addressLabel     = 'Our Office';
$addressPobox     = '';
$addressExt       = 'Suite 123';
$addressStreet    = '7th Avenue';
$addressTown      = 'New York';
$addressRegion    = 'NY';
$addressPostCode  = '91921-1234';
$addressCountry   = 'USA';

// building raw data
$codeContents  = 'BEGIN:VCARD'."\n";
$codeContents .= 'VERSION:2.1'."\n";
$codeContents .= 'N:'.$sortName."\n";
$codeContents .= 'FN:'.$name."\n";
$codeContents .= 'ORG:'.$orgName."\n";
$codeContents .= 'TEL;WORK;VOICE:'.$phone."\n";
$codeContents .= 'TEL;HOME;VOICE:'.$phonePrivate."\n";
$codeContents .= 'TEL;TYPE=cell:'.$phoneCell."\n";
$codeContents .= 'ADR;TYPE=work;'.
  'LABEL="'.$addressLabel.'":'
  .$addressPobox.';'
  .$addressExt.';'
  .$addressStreet.';'
  .$addressTown.';'
  .$addressPostCode.';'
  .$addressCountry
."\n";
$codeContents .= 'EMAIL:'.$email."\n";
$codeContents .= 'END:VCARD';

// generating
QRcode::png($codeContents, $tempDir.'026.png', QR_ECLEVEL_L, 3);

// displaying
echo '< img src="'.EXAMPLE_TMP_URLRELPATH.'026.png" />';

</pre>tp封装生成二维码函数,返回base64<pre class="php">
// application/common.php
function get_qrcode($data){
  vendor("phpqrcode.phpqrcode");
  $level = 'L';   // 纠错级别：L、M、Q、H
  $size = 4;      // 点的大小：1到10,用于手机端4就可以了
  $QRcode = new \QRcode();
  ob_start();
  $QRcode->png($data,false,$level,$size,2);
  $imageString = base64_encode(ob_get_contents());
  ob_end_clean();
  return "data:image/jpg;base64,".$imageString;
}

// 控制器调用
public function getQecode(){
  return '< img src="'.get_qrcode('hello qrcode').'" />';
}

</pre>生成带logo的二维码图片<pre class="php">
// application/common.php
function create_qrcode($data ='http://www.baidu.com', $level = 'L', $size =4){
  vendor("phpqrcode.phpqrcode");
  $outfile=ROOT_PATH."public/qrcode/".time().'.jpg';
  $QRcode = new \QRcode();
  ob_start();
  $QRcode->png($data,$outfile,$level,$size,2);
  ob_end_clean();
  return time();
}

namespace app\admin\controller;
class Qrcode extends \think\Controller{
  public function createQrcode(){
    $result=create_qrcode();  // 调用application/common.php公共函数
    echo $result;
  }

  // 生成带logo的二维码图片
  // 方法思路：先调用phpqrcode生成一张二维码,再使用php的image相关函数将logo图片添加到生成的二维码图片上
  public function qrcodeWithLogo(){
    Vendor('phpqrcode.phpqrcode');
    $object = new \QRcode();
    $text = request()->root(true);
    $level = 'L';
    $size = 6;
    $logo = ROOT_PATH.'public/static/logo.png';
    $qrcode = ROOT_PATH.'public/qrcode/qrcode.jpg';     // 存放生成原始二维码图地址
    $object->png($text, $qrcode, $level, $size, 2);     // 生成一个二维码图片
    if ($logo !== FALSE) {
      $qrcode = imagecreatefromstring(file_get_contents($qrcode));
      $logo = imagecreatefromstring(file_get_contents($logo));
      $qrcode_width = imagesx($qrcode);               //二维码图片宽度
      $qrcode_height = imagesy($qrcode);              //二维码图片高度
      $logo_width = imagesx($logo);                   //logo图片宽度
      $logo_height = imagesy($logo);                  //logo图片高度
      $logo_qr_width = $qrcode_width / 5;
      $scale = $logo_width / $logo_qr_width;
      $logo_qr_height = $logo_height / $scale;
      $from_width = ($qrcode_width - $logo_qr_width) / 2;
      //重新组合图片并调整大小
      imagecopyresampled($qrcode,$logo,$from_width,$from_width,0,0,$logo_qr_width,$logo_qr_height,$logo_width,$logo_height);
    }
    $savepath = "/public/qrcode/qrcodeWithLogo.png";
    imagepng($qrcode, ROOT_PATH.$savepath);             //输出图片
    echo '< img src="'.request()->root(true).$savepath.'">';
  }
}

</pre>

<h3>endroid/qrcode composer require endroid/qr-code</h3><pre class="php">
namespace app\admin\controller;
class Qrcode extends \think\Controller{
  // 基本版本
  public function endroid(){
    $qrCode = new \Endroid\QrCode\QrCode('http://www.baidu.com');
    header('Content-Type: '.$qrCode->getContentType());
    echo $qrCode->writeString();
    exit;
  }

  // 加上logo
  public function endroidWithLogo(){
    $set_log = true;
    $qrCode = new \Endroid\QrCode\QrCode('http://baidu.com');
    if($set_log ==true){
      $qrCode->setLogoPath(ROOT_PATH.'public/static/logo.png');
      $qrCode->setLogoWidth(90);
    }
    $qrCode->setErrorCorrectionLevel(\Endroid\QrCode\ErrorCorrectionLevel::HIGH);
    $name = rand(1,99999999).time();
    $path = ROOT_PATH.'public/qrcode/'.$name.'.png';
    $qrCode->writeFile($path);
    header('Content-Type: '.$qrCode->getContentType());
    echo $qrCode->writeString();
    //@去操作这张图片
    //@删除文件
    unlink($path);
    exit;
  }
}

</pre>
</div>

<div id="log">
<h2>日志</h2><pre>
日志记录由\think\Log类完成,主要完成日志记录和跟踪调试。由于日志记录了所有的运行错误,因此养成经常查看日志文件的习惯,可以避免和及早发现很多的错误隐患

【 日志初始化 】
如果没有执行日志初始化操作的话,默认会自动调用配置参数log来进行初始化
不同的日志类型可能会使用不同的初始化参数

在使用日志记录之前,首先需要初始化日志类,指定当前使用的日志记录方式。
Log::init([
  'type'  =>  'File',            // 指定了文件方式记录日志
  'path'  =>  APP_PATH.'logs/'   // 日志保存目录为APP_PATH.'logs/'
]);

应用扩展自己的日志驱动
Log::init([
  'type'  =>  '\org\Log\File',
  'path'  =>  APP_PATH.'logs/'
]);

【 日志驱动 】
日志可以通过驱动支持不同的方式写入,默认日志会记录到文件中,系统已经内置的写入驱动包括File驱动、Socket驱动(远程调试)
每个日志记录方式需要对应一个日志驱动文件,例如File方式记录对应的驱动文件是library/think/log/driver/File.php

日志的记录方式默认是File方式,可以通过驱动的方式来扩展支持更多的记录方式。

'log' => [
  'type' => 'File',          //日志记录方式,支持file、socket
  'path' => LOG_PATH,        //日志保存目录
  'level' => ['error'],      //日志记录级别,使用数组表示
  'file_size' =>2097152,     //单个日志文件的大小限制,超过后会自动记录到第二个文件
  'time_format' =>'c'        //日志的时间格式,默认是` c `
],

【 单文件日志 】
为了避免同一个目录下面的日志文件过多的性能问题,file方式记录的日志文件会自动生成日期子目录。
在某些情况下需要对日志记录进行分析和处理,那么开启单文件日志写入就会方便分析,开启后日志文件不再区分日期文件写入,而是统一写入到single.log文件中

'log' => [
  'type'  => 'File',
  'single' => true,   // 日志记录级别,使用数组表示
],

【 独立日志 】
为了便于分析,File类型的日志驱动还支持设置某些级别的日志信息单独文件记录,独立日志文件按天保存,不限制大小
如果开启了单文件日志写入的话,独立日志不会区分日期目录写入
设置后就会单独生成error和sql两个类型的日志文件,主日志文件中将不再包含这两个级别的日志信息

'log'   => [
  'type'          => 'file',
  'apart_level'   =>  ['error','sql'],  // error和sql日志单独记录
],

【 写入授权 】
日志功能支持写入授权,可以设置某个请求的日志授权Key,然后设置允许授权写入的配置Key,实现个别用户日志记录的功能,从而提高高负载下面的日志记录性能。

首先需要在应用配置文件或应用公共文件中添加当前访问的授权Key定义
Log::key(Request::instance()->ip());  // 设置IP为授权Key

然后在日志配置参数中增加allow_key参数
'log'   =>  [
  'type'      =>  'File',            // 日志类型为File
  'allow_key' =>  ['202.12.36.89'],  // 授权只有202.12.36.89才能记录日志
]

【 日志手动清空 】
日志类提供了日志清空的方法,可以在需要的时候手动清空日志,日志清空仅仅是清空内存中的日志。
Log::clear();

【 日志自动清理 】
支持文件日志的自动清理功能,设置
'max_files' => 30
则日志文件最多只会保留30个,超过会自动清理较早的日志文件,避免日志文件长期写入占满磁盘空间

【 关闭日志 】
系统并未提供关闭日志的方法,但有两种方式可以关闭日志的写入,第一种方式是设置日志类型为test,即可不写入任何日志。第二种方式是后面会提到的设置日志记录级别。
'log'   => [
  'type'  => 'test',  // 设置日志类型为Test即可临时关闭日志写入
],

【 日志级别 】
TP对系统的日志按照级别来分类,并且这个日志级别完全可以自己定义,系统内部使用的级别包括：
log    常规日志,用于记录日志
error  错误,一般会导致程序的终止
notice 警告,程序可以运行但是还不够完美的错误
info   信息,程序输出信息
debug  调试,用于调试信息
sql    SQL语句,用于SQL记录,只在数据库的调试模式开启时有效

【 日志写入 】
为避免内存溢出,在命令行下面执行的话日志信息会定时自动写入

一般情况下系统的日志记录是自动的,无需手动记录,但是某些时候也需要手动记录日志信息,Log类提供了3个方法用于记录日志。
Log::record() 记录日志信息到内存
Log::save()   把保存在内存中的日志信息(用指定的记录方式)写入
Log::write()  实时写入一条日志信息

由于系统在请求结束后会自动调用Log::save方法,所以通常只需要调用Log::record记录日志信息即可。
Log::record('测试日志信息');
Log::record('测试日志信息,这是警告级别','notice');  // 默认的话记录的日志级别是INFO,也可以指定日志级别

Log::write('测试日志信息,这是警告级别,并且实时写入','notice');

系统提供了不同日志级别的快速记录方法
Log::error('错误信息');
Log::info('日志信息');
// 和下面的用法等效
Log::record('错误信息','error');
Log::record('日志信息','info');

还封装了一个助手函数用于日志记录
trace('错误信息','error');
trace('日志信息','info');

</pre>
</div>

<div id="debug">
<h2>错误和调试</h2>
<h3>调试模式</h3><pre>
应用默认开启调试模式,在完成开发阶段部署到生产环境后可以修改应用配置文件的app_debug参数关闭调试模式切换到部署模式。
'app_debug' => false,  // 关闭调试模式

除此之外还可以在应用的ROOT_PATH目录下面定义.env文件,并且定义APP_DEBUG配置参数用于替代入口文件的常量定义,这样便于在部署环境中设置环境变量来开启和关闭调试模式。定义了.env文件后,配置文件中定义app_debug参数无效

.env文件的定义格式
# 设置开启调试模式
app_debug = true
# 其它的环境变量设置
author=berlin

var_dump($_ENV); // 返回空
var_dump($GLOBALS);
'env' =>
  array (size=1)
    'author' => string 'berlin' (length=6)
'val' => string 'berlin' (length=6)
'key' => string 'author' (length=6)
'name' => string 'PHP_AUTHOR' (length=10)

调试模式的优势：
开启日志记录,任何错误信息和调试信息都会详细记录,便于调试;
会详细记录整个执行过程;
模板修改可以即时生效;
记录SQL日志,方便分析SQL;
通过Trace功能更好的调试和发现错误;
发生异常的时候会显示详细的异常信息;

由于调试模式没有任何缓存,因此涉及到较多的文件IO操作和模板实时编译,所以在开启调试模式的情况下,性能会有一定的下降,但不会影响部署模式的性能

一旦关闭调试模式,项目的调试配置文件即刻失效,发生错误后不会提示具体的错误信息,如果仍希望看到具体的错误信息可以如下设置：
'show_error_msg' => true,

</pre>

<h3>异常处理</h3><pre>
和PHP默认的异常处理不同,TP抛出的不是单纯的错误信息,而是一个人性化的错误页面
只有在调试模式下面才能显示具体的错误信息,如果在部署模式下面可能看到的是一个简单的提示文字

本着严谨的原则默认会对任何错误(包括警告错误)抛出异常,如果不希望如此严谨的抛出异常,可以在应用公共函数文件中或配置文件中使用error_reporting方法设置错误报错级别,在入口文件中设置无效
error_reporting(E_ERROR | E_PARSE );  // 异常错误报错级别

【 异常处理接管 】
框架支持异常页面自定义类进行处理,需要配置参数exception_handle
'exception_handle' => '\\app\\common\\exception\\Http',   // 异常处理handle类,留空使用\think\exception\Handle

如果配置了'exception_handle'且没有再次调用系统render的情况下,配置http_exception_template就不再生效,具体可以参考Handle类内实现的功能。

自定义类需要继承Handle并且实现render方法
namespace app\common\exception;
use Exception;
use think\exception\Handle;
use think\exception\HttpException;
class Http extends Handle{
  public function render(Exception $e){
    // 参数验证错误
    if ($e instanceof ValidateException) {
      return json($e->getError(), 422);
    }

    // 请求异常
    if ($e instanceof HttpException && request()->isAjax()) {
      return response($e->getMessage(), $e->getStatusCode());
    }

    //TODO::开发者对异常的操作,可以在此交由系统处理
    return parent::render($e);
  }
}

可以通过闭包定义的方式简化异常自定义处理,例如上面的自定义异常类可以改为直接配置exception_handle参数：
'exception_handle'  =>  function(Exception $e){
  // 参数验证错误
  if ($e instanceof \think\exception\ValidateException) {
    return json($e->getError(), 422);
  }

  // 请求异常
  if ($e instanceof \think\exception\HttpException && request()->isAjax()) {
    return response($e->getMessage(), $e->getStatusCode());
  }
}

【 异常捕获 】
可以使用PHP的异常捕获进行必要的处理,但在异常捕获中不要使用think\Controller类的error、success和redirect方法,因为上述三个方法会抛出HttpResponseException异常,从而影响正常的异常捕获,例如：

try{
  Db::name('user')->find();
  $this->success('执行成功!');
}catch(\Exception $e){
  $this->error('执行错误');
}

应该改成

try{
  Db::name('user')->find();
}catch(\Exception $e){
  $this->error('执行错误');
}
$this->success('执行成功!');

【 手动抛出异常 】
可以使用\think\Exception类来抛出异常
throw new \think\Exception('异常消息', 100006);

如果不使用think异常类,也可以自定义异常类来抛出异常
throw new \foobar\Exception('异常消息');

助手函数
exception('异常消息', 100006);
exception('异常消息', 100006, \foobar\Exceeption);  // 使用自定义异常类

【 抛出HTTP异常 】
一般来说HTTP异常是由系统自动抛出的

可以使用\think\exception\HttpException类来手动抛出http异常
throw new \think\exception\HttpException(404, '异常消息', null, [参数]);

助手函数
abort(404, '异常消息', [参数]);
abort(404,'页面不存在');

404页面
一旦抛出了HttpException异常,可以支持定义单独的异常页面的模板地址(模板文件支持模板引擎中的标签)
'http_exception_template' => [   // 仅在部署模式下面生效
  404 => APP_PATH.'404.html',    // 定义404错误的重定向页面地址
  401 => APP_PATH.'401.html',    // 还可以定义其它的HTTP status
]

</pre>

<h3>Trace调试</h3><pre>
调试模式并不能完全满足调试的需要,有时候需要手动的输出一些调试信息。除了本身可以借助一些开发工具进行调试外,TP还提供了一些内置的调试工具和函数。

Trace调试功能就是TP提供给开发人员的一个用于开发调试的辅助工具,可以实时显示当前页面的操作的请求信息、运行情况、SQL执行、错误提示等,并支持自定义显示,支持没有页面输出的操作调试。

Trace调试功能对调试模式和部署模式都有效,可以单独开启和关闭。
只是在部署模式下面,显示的调试信息没有调试模式完整,通常建议Trace配合调试模式一起使用

【 开启Trace调试 】
如果定义了环境变量app_trace,那么以环境变量配置为准

默认关闭Trace调试功能,要开启Trace调试功能只需要配置下面参数：
'app_trace' =>  true,  // 开启应用Trace调试

开启页面Trace功能需要配置trace参数为：
// Trace信息
'trace'     =>  [
  'type'  =>  'html',  //支持Html,Console(使用浏览器console输出trace信息,方便没有页面输出的操作功能调试)
]

设置后并且页面有输出的话,页面右下角会显示ThinkPHP的LOGO
LOGO后面的数字就是当前页面的执行时间(单位是秒),点击该图标后,会展开详细的Trace信息

Trace框架有6个选项卡,分别是基本、文件、流程、错误、SQL和调试,点击不同的选项卡会切换到不同的Trace信息窗口。
基本  当前页面的基本摘要信息,例如执行时间、内存开销、文件加载数、查询次数等等
文件  详细列出当前页面执行过程中加载的文件及其大小
流程  会列出当前页面执行到的行为和相关流程
错误  当前页面执行过程中的一些错误信息,包括警告错误
SQL  当前页面执行到的SQL语句信息
调试  开发人员在程序中进行的调试输出

Trace的选项卡是可以定制和扩展的,默认的配置为：
'trace' =>[
  'type'       =>  'Html',
  'trace_tabs' =>  [
     'base'=>'基本',
     'file'=>'文件',
     'info'=>'流程',
     'error|notice'=>'错误',
     'sql'=>'SQL',
     'debug|log'=>'调试'
   ]
]

增加新的选项卡：用户则可以修改配置
'trace' =>[
  'type'       =>  'Html',
  'trace_tabs' =>  [
     'base'=>'基本',
     'file'=>'文件',
     'info'=>'流程',
     'error'=>'错误',
     'sql'=>'SQL',
     'debug'=>'调试',
     'user'=>'用户'
   ]
]

把某几个选项卡合并
'trace' =>[
  'type'       =>  'Html',
  'trace_tabs' =>  [
     'base'=>'基本',
     'file'=>'文件',
     'error|notice'=>'错误',
     'sql'=>'SQL',
     'debug|log|info'=>'调试',
   ]
]

</pre>

<h3>变量调试</h3><pre>
除了Trace调试之外,系统还提供了\think\Debug类用于各种调试。

输出某个变量是开发过程中经常会用到的调试方法,除了使用php内置的var_dump和print_r之外,ThinkPHP框架内置了一个对浏览器友好的dump方法,用于输出变量的信息到浏览器查看

Debug::dump($var, $echo=true, $label=null)
dump($var, $echo=true, $label=null)
var(必须)   要输出的变量,支持所有变量类型
echo(可选)  是否直接输出,默认为true,如果为false则返回但不输出
label(可选) 变量输出的label标识,默认为空

如果需要在调试变量输出后中止程序的执行,可以使用halt函数
$blog = Db::name('blog')->where('id', 3)->find();
halt($blog);
echo '这里的信息是看不到的';

</pre>

<h3>性能调试</h3><pre>
开发过程中,为了测试性能经常需要调试某段代码的运行时间或内存占用开销,系统提供了think\Debug类可以很方便的获取某个区间的运行时间和内存占用情况

Debug::remark('begin');
# ...其他代码段
Debug::remark('end');
# ...也许这里还有其他代码
echo Debug::getRangeTime('begin','end').'s';   // 进行统计区间
echo Debug::getRangeTime('begin','end',6).'s'; // 设置统计精度为6位,默认的统计精度是小数点后4位
echo Debug::getRangeMem('begin','end').'kb';   // 如果环境支持内存占用统计还可用getRangeMem方法进行区间内存开销统计,单位为kb,第三个参数使用m表示进行内存开销统计

begin必须是一个已经标记过的位置,如果这个时候end位置还没被标记过则会自动把当前位置标记为end标签

助手函数
debug('begin');
# ...其他代码段
debug('end');
# ...也许这里还有其他代码
echo debug('begin','end').'s';       // 进行统计区间
echo debug('begin','end',6).'s';
echo debug('begin','end','m').'kb';

</pre>

<h3>SQL调试</h3><pre>
查看SQL记录
如果开启了数据库的调试模式的话,可以在日志文件或设置的日志输出类型中看到详细的SQL执行记录以及性能分析

监听SQL
如果开启数据库的调试模式的话可以对数据库执行的任何SQL操作进行监听
默认如果没有注册任何监听操作的话,这些SQL执行会被根据不同的日志类型记录到日志中。
Db::listen(function($sql,$time,$explain){
  echo $sql. ' ['.$time.'s]';   // 记录SQL
  dump($explain);               // 查看性能分析结果
});

调试执行的SQL语句
在模型操作中为了更好的查明错误,可以用getLastsql方法来输出上次执行的sql语句

User::get(1);
echo User::getLastSql();   // SELECT * FROM 'think_user' WHERE 'id' = '1'

也可以使用fetchSql方法直接返回当前的查询SQL而不执行
echo User::fetchSql()->find(1);

getLastSql方法只能获取最后执行的SQL记录,如果需要了解更多的SQL日志,可以通过查看当前的Trace信息或日志文件。

</pre>

<h3>远程调试</h3><pre>
TP5.0提供了Socket日志驱动用于本地和远程调试

Socket调试
只需要在配置文件中设置如下：
'log' =>  [
  'type'                => 'socket',
  'host'                => 'slog.thinkphp.cn',  //该host配置地址是官方提供的公用服务端,首先需要去申请client_id
  'force_client_ids'    => [],                  //日志强制记录到配置的client_id
  'allow_client_ids'    => [],                  //限制允许读取日志的client_id
]

使用Chrome浏览器运行后,打开审查元素->Console,可以看到详细信息
SocketLog通过websocket将调试日志打印到浏览器的console中。还可以用它来分析开源程序,分析SQL性能,结合taint分析程序漏洞
SocketLog首先需要安装chrome插件

</pre>
</div>

<div id="safe">
<h2>安全</h2><pre>
【 输入安全 】
永远不要相信用户提交的数据,建议务必遵守下面规则：
设置public目录为唯一对外访问目录,不要把资源文件放入应用目录;
开启表单令牌验证避免数据的重复提交,能起到CSRF防御作用;
使用框架提供的请求变量获取方法(Request类param方法及input助手函数)而不是原生系统变量获取用户输入数据;
对不同的应用需求设置default_filter过滤规则(默认没有任何过滤规则),常见的安全过滤函数包括stripslashes、htmlentities、htmlspecialchars和strip_tags等,请根据业务场景选择最合适的过滤方法;
使用验证类或验证方法对业务数据设置必要的验证规则;
如果可能开启强制路由或设置MISS路由规则,严格规范每个URL请求;

【 数据库安全 】
数据操作使用了PDO预处理机制及自动参数绑定功能,请确保：
尽量少使用数组查询条件而应该使用查询表达式替代;
尽量少使用字符串查询条件,如果不得已的情况下使用手动参数绑定功能;
不要让用户输入决定要查询或写入的字段;
对于敏感数据在输出的时候使用hidden方法进行隐藏;
对于数据的写入操作应当做好权限检查工作;
写入数据严格使用field方法限制写入字段;
对于需要输出到页面的数据做好必要的XSS过滤;

【 上传安全 】
网站的上传功能也是一个非常容易被攻击的入口,所以对上传功能的安全检查是尤其必要的。

系统的think\File提供了文件上传的安全支持,包括对文件后缀、文件类型、文件大小及上传图片文件的合法性检查,确保已经在上传操作中启用了这些合法性检查。

为了方便版本升级,并且保证public目录为唯一的web可访问目录,资源文件可以放到项目之外,例如项目目录为
/home/www/thinkphp/
那么资源目录、上传文件保存的目录
/home/www/resource/
/home/www/resource/upload/
为了项目的可维护性,目录操作最好不超出本项目的根目录,所以需要把resource目录映射到根目录
ln -s /home/www/resource/  /home/www/thinkphp/resource/
如果上传文件也需要web访问,可以生成一个软连接到public
ln -s /home/www/thinkphp/resource/upload/  /home/www/thinkphp/public/upload/

【 其它的一些安全建议 】
对所有公共的操作方法做必要的安全检查,防止用户通过URL直接调用;
不要缓存需要用户认证的页面;
对用户的上传文件,做必要的安全检查,例如上传路径和非法格式;
对于项目进行充分的测试,不要生成业务逻辑的安全隐患(这可能是最大的安全问题);
最后一点,做好服务器的安全防护,安全问题的关键其实是你的最薄弱的环节;

</pre>
</div>

<div id="phpunit">
<h2>单元测试</h2><pre>
单元测试是对单独的代码对象进行测试的过程,比如对函数、类、方法进行测试。单元测试可以使用任意一段已经写好的测试代码,也可以使用一些已经存在的测试框架,比如PHPUnit、Phake或SimpleTest,单元测试框架提供了一系列共同、有用的功能来帮助编写自动化的检测单元,例如检查一个实际的值是否符合期望的值的断言。单元测试框架经常会包含每个测试的报告及给出已经覆盖到的代码覆盖率。

单元测试对于团队开发而言,主要作用包括：
尽可能减少开发中的BUG;
帮助提高应用或接口设计;
协助代码文档的编写;
减少开发过程的代码修改带来的错误;

TP5.0目前支持PHPUnit进行单元测试,TP5.0核心也是采用PHPUnit作为单元测试工具,这是最常用的单元测试工具,TP单元测试扩展还针对控制器和模型的单元测试做了完善支持,添加了额外的单元测试方法和断言。

【 安装扩展 】
首先安装TP5的单元测试扩展,命令行切换到应用根目录下面后执行：
composer require topthink/think-testing
不需要单独安装PHPUnit包,安装单元测试扩展的时候会自动安装相关的依赖包,其中就包括PHPUnit

安装完成后会在应用根目录下面增加tests目录和phpunit.xml文件。
tests目录是应用的单元测试用例目录,该目录下面的TestCase.php文件是所有单元测试类必须继承的基础类,不能删除
ExampleTest.php是测试示例文件,可以删除。

【 运行测试 】
由于单元测试扩展默认自带了一个tests/ExampleTest.php 单元测试文件,内容如下：
namespace tests;
class ExampleTest extends TestCase{
  public function testBasicExample(){
    $this->visit('/')->see('ThinkPHP');
  }
}
表示测试访问网站首页的响应输出内容中是否包含ThinkPHP内容
因此可以直接在命令行下面运行单元测试：
php think unit

如果是第一次安装TP5或没有改动过Index模块Index控制器的index方法的话,测试是OK的,会显示类似下面的结果：
PHPUnit 4.8.27 by Sebastian Bergmann and contributors.
.
Time: 221 ms, Memory: 6.00MB
OK (1 test, 2 assertions)

如果改过index方法并且页面输出内容没有ThinkPHP的话,测试就会失败。
PHPUnit 4.8.27 by Sebastian Bergmann and contributors.
F
Time: 230 ms, Memory: 6.00MB
There was 1 failure:
1) tests\ExampleTest::testBasicExample
Failed asserting that 'Hello,world' matches PCRE pattern "/ThinkPHP/i".
D:\www\tp5\vendor\topthink\think-testing\src\InteractsWithPages.php:67
D:\www\tp5\tests\ExampleTest.php:18
D:\www\tp5\vendor\topthink\think-testing\src\command\Test.php:39
D:\www\tp5\thinkphp\library\think\console\command\Command.php:195
D:\www\tp5\thinkphp\library\think\Console.php:728
D:\www\tp5\thinkphp\library\think\Console.php:188
D:\www\tp5\thinkphp\library\think\Console.php:125
D:\www\tp5\thinkphp\library\think\Console.php:94
D:\www\tp5\thinkphp\console.php:20
FAILURES!
Tests: 1, Assertions: 2, Failures: 1.

请始终使用以上命令进行单元测试,而不是直接用phpunit来运行单元测试。

【 添加单元测试用例 】
添加一个控制器类的单元测试文件tests/index/IndexTest.php,为了便于管理,按照模块名创建单元测试的子目录和应用类库的目录结构对应起来：
namespace tests\index;
use tests\TestCase;
class IndexTest extends TestCase{
  public function setUp(){
    parent::setUp();
  }
  public function testSome(){
    $this->assertTrue(true);
  }
  public function tearDown(){
    // todo
  }
}

每个单元测试类必须继承TestCase类或其子类,每个单元测试方法必须以test开头。
除了单元测试方法之外,还可以增加一些特殊的单元测试定义方法
setUp方法会在每一个单元测试方法之前自动调用,所以该方法可以用于一些测试的初始化即基境(fixture),对应还有一个tearDown方法会在每个测试方法完成后自动调用,通常用于重置一些测试的数据。

如果要同时对控制器类和模型类做单元测试的话,也可以在模块目录下面创建controller和mode子目录,然后分别创建单元测试文件。

控制器单元测试文件 tests/index/controller/IndexTest.php,测试用例对网站首页进行了一次GET请求,并判断是否返回正确的响应。
namespace tests\index\controller;
use tests\TestCase;
class IndexTest extends TestCase{
  public function testIndex(){
    $this->call('GET', '/');
    $this->assertResponseOk();
  }
}

模型单元测试文件 tests/index/model/IndexTest.php,该测试用例测试数据表think_user是否存在id为2的数据
namespace tests\index\model;
use tests\TestCase;
class IndexTest extends TestCase{
  public function testSearch(){
    $this->seeInDatabase('user', ['id' => 2]);
  }
}

其实模型的测试用例和控制器的测试用例没有明确的界限,大多数情况只需要针对控制器类做单元测试即可,同样仍然可以对不同的应用层类库做单元测试。

除了支持PHPUnit自带的测试方法外,TP单元测试扩展还封装了一些额外的方法

定义单元测试
单元测试最大的工作是使用断言(assertion),所以会发现PHPUnit自身带了很多的断言方法,常用的断言方法包括：
assertTrue($var) 断言变量为true
assertFalse($var) 断言变量为false
assertEquals($value,$var) 断言变量为$value
assertNull($var) 断言变量为null
assertContains($needle,$var) 断言变量中包含$needle

</pre>
</div>

<div id="tips">
<h2>Tips:问题集锦</h2><pre>
1.tp5整合ueditor,onclick="return alert(UE.getEditor('content').getContent())"可以弹出textarea编辑器的值,
但无法post处理,$_POST["content"]==''
解决方法：form表单包含table

使用ueditor上传视频是对apach和PHP的php.ini更改内容：
post_max_size=3 -> 64M,
upload_max_filesize=64M;
max_execution_time=120 -> 1200,
memory_limit=128M,
max_input_time=60 -> 1200

2.数据库更新update(),没有内容更新时返回0,提示更新失败,有内容改变时才会提示更新成功,所以要注意返回的地址
管理员修改时使用场景验证,不再验证密码,密码为空时表示密码不变,不更password字段即可

3.管理员管理的删除操作须屏蔽,管理员列表必须不展示删除功能,
为防止通过地址栏删除超级管理员,必须在控制器方法内部再次判断是否是超级管理员

4.$_SERVER['HTTP_REFERER']可以获取当前链接的上一个连接的来源地址,即链接到当前页面的前一页面的 URL 地址,
可以做到防盗链作用,只有点击超链接打开的页面才有HTTP_REFERER环境变量
其它如 window.open()、 window.location=...、window.showModelessDialog()等打开的窗口都没有HTTP_REFERER 环境变量。

js中location.href是获取当前页面的地址,可以在cookie或session中传递使用

5.后台栏目排序
方法1：排序页面name=cid,value=sort,post一个索引为cid,值为sort的一维数组,
控制器方法接收之后循环setField()更新sort字段

方法2：排序页面name=sort[],value=sort;设置隐藏字段name=cid[],value=cid;post一个二维数组,
控制器方法接收之后转换成新的二维数组循环setField()更新sort字段

$a= array('张三','李四','王五');
$b= array ('23','24','25');
foreach($a as $key=>$val){
    $d[$key]['姓名']=$a[$key];
    $d[$key]['年龄']=$b[$key];
}
dump($d);

6.后台删除博文和批量删除操作
input('bid') 返回单个字符串,input('') 返回1个或多个元素的数组
单条博文删除链接传递bid,是get方式;批量删除表单post方式根据bid来删除
可以共用控制器中的同一方法,input('')接收bid数组,foreach结合事务处理

db('user')->delete([1,2,3]);  //批量删除

</pre><pre class="php">
  <form action="{:url('deleteblog')}" method="post" onsubmit="return confirm('确定要删除吗？')" > </form>
  <a href="{:url('deleteblog',['bid'=>$vo.bid])}" onclick="return confirm('确定要删除该博文吗？')">删除</a>
</pre><pre>

7.怎么实现权限控制,防止地址栏进行删除操作,但是可以伪造一个HTTP_REFERER ！！！
限制入口地址,不能从地址栏进入,外部网页跳转到主页,但是内部网页怎么办？？？也是跳到首页
防止跳转回原页面时tp5报出HTTP_REFERER错误
使用target="_black"跳转时$_SERVER['HTTP_REFERER']

if( !isset($_SERVER['HTTP_REFERER'])){         //判断是否有上一个URL存在,表示从页面点击而来  否则就是直接键入地址
        $this->error('页面错误！','bloglist');   //$this->error默认是返回之前页面
}

dump($GLOBALS); 从当前页面链接进入的$_SERVER['HTTP_REFERER']才会有值,不然不存在

{$Request.header.referer}           //模板输出

echo $_SERVER['HTTP_REFERER'];      //不存在时会报错,不存在或未定义HTTP_REFERER
echo request()->header('referer');  //不存在时为空,不会报错

if(!request()->header('referer')){  //从地址栏进入登录页面,防止页面中的未定义数组索引: HTTP_REFERER报错
return $this->error('页面错误！');   //限制从页面唯一链接进入登录页
}

if(!request()->isPost()){
  $this->error('页面错误！');
}

8.二维数组添加索引的问题
foreach ($authrule as $k=>$v) {     //循环全部权限,如果在已有权限内则标记confed为1,便于模板标识
	$authrule[$k]['confed']=in_array($v['id'],$grouprules)?'1':'0';
	//$v['confed']=in_array($v['id'],$grouprules)?'1':'0';     //为什么不可以？？？？？
}

foreach ($authrule as &$v) {     //在$v前加一个取地址符&
	$v['confed']=in_array($v['id'],$grouprules)?'1':'0';     //为什么不可以？？？？？
}

9.全选,全不选  $(this).attr('checked')在thinkgroup内有效,在tp509内无效
$('.parentrule').click(function(){
	var inputs=$(this).parents('.maprule').find('.sonrule');
	// $(this).attr('checked')?inputs.attr('checked','checked'):inputs.removeAttr('checked');
	$(this).is(':checked')?inputs.attr('checked','checked'):inputs.removeAttr('checked');
});

10.tp509后台用户列表模板链接中href="{:url('editormembers',['uid'=>$vo.uid,'group_title'=>$vo.group_title])}"
group_title为超级管理时不能正确传参跳转,出现404页面Not Found,但是传递其他参数如普通管理、编辑等可以正常传递

11.有且仅有一个超级管理uid=1,admin
session('uid')可以分辨当前登录的用户,顶部导航栏修改密码按钮权限只能修改当前用户的密码,传递的uid必须是seesion的uid
用户管理中修改用户信息,传递的对应用户的uid

12.控制器中的方法接收传递的参数,和url传递的参数
public function action_name($uid){…………}                //必须接收一个uid参数
public function action_name($param='默认值'){…………}

实例：后台删除用户public function deletemembers(){},地址栏不传参数,显示没有条件不会执行删除操作
public function deletemembers($uid){},没有默认值,地址栏不传参数,显示方法参数错误:uid
public function deletemembers($uid=0){},默认值位0,地址栏不传参数,显示删除管理员失败

13.把session保存到数据库中,然后,现在有多少人访问,就有多少session,那么select数据库中的全部session,就可以遍历

14.后台禁止非管理员进入
后台入口：只能从地址栏进入
会员表添加typeof字段,前台注册用户采用默认值0,后台添加的用户的typeof值为1,
后台登录时验证用户名和密码后验证typeof值,为0则显示权限不足,返回前端首页;

后台登录后存入session.adminpass,除后台登录页没有继承后台共用控制器的初始化方法,
所有控制器必须先验证session.adminpass,其值不存在时表示非后台登录用户,跳转至前端首页;其值存在再采用auth验证管理员的权限
问题：非管理员进入后台要跳转到哪里？？本网站进入和外部网址进入

15.内置验证规则max,汉字和英文不同,需要结合js进行验证

</pre>
</div>

</main>
<ol>
  <li><a href="#framework">框架framework</a></li>
	<li><a href="#config">配置config</a></li>
  <li><a href="#route">url路由route</a></li>
	<li><a href="#controller">控制器controller</a></li>
	<li><a href="#request">请求request</a></li>
  <li><a href="#response">响应response</a></li>
	<li><a href="#db">数据库db</a></li>
	<li><a href="#model">模型model</a></li>
	<li><a href="#view">视图view</a></li>
	<li><a href="#tpl">模板template</a></li>
	<li><a href="#tag">内置标签</a></li>
	<li><a href="#page">分页</a></li>
  <li><a href="#cache">缓存</a></li>
  <li><a href="#cmd">cmd</a></li>
  <li><a href="#session">session cookie</a></li>
  <li><a href="#upload">上传</a></li>
	<li><a href="#validate">验证</a></li>
  <li><a href="#behavior">behavior</a></li>
  <li><a href="#captcha">验证码captcha</a></li>
	<li><a href="#img">图像</a></li>
	<li><a href="#phpexcel">phpexcel</a></li>
  <li><a href="#qrcode">qrcode</a></li>
  <li><a href="#log">log</a></li>
  <li><a href="#debug">debug</a></li>
  <li><a href="#safe">safe</a></li>
  <li><a href="#phpunit">phpunit</a></li>
	<li><a href="#tips">TIPS</a></li>
</ol>

<script src="vendors/jquery-3.3.1.min.js"></script>
<script src="vendors/public.js"></script>
<script src="vendors/SyntaxHighlighter/shCore.js"></script>
<script>
  // 代码高亮
    $('pre[class=html]').addClass('brush:html;toolbar:false');
    $('pre[class=js]').addClass('brush:js;toolbar:false');
    $('pre[class=php]').addClass('brush:php;toolbar:false');
    SyntaxHighlighter.all();
</script>
</body>
</html>