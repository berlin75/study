<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>laravel doc</title>
<link rel="stylesheet" href="vendors/public.css">
</head>
<body>
<h1><a name="top">laravel</a></h1>

<main>
<pre>
【 安装 】
在终端中运行create-project命令来安装Laravel：
$ composer create-project --prefer-dist laravel/laravel blog
$ composer create-project --prefer-dist laravel/laravel blog "5.5.*"  // 安装Laravel 5.5的最新版

public function home(Request $request){
  dd($request->all());
  dump($request);
  dump($request->segments());
  dd($request->file('picture'));
  $id = $request->input('id');
  return 'Hello, World!';
}

Route::get('/', function () {
  dump(env('APP_DEBUG'));
  dump(App::environment());
  dump(config('app.timezone'));
  config(['app.timezone' => 'PRC']);
  dump(config('app.timezone'));
  return view('welcome');
});

>php artisan tinker
Psy Shell v0.10.2 (PHP 7.2.5 — cli) by Justin Hileman
>>> ?

应用密钥
安装Laravel之后下一件应该做的事就是将应用程序的密钥设置为随机字符串。如果是通过Composer或Laravel安装器安装的Laravel,那这个密钥已经通过php artisan key:generate 命令设置好了。通常这个字符串长度为32个字符。密钥可以在.env环境文件中设置。前提是要将.env.example文件重命名为.env。 如果应用程序密钥没有被设置就不能确保用户会话和其他加密数据的安全

报错The Mix manifest does not exist
这是因为resources/views/layouts/app.blade.php中使用mix()方法,而还未运行Laravel Mix进行编译,找不到mix-manifest.json文件,所以报错
href="{{ mix('css/app.css') }}"
Laravel Mix一款前端任务自动化管理工具,使用了工作流的模式对制定好的任务依次执行。Mix提供了简洁流畅的API,能够为Laravel应用定义Webpack编译任务。Mix支持许多常见的CSS与JS预处理器,通过简单的调用可以轻松地管理前端资源。
使用Mix很简单,首先需要安装npm依赖即可
npm run watch-poll
watch-poll会在终端里持续运行,监控resources文件夹下的资源文件是否有发生改变。在watch-poll命令运行的情况下,一旦资源文件发生变化,Webpack会自动重新编译。

获取laravel项目的路径的内置帮助函数
$path = app_path();                                   // 返回app目录的绝对路径
$path = app_path('Http/Controllers/Controller.php');  // 为相对于app目录的给定文件生成绝对路径
$path = base_path();                                  // 返回项目根目录的绝对路径
$path = base_path('vendor/bin');                      // 为相对于应用目录的给定文件生成绝对路径
$path = config_path();                                // 返回应用配置目录的绝对路径
$path = database_path();                              // 返回应用数据库目录的绝对路径
$path = public_path();                                // 返回public目录的绝对路径
$path = storage_path();                               // 返回storage目录的绝对路径
$path = storage_path('app/file.txt');                 // 生成相对于storage目录的给定文件的绝对路径

Illuminate 照明; 照亮; 照射; 阐明; 解释; 用彩灯装饰;
Foundation 基础; 基本原理
Kernel     核心
bootstrapper 启动加载器; 引導程序; 引导程序; 启动载入器;


</pre>

<h4>kernel</h4><pre>
服务容器Container  服务提供者ServiceProvider 契约接口Contract 门面Facades类
Laravel的核心就是一个IoC容器,Laravel的核心本身十分轻量,并没有什么很神奇很实质性的应用功能。用到的各种功能模块比如 Route（路由）、Eloquent ORM（数据库ORM组件）、Request（请求）以及 Response（响应）等,实际上都是与核心无关的类模块提供的,这些类从注册到实例化,最终被所使用,其实都是Laravel的服务容器负责的

一个类要被容器所能够提取必须要先注册至这个容器,既然Laravel称这个容器叫做服务容器,那么需要某个服务就得先注册、绑定这个服务到容器,那么提供服务并绑定服务至容器的东西就是服务提供者（Service Provider）。
虽然绑定一个类到容器不一定非要通过服务提供者,但有时候类、模块会有需要其他类和组件的情况,为了保证初始化阶段不会出现所需要的模块和组件没有注册的情况,Laravel将注册和初始化行为进行拆分,注册的时候就只能注册,初始化的时候就是初始化。拆分后的产物就是现在的服务提供者。
服务提供者主要分为两个部分,register（注册） 和 boot（引导、初始化）,register 负责进行向容器注册“脚本”,但要注意注册部分不要有对未知事物的依赖,如果有就要移步至boot部分

服务提供者用于为相关服务容器提供统一绑定场所,此外服务提供者还可以做一些初始化启动操作。Laravel的每个核心组件都对应一个服务提供者,可以这么说,服务提供者是Laravel的心脏,是Laravel的核心,核心组件类在这里完成注册、初始化以供后续调用

</pre>在Laravel应用中定义和使用服务提供者<textarea>
1、定义服务类
先定义一个绑定到容器的测试类TestService,为了对类的定义加以约束,同时还定义一个契约接口TestContract

namespace App\Contracts;
interface TestContract {
  public function callMe($controller);
}

定义TestService
namespace App\Services;
use App\Contracts\TestContract;
class TestService implements TestContract {
  public function callMe($controller) {
    dd('Call Me From TestServiceProvider In '.$controller);
  }
}

2、创建服务提供者
定义一个服务提供者TestServiceProvider用于注册该类到容器。创建服务提供者可以使用如下Artisan命令：
php artisan make:provider TestServiceProvider
该命令会在app/Providers目录下生成一个TestServiceProvider.php文件,编辑该文件内容如下：
 
namespace App\Providers;
use Illuminate\Support\ServiceProvider;
use App\Services\TestService;
class TestServiceProvider extends ServiceProvider {
  /**
    * Bootstrap the application services.
    * @return void
    */
  public function boot() {
    //
  }

  /**
    * Register the application services.
    * @return void
    * @author LaravelAcademy.org
    */
  public function register() {  // 两种绑定方法
    //使用singleton绑定单例
    $this->app->singleton('test', function(){
      return new TestService();
    });
    //使用bind绑定实例到接口以便依赖注入
    $this->app->bind('App\Contracts\TestContract', function(){
      return new TestService();
    });
  }
}

3、注册服务提供者
定义完服务提供者类后,接下来需要将该服务提供者注册到应用中,只需将该类追加到配置文件config/app.php的providers数组中即可：
'providers' => [
    //其他服务提供者
    App\Providers\TestServiceProvider::class,
],

4、测试服务提供者
这样就可以在应用中使用该服务提供者了,为了测试该服务提供者首先使用Artisan命令创建一个资源控制器TestController：
php artisan make:controller TestController
然后在路由配置文件routes.php中定义路由：
Route::resource('test','TestController');
最后去TestController中编写测试代码：

namespace App\Http\Controllers;
use Illuminate\Http\Request;
use App\Http\Requests;
use App\Http\Controllers\Controller;
use App;
use App\Contracts\TestContract;
class TestController extends Controller {
    //依赖注入
    public function __construct(TestContract $test){
      $this->test = $test;
    }

    /**
      * Display a listing of the resource.
      * @return Response
      * @author LaravelAcademy.org
      */
    public function index() {
      // $test = App::make('test');
      // $test->callMe('TestController');
      $this->test->callMe('TestController');
    }
    ...//其他控制器动作
}

然后去浏览器中访问http://laravel.app:8000/test,分别测试使用App::make和依赖注入解析绑定类调用callMe方法的输出,结果一样都是：
"Call Me From TestServiceProvider In TestController"

</textarea>门面类Facades提供了一个“静态”接口到服务容器中绑定的类<textarea>
首先创建一个需要绑定到服务容器的Test类：
namespace App\Facades;
class Test {
  public function doSomething() {
    echo 'This is TestClass\'s method doSomething';
  }
}

然后创建一个静态指向Test类的门面类TestClass：
namespace App\Facades;
use Illuminate\Support\Facades\Facade;
class TestClass extends Facade {
  protected static function getFacadeAccessor() {
    return 'test';
  }
}

接下来要在服务提供者中绑定Test类到服务容器,修改TestServiceProvider类如下：
namespace App\Providers;
use Illuminate\Support\ServiceProvider;
use App\Services\TestService;
use App\Facades\Test;
class TestServiceProvider extends ServiceProvider {
  /**
    * Bootstrap the application services.
    * @return void
    */
  public function boot() { }
  
  /**
    * Register the application services.
    * @return void
    */
  public function register() {
    $this->app->singleton('test',function(){
      //return new TestService();
      return new Test;
    });
    $this->app->bind('App\Contracts\TestContract',function(){
      return new TestService();
    });
  }
}

再然后需要到配置文件config/app.php中注册门面类别名：
'aliases' => [
  ...//其他门面类别名映射
  'TestClass' => App\Facades\TestClass::class,
],

最后修改TestController代码如下：
namespace App\Http\Controllers;
use Illuminate\Http\Request;
use App\Http\Requests;
use App\Http\Controllers\Controller;
use App;
use TestClass;
use App\Contracts\TestContract;
class TestController extends Controller {
  public function __construct(TestContract $test){
      $this->test = $test;
  }
  /**
    * Display a listing of the resource.
    * @return Response
    */
  public function index() {
    // $test = App::make('test');
    // $test->callMe('TestController');
    //$this->test->callMe('TestController');
​
    TestClass::doSomething();
  }
​
  ...//其他方法
}

不要忘了在调用门面类TestClass的文件顶部使用use TestClass;引入TestClass,否则将不能正确调用。
好了,我们可以去浏览器中测试了,访问http://laravel.app:8000/test,页面将会输出：
This is TestClass's method doSomething

</textarea>
</pre>

<h4>配置</h4><pre>
【 数组类型的环境变量 】
MY_ARRAY_VALUE=1,2,house,cat,34234  // .env设置
explode(',', env('MY_ARRAY_VALUE')); // 读取

SETTING={"KEY1":"VALUE1","KEY2":"VALUE2"}  // 多维数组使用JSON字串的方式进行设置
$mydata = (array)json_decode(env('SETTING'));

【 环境变量.env 】
一般Web商业项目有以下几个运行环境：我的开发环境、队友的开发环境、线上测试环境、生产环境

开发时会出现以下情况：
本地数据库的配置信息,很多时候与线上不一致,需要区分配置;
本地环境的站点URL的不一致,如生产环境是learnku.com,线上测试环境是staging.learnku.com,而本地是learnku.test;
因为本地与线上域名不同,GitHub登录申请的OAuth Key和Secret也会不同,这些需要分开配置;
开源项目一般代码里绝不存放第三方服务提供的Key和Secret,这些认证信息都必须区分环境进行配置,并且这些配置的信息都不需要放入版本控制器如Git中。
在新安装好的Laravel应用程序根目录会包含一个.env.example文件,如果是通过Composer安装的Laravel,该文件会自动复制副本.env,否则需要手动复制一份
$ cp .env.example .env

.env.example存储环境变量的KEY,此文件需要放置到Git里,应用程序不会读取此文件,此文件只做不同环境的信息传递,如果某个环境里新增环境变量KEY,可在Git修改日志里查看
.env存放着应用程序的环境变量,因此文件专属于不同环境,故不需要Git版本控制

【 获取设置配置 】
Laravel框架的所有配置文件都保存在config目录中

自定义配置文件config/social.php配置社交账号
return [
  'weixin' => 'https://weixin.com/qrcode.png',
  'weibo' => 'https://weibo.com/my_acount'
];
return [
  'weixin' => [
    'url' => 'https://weixin.com/qrcode.png',
    'username' => 'my_wexin_name'
  ],
  'weibo' => [
    'url' => 'https://weibo.com/my_acount',
    'username' => 'my_acount'
  ]
];

动态设置配置信息,在代码中修改配置的信息只会在运行时修改内存里的值,不会修改配置文件

方法一、 Config facade
Config::set('social.weibo.username', 'new_account');
Config::set([
  'social.weibo.username' => 'new_account',
  'social.weixin.username' => 'new_account',
]);

方法二、 config函数替代Config facade的调用(推荐)
config(['social.weibo.username' => 'new_account'])  // 第一个参数必须传参数组才能触发Config::set()
config([
  'social.weibo.username' => 'new_account',
  'social.weixin.username' => 'new_account',
]);

配置值的访问可使用点语法,如app.timezone访问config/app.php的timezone选项,还可以指定默认值,如果配置选项不存在则返回默认值
>>> echo Config::get('app.timezone');
>>> echo Config::get('app.inexistence', '默认值');
>>> config('view')  // 获取整个配置文件
>>> echo config('app.timezone');  // php artisan tinker
>>> echo config('app.inexistence', '默认值');
>>> config('none_file')  // null

【 设置环境变量 】
例如增加API前缀的设置API_PREFIX

第一步、在.env.example中新增
本地的.env是不在Gi版本库里的,如果直接添加API_PREFIX KEY,队友的环境里没有此KEY的,提交的代码有可能会在他们的环境里报错。
正确的做法是.env.exampl里新增所需要的键,并赋予一个空值或默认的值
API_PREFIX=api

第二步、在.env中新增
API_PREFIX=api

第三步、将KEY放置于配置信息里
不要直接在代码中直接使用环境变量,因为如果在部署过程中执行config:cache命令来缓存配置信息,那应该确保只从配置文件内部调用env函数。一旦配置被缓存,.env文件将不再被加载,所有对env函数的调用都将返回null
只从配置文件内部调用env函数是最佳实践,可以把环境变量的读取放置于任何配置文件中。此例中选择创建新的配置信息文件config/api.php ,此文件用来存放所有API相关的配置信息,env函数的第二个参数是默认值,假如其他环境没有配置API_PREFIX的话就会使用此默认值
return [ 'prefix' => env('API_PREFIX', 'api') ];

第四步、开始使用
接下来就可以放心地在程序中使用此配置信息：
>>> config('api.prefix');

【 获取环境变量,从.env里获取内容 】
env('APP_DEBUG')  // Laravel封装的辅助函数,env()函数是读取环境变量的辅助函数
getenv('APP_DEBUG')  // 第三方包phpdotenv自带的辅助函数
$_ENV['APP_DEBUG']   // 传统的PHP环境变量数组$_ENV
$_SERVER['APP_DEBUG'] // 服务器信息数组

.env设定的值	env()读取的值
true	(bool) true
(true)	(bool) true
false	(bool) false
(false)	(bool) false
empty	(string) ''
(empty)	(string) ''
null	(null) null
(null)	(null) null

使用正确的方式来设置环境变量,并使用config()来读取,确保只从配置文件内部调用env函数
如果在部署过程中执行config:cache命令来缓存配置信息,那应该确保只从配置文件内部调用env函数。一旦配置被缓存.env文件将不再被加载,所有对env函数的调用都将返回null
$ php artisan config:cache  // 缓存配置信息
$ php artisan config:clear  // 清除缓存

【 代码中判断当前环境 】
有几个环境：
local 本地环境
staging 线上测试环境
production 生产环境

>>> app()->isLocal()  // true

>>> app()->environment('local')  // true
>>> app()->environment(['local', 'staging'])  // true,environment()方法支持多个环境匹配
>>> app()->environment(['production', 'staging'])  // false

>>> app()->runningUnitTests()  // false, 判断是否在单元测试中

>>> app()->runningInConsole()  // 运行在命令行下
>>> strpos(php_sapi_name(), 'cli') !== false)  // 运行在命令行下,使用 PHP 原生的方法来检测

【 配置nginx 】
# 测试是否生效：
curl -H "Accept-Encoding: gzip" -I http://www.example.com

# 开启 Gzip 压缩
gzip on;
gzip_comp_level 6;
gzip_buffers 16 8k;
gzip_http_version 1.1;
gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript

server {
  listen 80;
  server_name example.com;
  root /example.com/public;

  add_header X-Frame-Options "SAMEORIGIN";
  add_header X-XSS-Protection "1; mode=block";
  add_header X-Content-Type-Options "nosniff";

  index index.html index.htm index.php;

  charset utf-8;

  location / {
      try_files $uri $uri/ /index.php?$query_string;
  }

  location = /favicon.ico { access_log off; log_not_found off; }
  location = /robots.txt  { access_log off; log_not_found off; }

  error_page 404 /index.php;

  location ~ \.php$ {
      fastcgi_split_path_info ^(.+\.php)(/.+)$;
      fastcgi_pass unix:/var/run/php/php7.1-fpm.sock;  # 127.0.0.1:9000;
      fastcgi_index index.php;
      fastcgi_param SCRIPT_FILENAME $realpath_root$fastcgi_script_name;
      include fastcgi_params;
  }

  location ~ /\.(?!well-known).* {
      deny all;
  }
}

【 PHP-fpm配置调优 】
php-fpm进程数调优
ps aux|grep php-fpm

进程数是由/etc/php/7.2/fpm/pool.d/www.conf指定的：
pm = dynamic：默认,子进程的数量是根据以下指令来动态生成的：pm.max_children, pm.start_servers, pm.min_spare_servers, pm.max_spare_servers.
pm = ondemand：在服务启动的时候根据 pm.start_servers 指令生成进程,而非动态生成。
pm = static：子进程的数量是由 pm.max_children 指令来确定的。
服务器内存小使用默认就好,大内存服务器则可以设置为pm = static,然后pm.max_children数量根据服务器的内存来决定,这样就可以最大化服务器负载能力

【 维护模式 】
当应用程序处于维护模式时,所有对应用程序的请求都显示为一个自定义视图,这样可以在更新或执行维护时轻松地关闭应用程序。维护模式检查包含在应用程序的默认中间件栈中,如果应用程序处于维护模式,则将抛出一个状态码为503的MaintenanceModeException异常
可以通过修改 resources/views/errors/503.blade.php 模板文件来自定义默认维护模式模板

php artisan down  // 启用维护模式
php artisan down --message="Upgrading Database" --retry=60  // message的值用于显示或记录自定义消息,retry值可用于设置HTTP请求头中Retry-After的值
php artisan down --allow=127.0.0.1 --allow=192.168.0.0/16   // 允许特定的IP地址或网络访问
php artisan up   // 关闭维护模式

当应用程序处于维护模式时,不会处理队列任务,而这些任务会在应用程序退出维护模式后再继续处理。

维护模式的替代方案
维护模式会导致应用程序有数秒的停机(不响应)时间,因此可以考虑使用像Envoyer的替代方案,以便与Laravel完成零停机时间部署

</pre>
</div>

<div id="route">
<h3>route</h3><pre>
【 路由动词 】
$uri = 'test'  // 和/test相同,只匹配 domain/test 和 domain/test/,其余返回404
Route::get($uri, $callback);
Route::post($uri, $callback);
Route::put($uri, $callback);
Route::patch($uri, $callback);
Route::delete($uri, $callback);
Route::options($uri, $callback);

Route::match(['get', 'post'], '/', function(){});  // 支持两种方法
Route::any('foo', function(){});  // 可以接收所有的方法

【 获取访问当前路由 】
http://localhost:8001/test

Route::get('test', function(){
  $route = Route::current();  // 访问处理传入请求的路由的信息
  $name = Route::currentRouteName();  // "test"
  $action = Route::currentRouteAction(); // null
  dump($route, $name, $action);
})->name('test');

检查当前路由
如果想要确定当前请求是否路由到给定的命名路由可以在路由实例上使用named方法
public function handle($request, Closure $next){  // Handle an incoming request
  if ($request->route()->named('profile')) { }    // 在路由中间件检查当前路由名称
  return $next($request);
}

【 路由参数约束 】
有时需要对URL参数做限定,约束参数的类型,以节省系统资源或其他目的
http://example.com/users/1
users后是用户ID,对应数据库中ID类型为自增整数,接受URL传参时可以限定为只通过数字类型的数据
当用户请求了不是数字类型的参数的URL的传参时直接就返回404错误,不会继续消耗系统资源,也使代码更加严谨

正则表达式约束
Route::get('user/{name}', function ($name) { })->where('name', '[A-Za-z]+');
Route::get('user/{id}', function ($id) { })->where('id', '[0-9]+');
Route::get('user/{id}/{name}', function ($id, $name) { })->where(['id' => '[0-9]+', 'name' => '[a-z]+']);

</pre>全局约束<textarea>
// app/Providers/RouteServiceProvider.php的boot方法中定义参数,一旦参数被定义,它将自动应用于所有使用该参数名称的路由
public function boot(){           // 定义路由模型绑定、路由全局约束等
  Route::pattern('id', '[0-9]+'); // 某个字串类型路由参数如id始终受给定正则表达式的约束
  parent::boot();
}
// routes/web.php
Route::get('user/{id}', function ($id) {
  // 仅当{id}为数字时执行…
});

</textarea><pre>
【 定义包含斜杆/的路由参数 】
https://packagist.org/packages/laravel/scout,让laravel/scout这个URI分段为参数
Route::get('packages/{slashName?}', 'PackagesController@show')->where('slashName', '(.*)');
public function show($slashName, Request $request){
  dd($slashName);  // "laravel/scout"
}

【 路由命名 】
在开发的过程中如果要对一个路由的URI进行修改。若没有对该路由进行命名,那么就要对整个项目遍历寻找该路由进行修改,一旦项目很大,修改工作将会非常繁琐。路由命名可以简化此工作,并且路由命名还能让特定路由方便地生成URL或重定向

Route::get('test', function(){ return route('test'); })->name('test'); // http://localhost:8001/test
Route::get('user/profile', function(){ return route('profile'); })->name('profile');
Route::get('user/profile', 'UserProfileController@show')->name('profile');  // 为控制器的方法指定路由名称,http://localhost:8001/test.index
Route::get('tests', 'TestsController@index')->name('tests.index');

【 通过全局route函数生成指向命名路由的URL 】
一旦为给定路由分配了名称,则在通过全局route函数生成URL或重定向时可以使用路由的名称：
$url = route('profile');   // 生成URL
return redirect()->route('profile');  // 重定向

如果命名路由定义了参数,则可以将参数作为第二个参数传递给route函数,给定的参数将自动插入到其正确位置的URL
Route::get('user/{id}/profile', function ($id) { })->name('profile');
$url = route('profile', ['id' => 1]);

【 路由名称前缀 】
Route::name方法可以用来给路由组中的每个路由名称添加一个给定的字符串,例如希望以admin为所有分组路由的名称加前缀,给定的字符串与指定的路由名称前缀完全相同,因此将确保在前缀中提供尾部的.字符

</pre><textarea>
Route::name('admin.')->group(function () {
  Route::get('tests', function () {
    dump(route('admin.tests'));  // http://localhost/tests
    dump(request()->fullUrl());  // http://localhost/tests
  })->name('tests');             // 指定路由名为 "admin.tests"
});

</textarea><pre>
【 resource路由命名 】
Route::resource('users', 'UsersController');
上面代码将等同于：
Route::get('/users', 'UsersController@index')->name('users.index');
Route::get('/users/{user}', 'UsersController@show')->name('users.show');
Route::get('/users/create', 'UsersController@create')->name('users.create');
Route::post('/users', 'UsersController@store')->name('users.store');
Route::get('/users/{user}/edit', 'UsersController@edit')->name('users.edit');
Route::patch('/users/{user}', 'UsersController@update')->name('users.update');
Route::delete('/users/{user}', 'UsersController@destroy')->name('users.destroy');

resource路由的命名
Route::resource('foo', 'ProductsController');
route('foo.index'); // http://your.website/foo

Route::resource('products', 'ProductsController',  ['names' => 'foo']);
route('foo.index'); // http://your.website/products

Route::resource('products', 'ProductsController',  ['names' => 'admin.products']);
route('admin.products.index'); // http://your.website/products

resource路由名称前缀：
Route::resource('products',  'ProductsController',  ['as'  =>  'admin']);
route('admin.products.index'); // http://your.website/products

资源路由批量命名
Route::resource('photos', 'PhotosController', ['names' => [
  'index'   => 'photos.index',
  'create'  => 'photos.create',
  'store'   => 'photos.store',
  'show'    => 'photos.show',
  'edit'    => 'photos.edit',
  'update'  => 'photos.update',
  'destroy' => 'photos.destroy'
]]);

【 路由分组 路由组 】
路由组可以给组内路由一次性增加 命名空间、uri前缀、域名限定、中间件等属性,并且可以多级嵌套

路由前缀
Route::prefix('admin')->group(function () {   // Route::prefix方法给组中的每个路由添加指定的URI前缀
  Route::get('users', function () {
    dump(request()->fullUrl());  // 匹配/admin/users URL
  });
});

子域名路由
Route::domain('{account}.myapp.com')->group(function () { // 域名可以像路由URI一样被分配路由参数,允许获取一部分子域名作为参数给路由或控制器使用
  Route::get('user/{id}', function ($account, $id) {
    dump(request()->fullUrl());
  });
});

使用路由组来将后台页面置于“需要登录才能访问”的中间件下,以保证安全
Route::group(['middleware' => 'auth', 'namespace' => 'Admin', 'prefix' => 'admin'], function() {
  Route::get('/', 'HomeController@index');
  Route::get('article', 'ArticleController@index');
  Route::resource('articles', 'ArticleController');  // 使用资源路由,article单数变成了复数
});

【 路由模型绑定 】
当向路由或控制器行为注入模型ID时就需要查询这个ID对应的模型。Laravel为路由模型绑定提供了一个直接自动将模型实例注入到路由中的方法。例如可以注入与给定ID匹配的整个User模型实例,而不是注入用户的ID

隐式绑定
Laravel会自动解析定义在路由或控制器行为中与类型提示的变量名匹配的路由段名称的Eloquent模型,如果在数据库中找不到对应的模型实例会自动生成404异常

// $user变量被类型提示为Eloquent模型App\User,变量名称又与URI中的{user}匹配,因此Laravel会自动注入与请求URI中传入的ID匹配的用户模型实例
Route::get('api/users/{user}', function (App\User $user) {  
  dump($user->email);
});

自定义键名
如果想要模型绑定在检索给定的模型类时使用除id之外的数据库字段,可以在Eloquent模型上重写getRouteKeyName方法
public function getRouteKeyName(){  // 获取该模型的路由的自定义键名
  return 'slug';
}

显式绑定
使用路由器的model方法来为给定参数指定类注册显式绑定,在RouteServiceProvider类中的boot方法内定义这些显式模型绑定

// 将所有{user}参数绑定至App\User模型,所以User实例将被注入该路由,例如profile/1的请求会注入数据库中ID为1的User实例,如果在数据库中找不到匹配的模型实例会自动抛出404异常
public function boot(){  
  parent::boot();
  Route::model('user', App\User::class);
}
Route::get('profile/{user}', function (App\User $user) {});  // 定义一个包含 {user} 参数的路由

自定义逻辑解析
如果想要使用自定义的解析逻辑就使用Route::bind方法,传递到bind方法的闭包会接受URI中大括号对应的值,并且返回想要在该路由中注入的类的实例：

public function boot(){
  parent::boot();
  Route::bind('user', function ($value) {
    return App\User::where('name', $value)->first() ?? abort(404);
  });
}

或者可以重写Eloquent模型上的resolveRouteBinding方法,此方法会接受URI中大括号对应的值,并返回想要在该路由中注入的类的实例：

// 检索绑定值的模型。@return \Illuminate\Database\Eloquent\Model|null
public function resolveRouteBinding($value){
  return $this->where('name', $value)->first() ?? abort(404);
}

【 访问控制(节流)】
throttle middleware用于控制应用程序对路由的访问,如果想要使用则将throttle中间件分配给一个路由或一个路由组。
throttle中间件接收两个参数决定了在给定的分钟数内可以进行的最大请求数

Route::middleware('auth:api', 'throttle:60,1')->group(function () {  // 指定一个经过身份验证并且用户每分钟访问频率不超过60次的路由组
  Route::get('/user', function () {
    dump(request()->fullUrl());
  });
});

动态访问控制
根据已验证的User模型的属性指定动态请求的最大值,如果User模型包含rate_limit属性则可以将属性名称传递给throttle中间件,以便它用于计算最大请求数

Route::middleware('auth:api', 'throttle:rate_limit,1')->group(function () {
  Route::get('/user', function () {
    dump(request()->fullUrl());
  });
});

【 伪造表单方法 】
HTML表单不支持PUT、PATCH或DELETE行为,所以要从HTML表单中调用定义了PUT、PATCH或DELETE行为的路由时将需要在表单中增加一个隐藏的_method输入标签,使用_method字段的值作为HTTP的请求方法,也可以使用@method模板指令生成_method输入

</pre><textarea>
< form action="/foo/bar" method="POST">
  < input type="hidden" name="_method" value="PUT">
  < input type="hidden" name="_token" value="{{ csrf_token() }}">

  @method('PUT')
  @csrf
< /form>

</textarea><pre>
【 路由缓存和清理 】
基于闭包的路由无法被缓存,要使用路由缓存则需要将代码从闭包转移到控制器类中,路由缓存会大大减少注册所有路由所需的时间,甚至能快上100倍
php artisan route:cache  // 生成路由缓存
运行此命令后,将在每个请求上加载缓存的路由文件
如果添加了任何新的路由,则需要重新生成新的路由缓存,因此应该在项目部署的时候运行route:cache命令。
php artisan route:clear // 清除路由缓存

</pre>
</div>

<div id="middleware">
<h4>middleware</h4><pre>
【 所有自带全局中间件 】
可通过app\Http\Kernel.php文件查看Laravel启用了哪些中间件,以\App\Http\Middleware\开头的中间件(位于app/Http/Middleware目录)是可以对其行为进行定制的中间件

1、Authenticate中间件 
用户身份验证,可修改redirectTo方法返回未经身份验证的用户应该重定向到的路径
用户认证只要在一个新的Laravel应用程序中运行php artisan make:auth和php artisan migrate就可以了,然后把浏览器导航到http://your-app.test/register或其他任意一个分配给程序的URL,这两个命令将负责构建整个认证系统

php artisan make:auth命令搭建认证所需的所有路由和视图,安装布局视图、注册和登录视图及所有身份验证端点的路由,还生成一个HomeController处理应用程序仪表板的登录后请求
如果应用程序不需要注册,可以通过删除新创建的RegisterController并修改路由声明来禁用它： Auth::routes(['register' => false]);
认证所需的所有视图放在resources/views/auth目录中,包含应用程序基本布局是resources/views/layouts目录,所有这些视图都使用了Bootstrap CSS框架,但可自由地定制

Laravel使得实现身份验证非常简单,几乎所有的配置都是现成的,许多应用程序永远不需要修改默认的身份验证配置,身份验证配置文件位于config/auth.php,在其核心,Laravel的认证设施由警卫和提供者组成,守卫决定如何对每个请求的用户进行身份验证,比如Laravel带有一个session保护,它使用会话存储和Cookies维护状态。提供者决定如何从持久储存中检索用户,Laravel支持使用Eloquent和数据库查询生成器检索用户,可自定义其他提供者

默认Laravel包含一个App\User Eloquent model在app目录下,这个模型可与默认的Eloquent身份验证驱动程序一起使用。如果应用程序没有使用Eloquent,可以用database身份验证驱动程序,它用的是Laravel查询生成器。当为App\User模型生成数据库架构时,确保密码的长度至少为60个字符,保持默认的字符串长度为255个字符是一个不错的选择。另外应该验证users表是否包含一个可空的含有100个字符的remember_token字符串,此列将用于存储用户登录应用程序时选择记住我选项的令牌

Laravel附带了几个预构建的身份验证控制器,位于App\Http\Controllers\Auth命名空间中。RegisterController处理新用户注册,LoginController处理身份验证,ForgotPasswordController处理用于重置密码的电子邮件链接,ResetPasswordController包含重置密码的逻辑。这些控制器中的每一个都使用一个特性来包含它们的必要方法
控制器已默认包含了验证用户是否存在和保存用户到数据库中的认证逻辑,通过traits实现的

laravel 5.2的Route::auth();包含哪些路由，在哪里可以看到
@see Illuminate\Routing\Router.php
public function auth(){
  // Authentication Routes...
  $this->get('login', 'Auth\AuthController@showLoginForm');
  $this->post('login', 'Auth\AuthController@login');
  $this->get('logout', 'Auth\AuthController@logout');

  // Registration Routes...
  $this->get('register', 'Auth\AuthController@showRegistrationForm');
  $this->post('register', 'Auth\AuthController@register');

  // Password Reset Routes...
  $this->get('password/reset/{token?}', 'Auth\PasswordController@showResetForm');
  $this->post('password/email', 'Auth\PasswordController@sendResetLinkEmail');
  $this->post('password/reset', 'Auth\PasswordController@reset');
}

自定义路径
当用户认证成功会被重定向到/home,可以在LoginController,RegisterController,ResetPasswordController,VerificationController控制器中定义redirectTo属性来自定义验证后的重定向位置：protected $redirectTo = '/';
接下修改RedirectIfAuthenticated中间件中的handle方法,以便在重定向用户时重定向到新的URI。
如果重定向路径需要自定义生成逻辑,可以定义redirectTo方法替代redirectTo属性,redirectTo方法优先于redirectTo属性
protected function redirectTo(){
  return '/path';
}

自定义用户名
Laravel默认使用email字段来认证,如果想使用其他的字段,可以定义一个LoginController@username方法：
public function username(){
  return 'username';
}

自定义用户认证和注册的看守器
在LoginController,RegisterController和ResetPasswordController中定义guard方法,该方法会返回一个看守器实例：
use Illuminate\Support\Facades\Auth;
protected function guard(){
  return Auth::guard('guard-name');
}

自定义验证/存储
为了修改新用户在注册时所需要填写的表单字段,或自定义如何将新用户存储到数据库中,可以修改RegisterController类,该类负责验证和创建新用户。其中validator方法包含了验证新用户的规则,create方法负责使用Eloquent ORM在数据库中创建新的App\User记录

检索已认证的用户
use Illuminate\Support\Facades\Auth;
$user = Auth::user();  // 获取当前通过认证的用户
$id = Auth::id();      // 获取当前通过认证的用户ID
或者可以通过Illuminate\Http\Request实例来访问已认证的用户,类型提示的类会被自动注入到控制器方法中：
namespace App\Http\Controllers;
use Illuminate\Http\Request;
class ProfileController extends Controller{
  public function update(Request $request){  // 更新用户资料,@param  Request  $request,@return Response
    // $request->user() 返回一个认证用户实例
  }
}

确定当前用户是否已经认证
use Illuminate\Support\Facades\Auth;
if (Auth::check()) {
  // 用户已经登录了...
}

保护路由
路由中间件可用于只允许通过认证的用户访问给定的路由,定义在Illuminate\Auth\Middleware\Authenticate中,已经在HTTP内核中注册,只需把这个中间件附加到路由定义中：
Route::get('profile', function () {
  // 只有认证过的用户可以进入
})->middleware('auth');
如果使用控制器,可以在控制器的构造函数中调用middleware方法来直接将其附加到路由定义中：
public function __construct(){
  $this->middleware('auth');
}

重定向未认证的用户
当auth中间件检测到一个未认证用户时会把用户重定向到名为login的命名路由上,可以通过修改app/Http/Middleware/Authenticate.php文件中的redirectTo函数来修改此行为：
protected function redirectTo($request){
  return route('login');
}

指定看守器
当把auth中间件添加到路由中时,同时也能指定使用哪个看守器进行用户认证,指定的看守器应该对应auth.php配置文件中guards数组中的的一个键：
public function __construct(){
  $this->middleware('auth:api');
}

登录限流
如果使用Laravel内置的LoginController类,Illuminate\Foundation\Auth\ThrottlesLogins trait已经包含在该控制器中了。默认用户多次尝试却无法提供正确的登录凭据,那么该用户在一分钟内将不能再次尝试登录,这种限流策略基于用户的用户名/邮箱地址及其IP地址的唯一性

手动验证用户
不一定非要在Lavarel中使用验证控制器,如果选择删除这些控制器就需要直接使用Lavarel验证类,可以借助Auth facade访问Laravel服务,因此需要在类的开头导入Auth

</pre><textarea>
namespace App\Http\Controllers;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Auth;
class LoginController extends Controller{
  // 处理身份验证尝试, @param  \Illuminate\Http\Request $request,@return Response
  public function authenticate(Request $request){
    $credentials = $request->only('email', 'password');
    if (Auth::attempt($credentials)) {  // 身份验证通过
      return redirect()->intended('dashboard');
    }
  }
}

</textarea><pre>
attempt方法的每个参数是一个关联数组,数组值用于在数据库中查找用户。上面的例子将通过email列的值查找用户。如果找到该用户将用存储在数据库中的哈希密码与数组中的password值做比较。不需要对password做哈希运算,框架在与数据库中的哈希密码做比较前自动对此值做哈希运算。如果两个哈希值匹配将为该用户建立验证通过的session
重定向中的intended方法将经由身份验证中间件将用户重定向到身份验证前截获的URL。如果预期目标不存在,可以为此方法指定一个回退URI

指定额外条件
除电子邮件和密码之外,还可以向身份验证查询添加其他条件
if (Auth::attempt(['email' => $email, 'password' => $password, 'active' => 1])) { /* 用户存在,已激活且未被禁用 */}

访问指定的看守器实例
可使用Auth:guard方法指定要使用的看守器实例,允许使用完全独立的可验证模型或用户表管理应用程序各个部分的验证,传递的看守器名称需与auth.php配置中的配置项之一相匹配：
if (Auth::guard('admin')->attempt($credentials)) { }

登出
Auth::logout();  // 清除用户会话(session)中的用户验证信息

记住用户
给attempt方法传递一个布尔值作为其第二个参数会无限期保持用户身份验证,直到用户手动登出,用户表需要包含字符串类型的remember_token列用于存储令牌。
if (Auth::attempt(['email' => $email, 'password' => $password], $remember)) { /* 用户被记住 */ }
如果使用了Laravel内置的LoginController,记住用户的正确逻辑已经由控制器所用的traits实现。
如果启用了记住用户,可以使用viaRemember方法判断是否使用了记住我cookie对用户做身份验证：
if (Auth::viaRemember()) { }

验证用户实例
如果要将已经存在的用户登入应用,可以调用login方法,并以用户实例作为其参数,该对象必须实现Illuminate\Contracts\Auth\Authenticatable契约。Laravel自带的App\User模型已经实现了这个接口：
Auth::login($user);
Auth::login($user, true);  // 登录并记住给定的用户
Auth::guard('admin')->login($user);  // 指定想要的看守器实例

通过ID验证用户身份
Auth::loginUsingId(1);
Auth::loginUsingId(1, true);  // 登录并记住给定用户

仅验证一次用户身份
if (Auth::once($credentials)) { }  // 在单次请求中将用户登录到应用中,这样做将不使用session或cookies,这意味着此方法有助于构建一个无状态API

HTTP基础认证
HTTP基础认证提供了一种快速方法来验证应用程序中的用户,而无需设置专用的登录页面。开始之前先把已包含在Laravel框架中的auth.basic中间件附加到路由中
将中间件附加到路由后,在浏览器中访问此路由时将自动提示输入凭据。默认的auth.basic中间件把用户记录上的email字段作用户名
Route::get('profile', function () {
  // 只有认证过的用户可以进入
})->middleware('auth.basic');

FastCGI的注意事项
如果正使用PHP FastCGI模式,HTTP基础认证可能无法正常工作,需要把下面几行添加到.htaccess文件中：
RewriteCond %{HTTP:Authorization} ^(.+)$
RewriteRule .* - [E=HTTP_AUTHORIZATION:%{HTTP:Authorization}]

无状态HTTP基础认证
也可以使用HTTP基础身份验证,而无需在会话中设置用户标识符cookie,这对API的身份验证特别有用。为此请定义一个中间件它将调用onceBasic方法。如果onceBasic方法没有返回任何响应,那么请求就可以进一步传递到应用程序中

</pre><textarea>
namespace App\Http\Middleware;
use Illuminate\Support\Facades\Auth;
class AuthenticateOnceWithBasicAuth{
  /**
    * 处理传入的请求
    * @param  \Illuminate\Http\Request  $request
    * @param  \Closure  $next
    * @return mixed
    */
  public function handle($request, $next){
    return Auth::onceBasic() ?: $next($request);
  }
}
接着注册路由中间件,并将它附加到路由：
Route::get('api/user', function () {
  // 只有认证过的用户可以进入...
})->middleware('auth.basic.once');

</textarea><pre>
退出
Illuminate\Support\Facades\Auth::logout();  手动把用户从应用中退出登录,清除用户会话中的身份认证信息

让其它设备上的用户Session失效和注销,而不会使其当前设备上的Session失效
首先保证Illuminate\Session\Middleware\AuthenticateSession::class中间件在app/Http/Kernel.php类中的web中间件组中,然后就可以使用Auth:logoutOtherDevices方法,此方法要求用户提供其当前密码,应用程序应通过输入表单接受该密码：
Illuminate\Support\Facades\Auth::logoutOtherDevices($password);
然后用户的其它Session将完全失效,这意味着他们将退出他们之前通过身份认证的所有看守器。

添加自定义的看守器
在Laravel自带的AuthServiceProvider服务提供器中调用Auth:extend方法来定义自己的身份验证看守器

</pre><textarea>
namespace App\Providers;
use App\Services\Auth\JwtGuard;
use Illuminate\Support\Facades\Auth;
use Illuminate\Foundation\Support\Providers\AuthServiceProvider as ServiceProvider;
class AuthServiceProvider extends ServiceProvider{
  public function boot(){       // 注册任意应用认证／授权服务
    $this->registerPolicies();
    Auth::extend('jwt', function ($app, $name, array $config) {
      return new JwtGuard(Auth::createUserProvider($config['provider']));  // 返回一个实现Illuminate\Contracts\Auth\Guard接口的实例
    });
  }
}

</textarea><pre>
Illuminate\Contracts\Auth\Guard接口包含了一些需要在自定义的看守器中实现的方法。当自定义看守器定义完成之后,可以在auth.php配置文件的guards配置中使用这个看守器：
'guards' => [ 'api' => [ 'driver' => 'jwt', 'provider' => 'users' ], ],

请求闭包看守器
实现基于HTTP请求的自定义身份验证系统的最简单方法是使用Auth::viaRequest方法,此方法允许使用单个闭包来快速定义身份验证过程。
首先在AuthServiceProvider的boot方法中调用Auth::viaRequest方法,接受一个看守器名称作为其第一个参数,此名称可以是描述自定义看守器的任何字符串,第二个参数应该是一个闭包函数,它接收传入的HTTP请求并返回一个用户实例,或者如果验证失败则为null

</pre><textarea>
use App\User;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Auth;
public function boot(){
  $this->registerPolicies();
  Auth::viaRequest('custom-token', function ($request) {
    return User::where('token', $request->token)->first();
  });
}
完成了自定义看守器后就可以在auth.php配置文件的guards配置中使用这个看守器：
'guards' => [ 'api' => [ 'driver' => 'custom-token', ], ],

</textarea><pre>
添加自定义用户提供器
如果不使用传统的关系数据库存储用户,就需要使用自己的身份验证用户提供器扩展Lavarel,可以使用Auth::provider方法自定义用户提供器

</pre><textarea>
namespace App\Providers;
use Illuminate\Support\Facades\Auth;
use App\Extensions\RiakUserProvider;
use Illuminate\Foundation\Support\Providers\AuthServiceProvider as ServiceProvider;
class AuthServiceProvider extends ServiceProvider{
  // 注册任意应用身份验证 / 授权服务Register any application authentication / authorization services
  public function boot(){
    $this->registerPolicies();
    Auth::provider('riak', function ($app, array $config) {
      return new RiakUserProvider($app->make('riak.connection'));  // 返回Illuminate\Contracts\Auth\UserProvider实例
    });
  }
}
一旦使用provider方法注册完毕就可以在auth.php配置文件中切换到新的用户提供器,先定义一个使用新驱动的provider
'providers' => [ 'users' => [ 'driver' => 'riak' ], ],
随后就可以在guards配置中使用这个提供器：
'guards' => [
  'web' => [ 'driver' => 'session', 'provider' => 'users', ], 
],

</textarea><pre>
用户提供器契约
Illuminate\Contracts\Auth\UserProvider实现仅负责从MySQL、Riak等持久化存储系统中提取Illuminate\Contracts\Auth\Authenticatable实现,无论用户如何存储及用于表示它的类是什么类型,这两个接口都允许Laravel身份验证机制继续运行：

</pre>\Contracts\Auth\UserProvider契约<textarea>
namespace Illuminate\Contracts\Auth;
interface UserProvider {
  public function retrieveById($identifier);  // 通常接受用于表示类的key(如MySQL中自动递增的ID)作为参数,并获取和返回与这个ID匹配的Authenticatable实现
  public function retrieveByToken($identifier, $token);  // 通过用户的唯一$identifier和存储在remember_token列的记住我令牌获取用户,返回Authenticatable实现
  public function updateRememberToken(Authenticatable $user, $token); // 用新$token更新$user的remember_token列,在记住我登录校验成功或用户登出时分配刷新令牌
  public function retrieveByCredentials(array $credentials);
  public function validateCredentials(Authenticatable $user, array $credentials);
}

</textarea><pre>
在尝试登录到应用时,retrieveByCredentials方法接受凭证数组传递给Auth::attempt方法,此方法在底层持久化存储中查询与这些凭证匹配的用户。通常此方法运行一个基于$credentials['username']的where条件,它应该返回一个Authenticatable实现,此方法不就尝试进行任何密码校验或身份验证。
validateCredentials方法应该比较给定的$user与$credentials验证用户身份,例如此方法或许应该使用Hash::check来比较$user->getAuthPassword()的值与$credentials['password']的值,应该返回true或false以表明用户密码是否有效。

身份验证Authenticatable契约,用户提供器的retrieveById、retrieveByToken和retrieveByCredentials方法将返回此接口的实例

</pre><textarea>
// 此接口允许身份验证系统与任一User类一直工作,不管使用的是哪种ORM或抽象存储层,默认Laravel的app目录会包含一个实现了此接口的User类,可以以这个实现示例作为参考
namespace Illuminate\Contracts\Auth;
interface Authenticatable {
  public function getAuthIdentifierName();  // 返回用户主键列的名字
  public function getAuthIdentifier();      // 返回用户主键,在MySQL后台它会是自增主键
  public function getAuthPassword();        // 返回用户的哈希密码
  public function getRememberToken();
  public function setRememberToken($value);
  public function getRememberTokenName();
}

</textarea><pre>
事件
在身份验证处理过程中Laravel引发了多种事件,可以在EventServiceProvider中附着这些事件的监听器

</pre><textarea>
// 应用的事件监听器映射
protected $listen = [
  'Illuminate\Auth\Events\Registered' => [ 'App\Listeners\LogRegisteredUser', ],
  'Illuminate\Auth\Events\Attempting' => [ 'App\Listeners\LogAuthenticationAttempt', ],
  'Illuminate\Auth\Events\Authenticated' => [ 'App\Listeners\LogAuthenticated', ],
  'Illuminate\Auth\Events\Login' => [ 'App\Listeners\LogSuccessfulLogin', ],
  'Illuminate\Auth\Events\Failed' => [ 'App\Listeners\LogFailedLogin', ],
  'Illuminate\Auth\Events\Logout' => [ 'App\Listeners\LogSuccessfulLogout', ],
  'Illuminate\Auth\Events\Lockout' => [ 'App\Listeners\LogLockout', ],
  'Illuminate\Auth\Events\PasswordReset' => [ 'App\Listeners\LogPasswordReset', ],
];

</textarea><pre>
2、CheckForMaintenanceMode中间件
app\Http\Middleware\CheckForMaintenanceMode.php
检测项目是否处于维护模式,可通过$except数组属性设置在维护模式下仍能访问的网址

3、EncryptCookies中间件
app\Http\Middleware\EncryptCookies.php
对 Cookie 进行加解密处理与验证,可通过$except数组属性设置不做加密处理的cookie

4、RedirectIfAuthenticated中间件
app\Http\Middleware\RedirectIfAuthenticated.php
当请求页是 注册、登录、忘记密码时检测用户是否已经登录,如果已经登录,那么就重定向到首页,如果没有就打开相应界面。可以在handle方法中定制重定向到的路径
默认Laravel生成的所有Cookie都是经过加密和签名,因此不能被客户端修改或读取。如果想要应用程序生成的部分Cookie不被加密,那么可以使用在app/Http/Middleware目录中App\Http\Middleware\EncryptCookies中间件的$except属性

5、TrimStrings中间件
app\Http\Middleware\TrimStrings.php
对请求参数内容进行前后空白字符清理。可通过$except数组属性设置不做处理的参数
默认Laravel在应用的全局中间件堆栈中包含了TrimStrings和ConvertEmptyStringsToNull中间件。这些中间件被放在App\Http\Kernel类的堆栈列表中。它们自动裁剪请求中的所有输入字符串域,同时将空字符串域转换为null,这样就不必担心路由和控制器中的标准化规约问题。
如果想要禁用这个行为,只需要通过从App\Http\Kernel类的$middleware属性中移除它(相当于从应用的中间件堆栈中移除)

6、TrustProxies中间件
app\Http\Middleware\TrustProxies.php
配置可信代理,可通过$proxies属性设置可信代理列表,$headers属性设置用来检测代理的HTTP头字段

7、VerifyCsrfToken中间件
app\Http\Middleware\VerifyCsrfToken.php
验证请求里的令牌是否与存储在会话中令牌匹配,可通过$except数组属性设置不做CSRF验证的网址
Laravel自动为每个活跃的用户的会话生成一个CSRF令牌,该令牌用于验证经过身份验证的用户是否是向应用程序发出请求的用户。
无论何时在应用程序中定义HTML表单时都应该在表单中包含一个隐藏的CSRF标记字段,以便CSRF保护中间件可以验证该请求,可以使用@csrf Blade指令来生成令牌字段
当构建由js驱动的应用时可以方便的让JavaScript HTTP函数库发起每一个请求时自动附上CSRF令牌。默认resources/js/bootstrap.js文件会用Axios HTTP函数库注册的csrf-token meta标签中的值。如果不使用这个函数库,需要手动为应用配置此行为

【 创建中间件 】
中间件提供了一种方便的机制过滤进入应用程序的HTTP请求例如,Laravel包含一个验证用户身份的中间件。如果用户未能通过认证,中间件会把用户重定向到登录页面,反之用户如果通过验证,中间件将把请求进一步转发到应用程序中。
除了验证身份外,还可以编写其他的中间件来执行各种任务,例如CORS保护中间件可以负责为所有的应用返回的responses添加合适的响应头。日志中间件可以记录所有传入应用的请求。

创建一个检测请求是否来自微信浏览器的CheckMicroMessenger中间件
$ php artisan make:middleware CheckMicroMessenger  // 在app\Http\Middleware目录中生成CheckMicroMessenger.php中间件类文件

创建的CheckMicroMessenger类包含的handle方法就是中间件逻辑代码的地方
检测发起请求的客户端的代理字符串,如果包含MicroMessenger则判定是微信浏览器,重定向请求至微信公众号关注页面,否则返回$next($request)将请求传递下去

</pre><textarea>
public function handle($request, Closure $next){   //  所有的中间件都是通过服务容器解析的,因此可以在你的中间件构造函数中键入需要的任何依赖
  $agent = $request->header('user-agent');
  if (preg_match('#MicroMessenger#i', $agent)) {
    return redirect('wechat');
  }
  return $next($request);
}

</textarea><pre>
前置 & 后置中间件
中间件可以在处理请求之前或之后执行,这取决于中间件的功能,前置中间件用于在处理请求之前执行某些任务

</pre><textarea>
// 创建前置中间件CheckMicroMessenger
namespace App\Http\Middleware;
use Closure;
class BeforeMiddleware {
  public function handle($request, Closure $next) {
    // 前置操作代码在这里
    return $next($request);
  }
}

// 后置中间件用于在处理请求之后执行某些任务
namespace App\Http\Middleware;
use Closure;
class AfterMiddleware{
  public function handle($request, Closure $next){
    $response = $next($request);
    // 后置操作代码在这里
    return $response;
  }
}

</textarea><pre>
注册中间件
中间件建好后需要对其进行注册才能使其起作用,因为希望CheckMicroMessenger在处理每个HTTP请求期间运行,所以需把其注册为全局中间件,修改app/Http/Kernel.php文件：

</pre><textarea>
namespace App\Http;
use Illuminate\Foundation\Http\Kernel as HttpKernel;
class Kernel extends HttpKernel {
  protected $middleware = [
    \App\Http\Middleware\CheckForMaintenanceMode::class,
    \Illuminate\Foundation\Http\Middleware\ValidatePostSize::class,
    \App\Http\Middleware\TrimStrings::class,
    \Illuminate\Foundation\Http\Middleware\ConvertEmptyStringsToNull::class,
    \App\Http\Middleware\TrustProxies::class,
    \App\Http\Middleware\CheckMicroMessenger::class,
  ];
}

</textarea><pre>
【 路由中间件 】
不注册全局中间件,只对某个路由注册中间件
在app/Http/Kernel.php内为该中间件分配一个键,默认该类的$routeMiddleware属性包含内置的中间件,只需把自定义的中间件附加到列表后并为其分配一个自定义键

</pre><textarea>
protected $routeMiddleware = [
  'auth' => \App\Http\Middleware\Authenticate::class,
  'auth.basic' => \Illuminate\Auth\Middleware\AuthenticateWithBasicAuth::class,
  'bindings' => \Illuminate\Routing\Middleware\SubstituteBindings::class,
  'cache.headers' => \Illuminate\Http\Middleware\SetCacheHeaders::class,
  'can' => \Illuminate\Auth\Middleware\Authorize::class,
  'guest' => \App\Http\Middleware\RedirectIfAuthenticated::class,
  'signed' => \Illuminate\Routing\Middleware\ValidateSignature::class,
  'throttle' => \Illuminate\Routing\Middleware\ThrottleRequests::class,
  'verified' => \Illuminate\Auth\Middleware\EnsureEmailIsVerified::class,
  'my' => \App\Http\Middleware\MyMiddleware::class,
];

注册好后就可以通过middleware方法为路由分配中间件：
Route::get('my/profile', function () { })->middleware('my');
Route::get('/', function () { })->middleware('first', 'second');  // 为路由分配多个中间件
use App\Http\Middleware\MyMiddleware;
Route::get('my/profile', function () { })->middleware(MyMiddleware::class);  // 分配中间件时,还可以传递完整的类名

route的group使用多个中间件摆放顺序有时不能颠倒
Route::group([ 'middleware' => ['cors', 'auth:api-jwt', 'auth.permission'] ], function () { })
cors 前后端分离,如果出现在auth后面,一旦出现异常将会出现跨域现象。
auth:jwt 判断用户的token是否合法,从中可以注入当前用户Auth::user()
auth:permission 权限判断,依赖前面的Auth::user()

</textarea><pre>
【 中间件群组 】
支持把多个中间件打包成一组,方便将它们批量应用到路由中去
Laravel内置了开箱即用的web和api中间件组,其中包含可能希望应用于Web页面和API路由的常用中间件
只需在app\Http\Kernel.php文件的$middlewareGroups属性中使用一个键把多个中间件组合在一起即可
RouteServiceProvider默认将web中间件组自动应用到routes/web.php

</pre><textarea>
protected $middlewareGroups = [
  'web' => [
    \App\Http\Middleware\EncryptCookies::class,
    \Illuminate\Cookie\Middleware\AddQueuedCookiesToResponse::class,
    \Illuminate\Session\Middleware\StartSession::class,
    // \Illuminate\Session\Middleware\AuthenticateSession::class,
    \Illuminate\View\Middleware\ShareErrorsFromSession::class,
    \App\Http\Middleware\VerifyCsrfToken::class,
    \Illuminate\Routing\Middleware\SubstituteBindings::class,
  ],

  'api' => [
    'throttle:60,1',
    'bindings',
  ],
];

</textarea><pre>
中间件组定义好后可以采用与单个中间件相同的语法分配给路由和控制器操作,中间件组使得一次将多个中间件分配给一个路由组也变得更加方便：
Route::get('/', function(){})->middleware('web');
Route::group(['middleware' => ['web']], function(){});
Route::middleware(['web', 'subscribed'])->group(function(){ });

【 中间件参数 】
中间件可以接收附加的参数,这里的参数不是指用户输入的参数,而是在定义路由分配中间件时通常由开发人员指定的附加参数,这样中间件就可能通过附加参数的不同执行不同的逻辑。
比如如果应用程序需要在执行给定操作之前验证用户是否为给定的角色,可以创建一个CheckRole中间件,由它来接收角色名称作为附加参数。

</pre><textarea>
namespace App\Http\Middleware;
use Closure;
class CheckRole {
  public function handle($request, Closure $next, $role){  // 参数可以设定默认值
    if (! $request->user()->hasRole($role)) {
      // Redirect
    }
    return $next($request);
  }
}

</textarea><pre>
然后在定义路由时通过 : 来隔开中间件键名和附加的中间件参数值,用逗号分隔附加多个参数
Route::put('post/{id}', function ($id) { })->middleware('role:editor');

【 Terminable中间件 】
有时可能需要在HTTP响应之后做一些工作,如果在中间件上定义了一个terminate方法,并且使用的是FastCGI,那么terminate方法会在响应发送到浏览器之后自动调用。

</pre><textarea>
namespace Illuminate\Session\Middleware;
use Closure;
class StartSession {
  public function handle($request, Closure $next){
    return $next($request);
  }
  public function terminate($request, $response){  // 同时接收请求和响应
    // 存储session数据
  }
}

</textarea><pre>
定义了这个中间件之后将它添加到路由列表或app/Http/Kernel.php文件的全局中间件中。
在中间件上调用terminate方法时Laravel将从服务容器中解析出一个新的中间件实例。如果在调用handle和terminate方法的同时使用相同的中间件实例,请使用容器的singleton方法注册中间件,通常这应该在AppServiceProvider.php文件中的register方法中完成:

use App\Http\Middleware\TerminableMiddleware;
public function register() {  // 注册任意应用服务
  $this->app->singleton(TerminableMiddleware::class);
}

</pre>
</div>

<div id="controller">
<h3>conteoller</h3><pre>
为了替代在路由文件中以闭包形式定义的所有的请求处理逻辑,可能想要使用控制类来组织这些行为。控制器能将相关的请求处理逻辑组成一个单独的类,控制器被存放在app/Http/Controllers目录

控制器并不是必需继承基类控制器,如果控制器没有继承基础类将无法使用一些便捷的功能,如middleware, validate和dispatch方法,middleware方法可以为控制器行为添加中间件
在定义控制器路由时我们不需要指定完整的控制器命名空间,因为RouteServiceProvider会在一个包含命名空间的路由组中加载路由文件,只需要指令类名中App\Http\Controllers 命名空间之后的部分就可以了

</pre><textarea>
// 当一个请求与指定路由的URI匹配时,UserController控制器中的show方法将会执行,路由参数也将会被传递给该方法
Route::get('user/{id}', 'UserController@show');

namespace App\Http\Controllers;
use App\Http\Controllers\Controller;
use App\User;
class UserController extends Controller {
  /**
    * 显示指定用户的简介.
    * @param  int  $id
    * @return View
    */
  public function show($id) {
    return view('user.profile', ['user' => User::findOrFail($id)]);
  }
}

</textarea><pre>
【 单行为控制器 】
如果想要定义一个只处理单个行为的控制器,可以在控制器中放置一个__invoke方法,当注册单个行为控制器的路由时不需要指明方法

</pre><textarea>
Route::get('user/{id}', 'ShowProfile');

namespace App\Http\Controllers;
use App\Http\Controllers\Controller;
use App\User;
class ShowProfile extends Controller{
  public function __invoke($id){
    return view('user.profile', ['user' => User::findOrFail($id)]);
  }
}

</textarea><pre>
可以通过Artisan命令工具里的make:controller命令中的--invokable选项来生成一个可调用的控制器：
php artisan make:controller ShowProfile --invokable

可以使用Stub定制自定义控制器模板

【 控制器中使用中间件 】
中间件可以在路由文件中分配给控制器的路由：
Route::get('profile', 'UserController@show')->middleware('auth');

Laravel可以在控制器的构造函数中通过middleware方法将中间件分配给控制器的操作,而且还可进一步细分,将中间件限制仅用于控制器类上的某些方法。,这比在路由文件中分配中间件给控制器路由方便得多

</pre><textarea>
class UserController extends Controller {
  /**
    * Instantiate a new controller instance.
    * @return void
    */
  public function __construct() {
    $this->middleware('auth');                         // 将中间件应用于整个控制器
    $this->middleware('log')->only('index');           // 将中间件仅应用于控制器的 index 方法
    $this->middleware('subscribed')->except('store');  // 将中间件 subscribed 应用于控制器中除 store 之外的所有方法
    $this->middleware(function ($request, $next) {     // 支持以闭包形式来注册中间件
      // ...
      return $next($request);
    });
  }
}

</textarea><pre>
【 修改资源路由动作名称 】
Laravel的资源路由通过单行代码即可将典型的CURD(增删改查)路由分配给控制器

$ php artisan make:controller PhotoController --resource  // 生成控制器app/Http/Controllers/PhotoController.php,其中包括每个可用资源操作的方法
Route::resource('photos', 'PhotoController');

HTTP 方法	URI	动作	路由名称
GET	/photos	index	photos.index
GET	/photos/create	create	photos.create
POST	/photos	store	photos.store
GET	/photos/{photo}	show	photos.show
GET	/photos/{photo}/edit	edit	photos.edit
PUT/PATCH	/photos/{photo}	update	photos.update
DELETE	/photos/{photo}	destroy	photos.destroy

一次性的创建多个资源控制器
Route::resources([
  'photos' => 'PhotoController',
  'posts' => 'PostController'
]);

指定资源模型
如果使用了路由模型绑定,并且想在资源控制器的方法中使用类型提示,可以在生成控制器的时候使用--model选项
php artisan make:controller PhotoController --resource --model=Photo

部分资源路由
当声明资源路由时可以指定控制器处理的部分行为,而不是所有默认的行为：
Route::resource('photos', 'PhotoController')->only([ 'index', 'show' ]);
Route::resource('photos', 'PhotoController')->except([ 'create', 'store', 'update', 'destroy' ]);

API资源路由
当声明用于APIs的资源路由时通常需要排除显示HTML模板的路由如create和edit。为了方便起见可以使用apiResource方法自动排除这两个路由：
Route::apiResource('photos', 'PhotoController');
Route::apiResources([ 'photos' => 'PhotoController', 'posts' => 'PostController' ]);  // 传递一个数组给apiResources方法来同时注册多个API资源控制器
php artisan make:controller API/PhotoController --api  // 快速生成不包含create或edit方法的用于开发接口的资源控制器使用--api参数

嵌套资源
有时可能需要定义一个嵌套的资源型路由,例如照片资源可能被添加了多个评论,那么可以在路由中使用点”符号来声明资源型控制器：
Route::resource('photos.comments', 'PhotoCommentController');  // 注册一个嵌套资源,可以使用/photos/{photo}/comments/{comment}的URI访问

浅层嵌套
通常并不完全需要在URI中同时拥有父ID和子ID,因为子ID已经是唯一的标识符。当使用唯一标识符如自动递增的主键来标识URI中的模型时可以选择使用浅嵌套”的方式定义路由：
Route::resource('photos.comments', 'CommentController')->shallow();
HTTP 方式	URI	行为	路由名称
GET	/photos/{photo}/comments	index	photos.comments.index
GET	/photos/{photo}/comments/create	create	photos.comments.create
POST	/photos/{photo}/comments	store	photos.comments.store
GET	/comments/{comment}	show	comments.show
GET	/comments/{comment}/edit	edit	comments.edit
PUT/PATCH	/comments/{comment}	update	comments.update
DELETE	/comments/{comment}	destroy	comments.destroy

命名资源路由
默认所有的资源控制器行为都有一个路由名称,可以传入names数组来覆盖这些名称：
Route::resource('photos', 'PhotoController')->names([ 'create' => 'photos.build' ]);

命名资源路由参数
默认Route::resource会根据资源名称的单数形式创建资源路由的路由参数,可以在选项数组中传入parameters参数来轻松地覆盖每个资源。parameters数组应该是资源名称和参数名称的关联数组：
Route::resource('users', 'AdminUserController')->parameters([ 'users' => 'admin_user' ]); // 为资源的show路由生成/users/{admin_user}的URI

自定义资源URIs
默认Route::resource将会用英文动词创建资源URI。如果需要自定义create和edit行为的动作名可以在AppServiceProvider的boot中使用Route::resourceVerbs方法实现:
use Illuminate\Support\Facades\Route;
public function boot(){
  Route::resourceVerbs([ 'create' => 'crear', 'edit' => 'editar', ]);
}
动作被自定义后,像Route::resource('fotos', 'PhotoController') 这样注册的资源路由将会产生如下的 URI：
/fotos/crear
/fotos/{foto}/editar

补充资源控制器
如果想在默认的资源路由中增加额外的路由,应该在Route::resource之前定义这些路由,否则由resource方法定义的路由可能会无意中优先于补充的路由：
Route::get('photos/popular', 'PhotoController@method');
Route::resource('photos', 'PhotoController');
记住保持控制器的专一性。如果需要典型的资源操作之外的方法,可以考虑将控制器分成两个更小的控制器

如果想将create动作对应的默认路由名称photos.create修改为photos.build,可以链式调用name方法来修改,支持批量修改
Route::resource('photos', 'PhotoController')->name('create', 'photos.build');
Route::resource('photos', 'PhotoController')->names([ 'show' => 'photos.display', 'store' => 'photos.save', ]);

这时如果调用 route('photos.build') 全局辅助函数可以发现新的路由名称已经生效了。

路由采用 resource 方法,在控制器中使用 FormRequest 进行数据校验时,需要注意路径参数不是 id ,而是对应的路由名称单数,如下

// 更新相片时路由是`/photos/{photo}`,可以通过下面方式获取括号里面的路径参数值 
$this->route('photo')

当自己命名不符合英文单复数规范时,上述原则可能不适用,你也许始终找得不到正确的参数值,此时可以通过命令行查看路由的列表的 URI 列中的路径参数名称。
php artisan route:list

【 依赖注入 & 控制器 】
构造函数注入
Laravel使用服务容器来解析所有的控制器,因此可以在控制器的构造函数中使用类型提示需要的依赖项,而声明的依赖项会自动解析并注入控制器实例中：

</pre><textarea>
namespace App\Http\Controllers;
use App\Repositories\UserRepository;
class UserController extends Controller{
  protected $users;  // 用户 repository 实例
  public function __construct(UserRepository $users){
    $this->users = $users;
  }
}

</textarea><pre>
方法注入
还可以在控制器方法中类型提示依赖项,最常见的用法就是将 Illuminate\Http\Request 实例注入到控制器方法中：

</pre><textarea>
namespace App\Http\Controllers;
use Illuminate\Http\Request;
class UserController extends Controller{
  public function store(Request $request){
    $name = $request->name;
  }
}

如果控制器方法需要从路由参数中获取输入内容,只需要在其他依赖项后列出路由参数即可
namespace App\Http\Controllers;
use Illuminate\Http\Request;
class UserController extends Controller {
  public function update(Request $request, $id){
    //
  }
}

</textarea><pre>
【 路由缓存 】
基于闭包的路由不能被缓存。如果要使用路由缓存,必须将所有的闭包路由转换成控制器类路由。
如果应用只使用了基于控制器的路由,那么你应该充分利用Laravel的路由缓存。使用路由缓存将极大地减少注册所有应用路由所需的时间。某些情况下,路由注册的速度甚至可以快一百倍。要生成路由缓存,只需执行 Artisan 命令 route:cache :
php artisan route:cache
运行这个命令之后,每一次请求的时候都将会加载缓存的路由文件。如果你添加了新的路由,你需要生成一个新的路由缓存。因此,你应该只在生产环境运行 route:cache 命令：
可以使用route:clear命令清除路由缓存：
php artisan route:clear

</pre>
</div>

<div id="request">
<h4>request</h4><pre>
【 获取请求对象、请求参数 】
可以通过依赖注入的方式来获取当前的HTTP请求对象,在控制器的方法中注入Illuminate\Http\Request类,传入的请求会自动由服务容器注入

</pre><textarea>
Route::get('test', function(Illuminate\Http\Request $request){
  dump($request->fullUrl());
  return view('test.child');
})->name('test');

</textarea><textarea>
namespace App\Http\Controllers;
use Illuminate\Http\Request;
class UserController extends Controller {
  /**
    * 创建一个新用户
    * @param  Request  $request
    * @return Response
    */
  public function store(Request $request) {
    $request = request();                      // 使用request()辅助函数获取当前请求对象
    
    if ($request->has('name')) { }             // 判断是否存在输入值, /test, /test/name=tom&email=, /test/name=tom&email=
    if ($request->has(['name', 'email'])) { }  // 判断数组中指定的参数在请求中是否全部存在
    if ($request->filled('name')) { }          // 判断一个参数在请求中是否存在,并且不为空
    
    // input方法从整个请求中获取输入数据,包括查询字符串
    $input = $request->all();                   // 以数组形式获取到所有输入数据
    $name = $request->input('name');            // 获取指定输入值,无论是什么样的HTTP动作input方法都可以被用来获取用户输入数据
    $name = $request->input('name', 'Sally');   // 指定默认值
    $name = $request->input('user.name');       // 点语法获取JSON输入信息JSON数组,只要请求的Content-Type标头设置为application/json就可通过Input方法访问JSON数据
    $name = $request->input('products.0.name'); // 传输表单数据中包含数组形式的数据可以使用点语法来获取数组
    $names = $request->input('products.*.name');

    // query方法只从查询字符串中获取输入数据
    $query = $request->query();
    $name = $request->query('name');
    $name = $request->query('name', 'Helen');

    // 通过动态属性获取输入,Laravel在处理动态属性的优先级是,先在请求的数据中查找,没有再到路由参数中查找
    $name = $request->name;  // 通过$request实例的动态属性来获取用户输入,访问表单中包含name字段的值

    // 获取部分输入数据,获取输入数据的子集,only和except方法都接收数组或动态列表作为参数
    $input = $request->only(['username', 'password']);
    $input = $request->only('username', 'password');
    $input = $request->except(['credit_card']);
    $input = $request->except('credit_card');
    
    // 获取上一次请求的输入数据,从会话(session)中拉取之前传输的值,常用于登录表单在出错情况下恢复原数据
    $username = $request->old('username');
    // 在Blade模板中显示旧数据,old辅助函数会更方便,如果给定字段的旧值不存在将返回null
    < input type="text" name="username" value="{{ old('username') }}">

    // 获取请求路径
    $uri = $request->path();          // 获取http://domain.com/foo/bar请求中的foo/bar
    if($request->is('admin/*')) { }   // 验证传入的请求路径是否与给定的模式匹配,*字符作为通配符

    // 获取请求的完整URL
    $url = $request->url();          // url方法返回不含有查询字符串的URL,获取http://domain.com/foo/bar?name=tom中的"http://localhost:8001/test/haha"
    $fullUrl = $request->fullUrl();  // fullUrl获取包含查询字符串的URL,获取http://domain.com/foo/bar?name=tom整个URL包括后面的参数

    // 获取请求方法
    $method = $request->method();    // 总是大写
    $isPost = $request->isMethod('post');

    // 获取请求的标头信息,请求标头中不包含指定项则返回null,标头项名大小写不敏感
    $referer = $request->header('Referer');
    $userAgent = $request->header('User-Agent');
    $acceptLanguage = $request->header('Accept-Language');
  }
}

// http://localhost:8001/test/haha
Route::get('test/{name}', function(Illuminate\Http\Request $request, $name){
  dump(
    $request->all(),          // []
    $request->input('name'),  // null
    $request->query('name'),  // null
    $name,                    // "haha"
    $request->name            // "haha"
  );
  return view('test.child');
})->name('test');

</textarea><pre>
【 获取解析后的路由参数 】
在控制器方法的参数列表中把路由参数放在其他依赖注入项之后依次列出即可在控制器中获取路由参数
Route::put('photos/{id}', 'PhotoController@update');
public function update(Request $request, $id){ }

路由闭包中使用路由参数
Route::get('/test/{name}/{id}', function (Illuminate\Http\Request $request, $name, $id) {
  return ['name' => $name, 'id' => $id];
});

【 判断是否是Ajax请求 】
ajax()是判断X-Requested-With标头,而wantsJson()是判断Accept标头里是否存在json,而expectsJson()是两种情况去除掉Pjax请求

request()->ajax() ? return '来自AJAX请求' : return '正常访问';
request()->expectsJson() ? return '来自AJAX请求' : return '正常访问';

// 判断客户端是否期待返回JSON数据 - 源码
public function expectsJson(){
  return ($this->ajax() && ! $this->pjax()) || $this->wantsJson();
}

// 判断客户端是否请求返回JSON格式的数据 - 源码
public function wantsJson(){
  $acceptable = $this->getAcceptableContentTypes();
  return isset($acceptable[0]) && Str::contains($acceptable[0], ['/json', '+json']);
}

// 判断客服端是否使用Pjax - 源码
public function pjax(){
  return $this->headers->get('X-PJAX') == true;
}

// 判断是否Ajax请求 - 源码
public function ajax(){
  return $this->isXmlHttpRequest();
}

// 判断Header信息里`X-Requested-With`存在,并等于`XMLHttpRequest` - 源码
public function isXmlHttpRequest(){
  return 'XMLHttpRequest' == $this->headers->get('X-Requested-With');
}

【 表单验证 】
Laravel提供几种不同的方法验证传入应用程序的数据,默认Laravel的控制器基类使用ValidatesRequests trait,它提供了一种方便的方法去使用各种强大的验证规则来验证传入的HTTP请求

</pre><textarea>
public function create(){
  return view('post.create');
}

public function store(Request $request) {
  $validatedData = $request->validate([          // 如果验证失败会自动生成一个对应的响应,验证通过控制器将会继续正常运行
    'title' => 'required|unique:posts|max:255',  // 验证规则,规则会按照分配的顺序来验证
    'body' => 'required',

    'title' => ['required', 'unique:posts', 'max:255'],
    'body' => ['required'],

    'title' => 'bail|required|unique:posts|max:255',     // 附加bail规则到该属性时某个属性第一次验证失败后停止运行验证规则
    'publish_at' => 'nullable|date',                     // 可选字段,指定publish_at字段可以为null或一个有效的日期格式

    'author.name' => 'required',                         // HTTP请求包含一个嵌套参数即数组
    'author.description' => 'required', 
  ]);

  $validatedData = $request->validateWithBag('post', [   // 验证请求,并将任何错误消息存储在一个命名错误包中
    'title' => ['required', 'unique:posts', 'max:255'],
    'body' => ['required'],
  ]);
  
  // 博客文章验证通过
}

</textarea><pre>
显示验证错误信息
如果传入的请求参数未通过给定的验证规则,Laravel会自动把用户重定向到之前的位置,所有的验证错误信息会被自动存储到session
不必在GET路由中将错误消息显式绑定到视图,因为Lavarel会检查在Session数据中的错误信息,并自动将其绑定到存在的视图,其中的变量$errors是Illuminate\Support\MessageBag 的一个实例
$errors变量被web中间件组提供的Illuminate\View\Middleware\ShareErrorsFromSession中间件绑定到视图中。 当这个中间件被应用后,在视图中就可以获取到$errors变量,可以使一直假定$errors变量存在并且可以安全地使用

</pre><textarea>
/resources/views/post/create.blade.php
@if ($errors->any())
  <div class="alert alert-danger">
    <ul>
      @foreach ($errors->all() as $error)
        <li>{{ $error }}</li>
      @endforeach
    </ul>
  </div>
@endif

</textarea><pre>
@error 指令
还可以使用@error Blade模板指令快速检查给定属性是否存在验证错误消息,在@error指令中可以输出$message变量以显示错误消息

</pre><textarea>
/resources/views/post/create.blade.php
<label for="title">Post Title</label>
<input id="title" type="text" class="@error('title') is-invalid @enderror">
@error('title')
  <div class="alert alert-danger">{{ $message }}</div>
@enderror

</textarea><pre>
AJAX请求与验证
对AJAX的请求中使用validate方法时,Laravel并不会生成一个重定向响应,而是会生成一个包含所有验证错误信息的JSON响应,这个JSON响应会包含一个HTTP状态码422被发送出去。

【 表单请求验证类 】
php artisan make:request StoreBlogPost  // 创建表单请求类,新生成的类保存在app/Http/Requests目录

</pre><textarea>
class StoreBlogPost extends Illuminate\Foundation\Http\FormRequest {
  // 获取应用于请求的验证规则,添加一些验证规则到rules方法,可以向rules方法传入所需的任何依赖项,他们会自动被Laravel提供的服务容器自动解析
  public function rules() {
    return [
      'title' => 'required|unique:posts|max:255',
      'body' => 'required',
    ];
  }

  public function messages() {   // 自定义错误消息,此方法应返回属性 / 规则对及其对应错误消息的数组
    return [
      'title.required' => 'A title is required',
      'body.required'  => 'A message is required',
    ];
  }

  public function attributes() {             // 自定义验证属性,将验证消息的:attribute部分替换为自定义属性名称
    return ['email' => 'email address'];
  }

  // 表单请求授权验证,authorize方法中可以检查经过身份验证的用户确定其是否具有更新给定资源的权限,比方说可以判断用户是否拥有更新文章评论请求的权限：
  // 由于所有的表单请求都是继承了Laravel中的请求基类,所以可以使用user方法去获取当前认证登录的用户,调用route方法允许在被调用的路由上获取其定义的URI参数,如Route::post('comment/{comment}')中的{comment}参数
  // 如果authorize方法返回false则会自动返回一个包含403状态码的HTTP响应,也不会运行控制器的方法。
  // 如果打算在应用程序的其它部分处理授权逻辑,只需从authorize方法返回true
  // 判断用户是否有请求权限,可以向authorize方法传入所需的任何依赖项,他们会自动被Laravel提供的服务容器自动解析
  public function authorize() {
    $comment = Comment::find($this->route('comment'));
    return $comment && $this->user()->can('update', $comment);
  }

  protected function prepareForValidation() {   // 在应用验证规则之前清除请求中的任何数据
    $this->merge([ 'slug' => Illuminate\Support\Str::slug($this->slug), ]);
  }

  /**
  * 配置验证实例
  * 添加表单请求后钩子,withValidator方法接收一个完整的验证构造器,允许在验证结果返回之前调用任何方法
  * @param  \Illuminate\Validation\Validator  $validator
  * @return void
  */
  public function withValidator($validator) {
    $validator->after(function ($validator) {
      if ($this->somethingElseIsInvalid()) {
        $validator->errors()->add('field', 'Something is wrong with this field!');
      }
    });
  }

}

</textarea><pre>
存储传入的博客文章,在控制器方法中类型提示传入的请求,在调用控制器方法之前验证传入的表单请求,这意味着不需要在控制器中写任何验证逻辑
如果验证失败就会生成一个让用户返回到先前的位置的重定向响应,这些错误也会被闪存到session中,以便这些错误都可以在页面中显示出来。如果传入的请求是AJAX,会向用户返回具有422状态代码和验证错误信息的JSON数据的HTTP响应

public function store(StoreBlogPost $request) {
   // 传入的请求通过验证
   // 获取通过验证的数据
   $validated = $request->validated();
}

【 手动创建验证器 】
如果不想在请求上使用validate方法,可以通过Validator facade上的make方法手动创建一个验证器示例
如果验证失败可以使用withErrors方法把错误消息闪存到Session,使用这个方法进行重定向后$errors变量会自动和视图共享,withErrors方法接收验证器、MessageBag或Array

</pre><textarea>
namespace App\Http\Controllers;
use App\Http\Controllers\Controller;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Validator;
class PostController extends Controller {
  public function store(Request $request) {
    // 自定义错误消息,占位符
    $messages = [
      'required' => 'The :attribute field is required.',        // :attribute占位符会被验证字段的实际名称替换
      'same'    => 'The :attribute and :other must match.',
      'size'    => 'The :attribute must be exactly :size.',
      'between' => 'The :attribute value :input is not between :min - :max.',
      'in'      => 'The :attribute must be one of the following types: :values',

      'email.required' => 'We need to know your e-mail address!',  // 为给定属性指定自定义信息
    ];

    $validator = Validator::make($request->all(), [
      'title' => 'required|unique:posts|max:255',
      'body' => 'required',
    ], $messages);    // 自定义错误消息参数$messages可选

    if ($validator->fails()) {
      return redirect('post/create')->withErrors($validator)->withInput();
    }

    // Store the blog post...
  }

  // 在验证器实例上调用validate方法,如果验证失败用户将会自动重定向,在AJAX请求中则会返回JSON格式的响应
  public function store(Request $request) {
    Validator::make($request->all(), [
      'title' => 'required|unique:posts|max:255',
      'body' => 'required',
    ])->validate();
  }

  // 如果验证失败可以使用validateWithBag方法将错误消息存储在命名错误包中
  public function store(Request $request) {
    Validator::make($request->all(), [
      'title' => 'required|unique:posts|max:255',
      'body' => 'required',
    ])->validateWithBag('post');
  }

  // 验证后钩子,验证器还允许附加回调并在验证完成后执行,以便进行下一步的验证,甚至在消息集合中添加更多的错误消息,使用它只需在验证实例上使用after方法
  public function store(Request $request) {
    $validator = Validator::make(...);
    $validator->after(function ($validator) {
      if ($this->somethingElseIsInvalid()) {
        $validator->errors()->add('field', 'Something is wrong with this field!');
      }
    });
    if ($validator->fails()) {
      //
    }
  }
}

</textarea><pre>
命名错误包
如果一个页面中有多个表单,可以通过命名包来检索特定表单的错误消息,只需在控制器方法中给withErrors方法传递一个名字作为第二个参数:
return redirect('register')->withErrors($validator, 'login');
然后就可以从$errors变量中获取指定表单的错误消息：
{{ $errors->login->first('email') }}

处理错误消息
通过Validator实例调用errors方法返回Illuminate\Support\MessageBag实例,它拥有各种方法处理错误信息。自动提供给所有视图的$errors变量,也是MessageBag类的一个实例
$errors = $validator->errors();
echo $errors->first('email');                     // 查看特定字段的第一个错误信息
foreach ($errors->get('email') as $message) { }   // 查看特定字段的所有错误消息数组
foreach ($errors->get('attachments.*') as $message) { }  // 验证表单的数组字段可以使用 * 来获取每个数组元素的所有错误消息
foreach ($errors->all() as $message) { }          // 查看所有字段的所有错误消息
if ($errors->has('email')) { }                    // 判断特定字段是否含有错误消息

在PHP文件中指定自定义信息
大多数情况下可能会在文件中指定自定义信息,而不是直接将它们传递给Validator,为此需要把信息放置于resources/lang/xx/validation.php语言文件内的custom数组中
'custom' => [
    'email' => [
        'required' => 'We need to know your e-mail address!',
    ],
],

在PHP文件中指定自定义属性
如果希望将验证信息的:attribute部分替换为自定义属性名称,可以在resources/lang/xx/validation.php语言文件的attributes数组中指定自定义名称：
'attributes' => [
    'email' => 'email address',
],

在PHP文件中指定自定义值
有时可能需要将验证信息的:value替换为自定义的表示形式,例如指定payment_type的值为cc ：
$request->validate([
    'credit_card_number' => 'required_if:payment_type,cc'  // 此规则失败将生成错误信息：The credit card number field is required when payment type is cc.
]);

可以通过在validation语言文件中定义values数组指定自定义值表示形式,而不是将cc显示为 payment_type 的值：
'values' => [
    'payment_type' => [
        'cc' => 'credit card'
    ],
],
如果验证失败,将生成以下信息：The credit card number field is required when payment type is credit card

验证规则
1、accepted - 验证字段必须是yes、on、1或true,这在确认服务条款是否同意时相当有用
2、after:date - 验证字段必须是给定日期之后的值,日期值将传递到PHP函数strtotime
'start_date' => 'required|date|after:tomorrow'
可以指定另一个要与日期进行比较的字段,而不是传递要由strtotime处理的日期字符串:
'finish_date' => 'required|date|after:start_date'
3、after_or_equal:date - 验证字段必须是在给定日期之后或与此日期相同的值
4、alpha - 验证字段必须完全由字母构成
5、alpha_dash - 验证字段可能包含字母、数字及破折号 (-) 和下划线 ( _ )
6、alpha_num - 验证字段必须是完全是字母、数字
7、array - 验证的字段必须是一个 PHP 数组
8、bail - 在第一次验证失败后停止运行验证规则
9、before:date - 正在验证的字段必须是给定日期之前的值。这个日期将传递到 PHP 的 strtotime 函数中。此外,与 after 规则一样,另一个正在验证的字段可以作为 date 的值。
10、before_or_equal:date - 验证字段必须是在给定日期之前或与之相同的日期。这个日期值将会被传递给 PHP 的 strtotime 函数来计算
11、between:min,max - 验证字段的大小必须在给定的 min 和 max 之间。字符串、数字、数组和文件的计算方式都使用 size 方法
12、boolean - 验证的字段必须可以转换为 Boolean 类型。 可接受的输入为 true , false , 1 , 0 , "1" 和 "0"
13、confirmed - 验证字段必须具有匹配字段 foo_confirmation 。例如,验证字段为 password ,输入中必须存在与之匹配的 password_confirmation 字段。
14、date - 根据 PHP strtotime 函数,验证的字段必须是有效的日期
15、date_equals:date - 验证字段必须等于给定日期。日期将传递到 PHP strtotime 函数。
16、date_format:format - 验证字段必须匹配给定的日期格式。当验证某个字段时应该只使用date或date_format,而不是同时使用。此验证规则支持PHP所有的DateTime类
17、different:field - 验证的字段值必须与字段 field 的值不同
18、digits:value - 验证的字段必须为 numeric ,并且必须具有确切长度 value。
19、digits_between:min,max - 验证字段的长度必须在给定的 min 和 max 之间。
20、dimensions - 验证的文件必须是图片并且图片比例必须符合规则：
'avatar' => 'dimensions:min_width=100,min_height=200'
可用的规则为: min_width , max_width , min_height , max_height , width , height , ratio 。
ratio约束应该表示为宽度除以高度,这可以通过像3/2这样的语句或像1.5这样的float指定：
'avatar' => 'dimensions:ratio=3/2'
由于此规则需要多个参数,因此可以Rule::dimensions方法来构造可读性高的规则：
use Illuminate\Validation\Rule;
Validator::make($data, [
  'avatar' => [
    'required',
    Rule::dimensions()->maxWidth(1000)->maxHeight(500)->ratio(3 / 2),
  ],
]);
21、distinct - 验证数组时指定的字段不能有任何重复值。'foo.*.id' => 'distinct'
22、email - 验证的字段必须符合e-mail地址格式
23、ends_with:foo,bar,… - 验证的字段必须以给定的值之一结尾。
24、exclude_if:anotherfield,value - 如果_anotherfield_字段等于_value_,验证下的字段将被 validate 和 validated 方法返回的请求数据排除。
25、exclude_unless:anotherfield,value - 验证下的字段将被 validate 和 validated 方法返回的请求数据排除,除非 anotherfield 的字段等于 value 
26、exists:table,column - 验证的字段必须存在于给定的数据库表中。
'state' => 'exists:states'
'state' => 'exists:states,abbreviation'
'email' => 'exists:connection.staff,email'
'user_id' => 'exists:App\User,id'
// 自定义验证规则执行的查询可以使用Rule类来定义规则
use Illuminate\Validation\Rule;
Validator::make($data, [
  'email' => [
    'required',
    Rule::exists('staff')->where(function ($query) {
        $query->where('account_id', 1);
    }),
  ],
]);
27、file - 验证的字段必须是成功上传的文件。
28、filled - 验证的字段在存在时不能为空。
29、gt:field - 验证字段必须大于给定的 _field_。两个字段必须是相同的类型。字符串、数字、数组和文件都使用 size 进行相同的评估。
30、gte:field - 验证字段必须大于或等于给定的 field 。两个字段必须是相同的类型。字符串、数字、数组和文件都使用 size 进行相同的评估。
31、image - 验证的文件必须是图片 (jpeg, png, bmp, gif, svg, or webp)
32、in:foo,bar,… - 验证字段必须包含在给定的值列表中
33、in_array:anotherfield.* - 验证的字段必须存在于另一个字段 anotherfield 的值中。
34、integer - 验证的字段必须是整数。不是验证数据是 「integer」 类型,仅验证字符串或数值包含一个「integer
35、ip - 验证的字段必须是 IP 地址。
36、ipv4 - 验证的字段必须是 IPv4 地址。
37、ipv6 - 验证的字段必须是 IPv6 地址。
38、json - 验证的字段必须是有效的 JSON 字符串。
39、lt:field - 验证的字段必须小于给定的字段。这两个字段必须是相同的类型。字符串、数值、数组和文件大小的计算方式与size方法进行评估。
40、lte:field - 验证中的字段必须小于或等于给定的 字段 。这两个字段必须是相同的类型。字符串、数值、数组和文件大小的计算方式与size方法进行评估。
41、max:value - 验证中的字段必须小于或等于value。字符串、数字、数组或是文件大小的计算方式都用size规则。
42、mimetypes:text/plain,… - 验证的文件必须具备与列出的其中一个扩展相匹配的 MIME 类型：
'video' => 'mimetypes:video/avi,video/mpeg,video/quicktime'
为了确定上传文件的 MIME,框架将会读取文件,然后自动推测文件MIME类型,这可能与客户端提供的MIME类型不一致 。
43、mimes:foo,bar,… - 验证的文件必须具有与列出的其中一个扩展名相对应的MIME类型。'photo' => 'mimes:jpeg,bmp,png'
即使你可能只需要验证指定扩展名,但此规则实际上会去验证文件的 MIME 类型,其通过读取文件内容来推测它的 MIME 类型。
44、min:value - 验证字段必须具有最小值。 字符串,数值,数组,文件大小的计算方式都与 size 规则一致
45、not_in:foo,bar,… - 验证字段不能包含在给定的值的列表中
46、not_regex:pattern - 验证字段必须与给定的正则表达式不匹配。'email' => 'not_regex:/^.+$/i'
47、nullable - 验证字段可以为 null。这在验证基本数据类型时特别有用,例如可以包含空值的字符串和整数。
48、numeric - 验证字段必须为数值。
49、password - 验证字段必须与当前登录用户的密码相同,可以通过传入第一个参数来指定身份验证看守器。'password' => 'password:api'
50、present - 验证字段必须存在于输入数据中,但可以为空。
51、regex:pattern - 验证字段必须与给定的正则表达式匹配,'email' => 'not_regex:/^.+$/i'
52、required - 验证的字段必须存在于输入数据中,null、空字符串、空数组或空Countable对象、无路径的上传文件。
53、required_if:anotherfield,value,… - 如果其它字段_anotherfield_为任一值_value1_或_value2_等则此验证字段必须存在且不为空
54、required_unless:anotherfield,value,… - 如果其它字段_anotherfield_不等于任一值_value_则此验证字段必须存在且不为空。
55、required_with:foo,bar,… - 在其他任一指定字段出现时,验证的字段才必须存在且不为空。
56、required_with_all:foo,bar,… - 只有在其他指定字段全部出现时,验证的字段才必须存在且不为空。
57、required_without:foo,bar,… - 在其他指定任一字段不出现时,验证的字段才必须存在且不为空。
58、required_without_all:foo,bar,… - 只有在其他指定字段全部不出现时,验证的字段才必须存在且不为空。
59、same:field - 验证字段的值必须与给定字段的值相同。
60、size:value - 验证字段必须与给定值的大小一致。对于字符串value对应字符数,数字value对应给定的整数值,数组size对应数组的count值,文件size对应文件大小kB
'title' => 'size:12';  // 验证字符串长度是否为12
'seats' => 'integer|size:10';  // 验证数字是否为10
'tags' => 'array|size:5';  // 验证数组的长度（拥有的元素）是否为5
'image' => 'file|size:512';  // 验证上传的文件是否为512kB
61、starts_with:foo,bar,… - 验证字段必须以给定值之一开头。
62、string - 验证字段必须是一个字符串。如果允许这个字段为null,需要给这个字段分配nullable规则。
63、timezone - 验证字段必须为符合PHP函数timezone_identifiers_list所定义的有效时区标识。
64、unique:table,column,except,idColumn - 验证字段在给定的数据库表中必须是唯一的。
65、url - 验证的字段必须是有效的URL。
66、uuid - 验证字段必须是有效的RFC 4122通用唯一标识符UUID
67、sometimes - 要验证的字段存在于输入数组中时才对该字段执行验证,'email' => 'sometimes|required|email',

【 cookie 】
设置cookie
Route::get('hello', function () {
  return response('Hello World', 200)->header('Content-Type', 'text/plain')->withCookie('name', 'value', 10);
  $cookie = cookie('name', 'value', 10);
  return response('Hello World', 200)->header('Content-Type', 'text/plain')->withCookie($cookie);
});

Cookie::queue(\Cookie::forget('name'));    // 使用Cookie门面的queue方法,中间件会自动将队列中的cookie在内容输出至浏览器之前附加到响应中

获取Cookie
Lavarel框架生成的cookies都是加密的,并用授权码签名,可防止客户端非法篡改,所以在Laravel应用中不要直接用$_COOKIE来操作cookie
public function index(Request $request){
  $value = Cookie::get('name');
  $value = request()->cookie('name');
  return $request->cookie('laravel_session');
}

删除Cookie
public function index(Request $request){   // 首先通过Cookie::forget得到一个过期的cookie对象,然后将其附加到响应中,使之立即过期失效
  $cookie = Cookie::forget('name');  
  return response('view')->withCookie($cookie);
}

未加密的Cookie
修改app/Http/Middleware/中App\Http\Middleware\EncryptCookies中间件的$except属性,把不需加密的cookie名加入到该数组属性中就可以了：
protected $except = [ 'cookie_name', ];

【 session 】
Session的配置文件config/session.php,默认Laravel为绝大多数应用程序配置的Session驱动为file,生产环境中使用memcached或redis驱动让Session的性能更加出色

Session driver配置预设了每个请求存储Session数据的位置,Laravel自带了几个不错而且开箱即用的驱动：
file - Session存储在storage/framework/sessions
cookie - Sessions被存储在安全加密的cookie
database - Sessions被存储在关系型数据库中
memcached/redis - Sessions被存储在基于高速缓存的存储系统中,通过Composer安装predis/predis扩展包
array - Sessions存储在PHP数组中,但不会被持久化。数组驱动一般用于测试并且防止存储在Session中的数据被持久化

</pre>使用database作为Session驱动时需要创建一张包含Session各项数据的表<textarea>
Schema::create('sessions', function ($table) {
  $table->string('id')->unique();
  $table->unsignedInteger('user_id')->nullable();
  $table->string('ip_address', 45)->nullable();
  $table->text('user_agent')->nullable();
  $table->text('payload');
  $table->integer('last_activity');
});
php artisan session:table  生成此迁移
php artisan migrate

</textarea>处理Session数据有两种主要方法：全局辅助函数session和通过一个Request实例<textarea>
public function show(Request $request, $id){
  $value = $request->session()->get('key');
  $value = $request->session()->get('key', 'default');
  $value = $request->session()->get('key', function () {
    return 'default';
  });

  $data = $request->session()->all();
  if ($request->session()->has('users')) { }              // 该值存在且不为null则返回true
  if ($request->session()->exists('users')) { }           // 其值可以为null

  $request->session()->put('key', 'value');               // 存储数据
  $request->session()->push('user.teams', 'developers');  // 在Session数组中保存数据
  $value = $request->session()->pull('key', 'default');   // 从Session中检索并删除一条数据

  $request->session()->flash('status', 'Task was successful!');  // 闪存数据主要用于短期的状态消息,只会保留到下一个HTTP请求到来之前,然后就会被删除
  $request->session()->reflash();                          // 在更多的请求中使用到该一次性数据,该方法会将所有一次性请求保留到下一次请求
  $request->session()->keep(['username', 'email']);        // 保存一次性数据

  $request->session()->forget('key');                      // 删除单个值
  $request->session()->forget(['key1', 'key2']);           // 删除多个值
  $request->session()->flush();                            // 删除所有数据

  // 如果使用了内置函数LoginController,Laravel会自动重新生成身份认证中的Session ID,否则需手动使用regenerate方法重新生成Session ID
  $request->session()->regenerate();  // 重新生成session ID,通常是为了防止恶意用户利用session fixation对应用进行攻击
}

Route::get('home', function () {
  $value = session('key');             // 获取session中的一条数据
  $value = session('key', 'default');  // 指定一个默认值
  session(['key' => 'value']);         // 在Session中存储一条数据
});

</textarea>
</div>

<div id="response">
<h3>response</h3><pre>
【 生成url 】
Laravel提供了几个辅助函数来为应用程序生成URL,主要用于在模板和API响应中构建URL或在应用程序的其它部分生成重定向响应

1、辅助函数url可以用于应用的任何一个URL,生成的URL将自动使用当前请求中的方案(HTTP or HTTPS)和主机：
$post = App\Post::find(1);
echo url("/posts/{$post->id}");  // http://example.com/posts/1

访问当前URL
如果没有给辅助函数url提供路径则会返回一个Illuminate\Routing\UrlGenerator实例允许访问有关当前URL的信息
echo url()->current();  // Get the current URL without the query string
echo url()->full();     // Get the current URL including the query string
echo url()->previous(); // Get the full URL for the previous request
echo Illuminate\Support\Facades\URL::current();

2、控制器行为的URL
action功能可以为给定的控制器行为生成URL,这个功能不需要传递控制器的完整命名空间,但需要传递相对于命名空间App\Http\Controllers的控制器类名：
$url = action('HomeController@index');
$url = action('UserController@profile', ['id' => 1]);  // 控制器方法需要路由参数,那就将它们作为第二个参数传递给action函数
use App\Http\Controllers\HomeController;  
$url = action([HomeController::class, 'index']);

3、命名路由的URL
辅助函数route可以用于为指定命名的路由生成URL,命名路由生成的URL不与路由上定义的URL相耦合,因此就算路由的URL有任何改变都不需要对route函数调用进行任何更改
Route::get('/post/{post}', function(){})->name('post.show');
echo route('post.show', ['post' => 1]);     // http://example.com/post/1
echo route('post.show', ['post' => $post]); // 通常使用Eloquent模型的主键生成URL,因此可将Eloquent模型作为参数值传递,route辅助函数将自动提取模型的主键
Route::get('/post/{post}/comment/{comment}', function () {})->name('comment.show');  // 辅助函数route也可用于为具有多个参数的路由生成URL
echo route('comment.show', ['post' => 1, 'comment' => 3]);  // http://example.com/post/1/comment/3

默认值
对于某些应用程序,可能希望为某些URL参数的请求范围指定默认值
Route::get('/{locale}/posts', function(){})->name('post.index');
每次都通过locale来调用辅助函数route也是一件很麻烦的事情,因此使用URL::defaults方法定义这个参数的默认值,可以让该参数始终存在当前请求中,然后就能从路由中间件调用此方法来访问当前请求：
namespace App\Http\Middleware;
use Closure;
use Illuminate\Support\Facades\URL;
class SetDefaultLocaleForUrls{
  public function handle($request, Closure $next){
    URL::defaults(['locale' => $request->user()->locale]);
    return $next($request);
  }
}
一旦设置了locale参数的默认值就不再需要通过辅助函数route生成URL时传递它的值下

4、签名URL
Laravel允许为命名路由创建签名URL,这些URL在查询字符串后附加了签名哈希,验证URL自创建以来未被修改过,对于可公开访问但需要一层防止URL操作的路由特别有用,例如可以使用签名URL来实现通过电子邮件发送给客户的公共取消订阅链接。要创建指向路径的签名URL使用URL facade的signedRoute方法：
use Illuminate\Support\Facades\URL;
return URL::signedRoute('unsubscribe', ['user' => 1]);
return URL::temporarySignedRoute('unsubscribe', now()->addMinutes(30), ['user' => 1] );  // 生成具有有效期的临时签名路由URL

验证签名路由请求
要验证传入请求是否具有有效签名,应该对传入的Request调用hasValidSignature方法,如果传入请求没有有效签名则中间件将自动返回403错误响应
use Illuminate\Http\Request;
Route::get('/unsubscribe/{user}', function (Request $request) {
  if (! $request->hasValidSignature()) abort(401);
})->name('unsubscribe');
或者可以将Illuminate\Routing\Middleware\ValidateSignature中间件分配给路由,它不存在则应在HTTP内核routeMiddleware数组中为此中间件分配一个键,然后将其附加到路由中
protected $routeMiddleware = [ 'signed' => \Illuminate\Routing\Middleware\ValidateSignature::class, ];
Route::post('/unsubscribe/{user}', function (Request $request) { })->name('unsubscribe')->middleware('signed');

【 在控制器或路由中返回HTML内容的响应 】
最基本的响应就是从路由或控制器返回一个简单的字符串,框架会自动将这个字符串转化为Content-Type为text/html的完整的HTTP响应
Route::get('/', function () {
  return 'Hello World';
});

把HTML视图作为响应内容返回,这时可以使用全局辅助函数view即可,其第一个参数接受的是视图文件名
Route::get('/', function () {
  return view('welcome');
});

控制HTTP状态码和头信息可调用响应的view和header方法：
Route::get('/hello', function () {
  return response()->view('hello', ['text' => 'world'], 200)->header('Content-Type', 'text/html; charset=UTF-8');
});

【 返回JSON 】
JSON是Js原生格式,在Js中处理JSON数据不需要任何特殊的API或工具包
json()将Content-Type头设置为application/json,同时利用PHP内置函数json_encode把数组转成JSON格式,使用json()的好处是可自定义更多的响应信息,如状态码、头信息等
return response()->json([ 'name' => 'Abigail', 'state' => 'CA' ]);

源码
public static function json($data = array(), $status = 200, $headers = array(), $options = 0){
  return \Illuminate\Routing\ResponseFactory::json($data, $status, $headers, $options);
}

在控制器或闭包路由里,如果返回数组或模型或集合的话,Laravel会自动识别并自动转为json响应Content-Type: application/json
Route::get('/request-json-array', function(){
  $array = array('foo', 'bar');
  return $array;       // 返回的就是json响应
  return User::all();  // 返回模型/集合,User是eloquent模型
});

【 永远返回JSON响应 】
在编写API服务应用时所有响应都是JSON格式的,例如授权错误不会重定向到/home或/login,最终重定向会变成InvalidArgumentException: Route [login] is not defined.的视图。
下面这个简单的方案可以让Laravel应用优先响应为JSON格式,所有的响应都是application/json,包括错误和异常

</pre><textarea>
第一步、构建app/Http/Requests/BaseRequest.php来重写Illuminate\Http\Request,修改为默认优先使用JSON响应：
namespace App\Http\Requests;
use Illuminate\Http\Request;
class BaseRequest extends Request{
  public function expectsJson(){
    return true;
  }
  public function wantsJson(){
    return true;
  }
}

第二步、在public/index.php文件中将\Illumiate\Http\Request替换为BaseRequest
$response = $kernel->handle(
  $request = \App\Http\Requests\BaseRequest::capture()
);

</textarea>方法二<textarea>
第一步、创建app/Http/Middleware/JsonMiddleware.php
namespace App\Http\Middleware;
use Closure;
use Illuminate\Http\Request;
class JsonMiddleware{
  public function handle(Request $request, Closure $next) {
    $request->headers->set('Accept', 'application/json');
    return $next($request);
  }
}
第二步、app/Http/Kernel.php添加全局中间件
namespace App\Http;
use Illuminate\Foundation\Http\Kernel as HttpKernel;
class Kernel extends HttpKernel{
  protected $middleware = [
    \Illuminate\Foundation\Http\Middleware\CheckForMaintenanceMode::class,
    \App\Http\Middleware\JsonMiddleware::class,
  ];
}

</textarea><pre>
【 返回xml 】
Route::get('/xml', function () {
  $xml = new SimpleXMLElement('< ?xml version="1.0" encoding="UTF-8" ?>< websites>< /websites>');
  $website = $xml->addChild('website');
  $website->addChild('url', 'https://learnku.com');
  $website->addChild('desc', 'LearnKu 是终身学习者的编程知识社区');
  $content = $xml->asXML();
  return response($content)->header('Content-Type', 'text/xml');
});

视图文件xml.blade.php文件内容如下：
< ?xml version="1.0" encoding="UTF-8" ?>
< websites>
    < website>
        < url>https://learnku.com< /url>
        < desc>LearnKu 是终身学习者的编程知识社区< /desc>        
    < /website>
< /websites>
Route::get('/xml', function () {
  return response()->view('xml')->header('Content-Type', 'text/xml');
});

【 返回JSONP 】
前端页面http://a.com/1.html中的js向服务器http://b.com/2.php获取数据,如果用普通的AJAX方式就会被浏览器认为是跨域不安全而拦截
为了让所有浏览器都能够跨域名调用逐渐形成了一种非正式传输协议JSONP(JSON with Padding)
JSONP的实现原理就是利用script标签没有同源限制的特点,也就是script的src链接可以访问不同的域名。

访问服务端一般是存取JSON数据,而JSONP则返回包含函数的数据,将需要的JSON数据作为函数的参数。
客户端通过script标签的src访问带有callback查询参数的请求来获取返回带有函数的数据,然后浏览器执行带有服务器返回数据作为参数的callback函数
const jsonpCallback => serverData => console.log(serverData)
script src="http://localhost:3000/user?callback=jsonpCallback"  // 跨域请求数据,预期返回jsonpCallback函数
jsonpCallback({ "name": "xuthus" })                             // 服务器返回的内容,返回后就会执行这个这个函数就可以得到想要的JSON数据
  
Laravel将JSONP封装得极具简单,只需将json方法与withCallback方法结合就可以实现
return response()->json(['name' => 'Abigail', 'state' => 'CA'])->withCallback($request->input('callback')); 
输出jsonpCallback({ "name": "Abigail", "state": "CA" })

【 返回PDF (文件响应) 】
实现直接在用户浏览器显示一个图片或PDF之类的文件,而不是下载,这样做可以利用Chrome等现代浏览器上的PDF阅读功能直接阅读
Route::get('/pdf', function () {
  $fullPath = base_path().DIRECTORY_SEPARATOR.'ebook'.DIRECTORY_SEPARATOR.'doc.pdf';
  return response()->file($fullPath);
  return response()->file($pathToFile, $headers);
});

【 返回图片流 】
不想让用户知道图片的真实URL,在响应中返回图片流,即返回的不是一个浏览器可直接下载的图片文件URL,而是图片文件的字节流

Route::get('/pic', function () {
  $fullPath = base_path().DIRECTORY_SEPARATOR.'pic'.DIRECTORY_SEPARATOR.'demo.jpg';
  return response()->stream(function () use ($fullPath) {
    echo file_get_contents($fullPath);
  }, 200, ['Content-Type' => 'image/jpeg']);  // Content-Type设置不正确则浏览器显示的会是乱码
});

【 流式下载 】
流式下载即将某操作返回的字符串内容响应直接转换为下载响应,而不需要先保存至磁盘中
streamDownload方法可实现流式下载,这个方法接受回调及可选的文件名、头信息数组、disposition方式作为参数
要实现流式下载,在调用这个方法时必须指定第二个文件名参数,否则内容会直接显示在浏览器中,而不是下载

Route::get('/stream', function () {
  return response()->streamDownload(function () {
    echo file_get_contents("https://github.com/laravel/laravel/blob/master/readme.md");
  }, 'laravel-readme.md');
});

源码
public function streamDownload($callback, $name = null, array $headers = [], $disposition = 'attachment') {
  $response = new StreamedResponse($callback, 200, $headers);
  if (! is_null($name)) {
    $response->headers->set('Content-Disposition', $response->headers->makeDisposition( $disposition, $name, $this->fallbackName($name)));
  }
  return $response;
}

【 返回文件下载 】
用户点击页面上的按钮,即可将文件下载文件到本地,download()方法原理是生成一个下载的响应,访问这个路由时自动下载,php需开启扩展extension=php_fileinfo.dll

Route::get('/download', function() {
  $file= public_path(). "/download/info.pdf";  //PDF file is stored under project/public/download/info.pdf
  return response()->download($file, 'filename.pdf', [ 'Content-Type: application/pdf']);  // 第二个参数指定下载后的文件名(可选)
});

【 增加头信息 】
return response($content)->header('Content-Type', $type)->header('X-Header-One', 'Header Value')->header('X-Header-Two', 'Header Value');
return response($content)->withHeaders(['Content-Type' => $type, 'X-Header-One' => 'Header Value', 'X-Header-Two' => 'Header Value', ]);

【 重定向 】
301 永久重定向(Permanently Moved),网页更改地址后对搜索引擎友好的最好方法,只要不是暂时搬移的情况都建议使用301来做转址
302 暂时重定向(Temporarily Moved)

重定向响应是Illuminate\Http\RedirectResponse类的实例,并且包含用户需要重定向至另一个URL所需的头信息

在闭包路由、控制器方法或者中间件使用全局辅助函数redirect
Route::get('dashboard', function () {
  return redirect('home/dashboard'); 
  return redirect($url, 301); 
});

源码
function redirect($to = null, $status = 302, $headers = [], $secure = null){
  if (is_null($to)) return app('redirect');
  return app('redirect')->to($to, $status, $headers, $secure);
}

【 重定向跳回上一次的请求 】
当用户提交的表单无效时,响应将用户重定向回先前的位置
back()生成返回用户之前位置的重定向HTTP响应,并可以链式调用withInput、withErrors等方法带上输入值、错误提示信息等
由于重定向回先前的位置利用了HTTP会话机制,因此须确保调用back函数或方法的路由使用web中间件组或所有Session中间件

Route::post('user/profile', function () {
  return back()->withInput();           // 全局辅助函数back
  return Redirect::back()->withInput(); // Redirect门面的back()方法
});

源码
function back($status = 302, $headers = [], $fallback = false){
  return app('redirect')->back($status, $headers, $fallback);   // 只是简单地调用Redirector类的back方法
}

【 重定向到命名路由 】
不带参数调用全局辅助函数redirect时返回Illuminate\Routing\Redirector实例,这个实例允许调用Redirector上的任何方法
return redirect()->route('profile');
return redirect()->route('profile', ['id' => 1]);  // 如果路由中有参数profile/{id}
return Redirect::route('profile');
return Redirect::route('profile', ['id' => 1]);

【 重定向至控制器行为 】
return redirect()->action('HomeController@index');
return redirect()->action('UserController@profile', ['id' => 1] );  // 控制器行为需要参数可以在action方法的第二个参数中传递

在action()方法中指定的控制器和行为,必须是已在路由文件中注册的,且只对GET路由有效,可在终端中项目根目录输入以下命令查看都有哪些控制器及行为是可用的：
$ php artisan route:list

【 重定向后的闪存 】
在执行重定向跳转同时传送数据给会话
Route::post('user/profile', function () {
  return redirect('dashboard')->with('status', 'Profile updated!');
});
在用户跳转后就可以显示向会话传送的数据了,比如在视图文件中：
@if (session('status'))
  < div class="alert alert-success">{{ session('status') }}< /div>
@endif

【 自定义响应类型 】
自定义一个可以在多个路由和控制器中复用的响应,可以使用Response::macro方法创建一个响应宏方法

routes\web.php中创建一个xml响应宏方法,接受宏方法名作为第一个参数,闭包函数作为第二个参数,xml宏方法功能就是返回一个Content-Type标头为text/xml的响应
Response::macro('xml', function($content) {
  return Response::make($content, 200, [ 'Content-Type' => 'text/xml' ]);
});

Route::get('/xml', function () {
  $xml = new SimpleXMLElement('< ?xml version="1.0" encoding="UTF-8" ?>< websites>< /websites>');
  $website = $xml->addChild('website');
  $website->addChild('url', 'https://learnku.com');
  $website->addChild('desc', 'LearnKu 是终身学习者的编程知识社区');
  $content = $xml->asXML();
  return Response::xml($content);
});

响应宏方法定义好后在控制器或路由中可以这样调用：
return Response::xml($content);
return response()->xml($content);

【 错误处理 】
app\exceptions\handler类用于记录应用程序触发的所有异常,然后将其呈现回用户
config/app.php配置文件中的debug选项决定了对于一个错误实际上将显示多少信息给用户,默认该选项的设置将遵照存储在.env文件中的APP_DEBUG环境变量的值。
对于本地开发应该将APP_DEBUG环境变量的值设置为true,在生产环境中该值应始终为false,如果在生产中将该值设置为true则可能会将敏感配置值暴露给应用程序的终端用户

App\Exceptions\Handler类包含了两个方法report和render
report方法用于记录异常或将它们发送给如Flare,Bugsnag或Sentry等外部服务,默认report方法将异常传递给记录异常的基类,不过可以自定义来记录异常

以不同方式报告不同类型的异常则可以使用PHP的instanceof比较运算符
public function report(Exception $exception){
  if ($exception instanceof CustomException) {
    //
  }
  parent::report($exception);
}

全局日志
默认Laravel将当前用户ID作为数据添加到每一条异常日志中,可通过重写App\Exceptions\Handler类中的context方法定义全局环境变量,之后这个变量将包含在每一条异常日志中
protected function context(){
  return array_merge(parent::context(), [ 'foo' => 'bar', ]);
}

report辅助函数
有时可能需要报告异常,但又不希望终止当前请求的处理,report辅助函数允许使用异常处理器的report方法在不显示错误页面的情况下快速报告异常：
public function isValid($value){
  try {
    // 验证值...
  } catch (Exception $e) {
    report($e);
    return false;
  }
}

Render方法将给定的异常转换为HTTP响应
默认异常将传递给生成响应的基类,不过可以按自己意愿检查异常类型或返回自己的自定义响应
public function render($request, Exception $exception){
  if ($exception instanceof CustomException) {
    return response()->view('errors.custom', [], 500);
  }
  return parent::render($request, $exception);
}

HTTP异常
abort辅助函数从应用程序的任何地方生成服务器内部的HTTP错误响应,如404、401、500错误,辅助函数abort会立即引发一个由异常处理器渲染的异常,还可选择性地提供响应文本
abort(404);
abort(403, 'Unauthorized action.');

Route::get('abort/{code}', function(Illuminate\Http\Request $request, $code){
  abort($code);
});

自定义HTTP错误页面
自定义404错误页面可以创建一个resources/views/errors/404.blade.php视图文件,此目录中的视图文件的命名应匹配它们对应的HTTP状态码
由abort函数引发的HttpException实例将作为$exception变量传递给视图{{ $exception->getMessage() }}
php artisan vendor:publish --tag=laravel-errors  // 命令定义错误模板页面

【 日志 】
Laravel使用Monolog库为各种强大的日志处理服务提供支持,允许将日志消息系统错误日志记录到文件,甚至使用Slack通知到整个团队,Laravel允许混合使用
日志系统配置位于config/logging.php,默认使用stack去记录日志消息,stack通道被用来将多个日志通道聚合到一个单一的通道中,默认消息被写入配置文件中定义的默认日志通道

日志级别
emergency、alert、 critical、 error、 warning、 notice、 info 和 debug
Log::emergency($message);
Log::alert($message);
Log::critical($message);
Log::error($message);
Log::warning($message);
Log::notice($message);
Log::info($message);
Log::debug($message);

Log::info('User failed to login.', ['id' => $user->id]);  // 将上下文数据数组传递给日志方法。这些信息将被格式化,并与日志消息一直显示

</pre>
</div>

<div id="view">
<h3>view</h3><pre>
视图包含应用程序的 HTML,并且将控制器 / 应用程序逻辑与演示逻辑分开。视图文件存放于 resources/views 目录下

return view('greetings', ['name' => 'Victoria']);  // 传递参数给视图
return view('greeting')->with('name', 'Victoria'); // 传递参数给视图
return view('admin.profile', $data);  // 点号调用嵌套视图resources/views/admin/profile.blade.php

向视图文件输出数据
public function index(){
  return view('home')->withArticles(\App\Article::all());
}
withArticles是自定义的方法,Laravel并不提供,这也是Laravel优雅的一个表现：Laravel View采用__call来handle对未定义function的调用,其作用给视图系统注入一个名为$articles的变量,这段代码等价于->with('articles', \App\Article::all()),->withFooBar(100)等价于->with('foo_bar', 100),即驼峰变量会被完全转换为蛇形变量。

判断视图文件是否存在
use Illuminate\Support\Facades\View;
if (View::exists('emails.customer')) { }

创建第一个可用视图
使用first方法可以创建存在于给定数组视图中的第一个视图,如果应用程序或开发的第三方包允许定制或覆盖视图,这非常有用：
return view()->first(['custom.admin', 'admin'], $data);
return Illuminate\Support\Facades\View::first(['custom.admin', 'admin'], $data);  // 也可以通过View facade调用

与所有视图共享数据
在服务提供器的boot方法中调用视图门面Facade的share方法,例如可以将它们添加到AppServiceProvider或为它们生成一个单独的服务提供器

</pre><textarea>
namespace App\Providers;
use Illuminate\Support\Facades\View;
class AppServiceProvider extends ServiceProvider{
  // 注册任何应用服务, @return void
  public function register() { }

  // 引导任何应用服务,@return void
  public function boot(){
    View::share('key', 'value');
  }
}

</textarea><pre>
【 视图合成器 】
视图合成器是在呈现视图时调用的回调或类方法。如果每次呈现视图时都希望将某些数据绑定到视图,视图合成器可以帮助我们将该逻辑组织到一个统一的位置中。

创建一个ProfileComposer视图合成器,该视图合成器将用户计数绑定到视图

创建视图合成器
默认Laravel没有存放视图合成器的目录,需要新建目录app/Http/View/Composers,并创建一个名为ProfileComposer.php的文件

</pre><textarea>
namespace App\Http\View\Composers;
use Illuminate\View\View;
use App\Repositories\UserRepository;
class ProfileComposer {
  /**
    * The user repository implementation.
    * @var UserRepository
    */
  protected $users;

  /**
    * Create a new profile composer.
    * @param  UserRepository  $users
    * @return void
    */
  public function __construct(UserRepository $users){
    $this->users = $users;  // Dependencies automatically resolved by service container...
  }

  /**
    * Bind data to the view.该方法会在视图渲染之前被调用,可以使用$view的with方法将数据绑定到视图
    * @param  View  $view
    * @return void
    */
  public function compose(View $view){
    $view->with('count', $this->users->count());
  }
}

</textarea><pre>
因为所有的视图合成器都会通过服务容器进行解析,所以可以在视图合成器的构造函数中类型提示需要注入的依赖项。

注册视图合成器
创建好视图合成器之后还必须注册它,这样才能在每次渲染视图时都会执行ProfileComposer@compose方法。
在app\Providers目录中创建一个ViewServiceProvider服务提供商来注册视图合成器

</pre><textarea>
namespace App\Providers;
use Illuminate\Support\Facades\View;
use Illuminate\Support\ServiceProvider;
class ViewServiceProvider extends ServiceProvider{
  public function boot(){
    // 该方法接受的第一参数可以是一个视图名或包含一组视图的数组,甚至可以使用通配符*表示将一个视图合成器添加到所有视图,第二个参数可以是视图合成器的完全限定类名,也可以是一个闭包函数。
    View::composer( 'profile', 'App\Http\View\Composers\ProfileComposer' );
    // View::composer( ['profile', 'dashboard'], 'App\Http\View\Composers\MyViewComposer' );
    // View::composer('*', function ($view) { // });

    // Using Closure based composers...
    View::composer('dashboard', function ($view) {
      //
    });
  }

  /**
    * Register the service provider.
    * @return void
    */
  public function register(){
      //
  }
}

然后将这个新建的服务提供器添加到配置文件config/app.php的providers数组中：
'providers' => [
  // 省略
  App\Providers\ViewServiceProvider::class,
],

注册了视图合成器后每次渲染profile视图时都会执行ProfileComposer@compose方法

</textarea><pre>
【 视图构造器 】
视图构造器(creators)和视图合成器非常相似。唯一不同之处在于视图构造器在视图实例化之后执行,而视图合成器在视图即将渲染时执行。使用 creator 方法注册视图构造器：
View::creator('profile', 'App\Http\View\Creators\ProfileCreator');

【 获取模板的HTML内容 】
$html = view('templates.my_template')->render();
$html = view('templates.my_template', compact('variable1', 'variable2'))->render();  // 需要传参的话

【 视图优化 】
默认视图是按需编译的,当执行渲染视图的请求时Laravel将确定该视图的编译版本是否存在。如果已编译视图存在Laravel将比较未编译试图是否已被修改。如果已编译视图不存在或未编译视图已被修改,Laravel将重新编译该视图。
在请求期间编译视图会对性能产生影响,因此Laravel提供了view：cache Artisan命令来预编译应用中使用的所有视图文件。为了提高性能可能希望在部署过程中运行以下命令：
php artisan view:cache
可以使用 view：clear 命令清除视图缓存：
php artisan view:clear
通常,可以假设视图将永远不会在生产环境中被修改。因此可以通过修改view配置文件config/view.php中的expires选项来禁用Laravel检查视图文件是否过期：
'expires' => env('APP_ENV') !== 'production',
必须在部署过程中运行 php artisan view:cache 来禁用对过期视图的检查

</pre>
</div>

<div id="blade"></div>
<h3>blade</h3><pre>
Blade模板引擎有三种常见的语法：
{{-- 注释内容 --}}
通过 {{ }} 渲染PHP变量(最常用)
通过 {!! !!} 渲染原生HTML代码(用于富文本数据渲染),不对变量中HTML字符进行转义,比如在表单通过富文本编辑器编辑后提交的表单数据
通过以@作为前缀的Blade指令执行一些控制结构和继承、引入之类的操作

通过{{}}语法包裹渲染的PHP变量会通过htmlentities()方法进行HTML字符转义,从而避免类似XSS这种攻击,提高了代码的安全性,所以{{ $variable }}编译后的最终代码< ?php echo htmlentities($variable); ?>

</pre><textarea>
{{ $group->title }}

< link href="{{ asset('css/app.css')  }}" rel="stylesheet">

{!! $group->imageHtml() !!} 

@if (count($students) === 1) 
    操场上只有一个同学
@elseif (count($students) === 0)
    操场上一个同学也没有
@else
    操场上有 {{ count($students) }} 个同学
@endif

@unless是Blade提供的一个PHP中没有的语法,用于表示和@if条件相反的条件,@unless($condition)可以理解为< ?php if (!$condition):,然后以@endunless收尾：
@unless ($user->hasPaid()) 
  用户没有支付
@endunless

@unless(Auth::check())
  You are not signed in.
@endless

@isset($records)
    // 记录被设置
@endisset

@empty($records)
    // 记录为空
@endempty

@switch($i)
  @case(1)
    // $i = 1 做什么
    @break
  @case(2)
    // $i = 2 做什么
    @break
  @default
    // 默认情况下做什么
@endswitch

// for循环
@for ($i = 0; $i < $talk->slotsCount(); $i++) 
  The number is {{ $i }}< br> 
@endfor

// foreach循环
@foreach ($talks as $talk)
  {{ $talk->title }} ({{ $talk->length }} 分钟)<br> 
@endforeach

@forelse ($users as $user) 
  {{ $user->username }} {{ $user->nickname }}< br> 
@empty 
  该组中没有任何用户 
@endforelse

// while循环  
@while ($item = array_pop($items)) 
    {{ $item->orSomething() }}< br> 
@endwhile

@foreach ($pages as $page)
  @if ($loop->first)
    // 第一个循环迭代
  @endif 
  < li>{{ $loop->iteration }}: {{ $page->title }} 
    @if ($page->hasChildren()) 
    < ul> @foreach ($page->children() as $child) 
      < li>{{ $loop->parent->iteration }}. {{ $loop->iteration }}: {{ $child->title }}</li> 
      @endforeach 
    < /ul> 
    @endif 
  < /li> 
  @if ($loop->last)
      // 最后一个循环迭代
  @endif
@endforeach 

// $loop循环变量的属性: $loop->index、$loop->count、$loop->depth、$loop->remaining、$loop->iteration
@foreach($users as $user)
  @if ($loop->first)
    This is the first iteration.
  @endif

  @if ($loop->last)
    This is the last iteration.
  @endif

  < p>This is user {{ $user->id }}< /p>
@endforeach

在嵌套循环中,可以借助 parent 属性访问父循环的 $loop 变量：
@foreach ($users as $user)
    @foreach ($user->posts as $post)
        @if ($loop->parent->first)
            这是父循环的第一次迭代。
        @endif
    @endforeach
@endforeach

兼容js框架变量
Vue和Laravel一样使用{{ }},那么需要使用@{{ }}或@verbatim指令来正确输出Vue代码
Hello, @{{ name }}.
@verbatim
  < div class="container">
    Hello, {{ name }}.
  < /div>
@endverbatim

@php指令执行原生的PHP代码块
@php
    //
@endphp

认证
@auth和@guest指令用来判断当前用户是认证用户还是游客：

@auth
  // The user is authenticated...
@endauth

@guest
  //  The user is not authenticated...
@endguest

@guest
  //  The user is not authenticated...
@else
  // The user is authenticated...
@endguest

</textarea><pre>
【 模板继承 】
Blade模板引擎的主要两个优点是模板继承和区块
母版页还叫布局文件指令@section和@yield,@section定义区块,@yield定义区块里的内容
@section指令定义了视图的一部分内容,而@yield指令是用来显示指定部分的内容
继承布局文件: 子页中使用Blade的@extends指令指定继承的布局文件,使用@section指令为在布局文件中使用@section和@yield指令的地方注入内容

@section('content') ... @endsection 这两个标识符之间的代码会被放到基视图的@yield('content')中进行输出

在布局文件中使用 @yield 指令的地方,在子页中仍然使用 @section 注入内容;在布局文件中使用 @section 指令定义的一个好处是：在子页中使用 @section 注入时,可以使用 @parent 指令附加(而非重写)在布局文件中的内容,而在布局文件中使用 @yield 指令定义的地方是做不到的。@parent 指令会在视图渲染的时替换成布局文件里的内容。
注意,与在文件布局里定义的sidebar不同的是,子页里使用 @endsection 结束,而非@show。因为@endsection仅用来定义区块,而@show是用来定义、立马产出区块的

</pre><textarea>
< !-- Stored in resources/views/layouts/app.blade.php -->
< html>
  < head>
    < title>App Name - @yield('title')< /title>
  < /head>
  < body>
    @section('sidebar')
      This is the master sidebar.
    @show

    < div class="container">
      @yield('content')
    < /div>
  < /body>
< /html>

< !-- Stored in resources/views/child.blade.php -->
< !-- sidebar片段利用@parent指令向布局的sidebar追加(而非覆盖)内容。 在渲染视图时@parent指令将被布局中的内容替换 -->
< !-- sidebar片段使用@endsection代替@show来结尾。@endsection指令仅定义了一个片段,@show则在定义的同时立即yield这个片段 -->
@extends('layouts.app')

@section('title', 'Page Title')

@section('sidebar')
  @parent
  <p> This is appended to the master sideebar</p>
@endsection

@section('content')
  <p>This ismy body content. </p>
@endsection

Route::get('blade', function(){
  return view('child');
})

</textarea><pre>
1.@yield和@section都可以预定义可替代的区块,这两者有什么区别呢？
2.@section可以用@show, @stop, @overwrite及@append来结束,这三者又有什么区别呢？

@yield不可扩展,如果要定义的部分没有默认内容让子模板扩展的,那么用@yield($name, $default)比较方便,如果在子模板中并没有指定这个区块的内容就会显示默认内容,否则显示定义的内容
@section则既可以被替代,又可以被扩展,这是最大的区别。

</pre><textarea>
{{-- layout.master --}}
@yield('title','默认标题')

@section('content')
默认的内容
@show
 
{{-- home.index --}}
@extends('layout.master')

@section('title')
@parent
新的标题
@stop

@section('content')
@parent
扩展的内容
@stop

</textarea><pre>
模板用@yield和@section分别定义了一个区块,然后在子模板中去定义内容,由于@yield不能被扩展,所以即使加上了@parent也不起作用,输出的内容只有“新的标题”,替换了“默认的标题”。因此最终生成的页面只能是“默认的标题”或者“新的标题”,不能并存。而@section定义的部分,由于使用了@parent关键字,父模板中的内容会被保留,然后再扩展后添加的内容进去,输出的内容会是 “默认的内容 扩展的内容”

@section加上@stop,默认是替换(注入),必须用@parent关键字才能扩展。而@override关键字实际上有另外的应用场景

@endsection在4.0版本中已经被移除,虽然向下兼容,但不建议使用

@show指执行到此处时将该section中的内容输出到页面,而@stop则只是进行内容解析,并且不再处理当前模板中后续对该section的处理,除非用@override覆盖
通常在首次定义某个section的时候应该用@show,而在替换它或扩展它的时候应该用@stop,不应该用@show

</pre><textarea>
{{-- layout.master --}}
<div id="zoneA">
@section('zoneA')
AAA
@show
</div>

<div id="zoneB">
@section('zoneB')
BBB
@stop
</div>

<div id="zoneC">
@section('zoneC')
CCC
@show
</div>

{{-- page.view --}}
@extends('layout.master')

@section('zoneA')
aaa
@stop

@section('zoneB')
bbb
@stop

@section('zoneC')
ccc
@show

// 在layout.master中用@stop结束"zoneB",由于整个模板体系中没有以@show结束的"zoneB"的定义,因此这个区块不会被显示。而在page.view中用@show定义了'zoneC',这会在执行到这里时立即显示内容,并按照模板继承机制继续覆盖内容,因此最终显示的内容会是

<div class="zoneA">
aaa
</div>

<div class="zoneB">
</div>

<div class="zoneC">
ccc
</div>

// 从结果可以看到,zoneB的内容丢失,因为没有用@show告诉引擎输出这部分的内容,而zoneC的内容会显示两次,并且还破坏了layout.master的页面结构,因为@show出现了两次

</textarea><pre>
@append 和 @override
@override并不是在子模板中指明内容替换父模板的默认内容,这涉及到一个section在模板中可以多次使用的问题,也即所定义的每一个section,在随后的子模板中其实是可以多次出现的

</pre><textarea>
{{-- master --}}
<div>
@yield('content')
</div>

{{-- subview --}}
@extends('master')

@section('content')
加一行内容
@append

@section('content')
再加一行内容
@append

@section('content')
加够了,到此为止吧。
@stop

<div>
加一行内容
再加一行内容
加够了,到此为止吧。
</div>

</textarea><textarea>
{{-- filename : main.blade.php --}}
< title>App Name - @yield('title')< /title>

@section('sidebar')
  This is the master sidebar.
@stop

<div class="container">
  @yield('content')
</div>

{{-- filename: index.blade.php --}}
@extends('layouts.main')

{{--  point to  title ,  attach  @yield    --}}
@section('title', 'demo')

{{--
  父@show,子()  :  页面继承, 父页面滞后显示,
  父@stop,子()  :  子页面显示, 父页面被覆盖,

  父(),子@show :  页面继承, 父页面滞后显示,
  父(),子@stop :  父页面显示,子页面不显示.

  父@show,子@show  : 页面继承, 父页面滞后显示,
  父@show,子@stop  : 子页面显示, 父页面被覆盖,

  父@stop,子@show  :  子页面显示, 父页面被覆盖,
  父@stop,子@stop  :  所有的页面都不显示.
--}}

@section('sidebar')
  This is the childer sidebar.
@stop

</textarea><pre>
【 加载子视图 】
Blade允许在一个视图里通过@include指令引入一个视图。使用@include指令的视图称为父级视图,引入的视图称为子视图。父级视图的所有变量在子视图里都是可以获得的：

< div>
  @include('shared.error')
  @include('view.name',['some' => 'data'])     // 为引入的子视图传递额外数据
  @includeIf('view.name', ['some' => 'data'])  // 防止引入的视图不存在时Laravel抛出错误
  @includeWhen($boolean, 'view.name', ['some' => 'data'])  // 通过一个布尔值判断是否引入子视图
  < form>
    < !-- Form Contents -->
  < /form>
< /div>

</pre><pre>
【 组件别名 】
如果组件存储在子目录中,可能希望给它们起个别名以方便访问

如果一个Blade组件存储在resources/views/components/alert.blade.php中就可以使用component方法将components.alert的别名命名为alert。通常这一过程将在AppServiceProvider的boot方法中完成：
use Illuminate\Support\Facades\Blade;
Blade::component('components.alert', 'alert');

一旦组件有了别名就可以使用一条指令渲染它：
@alert(['type' => 'danger'])
    You are not allowed to access this resource!
@endalert

如果没有额外的插槽,还可以省略组件参数：
@alert
    You are not allowed to access this resource!
@endalert

【 为JS渲染JSON数据 】
有时为了初始化一个JavaScript变量,可能会向视图传递一个数据并将其渲染成JSON
var app = <?php echo json_encode($array); ?>;
var app = @json($array);  // 可以使用@json Blade指令代替手动调用json_encode函数

【 @each指令整合了循环数据和引入视图的功能 】
 使用 @each 渲染的视图不从父级模板里继承变量。如果子视图还需要这些变量应该使用foreach和@include指令组合
@each('view.name', $job, 'job')  // 遍历的数组jobs,在view.name视图里渲染job变量,当前迭代的key使用key变量获取
@each($bollean, 'view.name', [ 'some' => 'data'], 'view.empty')  // 第四个参数指定在给定数组元素为空时渲染的视图

【 @push指 】
使用@push指令向命名堆栈里推入内容,命令堆栈以@stack指令定义,可以定义在普通视图或布局文件里,推入的内容会在视图或布局文件里渲染出来。这在为子视图添加额外的js库的场景下特别有用,可以多次向堆栈推入数据

< !-- 在视图或者布局文件里定义堆栈 -->
< head>
  < !-- Head Contents -->
  @stack('scripts')
< /head>

< !-- 在子视图中推入堆栈内容 -->
@push('scripts')
  ＜script src="/example.js">＜/script>
@endpush

【 服务注入 】
@inject指令可以从Laravel的服务提供者中获得服务。传递给@inject指令的第一个参数是一个变量名,获得的服务就是存放在这个变量里,第二个参数就是你要解析的服务的类名或接口名。

@inject('metrics', 'App\Services\MetricesService')
< div>
  Monthly Revenue: {{ $metrics->monthlyRevenue() }}.
< /div>

【 扩展Blade 】
创建@datatime($var)指令,$var应该是一个DateTime实例
// 在更新自定义指令后,需要删除所有的视图文件,可以用 view:cache Artisan 命令实现
namespace App\Providers;
use Illuminate\Support\Facades\Blade;
use Illuminate\Support\ServiceProvider;
class AppServiceProvider extends ServiceProvider{
  public function boot(){
    Blade::directive('datetime', function($expression){
      return "<?php echo ($expression->format('m/d/Y H:i'); ?>)";
    });
  }
}

【 自定义if语句 】
当自定义涉及简单的条件判断时,使用Blade::directive的方式可能会变得稍复杂些。为此Blade引入了Blade::if方法使用闭包来快速自定义条件判断指令。例如定义一个指令,判断当前的项目环境,可以选择在 AppServiceProvider 的 boot 里做这件事情：

use Illuminate\Support\Facades\Blade;
public function boot(){
  Blade::if('env', function($expression){
    return app()->environment($environment);
  })
} 
定义好后使用：
@env('local')
    // The application is in the local environment...
@else
    // The application is not in the local environment...
@endenv

</pre>
</div>

<div id="db">
<h3>database</h3><pre>
Laravel能使用原生SQL、流畅的查询构造器和Eloquent ORM在各种数据库后台与数据库进行非常简单的交互,支持四种数据库:
MySQL 5.6+、PostgreSQL 9.4+、SQLite 3.8.8+、SQL Server 2017+
据库的配置文件放置在 config/database.php 文件中

【 SQLite配置 】
使用类似touch database/database.sqlite之类命令创建一个新的SQLite数据库之后,可以使用数据库的绝对路径配置环境变量来指向这个新创建的数据库:
DB_CONNECTION=sqlite
DB_DATABASE=/absolute/path/to/database.sqlite
添加到DB_FOREIGN_KEYS环境变量设置为true：
DB_FOREIGN_KEYS=true

【 URLs式配置 】
通常数据库连接使用多个配置值如host,database,username,password等,这些配置值中的每一个都有其相应的环境变量,这意味着在生产服务器上配置数据库连接信息时需要管理多个环境变量。
一些托管数据库提供程序如heroku提供单个数据库URL,该url在单个字符串中包含数据库的所有连接信息
mysql://root:password@127.0.0.1/forge?charset=UTF-8
这些URLs通常遵循标准模式约定：
driver://username:password@host:port/database?options
Laravel支持这些URLs,作为使用多个配置选项配置数据库的替代方法。如果存在url或相应的DATABASE_URL环境变量配置选项,则将使用该选项提取数据库连接和凭据信息

【 读写分离配置 】
有时希望SELECT语句使用一个数据库连接,而INSERT,UPDATE和DELETE语句使用另一个数据库连接,在Laravel中无论使用原生查询,查询构造器或者Eloquent ORM都能轻松的实现。
sticky是一个可选值,它可用于立即读取在当前请求周期内已写入数据库的记录。若sticky选项被启用,并且当前请求周期内执行过写操作,那么任何读操作都将使用写连接。这样可确保同一个请求周期内写入的数据可以被立即读取到,从而避免主从延迟导致数据不一致的问题。不过是否启用它,取决于应用程序的需求。

'mysql' => [
  'read' => [
    'host' => [ '192.168.1.1', '196.168.1.2', ],
  ],
  'write' => [
    'host' => [ '196.168.1.3', ],
  ],
  'sticky'    => true,
  'driver'    => 'mysql',
  'database'  => 'database',
  'username'  => 'root',
  'password'  => '',
  'charset'   => 'utf8mb4',
  'collation' => 'utf8mb4_unicode_ci',
  'prefix'    => '',
],

</pre>

<h4>运行原生SQL查询</h4><textarea>
public function index(){
  $results = DB::select('select * from users where id = :id', ['id' => 1]);
  $users = DB::select('select * from users where active = ?', [1]); // select方法将始终返回一个数组,数组中的每个结果都是一个StdClass对象
  foreach ($users as $user) {
    echo $user->name;
  }

  DB::insert('insert into users (id, name) values (?, ?)', [1, 'Dayle']);
  $affected = DB::update('update users set votes = 100 where name = ?', ['John']);  // 返回受该语句影响的行数
  $deleted = DB::delete('delete from users');  // 返回受该语句影响的行数
  
  DB::statement('drop table users');  // 运行普通语句

  // 事务的闭包Closure中出现异常事务将会回滚。如果事务闭包Closure执行成功事务将自动提交。一旦使用了transaction就不再需要担心手动回滚或提交的问题
  DB::transaction(function () {       // 数据库事务
    DB::table('users')->update(['votes' => 1]);
    DB::table('posts')->delete();
  });

  // 处理死锁,第二个可选参数表示事务发生死锁时重复执行的次数,一旦定义的次数尝试完毕就会抛出一个异常
  DB::transaction(function () {
    DB::table('users')->update(['votes' => 1]);
    DB::table('posts')->delete();
  }, 5);

  // 手动使用事务
  DB::beginTransaction();
  DB::rollBack();
  DB::commit();

  return view('user.index', ['users' => $users]);
}

</textarea><pre>
监听查询事件
监控程序执行的每一个SQL查询可以使用listen方法,对于记录查询或调试非常有用,可以在服务提供器中注册查询监听器

</pre><textarea>
namespace App\Providers;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\ServiceProvider;
class AppServiceProvider extends ServiceProvider{
  public function boot(){
    DB::listen(function ($query) {
      // $query->sql
      // $query->bindings
      // $query->time
    });
  }
}

</textarea>

<h4>查询构造器</h4><pre>
Laravel的数据库查询构造器为创建和运行数据库查询提供了一个方便的接口,可用于执行应用程序中大部分数据库操作,且可在所有支持的数据库系统上运行。
Laravel的查询构造器使用PDO参数绑定来保护您的应用程序免受SQL注入攻击。因此没有必要清理作为绑定传递的字符串。
PDO不支持绑定列名,因此不能让用户通过输入指定查询语句所引用的列名,包括order by字段等。如果必须要允许用户通过选择某些列来进行查询,请始终根据允许列的白名单来校验列名。

可以使用DB facade的table方法来开始查询,为给定的表返回一个查询构造器实例,允许在查询上链式调用更多的约束最后使用get方法获取结果

</pre><textarea>
public function index(){
  $users = DB::table('users')->get();  // 返回一个包含Illuminate\Support\Collection的结果,其中每个结果都是PHP StdClass对象的一个实例
  foreach ($users as $user) {
    echo $user->name;
  }

  $users = DB::table('users')->distinct()->get();  // 强制让查询返回的结果不重复
  $users = DB::table('users')->select('name', 'email as user_email')->get();  // 自定义一个select查询语句来查询指定的字段

  // 如果已经有了一个查询构造器实例,并且希望在现有的查询语句中加入一个字段
  $query = DB::table('users')->select('name');
  $users = $query->addSelect('age')->get();

  $user = DB::table('users')->where('name', 'John')->first();  // 从数据表中获取一行数据,返回一个StdClass对象
  echo $user->name;
  $email = DB::table('users')->where('name', 'John')->value('email');  // 从记录中获取单个值
  $user = DB::table('users')->find(3);  // 通过id字段值获取一行数据

  $titles = DB::table('roles')->pluck('title');  // 获取包含单列值的集合
  foreach ($titles as $title) {
    echo $title;
  }

  $roles = DB::table('roles')->pluck('title', 'name'); // 返回的集合中指定字段的自定义键名,将roles表中的name字段当做键名,title字段当做键值返回
  foreach ($roles as $name => $title) {
    echo $title;
  }

  // 分块结果
  // 如果需要处理上千条数据库记录可以考虑使用chunk方法一次获取结果集的一小块,并将其传递给闭包函数进行处理。该方法在Artisan命令编写数千条处理数据的时候非常有用。
  DB::table('users')->orderBy('id')->chunk(100, function ($users) {  // 将全部users表数据切割成一次处理100条记录的一小块
    foreach ($users as $user) { }
    return false;   // 过在闭包中返回false来终止继续获取分块结果
  });
  // 如果要在分块结果时更新数据库记录,则块结果可能会和预计的返回结果不一致,因此在分块更新记录时最好使用chunkById方法根据记录的主键自动对结果进行分页
  // 在块的回调里面更新或删除记录时,对主键或外键的任何更改都可能影响块查询。这可能会导致记录没有包含在分块结果中
  DB::table('users')->where('active', false)->chunkById(100, function ($users) {
    foreach ($users as $user) {
      DB::table('users')->where('id', $user->id)->update(['active' => true]);
    }
  });

  // 聚合
  $users = DB::table('users')->count();
  $price = DB::table('orders')->max('price');
  $price = DB::table('orders')->where('finalized', 1)->avg('price');

  // 判断记录是否存在
  return DB::table('orders')->where('finalized', 1)->exists();
  return DB::table('orders')->where('finalized', 1)->doesntExist();

  // DB::raw在查询中使用原生表达式,原生表达式将会被当做字符串注入到查询中,因此你应该小心使用,避免创建 SQL 注入的漏洞
  $users = DB::table('users')->select(DB::raw('count(*) as user_count, status'))->where('status', '<>', 1) ->groupBy('status') ->get();
  // selectRaw方法可以代替select(DB::raw(...))
  $orders = DB::table('orders')->selectRaw('price * ? as price_with_tax', [1.0825])->get();
  $orders = DB::table('orders')->whereRaw('price > IF(state = "TX", ?, 100)', [200])->get();
  $orders = DB::table('orders')->select('department', DB::raw('SUM(price) as total_sales'))->groupBy('department')->havingRaw('SUM(price) > ?', [2500])->get();
  $orders = DB::table('orders')->orderByRaw('updated_at - created_at DESC')->get();
  $orders = DB::table('orders')->select('city', 'state')->groupByRaw('city, state')->get();

  $users = DB::table('users')->join('contacts', 'users.id', '=', 'contacts.user_id')->join('orders', 'users.id', '=', 'orders.user_id')->select('users.*', 'contacts.phone', 'orders.price')->get();
  $users = DB::table('users')->leftJoin('posts', 'users.id', '=', 'posts.user_id')->get();
  $users = DB::table('users')->rightJoin('posts', 'users.id', '=', 'posts.user_id')->get();
  $users = DB::table('sizes')->crossJoin('colors')->get();  // crossJoin方法和想要连接的表名做交叉连接,交叉连接在第一个表和被连接的表之间会生成笛卡尔积

  DB::table('users')->join('contacts', function ($join) {
    $join->on('users.id', '=', 'contacts.user_id')->orOn(...);
  })->get();

  // 在连接上使用where和orWhere方法,这些方法会将列和值进行比较,而不是列和列进行比较
  DB::table('users')->join('contacts', function ($join) {
    $join->on('users.id', '=', 'contacts.user_id')>where('contacts.user_id', '>', 5);
  })->get();

  // 子连接查询
  // 可以使用 joinSub,leftJoinSub 和 rightJoinSub 方法关联一个查询作为子查询。他们每一种方法都会接收三个参数：子查询,表别名和定义关联字段的闭包：
  $latestPosts = DB::table('posts')
    ->select('user_id', DB::raw('MAX(created_at) as last_post_created_at'))
    ->where('is_published', true)
    ->groupBy('user_id');
  
  $users = DB::table('users')->joinSub($latestPosts, 'latest_posts', function ($join) {
    $join->on('users.id', '=', 'latest_posts.user_id');
  })->get();

  // 将两个查询联合的快捷方式
  $first = DB::table('users')->whereNull('first_name');
  $users = DB::table('users')->whereNull('last_name')->union($first)->get();

  // where语句
  $users = DB::table('users')->where('votes', '=', 100)->get();
  $users = DB::table('users')->where('votes', 100)->get();
  $users = DB::table('users')->where('votes', '>=', 100)->get();
  $users = DB::table('users')->where('votes', '<>', 100)->get();
  $users = DB::table('users')->where('name', 'like', 'T%')->get();
  $users = DB::table('users')->where([ ['status', '=', '1'], ['subscribed', '<>', '1'], ])->get();
  $users = DB::table('users')->where('votes', '>', 100)->orWhere('name', 'John')->get();
  $users = DB::table('users')->where('votes', '>', 100)->orWhere(function($query) {
    $query->where('name', 'Abigail')->where('votes', '>', 50);
  })->get(); 	// SQL: select * from users where votes > 100 or (name = 'Abigail' and votes > 50)
  $users = DB::table('users')->whereBetween('votes', [1, 100])->get();   // orWhereBetween
  $users = DB::table('users')->whereNotBetween('votes', [1, 100])->get();  // orWhereNotBetween
  $users = DB::table('users')->whereIn('id', [1, 2, 3])->get();  // whereNotIn / orWhereIn / orWhereNotIn
  $users = DB::table('users')->whereNull('updated_at')->get(); // whereNotNull / orWhereNull / orWhereNotNull
  $users = DB::table('users')->whereDate('created_at', '2016-12-31')->get();
  $users = DB::table('users')->whereMonth('created_at', '12')->get();
  $users = DB::table('users')->whereDay('created_at', '31')->get();
  $users = DB::table('users')->whereYear('created_at', '2016')->get();
  $users = DB::table('users')->whereTime('created_at', '=', '11:20:45')->get();
  $users = DB::table('users')->whereColumn('first_name', 'last_name')->get();   // whereColumn / orWhereColumn,whereColumn比较两个字段的值是否相等
  $users = DB::table('users')->whereColumn('updated_at', '>', 'created_at')->get();
  $users = DB::table('users')->whereColumn([ ['first_name', '=', 'last_name'], ['updated_at', '>', 'created_at'], ])->get();  // 用and运算符链接
    
  // 参数分组,select * from users where name = 'John' and (votes > 100 or title = 'Admin')
  $users = DB::table('users')->where('name', '=', 'John')->where(function ($query) {
    $query->where('votes', '>', 100)->orWhere('title', '=', 'Admin');
  })->get();

  // whereExists方法允许使用where exists SQL语句, select * from users where exists ( select 1 from orders where orders.user_id = users.id )
  $users = DB::table('users')->whereExists(function ($query) {
    $query->select(DB::raw(1))->from('orders')->whereRaw('orders.user_id = users.id');
  })->get();

  // 子查询 Where 语句
  use App\User;
  $users = User::where(function ($query) {
      $query->select('type')->from('membership')->whereColumn('user_id', 'users.id')->orderByDesc('start_date')->limit(1);
  }, 'Pro')->get();

  // -> 查询JSON类型的字段,仅在对JSON类型支持的数据库上
  $users = DB::table('users') ->where('options->language', 'en') ->get();
  $users = DB::table('users') ->where('preferences->dining->meal', 'salad') ->get();
  $users = DB::table('users') ->whereJsonContains('options->languages', 'en') ->get();
  $users = DB::table('users') ->whereJsonContains('options->languages', ['en', 'de']) ->get();
  $users = DB::table('users') ->whereJsonLength('options->languages', 0) ->get();
  $users = DB::table('users') ->whereJsonLength('options->languages', '>', 1) ->get();

  $users = DB::table('users') ->orderBy('name', 'desc') ->get();
  $user = DB::table('users') ->latest() ->first();  // latest和oldest方法可轻松地通过日期排序,默认使用created_at列作为排序依据,也可以传递自定义的列名
  $randomUser = DB::table('users') ->inRandomOrder() ->first();  // 随机排序
  $users = DB::table('users') ->groupBy('account_id') ->having('account_id', '>', 100) ->get();
  $users = DB::table('users') ->groupBy('first_name', 'status') ->having('account_id', '>', 100) ->get();

  $users = DB::table('users')->skip(10)->take(5)->get();  // 限制结果的返回数量,或跳过指定数量的结果
  $users = DB::table('users') ->offset(10) ->limit(5) ->get();

  // 子句只适用于某个情况为真是才执行查询,只想给定值在请求中存在的情况下才应用where语句,when方法只有在第一个参数为true时才执行给的的闭包
  $role = $request->input('role');
  $users = DB::table('users')->when($role, function ($query, $role) {
    return $query->where('role_id', $role);
  })->get();
  
  // 传递另一个闭包作为when方法的第三个参数,该闭包会在第一个参数为false的情况下执行
  $sortBy = null;
  $users = DB::table('users')->when($sortBy, function ($query, $sortBy) {
    return $query->orderBy($sortBy);
  }, function ($query) {
    return $query->orderBy('name');
  })->get();

  DB::table('users')->insert( ['email' => 'john@example.com', 'votes' => 0] );
  DB::table('users')->insert([
    ['email' => 'taylor@example.com', 'votes' => 0],
    ['email' => 'dayle@example.com', 'votes' => 0]
  ]);
  DB::table('users')->insertOrIgnore([  // insertOrIgnore方法用于忽略重复插入记录到数据库的错误
    ['id' => 1, 'email' => 'taylor@example.com'],
    ['id' => 2, 'email' => 'dayle@example.com']
  ]);
  $id = DB::table('users')->insertGetId(['email' => 'john@example.com', 'votes' => 0]);

  $affected = DB::table('users') ->where('id', 1) ->update(['votes' => 1]);

  // 首先尝试使用第一个参数的键和值对来查找匹配的数据库记录,如果记录存在则使用第二个参数中的值去更新记录,否则插入一个新记录,更新的数据是两个数组的集合
  DB::table('users')->updateOrInsert(                       // 更新或新增
      ['email' => 'john@example.com', 'name' => 'John'],  // 查找记录的条件数组
      ['votes' => '2']                                    // 要更该记录的键值对数组
  );
  
  //  更新json
  $affected = DB::table('users') ->where('id', 1) ->update(['options->enabled' => true]);

  DB::table('users')->increment('votes');
  DB::table('users')->increment('votes', 5);
  DB::table('users')->decrement('votes');
  DB::table('users')->decrement('votes', 5);
  DB::table('users')->increment('votes', 1, ['name' => 'John']);  // 在操作过程中指定要更新的字段

  DB::table('users')->delete();
  DB::table('users')->where('votes', '>', 100)->delete();
  DB::table('users')->truncate();  // 删除所有行,并重置自增ID为零

  悲观锁
  查询构造器也包含在select语法上实现悲观锁定的函数。若想在查询中实现一个共享锁可以使用sharedLock方法。共享锁可防止选中的数据列被篡改,直到事务被提交为止:
  DB::table('users')->where('votes', '>', 100)->sharedLock()->get();
  或者可以使用lockForUpdate方法。使用update锁可避免行被其它共享锁修改或选取：
  DB::table('users')->where('votes', '>', 100)->lockForUpdate()->get();

  // 调试,输出查询结果或SQL语句。使用dd方法可以显示调试信息,然后停止执行请求。dump方法同样可以显示调试信息,但不会停止执行请求
  DB::table('users')->where('votes', '>', 100)->dd();
  DB::table('users')->where('votes', '>', 100)->dump();

  return view('user.index', ['users' => $users]);
}

</textarea><pre>
【 分页 】
Laravel的分页器将查询构造器和Eloquent ORM结合起来,提供了方便易用的数据库结果集分页。通过分页器生成的HTML兼容Bootstrap CSS框架

查询构造器分页
数据分页有多种方法,最简单的是使用查询构造器或Eloquent query的paginate方法。paginate方法根据用户浏览的当前页码,自动设置恰当的偏移量offset和限制数limit。默认HTTP请求中的page查询参数值被当作当前页的页码。Laravel会自动检测该值,并自动将其插入到分页器生成的链接中
$users = DB::table('users')->paginate(15);  // 每页显示 15 条数据
$users = DB::table('users')->simplePaginate(15);  // 只在分页视图中简单地显示下一页和上一页的链接,这在数据量很大且不需要在渲染视图时显示每页的页码时非常有用

Eloquent分页
$users = App\User::paginate(15);
$users = User::where('votes', '>', 100)->paginate(15);
$users = User::where('votes', '>', 100)->simplePaginate(15);

</pre>
</div>

<div id="migrate">
<h4>数据库迁移 Schema生成器</h4><pre>
迁移就像数据库的版本控制器,让团队更容易修改和共享程序的数据库结构。迁移通常配合Laravel的结构生成器更容易生成应用程序的数据库结构
Laravel的Schema facade提供数据库无关的支持,用于在所有Laravel支持的数据库系统中创建和操作表

生成创建迁移
php artisan make:migration create_users_table    // 新创建的迁移会放在database/migrations目录,每个迁移的文件名都包含一个时间戳来让Laravel确认迁移的顺序
php artisan make:migration create_users_table --path database/migrations  // 自定义生成迁移文件的个人存放路径,给定的路径是相对于应用程序根目录的相对路径

--table和--create选项也可用于确定表的名称及是否在迁移中创建新的数据表,这些选项用指定的迁移模板预先填充指定的数据表,这些选项只需要简单放在上述迁移命令后面并指定表名
php artisan make:migration create_users_table --create=users
php artisan make:migration add_votes_to_users_table --table=users

迁移结构
迁移类包含方法up和down,up方法用于新增数据库的数据表、字段或索引的,down方法应该与up方法相反,这两种方法中可以使用Laravel的结构生成器以表达式方式创建和修改表
在迁移文件中up方法用于创建数据表,down方法用于回滚即删除数据表
在迁移文件上写上要创建表的字段及约束条件

</pre>创建flights数据表结构<textarea>
use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;
class CreateFlightsTable extends Migration{
  public function up(){  // Run the migrations
    Schema::create('flights', function (Blueprint $table) {  // 创建指定数据表
      $table->id();              // 默认生成
      $table->string('name');
      $table->string('airline');
      $table->timestamps();      // 默认生成
    });
  }

  public function down(){  // Reverse the migrations
    Schema::drop('flights');
  }
}

</textarea><pre>
查看当前的migrate的状态
php artisan migrate:status

运行迁移
php artisan migrate
执行所有未执行的迁移,根据迁移文件创建数据表结构,迁移之后修改迁移文件再执行迁移无效,需新建迁移文件来迁移,这时会生成migratoins表是迁移记录表
假设需要添加一个新的字段,可以回滚然后修改迁移文件再次执行迁移,或者可以直接新建一个迁移文件

查看创建表时的sql语句
php artisan migrate --pretend

在生产环境中强制执行迁移
大多数迁移操作都是破坏性的,这意味着也许会丢失数据。为了防止有人在生产环境数据中运行这些命令,在执行这些命令之前提示确认。如果要强制迁移命令在没有提示的情况下运行请使用 –force 参数：
php artisan migrate --force

回滚迁移
删除表结构不删除迁移文件,迁移文件down里面的代码被执行
php artisan migrate:rollback           // 回滚到migrate命令执行的最后一批的迁移,这可能会包含多个迁移文件
php artisan migrate:rollback --step=5  // 回滚最后五个迁移
php artisan migrate:reset              // 滚回应用程序所有的迁移

使用单个命令来执行迁移和回滚
migrate:refresh命令将会：
php artisan migrate:refresh           // 在回滚所有的迁移后执行migrate命令,可以高效的重新创建整个数据库
php artisan migrate:refresh --seed    // Refresh the database and run all database seeds
php artisan migrate:refresh --step=5  // 回滚并重新迁移最后五个迁移

删除所有数据表和迁移
php artisan migrate:fresh             // 删除数据库中所有的数据表并执行migrate命令
php artisan migrate:fresh --seed

【 迁移文件中的数据表 】

</pre><textarea>
if (Schema::hasTable('users')) { }            // 检查数据表是否存在
if (Schema::hasColumn('users', 'email')) { }  // 检查字段是否存在

// 创建数据表,一参为表名,可使用结构生成器的任何字段方法定义数据表的字段,二参个闭包（匿名函数）,获取用于定义新表的Blueprint对象
Schema::create('users', function (Blueprint $table) {  
  $table->id();
  
  // 常用迁移属性
  $table->increments('id');	              // 数据库主键自增ID
  $table->integer('votes');	              // 等同于数据库中的INTEGER类型
  $table->float('amount');	              // 等同于数据库中的FLOAT类型
  $table->char('name', 4);	              // 等同于数据库中的CHAR类型
  $table->dateTime('created_at');	        // 等同于数据库中的DATETIME类型
  $table->enum('choices', ['foo','bar']);	// 等同于数据库中的ENUM类型
  $table->tinyInteger('numbers');	        // 等同于数据库中的TINYINT类型
  $table->timestamps();	                  // 添加created_at和updated_at列
  
  // 在结构生成器上使用以下命令定义表的选项
  $table->engine = 'InnoDB';	            // 指定表存储引擎 (MySQL)。
  $table->charset = 'utf8';	              // 指定表的默认字符编码 (MySQL),Laravel默认使用utf8mb4编码,支持在数据库中储存emojis 
  $table->collation = 'utf8_unicode_ci';	// 指定表的默认排序格式 (MySQL)。
  $table->temporary();	                  // 创建临时数据表 (except SQL Server)。
});

Schema::connection('foo')->create('users', function (Blueprint $table) {  // 对非默认连接的数据库连接执行结构操作
  $table->id();
});

Schema::table('table', function($table){}); // 更新一个已存在的数据表

Schema::drop('users');          // 删除一个存在的数据表
Schema::dropIfExists('users');  // 删除一个存在的数据表

Schema::rename($from, $to);     // 重命名一个存在的数据库表
在重命名数据表之前应该验证表上的任何外键约束在迁移文件中是否具有确切的名称,而不是让Laravel按照约定来分配一个名称,否则外键约束名将引用旧表名

</textarea>【 字段 】<textarea>
Schema::create('users', function (Blueprint $table) {
  $table->id();
  $table->string('name');
  $table->string('email')->unique();
  $table->timestamp('email_verified_at')->nullable();
  $table->string('password');
  $table->rememberToken();
  $table->timestamps();
});

Schema::table('users', function (Blueprint $table) {   // 更新已存在的数据表
  $table->string('email');
});

</textarea><pre>
数据库结构生成器包含构建表时可以指定的各种字段类型

// 自增
$table->id();	                  // 相当于$table->bigIncrements('id')
$table->uuid('id');	            // 相当于UUID
$table->foreignId('user_id');	  // 相当于$table->unsignedBigInteger('user_id')
$table->increments('id');	      // 递增的ID (主键),相当于UNSIGNED INTEGER
$table->tinyIncrements('id');	  // 相当于自动递增UNSIGNED TINYINT
$table->smallIncrements('id');	// 递增ID(主键),相当UNSIGNED SMALLINT
$table->mediumIncrements('id');	// 递增 ID (主键) ,相当于UNSIGNED MEDIUM INTEGER
$table->bigIncrements('id');	  // 递增ID(主键),相当于UNSIGNED BIG INTEGER
 
// 数字
$table->integer('votes');	                // 相当于INTEGER
$table->tinyInteger('votes');	            // 相当于TINYINT
$table->smallInteger('votes');	          // 相当于SMALLINT
$table->mediumInteger('votes');	          // 相当于MEDIUMINT
$table->bigInteger('votes');	            // 相当于BIGINT
$table->float('amount', 8, 2);	          // 相当于带有精度与基数 FLOAT
$table->double('amount', 8, 2);	          // 相当于带有精度与基数 DOUBLE
$table->decimal('amount', 8, 2);	        // 相当于带有精度与基数DECIMAL
$table->unsignedBigInteger('votes');	    // 相当于Unsigned BIGINT
$table->unsignedDecimal('amount', 8, 2);	// 相当于带有精度和基数的UNSIGNED DECIMAL
$table->unsignedInteger('votes');	        // 相当于Unsigned INT
$table->unsignedMediumInteger('votes');	  // 相当于Unsigned MEDIUMINT
$table->unsignedSmallInteger('votes');	  // 相当于Unsigned SMALLINT
$table->unsignedTinyInteger('votes');	    // 相当于Unsigned TINYINT
 
// 字符串和文本
$table->char('name', 100);	        // 相当于带有长度的CHAR
$table->string('email');
$table->string('name', 100);	      // 相当于带长度的VARCHAR
$table->text('description');	      // 相当于TEXT
$table->mediumText('description');	// 相当于MEDIUMTEXT
$table->longText('description');	  // 相当于LONGTEXT

$table->nullableMorphs('taggable');	     // 相当于可空版本的 orphs()字段
$table->nullableUuidMorphs('taggable');	 // 相当于可空版本的uuidMorphs()字段
$table->nullableTimestamps(0);	         // timestamps()方法别名
 
// 日期和时间
$table->date('created_at');	          // 相当于DATE
$table->dateTime('created_at', 0);	  // 相当于DATETIME
$table->dateTimeTz('created_at', 0);	// 相当于带时区DATETIME
$table->time('sunrise');
$table->time('sunrise', 0);	          // 相当于TIME
$table->timestamp('added_on');
$table->timestamp('added_on', 0);	    // 相当于TIMESTAMP
$table->timestamps();                 // 添加 created_at 和 updated_at 行
$table->timestamps(0);	              // 相当于可空的created_at和updated_at TIMESTAMP
$table->timeTz('sunrise', 0);	        // 相当于带时区的TIME
$table->timestampTz('added_on', 0);	  // 相当于带时区的TIMESTAMP
$table->timestampsTz(0);	            // 相当于可空且带时区的created_at和updated_atTIMESTAMP
$table->nullableTimestamps();
$table->year('birth_year');	          // 相当于YEAR

// 为软删除添加 deleted_at 字段
$table->softDeletes();
$table->softDeletes(0);	    // 相当于为软删除添加一个可空的deleted_at字段
$table->softDeletesTz(0);	  // 相当于为软删除添加一个可空的带时区的deleted_at字段
 
// 其它类型
$table->binary('data');	                  // 相当于BLOB
$table->boolean('confirmed');	            // 相当于BOOLEAN
$table->enum('choices', array('foo', 'bar'));
$table->enum('level', ['easy', 'hard']);	// 相当于ENUM
$table->rememberToken();                  // 添加remember_token为VARCHAR(100) NULL,相当于可空版本的VARCHAR(100)的remember_token字段
$table->morphs('parent');                 // 添加整型的 parent_id 和字符串类型的 parent_type,相当于加入递增的taggable_id与字符串taggable_type
$table->geometry('positions');	          // 相当于GEOMETRY
$table->geometryCollection('positions');	// 相当于GEOMETRYCOLLECTION
$table->json('options');	                // 相当于JSON
$table->jsonb('options');	                // 相当于JSONB
$table->lineString('positions');	        // 相当于LINESTRING
$table->ipAddress('visitor');	            // 相当于IP 地址
$table->macAddress('device');	            // 相当于MAC 地址
$table->uuidMorphs('taggable');	          // 相当于加入taggable_id与字符串taggable_typeUUID列
$table->multiLineString('positions');	    // 相当于MULTILINESTRING
$table->multiPoint('positions');	        // 相当于MULTIPOINT
$table->multiPolygon('positions');        // 相当于MULTIPOLYGON
$table->point('position');	               // 相当于POINT
$table->polygon('positions');	             // 相当于POLYGON
$table->set('flavors', ['strawberry', 'vanilla']);	// 相当于SET

字段修饰,修改列
Schema::table('users', function (Blueprint $table) {
  $table->string('email')->nullable();
});

一些列名约束条件的写法
->first()	                      // 将此字段放置在数据表的首位,将该列置为表中第一个列
->after('column')	              // 将此字段放置在其它字段之后,将该列置于另一个列之后
->default($value)	              // 为字段指定默认值,指定列的默认值
->unsigned()	                  // 设置INTEGER类型的字段为UNSIGNED,设置integer列为UNSIGNED
->nullable()	                  // 允许该列的值为 NULL
->nullable($value = true)	      // 此字段默认允许写入NULL值
->autoIncrement()	              // 将INTEGER类型的字段设置为自动递增的主键
->charset('utf8')	              // 指定一个字符集
->collation('utf8_unicode_ci')	// 指定排序规则
->comment('my comment')	        // 为字段增加注释
->storedAs($expression)	        // 创建一个存储生成的字段
->useCurrent()	                // 将TIMESTAMP类型的字段设置为使用CURRENT_TIMESTAMP作为默认值
->virtualAs($expression)	      // 创建一个虚拟生成的字段

默认值表示方式
default修饰符接收一个变量或一个\Illuminate\Database\Query\Expression实例,使用Expression实例可避免使用包含在引号中的值,并且允许使用特定数据库函数,在当需要给JSON字段指定默认值的场景特别有用

Schema::create('flights', function (Blueprint $table) {
  $table->id();
  $table->json('movies')->default(new Expression('(JSON_ARRAY())'));
  $table->timestamps();
});

修改字段
修改字段前确保添加依赖doctrine/dbal,Doctrine DBAL库用于确定字段的当前状态,并创建对该字段进行指定调整所需的SQL查询
composer require doctrine/dbal
只有以下字段类型能被修改：bigInteger、binary、boolean、date、dateTime、dateTimeTz、decimal、integer、json、 longText、mediumText、smallInteger、string、text、time、unsignedBigInteger、unsignedInteger 和 unsignedSmallInteger

Schema::table('users', function (Blueprint $table) {   // 结构生成器
  $table->string('name', 50)->change();                // 将现有的字段类型修改为新的类型或修改属性,把name字段的长度增加到50
  $table->string('name', 50)->nullable()->change();    // 将字段修改为nullable
  $table->renameColumn('from', 'to');                  // 重命名字段
  $table->dropColumn('votes');                         // 删除字段
  $table->dropColumn(['votes', 'avatar', 'location']); // 删除多个字段
  $table->dropMorphs('morphable');	                   // 删除morphable_id和morphable_type字段
  $table->dropRememberToken();	                       // 删除remember_token字段
  $table->dropSoftDeletes();	                         // 删除deleted_at 字段
  $table->dropSoftDeletesTz();	                       // 相当于 dropSoftDeletes()
  $table->dropTimestamps();	                           // 删除created_at和updated_at字段
  $table->dropTimestampsTz();	                         // dropTimestamps()别名
});

【 索引 】
$table->string('email')->unique();            // 新建字段并创建索引
$table->unique('email');                      // 定义完字段之后创建索引
$table->index(['account_id', 'created_at']);  // 将数组传递给索引方法来创建一个复合(或合成)索引
$table->unique('email', 'unique_email');      // Laravel会自动生成一个合理的索引名称,但也可以传递第二个参数来自定义索引名称

可用的索引类型
每个索引方法都接受一个可选的第二个参数来指定索引的名称。如果省略,名称将根据表和列的名称生成。
$table->primary('id');	               // 添加主键
$table->primary(['id', 'parent_id']);	 // 添加复合键

$table->unique('email');	             // 添加唯一索引
$table->unique('column', 'key_name');  // 创建一个双唯一性索引
$table->unique(array('first', 'last'));
$table->unique(array('first', 'last'), 'key_name');

$table->index('state');	添加普通索引
$table->index('column', 'key_name');
$table->index(array('first', 'last'));  // 创建一个双索引
$table->index(array('first', 'last'), 'key_name');

$table->spatialIndex('location');	      // 添加空间索引 

$table->renameIndex('from', 'to');      // 重命名索引

删除索引
若要删除索引则必须指定索引的名称。Laravel默认会自动将数据表名称、索引的字段名及索引类型简单地连接在一起作为名称
$table->dropPrimary('users_id_primary');	              // 从users表中删除主键
$table->dropUnique('users_email_unique');	              // 从users表中删除唯一索引
$table->dropIndex('geo_state_index');	                  // 从geo表中删除基本索引
$table->dropSpatialIndex('geo_location_spatialindex');	// 从geo表中删除空间索引

Schema::table('geo', function (Blueprint $table) {
  $table->dropIndex(['state']);   // Drops index 'geo_state_index'
});

【 外键约束 】
Schema::table('posts', function (Blueprint $table) {
  $table->unsignedBigInteger('user_id');
  $table->foreign('user_id')->references('id')->on('users');  // 在posts表上定义一个引用users表的id字段的user_id字段
});

Schema::table('posts', function (Blueprint $table) {
  $table->foreignId('user_id')->constrained();   // 为on delete和on update属性指定所需的操作
});

foreignId方法是unsignedBigInteger的别名,而restricted方法将使用约定来确定引用的表名和列名。
可以为on delete和on update属性指定所需的操作：
$table->foreignId('user_id')->constrained()->onDelete('cascade');

$table->foreign('user_id')->references('id')->on('users')->onDelete('cascade'|'restrict'|'set null'|'no action');
$table->foreign('user_id')->references('id')->on('users')->onUpdate('cascade'|'restrict'|'set null'|'no action');

$table->dropForeign('posts_user_id_foreign');  // 删除外键。外键约束采用的命名方式与索引相同,即将数据表名称和约束的字段连接起来,再加上_foreign后缀
$table->dropForeign(['user_id']);  // 传递一个字段数组,在删除的时候会按照约定字段转换为对应的外键名称

可以在迁移文件中使用以下方法来开启或关闭外键约束：
Schema::enableForeignKeyConstraints();
Schema::disableForeignKeyConstraints();

</pre>
</div>

<div id="seeder">
<h4>数据填充</h4><pre>
database/seeds下的填充类可以为数据库填充测试数据,可以随意为填充类命名,但更建议遵守类似UserSeeder的命名规范
Laravel默认定义了DatabaseSeeder类,通过这个类可以用call方法来运行其它的seed类从而控制数据填充的顺序

生成Seeder
php artisan make:seeder UserSeeder

seeder类只包含一个默认方法run,这个方法会在执行db:seed这个Artisan命令时被调用。在run方法里可以根据需要在数据库中插入数据,也可以用查询构造器或Eloquent模型工厂来手动插入数据。使用数据填充时会自动禁用批量赋值保护,在run的方法签名中可以用类型来约束需要的依赖,它们会被Laravel服务容器自动解析

</pre><textarea>
use Illuminate\Database\Seeder;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Hash;
use Illuminate\Support\Str;
class DatabaseSeeder extends Seeder{
  // Run the database seeds. @return void
  public function run(){
    DB::table('users')->insert([    // 每次运行Seeders时插入一条数据
      'name' => Str::random(10),
      'email' => Str::random(10).'@gmail.com',
      'password' => Hash::make('password'),
    ]);
  }
}

手动为每个模型填充指定属性很麻烦,可以使用模型model工厂轻松地生成大量数据库数据。首先定义好了工厂文件,然后就可以使用factory辅助函数来向数据库中插入数据
public function run(){
  factory(App\User::class, 50)->create()->each(function ($user) {  // 创建50个用户并为每个用户创建关联
    $user->posts()->save(factory(App\Post::class)->make());
  });
}

调用其它Seeders
DatabaseSeeder类中可使用call方法运行其它的seed类,使用call方法可将数据填充拆分成多个文件,就不会使单个seeder变得非常大,只需简单传递要运行的seeder类名称即可：
public function run(){
  $this->call([ UserSeeder::class, PostSeeder::class, CommentSeeder::class, ]);
}

</textarea><pre>
运行Seeders
完成seeder类的编写之后可能需要使用composer dump-autoload命令重新生成Composer的自动加载器,然后使用Artisan命令db:seed来填充数据库
php artisan db:seed                     // 默认db:seed命令运行DatabaseSeeder类,这个类可以用来调用其它Seed类
php artisan db:seed --class=UserSeeder  // 指定特定的seeder类
php artisan migrate:fresh --seed        // 删除所有表并重新运行所有迁移,填充数据库,这个命令可以用来重建数据库

在生产环境中强制使用
一些填充操作可能会导致原有数据的更新或丢失,为了保护生产环境数据库的数据,在运行填充命令前会进行确认,可以添加--force选项来强制运行填充命令:
php artisan db:seed --force

</pre>
</div>

<div id="factories">
<h4>factories 模型工厂</h4><pre>
【 生成模型工厂 】
php artisan make:factory PostFactory  // 创建一个模型工厂,新生成的工厂位置在database/factories目录下
php artisan make:factory PostFactory --model=Post  // --model选项指示工厂创建的模型的名称,此选项将使用给定模型预填充生成的工厂文件

编写模型工厂
运行测试之前常需要插入一些数据到数据库中,创建测试数据时,除了手动设置每个字段的值,Laravel还可以使用Eloquent模型的工厂来设置每个属性的默认值。开始之前可以先看一下应用程database/factories/UserFactory.php的文件。开箱即用,这个文件包含一个模型工厂定义：

</pre><textarea>
use Faker\Generator as Faker;
use Illuminate\Support\Str;
$factory->define(App\User::class, function (Faker $faker) {
  return [
    'name' => $faker->name,
    'email' => $faker->unique()->safeEmail,
    'email_verified_at' => now(),
    'password' => '$2y$10$92IXUNpkjO0rOQ5byMi.Ye4oKoEa3Ro9llC/.og/at2.uheWG/igi',
    'remember_token' => Str::random(10),
  ];
});

</textarea><pre>
在这个模型工厂定义的闭包中可以返回模型上所有属性的默认测试值,闭包将接受PHP函数库Faker的一个实例,它允许便捷的生成各种随机数据来进行测试。
也可以为每个模型创建一个工厂文件以便实现更好的组织,如database/factories下创建UserFactory.php和CommentFactory.php,Laravel将自动加载factories目录下的所有文件。
也可以在config/app.php配置文件中添加faker_locale选项来设置Faker的语言环境。

工厂扩展
如果扩展了模型,则可能还希望扩展其工厂,以便在测试和数据填充期间利用子模型的工厂属性,为此可以调用工厂制造商的raw方法来从任何给定工厂获得原始属性数组：

</pre><textarea>
$factory->define(App\Admin::class, function (Faker\Generator $faker) {
  return factory(App\User::class)->raw([
    // ...
  ]);
});

</textarea><pre>
工厂状态
工厂状态可以任意组合模型工厂,仅需要做出适当差异化的修改就可以达到让模型拥有多种不同的状态。例如User模型中可以修改某个默认属性值来达到标识一种delinquent状态。可以使用state方法来进行这种状态转换。对于简单的工厂状态,可以传入要修改的属性数组：

</pre><textarea>
$factory->state(App\User::class, 'delinquent', [
  'account_status' => 'delinquent',
]);

// 如果工厂状态需要计算或使用$faker实例,可以使用闭包方法来实现状态属性的修改：
$factory->state(App\User::class, 'address', function ($faker) {
  return [
    'address' => $faker->address,
  ];
});

</textarea><pre>
工厂回调
工厂回调是使用afterMaking和afterCreating方法注册的,并且允许在创建模型之后执行其他任务,例如可以使用回调将附加模型与创建的模型相关联：

$factory->afterMaking(App\User::class, function ($user, $faker) { });
$factory->afterCreating(App\User::class, function ($user, $faker) {
  $user->accounts()->save(factory(App\Account::class)->make());
});

为工厂状态定义回调：
$factory->afterMakingState(App\User::class, 'delinquent', function ($user, $faker) { });
$factory->afterCreatingState(App\User::class, 'delinquent', function ($user, $faker) { });

【 使用模型工厂 】
创建模型
使用工厂创建模型时将自动禁用批量赋值
模型工厂定义后就可以在测试或数据库的填充文件中通过全局的factory函数来生成模型实例
$user = factory(App\User::class)->make();      // 使用make方法创建模型但不将他们保存至数据库
$users = factory(App\User::class, 3)->make();  // Create three App\User instances,创建一个含有多个模型的集合,或创建一个指定类型的模型

应用状态
也可将任何状态应用于模型,若将多个状态转换应用于模型应当为每个状态指定名称：
$users = factory(App\User::class, 5)->states('delinquent')->make();
$users = factory(App\User::class, 5)->states('premium', 'delinquent')->make();

覆盖属性
$user = factory(App\User::class)->make([ 'name' => 'Abigail' ]);  // 覆盖模型的某些默认值,而其余值仍为工厂指定的默认值

持久化模型
create方法创建模型实例的同时还调用了把记录写入数据库的save方法：
$user = factory(App\User::class)->create();  // 创建单个App\User实例
$users = factory(App\User::class, 3)->create();  // 创建3个App\User实例
$user = factory(App\User::class)->create([ 'name' => 'Abigail' ]);  // 重写模型的属性

【 模型关联 】
为模型创建关联。使用create方法创建多模型时返回一个Eloquent实例集合,这样就可以在集合上使用each等便捷方法：

$users = factory(App\User::class, 3)->create()->each(function ($user) {
  $user->posts()->save(factory(App\Post::class)->make());
  $user->posts()->createMany( factory(App\Post::class, 3)->make()->toArray() );  // 使用createMany方法创建多个相关模型
});

关联 & 属性闭包
模型工厂定义时也可以使用闭包里的属性来给模型添加关联,例如创建Post实例同时创建User实例

</pre><textarea>
$factory->define(App\Post::class, function ($faker) {
  return [
    'title' => $faker->title,
    'content' => $faker->paragraph,
    'user_id' => factory(App\User::class),
  ];
});

// 如果该关系取决于定义它的工厂,则可以提供一个闭包接收一个包含工厂属性的数组：
$factory->define(App\Post::class, function ($faker) {
  return [
    'title' => $faker->title,
    'content' => $faker->paragraph,
    'user_id' => factory(App\User::class),
    'user_type' => function (array $post) {
      return App\User::find($post['user_id'])->type;
    },
  ];
});

</textarea><pre>
使用数据填充
如果希望在测试期间使用数据填充填充数据库,则可以使用seed方法。默认seed方法将返回DatabaseSeeder,它会结束其他的数据填充器,或者将指定的数据填充器的类名传递给seed方法

</pre><textarea>
namespace Tests\Feature;
use Illuminate\Foundation\Testing\RefreshDatabase;
use Illuminate\Foundation\Testing\WithoutMiddleware;
use OrderStatusesTableSeeder;
use Tests\TestCase;
class ExampleTest extends TestCase {
  use RefreshDatabase;
  public function testCreatingANewOrder() {
    $this->seed();  // 运行整个数据填充器
    $this->seed(OrderStatusesTableSeeder::class);  // 运行单个数据填充器
  }
}

</textarea><pre>
每次测试后重置数据库
在PHPUnit每次测试后重置数据库是很有用的,这样前一次测试的数据不会干扰后续测试。 RefreshDatabase trait会采用最优化的方法来迁移测试数据库,这取决于使用的是内存数据库还是传统数据库。在测试类中引用这个trait,一切都将处理：

</pre><textarea>
namespace Tests\Feature;
use Illuminate\Foundation\Testing\RefreshDatabase;
use Illuminate\Foundation\Testing\WithoutMiddleware;
use Tests\TestCase;
class ExampleTest extends TestCase {
  use RefreshDatabase;
  public function testBasicExample() {  // 一个基本的功能测试示例
    $response = $this->get('/');
    // ...
  }
}

</textarea>
</div>

<div id="redis">
<h4>redis</h4><pre>
laravel的Redis配置文件都在config/database.php中,默认使用phpredis扩展

</pre>在Redis配置文件中使用clusters键来定义Redis服务器集群<textarea>
'redis' => [
  'client' => env('REDIS_CLIENT', 'phpredis'),
  'clusters' => [
    'default' => [
      [
        'host' => env('REDIS_HOST', 'localhost'),
        'password' => env('REDIS_PASSWORD', null),
        'port' => env('REDIS_PORT', 6379),
        'database' => 0,
      ],
    ],
  ],
],

</textarea>默认集群可以在节点上实现客户端分片,允许实现节点池及创建大量可用内存。客户端共享不会处理失败的情况;因此这个功能主要适用于从另一个主数据库获取的缓存数据。如果要使用Redis原生集群,需要在配置文件下的options键中做出如下指定<textarea>

'redis' => [
  'client' => env('REDIS_CLIENT', 'phpredis'),
  'options' => [
    'cluster' => env('REDIS_CLUSTER', 'redis'),
  ],
  'clusters' => [
    // ...
  ],
],

</textarea>Redis facade支持动态方法,可以在facade上调用各种Redis命令,命令将直接传递给Redis<textarea>
public function showProfile($id){
  $user = Redis::get('user:profile:'.$id);
  Redis::set('name', 'Taylor');
  $values = Redis::lrange('names', 5, 10);
  $values = Redis::command('lrange', ['name', 5, 10]);
  return view('user.profile', ['user' => $user]);
}

</textarea>使用多个Redis连接<textarea>
$redis = Redis::connection();
$redis = Redis::connection('my-connection');

管道命令,在一个操作中给服务器发送很多命令
Redis::pipeline(function ($pipe) {
  for ($i = 0; $i < 1000; $i++) {
    $pipe->set("key:$i", $i);
  }
});

</textarea><pre>
发布与订阅
Laravel为Redis的publish及subscribe提供了方便的接口。这些Redis命令让你可以监听指定频道上的消息。可以从另一个应用程序发布消息给另一个应用程序,甚至使用其它编程语言,让应用程序和进程之间能够轻松进行通信。
首先使用subscribe方法设置频道监听器,将这个方法调用放在Artisan命令中,因为调用subscribe方法会启动一个长时间运行的进程：

</textarea><textarea>
namespace App\Console\Commands;
use Illuminate\Console\Command;
use Illuminate\Support\Facades\Redis;
class RedisSubscribe extends Command{
  protected $signature = 'redis:subscribe';  // 控制台命令的名称和签名,@var string
  protected $description = 'Subscribe to a Redis channel';  // 控制台命令说明,@var string

  // 执行控制台命令,@return mixed
  public function handle(){
    Redis::subscribe(['test-channel'], function ($message) {
      echo $message;
    });
  }
}
现在可以使用publish方法将消息发布到频道：
Route::get('publish', function () {
  // 路由...
  Redis::publish('test-channel', json_encode(['foo' => 'bar']));
});

通配符订阅
使用psubscribe方法能够订阅一个通配符频道,可以用来从所有频道上获取所有的消息,$channel名称将作为第二个参数传递给提供的回调闭包
Redis::psubscribe(['*'], function ($message, $channel) { echo $message; });
Redis::psubscribe(['users.*'], function ($message, $channel) { echo $message; });

</textarea>
</div>

<div id="orm">
<h3>Eloquent ORM</h3><pre>
Laravel的Eloquent ORM提供了一个漂亮、简洁的ActiveRecord实现来和数据库交互,每个数据库表都有一个对应的模型用来与该表交互,可以通过模型查询数据表中的数据及在数据表中插入新记录

【 模型定义 】
创建一个Eloquent模型,模型通常在app目录中,但可根据composer.json文件将他们放置在可被自动加载的任意位置,所有的Eloquent模型都继承至Illuminate\Database\Eloquent\Model类

php artisan make:model Flight              // 创建模型
php artisan make:model Flight --migration  // 在生成模型的时候生成数据库迁移
php artisan make:model Flight -m           // 在生成模型的时候生成数据库迁移

<pre><textarea>
namespace App;
use Illuminate\Database\Eloquent\Model;
class Flight extends Model{         // Flight模型对应flights数据库表,使用类的复数形式蛇形命名来作为表名
  protected $table = 'my_flights';  // 自定义数据表名
  protected $primaryKey = 'flight_id';  // 默认每个数据表都有一个名为id的主键列,可自定义
  public $incrementing = false;         // 默认主键是一个自增的整数值,即主键会自动转换为int类型
  protected $keyType = 'string';        // 如果主键不是一个整数需要将模型上受保护的$keyType属性设置为string
  public $timestamps = false;           // 默认数据表中存在created_at和updated_at
  protected $dateFormat = 'U';          // 自定义时间戳的格式,$dateFormat决定日期属性在数据库的存储方式,以及模型序列化为数组或JSON的格式
  const CREATED_AT = 'creation_date';   // 自定义存储时间戳的字段名
  const UPDATED_AT = 'last_update';
  protected $connection = 'connection-name';        // 默认使用应用程序配置的默认数据库连接,可指定一个不同的连接
  protected $attributes = [ 'delayed' => false, ];  // 为模型的某些属性定义默认值
}

</textarea>

<h4>模型检索</h4><pre>
$flights = App\Flight::all();
foreach ($flights as $flight) {
  echo $flight->name;
}

集合: Eloquent的all和get方法可以查询到多个结果,返回一个Illuminate\Database\Eloquent\Collection实例,Collection类提供了大量的辅助函数来处理Eloquent结果
$flights = $flights->reject(function ($flight) {
  return $flight->cancelled;
});
foreach ($flights as $flight) {  像数组一样遍历集合
  echo $flight->name;
}

每个Eloquent模型都充当一个查询构造器,所以可使用查询构造器可用的所有方法,也可以添加查询条件,然后使用get方法获取查询结果
$flights = App\Flight::where('active', 1)->orderBy('name', 'desc')->take(10)->get();

重新加载模型,fresh()重新从数据库中检索模型,现有的模型实例不受影响
$flight = App\Flight::where('number', 'FR 900')->first();
$freshFlight = $flight->fresh();

重新加载模型,refresh方法使用数据库中的新数据重新赋值现有模型。此外,已经加载的关系会被重新加载
$flight = App\Flight::where('number', 'FR 900')->first();
$flight->number = 'FR 456';
$flight->refresh();
$flight->number; // "FR 900"

分块结果
如果需要处理大型结果集处理数以千计的Eloquent结果使用chunk命令可以节省内存,chunk方法会检索Eloquent模型中的分块,将他们提供给指定的Closure处理
Flight::chunk(200, function ($flights) {
  foreach ($flights as $flight) { }
});

使用游标
cursor方法允许使用游标遍历数据库,它只执行一次查询,处理大量的数据时cursor方法可以大大减少内存的使用量
foreach (Flight::where('foo', 'bar')->cursor() as $flight) { }

cursor返回的Illuminate\Support\LazyCollection实例允许使用Laravel集合中大多数集合方法,而且每次只会加载单个模型到内存中：
$users = App\User::cursor()->filter(function ($user) {
  return $user->id > 500;
});
foreach ($users as $user) {
  echo $user->id;
}

Select子查询
Eloquent提供了高级子查询支持,可以用单条查询语句从相关表中提取信息

// 使用子查询功能提供的select和addSelect方法可以用单条语句查询全部目的地destinations及抵达各目的地最后一班飞机的名称
use App\Destination;  // 目的地表
use App\Flight;       // 到目的地的航班表flights包含arrival_at字段表示航班何时到达目的地
return Destination::addSelect([
  'last_flight' => Flight::select('name')->whereColumn('destination_id', 'destinations.id')->orderBy('arrived_at', 'desc')->limit(1)
])->get();

根据子查询进行排序
查询构建器的orderBy函数也支持子查询,可以使用此功能根据最后一班航班到达目的地的时间对所有目的地排序,同样这可以只对数据库执行单个查询：
return Destination::orderByDesc(
  Flight::select('arrived_at')->whereColumn('destination_id', 'destinations.id')->orderBy('arrived_at', 'desc')->limit(1)
)->get();

检索单个模型/集合
除了从指定的数据表检索所有记录外,可以使用find、first或firstWhere方法来检索单条记录,这些方法返回单个模型实例,而不是返回模型集合：

$flight = App\Flight::find(1);  // 通过主键查找一个模型
$flight = App\Flight::where('active', 1)->first();  // 查找符合查询条件的首个模型
$flight = App\Flight::firstWhere('active', 1);  // 查找符合查询条件的首个模型的快速实现
$flights = App\Flight::find([1, 2, 3]);  // 使用主键数组作为参数调用find方法,它将返回匹配记录的集合

$model = App\Flight::where('legs', '>', 100)->firstOr(function () {
  // 在查找首个结果但找不到值时执行其他动作,firstOr将会在查找到结果时返回首个结果,如果没有结果将会执行给定的回调。回调的返回值将会作为firstOr方法的返回值
});

$model = App\Flight::where('legs', '>', 100)->firstOr(['id', 'legs'], function () {
  // firstOr方法同样接受栏位数组来查询
});

未找到的异常
findOrFail和firstOrFail方法会检索查询的第一个结果,如果未找到将抛出Illuminate\Database\Eloquent\ModelNotFoundException异常,在控制器和路由中非常有用
$model = App\Flight::findOrFail(1);
$model = App\Flight::where('legs', '>', 100)->firstOrFail();

如果没有捕获异常则会自动返回404响应给用户
Route::get('/api/flights/{id}', function ($id) {
  return App\Flight::findOrFail($id);
});

检索集合
还可以使用查询构造器提供的count、sum和max方法和其他的集合函数操作集合,这些方法只会返回适当的标量值而不是一个模型实例：
$count = App\Flight::where('active', 1)->count();
$max = App\Flight::where('active', 1)->max('price');

Route::get('test', function(Illuminate\Http\Request $request){
  dump(App\User::where('id', '>=', '1')->count());
	return view('test.child');
})->name('test');

</pre>

<h4>插入及更新模型</h4><pre>
save()插入
要往数据库新增一条记录,先创建新模型实例,给实例设置属性,然后调用save方法,created_at和updated_at时间戳自动设置

</pre><textarea>
namespace App\Http\Controllers;
use App\Http\Controllers\Controller;
use App\Flight;
use Illuminate\Http\Request;
class FlightController extends Controller{
  public function store(Request $request){  // 创建一个新的航班实例
    // 验证请求
    $flight = new Flight;
    $flight->name = $request->name;
    $flight->save();
  }
}

</textarea><pre>
save()更新
更新数据库已经存在的模型,需要先检索出来,设置要更新的属性,然后调用save方法,updated_at时间戳自动更新
$flight = App\Flight::find(1);
$flight->name = 'New Flight Name';
$flight->save();

批量更新
通过Eloquent批量更新时更新的模型不会触发saving、saved、updating和updated模型事件,这是因为在批量更新时实际上从未检索模型
App\Flight::where('active', 1)->where('destination', 'San Diego')->update(['delayed' => 1]);  // 更新匹配查询条件的多个模型,更新delayed字段

检查属性变化
Eloquent提供isDirty,isClean和wasChanged方法检查模型的内部状态并确定其属性从最初加载时如何变化。
isDirty方法确定自加载模型以来是否已更改任何属性,可以传递特定的属性名称来确定特定的属性是否变脏。isClean方法与isDirty相反,也接受可选的属性参数：
$user = User::create([ 'first_name' => 'Taylor', 'last_name' => 'Otwell', 'title' => 'Developer', ]);
$user->title = 'Painter';
$user->isDirty();             // true
$user->isDirty('title');      // true
$user->isDirty('first_name'); // false
$user->isClean();             // false
$user->isClean('title');      // false
$user->isClean('first_name'); // true
$user->save();
$user->isDirty(); // false
$user->isClean(); // true

wasChanged方法确定在当前请求周期内最后一次保存模型时是否更改了任何属性,还可以传递属性名称以查看特定属性是否已更改：
$user = User::create([ 'first_name' => 'Taylor', 'last_name' => 'Otwell', 'title' => 'Developer', ]);
$user->title = 'Painter';
$user->save();
$user->wasChanged(); // true
$user->wasChanged('title'); // true
$user->wasChanged('first_name'); // false

批量赋值
使用create方法来保存新模型插入新数据到数据库中,返回保存的模型实例,不过使用前要在模型上指定fillable或guarded属性,因为所有的Eloquent模型都默认不可进行批量赋值。
当用户通过请求传入意外的HTTP参数,并且该参数更改了数据库中不需要更改的字段时就会发生批量赋值漏洞。 比如恶意用户可能会通过HTTP请求传入is_admin参数,然后将其传给 create方法,此操作能让用户将自己升级成管理员,所以在开始之前应该定义好模型上的哪些属性是可以被批量赋值的,可以通过模型上的$fillable属性来实现

class Flight extends Model{
  protected $fillable = ['name'];  // 让Flight模型的name属性可以被批量赋值
}
$flight = App\Flight::create(['name' => 'Flight 10']);
$flight->fill(['name' => 'Flight 22']);  // 向模型实例传递一个数组给fill方法来赋值

保护属性
$fillable可以看作批量赋值的白名单, 也可以使用$guarded属性来实现。$guarded属性包含的是不允许批量赋值的数组, 从功能上将更像是一个黑名单,只能使用$fillable或$guarded二者中的一个,不可同时使用
class Flight extends Model{
  protected $guarded = ['price'];  // price属性之外的所有属性都可以进行批量赋值
  protected $guarded = [];         // 让所有属性都可以批量赋值
}

firstOrCreate/firstOrNew
两个用来批量赋值的方法
firstOrCreate方法通过给定的键值对来匹配数据库中的数据,如果在数据库中找不到模型则将插入一条记录,其中包含第一个参数的属性及可选的第二个参数的属性。
firstOrNew方法像firstOrCreate方法一样尝试通过给定的属性查找数据库中的记录,不过如果firstOrNew方法找不到对应的模型会返回一个新的模型实例,返回的模型实例尚未保存到数据库中,需要手动调用save方法来保存

$flight = App\Flight::firstOrCreate(['name' => 'Flight 10']);  // 通过name检索航班,不存在则创建
$flight = App\Flight::firstOrCreate(                           // 通过name检索航班,或使用name和delayed属性和arrival_time属性创建
  ['name' => 'Flight 10'],
  ['delayed' => 1, 'arrival_time' => '11:30']
);

$flight = App\Flight::firstOrNew(['name' => 'Flight 10']);     // 通过name检索航班,不存在则创建一个实例
$flight = App\Flight::firstOrNew(                              // 通过name检索航班,或使用name和delayed属性和arrival_time属性创建一个模型实例
  ['name' => 'Flight 10'],
  ['delayed' => 1, 'arrival_time' => '11:30']
);

updateOrCreate
更新现有模型或在不存在的情况下则创建新的模型的情景,updateOrCreate类似于firstOrCreate方法,updateOrCreate持久化模型,因此无需调用save()
$flight = App\Flight::updateOrCreate(  // 如果有从奥克兰到圣地亚哥的航班则价格定为99美元,如果没匹配到存在的模型则创建一个
  ['departure' => 'Oakland', 'destination' => 'San Diego'],
  ['price' => 99, 'discounted' => 1]
);

</pre>

<h4>删除模型</h4><pre>
$flight = App\Flight::find(1);
$flight->delete();  // 在模型实例上调用delete方法来删除实例

App\Flight::destroy(1);         // 通过主键直接使用destroy方法来删除模型,而不用先去数据库中查找
App\Flight::destroy(1, 2, 3);   // 多个主键
App\Flight::destroy([1, 2, 3]); // 多个主键
App\Flight::destroy(collect([1, 2, 3]));

通过查询删除模型,在模型上运行删除语句,与批量更新一样,批量删除不会为删除的模型启动任何模型事件
通过Eloquent执行批量删除语句时不会触发deleting和deleted模型事件,因此在执行删除语句时从不检索模型示例
$deletedRows = App\Flight::where('active', 0)->delete();

【 软删除 】
除了真实删除数据库记录,Eloquent也可以软删除模型。软删除的模型并不是真的从数据库中删除了,而是在模型上设置了deleted_at属性并将其值写入数据库。如果deleted_at值非空代表这个模型已被软删除。如果要开启模型软删除功能需要在模型上使用Illuminate\Database\Eloquent\SoftDeletes trait,SoftDeletes会自动将deleted_at属性转换成DateTime/Carbon实例

namespace App;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\SoftDeletes;
class Flight extends Model{
  use SoftDeletes;
}
需要把deleted_at字段添加到数据表中,Laravel的数据迁移有创建这个字段的方法：
Schema::table('flights', function (Blueprint $table) {
  $table->softDeletes();
});
那现在在模型实例上使用delete方法,当前日期时间会写入deleted_at字段,同时查询出来的结果也会自动排除已被软删除的记录。

使用trashed方法来验证给定的模型实例是否已被软删除：
if ($flight->trashed()) { }

查询软删除模型
包括已软删除的模型
查询结果会自动剔除已被软删除的结果,可以使用withTrashed方法来获取包括软删除模型在内的模型：
$flights = App\Flight::withTrashed() ->where('account_id', 1) ->get();
$flight->history()->withTrashed()->get();  // withTrashed方法也可以用在关联查询

只检索软删除模型
$flights = App\Flight::onlyTrashed() ->where('airline_id', 1) ->get();

恢复软删除模型,对软删除模型进行撤销,可恢复到有效状态：
$flight->restore();
App\Flight::withTrashed() ->where('airline_id', 1) ->restore(); // 快速恢复多个模型。和其他「批量」操作一样,这个操作不会触发模型的任何事件
$flight->history()->restore();  // 类似 withTrashed 方法,restore 方法也用在 关联 上

永久删除,从数据库中真正删除模型,从数据库中永久删除软删除的模型
$flight->forceDelete();  // 强制删除单个模型实例
$flight->history()->forceDelete();  // 强制删除所有相关模型

复制模型
使用replicate方法复制一个新的未保存到数据库的实例,当模型实例共享许多相同的属性时,这个方法非常好用

$shipping = App\Address::create([
  'type' => 'shipping',
  'line_1' => '123 Example Street',
  'city' => 'Victorville',
  'state' => 'CA',
  'postcode' => '90001',
]);
$billing = $shipping->replicate()->fill([ 'type' => 'billing' ]);
$billing->save();

</pre>

<h4>查询作用域</h4><pre>
全局作用域
全局作用域可以给模型的查询都添加上约束,软删除功能就是利用此特性从数据库中获取未删除的模型
编写全局作用域很简单,定义一个实现Illuminate\Database\Eloquent\Scope接口的类,并实现apply方法。根据需求在apply方法中加入查询的where条件：

<pre><textarea>
namespace App\Scopes;
use Illuminate\Database\Eloquent\Builder;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Scope;
class AgeScope implements Scope{
  /**
    * 把约束加到 Eloquent 查询构造中。
    * @param  \Illuminate\Database\Eloquent\Builder  $builder
    * @param  \Illuminate\Database\Eloquent\Model  $model
    * @return void
    */
  public function apply(Builder $builder, Model $model){
    $builder->where('age', '>', 200);
  }
}

</textarea>应用全局作用域,将全局作用域分配给模型,需要重写模型的booted方法并使用addGlobalScope方法<textarea>
namespace App;
use App\Scopes\AgeScope;
use Illuminate\Database\Eloquent\Model;
class User extends Model {
  protected static function booted(){
    static::addGlobalScope(new AgeScope);
  }
}

</textarea><pre>
添加作用域后对User::all()的查询会生成以下SQL查询语句：
select * from `users` where `age` > 200

匿名全局作用域
Eloquent同样允许使用闭包定义全局作用域,这样就不需要为一个简单的作用域而编写一个单独的类：

</pre><textarea>
namespace App;
use Illuminate\Database\Eloquent\Builder;
use Illuminate\Database\Eloquent\Model;
class User extends Model{
  protected static function booted(){
    static::addGlobalScope('age', function (Builder $builder) {
      $builder->where('age', '>', 200);
    });
  }
}

</textarea><pre>
取消全局作用域
如果需要对当前查询取消全局作用域需要使用withoutGlobalScope方法
User::withoutGlobalScope(AgeScope::class)->get();  // 仅接受全局作用域类名作为它唯一的参数
User::withoutGlobalScope('age')->get();  // 使用闭包定义全局作用域
User::withoutGlobalScopes()->get();  // 取消所有的全局作用域
User::withoutGlobalScopes([ FirstScope::class, SecondScope::class ])->get();  // 取消部分全局作用域

本地作用域
本地作用域允许定义通用的约束集合以便在应用程序中重复使用,例如可能经常需要获取所有流行的用户,定义这样一个范围只需要在对应的Eloquent模型方法前添加scope前缀。
作用域总是返回一个查询构造器实例：

</pre><textarea>
namespace App;
use Illuminate\Database\Eloquent\Model;
class User extends Model{
  /**
    * 只查询受欢迎的用户的作用域
    * @param  \Illuminate\Database\Eloquent\Builder  $query
    * @return \Illuminate\Database\Eloquent\Builder
    */
  public function scopePopular($query){
    return $query->where('votes', '>', 100);
  }

  /**
    * 只查询 active 用户的作用域
    * @param  \Illuminate\Database\Eloquent\Builder  $query
    * @return \Illuminate\Database\Eloquent\Builder
    */
  public function scopeActive($query){
    return $query->where('active', 1);
  }
}

</textarea><pre>
使用本地作用域
一旦定义了作用域就可以在查询该模型时调用作用域方法。不过在调用这些方法时不必包含scope前缀,甚至可以链式调用多个作用域
$users = App\User::popular()->active()->orderBy('created_at')->get();

借助or查询运行符整合多个Eloquent模型可能需要使用闭包回调：
$users = App\User::popular()->orWhere(function (Builder $query) {
    $query->active();
})->get();

因为这样可能会有点麻烦,Laravel提供了更高阶的orWhere 方法,它允许在链式调用作用域时不使用闭包：
$users = App\User::popular()->orWhere->active()->get();

动态作用域
有时可能地希望定义一个可以接受参数的作用域,把额外参数传递给作用域就可以达到此目的,作用域参数要放在$query参数之后：

</pre><textarea>
namespace App;
use Illuminate\Database\Eloquent\Model;
class User extends Model{
  /**
    * 将查询作用域限制为仅包含给定类型的用户
    * @param  \Illuminate\Database\Eloquent\Builder  $query
    * @param  mixed  $type
    * @return \Illuminate\Database\Eloquent\Builder
    */
  public function scopeOfType($query, $type){
    return $query->where('type', $type);
  }
}
$users = App\User::ofType('admin')->get();  // 这样就可以在调用作用域时传递参数了

</textarea><pre>
【 模型比较 】
判断两个模型是否相同,is方法可以用来快速校验两个模型是否拥有相同的主键、表和数据库连接：
if ($post->is($anotherPost)) {}

</pre>

<h4>模型事件</h4><pre>
Eloquent模型触发几个事件,允许挂接到模型生命周期的如下节点： retrieved、creating、created、updating、updated、saving、saved、deleting、deleted、restoring和restored。事件允许每当特定模型保存或更新数据库时执行代码,每个事件通过其构造器接受模型实例

retrieved事件在现有模型从数据库中查找数据时触发。当新模型每一次保存时creating和created事件被触发。如果数据库中已经存在模型并且调用了save方法时updating / updated事件被触发。这些情况下saving / saved事件也被触发。
通过Eloquent进行批量更新时,被更新模型的saved和updated, deleting和deleted事件不会被触发,这是因为批量更新时,并没有真的获取模型。

</pre>首先在Eloquent模型上定义$dispatchesEvents属性,将Eloquent模型生命周期的几个节点映射到自己的event类,定义并映射了Eloquent事件就可以使用事件监听处理这些事件了<textarea>
namespace App;
use App\Events\UserDeleted;
use App\Events\UserSaved;
use Illuminate\Foundation\Auth\User as Authenticatable;
class User extends Authenticatable{
    use Notifiable;

    // 模型的事件映射,@var array
    protected $dispatchesEvents = [
      'saved' => UserSaved::class,
      'deleted' => UserDeleted::class,
    ];
}

</textarea><pre>
使用闭包
可以注册在触发各种模型事件时执行的闭包,而不使用自定义事件类,通常应该在模型的booted方法中注册这些闭包：

</pre><textarea>
namespace App;
use App\Scopes\AgeScope;
use Illuminate\Database\Eloquent\Model;
class User extends Model{
  // The "booted" method of the model. @return void
  protected static function booted(){
    static::created(function ($user) {
        //
    });
  }
}

</textarea><pre>
【 观察者 】
定义观察者
如果在一个模型上监听了多个事件,可以使用观察者来将这些监听器组织到一个单独的类中。观察者类的方法名映射到希望监听的Eloquent事件,这些方法都以模型作为其唯一参数。
make:observer Artisan命令可以快速建立新的观察者类：
php artisan make:observer UserObserver --model=User
此命令将在App/Observers文件夹放置新的观察者类,如果这个目录不存在Artisan将创建

</pre><textarea>
开启观察者
namespace App\Observers;
use App\User;
class UserObserver{
  public function created(User $user){ }        // 处理Usercreated事件
  public function updated(User $user){ }        // 处理Userupdated事件
  public function deleted(User $user){ }        // 处理Userdeleted事件
  public function forceDeleted(User $user) { }  // 处理UserforceDeleted事件
}

在希望观察的模型上使用observe方法注册观察者,也可以在服务提供者的boot方法注册观察者
namespace App\Providers;
use App\Observers\UserObserver;
use App\User;
use Illuminate\Support\ServiceProvider;
class AppServiceProvider extends ServiceProvider{
  // 注册服务提供者,@return void
  public function register(){ }

  // 引导应用程序服,@return void
  public function boot(){
    User::observe(UserObserver::class);
  }
}

</textarea>

<h4>模型关联</h4><pre>
数据库表通常相互关联,例如一篇博客文章可能有许多评论,或者一个订单对应一个下单用户。Eloquent让这些关联的管理和使用变得简单,并支持多种类型的关联:
一对一
一对多
多对多
远程一对一
远程一对多
一对一(多态关联)
一对多(多态关联)
多对多(多态关联)

定义关联
Eloquent关联在Eloquent模型类中以方法的形式呈现。如同Eloquent模型本身,关联也可以作为强大的查询语句构造器使用,提供了强大的链式调用和查询功能。例如可以在posts关联的链式调用中附加一个约束条件：
$user->posts()->where('active', 1)->get();

关系名称不能与属性名称冲突,因为这会导致模型不知道要解析哪一个

【 一对一 】
一个User模型可能关联一个Phone模型,要在User模型中写一个phone方法定义这个关联,在phone方法内部调用hasOne方法并返回其结果

</pre><textarea>
namespace App;
use Illuminate\Database\Eloquent\Model;
class User extends Model{
  public function phone(){              // 获取与用户相关的电话记录
    return $this->hasOne('App\Phone');  // 基于模型名决定外键名称。在这种情况下会自动假设Phone模型有user_id外键
    return $this->hasOne('App\Phone', 'foreign_key');  // 第一个参数是关联模型的类名,第二个参数给hasOne方法来自定义外键
    return $this->hasOne('App\Phone', 'foreign_key', 'local_key'); // Eloquent假设外键的值是与父级id或自定义$primaryKey列的值相匹配的,即Eloquent将会在Phone记录的user_id列中查找与用户表的id列相匹配的值。如果希望该关联使用id以外的自定义键名则可以给hasOne方法传递第三个参数
  }
}

</textarea><pre>
一旦定义了模型关联就可以使用Eloquent的动态属性获得相关的记录,动态属性允许访问关联方法就像访问模型中定义的属性一样：
$phone = User::find(1)->phone;

定义反向关联
已经能从User模型访问到Phone模型了,再在Phone模型上定义一个关联,这个关联能让访问到拥有该电话的User模型。可以使用与hasOne方法对应的belongsTo方法来定义反向关联：

</pre><textarea>
namespace App;
use Illuminate\Database\Eloquent\Model;
class Phone extends Model{
  public function user(){  // 获取拥有此电话的用户
    return $this->belongsTo('App\User');
    return $this->belongsTo('App\User', 'foreign_key');  // Eloquent尝试匹配Phone模型上的user_id至User模型上的id,它是通过检查关系方法的名称并使用_id作为后缀名来确定默认外键名称的。但如果Phone模型的外键不是user_id,那么可以将自定义键名作为第二个参数传递给belongsTo方法
    return $this->belongsTo('App\User', 'foreign_key', 'other_key');  // 如果父级模型没有使用 id 作为主键,或者是希望用不同的字段来连接子级模型,则可以通过给 belongsTo 方法传递第三个参数的形式指定父级数据表的自定义键
  }
}

</textarea><pre>
【 一对多 】
一对多关联用于定义单个模型拥有任意数量的其它关联模型,例如一篇博客文章可能会有无限多条评论

</pre><textarea>
namespace App;
use Illuminate\Database\Eloquent\Model;
class Post extends Model{
  public function comments() {  // 获取博客文章的评论
    return $this->hasMany('App\Comment');
  }
}

</textarea><pre>
Eloquent将会自动确定Comment模型的外键属性。按照约定Eloquent将会使用所属模型名称的snake case形式,再加上_id后缀作为外键字段。因此在上面这个例子中Eloquent将假定Comment对应到Post模型上的外键就是post_id

一旦关系被定义好以后就可以通过访问Post模型的comments属性来获取评论的集合,由于Eloquent提供了动态属性,所以可以像访问模型的属性一样访问关联方法：
$comments = App\Post::find(1)->comments;
foreach ($comments as $comment) { }

由于所有的关联还可以作为查询语句构造器使用,因此可以使用链式调用的方式在comments方法上添加额外的约束条件：
$comment = App\Post::find(1)->comments()->where('title', 'foo')->first();

正如hasOne方法一样,也可以在使用hasMany方法时通过传递额外参数来覆盖默认使用的外键与本地键：
return $this->hasMany('App\Comment', 'foreign_key');
return $this->hasMany('App\Comment', 'foreign_key', 'local_key');

一对多 (反向)
现在已经能获得一篇文章的所有评论,接着再定义一个通过评论获得所属文章的关联关系。这个关联是hasMany关联的反向关联,需要在子级模型中使用belongsTo方法定义它：

</pre><textarea>
namespace App;
use Illuminate\Database\Eloquent\Model;
class Comment extends Model{
  public function post() {  // 获取此评论所属文章
    return $this->belongsTo('App\Post');
    return $this->belongsTo('App\Post', 'foreign_key');  // Eloquent会尝试用Comment模型的post_id与Post模型的id进行匹配。默认外键名是Eloquent依据关联名,并在关联名后加上_再加上主键字段名作为后缀确定的。当然,如果Comment 模型的外键不是post_id ,那么可以将自定义键名作为第二个参数传递给 belongsTo 方法
    return $this->belongsTo('App\Post', 'foreign_key', 'other_key');  // 如果父级模型没有使用 id 作为主键,或者是希望用不同的字段来连接子级模型,则可以通过给 belongsTo 方法传递第三个参数的形式指定父级数据表的自定义键
  }
}

</textarea><pre>
这个关系定义好以后就可以通过访问Comment模型的post这个动态属性来获取关联的Post模型了
$comment = App\Comment::find(1);
echo $comment->post->title;

【 多对多 】
一个用户可以拥有很多种角色,同时这些角色也被其他用户共享,许多用户可能都有管理员角色。

要定义这种关联,需要三个数据库表users ,roles和role_user。role_user表的命名是由关联的两个模型按照字母顺序来的,并且包含了user_id和role_id字段：
users: id - integer name - string
roles: id - integer name - string
role_user: user_id - integer role_id - integer

模型结构
多对多关联通过调用belongsToMany这个内部方法返回的结果来定义,例如在User模型中定义roles方法：

</pre><textarea>
namespace App;
use Illuminate\Database\Eloquent\Model;
class User extends Model{
    public function roles() {   // 用户拥有的角色
        return $this->belongsToMany('App\Role');
    }
}

</textarea><pre>
一旦关联关系被定义后可以通过roles动态属性获取用户角色：
$user = App\User::find(1);
foreach ($user->roles as $role) { }

像其它所有关联模型一样,可以使用roles方法利用链式调用对查询语句添加约束条件
$roles = App\User::find(1)->roles()->orderBy('name')->get();

为了确定关联连接表的表名,Eloquent 会按照字母顺序连接两个关联模型的名字。当然,你也可以不使用这种约定,传递第二个参数到 belongsToMany 方法即可：
return $this->belongsToMany('App\Role', 'role_user');
除了自定义连接表的表名,你还可以通过传递额外的参数到 belongsToMany 方法来定义该表中字段的键名。第三个参数是定义此关联的模型在连接表里的外键名,第四个参数是另一个模型在连接表里的外键名：
return $this->belongsToMany('App\Role', 'role_user', 'user_id', 'role_id');

定义反向关联
要定义多对多的反向关联,只需要在关联模型中调用belongsToMany方法。在 Role 模型中定义 users 方法：

</pre><textarea>
namespace App;
use Illuminate\Database\Eloquent\Model;
class Role extends Model{
    public function users() {   // 拥有此角色的用户
        return $this->belongsToMany('App\User');
    }
}

</textarea><pre>
除了引入模型为App\User外,其它与在User模型中定义的完全一样。由于重用了belongsToMany方法,自定义连接表表名和自定义连接表里的键的字段名称在这里同样适用。

获取中间表字段
多对多的关联关系需要一个中间表来提供支持, Eloquent提供了一些有用的方法来和这张表进行交互。例如假设User对象关联了多个Role对象。在获得这些关联对象后可以使用模型的pivot属性访问中间表的数：

$user = App\User::find(1);
foreach ($user->roles as $role) {
  echo $role->pivot->created_at;
}

获取的每个Role模型对象都会被自动赋予pivot属性,它代表中间表的一个模型对象,并且可以像其他的 Eloquent 模型一样使用。

默认pivot对象只包含两个关联模型的主键,如果中间表里还有其他额外字段,必须在定义关联时明确指出：
return $this->belongsToMany('App\Role')->withPivot('column1', 'column2');

return $this->belongsToMany('App\Role')->withTimestamps();  // 让中间表自动维护created_at 和 updated_at时间戳

自定义pivot属性名称
来自中间表的属性可以使用pivot属性访问,但可以自由定制此属性的名称,以便更好的反应其在应用中的用途。
例如应用中包含可能订阅的用户,则用户与博客之间可能存在多对多的关系,可能希望将中间表访问器命名为 subscription 取代 pivot,这可以在定义关系时使用 as 方法完成：
return $this->belongsToMany('App\Podcast') ->as('subscription') ->withTimestamps();
一旦定义完成可以使用自定义名称访问中间表数据：
$users = User::with('podcasts')->get();
foreach ($users->flatMap->podcasts as $podcast) {
  echo $podcast->subscription->created_at;
}

通过中间表过滤关系
在定义关系时还可以使用 wherePivot 和 wherePivotIn 方法来过滤 belongsToMany 返回的结果：
return $this->belongsToMany('App\Role')->wherePivot('approved', 1);
return $this->belongsToMany('App\Role')->wherePivotIn('priority', [1, 2]);
return $this->belongsToMany('App\Role')->wherePivotNotIn('priority', [1, 2]);

定义中间表模型
如果想定义一个自定义模型来表示关联关系中的中间表,可以在定义关联时调用 using 方法。自定义多对多中间表模型都必须扩展自 Illuminate\Database\Eloquent\Relations\Pivot 类,自定义多对多(多态)中间表模型必须继承 Illuminate\Database\Eloquent\Relations\MorphPivot 类。例如在写 Role 模型的关联时,使用自定义中间表模型 RoleUser:

</pre><textarea>
namespace App;
use Illuminate\Database\Eloquent\Model;
class Role extends Model{
  public function users(){  // 拥有此角色的所有用户
    return $this->belongsToMany('App\User')->using('App\RoleUser');
  }
}

</textarea><pre>
当定义 RoleUser 模型时要扩展 Pivot 类：
namespace App;
use Illuminate\Database\Eloquent\Relations\Pivot;
class RoleUser extends Pivot{ }

可以组合使用 using 和 withPivot 从中间表来检索列。例如,通过将列名传递给 withPivot 方法,就可以从 UserRole 中间表中检索出 created_by 和 updated_by 两列数据:

</pre><textarea>
namespace App;
use Illuminate\Database\Eloquent\Model;
class Role extends Model{
  public function users(){  // 拥有此角色的用户
    return $this->belongsToMany('App\User') ->using('App\RoleUser') ->withPivot([ 'created_by', 'updated_by', ]);
  }
}

</textarea><pre>
Pivot 模型可能不使用 SoftDeletes 特性。 如果您需要软删除数据关联记录,请考虑将您的数据关联模型转换为实际的 Eloquent 模型。

带有递增 ID 的自定义中继模型
如果你用一个自定义的中继模型定义了多对多的关系,而且这个中继模型拥有一个自增的主键,你应当确保这个自定义中继模型类中定义了一个 incrementing 属性其值为 true 。
public $incrementing = true;  // 标识 ID 是否自增

【 远程一对一关系 】
远程一对一关联通过一个中间关联模型实现。
例如,如果每个供应商都有一个用户,并且每个用户与一个用户历史记录相关联,那么供应商可以通过用户访问用户的历史记录,让我们看看定义这种关系所需的数据库表：

users： id - integer supplier_id - integer
suppliers： id - integer
history： id - integer user_id - integer

虽然 history 表不包含 supplier_id ,但 hasOneThrough 关系可以提供对用户历史记录的访问,以访问供应商模型。现在我们已经检查了关系的表结构,让我们在 Supplier 模型上定义相应的方法：

</pre><textarea>
namespace App;
use Illuminate\Database\Eloquent\Model;
class Supplier extends Model{
  public function userHistory() {   // 用户的历史记录
    return $this->hasOneThrough('App\History', 'App\User');
  }
}

</textarea><pre>
传递给 hasOneThrough 方法的第一个参数是希望访问的模型名称,第二个参数是中间模型的名称。

当执行关联查询时,通常会使用 Eloquent 约定的外键名。如果你想要自定义关联的键,可以通过给 hasOneThrough 方法传递第三个和第四个参数实现,第三个参数表示中间模型的外键名,第四个参数表示最终模型的外键名。第五个参数表示本地键名,而第六个参数表示中间模型的本地键名：

</pre><textarea>
class Supplier extends Model{
  public function userHistory() {    // 用户的历史记录
    return $this->hasOneThrough(
      'App\History',
      'App\User',
      'supplier_id', // Foreign key on users table...
      'user_id', // Foreign key on history table...
      'id', // Local key on suppliers table...
      'id' // Local key on users table...
    );
  }
}

</textarea><pre>
【 远程一对多关联 】
远程一对多关联提供了方便简短的方式通过中间的关联来获得远层的关联。例如一个Country模型可以通过中间的User模型获得多个Post模型,可以轻易地收集给定国家的所有博客文章

定义这种关联所需的数据表：
countries: id - integer name - string
users: id - integer country_id - integer name - string
posts: id - integer user_id - integer title - string

虽然 posts 表中不包含 country_id 字段,但 hasManyThrough 关联能让我们通过 $country->posts 访问到一个国家下所有的用户文章。为了完成这个查询,Eloquent 会先检查中间表 users 的 country_id 字段,找到所有匹配的用户 ID 后,使用这些 ID,在 posts 表中完成查找。

现在,我们已经知道了定义这种关联所需的数据表结构,接下来,让我们在 Country 模型中定义它：

</pre><textarea>
namespace App;
use Illuminate\Database\Eloquent\Model;
class Country extends Model{
  public function posts(){  // 当前国家所有文章
    return $this->hasManyThrough('App\Post', 'App\User');
  }
}

</textarea><pre>
hasManyThrough 方法的第一个参数是我们最终希望访问的模型名称,而第二个参数是中间模型的名称。

当执行关联查询时,通常会使用 Eloquent 约定的外键名。如果你想要自定义关联的键,可以通过给 hasManyThrough 方法传递第三个和第四个参数实现,第三个参数表示中间模型的外键名,第四个参数表示最终模型的外键名。第五个参数表示本地键名,而第六个参数表示中间模型的本地键名：

</pre><textarea>
class Country extends Model{
    public function posts()    {
        return $this->hasManyThrough(
            'App\Post',
            'App\User',
            'country_id', // 国家表外键...
            'user_id', // 用户表外键...
            'id', // 国家表本地键...
            'id' // 用户表本地键...
        );
    }
}

</textarea><pre>
【 多态关联 】
多态关联允许目标模型借助单个关联从属于多个模型。

一对一 (多态)

表结构
一对一多态关联与简单的一对一关联类似;不过,目标模型能够在一个关联上从属于多个模型。例如,博客 Post 和 User 可能共享一个关联到 Image 模型的关系。使用一对一多态关联允许使用一个唯一图片列表同时用于博客文章和用户账户。让我们先看看表结构：

posts: id - integer name - string
users: id - integer name - string
images: id - integer url - string imageable_id - integer imageable_type - string
    
imageable_id 列包含文章或用户的 ID 值,而imageable_type列包含的则是父模型的类名。Eloquent 在访问 imageable 时使用 imageable_type 列来判断父模型的 「类型」。

模型结构
建立关联的模型定义：

</pre><textarea>
namespace App;
use Illuminate\Database\Eloquent\Model;
class Image extends Model{
    public function imageable() {  // 获取拥有此图片的模型
        return $this->morphTo();
    }
}

class Post extends Model{
    public function image() {  // 获取文章图片
        return $this->morphOne('App\Image', 'imageable');
    }
}

class User extends Model{
    public function image() {   // 获取用户图片
        return $this->morphOne('App\Image', 'imageable');
    }
}

</textarea><pre>
获取关联
一旦定义了表和模型,就可以通过模型访问此关联。比如,要获取文章图片,可以使用 image 动态属性：
$post = App\Post::find(1);
$image = $post->image;

还可以通过访问执行 morphTo 调用的方法名来从多态模型中获知父模型。在这个例子中,就是 Image 模型的 imageable 方法。所以,我们可以像动态属性那样访问这个方法：
$image = App\Image::find(1);
$imageable = $image->imageable;

Image 模型的 imageable 关联将返回 Post 或 User 实例,其结果取决于图片属性哪个模型。

一对多(多态)
表结构
一对多多态关联与简单的一对多关联类似;不过,目标模型可以在一个关联中从属于多个模型。假设应用中的用户可以同时 「评论」 文章和视频。使用多态关联,可以用单个 comments 表同时满足这些情况。我们还是先来看看用来构建这种关联的表结构：

posts: id - integer title - string body - text
videos: id - integer title - string url - string
comments: id - integer body - text commentable_id - integer commentable_type - string

模型结构
构建这种关联的模型定义：

</pre><textarea>
namespace App;
use Illuminate\Database\Eloquent\Model;
class Comment extends Model{
    public function commentable(){  // 获取拥有此评论的模型
        return $this->morphTo();
    }
}

class Post extends Model{
    public function comments() {  // 获取此文章的所有评论
        return $this->morphMany('App\Comment', 'commentable');
    }
}

class Video extends Model{
    public function comments() {   // 获取此视频的所有评论
        return $this->morphMany('App\Comment', 'commentable');
    }
}

</textarea><pre>
获取关联
一旦定义了数据库表和模型,就可以通过模型访问关联。例如,可以使用 comments 动态属性访问文章的全部评论：
$post = App\Post::find(1);
foreach ($post->comments as $comment) { }

还可以通过访问执行 morphTo 调用的方法名来从多态模型获取其所属模型。在本例中,就是 Comment 模型的 commentable 方法：
$comment = App\Comment::find(1);
$commentable = $comment->commentable;

Comment 模型的 commentable 关联将返回 Post 或 Video 实例,其结果取决于评论所属的模型。

多对多(多态)
表结构
多对多多态关联比 morphOne 和 morphMany 关联略微复杂一些。例如,博客 Post 和 Video 模型能够共享关联到 Tag 模型的多态关系。使用多对多多态关联允许使用一个唯一标签在博客文章和视频间共享。以下是多对多多态关联的表结构：

posts: id - integer name - string
videos: id - integer name - string
tags: id - integer name - string
taggables: tag_id - integer taggable_id - integer taggable_type - string

模型结构
接下来,在模型上定义关联。Post 和 Video 模型都有调用 Eloquent 基类上 morphToMany 方法的 tags 方法：

</pre><textarea>
namespace App;
use Illuminate\Database\Eloquent\Model;
class Post extends Model{
    public function tags() {  // 获取文章的所有标签
        return $this->morphToMany('App\Tag', 'taggable');
    }
}

</textarea><pre>
定义反向关联关系
下面,需要在 Tag 模型上为每个关联模型定义一个方法。在这个示例中,我们将会定义 posts 方法和 videos 方法：

</pre><textarea>
namespace App;
use Illuminate\Database\Eloquent\Model;
class Tag extends Model {
    public function posts() {   // 获取被打上此标签的所有文章
        return $this->morphedByMany('App\Post', 'taggable');
    }

    public function videos() {  // 获取被打上此标签的所有视频
        return $this->morphedByMany('App\Video', 'taggable');
    }
}

</textarea><pre>
获取关联
一旦定义了数据库表和模型,就可以通过模型访问关联。例如,可以使用 tags 动态属性访问文章的所有标签：
$post = App\Post::find(1);
foreach ($post->tags as $tag) { }

还可以访问执行 morphedByMany 方法调用的方法名来从多态模型获取其所属模型。在这个示例中,就是 Tag 模型的 posts 或 videos 方法。可以像动态属性一样访问这些方法：
$tag = App\Tag::find(1);
foreach ($tag->videos as $video) { }

自定义多态类型
默认Laravel使用完全限定类名存储关联模型类型。在上面的一对多示例中因为 Comment 可能从属于一个 Post 或一个 Video,默认的 commentable_type 就将分别是 App\Post 或 App\Video。不过可能希望数据库与应用的内部结构解耦。在这种情况下可以定义一个morph映射来通知Eloquent使用自定义名称代替对应的类名：
use Illuminate\Database\Eloquent\Relations\Relation;
Relation::morphMap([ 'posts' => 'App\Post', 'videos' => 'App\Video', ]);
可以在 AppServiceProvider 的 boot 函数中注册 morphMap,或者创建一个单独的服务提供者。
在现有应用程序中添morph映射时,数据库中仍包含完全限定类的每个可变形 *_type 列值都需要转换为其「映射」名称

查询关联
由于 Eloquent 关联的所有类型都通过方法定义,你可以调用这些方法,而无需真实执行关联查询。另外,所有 Eloquent 关联类型用作 查询构造器,允许你在数据库上执行 SQL 之前,持续通过链式调用添加约束。
假设一个博客系统的 User 模型有许多关联的 Post 模型：
namespace App;
use Illuminate\Database\Eloquent\Model;
class User extends Model{
  public function posts() {  // 获取该用户的所有文章
    return $this->hasMany('App\Post');
  }
}
可以查询 posts 关联,并为其添加额外的约束：
$user = App\User::find(1);
$user->posts()->where('active', 1)->get();
你可以在关联上使用任意 查询构造器 方法,请查阅查询构造器文档,学习那些对你有用的方法

在关联之后链式添加 orWhere 条件
如上所示,你可以在查询关联时自由添加其他约束。 但是,在将 orWhere 子句链接到关联时要小心,因为 orWhere 子句将在逻辑上与关联约束处于同一级别：
$user->posts() ->where('active', 1) ->orWhere('votes', '>=', 100) ->get();
// select * from posts
// where user_id = ? and active = 1 or votes >= 100

在大多数情况下可以使用约束组 在括号中对条件检查进行逻辑分组：
use Illuminate\Database\Eloquent\Builder;
$user->posts()->where(function (Builder $query) {
  return $query->where('active', 1) ->orWhere('votes', '>=', 100);
})->get();
// select * from posts
// where user_id = ? and (active = 1 or votes >= 100)

关联方法 Vs. 动态属性
如果不需要向 Eloquent 关联查询添加额外的约束,可以像属性一样访问关联。例如,继续使用 User 和 Post 示例模型,可以这样访问用户的全部文章：
$user = App\User::find(1);
foreach ($user->posts as $post) { }
动态属性是「懒加载」的,这意味着它们仅在你真实访问关联数据时才被载入。因此,开发者经常使用 预加载 预先加载那些他们确知在载入模型后将访问的关联。对载入模型关联中必定被执行的 SQL 查询而言,预加载显著减少了查询的执行次数

查询已存在的关联
在访问模型记录时,可能希望基于关联的存在限制查询结果。比如想要获取至少存在一条评论的所有文章,可以通过给 has 和 orHas 方法传递关联名称来实现：
// 获取至少存在一条评论的所有文章...
$posts = App\Post::has('comments')->get();
还可以指定运算符和数量进一步自定义查询：
// 获取评论超过三条的文章...
$posts = App\Post::has('comments', '>=', 3)->get();
还可以用 「点」语法构造嵌套的 has 语句。比如,可以获取拥有至少一条评论和投票的文章：
// 获取拥有至少一条带有投票评论的文章...
$posts = App\Post::has('comments.votes')->get();
如果需要更多功能,可以使用 whereHas 和 orWhereHas 方法将「where」 条件放到 has 查询上。这些方法允许你向关联加入自定义约束,比如检查评论内容：
use Illuminate\Database\Eloquent\Builder;
// 获取至少带有一条评论内容包含 foo% 关键词的文章...
$posts = App\Post::whereHas('comments', function (Builder $query) {
  $query->where('content', 'like', 'foo%');
})->get();
// 获取至少带有十条评论内容包含 foo% 关键词的文章...
$posts = App\Post::whereHas('comments', function (Builder $query) {
  $query->where('content', 'like', 'foo%');
}, '>=', 10)->get();

查询不存在的关联
在访问模型记录时,可能希望基于关联不存在来限制查询结果。假设想要获取不存在任何评论的文章,可以通过向 doesntHave 和 orDoesntHave 方法传递关联名称来实现：
$posts = App\Post::doesntHave('comments')->get();
如果需要更多功能,可以使用 whereDoesntHave 和 orWhereDoesntHave 方法将「where」 条件加到 doesntHave 查询上。这些方法允许你向关联加入自定义限制,比如检测评论内容：
use Illuminate\Database\Eloquent\Builder;
$posts = App\Post::whereDoesntHave('comments', function (Builder $query) {
  $query->where('content', 'like', 'foo%');
})->get();
还可以使用 「点」 语法执行嵌套关联查询。例如,下面的查询用于获取带有没被禁用的作者发表评论的文章：
use Illuminate\Database\Eloquent\Builder;
$posts = App\Post::whereDoesntHave('comments.author', function (Builder $query) {
  $query->where('banned', 0);
})->get();

多态关联查询
要查询 MorphTo 关联的存在,可以使用 whereHasMorph 方法及其相应的方法：

</pre><textarea>
use Illuminate\Database\Eloquent\Builder;
// 查询与帖子或视频相关并且标题包含foo的评论
$comments = App\Comment::whereHasMorph(
  'commentable',
  ['App\Post', 'App\Video'],
  function (Builder $query) {
    $query->where('title', 'like', 'foo%');
  }
)->get();

// 查询与帖子相关的评论,标题不像foo％
$comments = App\Comment::whereDoesntHaveMorph(
  'commentable',
  'App\Post',
  function (Builder $query) {
    $query->where('title', 'like', 'foo%');
  }
)->get();

可以使用$type参数根据相关模型添加不同的约束：
use Illuminate\Database\Eloquent\Builder;
$comments = App\Comment::whereHasMorph(
  'commentable',
  ['App\Post', 'App\Video'],
  function (Builder $query, $type) {
    $query->where('title', 'like', 'foo%');
    if ($type === 'App\Post') {
      $query->orWhere('content', 'like', 'foo%');
    }
  }
)->get();

可以提供*作为通配符,让Laravel从数据库中查询所有可能的多态类型,而不是传递可能的多态模型数组。Laravel将执行其他查询以执行此操作：
use Illuminate\Database\Eloquent\Builder;
$comments = App\Comment::whereHasMorph('commentable', '*', function (Builder $query) {
  $query->where('title', 'like', 'foo%');
})->get();

</textarea><pre>
关联模型计数
如果想要只计算关联结果的统计数量而不需要真实加载它们,可以使用 withCount 方法,它将放在结果模型的 {relation}_count 列。示例如下：
$posts = App\Post::withCount('comments')->get();
foreach ($posts as $post) {
  echo $post->comments_count;
}
可以像给查询添加限制一样为多个关系添加「计数」：
use Illuminate\Database\Eloquent\Builder;
$posts = App\Post::withCount(['votes', 'comments' => function (Builder $query) {
  $query->where('content', 'like', 'foo%');
}])->get();
echo $posts[0]->votes_count;
echo $posts[0]->comments_count;
还可以给关联计数结果起别名,这允许你在同一关联上添加多个计数：
use Illuminate\Database\Eloquent\Builder;
$posts = App\Post::withCount([
  'comments',
  'comments as pending_comments_count' => function (Builder $query) {
    $query->where('approved', false);
  },
])->get();
echo $posts[0]->comments_count;
echo $posts[0]->pending_comments_count;
如果将 withCount 和 select 查询组装在一起,请确保在 select 方法之后调用 withCount ：
$posts = App\Post::select(['title', 'body'])->withCount('comments')->get();
echo $posts[0]->title;
echo $posts[0]->body;
echo $posts[0]->comments_count;
此外,使用 loadCount 方法,您可以在父模型被加载后使用关联计数:
$book = App\Book::first();
$book->loadCount('genres');
如果您需要在预加载查询上设置额外的查询约束,您可以传递一个希望加载的关联数组。数组值应该是 Closure 实例,它接收查询生成器实例:
$book->loadCount(['reviews' => function ($query) {
  $query->where('rating', 5);
}])

预加载
当以属性方式访问 Eloquent 关联时,关联数据「懒加载」。这意味着直到第一次访问属性时关联数据才会被真实加载。不过 Eloquent 能在查询父模型时「预先载入」子关联。预加载可以缓解 N + 1 查询问题。为了说明 N + 1 查询问题,考虑 Book 模型关联到 Author 的情形：

namespace App;
use Illuminate\Database\Eloquent\Model;
class Book extends Model{
  public function author() {   // 获取书籍作者
    return $this->belongsTo('App\Author');
  }
}
现在,我们来获取所有的书籍及其作者：
$books = App\Book::all();
foreach ($books as $book) {
  echo $book->author->name;
}
此循环将执行一个查询,用于获取全部书籍,然后为每本书执行获取作者的查询。如果我们有 25 本书,此循环将运行 26 个查询：1 个用于查询书籍,25 个附加查询用于查询每本书的作者。
谢天谢地,我们能够使用预加载将操作压缩到只有 2 个查询。在查询时,可以使用 with 方法指定想要预加载的关联：
$books = App\Book::with('author')->get();
foreach ($books as $book) {
  echo $book->author->name;
}
在这个例子中,仅执行了两个查询：
select * from books
select * from authors where id in (1, 2, 3, 4, 5, ...)

预加载多个关联
有时,你可能需要在单一操作中预加载几个不同的关联。要达成此目的,只要向 with 方法传递多个关联名称构成的数组参数：
$books = App\Book::with(['author', 'publisher'])->get();

嵌套预加载
可以使用 「点」 语法预加载嵌套关联。比如在一个 Eloquent 语句中预加载所有书籍作者及其联系方式：
$books = App\Book::with('author.contacts')->get();

嵌套预加载 morphTo 关联
如果你希望加载一个 morphTo 关系,以及该关系可能返回的各种实体的嵌套关系,可以将 with 方法与 morphTo 关系的 morphWith 方法结合使用。 为了帮助说明这种方法,让我们考虑以下模型：
use Illuminate\Database\Eloquent\Model;
class ActivityFeed extends Model{
  public function parentable() {  // 获取活动提要记录的父级
    return $this->morphTo();
  }
}
在这个例子中,我们假设 Event,Photo 和 Post 模型可以创建 ActivityFeed 模型。 另外,我们假设 Event 模型属于 Calendar 模型,Photo 模型与 Tag 模型相关联,Post 模型属于 Author 模型。

使用这些模型定义和关联,我们可以查询 ActivityFeed 模型实例并预加载所有 parentable 模型及其各自的嵌套关系：
use Illuminate\Database\Eloquent\Relations\MorphTo;
$activities = ActivityFeed::query()->with(['parentable' => function (MorphTo $morphTo) {
  $morphTo->morphWith([
    Event::class => ['calendar'],
    Photo::class => ['tags'],
    Post::class => ['author'],
  ]);
}])->get();

预加载指定列
并不是总需要获取关系的每一列。在这种情况下,Eloquent 允许你为关联指定想要获取的列：

$books = App\Book::with('author:id,name')->get();
注意：在使用这个特性时,一定要在要获取的列的列表中包含 id 列。

默认预加载
有时可能希望在查询模型时始终加载某些关联。 为此,你可以在模型上定义 $with 属性：
namespace App;
use Illuminate\Database\Eloquent\Model;
class Book extends Model{
  protected $with = ['author']; // 默认加载的关联
  public function author() {    // 获取书籍作者
    return $this->belongsTo('App\Author');
  }
}
如果你想从单个查询的 $with 属性中删除一个预加载,你可以使用 without 方法：
$books = App\Book::without('author')->get();

为预加载添加约束
有时,可能希望预加载一个关联,同时为预加载查询添加额外查询条件,就像下面的例子：
$users = App\User::with(['posts' => function ($query) {
  query->where('title', 'like', '%first%');
}])->get();
在这个例子中Eloquent 将仅预加载那些 title 列包含 first 关键词的文章。也可以调用其它的 查询构造器 方法进一步自定义预加载操作：

$users = App\User::with(['posts' => function ($query) {
  $query->orderBy('created_at', 'desc');
}])->get();
注意：在约束预加载时,不能使用 limit 和 take 查询构造器方法。

延迟预加载
有可能你还希望在模型加载完成后在进行渴求式加载。举例来说,如果你想要根据某个条件动态决定是否加载关联数据,那么 load 方法对你来说会非常有用：
$books = App\Book::all();
if ($someCondition) {
  $books->load('author', 'publisher');
}
如果你想要在渴求式加载的查询语句中进行条件约束,你可以通过数组的形式去加载,键为对应的关联关系,值为 Closure 闭包函数,该闭包的参数为一个查询实例：
$author->load(['books' => function ($query) {
  $query->orderBy('published_date', 'asc');
}]);
如果希望加载还没有加载的关联关系时,你可以使用 loadMissing 方法：
public function format(Book $book){
  $book->loadMissing('author');
  return [ 'name' => $book->name, 'author' => $book->author->name, ];
}

嵌套延迟预加载 & morphTo
如果希望快速加载 morphTo 关系,以及该关系可能返回的各种实体上的嵌套关系,可以使用 loadMorph 方法。

这个方法接受 morphTo 关系的名称作为它的第一个参数,第二个参数接收模型数组、关系数组。为了帮助说明这个方法,可以看一下以下模型例子:

use Illuminate\Database\Eloquent\Model;
class ActivityFeed extends Model{
  public function parentable() {  // 获取 activity feed 记录的父级
    return $this->morphTo();
  }
}
这个例子中假设 Event 、Photo 和 Post 模型可以创建 ActivityFeed 模型。此外,让我们假设 Event 模型属于 Calendar 模型,Photo 模型与 Tag 模型相关联,Post 模型属于 Author 模型。

使用这些模型定义和关系,我们可以检索 ActivityFeed 模型实例,并立即加载所有 parentable 模型及其各自的嵌套关系:
$activities = ActivityFeed::with('parentable')->get()->loadMorph('parentable', [
  Event::class => ['calendar'],
  Photo::class => ['tags'],
  Post::class => ['author'],
]);

插入 & 更新关联模型
保存方法
Eloquent 为新模型添加关联提供了便捷的方法。例如,也许你需要添加一个新的 Comment 到一个 Post 模型中。你不用在 Comment 中手动设置 post_id 属性,就可以直接使用关联模型的 save 方法将 Comment 直接插入：
$comment = new App\Comment(['message' => 'A new comment.']);
$post = App\Post::find(1);
$post->comments()->save($comment);
并没有使用动态属性的方式访问 comments 关联。相反,我们调用 comments 方法来获得关联实例。save 方法将自动添加适当的 post_id 值到 Comment 模型中。

如果你需要保存多个关联模型,你可以使用 saveMany 方法：
$post = App\Post::find(1);
$post->comments()->saveMany([
  new App\Comment(['message' => 'A new comment.']),
  new App\Comment(['message' => 'Another comment.']),
]);

递归保存模型和关联数据
如果你想 save 你的模型及其所有关联数据,你可以使用 push 方法:
$post = App\Post::find(1);
$post->comments[0]->message = 'Message';
$post->comments[0]->author->name = 'Author Name';
$post->push();

新增方法
除了 save 和 saveMany 方法外,你还可以使用 create 方法。它接受一个属性数组,同时会创建模型并插入到数据库中。 还有, save 方法和 create 方法的不同之处在于, save 方法接受一个完整的 Eloquent 模型实例,而 create 则接受普通的 PHP 数组:
$post = App\Post::find(1);
$comment = $post->comments()->create([ 'message' => 'A new comment.', ]);
备注：在使用 create 方法前,请务必确保查看过本文档的 批量赋值 章节。

你还可以使用 createMany 方法去创建多个关联模型：
$post = App\Post::find(1);
$post->comments()->createMany([
  [ 'message' => 'A new comment.', ],
  [ 'message' => 'Another new comment.', ],
]);
你还可以使用 findOrNew、firstOrNew、firstOrCreate 和 updateOrCreate 方法来 创建和更新关系模型。

更新 belongsTo 关联
当更新 belongsTo 关联时,可以使用 associate 方法。此方法将会在子模型中设置外键：
$account = App\Account::find(10);
$user->account()->associate($account);
$user->save();

当移除 belongsTo 关联时,可以使用 dissociate 方法。此方法会将关联外键设置为 null:
$user->account()->dissociate();
$user->save();

默认模型
belongsTo,hasOne,hasOneThrough 和 morphOne 关系允许你指定默认模型,当给定关系为 null 时,将会返回默认模型。 这种模式被称作 空对象模式 ,可以减少你代码中不必要的检查。在下面的例子中,如果发布的帖子没有找到作者, user 关系会返回一个空的 App\User 模型：

public function user(){  // Get the author of the post
  return $this->belongsTo('App\User')->withDefault();
}

如果需要在默认模型里添加属性, 你可以传递数组或者回调方法到 withDefault 中：
public function user(){  // 获取帖子的作者
  return $this->belongsTo('App\User')->withDefault([ 'name' => 'Guest Author', ]);
}

public function user(){  // 获取帖子的作者
  return $this->belongsTo('App\User')->withDefault(function ($user, $post) {
    $user->name = 'Guest Author';
  });
}

多对多关联
附加 / 分离
Eloquent 也提供了一些额外的辅助方法,使相关模型的使用更加方便。例如,我们假设一个用户可以拥有多个角色,并且每个角色都可以被多个用户共享。给某个用户附加一个角色是通过向中间表插入一条记录实现的,可以使用 attach 方法完成该操作：
$user = App\User::find(1);
$user->roles()->attach($roleId);
在将关系附加到模型时,还可以传递一组要插入到中间表中的附加数据：
$user->roles()->attach($roleId, ['expires' => $expires]);
当然,有时也需要移除用户的角色。可以使用 detach 移除多对多关联记录。detach 方法将会移除中间表对应的记录;但是这两个模型都将会保留在数据库中：
// 移除用户的一个角色...
$user->roles()->detach($roleId);
// 移除用户的所有角色...
$user->roles()->detach();
为了方便,attach 和 detach 也允许传递一个 ID 数组：
$user = App\User::find(1);
$user->roles()->detach([1, 2, 3]);
$user->roles()->attach([ 1 => ['expires' => $expires], 2 => ['expires' => $expires], ]);

同步关联
你也可以使用 sync 方法构建多对多关联。sync 方法接收一个 ID 数组以替换中间表的记录。中间表记录中,所有未在 ID 数组中的记录都将会被移除。所以该操作结束后,只有给出数组的 ID 会被保留在中间表中：
$user->roles()->sync([1, 2, 3]);
你也可以通过 ID 传递额外的附加数据到中间表：
$user->roles()->sync([1 => ['expires' => true], 2, 3]);
如果你不想移除现有的 ID,可以使用 syncWithoutDetaching 方法：
$user->roles()->syncWithoutDetaching([1, 2, 3]);

切换关联
多对多关联也提供了toggle方法用于切换给定ID数组的附加状态。如果给定的 ID 已被附加在中间表中,那么它将会被移除,同样,如果如果给定的 ID 已被移除,它将会被附加：
$user->roles()->toggle([1, 2, 3]);

在中间表上保存额外的数据
当处理多对多关联时,save 方法接收一个额外的数据数组作为第二个参数：
App\User::find(1)->roles()->save($role, ['expires' => $expires]);

更新中间表记录
如果你需要在中间表中更新一条已存在的记录,可以使用 updateExistingPivot 。此方法接收中间表的外键与要更新的数据数组进行更新：
$user = App\User::find(1);
$user->roles()->updateExistingPivot($roleId, $attributes);

更新父级时间戳
当一个模型属 belongsTo 或者 belongsToMany 另一个模型时, 例如 Comment 属于 Post,有时更新子模型导致更新父模型时间戳非常有用。例如,当 Comment 模型被更新时,您要自动「触发」父级 Post 模型的 updated_at 时间戳的更新。Eloquent 让它变得简单。只要在子模型加一个包含关联名称的 touches 属性即可：

namespace App;
use Illuminate\Database\Eloquent\Model;
class Comment extends Model{
  protected $touches = ['post'];  // 要触发的所有关联关系
  public function post() {  // 评论所属的文章
    return $this->belongsTo('App\Post');
  }
}
现在,当你更新一个 Comment 时,对应父级 Post 模型的 updated_at 字段同时也会被更新,使其更方便得知何时让一个 Post 模型的缓存失效：
$comment = App\Comment::find(1);
$comment->text = 'Edit to this comment!';
$comment->save();

</pre>

<h4>Eloquent集合</h4><pre>
Eloquent 返回的所有结果集都是 Illuminate\Database\Eloquent\Collection 对象的实例,包括通过 get 方法检索或通过访问关联关系获取到的结果。 Eloquent 的集合对象继承了 Laravel 的 集合基类,因此它自然也继承了数十种能优雅地处理 Eloquent 模型底层数组的方法。

而且,所有的集合都可以作为迭代器,你可以像遍历简单的 PHP 数组一样来遍历它们：

$users = App\User::where('active', 1)->get();
foreach ($users as $user) {
  echo $user->name;
}

不过,集合比数组更加强大,它通过更加直观的接口暴露出可链式调用的 map /reduce 等操作。例如,让我们移除所有未激活的用户并收集剩余用户的名字：

$users = App\User::all();
$names = $users->reject(function ($user) {
  return $user->active === false;
})->map(function ($user) {
  return $user->name;
});
注意：大多数 Eloquent 集合方法会返回新的 Eloquent 集合实例,但是 pluck, keys, zip, collapse, flatten 和 flip 方法除外,它们会返回一个 集合基类 实例。同样,如果 map 操作返回的集合不包括任何 Eloquent 模型,那么它会被自动转换成集合基类

可用方法
所有 Eloquent 的集合都继承了 Laravel Collection 对象;因此,他们也继承了所有集合基类提供的强大的方法。

另外,Illuminate\Database\Eloquent\Collection 类提供了一套上层的方法来帮你管理你的模型集合。大多数方法返回 Illuminate\Database\Eloquent\Collection 实例; 然而,也会有一些方法返回基于 Illuminate\Support\Collection 类的实例。

contains
diff
except
find
fresh
intersect
load
loadMissing
modelKeys
makeVisible
makeHidden
only
unique

contains($key, $operator = null, $value = null)
contains 方法可用于判断集合中是否包含指定的模型实例。这个方法接收一个主键或者模型实例：
$users->contains(1);
$users->contains(User::find(1));

diff($items)
diff 方法返回不在给定集合中的所有模型：
use App\User;
$users = $users->diff(User::whereIn('id', [1, 2, 3])->get());

except($keys)
except 方法返回给定主键外的所有模型：
$users = $users->except([1, 2, 3]);

find($key)
find方法查找给定主键的模型。如果 $key 是一个模型实例, find 将会尝试返回与主键匹配的模型。 如果 $key 是一个关联数组,find 将会使用 whereIn() 返回所有匹配 $keys 的模型:
$users = User::all();
$user = $users->find(1);

fresh($with = [])
fresh 方法从数据库检索集合中的每个模型的新实例。 此外,任何指定的关系都会被预先加载：
$users = $users->fresh();
$users = $users->fresh('comments');

intersect($items)
intersect 方法返回给定集合中也存在的所有模型:
use App\User;
$users = $users->intersect(User::whereIn('id', [1, 2, 3])->get());

load($relations)
load 方法会提前加载集合中所有模型的指定关系:
$users->load('comments', 'posts');
$users->load('comments.author');

loadMissing($relations)
如何尚未加载关系,loadMissing 方法将会为集合中的所有模型加载给定的关系
$users->loadMissing('comments', 'posts');
$users->loadMissing('comments.author');

modelKeys()
modelKeys 方法返回集合中所有模型的主键：
$users->modelKeys();  // [1, 2, 3, 4, 5]

makeVisible($attributes)
makeVisible 方法显示集合中的每个模型的指定隐藏属性：
$users = $users->makeVisible(['address', 'phone_number']);

makeHidden($attributes)
makeHidden 隐藏集合中的每个模型指定属性：
$users = $users->makeHidden(['address', 'phone_number']);

only($keys)
only 方法返回给定主键的所有模型：
$users = $users->only([1, 2, 3]);

unique($key = null, $strict = false)
unique 方法返回集合中的所有唯一模型。并且删除与集合中另一个模型有相同主键的同一类型的所有模型
$users = $users->unique();

【 自定义集合 】
如果你需要使用自定义 Collection 对象与自己的扩展方法一起使用, 可以在模型上重写newCollection方法
一旦定义了newCollection方法, 将随时可以从自定义集合中接收一个Collection返回的一个模型实例。如果要为应用程序的每个模型使用自定义集合,就应该重写所有模型扩展的基类模型中newCollection方法

</pre><textarea>
namespace App;
use App\CustomCollection;
use Illuminate\Database\Eloquent\Model;
class User extends Model{
    /**
     * 创建一个 Eloquent 集合实例.
     * @param  array  $models
     * @return \Illuminate\Database\Eloquent\Collection
     */
    public function newCollection(array $models = []) {
        return new CustomCollection($models);
    }
}

</textarea>

<h4>Eloquent: 修改器</h4><pre>
当你在 Eloquent 模型实例中获取或设置某些属性值的时候,访问器和修改器允许你对 Eloquent 属性值进行格式化。例如,你可能需要使用 Laravel 加密器 来加密保存在数据库中的值,而在使用 Eloquent 模型访问该属性的时候自动进行解密其值。

除了自定义访问器和修改器外,Eloquent 也会自动将日期字段类型转换为 Carbon 实例,或将 文本类型转换为 JSON。

访问器 & 修改器

定义一个访问器
若要定义一个访问器, 则需在模型上创建一个 getFooAttribute 方法,要访问的 Foo 字段需使用「驼峰式」命名。 在这个示例中,我们将为 first_name 属性定义一个访问器。当 Eloquent 尝试获取 first_name 属性时,将自动调用此访问器：

namespace App;
use Illuminate\Database\Eloquent\Model;
class User extends Model{
  public function getFirstNameAttribute($value){  // 获取用户的姓名
    return ucfirst($value);
  }
}
如你所见,字段的原始值被传递到访问器中,允许你对它进行处理并返回结果。如果想获取被修改后的值,你可以在模型实例上访问 first_name 属性:
$user = App\User::find(1);
$firstName = $user->first_name;
当然,你也可以通过已有的属性值,使用访问器返回新的计算值:
public function getFullNameAttribute(){  // 获取用户的姓名
  return "{$this->first_name} {$this->last_name}";
}
技巧：如果你需要将这些计算值添加到模型的数组 / JSON 中, 你需要追加它们。

定义一个修改器
若要定义一个修改器,则需在模型上面定义 setFooAttribute 方法。要访问的 Foo 字段使用「驼峰式」命名。让我们再来定义一个 first_name 属性的修改器。当我们尝试在模式上在设置 first_name 属性值时,该修改器将被自动调用：

namespace App;
use Illuminate\Database\Eloquent\Model;
class User extends Model{
  public function setFirstNameAttribute($value){  // 设置用户的姓名
    $this->attributes['first_name'] = strtolower($value);
  }
}
修改器会获取属性已经被设置的值,允许你修改并且将其值设置到 Eloquent 模型内部的 $attributes 属性上。举个例子,如果我们尝试将 first_name 属性的值设置为 Sally：
$user = App\User::find(1);
$user->first_name = 'Sally';
在这个例子中, setFirstNameAttribute 方法在调用的时候接受 Sally 这个值作为参数。接着修改器会应用 strtolower 函数并将处理的结果设置到内部的 $attributes 数组。

日期转换器
默认情况下,Eloquent 会将 created_at 和 updated_at 字段转换为 Carbon 实例,它继承了 PHP 原生的 DateTime 类并提供了各种有用的方法。你可以通过设置模型的 $dates 属性来添加其他日期属性：

namespace App;
use Illuminate\Database\Eloquent\Model;
class User extends Model{
  protected $dates = [ 'seen_at', ];  // 应该转换为日期格式的属性
}
Tip: 你可以通过将模型的公有属性 $timestamps 值设置为 false 来禁用默认的 created_at 和 updated_at 时间戳。.

当某个字段是日期格式时,你可以将值设置为一个 UNIX 时间戳,日期时间 (Y-m-d) 字符串,或者 DateTime / Carbon 实例。日期值会被正确格式化并保存到你的数据库中：
$user = App\User::find(1);
$user->deleted_at = now();
$user->save();
就如上面所说,当获取到的属性包含在 $dates 属性中时,都会自动转换为 Carbon 实例,允许你在属性上使用任意的 Carbon 方法：
$user = App\User::find(1);
return $user->deleted_at->getTimestamp();

日期格式
时间戳都将以 'Y-m-d H:i:s' 形式格式化。如果你需要自定义时间戳格式,可在模型中设置 $dateFormat 属性。这个属性决定了日期属性将以何种形式保存在数据库中,以及当模型序列化成数组或 JSON 时的格式：

namespace App;
use Illuminate\Database\Eloquent\Model;
class Flight extends Model{
  protected $dateFormat = 'U';  // 这个属性应该被转化为原生类型
}

属性类型转换
模型中的 $casts 属性提供了一个便利的方法来将属性转换为常见的数据类型。$casts 属性应是一个数组,且数组的键是那些需要被转换的属性名称,值则是你希望转换的数据类型。支持转换的数据类型有： integer, real, float, double, decimal:< digits>, string, boolean, object, array, collection, date, datetime, 和 timestamp。 当需要转换为 decimal 类型时,你需要定义小数位的个数,如： decimal:2。

示例, 让我们把以整数(0 或 1 )形式存储在数据库中的 is_admin 属性转成布尔值：

namespace App;
use Illuminate\Database\Eloquent\Model;
class User extends Model{
  protected $casts = [ 'is_admin' => 'boolean', ];  // The attributes that should be cast
}
现在当你访问 is_admin 属性时,虽然保存在数据库里的值是一个整数类型,但是返回值总是会被转换成布尔值类型：
$user = App\User::find(1);
if ($user->is_admin) { }

自定义类型转换
Laravel 内置了多种常用的类型转换。但是,用户偶尔会需要将数据转换成自定义类型。现在,该需求可以通过定义一个实现 CastsAttributes 接口的类来完成
实现了该接口的类必须事先定义一个 get 和 set 方法。 get 方法负责将从数据库中获取的原始数据转换成对应的类型,而 set 方法则是将数据转换成对应的数据库类型以便存入数据库中。举个例子,下面我们将内置的 json 类型转换以自定义类型转换的形式重新实现一遍：

</pre><textarea>
namespace App\Casts;
use Illuminate\Contracts\Database\Eloquent\CastsAttributes;
class Json implements CastsAttributes{
    /**
     * 将取出的数据进行转换
     * @param  \Illuminate\Database\Eloquent\Model  $model
     * @param  string  $key
     * @param  mixed  $value
     * @param  array  $attributes
     * @return array
     */
    public function get($model, $key, $value, $attributes){
        return json_decode($value, true);
    }

    /**
     * 转换成将要进行存储的值
     * @param  \Illuminate\Database\Eloquent\Model  $model
     * @param  string  $key
     * @param  array  $value
     * @param  array  $attributes
     * @return string
     */
    public function set($model, $key, $value, $attributes){
        return json_encode($value);
    }
}
定义好自定义类型转换后,可以使用其类名称将其附加到模型属性：

namespace App;
use App\Casts\Json;
use Illuminate\Database\Eloquent\Model;
class User extends Model{
    protected $casts = [ 'options' => Json::class, ];  // 应进行类型转换的属性
}

</textarea><pre>
值对象类型转换
你不仅可以将数据转换成原生的数据类型,还可以将数据转换成对象。两种自定义类型转换的定义方式非常类似。但是将数据转换成对象的自定义转换类中的 set 方法需要返回键值对数组,用于设置原始、可存储的值到对应的模型中。

举个例子,定义一个自定义类型转换类用于将多个模型属性值转换成单个 Address 值对象,假设 Address 对象有两个公有属性 lineOne 和 lineTwo：

</pre><textarea>
namespace App\Casts;
use App\Address;
use Illuminate\Contracts\Database\Eloquent\CastsAttributes;
class Address implements CastsAttributes {
    /**
     * 将取出的数据进行转换
     * @param  \Illuminate\Database\Eloquent\Model  $model
     * @param  string  $key
     * @param  mixed  $value
     * @param  array  $attributes
     * @return \App\Address
     */
    public function get($model, $key, $value, $attributes) {
        return new Address(
            $attributes['address_line_one'],
            $attributes['address_line_two']
        );
    }

    /**
     * 转换成将要进行存储的值
     * @param  \Illuminate\Database\Eloquent\Model  $model
     * @param  string  $key
     * @param  \App\Address  $value
     * @param  array  $attributes
     * @return array
     */
    public function set($model, $key, $value, $attributes){
        return [
            'address_line_one' => $value->lineOne,
            'address_line_two' => $value->lineTwo,
        ];
    }
}

</textarea><pre>
进行值对象类型转换后,任何对值对象的数据变更将会自动在模型保存前同步回模型当中：
$user = App\User::find(1);
$user->address->lineOne = 'Updated Address Value';
$user->save();

入站类型转换
有时候,你可能只需要对写入模型的属性值进行类型转换而不需要对从模型中获取的属性值进行任何处理。一个典型入站类型转换的例子就是 「hashing」。入站类型转换类需要实现 CastsInboundAttributes 接口,只需要实现 set 方法。

</pre><textarea>
namespace App\Casts;
use Illuminate\Contracts\Database\Eloquent\CastsInboundAttributes;
class Hash implements CastsInboundAttributes{
    protected $algorithm;  // 哈希算法

    /**
     * 创建一个新的类型转换类实例
     * @param  string|null  $algorithm
     * @return void
     */
    public function __construct($algorithm = null){
        $this->algorithm = $algorithm;
    }

    /**
     * 转换成将要进行存储的值
     * @param  \Illuminate\Database\Eloquent\Model  $model
     * @param  string  $key
     * @param  array  $value
     * @param  array  $attributes
     * @return string
     */
    public function set($model, $key, $value, $attributes){
        return is_null($this->algorithm) ? bcrypt($value); : hash($this->algorithm, $value);
    }
}

</textarea><pre>
类型转换参数
当将自定义类型转换附加到模型时,可以指定传入的类型转换参数。传入类型转换参数需使用 : 将参数与类名分隔,多个参数之间使用逗号分隔。这些参数将会传递到类型转换类的构造函数中：
protected $casts = [ 'secret' => Hash::class.':sha256', ];  // 应进行类型转换的属性

数组 & JSON 转换
当你在数据库存储序列化的 JSON 的数据时,array 类型的转换非常有用。比如：如果你的数据库具有被序列化为 JSON 的 JSON 或 TEXT 字段类型,并且在 Eloquent 模型中加入了 array 类型转换,那么当你访问的时候就会自动被转换为 PHP 数组：

namespace App;
use Illuminate\Database\Eloquent\Model;
class User extends Model{
  protected $casts = [ 'options' => 'array', ];  // 应进行类型转换的属性
}
一旦定义了转换,你访问  options 属性时他会自动从 JSON 类型反序列化为 PHP 数组。当你设置了 options 属性的值时,给定的数组也会自动序列化为 JSON 类型存储：
$user = App\User::find(1);
$options = $user->options;
$options['key'] = 'value';
$user->options = $options;
$user->save();

Date类型转换
当使用 date 或 datetime 属性时,可以指定日期的格式。 这种格式会被用在  模型序列化为数组或者 JSON：
protected $casts = [ 'created_at' => 'datetime:Y-m-d', ];  // The attributes that should be cast

查询时类型转换
有时候需要在查询执行过程中对特定属性进行类型转换,例如需要从数据库表中获取数据的时候。举个例子,请参考以下查询：
use App\Post;
use App\User;
$users = User::select([
  'users.*',
  'last_posted_at' => Post::selectRaw('MAX(created_at)')->whereColumn('user_id', 'users.id')
])->get();
在该查询获取到的结果集中,last_posted_at 属性将会是一个字符串。假如我们在执行查询时进行 date 类型转换将更方便。你可以通过使用 withCasts 方法来完成上述操作：
$users = User::select([
  'users.*',
  'last_posted_at' => Post::selectRaw('MAX(created_at)')->whereColumn('user_id', 'users.id')
])->withCasts([
  'last_posted_at' => 'date'
])->get();

</pre>
</div>

<div id="dbdemo">
<h3>db demo</h3>迁移文件生成数据库结构,模型、工厂、填充文件生成数据库测试数据<textarea>
Schema::create('users', function (Blueprint $table) {
  $table->increments('id');
  $table->string('name');
  $table->string('email')->unique();
  $table->timestamp('email_verified_at')->nullable();
  $table->string('password');
  $table->rememberToken();
  $table->timestamps();
});

mysql> show create table users;
Create Table: CREATE TABLE `users` (
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `name` varchar(255) COLLATE utf8mb4_unicode_ci NOT NULL,
  `email` varchar(255) COLLATE utf8mb4_unicode_ci NOT NULL,
  `email_verified_at` timestamp NULL DEFAULT NULL,
  `password` varchar(255) COLLATE utf8mb4_unicode_ci NOT NULL,
  `remember_token` varchar(100) COLLATE utf8mb4_unicode_ci DEFAULT NULL,
  `created_at` timestamp NULL DEFAULT NULL,
  `updated_at` timestamp NULL DEFAULT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `users_email_unique` (`email`)
) ENGINE=InnoDB AUTO_INCREMENT=101 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci

namespace App\Models;
use Illuminate\Notifications\Notifiable;
use Illuminate\Contracts\Auth\MustVerifyEmail;
use Illuminate\Foundation\Auth\User as Authenticatable;
class User extends Authenticatable implements MustVerifyEmail{
  use Notifiable;
  protected $fillable = [ 'name', 'email', 'password', ];  // The attributes that are mass assignable.
  protected $hidden = [ 'password', 'remember_token', ];  // The attributes that should be hidden for arrays.
  public function addresses(){
    return $this->hasMany(UserAddress::class);
  }
  public function favoriteProducts(){
    return $this->belongsToMany(Product::class, 'user_favorite_products')->withTimestamps()->orderBy('user_favorite_products.created_at', 'desc');
  }
  public function cartItems(){
    return $this->hasMany(CartItem::class);
  }
}

use Faker\Generator as Faker;
use Illuminate\Support\Str;
$factory->define(App\User::class, function (Faker $faker) {
  return [
    'name' => $faker->name,
    'email' => $faker->unique()->safeEmail,
    'email_verified_at' => now(),
    'password' => '$2y$10$92IXUNpkjO0rOQ5byMi.Ye4oKoEa3Ro9llC/.og/at2.uheWG/igi',
    'remember_token' => Str::random(10),
  ];
});

use Illuminate\Database\Seeder;
class UsersSeeder extends Seeder {
  public function run() {
    factory(\App\Models\User::class, 100)->create();  // 通过factory方法生成100个用户并保存到数据库中
  }
}

mysql> select * from users limit 2\G
*************************** 1. row ***************************
                id: 1
              name: 沙欢
            email: dolore48@example.org
email_verified_at: 2020-04-07 16:52:10
          password: $2y$10$TKh8H1.PfQx37YgCzwiKb.KjNyWgaHb9cbcoQgdIVFlYg7B77UdFm
    remember_token: 1UHLMfIKXE
        created_at: 2020-04-07 16:52:10
        updated_at: 2020-04-07 16:52:10
*************************** 2. row ***************************
                id: 2
              name: 植丽丽
            email: non02@example.net
email_verified_at: 2020-04-07 16:52:10
          password: $2y$10$TKh8H1.PfQx37YgCzwiKb.KjNyWgaHb9cbcoQgdIVFlYg7B77UdFm
    remember_token: uPgv4iYYvW
        created_at: 2020-04-07 16:52:10
        updated_at: 2020-04-07 16:52:10

</textarea>user_addresses<textarea>
Schema::create('user_addresses', function (Blueprint $table) {
  $table->increments('id');
  $table->unsignedInteger('user_id');
  $table->foreign('user_id')->references('id')->on('users')->onDelete('cascade');
  $table->string('province');
  $table->string('city');
  $table->string('district');
  $table->string('address');
  $table->unsignedInteger('zip');
  $table->string('contact_name');
  $table->string('contact_phone');
  $table->dateTime('last_used_at')->nullable();
  $table->timestamps();
});

mysql> show create table user_addresses;
Create Table: CREATE TABLE `user_addresses` (
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `user_id` int(10) unsigned NOT NULL,
  `province` varchar(255) COLLATE utf8mb4_unicode_ci NOT NULL,
  `city` varchar(255) COLLATE utf8mb4_unicode_ci NOT NULL,
  `district` varchar(255) COLLATE utf8mb4_unicode_ci NOT NULL,
  `address` varchar(255) COLLATE utf8mb4_unicode_ci NOT NULL,
  `zip` int(10) unsigned NOT NULL,
  `contact_name` varchar(255) COLLATE utf8mb4_unicode_ci NOT NULL,
  `contact_phone` varchar(255) COLLATE utf8mb4_unicode_ci NOT NULL,
  `last_used_at` datetime DEFAULT NULL,
  `created_at` timestamp NULL DEFAULT NULL,
  `updated_at` timestamp NULL DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `user_addresses_user_id_foreign` (`user_id`),
  CONSTRAINT `user_addresses_user_id_foreign` FOREIGN KEY (`user_id`) REFERENCES `users` (`id`) ON DELETE CASCADE
) ENGINE=InnoDB AUTO_INCREMENT=201 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci

namespace App\Models;
use Illuminate\Database\Eloquent\Model;
class UserAddress extends Model{
  protected $fillable = [ 'province', 'city', 'district', 'address', 'zip', 'contact_name', 'contact_phone', 'last_used_at', ];
  protected $dates = ['last_used_at'];  // 指明这个字段是日期类型
  public function user(){
    return $this->belongsTo(User::class);
  }
  public function getFullAddressAttribute(){
    return "{$this->province}{$this->city}{$this->district}{$this->address}";
  }
}

$factory->define(App\Models\UserAddress::class, function (Faker $faker) {
  $addresses = [
    ["北京市", "市辖区", "东城区"], ["河北省", "石家庄市", "长安区"],
    ["江苏省", "南京市", "浦口区"], ["江苏省", "苏州市", "相城区"], ["广东省", "深圳市", "福田区"],
  ];
  $address = $faker->randomElement($addresses);
  return [
    'province'      => $address[0],
    'city'          => $address[1],
    'district'      => $address[2],
    'address'       => sprintf('第%d街道第%d号', $faker->randomNumber(2), $faker->randomNumber(3)),
    'zip'           => $faker->postcode,
    'contact_name'  => $faker->name,
    'contact_phone' => $faker->phoneNumber,
  ];
});

class UserAddressesSeeder extends Seeder {
  public function run() {
    User::all()->each(function (User $user) {
      factory(UserAddress::class, random_int(1, 3))->create(['user_id' => $user->id]);
    });
  }
}

mysql> select * from user_addresses limit 2\G
*************************** 1. row ***************************
            id: 1
      user_id: 1
      province: 江苏省
          city: 苏州市
      district: 相城区
      address: 第28街道第116号
          zip: 203100
  contact_name: 焦楼
contact_phone: 17187686426
  last_used_at: NULL
    created_at: 2020-04-07 16:52:19
    updated_at: 2020-04-07 16:52:19
*************************** 2. row ***************************
            id: 2
      user_id: 1
      province: 广东省
          city: 深圳市
      district: 福田区
      address: 第54街道第50号
          zip: 418600
  contact_name: 卜军
contact_phone: 17075409998
  last_used_at: NULL
    created_at: 2020-04-07 16:52:19
    updated_at: 2020-04-07 16:52:19

</textarea>products product_skus<textarea>
Schema::create('products', function (Blueprint $table) {
  $table->increments('id');
  $table->string('title');
  $table->text('description');
  $table->string('image');
  $table->boolean('on_sale')->default(true);
  $table->float('rating')->default(5);            // 评分
  $table->unsignedInteger('sold_count')->default(0);
  $table->unsignedInteger('review_count')->default(0);
  $table->decimal('price', 10, 2);
  $table->timestamps();
});

Schema::create('product_skus', function (Blueprint $table) {
  $table->increments('id');
  $table->string('title');
  $table->string('description');
  $table->decimal('price', 10, 2);
  $table->unsignedInteger('stock');
  $table->unsignedInteger('product_id');
  $table->foreign('product_id')->references('id')->on('products')->onDelete('cascade');
  $table->timestamps();
});

mysql> show create table products;
Create Table: CREATE TABLE `products` (
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `title` varchar(255) COLLATE utf8mb4_unicode_ci NOT NULL,
  `description` text COLLATE utf8mb4_unicode_ci NOT NULL,
  `image` varchar(255) COLLATE utf8mb4_unicode_ci NOT NULL,
  `on_sale` tinyint(1) NOT NULL DEFAULT '1',
  `rating` double(8,2) NOT NULL DEFAULT '5.00',
  `sold_count` int(10) unsigned NOT NULL DEFAULT '0',
  `review_count` int(10) unsigned NOT NULL DEFAULT '0',
  `price` decimal(10,2) NOT NULL,
  `created_at` timestamp NULL DEFAULT NULL,
  `updated_at` timestamp NULL DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=31 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci

mysql> show create table product_skus;
Create Table: CREATE TABLE `product_skus` (
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `title` varchar(255) COLLATE utf8mb4_unicode_ci NOT NULL,
  `description` varchar(255) COLLATE utf8mb4_unicode_ci NOT NULL,
  `price` decimal(10,2) NOT NULL,
  `stock` int(10) unsigned NOT NULL,
  `product_id` int(10) unsigned NOT NULL,
  `created_at` timestamp NULL DEFAULT NULL,
  `updated_at` timestamp NULL DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `product_skus_product_id_foreign` (`product_id`),
  CONSTRAINT `product_skus_product_id_foreign` FOREIGN KEY (`product_id`) REFERENCES `products` (`id`) ON DELETE CASCADE
) ENGINE=InnoDB AUTO_INCREMENT=91 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci

$factory->define(App\Models\Product::class, function (Faker $faker) {
  $image = $faker->randomElement([
    "https://iocaffcdn.phphub.org/uploads/images/201806/01/5320/7kG1HekGK6.jpg",
    "https://iocaffcdn.phphub.org/uploads/images/201806/01/5320/1B3n0ATKrn.jpg",
    "https://iocaffcdn.phphub.org/uploads/images/201806/01/5320/r3BNRe4zXG.jpg",
    "https://iocaffcdn.phphub.org/uploads/images/201806/01/5320/C0bVuKB2nt.jpg",
    "https://iocaffcdn.phphub.org/uploads/images/201806/01/5320/82Wf2sg8gM.jpg",
    "https://iocaffcdn.phphub.org/uploads/images/201806/01/5320/nIvBAQO5Pj.jpg",
    "https://iocaffcdn.phphub.org/uploads/images/201806/01/5320/XrtIwzrxj7.jpg",
    "https://iocaffcdn.phphub.org/uploads/images/201806/01/5320/uYEHCJ1oRp.jpg",
    "https://iocaffcdn.phphub.org/uploads/images/201806/01/5320/2JMRaFwRpo.jpg",
    "https://iocaffcdn.phphub.org/uploads/images/201806/01/5320/pa7DrV43Mw.jpg",
  ]);
  return [
      'title'        => $faker->word,
      'description'  => $faker->sentence,
      'image'        => $image,
      'on_sale'      => true,
      'rating'       => $faker->numberBetween(0, 5),
      'sold_count'   => 0,
      'review_count' => 0,
      'price'        => 0,
  ];
});

$factory->define(App\Models\ProductSku::class, function (Faker $faker) {
  return [
    'title'       => $faker->word,
    'description' => $faker->sentence,
    'price'       => $faker->randomNumber(4),
    'stock'       => $faker->randomNumber(5),
  ];
});

class ProductsSeeder extends Seeder {
  public function run() {
    $products = factory(\App\Models\Product::class, 30)->create();  // 创建30个商品
    foreach ($products as $product) {
      $skus = factory(\App\Models\ProductSku::class, 3)->create(['product_id' => $product->id]);  // 创建3个SKU,每个SKU的product_id字段都设为当前循环的商品id
      $product->update(['price' => $skus->min('price')]);  // 找出价格最低的SKU价格，把商品价格设置为该价格
    }
  }
}

mysql> select * from products limit 2\G
*************************** 1. row ***************************
          id: 1
        title: amet
  description: Quod quisquam dicta sit libero voluptatum quisquam ipsam.
        image: https://iocaffcdn.phphub.org/uploads/images/201806/01/5320/7kG1HekGK6.jpg
      on_sale: 1
      rating: 3.67
  sold_count: 12
review_count: 5
        price: 2039.00
  created_at: 2020-04-07 16:52:35
  updated_at: 2020-04-07 16:53:27
*************************** 2. row ***************************
          id: 2
        title: quis
  description: Enim ipsa blanditiis a sit quia nam fugiat.
        image: https://iocaffcdn.phphub.org/uploads/images/201806/01/5320/pa7DrV43Mw.jpg
      on_sale: 1
      rating: 2.60
  sold_count: 15
review_count: 5
        price: 37.00
  created_at: 2020-04-07 16:52:35
  updated_at: 2020-04-07 16:53:27

mysql> select * from product_skus limit 2\G
*************************** 1. row ***************************
          id: 1
      title: et
description: Et quia et quaerat facilis beatae facilis fugiat.
      price: 8876.00
      stock: 55547
  product_id: 1
  created_at: 2020-04-07 16:52:37
  updated_at: 2020-04-07 16:52:37
*************************** 2. row ***************************
          id: 2
      title: doloremque
description: Eveniet dolore odio quas velit a quae voluptatibus.
      price: 2039.00
      stock: 85510
  product_id: 1
  created_at: 2020-04-07 16:52:37
  updated_at: 2020-04-07 16:52:37

</textarea>orders order_items<textarea>
Schema::create('orders', function (Blueprint $table) {
  $table->increments('id');
  $table->string('no')->unique();
  $table->unsignedInteger('user_id');
  $table->foreign('user_id')->references('id')->on('users')->onDelete('cascade');
  $table->text('address');
  $table->decimal('total_amount', 10, 2);
  $table->text('remark')->nullable();
  $table->dateTime('paid_at')->nullable();
  $table->string('payment_method')->nullable();
  $table->string('payment_no')->nullable();
  $table->string('refund_status')->default(\App\Models\Order::REFUND_STATUS_PENDING);  // 退款
  $table->string('refund_no')->unique()->nullable();
  $table->boolean('closed')->default(false);
  $table->boolean('reviewed')->default(false);  // 回顾
  $table->string('ship_status')->default(\App\Models\Order::SHIP_STATUS_PENDING);  // 运输
  $table->text('ship_data')->nullable();
  $table->text('extra')->nullable();   // 额外,附加
  $table->timestamps();
});

mysql> show create table orders;
Create Table: CREATE TABLE `orders` (
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `no` varchar(255) COLLATE utf8mb4_unicode_ci NOT NULL,
  `user_id` int(10) unsigned NOT NULL,
  `address` text COLLATE utf8mb4_unicode_ci NOT NULL,
  `total_amount` decimal(10,2) NOT NULL,
  `remark` text COLLATE utf8mb4_unicode_ci,
  `paid_at` datetime DEFAULT NULL,
  `coupon_code_id` int(10) unsigned DEFAULT NULL,
  `payment_method` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,
  `payment_no` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,
  `refund_status` varchar(255) COLLATE utf8mb4_unicode_ci NOT NULL DEFAULT 'pending',
  `refund_no` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,
  `closed` tinyint(1) NOT NULL DEFAULT '0',
  `reviewed` tinyint(1) NOT NULL DEFAULT '0',
  `ship_status` varchar(255) COLLATE utf8mb4_unicode_ci NOT NULL DEFAULT 'pending',
  `ship_data` text COLLATE utf8mb4_unicode_ci,
  `extra` text COLLATE utf8mb4_unicode_ci,
  `created_at` timestamp NULL DEFAULT NULL,
  `updated_at` timestamp NULL DEFAULT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `orders_no_unique` (`no`),
  UNIQUE KEY `orders_refund_no_unique` (`refund_no`),
  KEY `orders_user_id_foreign` (`user_id`),
  KEY `orders_coupon_code_id_foreign` (`coupon_code_id`),
  CONSTRAINT `orders_coupon_code_id_foreign` FOREIGN KEY (`coupon_code_id`) REFERENCES `coupon_codes` (`id`) ON DELETE SET NULL,
  CONSTRAINT `orders_user_id_foreign` FOREIGN KEY (`user_id`) REFERENCES `users` (`id`) ON DELETE CASCADE
) ENGINE=InnoDB AUTO_INCREMENT=101 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci

Schema::create('order_items', function (Blueprint $table) {
  $table->increments('id');
  $table->unsignedInteger('order_id');
  $table->foreign('order_id')->references('id')->on('orders')->onDelete('cascade');
  $table->unsignedInteger('product_id');
  $table->foreign('product_id')->references('id')->on('products')->onDelete('cascade');
  $table->unsignedInteger('product_sku_id');
  $table->foreign('product_sku_id')->references('id')->on('product_skus')->onDelete('cascade');
  $table->unsignedInteger('amount');
  $table->decimal('price', 10, 2);
  $table->unsignedInteger('rating')->nullable();  // 等级评分
  $table->text('review')->nullable();
  $table->timestamp('reviewed_at')->nullable();
});

mysql> show create table order_items;
Create Table: CREATE TABLE `order_items` (
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `order_id` int(10) unsigned NOT NULL,
  `product_id` int(10) unsigned NOT NULL,
  `product_sku_id` int(10) unsigned NOT NULL,
  `amount` int(10) unsigned NOT NULL,
  `price` decimal(10,2) NOT NULL,
  `rating` int(10) unsigned DEFAULT NULL,
  `review` text COLLATE utf8mb4_unicode_ci,
  `reviewed_at` timestamp NULL DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `order_items_order_id_foreign` (`order_id`),
  KEY `order_items_product_id_foreign` (`product_id`),
  KEY `order_items_product_sku_id_foreign` (`product_sku_id`),
  CONSTRAINT `order_items_order_id_foreign` FOREIGN KEY (`order_id`) REFERENCES `orders` (`id`) ON DELETE CASCADE,
  CONSTRAINT `order_items_product_id_foreign` FOREIGN KEY (`product_id`) REFERENCES `products` (`id`) ON DELETE CASCADE,
  CONSTRAINT `order_items_product_sku_id_foreign` FOREIGN KEY (`product_sku_id`) REFERENCES `product_skus` (`id`) ON DELETE CASCADE
) ENGINE=InnoDB AUTO_INCREMENT=209 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci

namespace App\Models;
use Illuminate\Database\Eloquent\Model;
use Ramsey\Uuid\Uuid;
class Order extends Model{
  const REFUND_STATUS_PENDING = 'pending';
  const REFUND_STATUS_APPLIED = 'applied';
  const REFUND_STATUS_PROCESSING = 'processing';
  const REFUND_STATUS_SUCCESS = 'success';
  const REFUND_STATUS_FAILED = 'failed';

  const SHIP_STATUS_PENDING = 'pending';
  const SHIP_STATUS_DELIVERED = 'delivered';
  const SHIP_STATUS_RECEIVED = 'received';

  public static $refundStatusMap = [
    self::REFUND_STATUS_PENDING    => '未退款',
    self::REFUND_STATUS_APPLIED    => '已申请退款',
    self::REFUND_STATUS_PROCESSING => '退款中',
    self::REFUND_STATUS_SUCCESS    => '退款成功',
    self::REFUND_STATUS_FAILED     => '退款失败',
  ];

  public static $shipStatusMap = [
    self::SHIP_STATUS_PENDING   => '未发货',
    self::SHIP_STATUS_DELIVERED => '已发货',
    self::SHIP_STATUS_RECEIVED  => '已收货',
  ];

  protected $fillable = [ 
    'no', 'address', 'total_amount', 'remark', 'paid_at', 'payment_method', 'payment_no', 
    'refund_status', 'refund_no', 'closed', 'reviewed', 'ship_status', 'ship_data', 'extra'
  ];

  protected $casts = [
    'closed'    => 'boolean',
    'reviewed'  => 'boolean',
    'address'   => 'json',
    'ship_data' => 'json',
    'extra'     => 'json',
  ];

  protected $dates = [ 'paid_at', ];

  protected static function boot(){
    parent::boot();
    static::creating(function ($model) {         // 监听模型创建事件，在写入数据库之前触发
      if (!$model->no) {                         // 如果模型的no字段为空
        $model->no = static::findAvailableNo();  // 调用 findAvailableNo 生成订单流水号
        if (!$model->no) {                       // 如果生成失败，则终止创建订单
          return false;
        }
      }
    });
  }

  public function user(){
    return $this->belongsTo(User::class);
  }

  public function items(){
    return $this->hasMany(OrderItem::class);
  }

  public function couponCode(){
    return $this->belongsTo(CouponCode::class);
  }

  public static function findAvailableNo(){
    $prefix = date('YmdHis');  // 订单流水号前缀
    for ($i = 0; $i < 10; $i++) {
      $no = $prefix.str_pad(random_int(0, 999999), 6, '0', STR_PAD_LEFT);  // 随机生成 6 位的数字
      if (!static::query()->where('no', $no)->exists()) {  // 判断是否已经存在
        return $no;
      }
    }
    \Log::warning('find order no failed');
    return false;
  }

  public static function getAvailableRefundNo(){
    do {
      $no = Uuid::uuid4()->getHex();  // Uuid类可以用来生成大概率不重复的字符串
    } while (self::query()->where('refund_no', $no)->exists());  // 为了避免重复在生成之后在数据库中查询看看是否已经存在相同的退款订单号
    return $no;
  }
}

namespace App\Models;
use Illuminate\Database\Eloquent\Model;
class OrderItem extends Model{
  protected $fillable = ['amount', 'price', 'rating', 'review', 'reviewed_at'];
  protected $dates = ['reviewed_at'];
  public $timestamps = false;
  public function product(){
    return $this->belongsTo(Product::class);
  }
  public function productSku(){
    return $this->belongsTo(ProductSku::class);
  }
  public function order(){
    return $this->belongsTo(Order::class);
  }
}

use App\Models\CouponCode;
use App\Models\Order;
use App\Models\User;
use Faker\Generator as Faker;
$factory->define(Order::class, function (Faker $faker) {
  $user = User::query()->inRandomOrder()->first();                   // 随机取一个用户
  $address = $user->addresses()->inRandomOrder()->first();           // 随机取一个该用户的地址
  $refund = random_int(0, 10) < 1;                                   // 10% 的概率把订单标记为退款
  $ship = $faker->randomElement(array_keys(Order::$shipStatusMap));  // 随机生成发货状态
  $coupon = null;                                                    // 优惠券
  if (random_int(0, 10) < 3) {                                       // 30% 概率该订单使用了优惠券
    $coupon = CouponCode::query()->where('min_amount', 0)->inRandomOrder()->first();  // 为了避免出现逻辑错误，只选择没有最低金额限制的优惠券
    $coupon->changeUsed();                                           // 增加优惠券的使用量
  }
  return [
    'address'        => [
      'address'       => $address->full_address,
      'zip'           => $address->zip,
      'contact_name'  => $address->contact_name,
      'contact_phone' => $address->contact_phone,
    ],
    'total_amount'   => 0,
    'remark'         => $faker->sentence,
    'paid_at'        => $faker->dateTimeBetween('-30 days'), // 30天前到现在任意时间点
    'payment_method' => $faker->randomElement(['wechat', 'alipay']),
    'payment_no'     => $faker->uuid,
    'refund_status'  => $refund ? Order::REFUND_STATUS_SUCCESS : Order::REFUND_STATUS_PENDING,
    'refund_no'      => $refund ? Order::getAvailableRefundNo() : null,
    'closed'         => false,
    'reviewed'       => random_int(0, 10) > 2,
    'ship_status'    => $ship,
    'ship_data'      => $ship === Order::SHIP_STATUS_PENDING ? null : [
      'express_company' => $faker->company,
      'express_no'      => $faker->uuid,
    ],
    'extra'          => $refund ? ['refund_reason' => $faker->sentence] : [],
    'user_id'        => $user->id,
    'coupon_code_id' => $coupon ? $coupon->id : null,
  ];
});

use App\Models\OrderItem;
use App\Models\Product;
use Faker\Generator as Faker;
$factory->define(OrderItem::class, function (Faker $faker) {
  $product = Product::query()->where('on_sale', true)->inRandomOrder()->first();  // 从数据库随机取一条商品
  $sku = $product->skus()->inRandomOrder()->first();  // 从该商品的 SKU 中随机取一条
  return [
    'amount'         => random_int(1, 5), // 购买数量随机 1 - 5 份
    'price'          => $sku->price,
    'rating'         => null,
    'review'         => null,
    'reviewed_at'    => null,
    'product_id'     => $product->id,
    'product_sku_id' => $sku->id,
  ];
});

use App\Models\Order;
use App\Models\OrderItem;
use App\Models\Product;
use Illuminate\Database\Seeder;
class OrdersSeeder extends Seeder {
  public function run() {
    $faker = app(Faker\Generator::class);  // 获取Faker实例
    $orders = factory(Order::class, 100)->create();  // 创建100笔订单
    $products = collect([]);               // 被购买的商品，用于后面更新商品销量和评分
    foreach ($orders as $order) {          // 每笔订单随机1-3个商品
      $items = factory(OrderItem::class, random_int(1, 3))->create([  
        'order_id'    => $order->id,
        'rating'      => $order->reviewed ? random_int(1, 5) : null,  // 随机评分1-5
        'review'      => $order->reviewed ? $faker->sentence : null,
        'reviewed_at' => $order->reviewed ? $faker->dateTimeBetween($order->paid_at) : null, // 评价时间不能早于支付时间
      ]);
      $total = $items->sum(function (OrderItem $item) { return $item->price * $item->amount; });  // 计算总价
      if ($order->couponCode) { $total = $order->couponCode->getAdjustedPrice($total); }  // 如果有优惠券则计算优惠后价格
      $order->update([ 'total_amount' => $total, ]);  // 更新订单总价
      $products = $products->merge($items->pluck('product'));  // 将这笔订单的商品合并到商品集合中
    }
    $products->unique('id')->each(function (Product $product) {  // 根据商品ID过滤掉重复的商品
      $result = OrderItem::query()   // 查出该商品的销量、评分、评价数
        ->where('product_id', $product->id)
        ->whereHas('order', function ($query) {
          $query->whereNotNull('paid_at');
        })
        ->first([
          \DB::raw('count(*) as review_count'),
          \DB::raw('avg(rating) as rating'),
          \DB::raw('sum(amount) as sold_count'),
        ]);

      $product->update([
        'rating'       => $result->rating ?: 5, // 如果某个商品没有评分则默认为5分
        'review_count' => $result->review_count,
        'sold_count'   => $result->sold_count,
      ]);
    });
  }
}

mysql> select * from orders limit 2\G
*************************** 1. row ***************************
            id: 1
            no: 20200407165252155426
        user_id: 24
        address: {"address":"\u6c5f\u82cf\u7701\u82cf\u5dde\u5e02\u76f8\u57ce\u533a\u7b2c16\u8857\u9053\u7b2c552\u53f7","zip":557700,"contact_name":"\u4faf\u6842\u73cd","contact_phone":"13792237510"}
  total_amount: 39492.00
        remark: Sit in voluptas dolor sint quia labore repudiandae.
        paid_at: 2020-03-16 17:27:41
coupon_code_id: NULL
payment_method: wechat
    payment_no: f8070a18-2e39-38d3-8b87-b922c60774b7
  refund_status: pending
      refund_no: NULL
        closed: 0
      reviewed: 0
    ship_status: delivered
      ship_data: {"express_company":"\u901a\u9645\u540d\u8054\u4f20\u5a92\u6709\u9650\u516c\u53f8","express_no":"b85db5f6-c7f1-3b1f-9f4a-519439c1b5d9"}
          extra: []
    created_at: 2020-04-07 16:52:52
    updated_at: 2020-04-07 16:53:00
*************************** 2. row ***************************
            id: 2
            no: 20200407165252438693
        user_id: 18
        address: {"address":"\u6c5f\u82cf\u7701\u82cf\u5dde\u5e02\u76f8\u57ce\u533a\u7b2c6\u8857\u9053\u7b2c886\u53f7","zip":636900,"contact_name":"\u81e7\u73fa","contact_phone":"17074898088"}
  total_amount: 11660.00
        remark: Maiores ipsam sed provident porro veniam.
        paid_at: 2020-03-12 03:38:57
coupon_code_id: NULL
payment_method: wechat
    payment_no: 07ca194f-387f-3a70-83cd-a525b78b0842
  refund_status: pending
      refund_no: NULL
        closed: 0
      reviewed: 0
  ship_status: delivered
    ship_data: {"express_company":"\u826f\u8bfa\u4f20\u5a92\u6709\u9650\u516c\u53f8","express_no":"a66e5d2d-c2ec-3029-ba2b-b5c9d6d25e12"}
        extra: []
    created_at: 2020-04-07 16:52:52
    updated_at: 2020-04-07 16:53:01

mysql> select * from order_items limit 2\G
*************************** 1. row ***************************
            id: 1
      order_id: 1
    product_id: 6
product_sku_id: 18
        amount: 4
        price: 2669.00
        rating: NULL
        review: NULL
  reviewed_at: NULL
*************************** 2. row ***************************
            id: 2
      order_id: 1
    product_id: 9
product_sku_id: 27
        amount: 4
        price: 7204.00
        rating: NULL
        review: NULL
  reviewed_at: NULL

</textarea>coupon_codes<textarea>
Schema::create('coupon_codes', function (Blueprint $table) {
  $table->increments('id');
  $table->string('name');
  $table->string('code')->unique();
  $table->string('type');
  $table->decimal('value');
  $table->unsignedInteger('total');
  $table->unsignedInteger('used')->default(0);
  $table->decimal('min_amount', 10, 2);
  $table->datetime('not_before')->nullable();
  $table->datetime('not_after')->nullable();
  $table->boolean('enabled');
  $table->timestamps();
});

use Illuminate\Support\Facades\Schema;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Database\Migrations\Migration;
class OrdersAddCouponCodeId extends Migration{
  public function up(){
    Schema::table('orders', function (Blueprint $table) {
      $table->unsignedInteger('coupon_code_id')->nullable()->after('paid_at');
      $table->foreign('coupon_code_id')->references('id')->on('coupon_codes')->onDelete('set null');
    });
  }
  public function down(){
    Schema::table('orders', function (Blueprint $table) {
      $table->dropForeign(['coupon_code_id']);
      $table->dropColumn('coupon_code_id');
    });
  }
}

mysql> show create table coupon_codes;
Create Table: CREATE TABLE `coupon_codes` (
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `name` varchar(255) COLLATE utf8mb4_unicode_ci NOT NULL,
  `code` varchar(255) COLLATE utf8mb4_unicode_ci NOT NULL,
  `type` varchar(255) COLLATE utf8mb4_unicode_ci NOT NULL,
  `value` decimal(8,2) NOT NULL,
  `total` int(10) unsigned NOT NULL,
  `used` int(10) unsigned NOT NULL DEFAULT '0',
  `min_amount` decimal(10,2) NOT NULL,
  `not_before` datetime DEFAULT NULL,
  `not_after` datetime DEFAULT NULL,
  `enabled` tinyint(1) NOT NULL,
  `created_at` timestamp NULL DEFAULT NULL,
  `updated_at` timestamp NULL DEFAULT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `coupon_codes_code_unique` (`code`)
) ENGINE=InnoDB AUTO_INCREMENT=21 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci

namespace App\Models;
use App\Exceptions\CouponCodeUnavailableException;
use Carbon\Carbon;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Support\Str;
class CouponCode extends Model{
  // 用常量的方式定义支持的优惠券类型
  const TYPE_FIXED = 'fixed';
  const TYPE_PERCENT = 'percent';

  public static $typeMap = [
    self::TYPE_FIXED   => '固定金额',
    self::TYPE_PERCENT => '比例',
  ];

  protected $fillable = [ 'name', 'code', 'type', 'value', 'total', 'used', 'min_amount', 'not_before', 'not_after', 'enabled', ];
  protected $casts = [ 'enabled' => 'boolean', ];
  protected $dates = ['not_before', 'not_after'];  // 指明这两个字段是日期类型
  protected $appends = ['description'];

  public function getDescriptionAttribute(){
    $str = '';
    if ($this->min_amount > 0) {
      $str = '满'.str_replace('.00', '', $this->min_amount);
    }
    if ($this->type === self::TYPE_PERCENT) {
      return $str.'优惠'.str_replace('.00', '', $this->value).'%';
    }
    return $str.'减'.str_replace('.00', '', $this->value);
  }

  public function checkAvailable(User $user, $orderAmount = null){
    if (!$this->enabled) {
      throw new CouponCodeUnavailableException('优惠券不存在');
    }
    if ($this->total - $this->used <= 0) {
      throw new CouponCodeUnavailableException('该优惠券已被兑完');
    }
    if ($this->not_before && $this->not_before->gt(Carbon::now())) {
      throw new CouponCodeUnavailableException('该优惠券现在还不能使用');
    }
    if ($this->not_after && $this->not_after->lt(Carbon::now())) {
      throw new CouponCodeUnavailableException('该优惠券已过期');
    }
    if (!is_null($orderAmount) && $orderAmount < $this->min_amount) {
      throw new CouponCodeUnavailableException('订单金额不满足该优惠券最低金额');
    }
    $used = Order::where('user_id', $user->id)->where('coupon_code_id', $this->id)->where(function($query) {
      $query->where(function($query) {
        $query->whereNull('paid_at')->where('closed', false);
      })->orWhere(function($query) {
        $query->whereNotNull('paid_at')->where('refund_status', '!=', Order::REFUND_STATUS_SUCCESS);
      });
    })->exists();
    if ($used) {
      throw new CouponCodeUnavailableException('你已经使用过这张优惠券了');
    }
  }

  public function getAdjustedPrice($orderAmount){  // 调整后的价格
    if ($this->type === self::TYPE_FIXED) {        // 固定金额
      return max(0.01, $orderAmount - $this->value);  // 为了保证系统健壮性，需要订单金额最少为0.01元
    }
    return number_format($orderAmount * (100 - $this->value) / 100, 2, '.', '');
  }

  public function changeUsed($increase = true){  // 传入true代表新增用量，否则是减少用量
    if ($increase) {                             // 与检查SKU库存类似，这里需要检查当前用量是否已经超过总量
      return $this->newQuery()->where('id', $this->id)->where('used', '<', $this->total)->increment('used');
    } else {
      return $this->decrement('used');
    }
  }

  public static function findAvailableCode($length = 16){
    do {
      $code = strtoupper(Str::random($length));               // 生成一个指定长度的随机字符串，并转成大写
    } while (self::query()->where('code', $code)->exists());  // 如果生成的码已存在就继续循环
    return $code;
  }
}

$factory->define(App\Models\CouponCode::class, function (Faker $faker) {
  $type  = $faker->randomElement(array_keys(App\Models\CouponCode::$typeMap));  // 首先随机取得一个类型
  $value = $type === App\Models\CouponCode::TYPE_FIXED ? random_int(1, 200) : random_int(1, 50);  // 根据取得的类型生成对应折扣
  if ($type === App\Models\CouponCode::TYPE_FIXED) {                            // 如果是固定金额则最低订单金额必须要比优惠金额高0.01元
    $minAmount = $value + 0.01;
  } else {                                                      // 如果是百分比折扣，有50%概率不需要最低订单金额
    $minAmount = random_int(0, 100) < 50 ? 0 : random_int(100, 1000);
  }
  return [
    'name'       => join(' ', $faker->words),                   // 随机生成名称
    'code'       => App\Models\CouponCode::findAvailableCode(), // 调用优惠码生成方法
    'type'       => $type,
    'value'      => $value,
    'total'      => 1000,
    'used'       => 0,
    'min_amount' => $minAmount,
    'not_before' => null,
    'not_after'  => null,
    'enabled'    => true,
  ];
});

class CouponCodesSeeder extends Seeder{
  public function run(){
    factory(\App\Models\CouponCode::class, 20)->create();
  }
}

mysql> select * from coupon_codes limit 2\G
*************************** 1. row ***************************
        id: 1
      name: porro nihil repellendus
      code: U6RAHKUVVARLKSAA
      type: fixed
      value: 103.00
      total: 1000
      used: 0
min_amount: 103.01
not_before: NULL
  not_after: NULL
    enabled: 1
created_at: 2020-04-07 16:52:46
updated_at: 2020-04-07 16:52:46
*************************** 2. row ***************************
        id: 2
      name: atque aut voluptas
      code: BETEOAS7AB6QBL6J
      type: percent
      value: 16.00
      total: 1000
      used: 0
min_amount: 406.00
not_before: NULL
  not_after: NULL
    enabled: 1
created_at: 2020-04-07 16:52:47
updated_at: 2020-04-07 16:52:47

</textarea>
</div>

<div id="front">
<h3>Laravel前端</h3><pre>
Laravel默认提供了Vue、Bootstrap、jQuery、React和Lodash等前端组件
resources/js/app.js入口文件加载了resources/js/bootstrap.js和Vue示例resources/js/components/ExampleComponent.vue
还要在resources/views/welcome.blade.php加载public/css/app.css和public/js/app.js,这两个文件下面的步骤会生成,这两个文件的生成路径和文件名在webpack.mix.js定义

Laravel提供的Bootstrap和Vue的脚手架位于laravel/ui Composer包中,可以使用Composer安装：
composer require laravel/ui --dev

安装完laravel/ui包后就可以使用ui Artisan命令安装前端脚手架：
// 生成基本脚手架
php artisan ui bootstrap
php artisan ui vue
php artisan ui react

// 生成登陆/注册脚手架
php artisan ui bootstrap --auth
php artisan ui vue --auth
php artisan ui react --auth

移除Boostrap和Vue
想要从应用中删除前端脚手架可使用preset Artisan命令。执行带none选项的preset命令,将从应用中删除Bootstrap和Vue脚手架,只保留空的SASS文件和几个常用的js工具库：
php artisan preset none

编写Vue组件
当使用laravel/ui包给前端搭脚手架时,ExampleComponent.vue Vue组件将会放置在resources/js/components目录中。 ExampleComponent.vue文件是一个单文件Vue组件示例,在同一个文件中定义了组件的JavaScript和HTML。单文件组件提供了构建js驱动应用的简便方法。这个示例组件是在app.js文件中注册的：
Vue.component( 'example-component', require('./components/ExampleComponent.vue').default );
要在应用中使用该组件,需要将其放入HTML模板,比如运行 php artisan ui vue --auth Artisan命令搭建应用的用户身份验证和注册页面的骨架,只要把这个组件放到home.blade.php Blade模板中：
@extends('layouts.app')
@section('content')
  < example-component>< /example-component>
@endsection
每次修改Vue组件都要运行npm run dev命令,也可以运行npm run watch命令监视和自动重编译发生变化的组件。

使用React
如果更喜欢使用React构建js应用,Laravel使得在Vue脚手架和React脚手架间切换变得非常容易：
composer require laravel/ui --dev
php artisan ui react         // 生成基础脚手架
php artisan ui react --auth  // 生成登录/注册脚手架

添加预设
预设是macroable,它允许在运行时向UiCommand类添加额外的方法。
例如下面的代码将一个nextjs方法添加到UiCommand类中,通常应该在服务提供者中声明预设的宏:
use Laravel\Ui\UiCommand;
UiCommand::macro('nextjs', function (UiCommand $command) {
  // 前端手脚架
});
然后可以通过ui命令调用新的预设:
php artisan ui nextjs

</pre>
</div>

<div id="rule">
<h3>Laravel项目开发规范</h3><pre>
这是一套严格的团队开发规范,是 优帆远扬 团队内部 Laravel 工程师践行的开发规范

规范有以下优点：
高效编码 - 避免了过多的选择造成的『决策时间』浪费;
风格统一 - 最大程度统一了开发团队成员代码书写风格和思路,代码阅读起来如出一辙;
减少错误 - 减小初级工程师的犯错几率。

【 开发哲学 】
因为篇幅原因本规范无法涉及到项目里每一块代码的编写标准,所以此处重点说明下此规范遵循的『开发哲学』,开发中请把其当做指明灯来指引你做决策：
DRY –「Don't Repeat Yourself」不写重复的逻辑代码;
约定俗成 - 「Convention Over Configuration」,优先选择框架提倡的做法,不过度配置;
KISS - 「Keep it Simple, Stupid」提倡简单易读的代码,不写高深、晦涩难懂的代码,不过度设计;
主厨精选 - 让有经验的人来为你选择方案,不独创方案;
官方提倡 - 优先选择官方推崇的方案。

【 设计理念 】
以下是一些优秀的『程序设计理念』：
MVC - Model, View, Controller ,以 MVC 为核心,严格控制 Controller 的可读性和代码行数;
Restful - 利用『资源化概念』和标准的 HTTP 动词来组织你的程序;
在此规范中将使用这两套理念作为程序设计基础。这些设计理念为我们设计程序提供了依据,遵循这些理念,能让程序变得清晰易读。

【 过于灵活是一件糟糕的事情 】
Laravel文档和网上的各种教程会教授一个任务可以使用好几种方法来完成。对于框架设计来说,灵活是件好事,能提供给开发者不同的选项,能让框架适用更多的用户场景。但是对于团队的协同开发来说,大部分时候更多的选项反而是累赘。

假如在为项目开发用户授权相关功能,仅注册用户权限这块就会有以下三个选项：

选项 1. 使用闭包：
可以在AuthServiceProvider中使用闭包注册用户权限
$gate->define('update-post', function ($user, $post) {
  return $user->id === $post->user_id;
});

选项 2. 自定义类方法：
可以在AuthServiceProvider中指定类方法注册用户权限
$gate->define('update-post', 'SomeClass@method');

这个时候又有决策需要去做：
SomeClass.php 放在哪个文件夹合适呢？
方法应该怎么取名合适呢？
我放在这里是对的吗？
大家都是怎么做的呢？

选项 3. Policy 授权策略类：
可以使用 Policy 授权策略类 来实现

namespace App\Policies;
use App\User;
use App\Post;

class PostPolicy{
  /**
    * 判断指定的文章是否可以被该用户更新。
    *
    * @param  \App\User  $user
    * @param  \App\Post  $post
    * @return bool
    */
  public function update(User $user, Post $post){
    return $user->id === $post->user_id;
  }
}

结论
上面的例子,如果独自开发个人项目倒是问题不大,最多一两年后回来看项目需要浪费点时间熟悉而已。然而,如果是在一个中大型的商业项目开发中,团队中有着几个甚至十几个开发者,没有规范的情况下,开发者会根据各自的喜好去选择,有时甚至出现一个开发者尝试多个选项的可能,就会造成整个团队产出的代码可读性极低,代码结构混乱,也为后面的项目代码的维护带来了难度。

与其无休止的争论哪种选项最好,还不如只知道一种选项。这一种选项能覆盖大部分的用例,且兼备开发效率、程序执行效率、扩展性、安全性等最佳实践,当再次遇到此类需求时,毫不犹豫地使用这一种选项直接了当地解决问题。

决策已提前做好,没必要浪费时间多次决策,节省时间,提高效率。

开发规范一旦统一,所有团队成员严格遵守,你会发现,你的队友写的代码就如你自己写的一样,编码愉悦感提高了,整个项目代码阅读起来更加流畅,工作效率自然也会因此提高,同时代码的健壮性也得到了保障。

【 关于「能愿动词」的使用 】
能愿动词
为了避免歧义,文档大量使用了「能愿动词」,对应的解释如下：
必须(Must) - 只能这样子做,请无条件遵循,没有别的选项;
绝不(Must Not)- 严令禁止,在任何情况下都不能这样做;
应该(Should) - 强烈建议这样做,但是不强求;
不应该(Should Not) - 强烈建议不这样做,但是不强求;
可以(May) - 选择性高一点,在这个文档内,此词语使用较少;

【 项目规范 】
1、Laravel版本选择
选择Laravel版本时应优先考虑LTS版本,因为安全性和稳定性考虑,商业项目开发中不应使用最新版本的Laravel一般发行版
composer create-project laravel/laravel project-name --prefer-dist "5.5.*"  // 创建指定版本的Laravel项目

2、开发和线上环境
一般情况下一个项目应该有以下三个基本的项目环境：
Local - 开发环境
Staging - 线上测试环境
Production - 线上生产环境

使用软件
服务器系统
Laravel社区提倡使用Ubuntu系统,开发环境Homestead中默认也是使用Ubuntu,所以服务器系统应优先考虑Ubuntu,并且是LTS支持的系统,如Ubuntu 14.04.5 LTS或Ubuntu 16.04.2 LTS

PHP 7
PHP版本应该优先考虑PHP7,不止因为其运行高效,还因为随着PHP7的广泛应用,PHP7以下的版本将会很快停止维护。

MySQL 5.7
数据库软件应该优先选择MySQL,因为其使用率最高。MySQL5.7与PHP7一样,已经是大势所趋,选择版本时应该优先考虑MySQL5.7

其他软件
应该优先选择流行稳定版本。线上环境绝不使用Beta或其他不稳定发行版。

Production 生产环境
线上环境部署可以参考Ubuntu 14/16下的Laravel LNMP线上环境自动部署脚本,此脚本参照了Homestead环境设置脚本 ,并做了更加适用于生产环境的效率和安全调优。
出于安全考虑,线上环境必须只开放以下端口：
80 HTTP
443 HTTPS
22 SSH

Local 开发环境
所有项目必须使用Homestead作为应用程序运行的环境
统一使用域名.test作为后缀;
统一使用IP 192.168.10.10作为hosts绑定地址,如192.168.10.10 project-name.test
统一使用vm alias

Staging 线上测试环境
除了域名等其他独立应用配置以外,环境必须跟Production保持高度一致性,可以的话应该与Production使用同台机器。

3、开发专用扩展包
Laravel 扩展包的注册会对应用造成消耗。有一些扩展包是开发环境中专用,生产环境中并不会使用到,为了避免无用的负载, 必须严格控制其安装和加载
安装开发专用扩展包时必须使用--dev参数
composer require laracasts/generators --dev

加载
开发专用的provider绝不在config/app.php里面注册,必须在app/Providers/AppServiceProvider.php文件中使用如以下方式：
public function register(){
  if ($this->app->environment() == 'local') {
    $this->app->register('Laracasts\Generators\GeneratorsServiceProvider');
  }
}

4、配置信息与环境变量
.env.example
因.env不会被纳入版本控制器中,所以本地.env里添加变量时必须同步到.env.example中,以免影响其他项目参与者的工作

变量存储位置
假如有个『CDN 域名』的变量,在 Laravel 中有以下几种方法：
硬代码,直接写死。- ❌ 可维护性低
写死在config/app.php文件中。 - ❌ 无法区分环境进行配置
存储于.env文件中,使用env()方法直接读取。 - ❌ 虽然解决了环境变量问题但不推荐
存储在.env和config/app.php文件中,然后使用config()函数来读取。- ✅ 最佳实践
第一种方法是最古老的方法,代码可维护性极低,一旦域名变更就只能全局替换。
第二种方法无法区分环境,例如本地使用开发环境域名测试,线上才是正式的CDN域名。
第三种方法虽解决了环境变量的问题,并具备一定的灵活性,但不够灵活,假如网站流量巨大,需要配置几个CDN域名,使其在加载静态资源时随机支配域名,这种做法就无法满足需求
第四种方法既支持环境变量,又具备极高的灵活性,假如遇到同样的CDN多域名随机问题,只需要写一个辅助方法,然后在config/app.php中调用即可,不需动到任何业务逻辑代码。

.env 文件中设置：
CDN_DOMAIN=cdndomain.com
config/app.php 文件中设置：
'cdn_domain' => env('CDN_DOMAIN', null),
程序中两种获取 相同配置 的方法：
env('CDN_DOMAIN')
config('app.cdn_domain')
在此统一规定：所有程序配置信息必须通过config()来读取,所有的.env配置信息必须通过config()来读取,绝不在配置文件以外的范围使用env()

这样做主要有以下几个优势：
定义分明,config()是配置信息,env()只是用来区分不同环境;
统一放置于config中还可以利用框架的配置信息缓存功能来提高运行效率;
代码健壮性,config()在env()之上多出来一个抽象层,会使代码更加健壮,更加灵活

5、辅助函数
Laravel提供了很多辅助函数,有时候也需要创建自己的全局辅助函数。
必须把所有的自定义辅助函数存放于app文件夹中,并在composer.json文件autoload.files中加载

// app/helpers.php
function foo() {
  return "foo";
}

修改项目composer.json
"autoload": {
  "files": [ "app/helpers.php" ]
}

然后运行:
$ composer dump-autoload
就可以在任何地方用到app/helpers.php中的函数

6、项目文档编写规范
每一个项目都包含一个readme.md文件介绍这个项目的简单信息,作用主要有两个,一个是团队新成员可从此文件中快速获悉项目大致情况,另一个是部署项目时可以作为参考。

行文规范
readme.md文档应该包含以下内容：
「项目概述」- 介绍说明项目的一些情况,类似于简单的产品说明,简单的功能描述,项目相关链接等,500 字以内;
「运行环境」- 运行环境说明,系统要求等信息;
「开发环境部署 / 安装」- 一步一步引导说明,保证项目新成员能最快速的,没有歧义的部署好开发环境;
「服务器架构说明」- 最好有服务器架构图,从用户浏览器请求开始,包括后端缓存服务使用等都描述清楚(主要体现为软件的使用),配合运行环境区块内容,可作为线上环境部署的依据
「代码上线」- 介绍代码上线流程,需要执行哪些步骤;
「扩展包说明」- 表格列出所有使用的扩展包,还有在哪些业务逻辑或者用例中使用了此扩展包;
「自定义 Artisan 命令列表」- 以表格形式罗列出所有自定义的命令,说明用途,指出调用场景;
「队列列表」- 以表格形式罗列出项目所有队列接口,说明用途,指出调用场景

7、工具统一
工具的统一,是为了方便工作流的统一,还有工具使用经验的传承。
团队里的成员,经常需要互相使用对方电脑来讨论问题、查看某段代码、Debug 某个功能,工具统一起来后,你会发现,虽然是别人的电脑,工具使用起来是熟悉的,用起来就跟自己的电脑一样顺手,自然的工作效率就会提高

硬件：RMBP 15 寸
系统：Mac 版本 10.10 以上
编辑器：Atom or Sublime
编辑器代码格式化：EditorConfig
PHP 代码风格矫正器：PHP-CS-Fixer
命令行工具：iTerm2
浏览器：Chrome
虚拟机：VirtualBox
MySQL 数据库查询工具：Sequel Pro
Redis 管理工具：RDM
MongoDB 管理工具：MongoDB
设计工具：Sketch 3
视频播放：MPlayerX
@todo zsh 的配置信息统一,Alias 等信息。

8、静态资源
css、js、font、图片、用户头像等静态资源使用CDN加载,用户上传的静态资源应酌情处理。
项目中使用了第三方前端类库中的CSS/JS/FONTS等静态资源,绝不使用第三方链接进行加载(包括第三方CDN),第三方类库静态资源必须下载并纳入代码版本管理器中
CSS和JS应使用独立的文件进行加载,不应直接写在页面中
页面CSS文件加载数量应该不超过2个,绝不超过3个。
页面JS文件加载数量应该不超过2个,绝不超过3个。

【 编码规范 】
1、代码风格严格遵循PSR-2规范

2、路由器
不在路由配置文件里书写闭包路由或其他业务逻辑代码,因为一旦使用将无法使用路由缓存
路由器要保持干净整洁,绝不放置除路由配置以外的其他程序逻辑

必须优先使用Restful路由,配合资源控制器使用
使用resource方法时,如果仅使用到部分路由,必须使用only列出所有可用路由：Route::resource('photos', 'PhotosController', ['only' => ['index', 'show']]);
不使用except,因为only相当于白名单,相对于except更加直观,路由使用白名单有利于养成安全习惯

资源路由的路由URI必须使用复数形式
/photos/create
/photos/{photo}

路由模型绑定
在允许使用路由模型绑定的地方必须使用,模型绑定代码必须放置于app/Providers/RouteServiceProvider.php文件的boot方法中
public function boot(){
  Route::bind('user_name', function ($value) {
    return User::where('name', $value)->first();
  });
  Route::bind('photo', function ($value) {
    return Photo::find($value);
  });
  parent::boot();
}

全局路由器参数
出于安全考虑,应该使用全局路由器参数限制
必须在RouteServiceProvider文件的boot方法里定义模式：
public function boot(Router $router){  // 定义路由模型绑定,模式过滤器等
  $router->pattern('id', '[0-9]+');
  parent::boot();
}
模式一旦被定义,便会自动应用到所有使用该参数名称的路由上：
Route::get('users/{id}', 'UsersController@show');
Route::get('photos/{id}', 'PhotosController@show');
只有在id为数字时才会路由到控制器方法中,否则404错误

路由命名
除了resource资源路由以外,其他所有路由都必须使用name方法进行命名。
必须使用资源前缀作为命名规范,如下的users.follow,资源前缀的值是users.
Route::post('users/{id}/follow', 'UsersController@follow')->name('users.follow');

获取URL
获取URL必须遵循以下优先级：$model->link()、route方法、url方法
在Model中创建link()方法：
public function link($params = []){
  $params = array_merge([$this->id], $params);
  return route('models.show', $params);
}
所有单个模型数据链接使用：
$model->link();
// 或者添加参数
$model->link($params = ['source' => 'list'])
单个模型URI经常会发生变化,这样做将会让程序更加灵活。
除了单个模型URI,其他路由必须使用route来获取URL：
$url = route('profile', ['id' => 1]);
无法使用route的情况下可以使用url方法来获取URL：
url('profile', [1]);

3、数据模型
所有的数据模型文件都必须存放在app/Models/文件夹中,命名空间：namespace App\Models;

User.php
Laravel5.1默认安装会把User模型存放在app/User.php,必须移动到app/Models文件夹中,并修改命名空间声明为App/Models
为了不破坏原有的逻辑点,必须全局搜索App/User并替换为App/Models/User

使用基类
所有的Eloquent数据模型都必须继承统一的基类App/Models/Model,此基类存放位置为/app/Models/Model.php,内容参考以下：
namespace App\Models;
use Illuminate\Database\Eloquent\Model as EloquentModel;
class Model extends EloquentModel{
  public function scopeRecent($query){
    return $query->orderBy('created_at', 'desc');
  }
}
以Photo数据模型作为例子继承Model基类：
namespace App\Models;
class Photo extends Model{
  protected $fillable = ['id', 'user_id'];
  public function user(){
    return $this->belongsTo(User::class);
  }
}

命名规范
数据模型相关的命名规范：
数据模型类名为单数, 如：App\Models\Photo
类文件名为单数,如：app/Models/Photo.php
数据库表名字复数,多个单词情况下使用Snake Case 如：photos, my_photos
数据库表迁移名字为复数,如：2014_08_08_234417_create_photos_table.php
数据填充文件名为复数,如：PhotosTableSeeder.php
数据库字段名为Snake Case,如：view_count, is_vip
数据库表主键为id
数据库表外键为resource_id,如：user_id, post_id
数据模型变量为resource_id,如：$user_id, $post_id

利用Trait来扩展数据模型
有时候数据模型里的代码会变得很臃肿,应该利用Trait来精简逻辑代码量,提高可读性,类似于Ruby China源码。
借鉴于Rails的设计理念：Fat Models, Skinny Controllers
存放于文件夹：app/Models/Traits文件夹中。

Repository
绝不使用Repository,因为不是在写JAVA代码,太多封装就成了过度设计(Over Designed),极大降低了编码愉悦感,使用MVC够傻够简单。
代码的可读性,维护和开发的便捷性,直接关系到程序员开发时的愉悦感,直接影响到项目推进效率和程序Debug的速度。

关于SQL文件
绝不使用命令行或PHPMyAdmin直接创建索引或表,必须使用数据库迁移去创建表结构,并提交版本控制器中;
绝不为了共享对数据库更改就直接导出SQL,所有修改都必须使用数据库迁移,并提交版本控制器中;
绝不直接向数据库手动写入伪造的测试数据,必须使用数据填充来插入假数据,并提交版本控制器中

全局作用域
Laravel的Model全局作用域允许为给定模型的所有查询添加默认的条件约束。
所有的全局作用域都统一使用闭包定义全局作用域
protected static function boot(){  // 数据模型的启动方法
  parent::boot();
  static::addGlobalScope('age', function(Builder $builder) {
    $builder->where('age', '>', 200);
  });
}

4、控制器
优先使用Restful资源控制器 
使用资源的复数形式,类名：PhotosController,文件名：PhotosController.php
保持控制器文件代码行数最小化,还有可读性
不应该为方法书写注释,这要求方法取名要足够合理,不需要过多注释
应该为一些复杂的逻辑代码块书写注释,主要介绍产品逻辑 - 为什么要这么做
不应该在控制器中书写私有方法,控制器里应该只存放路由动作方法
绝不遗留死方法即没有用到的方法,控制器里的所有方法都应该被使用到,否则应该删除;
绝不在控制器里批量注释掉代码,无用的逻辑代码就必须清除掉。

5、视图
统一布局
相似的页面下使用layouts文件来统一页面头部与尾部。

优先使用Blade
视图文件优先考虑使用.blade.php后缀来指定使用Blade模板引擎

保持目录清晰
避免在resources/views目录下直接放置视图文件
layouts - 页面布局文件放置于此目录下;
common - 存放页面通用元素;
pages - 简单的页面存放文件夹,如about、contact等;
resources - 对应Restful路由的资源路径名称,以URI photos/create为例,对应create.blade.php文件,存放在文件夹photos下

局部视图
局部视图文件使用_前缀来命名,如photos/_upload_form.blade.php

视图命名要释义
为了和Restful路由器和资源控制器保持一致,视图命名也使用资源视图的命名方式

photos/index.blade.php
内容列表视图
对应路由器 /photos,命名 photos.index
控制器方法 PhotosController@index

photos/show.blade.php
单个内容视图
对应路由器 /photos/{id},命名 photos.show
控制器方法 PhotosController@show

photos/create.blade.php
内容创建视图
对应路由器 /photos/create,命名 photos.create
控制器方法 PhotosController@create

photos/edit.blade.php
内容编辑的视图
对应路由器 /photos/edit,命名 photos.edit
控制器方法 PhotosController@edit

create_and_edit 视图
很多情况下创建和编辑视图里的页面结构接近相似,在这种情况下应该使用create_and_edit视图

PhotosController@create - 对应视图：/photos/create_and_edit.blade.php
PhotosController@edit - 对应 视图：/photos/create_and_edit.blade.php
这样通常情况下一个完整的photos资源对应的视图文件为以下：
├── photos
│   ├── create_and_edit.blade.php
│   ├── index.blade.php
│   └── show.blade.php

6、表单验证
使用表单请求 - FormRequest类来处理控制器里的表单验证
使用验证类的authorize()方法来做用户授权,用户授权会单独使用Policy授权策略来实现

使用基类,所有FormRequest表验证类必须继承app/Http/Requests/Request.php基类
namespace App\Http\Requests;
use Illuminate\Foundation\Http\FormRequest;
class Request extends FormRequest{
  public function authorize(){
    // Using policy for Authorization
    return true;
  }
}

验证类命名
FormRequest表验证类必须遵循资源路由方式进行命名,photos对应app/Http/Requests/PhotoRequest.php

FormRequest表验证类文件请参考
namespace App\Http\Requests;
class PhotoRequest extends Request {
  public function rules() {
    switch($this->method()) {
      // CREATE
      case 'POST': {
        return [ /* CREATE ROLES */ ];
      }
      // UPDATE
      case 'PUT':
      case 'PATCH': {
        return [ /* UPDATE ROLES */ ];
      }
      case 'GET':
      case 'DELETE':
      default: {
        return [];
      };
    }
  }

  public function messages(){
    return [
      // Validation messages
    ];
  }
}

7、授权策略
使用授权策略类来做用户授权

使用基类,所有Policy授权策略类必须继承app/Policies/Policy.php基类
namespace App\Policies;
use Illuminate\Auth\Access\HandlesAuthorization;
class Policy{
  use HandlesAuthorization;

  public function __construct(){ }

  public function before($user, $ability){
    if ($user->isAdmin()) return true;
  }
}

授权策略命名
Policy授权策略类必须遵循资源路由方式进行命名,photos对应/app/Policies/PhotoPolicy.php

Policy授权策略类文件内容请参考
namespace App\Policies;
use App\Models\User;
use App\Models\Photo;
class PhotoPolicy extends Policy {
  public function update(User $user, Photo $photo) {
    return $user->isAuthorOf($photo);
  }

  public function destroy(User $user, Photo $photo) {
    return $user->isAuthorOf($photo);
  }
}

自动判断授权策略
应该使用自动判断授权策略方法,这样控制器和授权类的方法名就统一起来了
public function update($id) {  // 更新指定的文章
  $post = Post::findOrFail($id);
  $this->authorize($post);  // 会自动调用`PostPolicy`类中的`update`方法
  // 更新文章...
}

9、数据填充
factory辅助函数
必须使用factory方法来做数据填充,因为是框架提倡的,并且可以同时为测试代码服务

运行效率
开发数据填充时必须特别注意php artisan db:seed的运行效率,否则随着项目的代码量越来越大,db:seed的运行时间会变得越来越长,有些项目多达几分钟甚至几十分钟。
原则是：Keep it lighting speed.
只有当db:seed运行起来很快的时候才能完全利用数据填充工具带来的便利,而不是累赘。

批量入库
所有假数据入库操作都必须是批量操作,配合factory使用以下方法：
在使用模型工厂函数来书写假数据插入逻辑时,要注意避免使用create方法,因为每一次就是一条SQL语句。
factory(\App\Models\User::class)->times(300)->create();
正确的做法使用make方法
$users = factory(User::class)->times(1000)->make();
User::insert($users->toArray());
以上只执行一条数据库语句

大批量假数据填充的正确方法
使用DB:insert,直接,快速,一步到位
$faker = Faker::create();
$users = User::lists('id');
$datas = [];

foreach (range(1, 1000) as $index) {
  $datas[] = [
    'user_id'     => $faker->randomElement($users),
    'title'       => $faker->sentence(),
    'description' => $faker->text(),
    'created_at'  => Carbon::now()->toDateTimeString(),
    'updated_at'  => Carbon::now()->toDateTimeString(),
  ];
}
DB::table('topics')->insert($datas);

10、Artisan命令行
所有的自定义命令都必须有项目的命名空间。
php artisan phphub:clear-token
php artisan phphub:send-status-email
错误的例子为：
php artisan clear-token
php artisan send-status-email

11、日期和时间
使用Carbon来处理日期和时间相关的操作。
Laravel 5.1中文的diffForHumans可以使用jenssegers/date。
Laravel 5.3及以上版本的diffForHumans,只需要在config/app.php文件中配置locale选项即可
'locale' => 'zh-CN',

12、前端开发
使用Laravel官方前端工具做前端开发自动化;
保证页面只加载一个.css文件;
保证页面只加载一个.js文件;
为.css和.js增加版本控制;
使用 SASS 来书写 CSS 代码;

13、中间件
Auth中间件必须书写在控制器的__construct方法中,并且必须使用except黑名单进行过滤,这样新增控制器方法时默认是安全的。
public function __construct(){
  $this->middleware('auth', [            
    'except' => ['show', 'index']
  ]);
}

【 Laravel 安全实践 】
关闭DEBUG
Laravel Debug开启时会暴露很多能被黑客利用的服务器信息,所以生产环境下请必须确保APP_DEBUG=false

XSS
跨站脚本攻击(cross-site scripting),具体危害体现在黑客能控制网站页面,包括使用JS盗取Cookie等
默认在无法保证用户提交内容是100%安全的情况下,必须使用Blade模板引擎的 {{ $content }} 语法会对用户内容进行转义。
Blade 的 {!! $content !!} 语法会直接对内容进行非转义输出,使用此语法时必须使用HTMLPurifier for Laravel 5来为用户输入内容进行过滤

SQL注入
Laravel的查询构造器和Eloquent是基于PHP的PDO,PDO使用prepared来准备查询语句,保障了安全性。
在使用 raw() 来编写复杂查询语句时必须使用数据绑定。
Route::get('sql-injection', function() {  // 利用select方法的第二个参数做数据绑定
  $name = "admin";
  $password = "xx' OR 1='1";
  $result = DB::select(
    DB::raw("SELECT * FROM users WHERE name =:name and password = :password"),
    [ 'name' => $name, 'password' => $password, ]
  );
  dd($result);
});
DB 类里的大部分执行 SQL 的函数都可传参第二个参数 $bindings

批量赋值
Laravel提供白名单和黑名单过滤($fillable 和 $guarded),开发者应该清楚认识批量赋值安全威胁的情况下合理灵活地运用。
批量赋值安全威胁指用户可更新本来不应有权限更新的字段。举例users表里的is_admin字段是用来标识用户是否是管理员,某不怀好意的用户更改了修改个人资料的表单,增加了一个字段：< input name="is_admin" value="1" />,这个时候如果更新代码如下：
Auth::user()->update(Request::all());
此用户将获取到管理员权限。可以有很多种方法来避免这种情况出现,最简单的方法是通过设置 User 模型里的 $guarded 字段来避免：
protected $guarded = ['id', 'is_admin'];

CSRF
CSRF跨站请求伪造是Web应用中最常见的安全威胁之一
Laravel 默认对所有『非幂等的请求』强制使用 VerifyCsrfToken 中间件防护,需要开发者做的是区分清楚什么时候该使用『非幂等的请求』。
幂等请求指的是：’HEAD’, 'GET’, 'OPTIONS’,既无论执行多少次重复的操作都不会给资源造成变更。
所有删除的动作必须使用DELETE作为请求方法;
所有对数据更新的动作必须使用POST、PUT或PATCH请求方法。

【 Laravel程序优化 】
配置信息缓存
生产环境中使用配置信息缓存来加速Laravel配置信息的读取。
使用以下Artisan自带命令把config文件夹里所有配置信息合并到一个文件里,减少运行时文件的载入数量：
php artisan config:cache
缓存文件存放在bootstrap/cache/文件夹中。
可以使用以下命令来取消配置信息缓存：
php artisan config:clear
配置信息缓存不会随着更新而自动重载,所以开发时建议关闭配置信息缓存,一般在生产环境中使用。可以配合Envoy任务运行器使用,在每次上线代码时执行config:clear命令。

路由缓存
生产环境中的应该使用路由缓存来加速Laravel的路由注册。
路由缓存可以有效的提高路由器的注册效率,在大型应用程序中效果越加明显,可以使用以下命令：
php artisan route:cache
缓存文件存放在bootstrap/cache/文件夹中。另外路由缓存不支持路由匿名函数编写逻辑
可以使用下面命令清除路由缓存：
php artisan route:clear
路由缓存不会随着更新而自动重载,所以,开发时候建议关闭路由缓存,一般在生产环境中使用。可以配合Envoy任务运行器使用,在每次上线代码时执行route:clear命令

类映射加载优化
optimize命令把常用加载的类合并到一个文件里,通过减少文件的加载,来提高运行效率。生产环境中的应该使用optimize命令来优化类的加载速度：
php artisan optimize --force
以上命令在bootstrap/cache/文件夹中生成缓存文件。可以通过修改config/compile.php文件来添加要合并的类。在production环境中参数--force不需要指定,文件会自动生成。
要清除类映射加载优化,请运行以下命令：
php artisan clear-compiled
此命令会删除上面optimize生成的两个文件。
此命令要运行在php artisan config:cache 后,因为optimize命令是根据配置信息(如config/app.php文件的providers数组)来生成文件的。

自动加载优化
此命令不止针对于Laravel程序,适用于所有使用composer来构建的程序。此命令会把PSR-0和PSR-4转换为一个类映射表,来提高类的加载速度。
composer dumpautoload -o
php artisan optimize --force 命令里已经做了这个操作。

使用Memcached或Redis来存储会话
每一个Laravel的请求都会产生会话,修改会话的存储方式能有效提高程序效率。会话的配置文件是config/session.php。生产环境中的必须使用Memcached或Redis等专业的缓存软件来存储会话,应该优先选择Memcached：
'driver' => 'memcached',

使用专业缓存驱动器
缓存是提高应用程序运行效率的法宝之一,Laravel默认缓存驱动是file文件缓存,生产环境中必须使用专业的缓存系统如Redis或Memcached,优先考虑Redis,避免使用数据库缓存。
'default' => 'redis',

数据库请求优化
关联模型数据读取时使用延迟预加载和预加载
临近上线时使用Laravel Debugbar或Clockwork留意每一个页面的总SQL求条数,进行数据库请求调优

为数据集书写缓存逻辑
应该合理的使用Laravel提供的缓存层操作,把从数据库里面拿出来的数据集合进行缓存,减少数据库的压力,运行在内存上的专业缓存软件对数据的读取也远远快于数据库。
$hot_posts = Cache::remember('posts.hot_posts', $minutes = 30, function(){
  return Post::getHotPosts();
});
remember甚至连数据关联模型也都一并缓存了,多么方便呀。

使用即时编译器
可以使用OpCache进行优化。OpCache都能轻轻松松的让应用程序在不用做任何修改的情况下,直接提高50%或更高的性能,PHPhub之前做过一个实验

前端资源合并
一个页面应该只加载一个CSS文件
一个页面应该只加载一个JS文件
为了文件要能方便走CDN,需要文件名随着修改而变化。

</pre>
</div>

<div id="shop">
<h3>Laravel Shop demo</h3>
<h4>需求分析</h4><pre>
【 用例分析 】
Laravel Shop项目是一个单商户的电商系统,先简单地从产品用例的角度上来分析Laravel Shop的需求,好让大家对即将开发的项目有个基础的概念,主要从以下三种元素入手：
角色、信息、动作

1. 角色
游客 —— 没有登录的用户;
用户 —— 注册用户,可以购买商品;
运营 —— 可以上架、下架商品,处理订单;
管理员 —— 权限最高的用户角色,可以管理运营。

2. 主要信息结构
用户 —— 模型名称User;
收货地址 —— 模型名称UserAddress,包含地址和收货人姓名、电话;
商品 —— 模型名称Product,比如iPhone X就是一个商品;
商品SKU —— 模型名称ProductSKU,同一商品下有个别属性可能有不同的值,iPhoneX 256G和iPhoneX 64G是同一个商品的不同SKU,每个SKU都有各自独立的库存
订单 —— 模型名称Order;
订单项 —— 模型名称OrderItem,一个订单会包含一个或多个订单项,每个订单项都会与一个商品SKU关联;
优惠券 —— 模型名称CouponCode,订单可以使用优惠券来扣减最终需要支付的金额;
运营人员 —— 模型名称Operator,管理员也属于运营人员。

3. 动作
角色和信息之间的互动称之为动作,动作主要有以下几个：
创建 Create
查看 Read
编辑 Update
删除 Delete

【 用例 】
1. 游客
查看商品列表;
查看单个商品内容。

2. 用户
查看自己的收货地址列表;
新增收货地址;
修改自己的收货地址;
删除自己的收货地址;
收藏商品;
将商品加入购物车;
将购物车中的商品打包下单;
在下单时使用优惠券;
通过微信、支付宝支付订单;
查看自己的订单信息;
对已支付的订单申请退款;
将已发货的订单标记为确认收货;
对已购买的商品发布评价。

3. 运营
看到所有的用户列表;
发布商品;
编辑商品内容;
编辑商品 SKU 及其库存;
下架商品;
将用户已支付的订单标记为已发货;
对申请退款的订单执行退款;
创建、编辑、删除优惠券。

4. 管理员
查看运营人员列表;
新增运营人员;
编辑运营人员;
删除运营人员。

</pre>

<h4>开发思路</h4><pre>
当开发团队开始启动一个项目时,区分功能模块的优先顺序尤其重要,否则不知道从哪里下手。这里使用一个简单的分析框架来决策功能模块的开发优先级,也可以使用其对大部分的Web项目进行模块开发的优先级分析。

1. 模块清单
首先基于需求分析将系统拆分成如下几大模块：
用户模块
商品模块
订单模块
支付模块
优惠券模块
管理模块

2. 依赖关系
有了模块清单,接下来需要思考他们之间的依赖关系是怎样的
整个系统已『订单模块』为中心
『支付模块』和『优惠券模块』又依赖于『订单模块』
『订单模块』依赖于『用户模块』和『商品模块』
上层的模块依赖于下层的模块,因此在开发过程中会优先构建下层的模块

3. 各个模块开发顺序
用户模块
商品模块
订单模块
支付模块
优惠券模块
管理模块是一个特殊的模块,既包含本身的逻辑(管理后台的权限控制等),又与其他业务模块都有关联,因此在开发过程中会与其他模块穿插开发。

4. MVP产品
工程师不需要了解产品的方方面面,那是产品经理的工作,但作为一位优秀的开发者,在开发项目时对将要完成的产品MVP要了然于胸,MVP是Minimum Viable Product (最小化可行性产品)的简称。如何得出产品的MVP产品呢？可以先问这样的问题：
对于这个产品来讲,哪些功能是必不可缺的？

电商产品是一个用户购买商品的地方,产品存在的核心价值是用户购买商品,那首先需要用户、然后需要商品、购买需要付款,所以在电商项目里用户、商品、订单和支付模块都必不可少
优惠券功能并不是购物流程中必备的一环,属于附加的功能,锦上添花的东西。在设计和开发项目时应优先完成基础的功能,让流程能尽快跑起来,尽早交付,快速迭代。

Web开发是个速度至上的领域,最小产品功能先上,测试的工作量也不会太大。不能憋大招,一个上线就是一大堆功能,复杂度增加的是无限的开发和调错时间,项目上线期限无尽延长。另一方面,用户能在最短时间内接触到产品,产品经理也可以尽快听到用户的反馈,及时调整产品战略,产品离成功会更进一步,这是一个多赢的方案。
这个思路也与敏捷开发的思路不谋而合：敏捷开发即是以用户的需求进化为核心,采用迭代、循序渐进的方法进行软件开发。

功能模块的开发优先级已经有了,接下来就是要动手开始写代码了

</pre>

<h4>创建应用</h4><pre>
3.用户模块
3.1. 注册与登录
用户即买家
Laravel自带了用户认证功能,可利用此功能来快速构建用户中心。
首先执行认证脚手架命令,生成代码：
$ php artisan ui:auth
命令make:auth会询问是否要覆盖app.blade.php,因为已经自定义了主要布局文件resources/views/layouts/app.blade.php,所以此处输入no
使用git status来查看文件更改的状态

</pre><textarea>
< !DOCTYPE html>
< html>
< head>
  < meta charset="utf-8">
  < meta http-equiv="X-UA-Compatible" content="IE=edge">
  < meta name="viewport" content="width=device-width, initial-scale=1">
  < meta name="csrf-token" content="{{ csrf_token() }}">
  < title>@yield('title',  'Laravel Shop')  - Laravel 电商教程< /title>
  < link href="{{ mix('css/app.css') }}" rel="stylesheet">
< /head>
< body>
  < div id="app"  class="{{ route_class() }}-page">
    @include('layouts._header')  
    < div class="container">
      @yield('content')  
    < /div> 
    @include('layouts._footer')  
  < /div>
  ＜script src="{{ mix('js/app.js') }}">＜/script>
< /body>
< /html>

</textarea><pre>
3.2. 验证邮箱
用户注册时系统会往用户邮箱发送一封带有验证链接的邮件,用户点击该链接即可证明这个邮箱是真实存在并且被对应的用户所拥有

3.3. 收货地址列表
user_addresses表的字段名称和类型：

字段名称	描述	类型	索引说明
id	自增长ID	unsigned big int	主键
user_id	该地址所属的用户	unsigned big int	外键
province	省	varchar	无
city	市	varchar	无
district	区	varchar	无
address	具体地址	varchar	无
zip	邮编	unsigned int	无
contact_name	联系人姓名	varchar	无
contact_phone	联系人电话	varchar	无
last_used_at

3.4. 新建收货地址

3.5. 修改和删除收货地址

4. 管理后台
4.1. 安装laravel-admin扩展包
encore/laravel-admin是一个可以快速构建后台管理的扩展包,它提供了页面组件和表单元素等功能,只需要使用很少的代码就实现功能完善的后台管理功能
$ composer require encore/laravel-admin "1.7.7"
$ php artisan vendor:publish --provider="Encore\Admin\AdminServiceProvider"  // 将Laravel-Admin的文件发布到项目目录中,如JS/CSS文件、配置文件等
$ php artisan admin:install  // 执行数据库迁移、创建默认管理
$ php artisan serve  // 运行服务查看效果
几个命令就可以完成一个功能比较齐全的资源操作后台管理系统，/admin,账号和密码都是admin
所有的配置都在config/admin.php文件中,代码主要集中在\APP\Admin中,默认系统提供了一个Dashboard界面,其它的静态资源文件放在/public/vendor/laravel-admin目录下
app/Admin/routes.php配置后台路由
app/Admin/bootstrap.php是laravel-admin的启动文件
app/Admin/Controllers目录用来存放后台控制器文件，该目录下的HomeController.php文件是后台首页的显示控制器

配置文件上传目录
编辑config/filesystems.php文件，在disks配置下添加如下内容,.env配置APP_URL=http://localhost:8002中的端口号
'admin' => [
  'driver' => 'local',
  'root' => public_path('upload'),
  'visibility' => 'public',
  'url' => env('APP_URL').'/upload/',
],

4.2. 用户列表
Laravel-Admin的控制器创建方式与普通的控制器创建方式不太一样,要用admin:make来创建：
$ php artisan admin:make UsersController --model=App\\Models\\User
其中--model=App\\Models\\User代表新创建的这个控制器是要对App\Models\User模型做增删改查

4.3. 权限设置
在Laravel-Admin创建一个拥有用户管理权限的运营角色及创建对应的运营人员

5. 商品模块
5.1. 商品的数据结构设计及创建数据模型
商品SKU的概念
SKU = Stock Keeping Unit库存量单位,也称单品,当一种商品品牌、型号、配置、等级、花色、包装容量、单位、生产日期、保质期、用途、价格、产地等属性中任一属性与其他商品存在不同时可称为一个单品
iPhone8就是商品,不同的版本、不同的存储容量所对应的具体型号就是这个商品的SKU,比如iPhone 8 - 无需合约版 - 红色 - 64G就是一个SKU,iPhone 8 - 无需合约版 - 红色 - 256G是另外一个SKU,不同的SKU价格可能不一样,库存也不一样

5.2. 后台商品列表
$ php artisan admin:make ProductsController --model=App\\Models\\Product  // 创建控制器

5.3. 后台创建和编辑商品

5.4. 商品列表页面

5.5. 商品筛选、排序

5.6. 商品详情页

5.7. 优雅地处理异常
if (!$product->on_sale) throw new \Exception('商品未上架');
此时页面显示500错误的提示,这样的提示对用户很不友好

5.8. 收藏商品
收藏商品本质上是用户和商品的多对多关联,因此不需要创建新的模型,只需要增加一个中间表即可：
$ php artisan make:migration create_user_favorite_products_table --create=user_favorite_products
中间表命名,要越直白越好,名字长点也无所谓。一个简单的判断命名是否合格的方法是 —— 想象自己半年一年以后是否能快速地从数据库表名得知此表的功能。

5.9. 收藏商品列表

6. 购物车 & 订单模块
6.1. 添加商品到购物车
购物车的数据通常会保存到Session或数据库。对于拥有多个端(网页、App)的电商网站来说为了保障用户体验会使用数据库来保存购物车中的数据,这样用户在网页端加入购物车的商品也能在App中看到
把购物车中的数据存入 cart_items 表,表结构如下：
字段名称	描述	类型	加索引缘由
id	自增长 ID	unsigned big int	主键
user_id	所属用户 ID	unsigned big int	外键
product_sku_id	商品 SKU ID	unsigned big int	外键
amount	商品数量	unsigned int	无

6.2. 查看购物车

6.3. 订单的数据模型
一笔订单支持多个商品SKU,因此需要orders和order_items两张表,orders保存用户、金额、收货地址等信息,order_items则保存商品SKU ID、数量及与orders表的关联。
orders表的字段：
字段名称	描述	类型	加索引缘由
id	自增长 ID	unsigned big int	主键
no	订单流水号	varchar	唯一
user_id	下单的用户 ID	unsigned big int	外键
address	JSON 格式的收货地址	text	无
total_amount	订单总金额	decimal	无
remark	订单备注	text	无
paid_at...

6.4. 购物车下单页面
通常来说用户重复使用最近用过的地址概率比较大,因此我们在取地址的时候根据 last_used_at 最后一次使用时间倒序排序,这样用户体验会好一些

6.5. 关闭未支付订单
上一节实现了创建订单的功能,在创建订单的同时减去了对应商品SKU的库存,恶意用户可以通过下大量的订单又不支付来占用商品库存,让正常的用户因为库存不足而无法下单。因此需要有一个关闭未支付订单的机制,当创建订单之后一定时间内没有支付,将关闭订单并退回减去的库存。
这个需求可以用Laravel提供的延迟任务(Delayed Job)功能来解决。当系统触发了一个延迟任务时Laravel会用当前时间加上任务的延迟时间计算出任务应该被执行的时间戳,然后将这个时间戳和任务信息序列化之后存入队列,Laravel的队列处理器会不断查询并执行队列中满足预计执行时间等于或早于当前时间的任务。
通过 make:job 命令来创建一个任务：
$ php artisan make:job CloseOrder
创建的任务类保存在app/Jobs目录下

6.6. 用户订单列表

6.7. 用户订单详情页

6.8. 封装业务代码
在本章节已经完成了购物车功能和下单功能,但发现Controller里面写了大量的包含复杂逻辑的业务代码,这是一个坏习惯,这样子随着需求的增加,控制器很快就变得臃肿。如果以后要开发App端,这些代码可能需要在Api的Controller里再重复一遍,假如出现业务逻辑的调整就需要修改两个或更多地方,这明显是不合理的。因此需要对逻辑复杂的业务代码进行封装
在项目里采用Service模式来封装代码。购物车的逻辑,放置于CartService类里,将下单的业务逻辑代码放置于OrderService里
首先创建一个CartService类：
$ mkdir -p app/Services && touch app/Services/CartService.php

7. 支付模块
7.1. 安装扩展包 yansongda/pay
支付库yansongda/pay封装了支付宝和微信支付的接口,通过这个库就不需要去关注不同支付平台的接口差异,使用相同的方法、参数来完成支付功能,节省开发时间
$ composer require yansongda/pay
配置参数
创建一个新的配置文件来保存支付所需的参数：
$ touch config/pay.php
return [
  'alipay' => [
    'app_id'         => '',
    'ali_public_key' => '',
    'private_key'    => '',
    'log'            => [ 'file' => storage_path('logs/alipay.log') ]
  ]
]

7.2. 集成支付宝
获取支付宝沙箱参数
支付宝有一个沙箱环境,可以不需要拥有真实的商家账号就可以进行支付的开发测试,用支付宝账号登录之后会看到如下界面

7.3. 订单的支付宝支付

7.4. 集成微信支付
微信支付的开发需要有一个微信公众号并且开通了微信支付才能正常进行,申请微信支付需要有公司资质。对于手上没有支付商户号的同学,可以大概地看下,知悉整个操作流程,心里有个概念,等以后在工作中遇到此类需求时,也可以胸有成竹。
首先访问微信支付商户平台https://pay.weixin.qq.com/

7.5. 订单的微信支付
微信支付配置的是正式参数,如果泄露将导致资金损失,所以不能把config/pay.php和resources/wechat_pay目录下的文件提交到公开代码库中,可以用如下命令让Git忽略这些文件：
$ git update-index --assume-unchanged config/pay.php
以及修改 .gitignore 文件：
.gitignore
/resources/wechat_pay
在正式的项目中由于不会提交到公开的代码仓库,因此不需要忽略这些文件。
Git 代码版本控制
现在让我们将这些变更加入到版本控制中：
$ git add -A
$ git commit -m "忽略微信支付证书"

7.6. 完善支付后逻辑
完成订单支付的部分后还要补充一些逻辑,比如支付之后要给订单中的商品增加销量,比如要发邮件给用户告知订单支付成功
商品增加销量和发送邮件并不会影响到订单的支付状态,即使这两个操作失败了也不影响后续的业务流程,对于此类需求通常使用异步事件来解决
接下来来创建一个支付成功的事件：
$ php artisan make:event OrderPaid
app/Events/OrderPaid.php
use App\Models\Order;
class OrderPaid{
    use Dispatchable, InteractsWithSockets, SerializesModels;

    protected $order;

    public function __construct(Order $order){
        $this->order = $order;
    }

    public function getOrder(){
        return $this->order;
    }
}
事件本身不需要有逻辑,只需要包含相关的信息即可,在这个场景里就只需要一个订单对象。
接下来在支付成功的服务器端回调里触发这个事件

8. 完善订单模块
8.1. 管理后台 - 订单列表

8.2. 管理后台 - 订单详情

8.3. 管理后台 - 订单发货

8.4. 用户界面 - 确认收货

8.5. 评价商品
由于需要对用户提交的数据进行校验,因此需要先创建一个Request类：
$ php artisan make:request SendReviewRequest

8.6. 用户界面 - 申请退款
首先创建一个ApplyRefundRequest来校验用户提交的退款申请,要求用户提交退款理由：
$ php artisan make:request ApplyRefundRequest
退款请求只需要用户提交申请退款理由即可：

8.7. 管理后台 - 拒绝退款
先创建一个HandleRefundRequest来校验运营人员处理退款的请求：
$ php artisan make:request Admin/HandleRefundRequest

8.8. 管理后台 - 同意退款(支付宝)
生成退款订单号
不管是支付宝还是微信,在申请退款的时候都需要提交一个唯一字符串作为退款订单号,之后可以通过退款订单号来查询退款进度,退款的回调也会带上退款订单号。
选择在 Order 模型中写这个逻辑：
app\Models\Order.php
use Ramsey\Uuid\Uuid;
public static function getAvailableRefundNo(){
  do {
    $no = Uuid::uuid4()->getHex();  // Uuid类可以用来生成大概率不重复的字符串,为了避免重复在生成之后在数据库中查询看看是否已经存在相同的退款订单号
  } while (self::query()->where('refund_no', $no)->exists());
  return $no;
}
接下来要完善之前在OrdersController里的handleRefund()方法,由于调用退款的逻辑比较多,因此单独拆出一个方法_refundOrder()

8.9. 管理后台 - 同意退款(微信)

9. 优惠券模块
9.1. 管理后台 - 优惠券列表
字段名称	描述	类型	加索引缘由
id	自增长ID	unsigned big int	主键
name	优惠券的标题	varchar	无
code	优惠码,用户下单时输入	varchar	唯一
type	优惠券类型,支持固定金额和百分比折扣	varchar	无
value	折扣值,根据不同类型含义不同	decimal	无
total	全站可兑换的数量	unsigned int	无
used	当前已兑换的数量

9.2. 管理后台 - 添加、修改、删除优惠券

9.3. 用户界面 - 检查优惠券

9.4. 用户界面 - 使用优惠券下单
使用优惠券来下单是优惠券模块中最核心的部分

9.5. 优化优惠券模块
一张优惠券一个用户只能使用一次
通常一张优惠券对每一个用户来说只能使用一次,这里对使用的定义是：有关联了此优惠券的未付款且未关闭订单或已付款且未退款成功订单

10. 杂项
10.1. 配置后台权限
完成了后台所有的功能开发(用户管理、商品管理、订单管理、优惠券管理)后需要给运营角色配置对应的权限

10.2. 完善假数据填充
用户假数据
Laravel默认就已经创建好了User模型的工厂文件,因此只需要编写Seeder文件即可：
$ php artisan make:seed UsersSeeder
database/seeds/UsersSeeder.php

use Illuminate\Database\Seeder;
class UsersSeeder extends Seeder{
  public function run(){
    factory(\App\Models\User::class, 100)->create();  // 通过factory方法生成100个用户并保存到数据库中
  }
}

收货地址假数据
之前已经完成了收货地址的工厂文件,因此只需要编写Seeder文件即可：
$ php artisan make:seed UserAddressesSeeder

10.3. 备份管理后台数据
在管理后台配置的菜单、权限都是保存在数据库里,没有办法像代码文件一样提交到Git版本库中,因此需要把开发环境中配置好的后台信息导出成SQL文件,然后把SQL文件提交到Gi版本库中
首先需要明确要备份哪些表里的数据,打开数据库管理工具,看看数据库里有哪些与管理后台相关的表
以admin_开头的表就是Laravel-Admin使用的表,从表名我们可以判断出各自的作用：
admin_menu —— 管理后台的菜单;
admin_operation_log —— 管理后台操作日志;
admin_permissions —— 权限列表;
admin_role_menu —— 角色与菜单的关联关系;
admin_role_permissions —— 角色与权限的关联关系;
admin_role_users —— 管理员与角色的关联关系;
admin_roles —— 角...

10.4. 系统安全
对于一个电商系统来说,安全性是一个很重要的指标,因为涉及到金钱交易,如果出现重大安全漏洞可能导致经济上的损失
SQL注入是最古老、最流行同样也是危害最大的漏洞之一,这个漏洞的核心就一句话：将未经过滤的用户输入拼接到SQL语句中
$product = DB::select("select * from products where id = '".$_GET['id']."'");
这个时候用户提交的id如果是1 and 1 = 2,那么最终被执行的SQL就是select * from products where id = 1 and 1 = 2
很明显这个SQL查出来的结果必然为空,那么页面就会显示该商品不存在。
但仅仅是这样感觉好像没有什么危害,那这个时候攻击者提交的id参数变成了：
1 and exists (select * from admins where name = 'admin')

10.5. Laravel-Shop电商系统的开发知识：
使用Laravel创建新项目;
composer autoload功能的使用姿势;
Laravel Mix的基本用法;
使用Laravel快速构建用户登录、注册功能;
使用MailHog调试邮件发送功能;
使用Laravel的Notification模块发送邮件;
优雅地处理Laravel项目中的异常;
事件与监听器的使用;
使用授权策略来控制权限;
使用overtrue/laravel-lang来汉化错误信息;
laravel-admin扩展包的安装与配置;
使用laravel-admin快速构建对模型的增删改查功能;
使用laravel-admin配置后台用户角色、权限;
商品SKU的概念;
使用查询构造器根据用户输入来动态构建查询SQL;
设置Laravel路由顺序的正确姿势;
购物车的设计与实现;
使用闭包来校验用户输入;
订单流水号的生成;
创建订单时保存用户收货地址信息的正确姿势;
代表状态的值应使用常量;
在Laravel中使用数据库事务的正确姿势;
高并发下减商品库存的正确姿势;
延迟任务的使用;
使用预加载与延迟预加载解决数据库N+1问题;
通过对业务代码的封装来提高代码的复用性;
yansongda/pay扩展包的安装与配置;
支付宝沙箱账号的申请与配置;
微信扫码支付的开通与配置;
拉起支付宝、微信支付;
支付的前端回调与后端回调的概念;
在本地开发环境处理支付宝、微信支付后端回调的正确姿势;
二维码的生成;
管理员收到支付订单开始发货;
用户收到商品后确认收货;
用户确认收货后选择退款;
管理员接到退款请求后的拒绝退款;
支付宝、微信支付的退款处理;
优惠券的设计与实现;
laravel-admin配置的备份与恢复;
常见Web项目漏洞类型及在Laravel项目中的防御措施。

10.6. 电商进阶内容包含：
无限级商品类目;
分面搜索(专业搜索引擎Elasticsearch );
商品推荐系统;
秒杀技术要点;
众筹;
分期付款;
正式环境部署;
服务器性能优化等。

10.7. 尝试给 Laravel-Shop 添加更多功能：
给SKU设置单独的图片,用户点击SKU时左侧展示对应的图片;
更完善的商品筛选、排序机制,如按价格范围筛选;
根据物流公司和单号跟踪物流动态;
更强大的优惠券功能,如打折券有减免上限、仅部分商品可用等
制作数据报表,在后台展示每天的新用户注册量、销量等统计信息。

demos
扩展了商品的 SKU 设计以及常用功能https://github.com/zuiqiangqishao/Laravel-shop
https://github.com/ycs77/Laravel-shop

</pre>
</div>

<div id="shop2">
<h3>Laravel Shop2 demo https://github.com/summerblue/laravel-shop/tree/L06_5.8是advance分支</h3><pre>
开发以下功能：
高性能无限级分类;
众筹商品管理;
众筹商品下单逻辑;
众筹商品结束逻辑;
使用分期付款支付订单;
计算分期付款逾期费;
分期付款订单的退款;
给商品增加属性;
使用 Elasticsearch 重构商品搜索模块;
分面搜索;
相似商品查询;
Elasticsearch 的索引迁移;
秒杀商品管理;
秒杀商品下单逻辑;
秒杀接口性能优化;
编写部署脚本;
多机部署实现负载均衡。

本课程的代码是在课程五的代码 Laravel Shop 为基础开发的,因此需要先将 Laravel Shop 安装到 Homestead 中

初始化数据库
清空数据库：php artisan migrate:fresh && php artisan migrate:reset,然后继续后面的操作。
执行数据库迁移： $ php artisan migrate
然后导入管理后台数据： $ mysql laravel-shop < database/admin.sql
管理后台初始账号：admin 密码：admin,后台地址为 http://shop.test/admin

配置集成支付宝支付
获取支付宝沙箱参数
支付宝有一个沙箱环境,可以让我们不需要拥有真实的商家账号就可以进行支付的开发测试。
首先访问https://openhome.alipay.com/platform/appDa... ,用你的支付宝账号登录
点击 设置应用公钥 链接
点击 设置应用公钥 按钮
点击 查看秘钥生成方法

. 商品类目
3.1. 商品类目数据库结构设计
3.2. 数据库填充
3.3. 商品类目管理后台
3.4. 调整后台商品管理
3.5. 完善前台商品列表页
3.6. 前台类目菜单

第四章. 众筹
4.1. 众筹业务逻辑
众筹是近几年开始流行的一种电商形式,对于一些研发智能硬件的创业公司来说,众筹是一种很合适的销售方案,公司可以根据众筹的金额、数量预估产品的受欢迎程度,同时销售数据也可以作为产品产量的一个参考,这样就不会因为产量过多导致库存积压,也不会因为产量过少导致光有口碑却没有足够的销量。
淘宝、京东都推出各自的众筹平台

众筹的业务逻辑
与普通商品相比,众筹商品有如下特殊的业务逻辑：
需要设置目标金额与截止时间;
到达截止时间时如果总订单金额低于目标金额则众筹失败,并退款所有订单;
到达截止时间时如果总订单金额大等于目标金额则众筹成功。
众筹订单不支持用户主动申请退款;
在众筹成功之前订单不可发货。

4.2. 众筹商品数据库结构设计
由于众筹相关的字段并不是所有商品都需要,因此比较合适的方案是用一个新的表来保存,新表与商品表的关联关系为一对一
crowdfunding_products字段：
字段名称	描述	类型	加索引缘由
id	自增长 ID	unsigned big int	主键
product_id	对应商品表的 ID	unsigned big int	外键
target_amount	众筹目标金额	decimal	无
total_amount	当前已筹金额	decimal	无
user_count	当前参与众筹用户数	unsigned int	无

4.3. 后台众筹商品管理
4.4. 代码封装
在实现众筹商品管理时,会发现大部分代码都与普通商品管理的控制器里的代码相同,假如之后我们添加了新的商品类型(比如秒杀),在编写后台管理时还需要再复制一份类似的代码,而且以后如果添加了一些公共的商品字段,就需要同时修改所有类型商品的后台控制器。
这种冗余的代码会让我们的项目产生较重的『技术债务』,因此我们需要把通用的代码封装起来,这样以后添加新的商品类型时只需要编写与普通商品不同字段的相关代码即可
代码分析,接下来我们来分析一下哪些地方是可以共用的

4.5. 下单逻辑
由于众筹商品的特殊性,众筹商品无法与像普通商品那样加入购物车后再统一下单,有如下几个原因：
众筹商品只有众筹成功之后才可以发货;
众筹订单不支持用户主动申请退款;
众筹商品不允许使用优惠券购买;
众筹失败的情况下会退款,如果众筹商品和普通商品混合在一起,处理退款时就需要部分退款,可能需要引入额外的表来记录相关信息。
因此在实现众筹商品下单时通常会跳过购物车这一步,直接创建一个只有一个商品的订单

4.6. 订单模块调整
先来回顾一下众筹的两个业务逻辑：
众筹订单不支持用户主动申请退款;
在众筹成功之前订单不可发货。
可见当订单是一个众筹商品订单时,系统会有与普通订单不同的处理逻辑。
在现有的数据库结构下要实现这些逻辑时只能通过判断订单下SKU对应商品是否众筹商品才能确定是否是一个众筹商品订单,这样不仅实现繁琐,还会有不少额外的SQL查询。
为了解决这个问题,可以在订单表中添加一个type字段来表明这个订单是普通商品订单还是众筹商品订单

4.7. 测试支付
现在需要测试一下支付成功之后的逻辑。
在上一个课程开发支付宝和微信支付的过程中,由于开发环境没有外网IP,支付宝和微信支付的回调无法直接访问到开发环境的接口,每次支付都需要使用Requestbin捕获支付成功回调,然后再在终端里使用curl手动请求开发环境的回调接口,十分麻烦。
为了更专注于业务功能的开发,下面学习一下内网穿透神器 Ngrok 的使用。
Ngrok是一个反向代理软件,启动后会在公共服务器和本地客户端之间建立一个通道,并由公共服务器分配一个唯一的域名给这个通道。在 Homestead 中运行 Ngrok 之后,通过公共服务器分配的域名就可以在公网访问到 Homestead 中的站点,从而让支付宝和微信支付的服务器直接将回调数据发送到对应的回调接口
Ngrok 官方提供了免费的公共服务器,但需要注册才能使用

4.8. 众筹结束逻辑
在 Laravel 框架下,要触发众筹结束的处理逻辑有两种方案：
使用异步延迟任务(Delayed Job),在创建众筹商品时就发起一个执行结束逻辑的异步延迟任务;
使用定时任务,每隔一段时间就扫描所有众筹状态为众筹中且众筹结束时间比当前时间要早的众筹商品。
相较于定时任务,异步延迟任务的优点很明显,就是可以较精确地在众筹结束时间执行众筹结束逻辑。但是也有一个致命的问题,假如运营人员修改了众筹商品的众筹结束时间,而我们却无法通过代码取消掉之前发起的异步延迟任务,这是由 Laravel 异步延迟任务的实现方案决定的,目前没有合适的方案来解决这个问题。因此这个方案我们没有采用。
而定时任务是不会有延迟任务这样的问题,虽然无法做到像延迟任务那样精确,但只要设定一个较为合理的任务间隔,比如每分钟一次,就可以把结束时间的误差控制在 1 分钟以内,对于大多数众筹项目来说 1 分钟的误差几乎没有影响。因此选择定时任务作为

4.9. 测试众筹结束逻辑
先来测试一下众筹失败逻辑,把之前的众筹商品的结束时间调整为当前时间之前并保存

第五章. 分期付款
5.1. 分期付款业务逻辑
各大电商网站都推出各自的分期付款方案,比如京东的白条分期、支付宝的花呗分期,用户只需要支付一定比例的首付款,即可购得相应的商品。电商网站支持分期付款可以在一定程度上提高商品的销量。

对于分期付款来说,有以下规则：

只有当商品订单总金额高于某个数值时才可以使用分期付款;
用户使用分期付款时,需要选择还款期限,通常为 3 个月的倍数;
使用分期付款需要支付手续费,不同的还款期限手续费费率不同,还款期限越久费率越高;
分期付款的手续费与银行贷款的利息不同,银行贷款的利息会随着还款而逐渐降低,而分期付款的手续费则是固定的;
使用分期付款后,用户需要立即支付第一期的费用,当第一期费用支付成功后,对应的商品订单状态即变为已支付;
用户需每 30 天还款一次,如果在还款截止日期之后仍未还款,需支付逾期费,逾期费按天计算;
逾期之后产生的逾期费用最...

5.2. 分期付款数据库结构设计
根据分期的业务逻辑,我们认为需要两个表来保存相应的信息,一个是分期信息表,用于保存分期付款的总体信息,如用户ID、还款期数、总金额等;另一个是还款计划表,用于保存每一次还款的信息,如还款期限、当期本金、当期手续费、当期逾期费等。

5.3. 实现分期付款的创建
配置文件
在开始之前需要先设定一下分期的手续费率、逾期费率及最低分期金额。
为了简单起见把费率写在配置文件中,在正式的项目可以考虑将这个配置存储到数据库中,同时做一个后台页面对这个配置做修改,这样就可以让运营人员自行调整相关参数而不需要修改代码配置了。
config/app.php
'installment_fee_rate' => [
    3  => 1.5, 
    6  => 2,
    12 => 2.5,
], // 分期费率,key为期数,value为费率
'min_installment_amount' => 300, // 最低分期金额
'installment_fine_rate' => 0.05, // 逾期日息 0.05%

逻辑分析
可以把分期付款想象成与支付宝、微信等支付网关一样,是一种支付方式,同样有拉起支付 + 支付回调这两个步骤。
想象一下完成一笔支付的过程中,支付网关做了哪些事情

5.4. 分期付款列表页
5.5. 分期详情页
5.6. 分期还款(支付宝)
实现思路
分期还款的支付与商品订单的支付是类似的,需要拉起支付 + 支付回调两个步骤。
由于分期还款的支付回调逻辑与普通商品订单支付回调逻辑是独立的,需要用另外的支付回调地址,因此需要在拉起支付的时候用还款回调地址覆盖掉之前在AppServiceProvider中设置的商品订单支付回调地址。
对于支付回调,需要判断当前还款的是第几期：如果是第一期,则需要将分期付款的状态修改为『还款中』,将对应的商品订单的支付状态标记为『已支付』,并触发一个商品订单已支付的事件;如果是最后一期则需要将分期付款的状态改为『已还清』。

5.7. 分期还款(微信支付)
5.8. 计算逾期费
逾期费的计算公式为：逾期天数 * 逾期金额 * 逾期费率,假设逾期费率为 0.05%,逾期金额(即当期本金 + 手续费)为1000,逾期10天,那么逾期费为10 * 1000 * 0.05% = 5 元。
由于国家规定逾期费不得超过当期本金 + 手续费,如果上述公式计算出来的逾期费超过了1000元则逾期费为1000元
逾期费是按天计算的,可以用定时任务来实现,每天凌晨查询出所有未还款但已超过还款期限的还款计划
首先创建一个命令：
$ php artisan make:command Cron/CalculateInstallmentFine

5.9. 退款处理
实现方案
退款操作是同步的,当运营人员点击同意退款之后,后端接口会直接调用对应支付网关的退款接口,然后将退款结果返回给浏览器。
但是对于分期付款来说,由于有多笔支付,如果仍然采用同步的方式退款,一是可能耗时比较长;二是假如中途某笔退款失败,我们很难决定这个分期付款的退款到底是成功还是失败。
可以参考一下微信支付的思路,在做微信退款时调用的微信支付接口并不会告诉退款成功没有,只是告诉退款申请收到了,等微信处理好之后再把结果通过后端回调告诉我们。
因此这边可以用一个异步队列来实现这个退款操作
创建异步任务
现在通过make:job命令创建一个任务：
$ php artisan make:job RefundInstallmentOrder

第六章. 搜索准备
6.1. 商品属性
在开始学习Elasticsearch之前,先在系统中加入商品属性的功能,为之后的分面搜索做准备。
商品属性是一组结构化的数据,用键值对的方式将商品的一系列特征展示给用户,这样可以让用户更容易了解该商品的一些数据,同时也可以通过这些属性来搜索、筛选商品

字段名称	描述	类型	加索引缘由
id	自增长 ID	unsigned big int	主键
product_id	商品 ID	unsigned big int, null	外键
name	属性名称	varchar	无
value	属性值	varchar	无

接下来创建商品属性的模型

6.2. 商品长标题
商品标题是电商系统搜索引擎一个权重很高的字段,为了使商品能够更容易被搜索出来,往往会在商品标题里添加很多关键字。
但电商网站为了页面样式能够统一,商品列表页面所能展示的字符数量通常会有所限制,不会超过两行
为了解决这个问题,电商网站通常都会引入一个商品长标题的字段,在商品列表页面展示短标题,在详情页面展示长标题
同时长标题的搜索权重略低于短标题但要高于商品描述

6.3. 导入商品数据
为了让之后的搜索更贴近真实情况,需要用一批真实的商品数据,从某著名电商网站复制了一些内存条的商品数据做成一个 Seeder。

6.4. Homestead启用Elasticsearch
以下所有命令都是在Homestead虚拟机中运行

6.5. Elasticsearch 基础概念
选用Elasticsearch作为底层的搜索引擎,目前Elasticsearch的最新版本是7.x,本课程所有的搜索代码都是基于7.x版本
Elasticsearch是一个分布式的搜索和分析引擎,可以用于全文检索、结构化检索和分析,并能将这三者结合起来。Elasticsearch基于Lucene开发,是Lucene的封装,提供了REST API的操作接口,开箱即用。现在是使用最广的开源搜索引擎之一,Wikipedia、Stack Overflow、GitHub等都基于Elasticsearch来构建他们的搜索引擎
Elasticsearch是一个非常灵活和强大的搜索引擎,涉及到非常多的概念
Elasticsearch本质上是一个数据库,但并不是MySQL这种关系型数据库,查询语言也不是SQL,而是Elasticsearch自己的一套查询语言。
既然是数据库,有一些概念是互通的

6.6. 在 Laravel 中使用 Elasticsearch
引入Composer包
Elasticsearch官方提供了Composer包,在引入时需要注意要指定版本,因为不同版本的Elasticsearch的API略有不同,用的是7.x,因此需使用~7.0来指定包版本。
$ composer require elasticsearch/elasticsearch '~7.0'
为什么不用Scout？
Scout是Laravel官方出的一个让Eloquent模型支持全文搜索的包,这个包封装好一批方法,通过这些方法就可以将数据索引到全文搜索引擎中、以及使用关键字从

6.7. 创建商品索引
创建一个新的 Elasticsearch 索引用以存放商品数据,以供之后的搜索使用
创建索引
现在需要重新创建一个Elasticsearch索引用于保存商品数据,名为products：
$ curl -XPUT http://localhost:9200/products?pretty
接下来定义商品字段：
$ curl -H'Content-Type: application/json' -XPUT http://localhost:9200/products/_mapping/?pretty -d'{
  "properties": {
    "type": { "type": "keyword" } ,
    "title": { "type": "text", "analyzer": "ik_smart" }, 
    "long_title": { "type": "text", "analyzer": "ik_smart" }, 
    "category_id": { "type": "integer" },
    "category": { "type": "keyword" },
    "category_path": { "type": "keyword" },
    "description": { "type": "text", "analyzer": "ik_smart" },
    "price": { "type": "scaled_float", "scaling_factor": 100 },
    "on_sale": { "typ...

6.8. 索引商品数据
上一节创建了商品索引,并手动将一个商品存入了Elasticsearch,接下来需要将这个过程写成代码,当创建新的商品或修改了商品信息时能够自动同步到Elasticsearch

同步已有数据
首先需要把系统中已有的商品数据同步到Elasticsearch中,可以创建一个Artisan命令来实现：
$ php artisan make:command Elasticsearch/SyncProducts

6.9. Elasticsearch 查询入门
前面几节完成了搜索的准备工作,本章节将要学习一些Elasticsearch的查询语句
布尔与词项查询
在开始之前先简单了解一下Elasticsearch的布尔查询(Bool Query)。布尔查询与SQL语言中的and/or有些类似,可以根据多个条件来筛选文档。

布尔查询下可以有filter/must/should/must_not 4类条件,每个类条件对应的项都是一个数组,数组内每个项对应一个条件。其中filter和must与SQL中的and类似,查询的文档必须符合这两类下的条件,只不过must下的条件会参与打分而filter下的条件不会;must_not和must相反,查询的文档必须不符合此类下的条件;should下的条件不需要全部满足,默认情况下只需要满足should下的一个条件即可,也可以通过minimum_should_match参数来改变需要满足的个数,满足的should

第七章. 搜索进阶
7.1. 开始搜索
开始改造商品搜索页,改为使用Elasticsearch查询
首先先实现分页与排序功能,先不管搜索以及类目功能

7.2. 分面搜索
现在完成了Elasticsearch搜索的改造,实现了最基本的搜索功能,接下来将要把这个搜索引擎做得更强大。
这一节将要实现的功能是分面搜索,可以在京东上搜索一下内存条,可以看到京东把一些属性聚合在一起并做成了链接,可以直接点击链接来进一步筛选商品,这个就叫分面搜索
分面搜索是电商系统搜索引擎一个非常重要的功能,可以帮助用户更方便地搜索到自己想要的商品
要实现分面搜索并不是一个简单的事情,我们将一步一步往目标靠近,首先我们试着把搜索结果中所有的商品属性名取出来(即properties.name),比如上图中的『频率』、『单套容量』,这就需要用到Elasticsearch的聚合。
Elasticsearch中的聚合与SQL语句的group by有些类似,但更加灵活和强大

7.3. 优化分面搜索
上一节我们完成了商品列表分面搜索功能,但是隐藏了一个不太容易发现的Bug,接下们需要复现这个Bug并将其修复。

1. 复现 Bug
首先复现这个Bug,这个Bug与商品属性值的筛选有关,需要找两个商品编辑商品属性,为了方便测试,挑选两个内存条商品来编辑：
第一个商品添加两个属性,分别为：条数 - 1,版本 - 2
第二个商品也是添加两个属性,但是值反过来：条数 - 2,版本 - 1
确保队列处理器在运行,将我们的变更同步到 Elasticsearch
接下来我们到前台商品列表页,搜索『内存条』

7.4. 同义词搜索
前面实现的搜索功能都是基于商品本身的字段值,某个商品想要在某个关键词的搜索结果中出现,就必须在长标题或者内容中出现该关键词,这样对运营人员很不友好,需要给商品配置大量的关键词才能让商品出现的频率提高。
为了解决这个问题,接下来将要让搜索引擎支持同义词,比如用户搜索苹果手机,那么字段包含iPhone的商品也会出现在搜索结果中。
作为目前最强大的开源搜索引擎,Elasticsearch是支持同义词搜索的,为了更好地理解Elasticsearch同义词搜索的工作原理,需要先了解一下相关的概念。
分析器：分析器是由字符过滤器、分词器、词语分析器

7.5. 代码封装
前面完成了商品列表的各项搜索功能,但商品列表控制器十分臃肿,有大量的代码用于构建Elasticsearch的查询,为了让代码布局更合理提高复用性,接下来对Elasticsearch的查询做一个简单的封装。

7.6. 推荐相似商品
推荐相似商品是电商系统常见的一个功能,通常会放在商品详情页,会根据当前商品的特征筛选出一批相似的商品展示给用户,可以有效提高用户的购买率

7.7. Elasticsearch 索引结构迁移(Migration)
前面完成了Elasticsearch相关的业务功能开发,在之前的开发过程中如果有涉及到商品索引的变更,都是通过手动调用Elasticsearch的接口完成的,这就如同MySQL的数据库结构变更都是由运维或者开发人员在代码上线时通过手动执行SQL来完成,这里会有两个问题：
在做某些变更时需要先关闭索引,完成变更之后再打开,需要执行很多次命令,操作起来比较麻烦;
索引的字段只能添加而不能修改,比如可以给nested类型的字段添加新的子字段,而integer类型的字段则无法被修改为string类型。
对于问题一可以通过写脚本的来避免手工操作的麻烦,但还是需要每次都编写对应的升级脚本;而问题二就更严重,需要删除掉旧的索引,根据新的结构创建新索引,然后还需要重新添加数据到索引中,可能会有较长的不可用时间

第八章. 部署
8.1. 创建阿里云服务器
在开发秒杀功能之前需要先将写好的Laravel项目部署到正式环境,因为在开发秒杀功能时我们需要将项目部署到云服务器上进行压力测试
阿里云的服务器是最适合这个课程学习的,理由如下：
打通支付宝实名,可以快速认证;
支持服务器按量付费;
支持停机不收费,不学习的时候关机就停止收费。
先完成注册与实名认证的流程,同时需要至少充值100元,这样才能开通按量付费服务器
建议充值 150 元以上,因为在开通或者升级按量付费服务器都需要保证余额不低于 100 元,之后的课程会涉及到开通新服务器和升级已有服务器。课程学习结束后可以将余额提现,整个课程下来消费一般不会超过 50 元

8.2. 安装运行环境
给新创建的服务器安装必要的运行环境,我们将通过一个脚本来安装,首先请确保通过 SSH 登录到了服务器上
阿里云的按量付费服务器关机一段时间之后再开机,公网IP可能发生改变,需要仔细检查。如果发生改变需要在Homestead的~/.ssh/config 里加入对应的新 IP

执行安装脚本
由于该脚本只支持 Ubuntu 16.04,请确保你的服务器系统无误。
然后执行如下命令：
$ wget -qO- https://raw.githubusercontent.com/summerblue/laravel-ubuntu-init/master/download.sh - | bash
如果遇到 GitHub 被墙,长时间未响应,可以改用 Gitee 版本 wget -qO- https://gitee.com/leo108/laravel-ubuntu-init/raw/master/download.sh - | bash
安装完毕之后会在屏幕上输出 Mysql 的 root 密码,请妥善保存

8.3. 手动部署代码
8.4. 使用Deployer部署(上)
前面用纯手工的方式完成了首次代码部署,如果之后有新的代码变更,需要做以下操作：
ssh登录到服务器;
使用git命令更新代码仓库;
如果有composer依赖变更,需要执行composer install;
如果.env文件有变更,需要通过scp或vim修改;
如果有数据库变更,需要执行php artisan migrate;
如果有队列相关的代码变更,需要执行php artisan queue:restart;
如果有Nodejs依赖变更,需要执行yarn;
如果有前端代码变更,需要执行yarn build。
如果用纯手工的方式部署会有以下问题：
容易遗漏步骤或者误操作;
在部署过程中站点可能不可用;
如果有多台服务器需要部署则会加剧上述两个问题。
为了解决这些问题,将要学习Deployer这个部署工具,Deployer可以让用PHP代码的方式描述部署步骤并执行。

8.5. 队列与定时任务
完成了Laravel Shop的Web站点部署,由于代码中使用了异步队列与定时任务,因此还需要做对应的部署操作。

使用Horizon管理定时任务
Horizon是Laravel官方推出的一个集成在Laravel项目中的Redis队列管理工具,包含了一个可视化面板和几个管理命令,可以更方便地管理异步任务。
$ composer require laravel/horizon
安装完成之后还需要把Horizon的配置文件和前端文件放到项目目录中：
$ php artisan vendor:publish --provider="Laravel\Horizon\HorizonServiceProvider"
现在访问http://shop.test/horizon看看Horizon的管理面板,默认这个页面只能在APP_ENV=local的环境可以看到,所以不用担心线上站点信息泄露。

8.6. 多机部署
在真实的项目中往往会用多台Web服务器来提高负载能力和稳定性,接下来调整一下部署脚本,使其支持多机部署

第九章. 秒杀
9.1. 数据库结构设计
实现秒杀功能,与众筹商品类似,秒杀商品也需要用单独的表来存储秒杀相关的数据
把秒杀商品的表命名为seckill_products,下面是对应的字段：

字段名称	描述	类型	加索引缘由
id	自增长ID	unsigned big int	主键
product_id	对应商品表的ID	unsigned big int	外键
start_at	秒杀开始时间	datetime	无
end_at	秒杀结束时间	datetime	无

根据上面整理好的字段创建对应的模型和迁移文件：
$ php artisan make:model Models/SeckillProduct -m

9.2. 秒杀商品管理后台
9.3. 实现下单逻辑
接下来需要实现最基本的抢购逻辑,暂时不需要考虑性能问题。
创建Request类
与众筹商品下单类似,需要创建一个秒杀商品下单的请求类,用于校验用户输入是否正确：

9.4. 压力测试
完成了秒杀商品的下单接口,接下来需要找出这个接口中可能的性能问题,因为即使一个非常小的性能问题,在秒杀这种短时间内大量请求的场景下,会被无限放大从而使整个站点不可用。
通常通过压力测试来模拟大量用户高并发请求这个接口,这样在开发阶段就可以知道哪些地方有性能问题,将这些问题消灭在上线前。同时还可以根据压力测试的结果大致预估出每台服务器可以承载多少的并发量,这样技术部门就可以根据运营部门预估的访问量来提前调整服务器数量,以更好地应对秒杀活动。
因此接下来将通过JMeter这款压力测试软件来对实现的秒杀接口进行测试,并通过对比测试结果来判断优化手段是否有效。
JMeter是一款由Apache基金会管理的使用Java开发的跨平台开源压力测试软件,可以用于HTTP/HTTPS、FTP、数据库、TCP等服务的压力测试,拥有多种测试结果展示方案,而且还支持Groovy和BeanShell脚本使其拥有强大的扩展能力。
由于JMeter是由Java开发的程序,因此需要有Java运行环境

服务器架构调整
之前创建的云服务器配置都不高,不太适合压力测试,接下来我们要调整一下云服务器规格

升级服务器配置
阿里云的服务器需要先停止才可以升级配置,进入ECS实例列表,选中所有实例,然后点击停止按钮
接下来点击更改实例规格链接
在实例规格的搜索框中填入c5.xlarge,选中对应的规格,然后点击确认调整按钮：
阿里云要求此时账户余额不低于100元人民币
然后对第二台服务器做同样的操作。然后返回实例列表,应该可以看到实例的配置都已经变成了4核8G

开始执行测试脚本。
启动压测的时候请保证当前设备所有的VPN、代理(SS、Surge)处于关闭状态,并尽量关闭其他占用系统CPU、内存的软件,否则会影响压测结果。

9.5. 减少SQL查询
前面已经榨干了Web服务器的性能,但不管用多大的并发,吞吐量总是在580左右,这是因为影响吞吐量的不仅仅是PHP-FPM进程数量,还有代码执行效率,而SQL查询是影响执行效率的一个重要因素,所以接下来将尽可能地减少秒杀接口的SQL查询数量
开启SQL日志
为了更清楚地了解在一次秒杀请求过程中发生了哪些SQL查询,需要先开启SQL日志
由于业务规则不允许一个用户同时存在两个未支付的秒杀订单,所以先在数据库中删掉之前创建的秒杀订单

优化思路
先来看看三个商品相关的SQL,这三个SQL是在Request类中用于判断用户提交的SKU ID是否属于一个秒杀商品、判断库存是否充足及当前是否在对应的商品秒杀期间。可以将秒杀商品的库存保存到Redis中,有用户创建秒杀订单就将对应的Redis值减一,秒杀订单被关闭就将其值加一。Redis的性能远高于MySQL,因此可以提高效率。
第一个SQL是在auth中间件校验用户登录状态时发出的查询,可以将这个查询延迟到判断库存之后,这样当秒杀商品已经没有库存的时候,提交下单请求就不会产生任何的SQL了。

9.6. 随机拒绝
在现在的实现中,每次提交秒杀下单请求至少会产生一次Redis查询,那有没有办法将这个查询也省掉呢？答案就是接下来我们将要学习的电商秒杀系统中另外一个大杀器：随机拒绝

原理介绍
电商秒杀系统都会需要用户提前预约,只有预约了的用户才有资格去参与秒杀。iPhoneX在天猫首发时10000部库存,而预约购买人数是100万,预约和库存比是100:1,一百个用户只有一个抢到
既然大部分人都不可能抢到,那完全可以在用户提交下单请求时生成一个0~100的随机数,如果这个数大等于2则直接告诉用户抢购的人太多请重试,落到Redis的请求就只剩下了2%即2万人
生成随机数的操作完全不涉及到其他服务,可以通过扩展Web服务器来线性地提高吞吐量,这就实现了用很低的成本消减掉98%的压力。

使用中间件实现
接下来就要实现随机拒绝功能,基于目前的实现,代码进入到控制器时就已经完成了Redis查询,因此需要在进入控制器之前就完成随机拒绝这个行为,在Laravel中可以用中间件来实现

10. 总结
10.2. Win安装JDK
判断是否已经安装
> javac -version
首先在官网下载JDK: https://www.oracle.com/java/technologies/javase-jdk8-downloads.html
下载合适的JDK之前需要先点击选择接受accept lincense agreement
下载完成后双击可执行文件jdk-8u121-windows-x64进入JDK的安装界面
在Win10系统下安装JDK完成后配置环境变量使JDK全局生效。首先找到JDK的安装目录C:\Program Files\Java\jdk1.8.0_121目录,复制以备后用。然后通过“控制面板”进入“系统”属性,实际上直接选择“此电脑”点击右键选择“属性”即可,选择“系统变量”区域的“新建”功能
设置系统变量名为JAVA_HOME,变量值为C:\Program Files\Java\jdk1.8.0_121,然后打开“系统变量”区域的Path,将%JAVA_HOME%\bin追加到Path变量值的最后面
命令行输入命令java验证是否按照成功

</pre>

</div>
</main>

<ol>
  <li><a href="#top">顶部</a></li>
  <li><a href="#route">route</a></li>
  <li><a href="#middleware">middleware</a></li>
  <li><a href="#controller">controller</a></li>
  <li><a href="#request">request</a></li>
  <li><a href="#response">response</a></li>
  <li><a href="#view">view</a></li>
  <li><a href="#blade">blade</a></li>
  <li><a href="#db">db</a></li>
  <li><a href="#migrate">migrate</a></li>
  <li><a href="#seeder">seeder</a></li>
  <li><a href="#factories">factories</a></li>
  <li><a href="#redis">redis</a></li>
  <li><a href="#orm">orm</a></li>
  <li><a href="#dbdemo">db demo</a></li>
  <li><a href="#front">front</a></li>
  <li><a href="#rule">rule</a></li>
  <li><a href="#shop">shop</a></li>
  <li>
    <a href="#todo" target="_blank">todo ▼</a>
    <ul>
      <li><a href="#todo">todo</a></li>
      <li><a href="#todo">todo</a></li>
    </ul>
  </li>
  <li><a href="https://learnku.com/docs/laravel/7.x/authentication/7474" target="_blank">doc7 ></a></li>
</ol>

<script src="vendors/jquery-3.3.1.min.js"></script>
<script src="vendors/public.js"></script>

</body>
</html>