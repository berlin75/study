<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>webpack</title>
<link href="vendors/public.css" rel="stylesheet" type="text/css">
<link rel="stylesheet" href="vendors/SyntaxHighlighter/shCoreDefault.css" />
</head>
<body>
<h1>webpack</h1>

<main>
<nav>
  <ul>
    <li class="home">
      <a href="#" onclick="location = location.hostname == 'localhost' ? '../' : './';return false;">STUDY</a>
    </li>
    <li class="it"><a href="javascript:;">webpack</a></li>
  </ul>
</nav>

<div id="webpack">
<pre>
javascript之所以需要打包合并,是因为模块化开发的存在。开发阶段需要将js文件分开写在很多零碎的文件中,方便调试和修改,但如果就这样上线,那首页的http请求数量将直接爆炸。同一个项目别人2-3个请求就拿到了需要的文件,而你的可能需要20-30个,结果就不用多说了。

但是合并脚本可不是"把所有的碎片文件都拷贝到一个js文件里"这样就能解决的,不仅要解决命名空间冲突的问题,还需要兼容不同的模块化方案,更别提根据模块之间复杂的依赖关系来手动确定模块的加载顺序了,所以利用自动化工具来将开发阶段的js脚本碎片进行合并和优化是非常有必要的

Js文件的一般打包需求:
代码编译(TS或ES6代码的编译)
脚本合并
公共模块识别
代码分割
代码压缩混淆

Webpack是一个前端资源模块加载打包工具,根据模块的依赖关系进行静态分析,然后将这些模块按照指定的规则生成对应的静态资源,Webpack可以将多种静态资源js、css、less转换成一个静态文件,减少了页面的请求

webpack用于编译JavaScript模块,完成安装后就可以通过webpack的CLI或API与其配合交互

webpack原理其实就是把所有非js资源都转换成js,如把一个css文件转换成"创建一个style标签并把它插入document"的脚本、把图片转换成一个图片地址的js变量或base64编码等,然后用CommonJS的机制管理起来

本质上webpack是一个JS应用程序的静态模块打包器(module bundler),当webpack处理应用程序时会递归地构建一个依赖关系图(dependency graph),其中包含应用程序需要的每个模块,然后将所有这些模块打包成一个或多个bundle,可由浏览器加载

任何时候一个文件依赖于另一个文件,webpack就把此视为文件之间有依赖关系,这使得webpack可以接收非代码资源(non-code asset)如图像或web字体),并且可以把它们作为依赖提供给应用程序

简单来说webpack就是一个JS的打包器,将各种模块(module)打包成资源文件;还可以通过Code Spliting来把代码分离到不同的bundle中,然后可以按需加载或并行加载这些文件;webpack可以使用loader来预处理文件,这允许打包除了js之外的任何静态资源

webpack能将资源转换为最适合浏览器的格式,提升应用性能,比如只引用被应用使用的资源(剔除未被使用的代码),懒加载资源(只在需要的时候才加载相应的资源)。对于开发阶段webpack也提供了实时加载和热加载的功能,大大地节省了开发时间。不过webpack最核心的还是打包的功能

【 安装 】
> mkdir webpack-demo && cd webpack-demo
> npm init -y                                    # 创建package.json文件
> npm install webpack webpack-cli --save-dev
> npx webpack --version                          # 查看webpack版本
> npx webpack help | findstr output              # 查看webpack帮助

本地安装
要安装最新版本或特定版本可运行以下命令之一：
npm install --save-dev webpack
npm install --save-dev webpack@< version >

如果使用webpack 4+版本还需要安装CLI,此工具用于在命令行中运行webpack
webpack4中cli工具分离成了webpack核心库与webpack-cli命令行工具两个模块,需要使用CLI必安装webpack-cli至项目中
npm install --save-dev webpack-cli

对于大多数项目建议本地安装,这可以在引入破坏式变更(breaking change)的依赖时更容易分别升级项目。通常webpack通过运行一个或多个npm scripts会在本地node_modules目录中查找安装的webpack：
"scripts": {
  "start": "webpack --config webpack.config.js"
}
在本地安装webpack后能够从node_modules/.bin/webpack访问它的bin版本

全局安装
以下的NPM安装方式将使webpack在全局环境下可用：
npm install --global webpack
不推荐全局安装webpack,这会将项目中的webpack锁定到指定版本,并且在使用不同的webpack版本的项目中可能会导致构建失败。

【 webpack来源 】
</pre>CommonJS的模块化规范<pre class="js">
// a.js依赖b.js和c.js,那么就在a.js的头部引入这些依赖文件
var b = require('./b')
var c = require('./c')
var n = b.square(2)

// b.js
exports.square = function(num) {
  return num * num
}

// c.js依赖d.js
var d = require('./d')
module.exports = d.PI

</pre><pre>
CommonJS在浏览器内并不适用。因为require()的返回是同步的,意味着有多个依赖的话需要一个一个依次下载,堵塞了js脚本的执行。所以人们就在CommonJS的基础上定义了Asynchronous Module Definition (AMD) 规范(2011年),使用了异步回调的语法来并行下载多个依赖项

</pre><pre class="js">
// 入口文件a.js
require(['./b', './c'], function(b, c) {
  var n = b.square(2)
  console.log(c)
})

// 相应的导出语法也是异步回调方式,比如c.js依赖d.js
define(['./d'], function(d) {
  return d.PI
})

</pre><pre>
定义一个模块是使用define()函数,define()和require()的区别是,define()必须要在回调函数中返回一个值作为导出的东西,require() 不需要导出东西,因此回调函数中不需要返回值,也无法作为被依赖项被其他文件导入,因此一般用于入口文件,比如页面中这样加载a.js:
< script src="js/require.js" data-main="js/a">< /script>

依托AMD模块化编程,SPA(Single-page application)的实现方式更为简单清晰,一个网页不再是传统的类似word文档的页面,而是一个完整的应用程序。SPA应用有一个总的入口页面,通常把它命名为index.html、app.html、main.html,这个html的body一般是空的,或只有总的布局layout

布局会把header、nav、footer的内容填上,但main区域是个空的容器。这个作为入口的html最主要的工作是加载启动SPA的js文件,然后由js驱动,根据当前浏览器地址进行路由分发,加载对应的AMD模块,然后该AMD模块执行,渲染对应的html到页面指定的容器内main。在点击链接等交互时,页面不会跳转,而是由js路由加载对应的AMD模块,然后该AMD模块渲染对应的html到容器内

虽然AMD模块让SPA更容易地实现,但小问题还是很多的：
1、不是所有的第三方库都是AMD规范的,这时候要配置shim,很麻烦。
2、虽然RequireJS支持通过插件把html作为依赖加载,但html里面的img的路径是个问题,需要使用绝对路径并且保持打包后的图片路径和打包前的路径不变,或者使用html模板语言把src写成变量,在运行时生成。
3、不支持动态加载css,变通的方法是把所有的css文件合并压缩成一个文件,在入口的html页面一次性加载。
4、SPA项目越做越大,一个应用打包后的js文件到了几MB的大小。虽然r.js支持分模块打包,但配置很麻烦,因为模块之间会互相依赖,在配置的时候需要exclude那些通用的依赖项,而依赖项要在文件里一个个检查。
5、所有的第三方库都要自己一个个的下载解压放到某个目录下,更别提更新。虽然可以用npm包管理工具,但npm的包都是CommonJS规范的,给后端Node.js用的,只有部分支持AMD规范,而且在npm3之前这些包有依赖项的话也是不能用的。后来有个bower包管理工具是专门的web前端仓库,这里的包一般都支持AMD规范。
6、AMD规范定义和引用模块的语法太麻烦,上面介绍的AMD语法仅是最简单通用的语法,API文档里面还有很多变异的写法,特别是当发生循环引用的时候(a依赖b,b依赖a),需要使用其他的语法解决这个问题。而且npm上很多前后端通用的库都是CommonJS的语法。后来很多人又开始尝试使用ES6模块规范,如何引用ES6模块又是一个大问题。
7、项目的文件结构不合理,因为grunt/gulp是按照文件格式批量处理的,所以一般会把js、html、css、图片分别放在不同的目录下,所以同一个模块的文件会散落在不同的目录下,开发的时候找文件是个麻烦的事情。code review时想知道一个文件是哪个模块的也很麻烦,解决办法比如又要在imgs目录下建立按模块命名的文件夹,里面再放图片

到了这里,webpack登场了,2012年

和webpack差不多同期登场的还有Browserify。Browserify的目的是让前端也能用CommonJS的语法require('module')来加载js。它会从入口js文件开始,把所有的require()调用的文件打包合并到一个文件,这样就解决了异步加载的问题。那么Browserify不足之处有下面几点：

1、最主要的一点,Browserify不支持把代码打包成多个文件,在有需要的时候加载。这就意味着访问任何一个页面都会全量加载所有文件。
2、Browserify对其他非js文件的加载不够完善,因为它主要解决的是require() js模块的问题,其他文件不是它关心的部分。比如html文件里的img标签,它只能转成Data URI的形式,而不能替换为打包后的路径。
3、因为上面一点Browserify对资源文件的加载支持不够完善,导致打包时一般都要配合gulp或grunt一块使用,无谓地增加了打包的难度。
4、Browserify只支持CommonJS模块规范,不支持AMD和ES6模块规范,这意味旧的AMD模块和将来的ES6模块不能使用。
基于以上几点,Browserify并不是一个理想的选择



【 使用Node-API 】
webpak暴露了一些方法,使得开发者可以通过调用他们而在脚本中启动webpack,使用的方法较为简单

</pre><pre class="js">
//webpack-node.js
const webpack = require('webpack');
const webpackConfig = require('./webpack.config.html.js');
const cowsay = require('cowsay');

const compiler = webpack(webpackConfig);

compiler.run((err, stats)=>{
  if(!err) {
    console.log(stats.toJson().assets);
    console.log(cowsay.say({text:'Congratulations!'}));
  }
});

</pre><pre>
代码的基本逻辑
引入了webpack模块以及webpack.config.html.js的配置文件(从这里就很容易理解为什么webpack的配置文件可以导出为一个函数或多个配置,它实际上也是作为一个模块参与到整个运行过程的),通过调用webpack([Object config])方法得到一个compiler实例,调用compiler.run方法就启动了webpack的构建功能,run方法的回调函数中如果有运行错误,可以通过err来获取,与构建过程有关的信息都挂载在stats对象(例如stats。toJson().assets)。这样便实现了以非命令行的方式启动webpack

</pre>【 webpack的作用和使用 】<pre class="js">
webpack-demo
|- package.json
|- index.html
|- /src
  |- index.js

// package.json
{
  "name": "webpack-demo",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "devDependencies": {
    "webpack": "^4.0.1",
    "webpack-cli": "^2.0.9"
  },
  "dependencies": {}
}

// src/index.js
function component() {
  var element = document.createElement('div');
  element.innerHTML = _.join(['Hello', 'webpack'], ' ');  // Lodash(目前通过一个 script 脚本引入)对于执行这一行是必需的
  return element;
}
document.body.appendChild(component());

// index.html
<!doctype html>
< html>
  < head>
    < title>起步< /title>
    < script src="https://unpkg.com/lodash@4.16.6">< /script>
  < /head>
  < body>
    < script src="./src/index.js">< /script>
  < /body>
< /html>

</pre><pre>
在此示例中script标签之间存在隐式依赖关系,index.js文件执行之前还依赖于页面中引入的lodash,之所以说是隐式的是因为index.js并未显式声明需要引入lodash,只是假定推测已经存在一个全局变量_

使用这种方式去管理JS项目会有一些问题：
1、无法立即体现,脚本的执行依赖于外部扩展库(external library)。
2如果依赖不存在,或者引入顺序错误,应用程序将无法正常运行。
3、如果依赖被引入但是并没有使用,浏览器将被迫下载无用代码。

使用webpack来管理这些脚本
首先调整目录结构,将"源"代码(/src)从"分发"代码(/dist)中分离出来,"源"代码是用于书写和编辑的代码,"分发"代码是构建过程产生的代码最小化和优化后的"输出"目录,最终将在浏览器中加载

</pre><pre class="js">
webpack-demo
|- package.json
|- /dist
  |- index.html
|- /src
  |- index.js

// 要在index.js中打包lodash依赖需要在本地安装library：
npm install --save lodash

// 在src/index.js脚本中import lodash
import _ from 'lodash';
function component() {
  var element = document.createElement('div');
  element.innerHTML = _.join(['Hello', 'webpack'], ' ');
  return element;
}
document.body.appendChild(component());

// dist/index.html
<!doctype html>
< html>
  < head>
    < title>起步< /title>
    < script src="https://unpkg.com/lodash@4.16.6">< /script>
  < /head>
  < body>
    < script src="main.js">< /script>
  < /body>
< /html>

</pre><pre>
在这个设置中index.js显式要求引入的lodash必须存在,然后将它绑定为_,没有全局作用域污染。通过声明模块所需的依赖,webpack能够利用这些信息去构建依赖图,然后使用图生成一个优化过的以正确顺序执行的bundle。
零配置执行npx webpack会将/src/index.js脚本作为入口起点,然后输出为/dist/main.js

</pre><pre class="js">
>npx webpack
Hash: c5ae2bffe6977e6a689f
Version: webpack 4.35.2
Time: 4960ms
Built at: 2019-07-09 2:50:21 AM
  Asset      Size  Chunks             Chunk Names
main.js  70.4 KiB       0  [emitted]  main
Entrypoint main = main.js
[1] ./src/index.js 268 bytes {0} [built]
[2](webpack)/buildin/global.js 472 bytes {0} [built]
[3](webpack)/buildin/module.js 497 bytes {0} [built]
    + 1 hidden module

</pre><pre>
ES2015中的import和export语句已经被标准化,虽然大多数浏览器还无法支持它们,但是webpack却能够提供开箱即用般的支持。
事实上webpack在幕后会将代码"转译",以便旧版本浏览器可以执行。如果检查dist/main.js可以看到webpack具体如何实现,除了import和export,webpack还能够很好地支持多种其他模块语法
webpack不会更改代码中除import和export语句以外的部分。如果在使用其它ES2015特性,请确保在webpack的loader系统中使用了一个像是Babel或Bublé的转译器

</pre>
</div>

<div id="webpack_modules">
<h4>模块(modules)</h4><pre>
在模块化编程中开发者将程序分解成离散功能块(discrete chunks of functionality),并称之为模块。

每个模块具有比完整程序更小的接触面,使得校验、调试、测试轻而易举。 精心编写的模块提供了可靠的抽象和封装界限,使得应用程序中每个模块都具有条理清楚的设计和明确的目的。

Node.js从最一开始就支持模块化编程。然而在web模块化的支持正缓慢到来。在web存在多种支持JavaScript模块化的工具,这些工具各有优势和限制。webpack基于从这些系统获得的经验教训,并将模块的概念应用于项目中的任何文件。

</pre><pre>
【 webpack模块 】
对比Node.js模块,webpack模块能够以各种方式表达它们的依赖关系,几个例子如下：
ES2015 import语句
CommonJS require()语句
AMD define和require语句
css/sass/less文件中的@import语句
样式(url(...))或HTML文件(< img src=...>)中的图片链接(image url)

【 支持的模块类型 】
webpack通过loader可以支持各种语言和预处理器编写模块。loader描述了webpack如何处理非JavaScript(non-JavaScript)模块,并且在bundle中引入这些依赖。webpack社区已经为各种流行语言和语言处理器构建了loader,包括：
CoffeeScript
TypeScript
ESNext(Babel)
Sass
Less
Stylus

总的来说,webpack提供了可定制的、强大和丰富的API,允许任何技术栈使用webpack,保持了在开发、测试和生成流程中无侵入性(non-opinionated)。

【 webpack模块类型及.mjs的支持 】
长久以来JS是webapck中唯一的模块类型,开发者无法有效地打包其它类型的文件。目前webpack实现了五种模块类型,它们各有自己的优势,可按需要使用
1、javascript/auto:(webpack3中默认)支持所有的JS模块系统：CommonJS、AMD、ESM。
2、javascript/esm: EcmaScript模块,所有其他模块系统不可用(.mjs文件中默认)。
3、javascript/dynamic: 不支持CommonJS和EcmaScript模块。
4、json: JSON数据,可以通过require和import导入(.json文件默认)。
5、webassembly/experimental: WebAssembly模式(目前处于实验性阶段,.wasm文件默认)。

javascript/esm相比于javascript/auto处理ESM更加严格,具体表现在两个方面：
1.导入的名称必须存在于导入的模块中。
2.动态的模块(非ESM,例如CommonJS)只能通过默认import导入,其他所有(包括命名空间导入)的导入都会报错

webpack按照.wasm, .mjs, .js以及.json等扩展名的顺序来解析

</pre>用法：module.rules中的type就是新增加的属性,用来支持不同的模块类型<pre class="js">
module: {
 rules: [{
   test: /\.special\.json$/,
   type: "javascript/auto",
   use: "special-loader"
 }]
}

</pre><pre>
【 JSON 】
webpack4不仅支持本地处理JSON,还支持对JSON的Tree Shaking。当使用ESM语法import json时webpack会消除掉JSON Module中未使用的导出。
此外如果要用loader转换json为js,需要设置type为javascript/auto,当然不用loader webpack依然可以正常工作

</pre><pre class="js">
module.rules: [
  {
    test: /\.special\.json$/,
    type: "javascript/auto",
    use: "special-loader"
  }
]

</pre><pre>
【 模块解析(module resolution) 】
resolver是一个库(library),用于帮助找到模块的绝对路径。一个模块可以作为另一个模块的依赖模块,然后被后者引用,如下：
import foo from 'path/to/module'
// 或者
require('path/to/module')

所依赖的模块可以是来自应用程序代码或第三方的库(library)。resolver帮助webpack找到bundle中需要引入的模块代码,这些代码在包含在每个 require/import语句中。 当打包模块时webpack使用enhanced-resolve来解析文件路径

【 webpack中的解析规则 】
使用enhanced-resolve,webpack能够解析三种文件路径：

1、绝对路径
import "/home/me/file";
import "C:\\Users\\me\\file";
由于已经取得文件的绝对路径,因此不需要进一步再做解析。

2、相对路径
import "../src/file1";
import "./file2";
在这种情况下使用import或require的资源文件(resource file)所在的目录被认为是上下文目录(context directory)。在import/require中给定的相对路径会添加此上下文路径(context path)以产生模块的绝对路径(absolute path)。

3、模块路径
import "module";
import "module/lib/file";
模块将在resolve.modules中指定的所有目录内搜索。 可以替换初始模块路径,此替换路径通过使用resolve.alias配置选项来创建一个别名。

一旦根据上述规则解析路径后,解析器(resolver)将检查路径是否指向文件或目录。如果路径指向一个文件：
如果路径具有文件扩展名则被直接将文件打包。
否则将使用[resolve.extensions]选项作为文件扩展名来解析,此选项告诉解析器在解析中能够接受哪些扩展名如.js,.jsx

如果路径指向一个文件夹则采取以下步骤找到具有正确扩展名的正确文件：
如果文件夹中包含package.json文件则按照顺序查找resolve.mainFields配置选项中指定的字段。并且package.json中的第一个这样的字段确定文件路径。
如果package.json文件不存在或package.json文件中的main字段没有返回一个有效路径则按照顺序查找resolve.mainFiles配置选项中指定的文件名,看是否能在import/require目录下匹配到一个存在的文件名。
文件扩展名通过resolve.extensions选项采用类似的方法进行解析。

webpack根据构建目标(build target)为这些选项提供了合理的默认配置。

【 解析 Loader(Resolving Loaders) 】
Loader解析遵循与文件解析器指定的规则相同的规则。但是resolveLoader配置选项可以用来为Loader提供独立的解析规则。

【 缓存 】
每个文件系统访问都被缓存,以便更快触发对同一文件的多个并行或串行请求。在观察模式下只有修改过的文件会从缓存中摘出。如果关闭观察模式,在每次编译前清理缓存。

</pre>
</div>

<div id="webpack_cli">
<h3>命令行接口cli(command line interface)</h3><pre>
为了更合适且方便地使用配置,可以在 webpack.config.js 中对 webpack 进行配置。CLI 中传入的任何参数会在配置文件中映射为对应的参数

使用配置文件的用法
webpack [--config webpack.config.js]
配置文件中的相关选项

不使用配置文件的用法
webpack < entry> [< entry>] -o < output>
entry:一个文件名或一组被命名的文件名,作为构建项目的入口起点。可以传递多个入口(每个入口在启动时加载)。如果传递一个形式为name = request的键值对则可以创建一个额外的入口起点。它将被映射到配置选项(configuration option)的entry属性。
output:要保存的bundled文件的路径和文件名。它将映射到配置选项output.path和output.filename。

假设项目结构像下面这样：
├── dist
├── index.html
└── src
    ├── index.js
    ├── index2.js
    └── others.js

webpack src/index.js dist/bundle.js
打包源码,入口为index.js,并且输出文件的路径为dist,文件名为bundle.js
| Asset     | Size    | Chunks      | Chunk Names |
|-----------|---------|-------------|-------------|
| bundle.js | 1.54 kB | 0 [emitted] | index       |
[0] ./src/index.js 51 bytes {0} [built]
[1] ./src/others.js 29 bytes {0} [built]

webpack index=./src/index.js entry2=./src/index2.js dist/bundle.js
以多个入口的方式打包文件
| Asset     | Size    | Chunks        | Chunk Names   |
|-----------|---------|---------------|---------------|
| bundle.js | 1.55 kB | 0,1 [emitted] | index, entry2 |
[0] ./src/index.js 51 bytes {0} [built]
[0] ./src/index2.js 54 bytes {1} [built]
[1] ./src/others.js 29 bytes {0} {1} [built]

列出命令行所有可用的配置选项
webpack --help
webpack -h

使用配置文件进行构建
指定其它的配置文件。配置文件默认为webpack.config.js,如果想使用其它配置文件,可以加入这个参数。
webpack --config example.config.js

以JSON格式输出webpack的运行结果
webpack --json
webpack --json > stats.json
在其他每个情况下,webpack会打印一组统计信息,用于显示bundle、chunk和用时等详细信息。使用此选项输出可以是JSON对象。此输出文件(response)可被webpack的分析工具,或chrisbateman的webpack可视化工具,或th0r的webpack bundle分析工具接收后进行分析。分析工具将接收JSON并以图形形式提供构建的所有细节。

【 环境选项 】
当webpack配置对象导出为一个函数时可以向起传入一个"环境对象(environment)"。

webpack --env.production    # 设置 env.production == true
webpack --env.platform=web  # 设置 env.platform == "web"

--env 参数具有多种语法 accepts various syntaxes:
Invocation  Resulting environment
webpack --env prod                     "prod"
webpack --env.prod                     { prod: true }
webpack --env.prod=1                   { prod: 1 }
webpack --env.prod=foo                 { prod: "foo" }
webpack --env.prod --env.min           { prod: true, min: true }
webpack --env.prod --env min           [{ prod: true }, "min"]
webpack --env.prod=foo --env.prod=bar  {prod: [ "foo", "bar" ]}

【 配置选项 】
--config desc: 配置文件的路径 type: string default: webpack.config.js 或 webpackfile.js
--config-register, -r desc: 在webpack配置文件加载前先预加载一个或多个模块 type: array
--config-name desc: 要使用的配置名称 type: string
--env desc: 当配置文件是一个函数时会将环境变量传给这个函数
--mode desc: 用到的模式,"development" 或 "production"  default: 中的一个 type: string

【 输出配置 】
--output-chunk-filename
type: string default: 含有[id]的文件名,而不是[name]或[id]作为前缀
输出的附带chunk的文件名

--output-filename
type: string default: [name].js
打包文件的文件名

--output-jsonp-function
type: string default: webpackJsonp
加载 chunk 时使用的 JSONP 函数名

--output-library
type: string default: --output-library-target
以库的形式导出入口文件

type: string default: var
以库的形式导出入口文件时,输出的类型

--output-path
type: string default: 当前目录
输出的路径(在公共路径的基础上)

--output-pathinfo
type: boolean default: false
加入一些依赖信息的注解

--output-public-path
type: string default: /
The 输出文件时使用的公共路径

--output-source-map-filename
type: string default: [name].map or [outputFilename].map
生成的 SourceMap 的文件名

webpack index=./src/index.js index2=./src/index2.js --output-path='./dist' --output-filename='[name][hash].bundle.js'
| Asset                                | Size    | Chunks      | Chunk Names   |
|--------------------------------------|---------|-------------|---------------|
| index2740fdca26e9348bedbec.bundle.js |  2.6 kB | 0 [emitted] | index2        |
| index740fdca26e9348bedbec.bundle.js  | 2.59 kB | 1 [emitted] | index         |
    [0] ./src/others.js 29 bytes {0} {1} [built]
    [1] ./src/index.js 51 bytes {1} [built]
    [2] ./src/index2.js 54 bytes {0} [built]

webpack.js index=./src/index.js index2=./src/index2.js --output-path='./dist' --output-filename='[name][hash].bundle.js' --devtool source-map --output-source-map-filename='[name]123.map'
| Asset                                | Size    | Chunks      | Chunk Names   |
|--------------------------------------|---------|-------------|---------------|
| index2740fdca26e9348bedbec.bundle.js | 2.76 kB | 0 [emitted] | index2        |
|  index740fdca26e9348bedbec.bundle.js | 2.74 kB | 1 [emitted] | index         |
|                        index2123.map | 2.95 kB | 0 [emitted] | index2        |
|                         index123.map | 2.95 kB | 1 [emitted] | index         |
    [0] ./src/others.js 29 bytes {0} {1} [built]
    [1] ./src/index.js 51 bytes {1} [built]
    [2] ./src/index2.js 54 bytes {0} [built]

【 Debug配置 】
--debug
type: boolean default: false
把loader设置为debug模式

--devtool
type: string default: -
为打包好的资源定义 [source map的类型]

--progress
type: boolean default: false
打印出编译进度的百分比值

--display-error-details
type: boolean default: false
展示错误细节

【 模块配置 】
这些配置可以用于绑定 Webpack 允许的模块。

--module-bind
为loader绑定一个扩展
--module-bind js=babel-loader

【 Watch 配置 】
这些配置可以用于观察依赖文件的变化,一旦有变化则可以重新执行构建流程。

--watch, -w
观察文件系统的变化

--watch-aggregate-timeout
指定一个毫秒数,在这个时间内,文件若发送了多次变化,会被合并

--watch-poll
轮询观察文件变化的时间间隔(同时会打开轮询机制)

--watch-stdin, --stdin
当 stdin 关闭时,退出进程

【 性能优化配置 】
在生产环境的构建时,这些配置可以用于调整的一些性能相关的配置。

--optimize-max-chunks
限制 chunk 的数量,plugin: LimitChunkCountPlugin

--optimize-min-chunk-size
限制 chunk 的最小体积,plugin: MinChunkSizePlugin

--optimize-minimize
压缩混淆javascript,并且把loader设置为minimizing,plugin: UglifyJsPlugin & LoaderOptionsPlugin

【 Resolve配置 】
这些配置可以用于设置webpack resolver时使用的别名(alias)和扩展名(extension)。

--resolve-alias
指定模块的别名
--resolve-alias jquery-plugin=jquery.plugin

--resolve-extensions
指定需要被处理的文件的扩展名
--resolve-extensions .es6 .js .ts

--resolve-loader-alias
Minimize javascript and switches loaders to minimizing

【 统计数据配置 】
以下选项用于配置Webpack在控制台输出的统计数据,以及这些数据的样式。

--color, --colors  type: boolean
E开启/关闭控制台的颜色 [默认值：(supports-color)]

--display  type: webpack 3.0.0 开始
选择显示预设(verbose - 繁琐, detailed - 细节, normal - 正常, minimal - 最小, errors-only - 仅错误, none - 无; 从 )
string
--display-cached  type: boolean
在输出中显示缓存的模块

--display-cached-assets  type: boolean
在输出中显示缓存的 assets

--display-chunks  type: boolean
在输出中显示 chunks

--display-depth  type: boolean
显示从入口起点到每个模块的距离

--display-entrypoints  type: boolean
在输出中显示入口文件

--display-error-details  type: boolean
显示详细的错误信息

--display-exclude  type: boolean
在输出中显示被排除的文件

--display-max-modules  type: number
设置输出中可见模块的最大数量

--display-modules  type: boolean
在输出中显示所有模块,包括被排除的模块

--display-optimization-bailout  type: boolean
作用域提升回退触发器(Scope hoisting fallback trigger)(从 webpack 3.0.0 开始)

--display-origins  type: boolean
在输出中显示最初的 chunk

--display-provided-exports  type: boolean
显示有关从模块导出的信息

--display-reasons  type: boolean
显示模块包含在输出中的原因

--display-used-exports  type: boolean
显示模块中被使用的接口(Tree Shaking)

--hide-modules  type: boolean
隐藏关于模块的信息

--sort-assets-by  type: string
对 assets 列表以某种属性排序

--sort-chunks-by  type: string
对 chunks 列表以某种属性排序

--sort-modules-by  type: string
对模块列表以某种属性排序

--verbose  type: boolean
显示更多信息

【 高级配置 】
--bail
一旦发生错误,立即终止

--cache
开启缓存 [watch 时会默认打开]
--cache=false

--define
定义 bundle 中的任意自由变量,查看 shimming
--define process.env.NODE_ENV='development'

--hot
开启模块热替换
--hot=true

--labeled-modules
开启模块标签 [使用 LabeledModulesPlugin]

--plugin
加载某个插件

--prefetch
预加载某个文件
--prefetch=./files.js

--provide
在所有模块中将这些模块提供为自由变量,查看 shimming
--provide jQuery=jquery

--records-input-path
记录文件的路径(读取)

--records-output-path
记录文件的路径(写入)

--records-path
记录文件的路径

--target
目标的执行环境
--target='node'

【 简写 】
-d： --debug --devtool cheap-module-eval-source-map --output-pathinfo
-p： --optimize-minimize --define process.env.NODE_ENV="production", see building for production

【 Profiling 】
--profile 选项捕获编译时每个步骤的时间信息,并且将这些信息包含在输出中。

webpack --profile

⋮
[0] ./src/index.js 90 bytes {0} [built]
    factory:22ms building:16ms = 38ms

</pre>
</div>

<div id="webpack_config">
<h3>配置(configuration)</h3><pre>
从webpack v4开始可以不用引入一个配置文件,然而webpack仍然还是高度可配置的

Webpack零配置体验
可以不用配置entry和output,默认的entry:'/src',默认的output:'./dist',但是零配置的情况下'./src'的入口文件的文件名必须是index.js,否则会报错

使用webpack命令把origin.js文件编译打包生成newfile.js,html页面加载newfile.js即可
origin.js可以使用require('./otherorgin.js')来加载module.exports = "It works";导出的其他js文件
webpack根据模块的依赖关系进行静态分析,这些文件/模块会被包含到newfile.js文件中。Webpack会给每个模块分配一个唯一的id并通过这个id索引和访问模块。 在页面启动时会先执行origin.js中的代码,其它模块会在运行require的时候再执行

> webpack origin.js newfile.js
Hash: 66f592ae2a17bafd08d1
Version: webpack 3.8.1
Time: 83ms
 Asset     Size  Chunks             Chunk Names
newfile.js  2.62 kB       0  [emitted]  main
   [0] ./origin.js 43 bytes {0} [built]
   [1] ./otherorgin.js 28 bytes {0} [built]

【 webpack命令参数 】
通过参数让编译的输出内容带有进度和颜色,显示打包的模块
> webpack --progress --colors --display-modules --display-reasons

如果不想每次修改模块后都重新编译以启动监听模式,开启监听模式后没有变化的模块会在编译后缓存到内存中,而不会每次都被重新编译,所以监听模式的整体速度是很快的
> webpack --progress --colors --watch

package.json
"scripts.webpack": "webpack --progress --colors --display-modules --display-reasons --watch"
npm run webpack

【 webapck.config.js 】
在webpack4中可以无须任何配置使用,然而大多数项目会需要很复杂的设置,这就是为什么webpack仍然要支持配置文件,将一些编译选项放在配置文件中以便于统一管理比在终端(terminal)中手动输入大量命令要高效的多,灵活的多
创建webpack.config.js,执行webpack命令会默认载入当前项目的根目录的webpack.config.js文件,然后只需要执行webpack命令即可生成newfile.js文件

考虑到用CLI这种方式来运行本地的webpack不是特别方便,可以设置一个快捷方式,在 package.json添加一个npm脚本(npm script)
"scripts": {
  "test": "echo \"Error: no test specified\" && exit 1",
  "build": "webpack"
},
现在可以使用npm run build命令来替代npx命令,使用npm的scripts可以像使用npx那样通过模块名引用本地安装的npm包,这是大多数基于npm的项目遵循的标准,因为它允许所有贡献者使用同一组通用脚本,如果必要每个flag都带有--config标志

通过向npm run build命令和参数之间添加两个中横线可以将自定义参数传递给webpack,例如npm run build -- --colors

webpack.config.js语法检查：配置文件是js文件,所以可以通过node webpack.config.js来查看配置文件的语法错误

</pre><pre class="js">
module.exports = {
  entry: './origin.js',
  output: {
    path: __dirname,
    filename: 'newfile.js'
  },
  module: {
    loaders: [{
        test: /\.css/,
        loader: 'style-loader!css-loader'
      },
      {
        test: /\.styl$/,
        use: [
            'style-loader',
            'css-loader',
            {
              loader: 'postcss-loader',
              options: {
                sourceMap: true
              }
            },
            'stylus-loader'
        ]
      }
    ]
  }
}

</pre>webpack.config.js<pre class="js">
const path = require('path');
const webpack = require('webpack');
const ExtractTextPlugin = require('extract-text-webpack-plugin');
const HtmlWebpackPlugin = require('html-webpack-plugin');
const CopyWebpackPlugin = require('copy-webpack-plugin');

module.exports = {
  entry: {
    main: './index.js',
    vendor: ['react', 'react-dom']
  },
  output: {
    filename: 'static/js/[name].js',
    path: path.resolve(__dirname, 'dist'),
    publicPath: '/',
  },
  context: path.resolve(__dirname, 'src'),
  module: {
    rules: [{
        test: /\.js$/,
        use: ['babel-loader'],
        exclude: /node_modules/
      },
      {
        test: /\.css$/,
        use: ExtractTextPlugin.extract(['css-loader', 'postcss-loader'])
      },
      {
        test: /\.(png|jpg|gif|svg)$/,
        use: ['file-loader?name=static/images/[name].[ext]']
      }
    ],
  },
  devtool: 'source-map',
  plugins: [
    new webpack.optimize.CommonsChunkPlugin({
      names: ['vendor']
    }),
    new ExtractTextPlugin('static/css/[name].css'),
    new HtmlWebpackPlugin({
      template: path.resolve(__dirname, 'public/index.html'),
      filename: 'index.html'
    }),
    new CopyWebpackPlugin([{
      from: path.resolve(__dirname, 'public/favicon.ico')
    }])
  ],
  performance: {
    hints: false
  }
}
if(process.env.NODE_ENV === 'production') {
  module.exports.plugins =(module.exports.plugins || []).concat([
    new webpack.DefinePlugin({
      'process.env': {
        NODE_ENV: '"production"'
      }
    }),
    new webpack.optimize.UglifyJsPlugin({
      sourceMap: true,
      compress: {
        warnings: false
      }
    })
  ])
}

// postcss.config.js
module.exports = {
  plugins: [
    require("postcss-cssnext")()
  ]
}

</pre><pre>
webpack是需要传入一个配置对象(configuration object),取决于如何使用webpack,可以通过两种方式：终端或Node.js

webpack的配置文件是导出一个对象的JS文件,此对象由webpack根据对象定义的属性进行解析。

因为webpack配置是标准的Node.js CommonJS模块,可以做到以下事情：
通过require()导入其他文件
通过require()使用npm的工具函数
使用JS控制流表达式如三元表达式
对常用值使用常量或变量
编写并执行函数来生成部分配置

应避免以下做法：
在使用webpack命令行接口(CLI)(应该编写自己的命令行接口或使用--env)时访问命令行接口(CLI)参数
导出不确定的值,调用webpack两次应该产生同样的输出文件
编写很长的配置,应该将配置拆分为多个文件

webpack配置可以有很多种的格式和风格,但为了你和你的团队能够易于理解和维护,要始终采取同一种用法、格式和风格。

webpack配置对象(webpack configuration object)具有表现力,又具有可配置性,这是因为配置对象即是代码

webpack接受以多种编程和数据语言编写的配置文件,如TypeScript、CoffeeScript、Babel and JSX

整个配置中使用Node内置的path模块,并在它前面加上__dirname这个全局变量,可以防止不同操作系统之间的文件路径问题,并且可以使相对路径按照预期工作

</pre>webpack.config.js<pre class="js">
const path = require('path');

module.exports = {
  // Chosen mode tells webpack to use its built-in optimizations accordingly.
  mode: "production",    // "production" | "development" | "none"
  mode: "production",    // enable many optimizations for production builds
  mode: "development",   // enabled useful tools for development
  mode: "none",          // no defaults

  // 这里应用程序开始执行,webpack 开始打包
  entry: "./app/entry",  // string | object | array
  entry: ["./app/entry1", "./app/entry2"],
  entry: {
    a: "./app/entry-a",
    b: ["./app/entry-b1", "./app/entry-b2"]
  },

  // webpack 如何输出结果的相关选项
  output: {
    // 所有输出文件的目标路径,必须是绝对路径(使用Node.js的path模块)
    path: path.resolve(__dirname, "dist"), // string

    // 「入口分块(entry chunk)」的文件名模板(出口分块)
    filename: "bundle.js",        // string
    filename: "[name].js",        // 用于多个入口点(entry point)(出口点)
    filename: "[chunkhash].js",   // 用于长效缓存

    // 输出解析文件的目录,url 相对于 HTML 页面
    publicPath: "/assets/",       // string
    publicPath: "",
    publicPath: "https://cdn.example.com/",

    // 导出库(exported library)的名称
    library: "MyLibrary",         // string,

    // 导出库(exported library)的类型
    libraryTarget: "umd",             // 通用模块定义
    libraryTarget: "umd2",            // 通用模块定义
    libraryTarget: "commonjs2",       // exported with module.exports
    libraryTarget: "commonjs-module", // 使用module.exports导出
    libraryTarget: "commonjs",        // 作为exports的属性导出
    libraryTarget: "amd",             // 使用AMD定义方法来定义
    libraryTarget: "this",            // 在 this 上设置属性
    libraryTarget: "var",             // 变量定义于根作用域下
    libraryTarget: "assign",          // 盲分配(blind assignment)
    libraryTarget: "window",          // 在window对象上设置属性
    libraryTarget: "global",          // property set to global object
    libraryTarget: "jsonp",           // jsonp wrapper

    /* 高级输出配置(点击显示) */
    // 在生成代码时,引入相关的模块、导出、请求等有帮助的路径信息。
    pathinfo: true,                             // boolean

    // 附加分块(additional chunk)的文件名模板
    chunkFilename: "[id].js",
    chunkFilename: "[chunkhash].js",            // 长效缓存(/guides/caching)

    // 用于加载分块的JSONP函数名
    jsonpFunction: "myWebpackJsonp",            // string

    // source map位置的文件名模板
    sourceMapFilename: "[file].map",            // string
    sourceMapFilename: "sourcemaps/[file].map", // string

    // devtool中模块的文件名模板
    devtoolModuleFilenameTemplate: "webpack:///[resource-path]",                // string

    // devtool中模块的文件名模板(用于冲突)
    devtoolFallbackModuleFilenameTemplate: "webpack:///[resource-path]?[hash]", // string

    // 在UMD库中使用命名的AMD模块
    umdNamedDefine: true,                  // boolean

    // 指定运行时如何发出跨域请求问题
    crossOriginLoading: "use-credentials", // 枚举
    crossOriginLoading: "anonymous",
    crossOriginLoading: false,

    /* 专家级输出配置 */
    // 为这些模块使用1:1映射SourceMaps(快速)
    devtoolLineToLine: {
      test: /\.jsx$/
    },

    // HMR清单的文件名模板
    hotUpdateMainFilename: "[hash].hot-update.json",     // string

    // HMR分块的文件名模板
    hotUpdateChunkFilename: "[id].[hash].hot-update.js", // string

    // 包内前置式模块资源具有更好可读性
    sourcePrefix: "\t",                                  // string
  },

  // 关于模块配置
  module: {
    // 模块规则(配置loader、解析器等选项)
    rules: [
      {
        // 匹配条件,每个选项都接收一个正则表达式或字符串,test和include作用相同都是必须匹配选项,exclude是必不匹配选项,优先于test和include
        // 最佳实践：只在test和文件名匹配中使用正则表达式,在include和exclude中使用绝对路径数组,尽量避免exclude,更倾向于使用include
        test: /\.jsx?$/,
        include: [ path.resolve(__dirname, "app") ],
        exclude: [ path.resolve(__dirname, "app/demo-files") ],

        // issuer(导入源)条件
        issuer: { test, include, exclude },

        // 标识应用这些规则,即使规则覆盖(高级选项)
        enforce: "pre",
        enforce: "post",

        // 使用用的loader,它相对上下文解析,为了更清晰`-loader`后缀在webpack2中不再是可选的
        loader: "babel-loader",

        // loader的可选项
        options: {
          presets: ["es2015"]
        },
      },

      {
        test: /\.html$/,
        test: "\.html$"

        // 应用多个loader和选项
        use: [
          "htmllint-loader",
          {
            loader: "html-loader",
            options: {}
          }
        ]
      },

      { oneOf: [ /* rules */ ] },             // 只使用这些嵌套规则之一
      { rules: [ /* rules */ ] },             // 使用所有这些嵌套规则(合并可用条件)
      { resource: { and: [ /* 条件 */ ] } },  // 仅当所有条件都匹配时才匹配
      { resource: { or: [ /* 条件 */ ] } },   // 任意条件匹配时匹配(默认为数组)
      { resource: [ /* 条件 */ ] },           // 任意条件匹配时匹配(默认为数组)
      { resource: { not: /* 条件 */ } }       // 条件不匹配时匹配
    ],

    /* 高级模块配置 */
    // 不解析这里的模块
    noParse: [
      /special-library\.js$/
    ],

    // specifies default behavior for dynamic(动态) requests
    unknownContextRequest: ".",
    unknownContextRecursive: true,
    unknownContextRegExp: /^\.\/.*$/,
    unknownContextCritical: true,
    exprContextRequest: ".",
    exprContextRegExp: /^\.\/.*$/,
    exprContextRecursive: true,
    exprContextCritical: true,
    wrappedContextRegExp: /.*/,
    wrappedContextRecursive: true,
    wrappedContextCritical: false,
  },

  // 解析模块请求的选项,不适用于对loader解析
  resolve: {
    // 用于查找模块的目录
    modules: [ "node_modules", path.resolve(__dirname, "app") ],

    // 使用的扩展名
    extensions: [".js", ".json", ".jsx", ".css"],
    extensions: ['', '.js', '.vue'],    // require时省略的扩展名,如require('module')不需要module.js

    // 模块别名列表
    alias: {
    	// 使用：import router from '~/router'
			'~': resolve(__dirname, 'src'),

      'vue': 'vue/dist/vue.js',

      components: path.join(__dirname, './src/components'),

      // 起别名："module" -> "new-module" 和 "module/path/file" -> "new-module/path/file"
      "module": "new-module",

      // 起别名："only-module" -> "new-module",但不匹配"only-module/path/file" -> "new-module/path/file"
      "only-module$": "new-module",

      // 起别名："module" -> "./app/third/module.js" 和 "module/file" 会导致错误,模块别名相对于当前上下文导入
      "module": path.resolve(__dirname, "app/third/module.js"),
    },

    /* 可供选择的别名语法 */
    alias: [
      {
        name: "module",      // 旧的请求
        alias: "new-module", // 新的请求
        onlyModule: true     // 如果为true,只有"module"是别名,如果为false,"module/inner/path"也是别名
      }
    ],

    /* 高级解析选项 */
    symlinks: true,                       // 遵循符号链接(symlinks)到新位置
    descriptionFiles: ["package.json"],   // 从package描述中读取的文件
    mainFields: ["main"],                 // 从描述文件中读取的属性,当请求文件夹时
    aliasFields: ["browser"],             // 从描述文件中读取的属性,以对此package的请求起别名
    enforceExtension: false,              // 如果为true,请求必不包括扩展名,如果为false,请求可以包括扩展名
    moduleExtensions: ["-module"],
    enforceModuleExtension: false,        // 类似 extensions/enforceExtension,但是用模块名替换文件
    unsafeCache: true,
    unsafeCache: {},                      // 为解析的请求启用缓存,这是不安全,因为文件夹结构可能会改动,但是性能改善是很大的
    cachePredicate:(path, request) => true,  // predicate function which selects requests for caching

    // 应用于解析器的附加插件
    plugins: [
      // ...
    ]
  },

  resolveLoader: { /* 等同于 resolve */ }         // 独立解析选项的loader
  resolveLoader: {
    root: path.join(__dirname, 'node_modules')
  },

  performance: {
    hints: "warning",                       // 枚举
    hints: "error",                         // 性能提示中抛出错误
    hints: false,                           // 关闭性能提示:WARNING in asset size limit
    maxAssetSize: 200000,                   // 整数类型(以字节为单位)
    maxEntrypointSize: 400000,              // 整数类型(以字节为单位)
    assetFilter: function(assetFilename) {  // 提供资源文件名的断言函数
      return assetFilename.endsWith('.css') || assetFilename.endsWith('.js');
    }
  },

  // 通过在浏览器调试工具(browser devtools)中添加元信息(meta info)增强调试,牺牲了构建速度的`source-map'是最详细的。
  devtool: "source-map",               // enum
  devtool: "inline-source-map",        // 嵌入到源文件中
  devtool: "eval-source-map",          // 将SourceMap嵌入到每个模块中
  devtool: "hidden-source-map",        // SourceMap不在源文件中引用
  devtool: "cheap-source-map",         // 没有模块映射(module mappings)的SourceMap低级变体(cheap-variant)
  devtool: "cheap-module-source-map",  // 有模块映射(module mappings)的SourceMap低级变体
  devtool: "eval",                     // 没有模块映射,而是命名模块,以牺牲细节达到最快。

  // webpack的主目录,entry和module.rules.loader选项相对于此目录解析
  context: __dirname,                  // string(绝对路径)

  // 包(bundle)应该运行的环境,更改块加载行为(chunk loading behavior)和可用模块(available module)
  target: "web",                       // 枚举
  target: "webworker",                 // WebWorker
  target: "node",                      // node.js通过require
  target: "async-node",                // Node.js通过fs and vm
  target: "node-webkit",               // nw.js
  target: "electron-main",             // electron,主进程(main process)
  target: "electron-renderer",         // electron,渲染进程(renderer process)
  target:(compiler) => { /* ... */ },  // 自定义

  // 不要遵循/打包这些模块,而是在运行时从环境中请求他们
  externals: ["react", /^@angular\//],
  externals: "react",                  // string(精确匹配)
  externals: /^[a-z\-]+($|\/)/,        // 正则
  externals: {                         // 对象
    angular: "this angular",           // this["angular"]
    react: {                           // UMD
      commonjs: "react",
      commonjs2: "react",
      amd: "react",
      root: "React"
    }
  },
  externals:(request) => { /* ... */ return "commonjs " + request }

  // 精确控制要显示的bundle信息
  stats: "errors-only",
  stats: {
    assets: true,
    colors: true,
    errors: true,
    errorDetails: true,
    hash: true,
    // ...
  },

  devServer: {
    proxy: {                                       // proxy URLs to backend development server
      '/api': 'http://localhost:3000'
    },
    contentBase: path.join(__dirname, 'public'),   // boolean | string | array, static file location
    compress: true,                                // enable gzip compression
    historyApiFallback: true,                      // true for index.html upon 404, object for multiple paths
    hot: true,                                     // hot module replacement. Depends on HotModuleReplacementPlugin
    https: false,                                  // true for self-signed, object for cert authority
    noInfo: true,                                  // only errors & warns on hot reload
    // ...
  },

  // 附加插件列表
  plugins: [
    // ...
  ],

  /* 高级配置 */
  parallelism: 1,                                // number,限制并行处理模块的数量
  profile: true,                                 // boolean,捕获时机信息
  bail: true,                                    // boolean,在第一个错误出错时抛出,而不是无视错误。
  cache: false,                                  // boolean,禁用/启用缓存
  watch: true,                                   // boolean,启用观察
  watchOptions: {
    aggregateTimeout: 1000,                      // in ms,将多个更改聚合到单个重构建(rebuild)
    // 启用轮询观察模式,必须用在不通知更改的文件系统中即nfs shares(Network FileSystem,最大的功能就是可以透過網路,讓不同的機器、不同的作業系統可以彼此分享個別的檔案(share file ))
    poll: true,
    poll: 500,                                   // 间隔单位ms
  },

  // Polyfills and mocks(模拟) to run Node.js-environment code in non-Node environments.
  node: {
    console: false,       // boolean | "mock"
    global: true,         // boolean | "mock"
    process: true,        // boolean
    __filename: "mock",   // boolean | "mock"
    __dirname: "mock",    // boolean | "mock"
    Buffer: true,         // boolean | "mock"
    setImmediate: true    // boolean | "mock" | "empty"
  },

  recordsPath: path.resolve(__dirname, "build/records.json"),
  recordsInputPath: path.resolve(__dirname, "build/records.json"),
  recordsOutputPath: path.resolve(__dirname, "build/records.json"),
  // TODO
}

</pre><pre>
【 统计信息(stats) 】
如果不希望使用quiet或noInfo这样的不显示信息,而是又不想得到全部的信息,只是想要获取某部分bundle的信息,使用stats选项是比较好的折衷方式。

对于webpack-dev-server这个属性要放在devServer对象里。
在使用Node.js API时此选项无效

stats
object string

有一些预设选项可作为快捷方式
stats: "errors-only"  只在发生错误时输出
stats: "minimal"      只在发生错误或有新的编译时输出
stats: "none"         没有输出
stats: "normal"       标准输出
stats: "verbose"      全部输出

</pre>下列这些选项可以准确地控制并展示信息,此对象中的所有选项都是可选的<pre class="js">
stats: {
  all: undefined,          // 未定义选项时stats选项的备用值(fallback value)(优先级高于webpack本地默认值)
  assets: true,            // 添加资源信息
  assetsSort: "field",     // 对资源按指定的字段进行排序,可以使用`!field`来反转排序
  builtAt: true,           // 添加构建日期和构建时间信息
  cached: true,            // 添加缓存(但未构建)模块的信息
  cachedAssets: true,      // 显示缓存的资源(将其设置为`false`则仅显示输出的文件)
  children: true,          // 添加children信息
  chunks: true,            // 添加chunk信息(设置为`false`能允许较少的冗长输出)
  chunkGroups: ?
  chunkModules: true,      // 将构建模块信息添加到chunk信息
  chunkOrigins: true,      // 添加chunk和chunk merge来源的信息
  chunksSort: "field",     // 按指定的字段对chunk进行排序,可以使用`!field`来反转排序,默认是按照`id`排序。
  context: "../src/",      // 用于缩短request的上下文目录
  colors: false,           // `webpack --colors`等同于
  depth: false,            // 显示每个模块到入口起点的距离(distance)
  entrypoints: false,      // 通过对应的bundle显示入口起点
  env: false,              // 添加--env information
  errorDetails: true,      // 添加错误的详细信息(就像解析日志一样)
  errors: true,            // 添加错误信息
  hash: true,              // 添加compilation的哈希值
  maxModules: 15,          // 设置要显示的模块的最大数量
  modules: true,           // 添加构建模块信息
  moduleAssets: ?
  modulesSort: "field",    // 按指定的字段对模块进行排序,可以使用`!field`来反转排序。默认是按照`id`排序。
  moduleTrace: true,       // 显示警告/错误的依赖和来源
  nestedModules: ?
  optimizationBailout: ?
  outputPath: ?
  performance: true,       // 当文件大小超过`performance.maxAssetSize`时显示性能提示
  providedExports: false,  // 显示模块的导出
  publicPath: true,        // 添加public path的信息
  reasons: true,           // 添加模块被引入的原因
  source: true,            // 添加模块的源码
  timings: true,           // 添加时间信息
  usedExports: false,      // 显示哪个模块导出被用到
  version: true,           // 添加webpack版本信息
  warnings: true,          // 添加警告

  // 将资源显示在stats中的情况排除,这可以通过String, RegExp,获取assetName的函数来实现,并返回一个布尔值或如下所述的数组。
  excludeAssets: "filter" | /filter/ |(assetName) => ... return true|false |
    ["filter"] | [/filter/] | [(assetName) => ... return true|false],

  // 将模块显示在stats中的情况排除,这可以通过String, RegExp,获取moduleSource的函数来实现,并返回一个布尔值或如下所述的数组。
  excludeModules: "filter" | /filter/ |(moduleSource) => ... return true|false |
    ["filter"] | [/filter/] | [(moduleSource) => ... return true|false],

  // 和excludeModules相同
  exclude: "filter" | /filter/ |(moduleSource) => ... return true|false |
    ["filter"] | [/filter/] | [(moduleSource) => ... return true|false],

  // 过滤警告显示,可以是String,Regexp,一个获取warning的函数,并返回一个布尔值或上述组合的数组。第一个匹配到的为胜(First match wins.)。
  warningsFilter: "filter" | /filter/ | ["filter", /filter/] |(warning) => ... return true|false
};

</pre><pre>
【 包含统计数据的文件(stats data) 】
通过webpack编译源文件时,用户可生成包含有关于模块的统计数据的JSON文件。这些统计数据不仅可以帮助开发者分析应用的依赖图表,还可以优化编译的速度,这个JSON文件可以通过以下的命令来生成:
webpack --profile --json > compilation-stats.json
这个标识是告诉webpack compilation-stats.json要包含依赖的图表以及各种其他的编译信息。一般来说也会把--profile一起加入,这样每一个包含自身编译数据的模块对象(modules object)都会添加profile

</pre>结构(Structure)<pre class="js">
{
  "version": "1.4.13",            // 用来编译的webpack的版本
  "hash": "11593e3b3ac85436984a", // 编译使用的hash
  "time": 2469,                   // 编译耗时(ms)
  "filteredModules": 0,           // 当`exclude`传入`toJson`函数时统计被无视的模块的数量
  "outputPath": "/",              // webpack输出目录的path路径
  "assetsByChunkName": {
    // 用作映射的chunk的名称
    "main": "web.js?h=11593e3b3ac85436984a",
    "named-chunk": "named-chunk.web.js",
    "other-chunk": [
      "other-chunk.js",
      "other-chunk.css"
    ]
  },
  "assets": [
    // asset对象(asset objects)的数组
  ],
  "chunks": [
    // chunk对象(chunk objects)的数组
  ],
  "modules": [
    // 模块对象(module objects)的数组
  ],
  "errors": [
    // 错误字符串(error string)的数组
  ],
  "warnings": [
    // 警告字符串(warning string)的数组
  ]
}

</pre><pre>
【 多个Target、多种配置类型(configuration types) 】
除了导出单个配置对象,还有一些方式满足其他需求

1、导出为一个函数
需要在开发和生产构建之间消除webpack.config.js的差异,至少有两种选项

作为导出一个配置对象的替代,还有一种可选的导出方式是从webpack配置文件中导出一个函数。该函数在调用时可传入两个参数：
环境对象(environment)作为第一个参数,一个选项map对象(argv)作为第二个参数,这个对象描述了传递给webpack的选项,并且具有output-filename和optimize-minimize等key。

</pre><pre class="js">
module.exports = function(env, argv) {
  return {
    mode: env.production ? 'production' : 'development',
    devtool: env.production ? 'source-maps' : 'eval',
    plugins: [
      new webpack.optimize.UglifyJsPlugin({
        compress: argv['optimize-minimize'] // 只有传入-p或--optimize-minimize
      })
    ]
  };
};

</pre><pre>
2、导出一个Promise
webpack将运行由配置文件导出的函数,并且等待Promise返回,便于需要异步地加载所需的配置变量。

</pre><pre class="js">
module.exports =() => {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve({
        entry: './app.js',
        /* ... */
      })
    }, 5000)
  })
}

</pre><pre>
3、导出多个配置对象
作为导出一个配置对象/配置函数的替代,可能需要导出多个配置对象,从webpack3.1.0开始支持导出多个函数。当运行webpack时所有的配置对象都会构建,例如导出多个配置对象,对于针对多个构建目标(例如AMD和CommonJS)打包一个library非常有用

</pre><pre class="js">
module.exports = [{
  output: {
    filename: './dist-amd.js',
    libraryTarget: 'amd'
  },
  entry: './app.js',
  mode: 'production',
}, {
  output: {
    filename: './dist-commonjs.js',
    libraryTarget: 'commonjs'
  },
  entry: './app.js',
  mode: 'production',
}]

</pre><pre>
【 生产环境构建 】
开发环境(development)和生产环境(production)的构建目标差异很大。在开发环境中需要具有强大的、具有实时重新加载(live reloading)或热模块替换(hot module replacement)能力的source map和localhost server。而在生产环境中目标则转向于关注更小的bundle,更轻量的source map以及更优化的资源以改善加载时间。由于要遵循逻辑分离,通常建议为每个环境编写彼此独立的webpack配置。

虽然以上将生产环境和开发环境做了略微区分,但是还是会遵循不重复原则(Don't repeat yourself - DRY)保留一个"通用"配置。为了将这些配置合并在一起,将使用一个名为webpack-merge的工具。通过"通用"配置不必在环境特定(environment-specific)的配置中重复代码。

安装
npm install --save-dev webpack-merge

</pre><pre class="js">
- |- webpack.config.js
+ |- webpack.common.js
+ |- webpack.dev.js
+ |- webpack.prod.js

// webpack.common.js,设置entry和output配置,并且在其中引入这两个环境公用的全部插件
const path = require('path');
const CleanWebpackPlugin = require('clean-webpack-plugin');
const HtmlWebpackPlugin = require('html-webpack-plugin');

module.exports = {
  entry: {
    app: './src/index.js'
  },
  plugins: [
    new CleanWebpackPlugin(['dist']),
    new HtmlWebpackPlugin({
      title: 'Production'
    })
  ],
  output: {
    filename: '[name].bundle.js',
    path: path.resolve(__dirname, 'dist')
  }
};

// webpack.dev.js,为此环境添加了推荐的devtool(强大的source map)和简单的devServer配置
const merge = require('webpack-merge');
const common = require('./webpack.common.js');

module.exports = merge(common, {
  devtool: 'inline-source-map',
  devServer: {
    contentBase: './dist'
  }
});

// webpack.prod.js,引入了tree shaking中的UglifyJSPlugin即删除未引用代码(dead code)
const merge = require('webpack-merge');
const UglifyJSPlugin = require('uglifyjs-webpack-plugin');
const common = require('./webpack.common.js');

module.exports = merge(common, {
  plugins: [
    new UglifyJSPlugin()
  ]
});

// package.json,将npm start定义为开发环境脚本,并在其中使用webpack-dev-server,将npm run build定义为生产环境脚本
"scripts": {
  "start": "webpack-dev-server --open --config webpack.dev.js",
  "build": "webpack --config webpack.prod.js"
},

</pre>
</div>

<div id="webpack_entry">
<h4>入口(entry)</h4><pre>
context string
基础目录,绝对路径,用于从配置中解析入口起点(entry point)和loader
默认使用当前目录,但是推荐在配置中传递一个值,这使得配置独立于CWD(current working directory - 当前执行路径)
context: path.resolve(__dirname, "app")

入口文件配置：entry参数
入口起点(entry point)指示webpack应该使用哪个模块来作为构建其内部依赖图的开始。
这里应用程序开始执行,webpack开始打包,进入入口起点后webpack会找出有哪些模块和库是入口起点直接和间接依赖的,每个依赖项随即被处理,最后输出到称之为bundles的文件中
可以通过在webpack配置中配置entry属性来指定一个入口起点或多个入口起点,默认./src

entry可以是字符串(单入口),可以是数组(多入口),但为了后续发展务必使用object,因为object中的key在webpack里相当于此入口的name,既可以后续用来拼生成文件的路径,也可以用来作为此入口的唯一标识。

简单规则：每个HTML页面都有一个入口起点,单页应用(SPA)：一个入口起点,多页应用(MPA)：多个入口起点。

【 在webpack配置中有多种方式定义entry属性 】
如果传入一个字符串或字符串数组,chunk会被命名为main。如果传入一个对象则每个键(key)会是chunk的名称,该值描述了chunk的入口起点

</pre><pre class="js">
entry: "./app/entry",
entry: ["./app/entry1", "./app/entry2"],
entry: {
  a: "./app/entry-a",
  b: ["./app/entry-b1", "./app/entry-b2"]
},

</pre>1、单个入口语法：传递一个字符串<pre class="js">
const config = {
  entry: './path/to/my/entry/file.js'
};

// entry属性的单个入口语法是下面的简写：
const config = {
  entry: {
    main: './path/to/my/entry/file.js'
  }
};

module.exports = config;

</pre><pre>
2、传递数组
向entry属性传入文件路径数组将创建多个主入口(multi-main entry),并且将它们的依赖导向(graph)到一个"chunk"时。

</pre>效果为文件合并到一个文件中<pre class="js">
module.exports = {
  entry: ['./src/js/main.js', './src/js/a.js'],
  output: {
    path: __dirname,
    filename: './dist/js/bundle.js'
  }
}

</pre><pre class="js">
// src/index.js
import _ from 'lodash'
console.log(_.join(['Hello', 'webpack'], ' '));

// src/admin.js
import _ from 'lodash'
console.log(_.join(['Hello', 'admin'], ' '));

// webpack.config.js
const path = require('path');
const { CleanWebpackPlugin } = require('clean-webpack-plugin');
const HtmlWebpackPlugin = require('html-webpack-plugin');
const BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin;

module.exports = {
  mode: 'development',
  devtool: 'eval-source-map',
  entry: {
    index: ['./src/index.js', './src/admin.js']
  },
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: '[name].js'
  },
  plugins: [
    new CleanWebpackPlugin(),
    new HtmlWebpackPlugin(),
    new BundleAnalyzerPlugin(),
  ],
};

/*输出
>npx webpack
index.html  181 bytes          [emitted]
  index.js   1.39 MiB   index  [emitted]  index
Entrypoint index = index.js
[0] multi ./src/index.js ./src/admin.js 40 bytes {index} [built]
[./node_modules/webpack/buildin/global.js](webpack)/buildin/global.js 472 bytes {index} [built]
[./node_modules/webpack/buildin/module.js](webpack)/buildin/module.js 497 bytes {index} [built]
[./src/admin.js] 69 bytes {index} [built]
[./src/index.js] 73 bytes {index} [built]
    + 1 hidden module
*/

entry: {
  index: ['./src/index.js', './src/admin.js'],
  vendors: ['lodash']
}

/*输出
>npx webpack
index.html  238 bytes           [emitted]
  index.js   1.39 MiB    index  [emitted]  index
vendors.js   1.39 MiB  vendors  [emitted]  vendors
Entrypoint index = index.js
Entrypoint vendors = vendors.js
[0] multi ./src/index.js ./src/admin.js 40 bytes {index} [built]
[1] multi lodash 28 bytes {vendors} [built]
[./node_modules/webpack/buildin/global.js](webpack)/buildin/global.js 472 bytes {index} {vendors} [built]
[./node_modules/webpack/buildin/module.js](webpack)/buildin/module.js 497 bytes {index} {vendors} [built]
[./src/admin.js] 69 bytes {index} [built]
[./src/index.js] 73 bytes {index} [built]
    + 1 hidden module
*/

module.exports = {
  mode: 'development',
  devtool: 'eval-source-map',
  entry: {
    index: ['./src/index.js', './src/admin.js'],
    vendors: ['lodash']
  },
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: '[name].js'
  },
  plugins: [
    new CleanWebpackPlugin(),
    new HtmlWebpackPlugin(),
    new BundleAnalyzerPlugin(),
  ],
  optimization: {
    splitChunks: {
      cacheGroups: {
        commons: {
          name: 'commons',
          chunks: 'initial',
          minChunks: 2
        }
      }
    }
  }
};

/*输出
>npx webpack
commons.js   1.38 MiB  commons  [emitted]  commons
index.html  295 bytes           [emitted]
  index.js   8.78 KiB    index  [emitted]  index
vendors.js   6.43 KiB  vendors  [emitted]  vendors
Entrypoint index = commons.js index.js
Entrypoint vendors = commons.js vendors.js
*/

</pre><pre>
3、对象语法
entry: {[entryChunkName: string]: string|Array< string>}

对象语法会比较繁琐,然而这是应用程序中定义入口的最可扩展的方式。
可扩展的webpack配置是指可重用并且可以与其他配置组合使用。这是一种流行的技术,用于将关注点(concern)从环境(environment)、构建目标(build target)、运行时(runtime)中分离,然后使用专门的工具如webpack-merge将它们合并。

</pre><pre class="js">
const config = {
  entry: {
    home: "./home.js",
    about: "./about.js",
    contact: "./contact.js"
  }
}

</pre>分离应用程序(app)和第三方库(vendor)入口<pre class="js">
const config = {
  entry: {
    app: './src/app.js',
    vendors: './src/vendors.js'
  }
};

/*
告诉webpack从app.js和vendors.js开始创建依赖图(dependency graph)。这些依赖图是彼此完全分离、互相独立的,每个bundle中都有一个webpack引导(bootstrap)。这种方式比较常见于只有一个入口起点(不包括vendor)的单页应用程序(single page application)中。

为什么？此设置允许使用CommonsChunkPlugin从应用程序bundle中提取vendor引用(vendor reference)到vendor bundle,并把引用vendor的部分替换为__webpack_require__()调用。如果应用程序bundle中没有vendor代码,那么可以在webpack中实现被称为长效缓存的通用模式。
*/

</pre>多页面应用程序<pre class="js">
const config = {
  entry: {
    pageOne: './src/pageOne/index.js',
    pageTwo: './src/pageTwo/index.js',
    pageThree: './src/pageThree/index.js'
  }
};

/*
告诉webpack需要3个独立分离的依赖图
在多页应用中每当页面跳转时服务器将为你获取一个新的HTML文档,页面重新加载新文档,并且资源被重新下载,这提供特殊的机会去做很多事
使用CommonsChunkPlugin为每个页面间的应用程序共享代码创建bundle。由于入口起点增多,多页应用能够复用入口起点之间的大量代码/模块,从而可以极大地从这些技术中受益。
根据经验：每个 HTML 文档只使用一个入口起点。
*/

</pre><pre>
【 动态入口 】
entry:() => './demo'
entry:() => new Promise((resolve) => resolve(['./demo', './demo2']))
当结合output.library选项时：如果传入数组则只导出最后一项。

【 路径上的差异 】
entry: {
  main: __dirname + '/src/index.js'
}
这样写在Mac下完全没有问题,但在Windows下会报错：
ERROR in Entry module not found: Error: Can't resolve 'd:\demo\config/src/index.js' in 'd:\demo'
这是因为两个平台的路径是存在差异的。Mac是/,而Windows是\。

解决办法：
const path = require('path');
entry: {
  main: path.resolve(__dirname, '/src/index.js')
}

</pre>
</div>

<div id="webpack_output">
<h4>出口、输出(output) 输出文件：output参数</h4><pre>
配置output选项可控制webpack如何向硬盘写入编译文件,output参数告诉webpack以什么方式来生成/输出文件,output属性告诉webpack在哪里输出它所创建的bundles、asset和其他你所打包或使用webpack载入的任何内容以及如何命名这些文件,默认值为./dist。
基本上整个应用程序结构都会被编译到指定的输出路径的文件夹中,可以通过在配置中指定一个output字段来配置这些处理过程

与entry不同,output相当于一套规则,所有的入口都必须使用这一套规则,不能针对某一个特定的入口来制定output规则

配置output属性的最低要求是将它的值设置为一个对象,包括以下两点：
1、filename用于输出文件的文件名
2、目标输出目录path的绝对路径

</pre>webpack如何输出结果的相关选项<pre class="js">
output: {
  // 所有输出文件的目标路径,必须是绝对路径(使用Node.js的path模块)
  path: path.resolve(__dirname, "dist"), // string

  // 「入口分块(entry chunk)」的文件名模板(出口分块？)
  filename: "bundle.js",                 // string
  filename: "[name].js",                 // 用于多个入口点(entry point)(出口点？)
  filename: "[chunkhash].js",            // 用于长效缓存

  // 输出解析文件的目录,url相对于HTML页面
  publicPath: "/assets/",                // string
  publicPath: "",
  publicPath: "https://cdn.example.com/",

  // 导出库(exported library)的名称
  library: "MyLibrary",                  // string

  // 导出库(exported library)的类型
  libraryTarget: "umd",                  // 通用模块定义
  libraryTarget: "umd2",                 // 通用模块定义
  libraryTarget: "commonjs2",            // exported with module.exports
  libraryTarget: "commonjs-module",      // 使用module.exports导出
  libraryTarget: "commonjs",             // 作为exports的属性导出
  libraryTarget: "amd",                  // 使用AMD定义方法来定义
  libraryTarget: "this",                 // 在this上设置属性
  libraryTarget: "var",                  // 变量定义于根作用域下
  libraryTarget: "assign",               // 盲分配(blind assignment)
  libraryTarget: "window",               // 在window对象上设置属性
  libraryTarget: "global",               // property set to global object
  libraryTarget: "jsonp",                // jsonp wrapper

  /* 高级输出配置 */
  // 在生成代码时引入相关的模块、导出、请求等有帮助的路径信息。
  pathinfo: true,                        // boolean

  // 「附加分块(additional chunk)」的文件名模板
  chunkFilename: "[id].js",
  chunkFilename: "[chunkhash].js",       // 长效缓存(/guides/caching)

  // 用于加载分块的JSONP函数名
  jsonpFunction: "myWebpackJsonp",       // string

  // 「source map位置」的文件名模板
  sourceMapFilename: "[file].map",               // string
  sourceMapFilename: "sourcemaps/[file].map",    // string

  // 「devtool中模块」的文件名模板
  devtoolModuleFilenameTemplate: "webpack:///[resource-path]",                  // string

  // 「devtool中模块」的文件名模板(用于冲突)
  devtoolFallbackModuleFilenameTemplate: "webpack:///[resource-path]?[hash]",   // string

  // 在UMD库中使用命名的AMD模块
  umdNamedDefine: true,                     // boolean

  // 指定运行时如何发出跨域请求问题
  crossOriginLoading: "use-credentials",    // 枚举
  crossOriginLoading: "anonymous",
  crossOriginLoading: false,

  /* 专家级输出配置 */
  // 为这些模块使用1:1映射SourceMaps(快速)
  devtoolLineToLine: {
    test: /\.jsx$/
  },

  // 「HMR清单」的文件名模板
  hotUpdateMainFilename: "[hash].hot-update.json",     // string

  // 「HMR分块」的文件名模板
  hotUpdateChunkFilename: "[id].[hash].hot-update.js", // string

  // 包内前置式模块资源具有更好可读性
  sourcePrefix: "\t",                                  // string
},

</pre>通过output的filename和path属性告诉webpack bundle的名称及想要bundle生成(emit)到哪里：webpack.config.js<pre class="js">
const path = require('path');
module.exports = {
  entry: './path/to/my/entry/file.js',
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: 'my-first-webpack.bundle.js'
  }
};

</pre><pre>
多个入口起点
如果配置创建了多个单独的 "chunk"(例如使用多个入口起点或使用像CommonsChunkPlugin这样的插件),则应该使用占位符(substitutions)来确保每个文件具有唯一的名称。

</pre>即使可以存在多个入口起点,但只指定一个输出配置<pre class="js">
{
  entry: {
    app: './src/app.js',
    search: './src/search.js'
  },
  output: {                     // 写入到硬盘：./dist/app.js, ./dist/search.js
    filename: '[name].js',
    path: __dirname + '/dist'
  }
}

</pre>使用CDN和资源hash的复杂示例<pre class="js">
output: {
  path: "/home/proj/cdn/assets/[hash]",
  publicPath: "http://cdn.example.com/assets/[hash]/"
}

</pre><pre>
在编译时不知道最终输出文件的publicPath的情况下publicPath可以留空,并且在入口起点文件运行时动态设置。如果在编译时不知道publicPath,可以先忽略它,并且在入口起点设置 __webpack_public_path__

__webpack_public_path__ = myRuntimePublicPath
// 剩余的应用程序入口

【 output.path 】
string
path参数表示生成文件的根目录,需要传入一个绝对路径,path参数和后面的filename参数共同组成输出文件的完整路径
path: path.resolve(__dirname, 'dist/assets')

【 output.publicPath 】
string/function,默认值是一个空字符串,表示打包生成的index.html文件里面引用资源的前缀
对于按需加载(on-demand-load)或加载外部资源(external resources)如图片、文件等来说,output.publicPath是很重要的选项,如果指定了一个错误的值则在加载这些资源时会收到404错误。

通常dev环境时不用配置publicPath,此时静态资源的引用路径相对于HTML页面,而生产环境时把publicPath的值设为CDN的目录路径就可以了

publicPath参数表示一个URL路径(指向生成文件的根目录),用于生成css/js/图片/字体文件等资源的路径,以确保网页能正确地加载到这些资源。
publicPath选项是指定HTML文件中资源文件(字体、图片、JS文件等)的文件名的公共URL部分的。在实际情况中首先会通过output.filename或有些loader如file-loader的name属性设置文件名的原始部分,webpack将文件名的原始部分和公共部分结合之后HTML文件就能获取到资源文件了
该选项的值是以runtime(运行时)或loader(载入时)所创建的每个URL为前缀。因此在多数情况下此选项的值都会以/结束。

path：指定编译目录而已(/dist/),不能用于html中的js引用。
publicPath：虚拟目录,自动指向path编译目录(/assets/ => /dist/),html中引用js文件时必须引用此虚拟路径,但实际上引用的是内存中的文件,既不是/build/js/也不是/assets/

1.在webpack.config.js文件中,output配置只在production环境下起效,devServer只在development环境下有效。
2.启动devServer时文件也会被编译,devServer运行下所编译的文件皆存在于内存中,不会改变本地文件。devServer.publicPath其实就是指定外部访问编译文件的路径,在服务运行中如果内存中找不到想要的文件时devServer会根据文件的路径尝试去本地磁盘上找publicPath设置的目录下的资源,即可以在设置publicPath的同时在dist目录下创建publicPath值对应的目录并将资源放置在其中,但在开发模式且设置CleanWebpackPlugin插件时会先清除dist目录下所有文件,如果这样还找不到才会404
3.在项目中用到了html-webpack-plugin时要保证output和devServer的publicPath路径一致,因为html-webpack-plugin在嵌入静态资源的时候使用的是output的publicPath,会导致在devServer运行的时候加载资源报错,除非output.publicPath使用的是相对路径
4.默认资源文件的url直接在根目录,比如http://127.0.0.1:8080/index.js,这样做缓存控制和CDN不是很方便,因此可通过设置ouput.publicPath和devServer.publicPath给资源文件的url加一个前缀,比如http://127.0.0.1:8080/assets/index.js

output.publicPath表示打包生成的index.html文件里面引用资源的前缀,publicPath被webpack的插件(url-loader、html-webpack-plugin)用于在production环境下更新引用的静态资源的url,当执行打包过后静态资源路径就会被加上publicPath的路径
devServer.publicPath表示打包生成的静态文件所在的位置,若devServer.publicPath没有设置则会认为是output里面设置的publicPath的值

两个publicPath可看作devServer对生成目录dist设置的虚拟目录,devServer先从devServer.publicPath中取值,如果它没有设置就取output.publicPath的值作为虚拟目录,如果它也没有设置就取默认值 “/”
当output.publicPath和devServer.publicPath同时设置不同的值时虚拟目录优先取devServer中的publicPath,index.html中的js路径仍然取的output.publicPath,但是由于两者值不一样,所以server找不到/asset/的虚拟目录

output.publicPath不仅可以影响虚拟目录的取值,也影响利用html-webpack-plugin插件生成的index.html中引用的js、css、img等资源的引用路径,会自动在资源路径前面追加设置的output.publicPath

</pre><pre class="js">
output: {
  filename: 'index.js',
  path: resolve(__dirname, 'dist'),
  publicPath: "/assets/"             // http://localhost:8080/assets/访问dist目录
},

// index.js
import img from './favicon.png'
var myImage = new Image();
myImage.src = img;
document.body.appendChild(myImage);

webpack打包后自动生成的index.html引用index.js
< img src="/assets/1604f7ad265ab7c66657b250a5cd5965.png">
< script type="text/javascript" src="/assets/index.js">< /script>

</pre><pre>
publicPath参数跟path参数的区别：path参数针对本地文件系统的,而publicPath则针对浏览器;因此publicPath既可以是一个相对路径如'../../../../build/',也可以是一个绝对路径如http://www.xxxxx.com/
相对URL(relative URL)会被相对于HTML页面或base标签解析。相对于服务的URL(Server-relative URL),相对于协议的URL(protocol-relative URL)或绝对URL(absolute URL)也可是可能用到的,或者有时必须用到,例如当将资源托管到CDN时。
一般来说推荐相对路径的写法,这样的话整体迁移起来非常方便。当html文件跟其它资源放在不同的域名下的时候就应该用绝对路径了,这种情况非常多见于后端渲染模板的场景。

path: path.resolve(__dirname, "public/assets"),
publicPath: "https://cdn.example.com/assets/"

对于这个配置：
publicPath: "/assets/",
chunkFilename: "[id].chunk.js"
对于一个chunk请求,看起来像这样/assets/4.chunk.js。
对于一个输出HTML的loader可能会像这样输出：< link href="/assets/spinner.gif" />
在加载CSS的一个图片时：background-image: url(/assets/spinner.gif);

示例：
publicPath: "https://cdn.example.com/assets/", // CDN(总是 HTTPS 协议)
publicPath: "//cdn.example.com/assets/", // CDN(协议相同)
publicPath: "/assets/", // 相对于服务(server-relative)
publicPath: "assets/", // 相对于 HTML 页面
publicPath: "../assets/", // 相对于 HTML 页面
publicPath: "", // 相对于 HTML 页面(目录相同)

编译时(compile time)无法知道输出文件的publicPath时可以留空,然后在入口文件(entry file)处使用自由变量(free variable)__webpack_public_path__,以便在运行时(runtime)进行动态设置。
__webpack_public_path__ = myRuntimePublicPath
// 应用程序入口的其他部分

webpack-dev-server也会默认从publicPath为基准,使用它来决定在哪个目录下启用服务来访问webpack输出的文件。

【 output.filename 】
string function
filename属性表示的是如何命名生成出来的入口文件,此选项决定了每个输出bundle的名称,这些bundle将写入到output.path选项指定的目录下。

对于单个入口起点,filename会是一个静态名称
filename: "bundle.js"

当通过多个入口起点(entry point)、代码拆分(code splitting)或各种插件(plugin)创建多个bundle,应该使用占位符/替换模板字符串来赋予每个bundle一个唯一的名称

1、[name]指代入口文件的name即entry参数的key,因此可以在name里利用/即可达到控制文件目录结构的效果。
filename: "[name].bundle.js"
filename: "js/[name].bundle.js"
利用filename参数和path参数来设计入口文件的目录结构
filename: '[name]/entry.js',    // [name]表示entry每一项中的key,用以批量指定生成后文件的名称
如示例中key为'index/login'的入口文件生成出来的路径就是build/index/login/entry.js

2、[hash]指代本次编译构建过程的一个hash版本,只要是在同一次编译过程中生成的文件[hash]值就是一样的,在缓存的层面来说相当于一次全量的替换。
filename: "[name].[hash].bundle.js"

3、[chunkhash]指代当前chunk内容的一个hash版本,即在同一次编译中每一个chunk的hash都不一样,而在两次编译中如果某个chunk根本没有发生变化则该chunk的hash也就不会发生变化。这在缓存的层面上来说就是把缓存的粒度精细到具体某个chunk,只要chunk不变则该chunk的浏览器缓存就可以继续使用。
filename: "[chunkhash].bundle.js"

[hash]和[chunkhash]的长度可以使用[hash:16](默认为20)来指定,或通过指定output.hashDigestLength在全局配置长度。
在使用ExtractTextWebpackPlugin时,可以用[contenthash]来获取提取文件的hash,既不是[hash]也不是[chunkhash]

此选项不会影响那些按需加载chunk的输出文件,对于这些文件请使用output.chunkFilename选项来控制输出。
通过loader创建的文件也不受影响,在这种情况下必须尝试loader特定的可用选项。

如果将这个选项设为一个函数,函数将返回一个包含上面表格中替换信息的对象。

【 output.chunkFilename 】
string function
此选项决定了非入口(non-entry) chunk文件的名称,这些文件名需要在runtime根据chunk发送的请求去生成,因此需要在webpack runtime输出bundle值时将chunk id的值对应映射到占位符(如[name]和[chunkhash])。这会增加文件大小,并且在任何chunk的占位符值修改后都会使bundle失效。

chunkFilename参数与filename参数类似,都用来定义生成文件的命名方式的,只不过chunkFilename参数指定的是除入口文件外的chunk的命名,这些chunk通常是由于webpack对代码的优化所形成的,比如因应实际运行的情况来异步加载

默认使用[id].js或从output.filename中推断出的值,[name]会被预先替换为[id]或[id].

【 output.auxiliaryComment 】
string object
在和output.library和output.libraryTarget一起使用时此选项允许用户向导出容器(export wrapper)中插入注释。要为libraryTarget每种类型都插入相同的注释,将auxiliaryComment设置为一个字符串：

</pre><pre class="js">
output: {
  library: "someLibName",
  libraryTarget: "umd",
  filename: "someLibName.js",
  auxiliaryComment: "Test Comment"
}

// 将会生成如下：
(function webpackUniversalModuleDefinition(root, factory) {
  // Test Comment
  if(typeof exports === 'object' && typeof module === 'object') module.exports = factory(require("lodash"));
  // Test Comment
  else if(typeof define === 'function' && define.amd) define(["lodash"], factory);
  // Test Comment
  else if(typeof exports === 'object') exports["someLibName"] = factory(require("lodash"));
  // Test Comment
  else root["someLibName"] = factory(root["_"]);
})(this, function(__WEBPACK_EXTERNAL_MODULE_1__) {
  // ...
});

</pre>对于libraryTarget每种类型的注释进行更细粒度地控制,请传入一个对象<pre class="js">
auxiliaryComment: {
  root: "Root Comment",
  commonjs: "CommonJS Comment",
  commonjs2: "CommonJS2 Comment",
  amd: "AMD Comment"
}

</pre><pre>
【 output.chunkLoadTimeout 】
integer
chunk请求到期之前的毫秒数,默认为120000

【 output.crossOriginLoading 】
boolean string
只用于target是web,使用了通过script标签的JSONP来按需加载chunk。启用cross-origin属性加载chunk,以下是可接收的值:
1、crossOriginLoading: false - 禁用跨域加载(默认)
2、crossOriginLoading: "anonymous" - 不带凭据(credential)启用跨域加载
3、crossOriginLoading: "use-credentials" - 带凭据(credential)启用跨域加载 with credentials

【 output.jsonpScriptType 】
string
允许自定义script的类型,webpack会将script标签注入到DOM中以下载异步chunk。可以使用以下选项：
"text/javascript"(默认)
"module"：与ES6就绪代码一起使用。

【 output.devtoolLineToLine 】
避免使用此选项,因为它们已废弃,并将很快删除。 it is deprecated and will soon be removed.

【 output.devtoolModuleFilenameTemplate 】
string | function(info)
此选项仅在devtool使用了需要模块名称的选项时使用。
自定义每个source map的sources数组中使用的名称,可以通过传递模板字符串(template string)或函数来完成。
例如当使用devtool: 'eval',默认值是：
devtoolModuleFilenameTemplate: "webpack://[namespace]/[resource-path]?[loaders]"

模板字符串(template string)中做以下替换(通过webpack内部的ModuleFilenameHelpers)：
[absolute-resource-path] 绝对路径文件名
[all-loaders] 自动和显式的loader,并且参数取决于第一个loader名称
[hash] 模块标识符的hash
[id] 模块标识符
[loaders] 显式的loader,并且参数取决于第一个loader名称
[resource] 用于解析文件的路径和用于第一个loader的任意查询参数
[resource-path] 不带任何查询参数,用于解析文件的路径
[namespace] 模块命名空间。在构建成为一个library之后通常也是library名称,否则为空

当使用一个函数,同样的选项要通过info参数并使用驼峰式(camel-cased)：
devtoolModuleFilenameTemplate: info => `webpack:///${info.resourcePath}?${info.loaders}`

如果多个模块产生相同的名称,使用output.devtoolFallbackModuleFilenameTemplate来代替这些模块。

【 output.devtoolFallbackModuleFilenameTemplate 】
string | function(info)
当上面的模板字符串或函数产生重复时使用的备用内容

【 output.devtoolNamespace 】
string
此选项确定output.devtoolModuleFilenameTemplate使用的模块名称空间。未指定时的默认值为output.library。在加载多个通过webpack构建的library时用于防止sourcemap中源文件路径冲突。
例如有两个library分别使用命名空间library1和library2,并且都有一个文件./src/index.js,它们会将这些文件暴露为webpack://library1/./src/index.js和webpack://library2/./src/index.js。

【 output.hashDigest 】
在生成hash时使用的编码方式,默认为'hex',支持Node.js hash.digest的所有编码。

【 output.hashDigestLength 】
散列摘要的前缀长度,默认为20。

【 output.hashFunction 】
string|function
散列算法,默认为'md5'。支持Node.JS crypto.createHash的所有功能。从4.0.0-alpha2开始hashFunction可以是一个返回自定义hash的构造函数。出于性能原因可以提供一个不加密的哈希函数(non-crypto hash function)。

hashFunction: require('metrohash').MetroHash64

确保hash函数有可访问的update and digest方法。

【 output.hashSalt 】
一个可选的加盐值,通过Node.JS hash.update来更新哈希。

【 output.hotUpdateChunkFilename 】
string function
自定义热更新chunk的文件名。可选的值的详细信息查看output.filename选项。
占位符只能是[id]和[hash],默认值hotUpdateChunkFilename: "[id].[hash].hot-update.js",这里没有必要修改它。

【 output.hotUpdateFunction 】
function
只在target是web时使用,用于加载热更新(hot update)的JSONP函数,JSONP函数用于异步加载(async load)热更新(hot-update) chunk。
详细请查看output.jsonpFunction。

【 output.hotUpdateMainFilename 】
string function
自定义热更新的主文件名(main filename)。可选的值的详细信息查看output.filename选项
占位符只能是 [hash],默认值hotUpdateMainFilename: "[hash].hot-update.json",这里没有必要修改它。

【 output.jsonpFunction 】
string
只在target是web时使用,用于按需加载(load on-demand) chunk的JSONP函数。
JSONP函数用于异步加载(async load) chunk,或拼接多个初始chunk(CommonsChunkPlugin, AggressiveSplittingPlugin)。
如果在同一网页中使用了多个(来自不同编译过程(compilation)的)webpack runtime,则需要修改此选项。

如果使用了output.library选项,library名称时自动追加的。

【 output.library 】
string
string或object(从webpack 3.1.0开始;用于libraryTarget: "umd")

output.library的值的作用取决于output.libraryTarget选项的值,output.libraryTarget的默认选项是var,所以如果使用以下配置选项：
output: { library: "MyLibrary" }
如果生成的输出文件是在HTML页面中作为一个script标签引入,则变量MyLibrary将与入口文件的返回值绑定。

如果将数组作为entry,那么只会暴露数组中的最后一个模块。如果将对象作为entry,还可以使用数组语法暴露

【 output.libraryExport 】
string or string[](since webpack 3.0.0)
Default: _entry_return_

Configure which module or modules will be exposed via the libraryTarget. The default _entry_return_ value is the namespace or default module returned by your entry file. The examples below demonstrate the effect of this config when using libraryTarget: "var", but any target may be used.

The following configurations are supported:
1、libraryExport: "default" - The default export of your entry point will be assigned to the library target:
// if your entry has a default export of `MyDefaultModule`
var MyDefaultModule = _entry_return_.default;

2、libraryExport: "MyModule" - The specified module will be assigned to the library target:
var MyModule = _entry_return_.MyModule;

3、libraryExport: ["MyModule", "MySubModule"] - The array is interpreted as a path to a module to be assigned to the library target:
var MySubModule = _entry_return_.MyModule.MySubModule;

With the libraryExport configurations specified above, the resulting libraries could be utilized as such:
MyDefaultModule.doSomething();
MyModule.doSomething();
MySubModule.doSomething();

【 output.libraryTarget 】
string,默认值： "var"
配置如何暴露library。可以使用下面的选项中的任意一个。此选项与分配给output.library的值一同使用。

对于下面的所有示例都假定将output.library的值配置为MyLibrary。
下面的示例代码中的_entry_return_是入口起点返回的值。在bundle本身中,它是从入口起点、由webpack生成的函数的输出结果。

【 output.pathinfo 】
boolean
告诉webpack在bundle中引入所包含模块信息的相关注释,默认值是false,并且不应该用于生产环境(production),但是对阅读开发环境(development)中的生成代码(generated code)极其有用。这些注释也会被添加至经过tree shaking后生成的bundle中。
pathinfo: true

【 output.sourceMapFilename 】
string
此选项会向硬盘写入一个输出文件,只在devtool启用了SourceMap选项时才使用。
配置source map的命名方式,默认使用"[file].map"。

可以使用output.filename中的[name], [id], [hash]和[chunkhash]替换符号。除此之外还可以使用以下替换符号。[file]占位符会被替换为原始文件的文件名,建议只使用[file]占位符,因为其他占位符在非chunk文件(non-chunk files)生成的SourceMap时不起作用。
[file] 模块文件名称
[filebase] 模块 basename

【 output.sourcePrefix 】
string,修改输出bundle中每行的前缀。
sourcePrefix: "\t"
默认情况下使用空字符串。使用一些缩进会看起来更美观,但是可能导致多行字符串中的问题,这里没有必要修改它。

【 output.strictModuleExceptionHandling 】
boolean
如果一个模块是在require时抛出异常,告诉webpack从模块实例缓存(require.cache)中删除这个模块。
出于性能原因默认为false,当设置为false时该模块不会从缓存中删除,这将造成仅在第一次require调用时抛出异常,会导致与node.js不兼容

【 output.umdNamedDefine 】
boolean
当使用了libraryTarget: "umd",设置umdNamedDefine: true会对UMD的构建过程中的AMD模块进行命名。否则就使用匿名的define。

</pre>
</div>

<div id="webpack_mode_target">
<h3>模式(mode)和构建目标(target)</h3><pre>
webpack4之前的版本中针对生产环境和开发环境需要做不同的配置,通常指定标量,然后在webpack.config.js配置文件中进行环境判别,比如：
"scripts":{
  "prod":"NODE_ENV=production webpack -p"
}
判别出环境后再在配置文件中根据不同的环境做不同的打包工作,或者是生成两个配置文件,webpack.dev.js和webpack.prod.js,分别对应于两个环境。

webpack4默认不需要配置文件,mode属性用于配置运行环境,可以通过mode选项为webpack指定一些默认的配置。
"scripts":{
  "build":"webpack --mode production",
  "dev":"webpack-dev-server --mode development"
}

webpack4开始提供mode
设置mode参数为development或production可以启用相应模式下的webpack内置的优化
从CLI参数中传递：webpack --mode=production

The 'mode' option has not been set, webpack will fallback to 'production' for this value

Chosen mode tells webpack to use its built-in optimizations(优化) accordingly(相应地)
mode: "production",  // enable many optimizations for production builds
mode: "development", // enabled useful tools for development
mode: "none",        // no defaults,这种模式下会禁用一切优化

"scripts": {
  "dev": "webpack --mode development",
  "build": "webpack --mode production"
}
npm run dev: dist里面的文件的不是压缩过的
npm run build: dist的main.js就是压缩了的

只设置NODE_ENV则不会自动设置mode
webpack运行时会根据mode设置一个全局变量process.env.NODE_ENV,这不是node中的环境变量,而是webpack.DefinePlugin中定义的全局变量,允许根据不同的环境执行不同的代码

development会将process.env.NODE_ENV的值设为development,启用NamedChunksPlugin和NamedModulesPlugin。
在开发环境中使用了所有的注释和提示功能,并且在devtool中设置了sourcemap的类型为eval

production会将process.env.NODE_ENV的值设为production,启用FlagDependencyUsagePlugin、FlagIncludedChunksPlugin、ModuleConcatenationPlugin、NoEmitOnErrorsPlugin、OccurrenceOrderPlugin、SideEffectsFlagPlugin和UglifyJsPlugin
生产环境默认提供所有可能的优化,如代码压缩/作用域提升等,使用了所有内置的optimizations优化配置来得到优化后的bundles结果
在生产环境中不支持文件的监听,在开发环境中的约定配置使得重新build的速度更快
在生产环境中支持Scope Hoisting, Scope Hoisting指将所有的打包后的文件放在一个函数里,所带来的好处有,其一函数声明少了,文件的体积比之前小,其二就是运行代码所创建的函数作用域也少了

每个选项的默认配置如下(common指两个配置项都存在的属性):

common
optimization.removeAvailableModules:true  //parent chunk中解决了的chunk会被删除
optimization.removeEmptyChunks:true       //删除空的chunks
optimization.mergeDuplicateChunks:true    //合并重复的chunk

development
devtool:eval                        //调试
cache:true                          //缓存模块, 避免在未更改时重建它们。
module.unsafeCache:true             //缓存已解决的依赖项, 避免重新解析它们。
output.pathinfo:true                //在bundle中引入「所包含模块信息」的相关注释
optimization.providedExports:true   //在可能的情况下确定每个模块的导出,被用于其他优化或代码生成。
optimization.splitChunks:true       //找到chunk中共享的模块,取出来生成单独的chunk
optimization.runtimeChunk:true      //为webpack运行时代码创建单独的chunk
optimization.noEmitOnErrors:true    //编译错误时不写入到输出
optimization.namedModules:true      //给模块有意义的名称代替ids
optimization.namedChunks:true       //给模chunk有意义的名称代替ids

production
performance:{hints:"error"....}      //性能相关配置
optimization.flagIncludedChunks:true //某些chunk的子chunk已一种方式被确定和标记,这些子chunks在加载更大的块时不必加载
optimization.occurrenceOrder:true    //给经常使用的ids更短的值
optimization.usedExports:true        //确定每个模块下被使用的导出
optimization.sideEffects:true         //识别package.json or rules sideEffects 标志
optimization.concatenateModules:true  //尝试查找模块图中可以安全连接到单个模块中的段。- -
optimization.minimize:true            //使用uglify-js压缩代码

sideEffects
在webapck2开始支持ESModule后,webpack提出了tree-shaking进行无用模块的消除,主要依赖ES Module的静态结构。在webapck4之前,主要通过在.babelrc文件中设置"modules": false来开启无用的模块检测,该方法显然比较粗暴。webapck4灵活扩展了如何对某模块开展无用代码检测,主要通过在package.json文件中设置sideEffects: false来告诉编译器该项目或模块是pure的,可以进行无用模块删除
webpack4友好支持json模块,以ESMoudle的语法引入,还可以对json模块进行tree-shaking处理

</pre>webpack.production.config.js<pre class="js">
// webpack 2/3
module.exports = {
  plugins: [
    new UglifyJsPlugin(/* ... */),
    new webpack.DefinePlugin({ "process.env.NODE_ENV": JSON.stringify("production") }),
    new webpack.optimize.ModuleConcatenationPlugin(),
    new webpack.NoEmitOnErrorsPlugin()
  ]
 }

// webpack 4
module.exports = {
  mode: 'production'
}

</pre>webpack.development.config.js<pre class="js">
// webpack 2/3
module.exports = {
  plugins: [
    new webpack.NamedModulesPlugin(),
    new webpack.DefinePlugin({ "process.env.NODE_ENV": JSON.stringify("development") })
  ]
}

// webpack 4
module.exports = {
  mode: 'development'
}

</pre>

<h4>构建目标(targets)</h4><pre>
因为服务器和浏览器代码都可以用js编写,所以webpack提供了多种构建目标(target),可以在webpack配置中设置

target
string | function(compiler)

</pre><pre class="js">
module.exports = {
  target: 'node'
};

</pre><pre>
每个target都有各种部署(deployment)/环境(environment)特定的附加项,以支持满足其需求

async-node:编译为类Node.js环境可用,使用fs和vm异步加载分块
electron-main:编译为Electron主进程。
electron-renderer:编译为Electron渲染进程
node:编译为类Node.js环境可用,使用Node.js require加载chunk
node-webkit:编译为Webkit可用,并且使用jsonp去加载分块
web:编译为类浏览器环境里可用(默认)
webworker:编译成一个 WebWorker

</pre>
</div>

<div id="webpack_module">
<h4>模块(module)</h4><pre>
module选项决定了如何处理项目中的不同类型的模块

【 module.noParse 】
RegExp | [RegExp] | function
防止webpack解析那些任何与给定正则表达式相匹配的文件。忽略的文件中不应该含有import, require, define的调用或任何其他导入机制。忽略大型的library可以提高构建性能。

noParse: /jquery|lodash/
noParse: content => /jquery|lodash/.test(content)

【 module.rules 】
array
创建模块时匹配请求的规则数组,这些规则能够修改模块的创建方式。这些规则能够对模块(module)应用loader或修改解析器(parser)。

每个规则可以分为三部分: 条件(condition),结果(result)和嵌套规则(nested rule)

条件有两种输入值：
resource：请求文件的绝对路径,它已经根据resolve规则解析。
issuer: 被请求资源(requested the resource)的模块文件的绝对路径,是导入时的位置。
例如从app.js导入'./style.css',resource是/path/to/style.css, issuer是/path/to/app.js
在规则中属性test、include、exclude和resource对resource匹配,并且属性issuer对issuer匹配。
当使用多个条件时所有条件都匹配。

规则结果只在规则条件匹配时使用,规则有两种输入值：
1、应用的loader：应用在resource上的loader数组。
2、Parser选项：用于为模块创建解析器的选项对象。
这些属性会影响loader：loader, options, use,也兼容这些属性：query, loaders。
enforce属性会影响loader种类,不论是普通的、前置的、后置的loader。
parser属性会影响parser选项。

嵌套的Rule
可以使用属性rules和oneOf指定嵌套规则,这些规则用于在规则条件(rule condition)匹配时进行取值

【 Rule.enforce 】
指定loader种类,可能的值有："pre" | "post",没有值表示是普通loader。
还有一个额外的种类"行内loader",loader被应用在import/require行内。
所有loader通过前置、行内、普通、后置排序,并按此顺序使用。

所有普通loader可以通过在请求中加上!前缀来忽略(覆盖)。
所有普通和前置loader可以通过在请求中加上-!前缀来忽略(覆盖)。
所有普通、后置和前置loader可以通过在请求中加上!!前缀来忽略(覆盖)。

不应该使用行内loader和!前缀,因为它们是非标准的、它们可在由loader生成的代码中使用

【 Rule.exclude 】
Rule.exclude是Rule.resource.exclude的简写。如果提供了Rule.exclude选项就不能再提供Rule.resource

【 Rule.include 】
Rule.include是Rule.resource.include的简写。如果提供了Rule.include选项就不能再提供Rule.resource

【 Rule.issuer 】
一个条件,用来与被发布的request对应的模块项匹配。在以下示例中a.js request的发布者(issuer)是index.js文件的路径。
// index.js
import A from './a.js'
这个选项可以用来将loader应用到一个特定模块或一组模块的依赖中。

【 Rule.loader 】
Rule.loader是Rule.use: [ { loader } ] 的简写

【 Rule.oneOf 】
规则数组,当规则匹配时只使用第一个匹配规则

</pre><pre class="js">
{
  test: /.css$/,
  oneOf: [
    {
      resourceQuery: /inline/,     // foo.css?inline
      use: 'url-loader'
    },
    {
      resourceQuery: /external/,   // foo.css?external
      use: 'file-loader'
    }
  ]
}

</pre><pre>
【 Rule.parser 】
解析选项对象。所有应用的解析选项都将合并。
解析器(parser)可以查阅这些选项,并相应地禁用或重新配置。大多数默认插件会如下解释值：
将选项设置为false将禁用解析器。
将选项设置为true或不修改将其保留为undefined可以启用解析器。

然而一些解析器(parser)插件可能不光只接收一个布尔值,例如内部的NodeStuffPlugin差距可以接收一个对象而不是true来为特定的规则添加额外的选项。

</pre>默认的插件解析器选项<pre class="js">
parser: {
  amd: false, // 禁用 AMD
  commonjs: false, // 禁用 CommonJS
  system: false, // 禁用 SystemJS
  harmony: false, // 禁用 ES2015 Harmony import/export
  requireInclude: false, // 禁用 require.include
  requireEnsure: false, // 禁用 require.ensure
  requireContext: false, // 禁用 require.context
  browserify: false, // 禁用特殊处理的 browserify bundle
  requireJs: false, // 禁用 requirejs.*
  node: false, // 禁用 __dirname, __filename, module, require.extensions, require.main 等。
  node: {...} // 在模块级别(module level)上重新配置 node 层(layer)
}

</pre><pre>
【 Rule.resource 】
条件会匹配resource。既可以提供Rule.resource选项,也可以使用快捷选项Rule.test、Rule.exclude和Rule.include

【 Rule.resourceQuery 】
A Condition matched with the resource query. This option is used to test against the query section of a request string(i.e. from the question mark onwards). If you were to import Foo from './foo.css?inline', the following condition would match:
{ test: /.css$/, resourceQuery: /inline/, use: 'url-loader' }

【 Rule.rules 】
规则数组,当规则匹配时使用

【 Rule.test 】
Rule.test是Rule.resource.test的简写。如果提供了一个Rule.test选项就不能再提供 Rule.resource

【 Rule.use 】
应用于模块的UseEntries列表。每个入口(entry)指定使用一个loader。
传递字符串如use: [ "style-loader" ]是loader属性的简写方式如use: [ { loader: "style-loader "} ]

Loaders can be chained by passing multiple loaders, which will be applied from right to left(last to first configured).

</pre><pre class="js">
use: [
  'style-loader',
  {
    loader: 'css-loader',
    options: { importLoaders: 1 }
  },
  {
    loader: 'less-loader',
    options: { noIeCompat: true }
  }
]

</pre><pre>
【 条件 】
条件可以是这些之一：
字符串：匹配输入必须以提供的字符串开始。是的。目录绝对路径或文件绝对路径。
正则表达式：test输入值。
函数：调用输入的函数,必须返回一个真值(truthy value)以匹配。
条件数组：至少一个匹配条件。
对象：匹配所有属性。每个属性都有一个定义行为。

{ test: Condition }：匹配特定条件。一般是提供一个正则表达式或正则表达式的数组,但这不是强制的。
{ include: Condition }：匹配特定条件。一般是提供一个字符串或者字符串数组,但这不是强制的。
{ exclude: Condition }：排除特定条件。一般是提供一个字符串或字符串数组,但这不是强制的。
{ and: [Condition] }：必须匹配数组中的所有条件
{ or: [Condition] }：匹配数组中任何一个条件
{ not: [Condition] }：必须排除这个条件

</pre><pre class="js">
{
  test: /\.css$/,
  include: [
    path.resolve(__dirname, "app/styles"),
    path.resolve(__dirname, "vendor/styles")
  ]
}

</pre><pre>
【 UseEntry 】
object
必须有一个loader属性是字符串。它使用loader解析选项(resolveLoader),相对于配置中的context来解析。
可以有一个options属性为字符串或对象。值可以传递到loader中,将其理解为loader选项。
由于兼容性原因,也可能有query属性,它是options属性的别名。使用options属性替代。

</pre><pre class="js">
{
  loader: "css-loader",
  options: {
    modules: true
  }
}

</pre><pre>
webpack需要生成资源和所有loader的独立模块标识,包括选项。它尝试对选项对象使用JSON.stringify。这在99.9%的情况下是可以的,但是如果将相同的loader应用于相同资源的不同选项,并且选项具有一些带字符的值,则可能不是唯一的。

如果选项对象不被字符化(例如循环JSON),它也会中断。因此可以在选项对象使用ident属性作为唯一标识符。

</pre>
</div>

<div id="webpack_loader">
<h3>loader 管理资源</h3><pre>
在webpack出现之前,前端开发人员会使用grunt和gulp等工具来处理资源,并将它们从/src文件夹移动到/dist目录中,同样方式也被用于js模块,但是webpack工具将动态打包(dynamically bundle)所有依赖项,即创建所谓的依赖图(dependency graph),这样每个模块都可以明确表述它自身的依赖,避免打包未使用的模块

webpack最出色的功能之一就是除了Js还可以通过loader引入任何其他类型的文件,即以上列出的那些Js的优点如显式依赖,同样可以用来构建网站或web应用程序中的所有非Js内容

Webpack本身只能处理Js模块,如果要处理其他非js类型的文件就需要使用loader进行转换,loader可以将所有类型的文件转换为webpack能够处理的有效模块,然后就可以利用webpack的打包能力对它们进行处理,Webpack把所有的文件都当做模块处理,JS代码、CSS和fonts以及图片等等通过合适的loader都可以被处理

loader用于对模块的源代码进行转换,loader可以在import或"加载"模块时预处理文件,因此loader类似于其他构建工具中"任务(task)",并提供了处理前端构建步骤的强大方法。loader可以将文件从不同的语言如TypeScript转换为JavaScript,或将内联图像转换为data URL,loader甚至允许直接在JS模块中import CSS文件

webpack遇到import/reqiure导入任何类型的模块文件如.css文件等外部的脚本或工具时会调用配置的对应loader对引用的文件进行编译,,实现对不同格式的文件的处理,如分析转换scss为css,或把ES6、ES7的JS文件转换为现代浏览器兼容的JS文件,loader将所有类型的文件转换为应用程序的依赖图和最终的bundle可以直接引用的模块,这种语言扩展是有很必要的,因为这可以使开发人员创建出更准确的依赖关系图。

【 loader特性 】
1、loader支持链式传递,能够对资源使用流水线(pipeline)。一组链式的loader将按照相反的顺序执行。loader链中的第一个loader返回值给下一个loader。在最后一个loader返回webpack所预期的JS
2、loader可以是同步的,也可以是异步的。
3、loader运行在Node.js中并且能够执行任何可能的操作。
4、loader接收查询参数,用于对loader传递配置。
5、loader也能够使用options对象进行配置。
6、除了使用package.json常见的main属性,还可以将普通的npm模块导出为loader,做法是在package.json里定义一个loader字段。
7、插件(plugin)可以为loader带来更多特性。
8、loader能够产生额外的任意文件。

loader通过(loader)预处理函数为JS生态系统提供了更多能力,用户现在可以更加灵活地引入细粒度逻辑,例如压缩、打包、语言翻译和其他更多。

【 loader的使用 】
Loaders需要使用cnpm install单独安装并且需要在webpack.config.js中的modules关键字下进行配置,webpack根据正则表达式来确定应该查找哪些文件,并将其提供给指定的loader,webpack将loader要处理的模块和loader本身一起打包进输出文件中,可通过npx webpack --display-mudoles查看打包的模块,在浏览器控制台查看打包的结果

test：一个用以匹配loaders所处理文件拓展名的正则表达式(必须)
use：loader的名称(必须)
include/exclude:手动添加必须处理的文件(文件夹)或屏蔽不需要处理的文件(文件夹)(可选);
query：为loaders提供额外的设置选项(可选)

npm install css-loader style-loader --save

要在应用中添加css文件就需要使用到css-loader和style-loader,二者组合在一起能够把样式表嵌入webpack打包后的JS文件中
css-loader会遍历CSS文件,然后找到url()表达式然后处理他们,css-loader能够使用类似@import和url(...)的方法实现require()的功能
style-loader会把原来的CSS代码插入页面中的一个style标签中,style-loader将所有的计算后的样式加入页面中

css预处理器
less loader
sass loader
stylus loader
postcss-loader autoprefixer

origin.js中加载css文件然后打包
require('!style-loader!css-loader!./style.css');
import './assets/styles/global.styl'

Hash: 14b99031bd917c494497
Version: webpack 3.8.1
Time: 896ms
 Asset     Size  Chunks             Chunk Names
newfile.js  18.8 kB       0  [emitted]  main
   [0] ./origin.js 93 bytes {0} [built]
   [1] ./node_modules/style-loader!./node_modules/css-loader!./style.css 1.01 kB {0} [built]
   [2] ./node_modules/css-loader!./style.css 187 bytes {0} [built]
   [6] ./otherorgin.js 28 bytes {0} [built]
    + 3 hidden modules

也可以根据模块类型(扩展名)来自动绑定需要的loader
require("./style.css");
webpack origin.js newfile.js --module-bind 'css=style-loader!css-loader'

url-loader实际上是对file-loader的封装

比如CSS文件当中有这样的引用:
.demo { background-image: url('a.png'); }
那么对应这样的loader配置就能把a.png抓出来,并且按照文件大小转化为base64或单独作为文件:

module: {
  loaders: [
    {test: /\.(png|jpg)$/, loader: 'url-loader?limit=8192'}
    // inline base64 URLs for <=8k images, direct URLs for the rest
  ]
}

【 使用loader 】
在应用程序中有三种使用loader的方式：
1、配置(推荐)：在webpack.config.js文件中指定loader
2、内联：在每个import语句中显式指定loader
3、CLI：在shell命令中指定它们,webpack --module-bind jade-loader --module-bind 'css=style-loader!css-loader'

【 内联 】
可以在import语句或任何等效于"import"的方式中指定loader,使用!将资源中的loader分开,分开的每个部分都相对于当前目录解析。

import Styles from 'style-loader!css-loader?modules!./styles.css';

通过前置所有规则及使用!可以对应覆盖到配置中的任意loader。

选项可以传递查询参数如?key=value&foo=bar,或一个JSON对象如?{"key":"value","foo":"bar"}

尽可能使用module.rules,因为这样可以减少源码中的代码量,并且可以在出错时更快地调试和定位loader中的问题。

【 配置[Configuration] 】
webpack的配置中loader有两个必须属性：
1、test属性,用于标识出应该被对应的loader进行转换的某个或某些文件。
2、use属性,表示进行转换时应该使用哪个loader。

</pre><pre class="js">
首先安装相应的loader
cnpm install --save-dev style-loader css-loader ts-loader raw-loader file-loader url-loader html-loader vue-loader csv-loader xml-loader postcss-loader autoprefixer

/* webpack.config.js */
const path = require('path');
const config = {
	mode: dev ? 'development' : 'production',
  devtool: dev ? 'cheap-module-eval-source-map' : 'hidden-source-map',
	stats: { children: false },
  entry: './src/index.js',
  output: {
    path: path.resolve(__dirname, 'dist')
    filename: 'index.bundle.js',
  },

  // 配置各种类型文件的加载器,称之为loader,webpack当遇到import ... 时会调用这里配置的loader对引用的文件进行编译
  module: {
    rules: [
    	// 指示webpack编译器(compiler)碰到require()/import语句中被解析为'.txt'的路径时在对它打包之前先使用raw-loader转换
      {
        test: /\.txt$/,
        use: 'raw-loader'
      },

      {
        test: /\.vue$/,
        use: 'vue-loader'
      },

			// 匹配html文件,使用html-loader将html内容存为js字符串,当遇到如import htmlString from './template.html';template.html文件内容会被转成js字符串合并到js文件里
      {
        test: /\.html$/,
        use: 'html-loader'
      },

			/*
      use指定该文件的loader,值可以是字符串或数组。
      这里先使用eslint-loader处理,返回的结果交给babel-loader处理。loader的处理顺序是从最后一个到第一个。
      eslint-loader用来检查代码,如果有错误,编译的时候会报错,babel-loader用来编译js文件。
      */
      {
        test: /\.(js|jsx)$/,      // 使用babel编译ES6/ES7/ES8为ES5代码,使用正则表达式匹配后缀名为.js或.jsx的文件
        exclude: /node_modules/,  // 排除node_modules目录下的文件,npm安装的包不需要编译
        include: [ path.resolve(__dirname, "app/src"), path.resolve(__dirname, "app/test") ],
        use: [
        	{
		        loader: "babel-loader",
		        options: {
		          presets: ['@babel/preset-env']
		        }
		      },
        	'eslint-loader'
        ]
      },

			// 指示webpack对所有.ts文件使用ts-loader
      {
        test: /\.ts$/,
        use: 'ts-loader'
      },

      {
        // 匹配css文件,指示webpack对每个.css文件使用postcss-loader、css-loader、style-loader,先使用postcss-loader、css-loader处理,返回的结果交给style-loader处理
        // 这样可以在依赖于此样式的文件中import './style.css',当该模块运行时含有CSS字符串的style标签将被插入到html文件的head中
        // css-loader将css内容存为js字符串,并且会把background、@font-face等引用的图片、字体文件交给指定的loader打包,类似上面的html-loader,用什么loader同样在loaders对象中定义,等会下面就会看到。
        // 多数情况下也可进行CSS分离,以便在生产环境中节省加载时间。最重要的是现有的loader可以支持任何CSS处理器风格如postcss、sass和less等
        test: /\.css$/,
        use: [
          'style-loader',
          {
            loader: "css-loader",
            options: {
              modules: true
            }
          },
          'postcss-loader'
        ]
      },

			/*
        匹配各种格式的图片和字体文件
        上面html-loader会把html中img标签的图片解析出来,文件名匹配到这里的test的正则表达式,css-loader引用的图片和字体同样会匹配到这里的test条件
        使用url-loader,它接受一个limit参数,单位为字节(byte)
        当文件体积小于limit时url-loader把文件转为Data URI的格式内联到引用的地方
        当文件大于limit时url-loader会调用file-loader,把文件储存到输出目录,并把引用的文件路径改写成输出后的路径
        比如views/foo/index.html中
        < img src="smallpic.png">会被编译成< img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAA...">
        < img src="largepic.png">会被编译成< img src="/f78661bef717cf2cc2c2e5158f196384.png">
      */
      {
        test: /\.(png|jpg|jpeg|gif|eot|ttf|woff|woff2|svg|svgz)(\?.+)?$/,
        use: [
          {
            loader: 'url-loader',
            options: {
              limit: 10000
            }
          }
        ]
      },

			// 使用file-loader可以轻松地将css背景和图标这些图片这些内容混合到CSS中
      // import MyImage from './my-image.png'时该图像将被处理并添加到输出目录output目录,并且MyImage变量将包含该图像在处理后的最终url。当使用css-loader时CSS中的url('./my-image.png')会使用类似的过程去处理。loader会识别这是一个本地文件,并将'./my-image.png'路径替换为output/中图像的最终路径,实际的文件名已更改为类似5c999da72346a995e7e2718865d019c8.png。html-loader以相同的方式处理< img src="./my-image.png" />
      // 下一步是增强加载处理图片功能,压缩和优化图像,查看image-webpack-loader和url-loader,extract-text-webpack-plugin
      {
        test: /\.(png|jpg|gif|svg)$/,
        use: [ 'file-loader' ]
      },

      {
        test: /\.(gif|png|jpg|jpeg|svg)$/,
        use: [{
          loader: 'url-loader',
          options: {
            limit: 1024,
            name: '[name]-webpack.[ext]'
          }
        }]
      },

      /*
      file-loader和url-loader可以接收并加载任何类型的文件包括字体,然后将其输出到构建目录
      @font-face {
        font-family: 'MyFont';
        src: url('./my-font.woff2') format('woff2'), url('./my-font.woff') format('woff');
        font-weight: 600;
        font-style: normal;
      }
      .hello {
        color: red;
        font-family: 'MyFont';
        background: url('./icon.png');
      }
      */
      {
        test: /\.(woff|woff2|eot|ttf|otf)$/,
        use: [ 'file-loader' ]
      },

			// 可加载的资源还有数据如JSON文件、CSV、TSV和XML。内置支持JSON,即import Data from './data.json' 默认将正常运行,要导入CSV、TSV和XML可以使用csv-loader和xml-loader
      {
        test: /\.(csv|tsv)$/,
        use: [ 'csv-loader' ]
      },

      {
        test: /\.xml$/,
        use: [ 'xml-loader' ]
      }
    ]
  }
};

module.exports = config;

// postcss.config.js
module.exports = {
  plugins: [
    require('autoprefixer')
  ]
}

</pre><pre>
全局资源
上述所有内容中最出色之处是以这种方式加载资源可以以更直观的方式将模块和资源组合在一起。无需依赖于含有全部资源的/assets目录,而是将资源与代码组合在一起,例如类似这样的结构会非常有用：

- |- /assets
+ |– /components
+ |  |– /my-component
+ |  |  |– index.jsx
+ |  |  |– index.css
+ |  |  |– icon.svg
+ |  |  |– img.png

这种配置方式会使代码更具备可移植性,因为现有的统一放置的方式会造成所有资源紧密耦合在一起。假如想在另一个项目中使用/my-component,只需将其复制或移动到/components目录下。只要已经安装了任何扩展依赖(external dependencies),并且已经在配置中定义过相同的loader,那么项目应该能够良好运行。

但是假如无法使用新的开发方式,只能被固定于旧有开发方式,或者有一些在多个组件(视图、模板、模块等)之间共享的资源,仍然可以将这些资源存储在公共目录(base directory)中,甚至配合使用alias来使它们更方便import导入

</pre>
</div>

<div id="babel-loader">
<h4>Babel</h4><pre>
js文件处理
Js文件的一般打包需求：
代码编译(TS或ES6代码的编译),使用babel转换ES6+语法
脚本合并
公共模块识别
代码分割
代码压缩混淆

Babel是一个编译JS的平台,使用babel编译ES6/ES7/ES8为ES5代码,它可以编译代码达到以下目的：
让你能使用最新的JS代码(ES6,ES7),而不用管新标准是否被当前使用的浏览器完全支持
让你能使用基于JS进行了拓展的语言,比如React的JSX

虽然webpack本身就能够处理js文件,但无法对ES2015+的语法进行转换,babel-loader的作用正是实现对使用了ES2015+语法的js文件进行处理

Babel其实是几个模块化的包,其核心功能位于称为babel-core的npm包中,webpack可以把其不同的包整合在一起使用,对于每一个需要的功能或拓展都需要安装单独的包,用得最多的是解析Es6的babel-preset-env包和解析JSX的babel-preset-react包

babel-loader是webpack整合Babel的关键,需要配置好babel-loader来加载那些使用了ES6语法的js文件;那些本来就是ES5语法的文件是不需要用babel-loader来加载的,用了也只会浪费编译的时间

babel-core：babel的核心
作用在于提供一系列api,当webpack使用babel-loader处理文件时babel-loader实际上调用了babel-core的api,因此也必须安装babel-core

babel-preset-env
作用是告诉babel使用哪种转码规则进行文件处理。事实上babel有几种规则都可以实现对ES6语法的转码,如babel-preset-es2015、babel-preset-latest、babel-preset-env,不过官方现已建议采用babel-preset-env

babel-preset-react
babel-plugin-transform-runtime和babel-runtime这属于优化项,不用也没啥问题
babel-helper-vue-jsx-merge-props  babel-plugin-syntax-jsx  babel-plugin-transform-vue-jsx

Install
webpack 4.x | babel-loader 8.x | babel 7.x
cnpm install -D babel-loader @babel/core @babel/preset-env

</pre>先使用eslint-loader处理,eslint-loader用来检查代码,如果有错误编译的时候会报错,返回的结果交给babel-loader处理,babel-loader用来编译js文件。loader的处理顺序是从最后一个到第一个<pre class="js">
const path = require('path')
module.exports = {
  entry: {
    main: path.resolve(__dirname, 'src/main.js'),
  },
  output: {
    filename: 'bundle.js',
    path: path.resolve(__dirname, 'build')
  },
  devServer: {                                      // 检测代码变化并自动重新编译并自动刷新浏览器
    contentBase: path.resolve(__dirname, 'build')   // 设置静态资源的根目录
  },
  module: {                                         // 如何处理项目中不同类型的模块
    rules: [{                                       // 用于规定在不同模块被创建时如何处理模块的规则数组
      test: /(\.jsx|\.js)$/,
      use: [
      	{
	        loader: "babel-loader",
	        options: {
	          presets: ['@babel/preset-env']
	        }
	      },
				'eslint-loader'
	    ]
      exclude: path.resolve(__dirname, 'node_modules'),  // 排除node_modules目录下的文件,npm安装的包不需要编译
      include: path.resolve(__dirname, 'src'),
    }]
  }
}

"scripts": {
  "build": "webpack",
  "start": "webpack-dev-server --open"
}

</pre><pre class="js">
module: {
  rules: [{
    test: /\.js$/,
    exclude: /node_modules|vendor|bootstrap/,
    use: {
      loader: 'babel-loader',
      options: {
        presets: ['@babel/preset-env'],
        plugins: ['@babel/plugin-proposal-object-rest-spread']
      }
    }
  }]
}

</pre><pre class="js">
// webpack.config.js
module: {
  rules: [
    {
      test: /\.js$/,
      exclude: /node_modules/,
      use: [
        {
           loader: 'babel-loader'
        }
      ]
    }
  ]
},

// .babelrc
{
  "presets":[
    ["env", { "targets": { "browsers":"last 2 versions" } } ]
  ],
  "plugins": [
    "babel-plugin-transform-runtime"
  ]
}

</pre>modules:false告诉es2015 preset避免把import statements编译成CommonJS,这样Webpack才好做tree shaking<pre class="js">
{
  test: /\.(js|es|es6|jsx)$/,
  use: [
    {
      loader: 'babel-loader',
      options: {
        presets: [
          ['es2015', {modules: false, loose: true}],
          ['react'],
          ['stage-2']
        ],
        plugins: [
          ['transform-runtime']
        ],
        comments: false,
        cacheDirectory: true
      }
    },
    {
      loader: 'eslint-loader',
      options: {
        configFile: eslintConfigPath
      }
    }
  ],
  exclude: excludeReg
},

// 将babel的配置options抽出来放到.bablerc文件中
{
  presets: [
    ["react"],
    [ "es2015", {"modules": false, "loose": true} ],
    ["stage-2"]
  ],
  plugins: [
    ["transform-runtime"]
  ],
  comments: false
}

</pre><pre>
options.cacheDirectory参数默认为false,若设置为一个文件目录路径(表示把cache存到哪),或是保留为空(表示操作系统默认的缓存目录),则相当于开启cache。
这里的cache指的是babel在编译过程中某些可以缓存的步骤,只要开启了cache就可以加快webpack整体编译速度,未开启cache的时候需要15秒半来编译;而开启cache后的第一次编译时间并没有减少,第二次编译则变为14秒了,足足减少了1秒半

plugins参数
npm install babel-plugin-transform-runtime babel-runtime --save
plugins: ['@babel/transform-runtime']
虽然preset已经包括N个plugin了,但总有一些漏网之鱼是要专门加载的。这里只用到了transform-runtime,不用这plugin的话babel会仅在需要的情况下为每一个转换后的文件即chunk都添加一些辅助的方法;而如果用了这个plugin,babel会把这些辅助的方法都集中到一个文件里统一加载统一管理,算是一个可选的减少冗余、增强性能的优化项

配置babel规则
安装了三个包,如果要使babel起作用便需要配置babel规则
第一种方式是通过package.json。
在package.json文件中增加一个"babel"属性,该属性是一个JSON对象,作用是设置项目中的babel转码规则和使用到的babel插件,"babel.presets"属性字段设定转码规则,"babel.plugins"属性设置使用到的插件,其基本格式如下：

</pre><pre class="js">
"babel": {
  "presets": ["env"],  // 告诉npm本项目将使用babel,并且使用bable-preset-env规则进行转码,即实现对ES2015+语法进行转码
  "plugins": []
}

</pre><pre>
第二种方式即通过项目根目录下.babelrc文件
Babel完全可以在webpack.config.js中进行配置,但是考虑到babel具有非常多的配置选项,在单一的webpack.config.js文件中进行配置往往使得这个文件显得太复杂,因此一些开发者支持把babel的配置选项放在一个单独的名为.babelrc的配置文件中,webpack会自动调用.babelrc里的babel配置选项

</pre>.babelrc文件 <pre class="js">
{
  "presets": [ "env" ],
  "plugins": [ "transform-vue-jsx" ]
}

</pre>
</div>

<div id="treeshaking">
<h4>treeshaking</h4><pre>
想要使用lodash中的chunk方法,但是直接导入lodash并打包显然很冗余,因为就用chunk那个方法而已,多了没用。treeshaking就负责帮你只引用chunk,把多余的代码像摇树一样摇掉。

treeshaking是基于ES6的import和export语法

1. treeshaking在development模式下无效,production下效果正常

2. import { chunk } from 'lodash';语法无效,lodash模块不支持ES6写法,需要使用lodash-es模块

</pre>3. 参照官网使用webpack.ProvidePlugin的treeshaking写法无效<pre class="js">
// 官网写法
plugins: [
  new webpack.ProvidePlugin({
		// _: 'lodash'
		join: ['lodash', 'join']
  })
]

// 目前写法
new webpack.ProvidePlugin({
  _join: "lodash-es/join"    //   lodash/join 也可
})

</pre><pre>
4. 还有一种情况也会导致treeshaking无效,当使用babel进行语法转换时babel有可能会将import语法进行了转换,而treeshaking是基于import语法的。需要做的是把babel的配置文件.babelrc中添加如下字段"modules":false,modules字段用于将ES6写法转换为CommonJS、AMD等规范的写法,false就是保留ES6的import写法,不进行转换

</pre><pre class="js">
{
  "presets": [
  	[ "env", { "modules": false } ]
  ]
}

</pre>
</div>

<div id="html-loader">
<h4>html-loader</h4><pre>
npm i -D html-loader
Exports HTML as string. HTML is minimized when the compiler demands.

</pre>使用html-loader配置favicon<pre class="js">
{
  module: {
    rules: [
      {
        test: /\.html$/,
        use: [
          {
            loader: 'html-loader',
            options: {
              /*
              html-loader接受attrs参数表示什么标签的什么属性需要调用webpack的loader进行打包。
              比如img标签的src属性,webpack会把img引用的图片打包,然后src的属性值替换为打包后的路径。
              使用什么loader代码,同样是在module.rules定义中使用匹配的规则。
              如果html-loader不指定attrs参数,默认值是img:src, 意味着会默认打包img标签的图片。
              这里加上link标签的href属性,用来打包入口index.html < link rel="icon" type="image/png" href="favicon.png">引入的favicon.png文件。
              */
              attrs: ['img:src', 'link:href']
            }
          }
        ]
      },

      {
        // 匹配favicon.pn,上面的html-loader会把入口index.html引用的favicon.png图标文件解析出来进行打包,打包规则就按照这里指定的loader执行
        test: /favicon\.png$/,
        use: [
          {
            loader: 'file-loader',
            options: { name: '[hash].[ext]' }
          }
        ]
      },

      // 图片文件的加载配置增加一个exclude参数,排除favicon.png,因为它已经由上面的loader处理了。如果不排除掉它会被这个loader再处理一遍
      {
        test: /\.(png|jpg|jpeg|gif|eot|ttf|woff|woff2|svg|svgz)(\?.+)?$/,
        exclude: /favicon\.png$/,
        use: [
          {
            loader: 'url-loader',
            options: { limit: 10000 }
          }
        ]
      }
    ]
  }
}

</pre>html中的img标签没法使用resolve.alias别名功能,但html-loader有一个root参数可以使/开头的文件相对于root目录解析,那么< img src="/favicon.png">就能顺利指向到src目录下的favicon.png文件,不需要关心当前文件和目标文件的相对路径<pre class="js">
{
  test: /\.html$/,
  use: [
    {
      loader: 'html-loader',
      options: {
        root: resolve(__dirname, 'src'),
        attrs: ['img:src', 'link:href']
      }
    }
  ]
}

// 在调试img标签的时候遇到一个坑,html-loader会解析html注释中的内容,之前在注释中写的
< !--
大于 10kb 的图片,图片会被储存到输出目录,src 会被替换为打包后的路径
< img src="/assets/f78661bef717cf2cc2c2e5158f196384.png">
-->
之前因为没有加root参数,所以 / 开头的文件名不会被解析,加了root导致编译时报错,找不到该文件

</pre><pre>
默认每个本地的< img src="image.png">都需要通过require('./image.png')来进行加载,可能需要在配置中为图片指定loader如file-loader或url-loader

可以通过查询参数attrs来指定哪个标签属性组合(tag-attribute combination)应该被此loader处理。传递数组或以空格分隔的tag:attribute组合的列表,默认值：attrs=img:src

If you use custom-elements, and lots of them make use of a custom-src attribute, you don't have to specify each combination tag:attribute: just specify an empty tag like attrs=:custom-src and it will match every element.

</pre><pre class="js">
{
  test: /\.(html)$/,
  use: {
    loader: 'html-loader',
    options: {
      attrs: [':data-src']
    }
  }
}

</pre><pre>
要完全禁用对标签属性的处理例如如果在客户端处理图片加载,可以传入attrs=false

</pre><pre class="js">
{
  module: {
    rules: [
      { test: /\.jpg$/, use: [ "file-loader" ] },
      { test: /\.png$/, use: [ "url-loader?mimetype=image/png" ] }
    ]
  },
  output: {
    publicPath: "http://cdn.example.com/[hash]/"
  }
}

// file.html
< img src="image.png" data-src="image2x.png" >

require("html-loader!./file.html");
// '< img src="http://cdn.example.com/49eba9f/a992ca.png" data-src="image2x.png">'

require("html-loader?attrs=img:data-src!./file.html");
// '< img src="image.png" data-src="data:image/png;base64,..." >'

require("html-loader?attrs=img:src img:data-src!./file.html");
require("html-loader?attrs[]=img:src&attrs[]=img:data-src!./file.html");
// '< img  src="http://cdn.example.com/49eba9f/a992ca.png" data-src="data:image/png;base64,..." >'

require("html-loader?-attrs!./file.html");
// '< img  src="image.jpg"  data-src="image2x.png" >'

</pre>通过运行webpack --optimize-minimize来最小化<pre class="js">
// '< img src=http://cdn.example.com/49eba9f/a9f92ca.jpg data-src=data:image/png;base64,...>'

// 或者在webpack.conf.js的rule选项中指定minimize属性
module: {
  rules: [{
    test: /\.html$/,
    use: [ {
      loader: 'html-loader',
      options: {
        minimize: true
      }
    }],
  }]
}

</pre><pre>
The enabled rules for minimizing by default are the following ones:
removeComments
removeCommentsFromCDATA
removeCDATASectionsFromCDATA
collapseWhitespace
conservativeCollapse
removeAttributeQuotes
useShortDoctype
keepClosingSlash
minifyJS
minifyCSS
removeScriptTypeAttributes
removeStyleTypeAttributes

</pre>The rules can be disabled using the following options in your webpack.conf.js<pre class="js">
module: {
  rules: [{
    test: /\.html$/,
    use: [ {
      loader: 'html-loader',
      options: {
        minimize: true,
        removeComments: false,
        collapseWhitespace: false
      }
    }],
  }]
}

</pre>对于以/开头的url,默认行为是不转换它们。 如果设置了root查询参数,它将被添加到URL之前,然后进行转换<pre class="js">
// 和上面配置相同：
<img src="/image.jpg">

require("html-loader!./file.html");
// '< img src="/image.jpg">'

require("html-loader?root=.!./file.html");
// '< img src="http://cdn.example.com/49eba9f/a992ca.jpg">'

</pre>插值:可以使用interpolate标记为ES6模板字符串启用插值语法<pre>
require("html-loader?interpolate!./file.html");

< img src="${require(`./images/gallery.png`)}">
< div>${require('./components/gallery.html')}</div>

// 如果只想在模板中使用require,任何其它的${}不被转换,可以设置interpolate标记为require
require("html-loader?interpolate=require!./file.ftl");

<#list list as list>
  < a href="${list.href!}" />${list.name}</a>
</#list>
< img src="${require(`./images/gallery.png`)}">
< div>${require('./components/gallery.html')}</div>

</pre><pre>
导出格式
这里有几种不同的可用导出格式：
module.exports(默认配置,cjs格式)。"Hello world"转为module.exports = "Hello world";
exports.default (当设置了exportAsDefault参数,es6to5格式)。"Hello world"转为exports.default = "Hello world";
export default (当设置了exportAsEs6Default参数,es6格式)。"Hello world"转为export default "Hello world";

</pre>如果需要传递更多高级选项特别是那些不能被字符串化,还可以在webpack.config.js中定义一个htmlLoader属性<pre class="js">
var path = require('path')
module.exports = {
  module: {
    rules: [
      {
        test: /\.html$/,
        use: [ "html-loader" ]
      }
    ]
  },
  htmlLoader: {
    ignoreCustomFragments: [/\{\{.*?}}/],
    root: path.resolve(__dirname, 'assets'),
    attrs: ['img:src', 'link:href']
  }
};

</pre>如果需要定义两个不同的loader配置,也可以通过html-loader?config=otherHtmlLoaderConfig改变配置的属性名<pre class="js">
module.exports = {
  module: {
    rules: [
      {
        test: /\.html$/,
        use: [ "html-loader?config=otherHtmlLoaderConfig" ]
      }
    ]
  },
  otherHtmlLoaderConfig: {
    ...
  }
};

</pre><pre>
导出到HTML文件
一个很常见的场景:将HTML导出到.html文件中直接访问它们,而不是使用js注入,这可以通过3个loader的组合来实现：
file-loader
extract-loader
html-loader

html-loader将解析URL,并请求图片等一切资源。extract-loader会将javascript解析为合适的html文件,确保引用的图片指向正确的路径,file-loader将结果写入.html文件

</pre><pre class="js">
{
  test: /\.html$/,
  use: [ 'file-loader?name=[path][name].[ext]!extract-loader!html-loader' ]
}

</pre>
</div>

<div id="file-url">
<h4>Assets资源的基本处理需求</h4><pre>
Assets指项目中被引用的资源,通常为各种格式的图片和字体文件,当然也可能包含各式各样其他扩展名的文件(.json,.xml等),常见的图片和文字资源的处理包括：
体积压缩
雪碧图合并及引用修正
资源的引用路径自动替换

资源打标
webpack通过file-loader处理资源文件,它会将rules规则命中的资源文件按照配置的信息(路径,名称等)输出到指定目录即构建文件夹,并返回其资源定位地址(输出路径,用于生产环境的publicPath路径),默认的输出名是以原文件内容计算的MD5 Hash命名的

</pre>在webpack.config.js中添加对图片文件的处理规则<pre class="js">
{
  test:/\.(jpg|png|svg|gif)/,
  use:[{
    loader:'file-loader',
    options:{
      outputPath:'imgs/'
    }
  }]
}

</pre><pre>
执行打包命令可以看到png图片资源的名称被替换为hash并输出至构建文件夹。
CSS文件中对图片的引用也被替换为修改后的hash名称

html文件中静态资源引用替换需要通过html-loader
使用html-loader将html内容存为js字符串合并到js文件里,比如当遇到import htmlString from './template.html';

引用优化
构建工具通过url-loader来优化项目中对于资源的引用路径,并设定大小限制,当资源的体积小于limit时将其直接进行Base64转换后嵌入引用文件,体积大于limit时可通过fallback参数指定的loader进行处理。

也可以根据实际需求选择svg-url-loader,image-webpack-loader等其他插件

</pre>在webpack.config.js中添加url-loader相关配置<pre class="js">
{
  test:/\.(jpg|png|svg|gif)/,
  use:[{
    loader:'url-loader',
    options:{
      limit:8129,   //小于limit限制的图片将转为base64嵌入引用位置,小于8k的资源被直接内嵌进了CSS文件而没有生成独立的资源文件
      fallback:'file-loader', //大于limit限制的将转交给指定的loader处理
      outputPath:'imgs/'      //options会直接传给fallback指定的loader
    }
  }]
}

// 原始CSS文件中对资源的引用:
.with-img{
    background-image: url('../imgs/pic1.png');
}
.with-small-img{
    background-image: url('../imgs/6k.gif');
}

</pre><pre>
sprites雪碧图合成
有的场景下需要将图片资源合并为独立的雪碧图而减少http请求的次数,有的时候或许通过url-loader直接将其嵌入文档就可以。矢量图在不同场景下的处理方式也不相同。

webpack官方仓库并没有推荐图片的处理工具,而是采用url-loader + file-loader作为资源处理的一般通用方案。

1.位图处理
位图资源可以使用webpack-spritesmith插件进行处理,在webpack.config.js的plugins配置项中实例化插件并传入配置信息,运行webpack后可以得到sprites.css和合成的雪碧图

</pre><pre class="js">
new SpritesmithPlugin({
  //设置源icons,即icon的路径,必选项
  src: {
    cwd: __dirname + '/imgs/pngs',
    glob: '*.png' //正则匹配,照着填即可
  },
  //设置导出的sprite图及对应的样式文件,必选项
  target: {
    image: __dirname + '/build/imgs/sprite.png',
    css: __dirname + '/build/imgs/sprite.css'
  },
  //设置sprite.png的引用格式,会自己加入sprite.css的头部
  apiOptions: {
    cssImageRef: './sprite.png' //cssImageRef为必选项
  },
  //配置spritesmith选项,非必选
  spritesmithOptions: {
    algorithm: 'top-down',//设置图标的排列方式
    padding: 4 //每张小图的补白,避免雪碧图中边界部分的bug
  }
})

</pre><pre>
2. 矢量图处理
开发中常用的矢量图为svg格式,既可以使用inline-svg-loader进行资源嵌入,也可以使用svg-sprite-loader将矢量图资源合并为雪碧图,具体采用哪种方案需要由项目的实际情况来判断。矢量图的合并原理与位图稍有不同

源代码中的引用:
.class1{
  background-image: url('../imgs/svgs/001-home.svg') no-repeat 0 0;
}

使用inline-svg-loader加载器打包后的引用：
.class1{
  background-image: url("< svg version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" viewBox=\"0 0 16 16\">< path fill=\"#000000\" d=\"M16 9.226l-8-6.21-8 6.21v-2.532l8-6.21 8 6.21zM14 9v6h-4v-4h-4v4h-4v-6l6-4.5z\">< /path>< /svg>") no-repeat 0 0;
}

【 file-loader 】
npm install --save-dev file-loader
Instructs webpack to emit the required object as file and to return its public URL
默认生成的文件的文件名就是文件内容的MD5哈希值并会保留所引用资源的原始扩展名

</pre>生成文件file.png,输出到输出目录并返回public URL: "/public/path/0dcbbaa7013869e351f.png"<pre class="js">
import img from './file.png'
var myImage = new Image();
myImage.src = img;
document.body.appendChild(myImage);

{
  test: /\.(png|jpg|gif)$/,
  use: [
    {
      loader: 'file-loader',
      options: {}
    }
  ]
}

</pre><pre>
配置选项
name {String|Function} default [hash].[ext]
为文件配置自定义文件名模板

placeholders
[ext] type:{String} default:file.extname desc:资源扩展名
[name] type:{String} default:file.basename desc:资源的基本名称
[path] type:{String} default:file.dirname desc:资源相对于context的路径
[hash] type:{String} default:md5 desc:内容的哈希值
[N] type:{Number} desc:当前文件名按照查询参数regExp匹配后获得到第N个匹配结果

hashes
[< hashType>:hash:< digestType>:< length>] optionally you can configure
hashType type:{String} default:md5 desc:sha1, md5, sha256, sha512
digestType type:{String} default:base64 desc:hex, base26, base32, base36, base49, base52, base58, base62, base64
length type:{Number} default:9999 desc:字符的长度
默认文件会按照指定的路径和名称输出同一目录中,且会使用相同的URL路径来访问文件

</pre><pre class="js">
name: '[path][name].[ext]'

import png from 'image.png'
name: 'dirname/[hash].[ext]'          // dirname/0dcbbaa701328ae351f.png

name: '[sha512:hash:base64:7].[ext]'  // gdyb21L.png

import png from 'path/to/file.png'
name: '[path][name].[ext]?[hash]'     // path/to/file.png?e43b20c069c4a01867c31e98cbce33c9

name(file) {
  if(env === 'development') return '[path][name].[ext]'
  return '[hash].[ext]'
}

</pre><pre>
context {String} default this.options.context
配置自定义文件context,默认为webpack.config.js context
可以使用outputPath,useRelativePath和publicPath来指定自定义output输出路径和public发布目录

publicPath {String|Function} default __webpack_public_path__
为文件配置自定义public发布目录,如publicPath: 'assets/'

outputPath {String|Function} default 'undefined'
为文件配置自定义output输出目录,如outputPath: 'images/'

useRelativePath {Boolean} default false
如果希望为每个文件生成一个相对url的context时应该将其设置为true,如useRelativePath: process.env.NODE_ENV === "production"

emitFile {Boolean} default true
默认情况下会生成文件,可以通过将此项设置为false来禁止,例如使用了服务端的packages
返回public URL但不会生成文件,`${publicPath}/0dcbbaa701328e351f.png`

【 url-loader 】
npm install --save-dev url-loader
Loads files as base64 encoded URL,url-loader功能类似于file-loader,但是在文件大小(单位byte)低于指定的限制时可以返回一个DataURL

Options
limit {Number} default undefined
Byte limit to inline files as Data URL,如limit: 8192

mimetype {String} default extname
Specify MIME type for the file, Otherwise it's inferred(推断出) from the file extension,如mimetype: 'image/png'

fallback {String} default file-loader
Specify loader for the file when file is greater than the limit(in bytes),如fallback: 'responsive-loader'

</pre><pre class="js">
import img from './image.png'
var myImage = new Image();
myImage.src = img;
document.body.appendChild(myImage);

{
  test: /\.(png|jpg|gif)$/,
  use: [
    {
      loader: 'url-loader',
      options: {
        limit: 8192
      }
    }
  ]
}

</pre><pre class="js">
{
  test: /\.(png|jpg|gif|svg)$/,
  use: [{
    loader: 'file-loader',
    options: {
      name: '[name].[ext]?[hash]'
    }
  }]
},{
  test: /\.(png|jpg|jpeg|gif|eot|ttf|woff|woff2|svg|svgz)(\?.+)?$/,
  use: [{ loader: 'url-loader', options: { limit: 10000 } }]
},{
  test: /\.(gif|png|jpg|jpeg|svg)$/,
  use: [{
    loader: 'url-loader',
    options: {
      limit: 1024,
      name: 'images/[name]-webpack.[ext]',
    }
  }]
},
{
  test: /\.(mp4|webm|ogg|mp3|wav|flac|aac)(\?.*)?$/,
  loader: 'url-loader',
  options: { limit: 10000, name: '/YDW_res/media/[name].[ext]' }
},
{
  test: /\.(woff2?|eot|ttf|otf)(\?.*)?$/,
  loader: 'url-loader',
  options: { limit: 10000, name: '/YDW_res/fonts/[name].[ext]' }
}

</pre>
</div>

<div id="css">
<h4>CSS文件处理</h4><pre>
假设项目中的CSS文件均采用预编译语言编写,那么在打包中需要处理的基本问题包括：
预编译语言转换
样式文件挂载方式选择
代码优化(合并及压缩)
去除或保留指定格式的注释
资源定位路径的转换
响应式布局单位转换,可选
模块化,可选
处理浏览器兼容,可选

构建工具可以通过自动化检测将预编译语言转换为CSS,基于现代化构建工具的CSS-Module功能,可以通过特定的语法解决CSS模块化的问题,而基于POSTCSS实现的autoprefixer插件,可以依据CanIUse网站提供的浏览器支持度数据实现代码的跨浏览器前缀自动补齐

webpack4.0中CSS模块的处理方式需要用到的插件及功能如下：
style-loader——将处理结束的CSS代码存储在js中,运行时嵌入style后挂载至html页面上
css-loader——加载器,使webpack可以识别css模块
postcss-loader——加载器
sass-loader——加载器,使webpack可以识别scss/sass文件,默认使用node-sass进行编译
mini-css-extract-plugin——插件,4.0版本启用的插件,替代原extract-text-webpack-plugin插件,将处理后的CSS代码提取为独立的CSS文件
optimize-css-assets-webpack-plugin——插件,实现CSS代码压缩优化
autoprefixer——自动化添加跨浏览器兼容前缀

</pre><pre class="js">
const ExtractTextPlugin = require('extract-text-webpack-plugin')

{
	test: /\.less$/,
	use: ExtractTextPlugin.extract({
		fallback: 'style-loader',
		use: [
			'css-loader',
			{
				loader: 'postcss-loader',
				options: {
					plugins: [
						require('autoprefixer')
						require('autoprefixer')({browsers: ['last 5 versions']})
					]
				}
			},
			'less-loader'
		]
	})
},

</pre><pre class="js">
// 在webpack中使用postcss自动添加厂商前缀
cnpm install --save-dev style-loader css-loader postcss-loader autoprefixer

const extractTextWebpackPlugin = require('extract-text-webpack-plugin');
let cssExtract = new extractTextWebpackPlugin({ filename: 'css/index.css', disable: false });
let sassExtract = new extractTextWebpackPlugin({ filename: 'css/public.css', disable: false });

rules: [
  //配置css加载器
  {
    test: /\.css$/,
    use: cssExtract.extract({
      fallback: "style-loader",
      use: ["css-loader", "postcss-loader"]
    })
  },
  //配置sass加载器
  {
    test: /\.scss$/,
    use: sassExtract.extract({
      fallback: 'style-loader',
      use: ['css-loader', "postcss-loader", 'sass-loader']
    })
  },
]

// 在根目录下面创建一个postcss.config.js文件,并配置如下
module.exports = {
  plugins: [
  	require('autoprefixer')
  ]
}

</pre><pre class="js">
const HtmlWebpackPlugin = require('html-webpack-plugin');                      //用于自动生成html入口文件的插件
const MiniCssExtractPlugin = require("mini-css-extract-plugin");               //将CSS代码提取为独立文件的插件
const OptimizeCssAssetsPlugin = require("optimize-css-assets-webpack-plugin"); //CSS模块资源优化插件

module.exports = {
  mode:'development',
  entry:'./main.js',
  output:{
    filename:'main.bundle.js',
    path:__dirname + '/build'
  },
  module: {
    rules: [
      {
        test: /\.scss$/,
        exclude: /node_modules/,                  // 排除node_modules文件夹
        use: [
          {
            loader: MiniCssExtractPlugin.loader   // 建议生产环境采用此方式解耦CSS文件与js文件
          },{
            loader: 'css-loader',                 // CSS加载器
            options: {importLoaders: 2}           // 指定css-loader处理前最多可以经过的loader个数
          },{
            loader: 'postcss-loader',             // 承载autoprefixer功能
          },{
            loader: 'sass-loader'                 // SCSS加载器,webpack默认使用node-sass进行编译
          }
        ]
      }
    ]
  },
  plugins:[
      new HtmlWebpackPlugin(),    // 生成入口html文件
      new MiniCssExtractPlugin({  // 为抽取出的独立的CSS文件设置配置参数
        filename: "[name].css"
      })
  ],
  optimization:{
    minimizer:[                   //对生成的CSS文件进行代码压缩,mode='production'时生效
      new OptimizeCssAssetsPlugin()
    ]
  }
}

/* postcss.config.js的配置较为简单 */
module.exports = {
  plugins:[
    require('autoprefixer')
  ]
}

// package.json中增加新的参数指定打包需要支持的浏览器类别：
"browerslist": [
  "last 2 versions",
  "IE 8",
  "UCAndroid"
]

/* SCSS代码 */
//变量定义
$grey: #1e1e1d;
$yellow: #ffad15;
$offwhite: #f8f8f8;
$darkerwhite: darken($offwhite, 15);//SCSS函数
$baseFontSize:14px;

//循环
@for $i from 1 through 3 {
  .item-#{$i} { width: 2em * $i; }
}

//mixin
@mixin px2rem($name, $px){
  #{$name}: $px / $baseFontSize * 1rem;
}

//嵌套
.class3{
  font-weight: bold;
  display:flex;
  &-small{
    color: $offwhite;
    @include px2rem('font-size',14px);
  }
}

//autoprefixer
::placeholder{
  width:10px;
}

</pre><pre>
【 css-loader 】
npm install --save-dev css-loader
css-loader解释(interpret) @import和url() ,会import/require()后再解析(resolve)它们。
引用资源的合适loader是file-loader和url-loader,应该在配置中指定

</pre><pre class="js">
import css from 'file.css'

{
  test: /\.css$/,
  use: [ 'style-loader', 'css-loader' ]
}

</pre>也可以直接将css-loader的结果作为字符串使用,例如Angular的组件样式,如果有SourceMap,它们也将包含在字符串结果中<pre class="js">
{
   test: /\.css$/,
   use: [
     'to-string-loader',
     'css-loader'
   ]
}

// 或者
const css = require('./test.css').toString();
console.log(css); // {String}

</pre>如果由于某种原因需要将CSS提取为纯粹的字符串资源,即不包含在JS模块中,则可能需要查看extract-loader,例如当你需要将CSS作为字符串进行后处理时很有用<pre class="js">

{
   test: /\.css$/,
   use: [
     'handlebars-loader', // handlebars loader expects raw resource string
     'extract-loader',
     'css-loader'
   ]
}

</pre>以下webpack.config.js可加载CSS文件,将小体积PNG/JPG/GIF/SVG图像转为像字体那样的Data URL嵌入,并复制较大的文件到输出目录<pre class="js">
// 先使用css-loader处理,返回的结果交给style-loader处理。css-loader将css内容存为js字符串,并且会把background、 @font-face等引用的图片、字体文件交给指定的loader打包,类似html-loader,用什么loader同样在rules对象中定义

module.exports = {
  module: {
    rules: [
      {
        test: /\.css$/,
        use: [ 'style-loader', 'css-loader' ]
      },
      {
        test: /\.(png|jpg|gif|svg|eot|ttf|woff|woff2)$/,
        test: /\.(png|jpg|jpeg|gif|eot|ttf|woff|woff2|svg|svgz)(\?.+)?$/,
        loader: 'url-loader',
        options: {
          limit: 10000
        }
      }
    ]
  }
}

</pre><pre>
使用CSS-Modules
CSS Module在CSS中使用类选择器,其基本原理是将CSS代码中的样式名替换为哈希值,并建立一个json对照表,在js文件中对于属性名选择器的使用均被替换为哈希字符串,以此来解决CSS模块化的问题。

在webpack中使用CSS Modules功能非常简单,只需要在css-loader的配置参数中设置:{modules:true}即可激活模块化功能。

</pre>在生产环境构建可通过使用extract-text-webpack-plugin来实现从bundle中提取CSS,以便之后并行加载CSS/JS资源,<pre class="js">
const env = process.env.NODE_ENV
const ExtractTextPlugin = require('extract-text-webpack-plugin')

module.exports = {
  module: {
    rules: [
      {
        test: /\.css$/,
        use: env === 'production'
          ? ExtractTextPlugin.extract({
              fallback: 'style-loader',
              use: [ 'css-loader' ]
          })
          : [ 'style-loader', 'css-loader' ]
      },
    ]
  },
  plugins: env === 'production' ? [ new ExtractTextPlugin({ filename: '[name].css' }) ] : []
}

</pre><pre>
选项
root type:{String} default:/
解析URL的路径,以/开头的URL不会被转译
对于以/开头的URL默认行为是不转译它们,url(/image.png) => url(/image.png)
如果设置了root查询参数,那么此查询参数将被添加到URL前面,然后再进行转译
{
  loader: 'css-loader',
  options: { root: '.' }
}
url(/image.png) => require('./image.png')
不建议使用'相对根路径'的url。应该只将其用于旧版CSS文件

url  type:{Boolean} default:true
启用/禁用url()处理,要禁用css-loader解析url()将选项设置为false
与现有的css文件兼容(如果不是在CSS模块模式下)。
url(image.png) => require('./image.png')
url(~module/image.png) => require('module/image.png')

alias  type:{Object} default:{}
创建别名更容易导入一些模块,用别名重写URL在难以改变输入文件的url路径时很有帮助,例如当使用另一个包(package)如bootstrap、ratchet、font-awesome等中一些css/sass文件。
css-loader的别名遵循与webpack的resolve.alias相同的语法

</pre><pre class="js">
// index.scss
@charset "UTF-8";
@import "bootstrap";

// webpack.config.js
const path = require("path");
module.exports = {
  entry: path.resolve(__dirname, "index.scss"),
  output: {
    path: path.resolve(__dirname),
    filename: "bundle.bootstrap-sass.js"
  },
  devtool: "source-map",
  module: {
    rules: [{
      test: /\.scss$/,
      use: [{
        loader: "style-loader"
      }, {
        loader: "css-loader",
        options: {
          alias: {
            "../fonts/bootstrap": "bootstrap-sass/assets/fonts/bootstrap"
          }
        }
      }, {
        loader: "sass-loader",
        options: {
          includePaths: [
            path.resolve("./node_modules/bootstrap-sass/assets/stylesheets")
          ]
        }
      }]
    }, {
      test: /\.woff2?$|\.ttf$|\.eot$|\.svg$/,
      use: [{
        loader: "file-loader"
      }]
    }]
  }
};

// index.html
< !DOCTYPE html>
< html lang="en">
  < head>
    < meta charset="utf-8">
    < meta http-equiv="X-UA-Compatible" content="IE=edge">
    < meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
    < meta name="description" content="">
    < meta name="author" content="">
    < link rel="icon" href="//getbootstrap.com/favicon.ico">

    < title>Starter Template for Bootstrap< /title>

    <!-- IE10 viewport hack for Surface/desktop Windows 8 bug -->
    < link href="//getbootstrap.com/assets/css/ie10-viewport-bug-workaround.css" rel="stylesheet">

    <!-- Custom styles for this template -->
    < link href="//getbootstrap.com/examples/starter-template/starter-template.css" rel="stylesheet">

    <!-- Just for debugging purposes. Don't actually copy these 2 lines! -->
    <!--[if lt IE 9]><script src="//getbootstrap.com/assets/js/ie8-responsive-file-warning.js"></script><![endif]-->
    < script src="//getbootstrap.com/assets/js/ie-emulation-modes-warning.js"></script>

    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
  < /head>

  < body>

    < nav class="navbar navbar-inverse navbar-fixed-top">
      < div class="container">
        < div class="navbar-header">
          < button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
            < span class="sr-only">Toggle navigation< /span>
            < span class="icon-bar">< /span>
            < span class="icon-bar">< /span>
            < span class="icon-bar">< /span>
          < /button>
          < a class="navbar-brand" href="#">Project name< /a>
        < /div>
        < div id="navbar" class="collapse navbar-collapse">
          < ul class="nav navbar-nav">
            < li class="active">< a href="#">Home< /a>< /li>
            < li>< a href="#about">About< /a>< /li>
            < li>< a href="#contact">Contact< /a>< /li>
          < /ul>
        < /div><!--/.nav-collapse -->
      < /div>
    < /nav>

    < div class="container">
      < div class="starter-template">
        < h1>Bootstrap starter template< /h1>
        < p class="lead">Use this document as a way to quickly start any new project.<br> All you get is this text and a mostly barebones HTML document.< /p>
      < /div>
    < /div><!-- /.container -->


    <!-- Bootstrap core JavaScript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    < script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js">< /script>
    < script async src="/bundle.bootstrap-sass.js">< /script>
  < /body>
< /html>

</pre><pre>
import  type:{Boolean} default:true
启用/禁用@import处理,要禁用css-loader解析@import将选项设置为false
@import url('https://fonts.googleapis.com/css?family=Roboto');
谨慎使用,因为这将禁用解析所有@import,包括css模块composes: xxx from 'path/to/file.css'功能

modules  type:{Boolean} default:false
启用/禁用CSS模块
查询参数modules会启用CSS模块规范。
默认情况下这将启用局部作用域CSS。可以使用:global(...)或:global关闭选择器and/or规则

minimize  type:{Boolean|Object} default:false
启用/禁用压缩

sourceMap  type:{Boolean} default:false
启用/禁用Sourcemap,设置sourceMap选项查询参数来引入source map,例如extract-text-webpack-plugin能够处理它们
默认情况下不启用它们,因为它们会导致运行时的额外开销,并增加了bundle大小(JS source map不会)。此外相对路径是错误的,需要使用包含服务器URL的绝对公用路径

camelCase  type:{Boolean|String} default:false
以驼峰化式命名导出类名
默认导出JSON键值对形式的类名。如果想要驼峰化(camelize)类名(有助于在JS中使用),通过设置css-loader的查询参数camelCase即可实现

</pre><pre class="js">
// file.css
.class-name {}

// file.js
import { className } from 'file.css';

// webpack.config.js
{
  loader: 'css-loader',
  options: {
    camelCase: true
  }
}

</pre><pre>
importLoaders  type:{Number} default:0
在css-loader前应用的loader的数量

localIdentName  type:{String} default:[hash:base64]
配置生成的标识符(ident)

</pre><pre>
【 style-loader 】
npm install style-loader --save-dev
Adds CSS to the DOM by injecting a style tag,建议将style-loader与css-loader结合使用

</pre><pre class="js">
// component.js
import style from './file.css'

// webpack.config.js
{
  module: {
    rules: [
      {
        test: /\.css$/,
        use: [
          { loader: "style-loader" },
          { loader: "css-loader" }
        ]
      }
    ]
  }
}

</pre><pre>
在使用局部作用域CSS时模块导出生成的(局部)标识符(identifier)
// component.js
import style from './file.css'
style.className === "z849f98ca812"

</pre><pre>
也可以添加一个URL< link href="path/to/file.css" rel="stylesheet">,而不是用带有style标签的内联CSS {String}

使用url引用的Source map和资源
当style-loader与{ options: { sourceMap: true } }选项一起使用时,CSS模块将生成为Blob,因此相对路径无法正常工作(他们将相对于chrome:blob或chrome:devtools)。为了使资源保持正确的路径,必须设置webpack配置中的output.publicPath属性以便生成绝对路径,或者可以启用上面convertToAbsoluteUrls选项

</pre><pre class="js">
import url from 'file.css'

{
  module: {
    rules: [
      {
        test: /\.css$/,
        use: [
          { loader: "style-loader/url" },
          { loader: "file-loader" }
        ]
      }
    ]
  }
}

< link rel="stylesheet" href="path/to/file.css">

</pre><pre>
选项
hmr type:{Boolean} default:true
Enable/disable Hot Module Replacement(HMR), if disabled no HMR Code will be added(good for non local development/production)

</pre><pre class="js">
{
  loader: 'style-loader',
  options: {
    hmr: false
  }
}

</pre><pre>
base type:{Number} default:true
设置模块 ID 基础(DLLPlugin)

attrs type:{Object} default:{}
添加自定义attrs到style标签,如果已定义则style-loader将把属性值附加在style/link元素上

</pre><pre class="js">
// component.js
import style from './file.css'

// webpack.config.js
{
  test: /\.css$/,
  use: [
    { loader: 'style-loader', options: { attrs: { id: 'id' } } }
    { loader: 'css-loader' }
  ]
}

< style id="id">< /style>

</pre>url<pre class="js">
// component.js
import link from './file.css'

// webpack.config.js
{
  test: /\.css$/,
  use: [
    { loader: 'style-loader/url', options: { attrs: { id: 'id' } } }
    { loader: 'file-loader' }
  ]
}

</pre><pre>
transform type:{Function} default:false
转换/条件加载CSS,通过传递转换/条件函数
transform是一个函数,可以在通过style-loader加载到页面之前修改css。 该函数将在即将加载的css上调用,函数的返回值将被加载到页面,而不是原始的css中。 如果transform函数的返回值是falsy值,那么css根本就不会加载到页面中

</pre><pre class="js">
// webpack.config.js
{
  loader: 'style-loader',
  options: {
    transform: 'path/to/transform.js'
  }
}

// transform.js
module.exports = function(css) {
  // Here we can change the original css
  const transformed = css.replace('.classNameA', '.classNameB')

  return transformed
}

</pre>Conditional<pre class="js">
// webpack.config.js
{
  loader: 'style-loader',
  options: {
    transform: 'path/to/conditional.js'
  }
}

// conditional.js,如果条件匹配则加载[和转换]CSS,如果返回falsy值则不会加载CSS
module.exports = function(css) {
  if(css.includes('something I want to check')) return css;
  return false
}

</pre><pre>
insertAt type:{String|Object} default:bottom
在给定位置处插入style标签
默认style-loader将style元素附加到样式目标(style target)的末尾即页面的head标签,也可以是由insertInto指定其他标签。这将导致loader创建的CSS优先于目标中已经存在的CSS。要在目标的起始处插入style元素,请将此查询参数(query parameter)设置为'top'

</pre><pre class="js">
{
  loader: 'style-loader',
  options: {
    insertAt: 'top'
  }
}

{
  loader: 'style-loader',
  options: {
    insertAt: {
      before: '#id'
    }
  }
}

</pre><pre>
insertInto type:{String} default:< head>
给定位置中插入style标签
默认样式加载器将style元素插入到页面的head标签中。如果要将标签插入到其他位置,可以在这里为该元素指定CSS选择器。如果想要插入到IFrame中请确保具有足够的访问权限,样式将被注入到内容文档的head中。 还可以将样式插入到ShadowRoot中

</pre><pre class="js">
{
  loader: 'style-loader',
  options: {
    insertInto: '#host::shadow>#root'
  }
}

</pre><pre>
sourceMap type:{Boolean} default:false
启用/禁用Sourcemap

convertToAbsoluteUrls type:{Boolean} default:false
启用source map后将相对URL转换为绝对URL
如果convertToAbsoluteUrls和sourceMaps都启用,那么相对url将在css注入页面之前被转换为绝对url。这解决了在启用source map时相对资源无法加载的问题。可以使用convertToAbsoluteUrls选项启用它

</pre><pre class="js">
{
  loader: 'style-loader',
  options: {
    sourceMap: true,
    convertToAbsoluteUrls: true
  }
}

</pre><pre>
【 postcss-loader 】
npm i -D postcss-loader autoprefixer
Loader for webpack to process CSS with PostCSS

postcss一种对css编译的工具,类似babel对js的处理,常见的功能：
1、使用下一代css语法
2、自动补全浏览器前缀
3、自动把px代为转换成rem
4、css代码压缩等

postcss只是一个工具,本身不会对css一顿操作,它通过插件实现功能,autoprefixer就是其一。

与less、sass的区别
less、sass是预处理器,用来支持扩充css语法,less、sass扩展了原生css,把css作为一个子集,但这不好保持向后兼容
postcss既不是预处理器也不是后处理器,其功能比较广泛,而且重要的一点是postcss可以和less/sass结合使用
虽然可以结合less/sass使用,但是它们还是有很多重复功能,用其中一个基本就ok

</pre><pre class="js">
// npm install --save-dev css-loader style-loader postcss-loader autoprefixer

// webpack.config.js中配置
{
  test: /\.css$/,
  use: [
    {
      loader: MiniCssExtractPlugin.loader,
      options: { hmr: true },
    },
    // 'style-loader',
    {
      loader: 'css-loader',
      options:{
        modules:true,
        importLoaders:1,             // 在css-loader前应用的loader的数量
        minimize: true,
        localIdentName: '[local]_[hash:base64:5]'
      }
    },
    {
      loader: 'postcss-loader',
      options: {
        plugins: [
          require('autoprefixer')({
            "overrideBrowserslist": [
              "defaults",
              "not ie < 11",
              "last 2 versions",
              "> 1%",
              "iOS 7",
              "last 3 iOS versions"
            ]
          })
        ]
      }
    }
  ]
}

// postcss-loader的options选项抽取到postcss.config.js中配置
// 在项目根目录创建postcss.config.js,并且设置支持哪些浏览器,必须设置支持的浏览器才会自动添加添加浏览器兼容,postcss的配置文件里面配置一些插件,也可以在webpack中配置
module.exports = {
  plugins: [
  	// require('autoprefixer')    // 可以都不填,用默认配置
  	// require('autoprefixer')({ browsers: '> 5%' })
  	// require('autoprefixer')({ browsers: ['last 2 versions'] })
  	// require('autoprefixer')({ browsers: ['last 10 versions'] }
    require('autoprefixer')({
        "browsers": [
            "defaults",
            "not ie < 11",
            "last 2 versions",
            "> 1%",
            "iOS 7",
            "last 3 iOS versions"
        ]
    })
  ]
};

</pre>
</div>

<div id="vue-loader">
<h4>vue-loader</h4><pre>
npm i -D vue-loader vue-template-compiler
vue-template-compiler需要独立安装的原因是可以单独指定其版本,每个vue包的新版本发布时一个相应版本的vue-template-compiler也会随之发布。编译器的版本必须和基本的vue包保持同步,这样vue-loader就会生成兼容运行时的代码,这意味着每次升级项目中的vue包时也应该匹配升级vue-template-compiler

Vue Loader是一个webpack的loader,允许以一种名为单文件组件(SFCs)的格式撰写Vue组件,帮助撰写Vue.js应用

Vue Loader提供了很多酷炫的特性：
允许为Vue组件的每个部分使用其它的webpack loader,例如在style的部分使用Sass和在template的部分使用Pug
允许在一个.vue文件中使用自定义块,并对其运用自定义的loader链
使用webpack loader将style和template中引用的资源当作模块依赖来处理
为每个组件模拟出scoped CSS
在开发过程中使用热重载来保持状态

</pre><pre class="js">
// webpack.config.js
const VueLoaderPlugin = require('vue-loader/lib/plugin')

module.exports = {
  mode: 'development',
  module: {
    rules: [
      {
        test: /\.vue$/,
        loader: 'vue-loader'
      },{
        test: /\.js$/,           // 应用到普通的.js文件以及.vue文件中的script块
        loader: 'babel-loader'
      },{
        test: /\.css$/,          // 应用到普通的.css文件以及.vue文件中的style块
        use: [
          'vue-style-loader',
          'css-loader'
        ]
      }
    ]
  },
  plugins: [
    new VueLoaderPlugin()       // 将定义过的其它规则复制并应用到.vue文件里相应语言的块
  ]
}

</pre><pre>
【 处理资源路径 】
当vue-loader编译单文件组件中的template块时会将所有遇到的资源URL转换为webpack模块请求

资源URL转换规则：
1、如果路径是绝对路径如/images/foo.png会原样保留。
2、如果路径以 . 开头将会被看作相对的模块依赖,并按照本地文件系统上的目录结构进行解析。
3、如果路径以 ~ 开头其后的部分将会被看作模块依赖,即可用该特性来引用一个Node依赖中的资源：< img src="~some-npm-package/foo.png">
4、如果路径以 @ 开头也会被看作模块依赖。如果webpack配置中给@配置了alias就很有用了,所有vue-cli创建的项目都默认配置了将@指向/src

【 使用预处理器 】
在webpack中所有的预处理器需要匹配对应的loader,vue-loader允许使用其它webpack loader处理Vue组件的某一部分,它会根据lang特性以及webpack配置中的规则自动推断出要使用的loader

</pre>通过Sass/SCSS编译style标签<pre class="js">
// node-sass4.5.3不支持node10,node10版本NODE_MODULE_VERSION 64,这文件就是不存在的,下载不下来,node-sass 4.9.0 版本开始支持node10
npm install -D sass-loader node-sass@4.9.0


// 普通的.scss文件和*.vue文件中的style lang="scss"块都应用它
{
  test: /\.scss$/,
  use: [ 'vue-style-loader', 'css-loader', 'sass-loader' ]
}

现在除了能够import 'style.scss'还可以在Vue组件中使用SCSS：
< style lang="scss">
/* 在这里撰写SCSS */
< /style>
这个块里的任何内容都会被webpack当作在一个*.scss文件中一样被处理

{
  test: /\.sass$/,
  use: [
    'vue-style-loader',
    'css-loader',
    {
      loader: 'sass-loader',
      options: {
        // sass-loader会默认处理不基于缩进的scss语法,为了使用基于缩进的sass语法需要向这个loader传递选项：
        indentedSyntax: true,

        // 共享全局变量:sass-loader支持data选项来允许在所有被处理的文件之间共享常见的变量,而不需要显式地导入它们：
        // 也可以从一个文件读取如 `variables.scss`
        data: `$color: red;`
      }
    }
  ]
}

</pre>less<pre class="js">
npm install -D less less-loader

{
  test: /\.less$/,
  use: [
    'vue-style-loader',
    'css-loader',
    'less-loader'
  ]
}

</pre>stylus<pre class="js">
npm install -D stylus stylus-loader

{
  test: /\.styl(us)?$/,
  use: [
    'vue-style-loader',
    'css-loader',
    'stylus-loader'
  ]
}

</pre>PostCSS的配置可以通过postcss.config.js或postcss-loader选项来完成<pre class="js">
npm install -D postcss-loader

{
  test: /\.css$/,
  use: [
    'vue-style-loader',
    {
      loader: 'css-loader',
      options: { importLoaders: 1 }
    },
    'postcss-loader'
  ]
}

</pre>Babel的配置可以通过.babelrc或babel-loader选项来完成<pre class="js">
npm install -D babel-core babel-loader

{
  test: /\.js?$/,
  loader: 'babel-loader',
  // 排除node_modules: 为了确保JS的转译应用到node_modules的Vue单文件组件需要通过使用一个排除函数将它们加入白名单
  exclude: file => (/node_modules/.test(file) && !/\.vue\.js/.test(file))
}

</pre>TypeScript的配置可以通过tsconfig.json来完成<pre class="js">
npm install -D typescript ts-loader

module.exports = {
  resolve: {
    extensions: ['.ts', '.js']     // 将.ts添加为一个可解析的扩展名
  },
  module: {
    rules: [
      {
        test: /\.ts$/,
        loader: 'ts-loader',
        options: { appendTsSuffixTo: [/\.vue$/] }
      }
    ]
  },
}

</pre><pre>
Pug
模板的处理会稍微有些不同,因为绝大对数webpack的模板类loader如pug-loader会返回一个模板函数而不是一个编译好的HTML字符串,所以需要使用一个返回原始的HTML字符串的loader如pug-plain-loader

</pre><pre class="js">
npm install -D pug pug-plain-loader

{
  test: /\.pug$/,
  loader: 'pug-plain-loader'
}

< template lang="pug">
div
  h1 Hello world!
< /template>

</pre><pre>
如果还打算使用它在js中将.pug文件作为字符串导入,需要在这个预处理loader之后链上raw-loader,添加raw-loader会破坏Vue组件内的用法,所以需要定义两条规则,其中一条指向使用了一个resourceQuery的Vue文件,另一条指向 (回退到) JavaScript导入

</pre><pre class="js">
{
  test: /\.pug$/,
  oneOf: [
    // 这条规则应用到Vue组件内的< template lang="pug">
    {
      resourceQuery: /^\?vue/,
      use: ['pug-plain-loader']
    },
    // 这条规则应用到JavaScript内的pug导入
    {
      use: ['raw-loader', 'pug-plain-loader']
    }
  ]
}

</pre><pre>
【 Scoped CSS 】
当style标签有scoped属性时它的CSS只作用于当前组件中的元素,这类似于Shadow DOM中的样式封装,它有一些注意事项,但不需要任何 polyfill,它通过使用PostCSS来实现以下转换：

</pre><pre class="js">
< style scoped>
.example { color: red; }
< /style>

< template>
  < div class="example">hi< /div>
< /template>

// 转换结果：
< style>
.example[data-v-f3f3eg9] { color: red; }
< /style>

< template>
  < div class="example" data-v-f3f3eg9>hi< /div>
< /template>

</pre>混用本地和全局样式:可以在一个组件中同时使用有scoped和非scoped样式<pre class="js">
< style>
/* 全局样式 */
< /style>

< style scoped>
/* 本地样式 */
< /style>

</pre><pre>
子组件的根元素
使用scoped后父组件的样式将不会渗透到子组件中。不过一个子组件的根节点会同时受其父组件的scoped CSS和子组件的scoped CSS的影响,这样设计是为了让父组件可以从布局的角度出发,调整其子组件根元素的样式

深度作用选择器
如果希望scoped样式中的一个选择器能够作用得“更深”,例如影响子组件,可以使用 >>> 操作符：
有些像Sass之类的预处理器无法正确解析>>>,这种情况下可以使用/deep/或::v-deep操作符取代,两者都是>>>的别名,同样可以正常工作

</pre><pre class="js">
< style scoped>
.a >>> .b { /* ... */ }
< /style>

// 上述代码将会编译成：
.a[data-v-f3f3eg9] .b { /* ... */ }

</pre><pre>
动态生成的内容
通过v-html创建的DOM内容不受scoped样式影响,但仍然可以通过深度作用选择器来为他们设置样式

Scoped样式不能代替class,考虑到浏览器渲染各种CSS选择器的方式,当p { color: red }是scoped时即与特性选择器组合使用时会慢很多倍,如果使用class或id取代比如.example { color: red }性能影响就会消除

在递归组件中小心使用后代选择器,对选择器.a .b中的CSS规则来说,如果匹配.a的元素包含一个递归子组件,则所有的子组件中的.b都将被这个规则匹配

【 CSS Modules 】
CSS Modules是一个流行的用于模块化和组合CSS的系统。vue-loader提供了与CSS Modules的一流集成,可以作为模拟scoped CSS的替代方案。

</pre><pre class="js">
// 首先CSS Modules必须通过向css-loader传入modules: true来开启：
{
  module: {
    rules: [
      {
        test: /\.css$/,
        use: [
          'vue-style-loader',
          {
            loader: 'css-loader',
            options: {
              modules: true,                             // 开启CSS Modules
              localIdentName: '[local]_[hash:base64:8]'  // 自定义生成的类名
            }
          }
        ]
      }
    ]
  }
}

// 然后在style上添加module特性：
< style module>
.red {
  color: red;
}
.bold {
  font-weight: bold;
}
< /style>

// 这个module特性指引vue-loader作为名为$style的计算属性,向组件注入CSS Modules局部对象,然后就可以在模板中通过一个动态类绑定来使用它了
< template>
  <p :class="$style.red"> This should be red </p>
< /template>

// 因为这是一个计算属性,所以它也支持:class的对象/数组语法：
< template>
  <div>
    <p :class="{ [$style.red]: isRed }"> Am I red? </p>
    <p :class="[$style.red, $style.bold]"> Red and bold </p>
  </div>
< /template>

// 也可以通过js访问到它
< script>
export default {
  created () {
    console.log(this.$style.red)   // "red_1VyoJ-uZ",一个基于文件名和类名生成的标识符
  }
}
< /script>

</pre>如果只想在某些Vue组件中使用CSS Modules,可以使用oneOf规则并在resourceQuery字符串中检查module字符串<pre class="js">
{
  test: /\.css$/,
  oneOf: [
    // 这里匹配< style module>
    {
      resourceQuery: /module/,
      use: [
        'vue-style-loader',
        {
          loader: 'css-loader',
          options: {
            modules: true,
            localIdentName: '[local]_[hash:base64:5]'
          }
        }
      ]
    },
    // 这里匹配普通的< style>或< style scoped>
    {
      use: [
        'vue-style-loader',
        'css-loader'
      ]
    }
  ]
}

</pre>CSS Modules可以与其它预处理器一起配合使用<pre class="js">
{
  test: /\.scss$/,
  use: [
    'vue-style-loader',
    {
      loader: 'css-loader',
      options: { modules: true }
    },
    'sass-loader'
  ]
}

</pre>自定义的注入名称: 在.vue中可定义多个style,为了避免被覆盖,可通过设置module属性来为它们定义注入后计算属性的名称<pre class="js">

< style module="a">
  /* 注入标识符 a */
< /style>

< style module="b">
  /* 注入标识符 b */
< /style>

</pre><pre>
【 热重载 】
热重载不只是当修改文件的时候简单重新加载页面。启用热重载后当修改.vue文件时,该组件的所有实例将在不刷新页面的情况下被替换,它甚至保持了应用程序和被替换组件的当前状态,当你调整模版或者修改样式时,这极大地提高了开发体验

状态保留规则
当编辑一个组件的template时,这个组件实例将就地重新渲染,并保留当前所有的私有状态,能够做到这一点是因为模板被编译成了新的无副作用的渲染函数。
当编辑一个组件的script时,这个组件实例将就地销毁并重新创建。(应用中其它组件的状态将会被保留) 是因为script可能包含带有副作用的生命周期钩子,所以将重新渲染替换为重新加载是必须的,这样做可以确保组件行为的一致性。这也意味着,如果组件带有全局副作用,则整个页面将会被重新加载。
style标签会通过vue-style-loader自行热重载,所以它不会影响应用的状态

用法
当使用脚手架工具vue-cli时热重载是开箱即用的。
当手动设置工程时热重载会在启动webpack-dev-server --hot服务时自动开启。

关闭热重载
热重载默认是开启的,除非遇到以下情况：
1、webpack的target的值是node(服务端渲染)
2、webpack会压缩代码
3、process.env.NODE_ENV === 'production'

</pre>可以设置hotReload: false选项来显式地关闭热重载<pre class="js">

module: {
  rules: [
    {
      test: /\.vue$/,
      loader: 'vue-loader',
      options: {
        hotReload: false // 关闭热重载
      }
    }
  ]
}

</pre><pre>
【 函数式组件 】
在一个 *.vue 文件中以单文件形式定义的函数式组件,现在对于模板编译、scoped CSS和热重载也有了良好的支持。

要声明一个应该编译为函数式组件的模板,请将functional特性添加到模板块中。这样做以后就可以省略script块中的functional选项。

模板中的表达式会在函数式渲染上下文中求值,这意味着在模板中prop需要以props.xxx的形式访问：

</pre><pre class="js">
< template functional>
  <div>{{ props.foo }}</div>
< /template>

// 可以在parent上访问Vue.prototype全局定义的属性：
< template functional>
  <div>{{ parent.$someProperty }}</div>
< /template>

</pre><pre>
【 自定义块 】
在.vue文件中可以自定义语言块。应用于一个自定义块的loader是基于这个块的lang特性、块的标签名以及webpack配置进行匹配的。
如果指定了一个lang特性,则这个自定义块将会作为一个带有该lang扩展名的文件进行匹配。
也可以使用resourceQuery来为一个没有lang的自定义块匹配一条规则

</pre>匹配自定义块foo<pre class="js">
{
  module: {
    rules: [
      {
        resourceQuery: /blockType=foo/,
        loader: 'loader-to-use'
      }
    ]
  }
}

</pre><pre>
如果找到了一个自定义块的匹配规则,它将会被处理,否则该自定义块会被默默忽略。

此外,如果这个自定义块被所有匹配的loader处理之后导出一个函数作为最终结果,则这个*.vue文件的组件会作为一个参数被这个函数调用。

</pre>向组件内注入< docs>自定义块,且它是在运行时可用的<pre class="js">
// 为了注入自定义块的内容,撰写一个自定义loader
module.exports = function (source, map) {
  this.callback(
    null,
    `export default function (Component) {
      Component.options.__docs = ${ JSON.stringify(source) }
    }`,
    map
  )
}

// 配置webpack来使用为docs自定义块撰写的自定义loader
module.exports = {
  module: {
    rules: [
      {
        resourceQuery: /blockType=docs/,
        loader: require.resolve('./docs-loader.js')
      }
    ]
  }
}

// 在运行时访问被导入组件的docs块内容
<!-- ComponentB.vue -->
< template>
  <div>Hello</div>
< /template>

< docs>
This is the documentation for component B.
< /docs>

<!-- ComponentA.vue -->
< template>
  <div>
    < ComponentB/>
    <p>{{ docs }}</p>
  </div>
< /template>

< script>
import ComponentB from './ComponentB.vue';

export default {
  components: { ComponentB },
  data () {
    return {
      docs: ComponentB.__docs
    }
  }
}
< /script>

</pre><pre>
【 CSS提取 】
请只在生产环境下使用CSS提取,这将便于你在开发环境下进行热重载。

</pre><pre class="js">
npm install -D mini-css-extract-plugin

var MiniCssExtractPlugin = require('mini-css-extract-plugin')

module.exports = {
  module: {
    rules: [
      {
        test: /\.css$/,
        use: [
          process.env.NODE_ENV !== 'production' ? 'vue-style-loader' : MiniCssExtractPlugin.loader,
          'css-loader'
        ]
      }
    ]
  },
  plugins: [
    new MiniCssExtractPlugin({
      filename: 'style.css'
    })
  ]
}

</pre><pre>
【 代码校验(Linting) 】
官方的eslint-plugin-vue同时支持在Vue单文件组件的模板和脚本部分的代码校验。

请确认在ESLint配置文件中使用该插件要导入的配置：

</pre><pre class="js">
// .eslintrc.js
module.exports = {
  extends: [
    "plugin:vue/essential"
  ]
}

</pre><pre>
接下来从命令行运行：
eslint --ext js,vue MyComponent.vue

另一个选项是使用eslint-loader那么*.vue文件在开发过程中每次保存的时候就会自动进行代码校验：
npm install -D eslint eslint-loader

</pre>请确保它是作为一个pre-loader运用的<pre class="js">
module.exports = {
  // ... 其它选项
  module: {
    rules: [
      {
        enforce: 'pre',
        test: /\.(js|vue)$/,
        loader: 'eslint-loader',
        exclude: /node_modules/
      }
    ]
  }
}

</pre><pre>
stylelint
stylelint支持在Vue单文件组件的样式部分的代码校验

请确认在stylelint配置文件正确。
接下来从命令行运行：
stylelint MyComponent.vue

另一个选项是使用 stylelint-webpack-plugin:
npm install -D stylelint-webpack-plugin
请确保它是作为一个插件运用的

</pre><pre class="js">
const StyleLintPlugin = require('stylelint-webpack-plugin');
module.exports = {
  plugins: [
    new StyleLintPlugin({
      files: ['**/*.{vue,htm,html,css,sss,less,scss,sass}'],
    })
  ]
}

</pre>
</div>

<div id="webpack_plugins">
<h3>插件(plugins)</h3><pre>
插件是webpack的支柱功能,webpack自身也是构建于在webpack配置中用到的相同的插件系统之上
loaders是在打包构建过程中用来处理源文件的,一次处理一个,插件并不直接操作单个文件,它直接对整个构建过程其作用
插件目的在于解决loader无法实现的其他事,loader被用于转换某些类型的模块,而插件则可以用于执行范围更广的任务。插件的范围包括从打包优化和压缩一直到重新定义环境中的变量。插件接口功能极其强大,可以用来处理各种各样的任务。

plugin和loader的区别:
loader是在import时根据不同的文件名,匹配不同的loader对这个文件做处理,
plugin关注的不是文件的格式,而是在编译的各个阶段会触发不同的事件,让你可以干预每个编译阶段。

plugins选项用于以各种方式自定义webpack构建过程。webpack提供许多开箱可用的插件,webpack附带了各种内置插件,可以通过webpack.[plugin-name]访问这些插件

webpack插件是一个具有apply属性的JS对象,apply属性会被webpack compiler调用,并且compiler对象可在整个编译生命周期访问

想要使用一个插件只需要require()它,然后把它添加到plugins数组中。多数插件可以通过选项(option)自定义,也可以在一个配置文件中因为不同目的而多次使用同一个插件,这时需要通过使用new操作符来创建它的一个实例。

由于插件可以携带参数/选项,必须在webpack配置中向plugins属性传入new实例

plugins
array,webpack插件列表。例如当多个bundle共享一些相同的依赖,CommonsChunkPlugin有助于提取这些依赖到共享的bundle中来避免重复打包。可以像这样添加：

</pre><pre class="js">
plugins: [
  new webpack.optimize.CommonsChunkPlugin({
    ...
  })
]

</pre>webpack.config.js<pre class="js">
// 导入非webpack自带默认插件
var DashboardPlugin = require('webpack-dashboard/plugin');
var ExtractTextPlugin = require('extract-text-webpack-plugin');
const HtmlWebpackPlugin = require('html-webpack-plugin'); // 通过npm安装
const webpack = require('webpack');                       // 用于访问内置插件

const config = {
  entry: './path/to/my/entry/file.js',
  output: {
    filename: 'my-first-webpack.bundle.js',
    path: path.resolve(__dirname, 'dist')
  },
  module: {
    rules: [
      { test: /\.txt$/, use: 'raw-loader' },
      { test: /\.(js|jsx)$/, use: 'babel-loader' }
    ]
  },
  // 在配置中添加插件
  plugins: [
    new webpack.optimize.UglifyJsPlugin(),
    new HtmlWebpackPlugin({template: './src/index.html'}),

    // 构建优化插件
    new webpack.optimize.CommonsChunkPlugin({
      name: 'vendor',
      filename: 'vendor-[hash].min.js',
    }),
    new webpack.optimize.UglifyJsPlugin({
      compress: {
        warnings: false,
        drop_console: false,
      }
    }),
    new ExtractTextPlugin({
      filename: 'build.min.css',
      allChunks: true,
    }),
    new webpack.IgnorePlugin(/^\.\/locale$/, /moment$/),

    // 编译时(compile time)插件
    new webpack.DefinePlugin({
      'process.env.NODE_ENV': '"production"',
    }),

    // webpack-dev-server强化插件
    new DashboardPlugin(),
    new webpack.HotModuleReplacementPlugin(),
  ]
};

module.exports = config;

</pre><pre>
【 webpack自带的插件 】
AggressiveSplittingPlugin: 将原来的chunk分成更小的chunk
BabelMinifyWebpackPlugin: 使用babel-minify进行压缩
BannerPlugin: 在每个生成的chunk顶部添加banner
CommonsChunkPlugin: 提取chunks之间共享的通用模块
CompressionWebpackPlugin: 预先准备的资源压缩版本,使用Content-Encoding提供访问服务
ContextReplacementPlugin: 重写require表达式的推断上下文
CopyWebpackPlugin: 将单个文件或整个目录复制到构建目录
DefinePlugin: 允许在编译时(compile time)配置的全局常量
DllPlugin: 为了极大减少构建时间进行分离打包
EnvironmentPlugin: DefinePluginprocess.env 键的简写方式。
ExtractTextWebpackPlugin: 从bundle中提取文本(CSS)到单独的文件
HotModuleReplacementPlugin: 启用模块热替换(Enable Hot Module Replacement - HMR)
HtmlWebpackPlugin: 简单创建HTML文件,用于服务器访问
I18nWebpackPlugin: 为bundle增加国际化支持
IgnorePlugin: 从bundle中排除某些模块
LimitChunkCountPlugin: 设置chunk的最小/最大限制,以微调和控制chunk
LoaderOptionsPlugin: 用于从webpack 1迁移到webpack 2
MinChunkSizePlugin: 确保chunk大小超过指定限制
NoEmitOnErrorsPlugin: 在输出阶段时遇到编译错误跳过
NormalModuleReplacementPlugin: 替换与正则表达式匹配的资源
NpmInstallWebpackPlugin: 在开发时自动安装缺少的依赖
ProvidePlugin: 不必通过import/require使用模块
SourceMapDevToolPlugin: 对source map进行更细粒度的控制
EvalSourceMapDevToolPlugin: 对eval source map进行更细粒度的控制
UglifyjsWebpackPlugin: 可以控制项目中UglifyJS的版本
ZopfliWebpackPlugin: 通过node-zopfli将资源预先压缩的版本

</pre>
</div>

<div id="BannerPlugin">
<h4>使用内置的BannerPlugin插件</h4><pre>
为每个chunk文件头部添加banner,用于在输出文件头部输出一些注释信息
new webpack.BannerPlugin(banner)
new webpack.BannerPlugin(options)

选项
{
  banner: string,                // 其值为字符串,将作为注释存在
  raw: boolean,                  // 如果值为true将直出不会被作为注释
  entryOnly: boolean,            // 如果值为true将只在入口chunks文件中添加
  test: string | RegExp | Array,
  include: string | RegExp | Array,
  exclude: string | RegExp | Array,
}

占位符(Placeholders)
从webpack 2.5.0开始会对banner字符串中的占位符取值：
new webpack.BannerPlugin({
  banner: "hash:[hash], chunkhash:[chunkhash], name:[name], filebase:[filebase], query:[query], file:[file]"
})

</pre><pre class="js">
const  webpack = require('webpack')

module.exports = {
  entry: './origin.js',
  output: {
    path: __dirname,
    filename: 'newfile.js'
  },
  module: {
    loaders: [{
      test: /\.css$/,
      use: [
        { loader: "style-loader" },
        { loader: "css-loader" }
      ]
    }]
  },
  plugins: [
    new webpack.bannerPlugin('测试webpack实例,版权所有,翻版必究')
  ]
}

</pre>
</div>

<div id="DefinePlugin">
<h4>webpack.DefinePlugin</h4><pre>
The DefinePlugin allows you to create global constants which can be configured at compile time. This can be useful for allowing different behavior between development builds and production builds. If you perform logging in your development build but not in the production build you might use a global constant to determine whether logging takes place. That's where DefinePlugin shines, set it and forget it rules for development and production builds

new webpack.DefinePlugin({
  // Definitions...
});

Usage
Each key passed into DefinePlugin is an identifier or multiple identifiers joined with .

If the value is a string it will be used as a code fragment.
If the value isn't a string, it will be stringified (including functions).
If the value is an object all keys are defined the same way.
If you prefix typeof to the key, it's only defined for typeof calls.
The values will be inlined into the code allowing a minification pass to remove the redundant conditional.

</pre>这里面的标识就相当于全局变量,业务代码可以直接使用配置的标识<pre class="js">
new webpack.DefinePlugin({
  PRODUCTION: JSON.stringify(true),
  VERSION: JSON.stringify('5fa3b9'),
  BROWSER_SUPPORTS_HTML5: true,
  TWO: '1+1',
  'typeof window': JSON.stringify('object'),
  'process.env.NODE_ENV': JSON.stringify(process.env.NODE_ENV)
});

console.log('Running App version ' + VERSION);
if(!BROWSER_SUPPORTS_HTML5) require('html5shiv');

</pre><pre>
W> When defining values for process prefer 'process.env.NODE_ENV': JSON.stringify('production') over process: { env: { NODE_ENV: JSON.stringify('production') } }. Using the latter will overwrite the process object which can break compatibility with some modules that expect other values on the process object to be defined.

T> Note that because the plugin does a direct text replacement, the value given to it must include actual quotes inside of the string itself. Typically, this is done either with alternate quotes, such as '"production"', or by using JSON.stringify('production')

</pre><pre class="js">
// index.js
if (!PRODUCTION) {
  console.log('Debug info');
}
if (PRODUCTION) {
  console.log('Production log');
}

// After passing through webpack with no minification results in:
if (!true) {
  console.log('Debug info');
}
if (true) {
  console.log('Production log');
}

// and then after a minification pass results in:
console.log('Production log');

</pre>Feature Flags: Enable/disable features in production/development build using feature flags<pre class="js">
new webpack.DefinePlugin({
  'NICE_FEATURE': JSON.stringify(true),
  'EXPERIMENTAL_FEATURE': JSON.stringify(false)
});

</pre>Service URLs: Use a different service URL in production/development builds<pre class="js">
new webpack.DefinePlugin({
  'SERVICE_URL': JSON.stringify('https://dev.example.com')
});

</pre><pre class="js">
new webpack.DefinePlugin({
  'process.env': require('../config/dev.env')
})

// dev.env.js
module.exports = {
  NODE_ENV: '"development"',
  ENV_CONFIG: '"dev"',
  BASE_API: '"https://api-dev"'
}

在建立axios的默认service时
const service = axios.create({ 
	baseURL: process.env.BASE_API, // api的base_url,process.env.BASE_API就是运行时的动态全局变量
	imeout: 5000                   // request timeout
})

</pre><pre>
在node中有全局变量process表示的是当前的node进程,process.env包含着关于系统环境的信息,但process.env中并不存在NODE_ENV属性,NODE_ENV是用户一个自定义的变量,在webpack中它的用途是判断生产环境或开发环境的依据的

许多library通过与process.env.NODE_ENV环境变量关联以决定library中应该引用哪些内容,当不处于生产环境中时某些library为了使调试变得容易可能会添加额外的日志记录(log)和测试(test)。其实当使用process.env.NODE_ENV === 'production'时一些library可能针对具体用户的环境进行代码优化,从而删除或添加一些重要代码。可以使用webpack内置的DefinePlugin为所有的依赖定义这个变量：

plugins: [
  new webpack.DefinePlugin({ 'process.env.NODE_ENV': JSON.stringify('production') })
]

NODE_ENV是一个由Node.js暴露给执行脚本的系统环境变量,通常用于决定在开发环境与生产环境下服务器工具、构建脚本和客户端library的行为
然而与预期不同的是无法在构建脚本webpack.config.js中将process.env.NODE_ENV设置为"production",因此例如process.env.NODE_ENV === 'production' ? '[name].[hash].bundle.js' : '[name].bundle.js' 这样的条件语句在webpack配置文件中无法按照预期运行。

如果使用像react这样的library,那么在添加此DefinePlugin插件后,应该看到bundle大小显著下降
任何位于/src的本地代码都可以关联到process.env.NODE_ENV环境变量,所以入口文件中进行以下检查也是有效的：
if(process.env.NODE_ENV !== 'production') console.log('Looks like we are in development mode!');

</pre><pre class="js">
module.exports = {
  plugins: [
    // 设置环境变量信息
    new webpack.DefinePlugin({
      PRODUCTION: JSON.stringify(true),
      VERSION: JSON.stringify('5fa3b9'),
      BROWSER_SUPPORTS_HTML5: true,
      TWO: '1+1',
      'typeof window': JSON.stringify('object'),
      'process.env': {
        NODE_ENV: JSON.stringify(process.env.NODE_ENV)
      }
    })
  ]
}

package.json打包配置如下命令：
"scripts": {
  "dev": "webpack-dev-server --progress --colors --devtool cheap-module-eval-source-map --hot --inline",
  "build": "webpack --progress --colors --devtool cheap-module-source-map",
  "build:dll": "webpack --config webpack.dll.config.js"
},

这样配置完成后,为了验证一下是否是全局变量,运行npm run dev打包后可以在项目中入口js文件
console.log('Running App version ' + VERSION); // Running App version 5fa3b9
console.log(PRODUCTION);                       // true
console.log(process.env);                      // { NODE_ENV: undefined }

process.env.NODE_ENV打印undefined,那是因为在package.json文件中未进行配置。下面把package.json加上NODE_ENV变量值
"scripts": {
  "dev": "NODE_ENV=development webpack-dev-server --progress --colors --devtool cheap-module-eval-source-map --hot --inline",
  "build": "NODE_ENV=production webpack --progress --colors --devtool cheap-module-source-map",
  "build:dll": "webpack --config webpack.dll.config.js"
},

在dev打包命令上前面加上了NODE_ENV=development命令,在build打包命令上前面加上NODE_ENV=production
console.log('Running App version ' + VERSION); // Running App version 5fa3b9
console.log(PRODUCTION);                       // true
console.log(process.env);                      // { NODE_ENV: 'development' }

可以看到这个时候process.env.NODE_ENV才有值,因此在项目打包中为了区分开发环境和正式环境像如上配置即可,然后在webpack.config.js中通过process.env.NODE_ENV这个来区分正式环境还是开发环境即可

</pre><pre>
windows环境配置如下：
#node中常用的到的环境变量是NODE_ENV,首先查看是否存在
set NODE_ENV
#如果不存在则添加环境变量
set NODE_ENV=production
#环境变量追加值 set 变量名=%变量名%;变量内容
set path=%path%;C:\web;C:\Tools
#某些时候需要删除环境变量
set NODE_ENV=

Linux配置(mac系统环境也属于这个)
#node中常用的到的环境变量是NODE_ENV,首先查看是否存在
echo $NODE_ENV
#如果不存在则添加环境变量
export NODE_ENV=production
#环境变量追加值
export path=$path:/home/download:/usr/local/
#某些时候需要删除环境变量
unset NODE_ENV
#某些时候需要显示所有的环境变量
env

如果在命令行中设置环境变量后,比如通过export NODE_ENV=production设置production后在所有的项目下都是正式环境,当使用命令npm install后下载依赖包时只会把package.json中的dependencies依赖项下载下来,对于devDependencies中的依赖包是下载不下来的。
因此需要使用上面的命令unset NODE_ENV删除刚刚设置的环境变量

cross-env是运行跨平台设置和使用环境变量的脚本。
当使用NODE_ENV = production来设置环境变量时,大多数windows命令会提示将会阻塞或异常,或者windows不支持NODE_ENV=development的这样的设置方式会报错。因此cross-env出现了,可以使用cross-env命令这样就不必担心平台设置或使用环境变量了,也就是说cross-env能够提供一个设置环境变量的scripts,这样就能够以unix方式设置环境变量,然而在windows上也能够兼容的。

安装命令
npm install --save-dev cross-env

package.json中配置scripts
"scripts": {
  "dev": "cross-env NODE_ENV=development webpack-dev-server --progress --colors --devtool cheap-module-eval-source-map --hot --inline",
  "build": "cross-env NODE_ENV=production webpack --progress --colors --devtool cheap-module-source-map",
  "build:dll": "webpack --config webpack.dll.config.js"
}

</pre>
</div>

<div id="cleanWebpackPlugin">
<h4>clean-webpack-plugin</h4><pre>
cnpm install clean-webpack-plugin --save-dev
A webpack plugin to remove your build folder(s) before building
webpack会生成文件,然后将这些文件放置在/dist文件夹中,但webpack无法追踪到哪些文件是实际在项目中用到的,由于之前的构建遗留下来,导致的/dist文件夹相当杂乱。通常在每次构建前使用clean-webpack-plugin插件清理/dist文件夹是比较推荐的做法,因此只会生成用到的文件

All files inside webpack's output.path directory will be removed once, but the directory itself will not be.
If using webpack 4+'s default configuration, everything under < PROJECT_DIR>/dist/ will be removed. Use cleanOnceBeforeBuildPatterns to override this behavior.
During rebuilds, all webpack assets that are not used anymore will be removed automatically.

</pre><pre class="js">
const path = require('path');
const { CleanWebpackPlugin } = require('clean-webpack-plugin');
const HtmlWebpackPlugin = require('html-webpack-plugin');

module.exports = {
  entry: './src/index.js',
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: 'bundle.js'
  },
  module: {
    rules: [
      {
        test: /\.css$/,
        use: [ 'style-loader', 'css-loader'
      }
    ]
  },
  plugins: [
    new CleanWebpackPlugin(),
    new HtmlWebpackPlugin(),
  ],
};

</pre>
</div>

<div id="htmlWebpackPlugin">
<h4>html-webpack-plugin</h4><pre>
cnpm install html-webpack-plugin --save-dev

webpack中的html文件
对于浏览器而言html文件是用户访问的入口点,也是所有资源的挂载点,所有资源都是通过html中的标记来进行引用的。而在webpack的构建世界里,html只是一个展示板,而entry参数中指定的js入口文件才是真正在构建过程中管理和调度资源的挂载点,html文件中最终展示的内容都是webpack在加工并为所有资源打好标记以后传递给它的,业界将这种有别与浏览器的模式称之为"webpack的逆向注入"。

html文件基本处理需求
前端项目可以大致分为单页面应用和多页面应用,现代化组件中的html文件主要作为访问入口文件,是style样式标签和script脚本标签的挂载点,打包中需要解决的基本问题包括：
个性化内容填充(例如页面标题、描述、关键词)
多余空格删除(连续多个空白字符的合并)
代码压缩(多余空白字符的合并)
去除注释

html-webpack-plugin用来打包入口html文件
entry配置的入口是js文件,webpack以js文件为入口,遇到import,用配置的loader加载引入文件

但作为浏览器打开的入口html,是引用入口js的文件,它在整个编译过程的外面,所以需要html-webpack-plugin来打包作为入口的html文件
html-webpack-plugin插件的作用是依据一个简单的index.html模板,所有的bundle会自动添加到output.path目录下新index.html中,这在每次生成的js文件名称不同时非常有用,比如添加了hash值
如果在dist/文件夹已经有index.html文件,HtmlWebpackPlugin还是会默认生成index.html文件,即它会用新生成的index.html文件把原来的替换,将输出的bundle写入对应位置的标签(如js文件对应的script标签插入body闭合标签之前),其他内容不变

如果有多个webpack入口点,他们都会在生成的HTML文件中的script标签内。
如果有任何CSS assets在webpack的输出中,例如利用ExtractTextPlugin提取CSS,那么这些将被包含在HTML head中的link标签内。

</pre><pre class="js">
var HtmlWebpackPlugin = require('html-webpack-plugin');
var path = require('path');
var webpackConfig = {
  entry: 'index.js',
  output: {
    path: path.resolve(__dirname, './dist'),
    filename: 'index_bundle.js'
  },
  plugins: [new HtmlWebpackPlugin()]  // 构造函数中传入参数{ title: 'newtitle' }时生成的html文件中title替换为"newtitle"
};
module.exports = webpackConfig

// 这将会产生一个包含以下内容的文件dist/index.html：
< !DOCTYPE html>
< html>
  < head>
    < meta charset="UTF-8">
    < title>webpack App< /title>
  < /head>
  < body>
    < script src="index_bundle.js">< /script>
  < /body>
< /html>

</pre><pre class="js">
{
  entry: 'index.js',
  output: {
    path: __dirname + '/dist',
    filename: 'index_bundle.js'
  },
  plugins: [
    new HtmlWebpackPlugin({
      title: 'My App',
      filename: 'assets/admin.html'
    })
  ]
}

</pre>Generating Multiple HTML Files<pre class="js">
{
  entry: 'index.js',
  output: {
    path: __dirname + '/dist',
    filename: 'index_bundle.js'
  },
  plugins: [
    new HtmlWebpackPlugin(), // Generates default index.html
    new HtmlWebpackPlugin({  // Also generate a test.html
      filename: 'test.html',
      template: 'src/assets/test.html'
    })
  ]
}

</pre><pre>
配置选项
在app目录下创建一个index.tmpl.html文件模板,这个模板包含title等必须元素,在编译过程中插件会依据此模板生成最终的html页面,自动添加所依赖的css,、js、favicon等文件

title {String}
设置生成的html文件的标题,如果在模板文件指定了title会忽略该属性

filename {String}
生成html文件的文件名,默认为index.html,可以直接配置带有子目录
filename的路径是相对于output.path的,而在webpack-dev-server中则是相对于webpack-dev-server配置的publicPath
如果webpack-dev-server的publicPath和output.publicPath不一致,在使用html-webpack-plugin可能会导致引用静态资源失败,因为在devServer中仍然以output.publicPath引用静态资源,和webpack-dev-server的提供的资源访问路径不一致,从而无法正常访问。
有一种情况除外,就是output.publicPath是相对路径,这时候可以访问本地资源
所以一般情况下都要保证devServer中的publicPath与output.publicPath保持一致

template {String}
根据自定义的模板文件来生成特定的html文件,模板类型可以是html、jade、ejs、hbs等,使用自定义的模板文件时需要提前安装对应的loader,否则webpack不能正确解析
template参数指定入口html文件路径,插件会把这个文件交给webpack去编译,webpack按照正常流程,找到loaders中test条件匹配的loader(如html-loader)来编译,html-loader编译后产生的字符串会由html-webpack-plugin储存为html文件到输出目录,默认文件名为index.html,可以通过filename参数指定输出的文件名
html-webpack-plugin也可以不指定template参数,它会使用默认的html模板。

template只有定义在webpack的context下才会被识别,webpack context的默认值为process.cwd(),即运行node命令时所在的文件夹的绝对路径

</pre><pre class="js">
< !DOCTYPE html>
< html lang="en">
  < head>
    < meta charset="utf-8">
    < title><%= htmlWebpackPlugin.options.title %>< /title>
  < /head>
  < body>
  < /body>
< /html>

const HtmlWebpackPlugin = require('html-webpack-plugin');
new HtmlWebpackPlugin({ template: __dirname + "/app/index.tmpl.html" })

</pre><pre>
templateParameters  {Boolean|Object|Function}
默认空字符串,Allows to overwrite the parameters used in the template

inject
注入选项,有四个选项值true、'body'、'head'、false
true: 默认值,script标签位于html文件的body底部
'body': 同true
'head': script标签位于head标签内
false: 不插入生成的js文件,只是单纯的生成一个html文件

favicon {String}
给生成的html文件生成一个favicon,属性值为favicon文件所在的路径名
favicon: './favicon.ico'  // favicon.ico放置到根目录

meta  {Object}  默认{}
Allows to inject meta-tags. E.g. meta: {viewport: 'width=device-width, initial-scale=1, shrink-to-fit=no'}

base  {Object|String|false} 默认false
Inject a base tag. E.g. base: "https://example.com/path/page.html

minify {Boolean|Object}
对html文件进行压缩,minify的属性值是一个压缩选项或默认值false即不对生成的html文件进行压缩

hash {Boolean}
给生成的js文件一个独特的hash值,该hash值是该次webpack编译的hash值,默认值为false

cache  {Boolean}
默认true表示只有在内容变化时才生成一个新的文件

showErrors  {Boolean}
如果webpack编译出现错误,webpack会将错误信息包裹在一个pre标签内,属性的默认值为true即显示错误信息

chunks
针对多入口(entry)文件,当有多个入口文件时对应就会生成多个编译后的js文件,chunks选项就可以决定是否都使用这些生成的js文件。
chunks默认会在生成的html文件中引用所有的js文件,当然也可以指定引入哪些特定的文件

</pre><pre class="js">
entry: {
  index: path.resolve(__dirname, './src/index.js'),
  index1: path.resolve(__dirname, './src/index1.js'),
  index2: path.resolve(__dirname, './src/index2.js')
},plugins: [
  new HtmlWebpackPlugin({
    chunks: ['index','index2']
  })
]

</pre><pre>
excludeChunks {Array.< string>}
跟chunks是相反的,排除掉某些js文件
excludeChunks: ['index1.js']

</pre><pre class="js">
plugins: [
  new HtmlWebpackPlugin({
    excludeChunks: [ 'dev-helper' ]
  })
]

</pre><pre>
chunksSortMode {String|Function}
指定script标签的引用顺序,有四个选项：'none', 'auto', 'dependency', '{function}'。
'dependency' 按照不同文件的依赖关系来排序
'auto' 默认值,插件的内置的排序方式
{function} 提供一个函数

Error:Cyclic dependency,问题是因为HtmlWebpackPlugin中的toposort库出现的错误
因为和webpack4的兼容性问题,chunksSortMode参数需要设置为'none',如果设置为none页面加载顺序就不能保证了,可以通过升级html-webpack0plugin来解决"html-webpack-plugin": "4.0.0-alpha",npm i --save-dev html-webpack-plugin@next

xhtml  {Boolean}
一个布尔值,默认值是false,如果为true则以兼容xhtml的模式引用文件

入口html文件的处理
1、单页面应用打包
对于入口html文件的处理直接使用html-webpack-plugin插件来设置一定的配置参数即可

</pre><pre class="js">
// webpack.config.js
const HtmlWebpackPlugin = requrie('html-webpack-plugin')
module.exports = {
  mode: 'development',
  entry: __dirname + 'index.js';
  ouput: {
    filename: "[name].bundle.js",
    path: __dirname + 'build'
  },
  plugins: [
    new HtmlWebpackPlugin({
      title: 'test',
      template: 'index.html',
      templateParameters: { param1: 'tony stark', param2: 'bruce banner' },
      minify: {
        removeComments: true,              // 移出注释
        collapseWhitespace: true,          // 压缩html中空白的文本节点
        collapseInlineTagWhitespace: true  // 压缩行级元素的空白,保留& nbsp ;实体空格
      }
    })
  ]
}

// index.html模板文件,构建生成的入口页面是以此为模板的
< !DOCTYPE html>
< html lang="en">
  < head>
    < meta charset="utf-8">
    < title>Document< /title>
  < /head>
  < body>
    < div>
      < !-- 这里有一行注释 -->
      <p><%= param1 %></p>
      <p><%= param2 %>&nbsp ;</p>
    < /div>
  < /body>
< /html>

// 打包后生成的index.html:
< !DOCTYPE html>< html lang="en">< head>< meta charset="UTF-8">< title>Document< /title>< /head>< body>< div><p>tony stark</p><p>bruce banner </p>< /div>< script type="text/javascript" src="main.boundle.js">< /script>< /body>< /html>

</pre><pre>
2、多页面应用打包
如果项目中有多个页面,那么打包的时候需要考虑两个基本问题：
1.如何自动生成多个页面？
2.如果引用中存在公共的模块,怎样才能提取公共模块？

项目结构：
index.html -> indexController.js -> eventbus.js + underscore.js
about.html -> aboutController.js -> eventbus.js
list.html -> listController.js

多页面应用的基本结构理解起来并不复杂,可以将其看做是多个单页面应用的组合,在webpack中需要进行一些配置调整

</pre><pre class="js">
// entry参数需要配置多个依赖入口文件
entry:{
  "main":__dirname + "/src/indexController.js",
  "about":__dirname + "/src/aboutController.js",
  "list":__dirname + "/src/listController.js",
},

// html文件则需要分别引用对应的入口文件并生成对应的访问入口,在生成html文件时已经为其单独引用了chunks数组中指定的模块,这使得对应的页面生成时只依赖自己需要的脚本
plugins:[
    //index.html
    new HtmlWebpackPlugin({
        title:'MainPage',
        template:'src/index.html',
        filename:'index.html',
        templateParameters:{
            param1:'tony stark',
            param2:'bruce banner'
        },
        chunks:['main'],
   }),
    //about.html
    new HtmlWebpackPlugin({
        title:'AboutPage',
        template:'src/about.html',
        filename:'about.html',
        templateParameters:{
            param1:'tony stark',
            param2:'bruce banner'
        },
        chunks:['about'],
   }),
   //list.html
   new HtmlWebpackPlugin({
        title:'ListPage',
        template:'src/list.html',
        filename:'list.html',
        templateParameters:{
            param1:'tony stark',
            param2:'bruce banner'
        },
        chunks:['list'],
   }),
],

</pre><pre>
关于公共模块提取
从得到的打包后的模块中很容易看出它存在重复打包的问题,eventbus.js这个公共库被indexController.js和aboutController.js中均被引用,但在不同的chunks中被重复打包,当公共部分的体积较大时这样的方式明显是不能接受的。实际上分包问题并不是多页面应用中才存在的,而且是非常复杂的,它不仅要考虑公共模块本身的大小,模块之间的引用关系,还需要考虑同步引用和异步引用等等非常多的问题
webpack4.0以上的版本使用optimization.splitChunks和optimization.runtimeChunk来解决优化chunk拆分的问题

</pre><pre class="js">
const webpack = require('webpack');
const path = require('path');
const ExtractTextPlugin = require('extract-text-webpack-plugin');
const HtmlWebpackPlugin = require('html-webpack-plugin');
const CleanWebpackPlugin = require('clean-webpack-plugin');
const glob = require('glob');
const OpenBrowserPlugin = require('open-browser-webpack-plugin');
const progressbarWebpack = require('progress-bar-webpack-plugin');

var prod = process.env.NODE_ENV === 'production' ? true : false;

let hostName = "127.0.0.1";   //可以设置自己电脑IP或者其他,如"192.168.1.83"
let devPort = "8888";

function resolve(dir) {
  return path.join(__dirname, dir)
}

function getEntry() {
  var entry = {};
  glob.sync('./src/APPpages/**/*.js').forEach(name => {  //读取开发目录,并进行路径裁剪
    var start = name.indexOf('src/') + 4,
        end = name.length - 3;
    var eArr = [];
    var n = name.slice(start, end);
    n = n.slice(0, n.lastIndexOf('/'));                  //保存各个组件的入口
    n = n.split('/')[1];
    eArr.push(name);
    entry[n] = eArr;
  });
  return entry;
};

function getHtmlPlugin(name) {
  return new HtmlWebpackPlugin({
    filename: 'views/' + name + '.html',
    template: './src/APPcommon/view/index.html',
    favicon: resolve('../src/APPcommon/img/fav.png'),
    inject: 'body',
    chunks: ['vendors', name],
    minify: {
      removeAttributeQuotes: true,
      collapseWhitespace: true
    }
  })
}

let entryObj = getEntry();
let pageNameList = Object.keys(entryObj);
let proHtmlPlugin = [];
for (let i = 0; i < pageNameList.length; i++) {
  proHtmlPlugin.push(getHtmlPlugin(pageNameList[i]))
}

module.exports = {
  entry: entryObj,
  output: {
    path: resolve('./dist'),                   //输出目录的配置,js,css,img,html等存放目录
    publicPath: prod ? '../' : '/dist/',       //js,css,img等资源对应的server目录
    filename: 'js/[name].js',                  //每个子页面所对应的专用js
    chunkFilename: 'js/common/[id].chunk.js'   //按需加载js命名
  },
  resolve: {
    alias: {
      'vue': 'vue/dist/vue.js',
      'common':resolve('./src/APPcommon')
    }
  },
  devtool: "cheap-module-source-map",
  module: {
    rules: [
      {
        test: /\.vue$/,
        loader: 'vue-loader',
        options: {
          transformToRequire: {
            video: 'src',
            source: 'src',
            img: 'src',
            image: 'xlink:href'
          }
        }
      },{
        test: /\.html$/,
        loader: 'html-loader?attrs=img:src img:data-src'
      },{
        test: /\.js$/,
        loader: 'babel-loader',
        enforce: 'pre',
        include: resolve('src'),
        exclude: ['node_modules/'],
      },{
        test: /\.scss$/,
        use: ExtractTextPlugin.extract({
          fallback: 'style-loader',
          use: ['css-loader','postcss-loader', 'sass-loader']
        })
      },{
        test: /\.css$/,
        use: ExtractTextPlugin.extract({
          fallback: 'style-loader',
          use: ['css-loader','postcss-loader']
        })
      },{
        test: /\.(png|jpeg|jpg|gif|svg)(\?.*)?$/,
        loader: 'url-loader',
        options: {
          limit: 5000,
          name: './img/[name].[ext]',
        }
      },{
        test: /\.(mp4|webm|ogg|mp3|wav|flac|aac)(\?.*)?$/,
        loader: 'url-loader',
        options: {
          limit: 10000,
          name: '/YDW_res/media/[name].[ext]'
        }
      },{
        test: /\.(woff2?|eot|ttf|otf)(\?.*)?$/,
        loader: 'url-loader',
        options: {
          limit: 10000,
          name: '/YDW_res/fonts/[name].[ext]'
        }
      }
    ]
  },
  plugins: [
    new webpack.optimize.CommonsChunkPlugin({
      name: 'vendors',                     //公共模块提取,什么名为vendors的js
      minChunks: Infinity,
      chunks: ['home', 'list', 'about'],   //提取哪些模块共有的部分
      minChunks: pageNameList.length,      //至少三个模块共有部分,才会进行提取
      publicPath:'./dist/static'
    }),
    new ExtractTextPlugin({
      filename: 'css/[name].css',
      allChunks: true,
    }),
    new OpenBrowserPlugin({
      url: 'http://' + hostName + ':' + devPort + '/dist/views/test.html',//测试页面选择test.html,可以自己更改
    }),
    new webpack.HotModuleReplacementPlugin(),   //热替换
    new progressbarWebpack()
  ],

  devServer: {
    contentBase: path.join(__dirname, "dist"),
    compress: true,
    port: devPort,
    host: hostName,
    inline: true,
    hot: true,
    noInfo: true,
    historyApiFallback: true,
  },
  performance: {
    hints: false
  },
};

module.exports.plugins = (module.exports.plugins || []).concat(proHtmlPlugin);

if (prod) {
  module.exports.devtool = 'source-map'
  module.exports.plugins = (module.exports.plugins || []).concat([
    new CleanWebpackPlugin('./dist'),
    new webpack.optimize.UglifyJsPlugin({
      sourceMap: true,
      compress: { warnings: false }
    }),
    new webpack.LoaderOptionsPlugin({ minimize: true })
  ])
};


</pre>
</div>

<div id="miniCssExtractPlugin">
<h4>extract-text-webpack-plugin</h4><pre>
npm install extract-text-webpack-plugin --save-dev  npm提示该插件已弃用,使用mini-css-extract-plugin替代
该插件的主要是为了抽离css样式,防止将样式打包在js中引起页面样式加载错乱的现象

</pre><pre class="js">
const ExtractTextPlugin = require("extract-text-webpack-plugin");

module.exports = {
  module: {
    rules: [
      {
        test: /\.css$/,
        use: ExtractTextPlugin.extract({
          fallback: "style-loader",        // 编译后用什么loader来提取css文件
          use: "css-loader",               // 指需要什么样的loader去编译文件,这里由于源文件是.css所以选择css-loader
          // publicfile:用来覆盖项目路径,生成该css文件的文件路径
        })
      }
    ]
  },
  plugins: [
    new ExtractTextPlugin("styles.css"),
  ]
}

</pre><pre>
将所有的入口chunk(entry chunks)中引用的*.css移动到独立分离的CSS文件,因此样式将不再内嵌到JS bundle中,而是会放到一个单独的CSS文件即styles.css当中。 如果样式文件大小较大,这会做更快提前加载,因为CSS bundle会跟JS bundle并行加载

优点 vs 缺点
更少style标签,旧版本的IE浏览器有限制 vs 额外的HTTP请求
CSS SourceMap,使用devtool:"source-map"和extract-text-webpack-plugin?sourceMap配置 vs 更长的编译时间
CSS请求并行 vs 没有运行时(runtime)的公共路径修改
CSS单独缓存 vs 没有热替换
更快的浏览器运行时(runtime),更少代码和DOM操作 vs ...

插件配置选项
new ExtractTextPlugin(options: filename | object)

id {String}
此插件实例的唯一ident,仅限高级用途,默认情况下自动生成

filename {String|Function}
生成文件的文件名,可能包含[name]、[id] and [contenthash]
[name] chunk的名称
[id] chunk的数量
[contenthash] 根据提取文件的内容生成的hash
[< hashType>:contenthash:< digestType>:< length>] optionally you can configure
other hashTypes, e.g. sha1, md5, sha256, sha512
other digestTypes, e.g. hex, base26, base32, base36, base49, base52, base58, base62, base64
and length, the length of the hash in chars
ExtractTextPlugin对每个入口chunk都生成一个对应的文件,所以配置多个入口chunk时必须使用[name],[id]或[contenthash]

allChunks {Boolean}
从所有额外的chunk(additional chunk)提取,默认情况下仅从初始chunk(initial chunk)中提取
当使用CommonsChunkPlugin并且在公共chunk中有提取的chunk(来自ExtractTextPlugin.extract)时allChunks必须设置为true

disable {Boolean}
禁用插件

ignoreOrder {Boolean}
禁用顺序检查,这对CSS模块很有用,默认false

</pre>假设项目中有css和less两种样式文件,希望可以把这两种样式文件分别打包<pre class="js">
var ExtractTextPlugin = require('extract-text-webpack-plugin');
module.exports = {
  entry: __dirname + '/src/main.js',
  output: {
    path: __dirname + '/output',
    filename: 'main.js'
  },
  module: {
    rules: [
      {
        test: /\.css/,
        use: extractCss.extract({
          fallback: 'style-loader',
          use: [ 'css-loader', 'autoprefixer-loader' ]
        })
      },
      {
        test: /\.less$/i,
        use: extractLess.extract({
          fallback: 'style-loader',
          use: ['css-loader','less-loader']
        })
      },
      {
        test: /\.jpeg$/,
        use: 'url-loader?limit=1024&name=[path][name].[ext]&outputPath=img/&publicPath=./',
      },
    ]
  },
  plugins: [  // 生成两个实例,参数是生成文件的相对路径
    new ExtractTextPlugin('[name]-one.css'),
    new ExtractTextPlugin('[name]-two.css')
  ]
}

</pre><pre>
【 mini-css-extract-plugin 】
npm install -D mini-css-extract-plugin

将CSS提取为独立的文件的插件,对每个包含css的js文件都会创建一个CSS文件,支持按需加载css和sourceMap,只能用在webpack4中
对比插件extract-text-webpack-plugin优点:
异步加载
不重复编译,性能更好
更容易使用
只针对CSS
HMR

This plugin extracts CSS into separate files. It creates a CSS file per JS file which contains CSS. It supports On-Demand-Loading of CSS and SourceMaps.

It builds on top of a new webpack v4 feature (module types) and requires webpack 4 to work.

Compared to the extract-text-webpack-plugin:
Async loading
No duplicate compilation (performance)
Easier to use
Specific to CSS

</pre><pre class="js">
new MiniCssExtractPlugin({
    filename: 'css/[name].css',
  }),
],


</pre><pre class="js">
const MiniCssExtractPlugin = require('mini-css-extract-plugin');
module.exports = {
  plugins: [
    new MiniCssExtractPlugin({
      // Options similar to the same options in webpackOptions.output,both options are optional
      filename: '[name].css',
      chunkFilename: '[id].css',
    }),
  ],
  module: {
    rules: [
      {
        test: /\.css$/,
        use: [
          {
            loader: MiniCssExtractPlugin.loader,
            options: {
              // you can specify a publicPath here, by default it uses publicPath in webpackOptions.output
              publicPath: '../',
              hmr: process.env.NODE_ENV === 'development',
            },
          },
          'css-loader',
        ],
      },
    ],
  },
};

</pre><pre>
配置选项
publicPath
Type: String|Function Default: the publicPath in webpackOptions.output

Specifies a custom public path for the target file(s)

</pre>publicPath function example<pre class="js">
const MiniCssExtractPlugin = require('mini-css-extract-plugin');
module.exports = {
  plugins: [
    new MiniCssExtractPlugin({
      filename: '[name].css',
      chunkFilename: '[id].css',
    }),
  ],
  module: {
    rules: [
      {
        test: /\.css$/,
        use: [
          {
            loader: MiniCssExtractPlugin.loader,
            options: {
              publicPath: (resourcePath, context) => {
                // publicPath is the relative path of the resource to the context
                // e.g. for ./css/admin/main.css the publicPath will be ../../
                // while for ./css/main.css the publicPath will be ../
                return path.relative(path.dirname(resourcePath), context) + '/';
              },
            },
          },
          'css-loader',
        ],
      },
    ],
  },
};

</pre>Advanced configuration example<pre class="js">
// This plugin should be used only on production builds without style-loader in the loaders chain, especially if you want to have HMR in development.
// Here is an example to have both HMR in development and your styles extracted in a file for production builds

const MiniCssExtractPlugin = require('mini-css-extract-plugin');
const devMode = process.env.NODE_ENV !== 'production';

module.exports = {
  plugins: [
    new MiniCssExtractPlugin({
      filename: devMode ? '[name].css' : '[name].[hash].css',
      chunkFilename: devMode ? '[id].css' : '[id].[hash].css',
    }),
  ],
  module: {
    rules: [
      {
        test: /\.(sa|sc|c)ss$/,
        use: [
          {
            loader: MiniCssExtractPlugin.loader,
            options: {
              hmr: process.env.NODE_ENV === 'development',
            },
          },
          'css-loader',
          'postcss-loader',
          'sass-loader',
        ],
      },
    ],
  },
};

</pre><pre>
Hot Module Reloading (HMR)
extract-mini-css-plugin supports hot reloading of actual css files in development. Some options are provided to enable HMR of both standard stylesheets and locally scoped CSS or CSS modules. Below is an example configuration of mini-css for HMR use with CSS modules.

While we attempt to hmr css-modules. It is not easy to perform when code-splitting with custom chunk names. reloadAll is an option that should only be enabled if HMR isn't working correctly. The core challenge with css-modules is that when code-split, the chunk ids can and do end up different compared to the filename.

</pre><pre class="js">
const MiniCssExtractPlugin = require('mini-css-extract-plugin');
module.exports = {
  plugins: [
    new MiniCssExtractPlugin({
      filename: '[name].css',
      chunkFilename: '[id].css',
    }),
  ],
  module: {
    rules: [
      {
        test: /\.css$/,
        use: [
          {
            loader: MiniCssExtractPlugin.loader,
            options: {
              hmr: process.env.NODE_ENV === 'development',  // only enable hot in development
              reloadAll: true,                              // if hmr does not work, this is a forceful method.
            },
          },
          'css-loader',
        ],
      },
    ],
  },
};

</pre><pre>
Minimizing For Production
To minify the output, use a plugin like optimize-css-assets-webpack-plugin. Setting optimization.minimizer overrides the defaults provided by webpack, so make sure to also specify a JS minimizer:

设置mode: 'production'之后webpack会自动压缩

</pre><pre class="js">
const TerserJSPlugin = require('terser-webpack-plugin');
const MiniCssExtractPlugin = require('mini-css-extract-plugin');
const OptimizeCSSAssetsPlugin = require('optimize-css-assets-webpack-plugin');
module.exports = {
  optimization: {
    minimizer: [new TerserJSPlugin({}), new OptimizeCSSAssetsPlugin({})],
  },
  plugins: [
    new MiniCssExtractPlugin({
      filename: '[name].css',
      chunkFilename: '[id].css',
    }),
  ],
  module: {
    rules: [
      {
        test: /\.css$/,
        use: [MiniCssExtractPlugin.loader, 'css-loader'],
      },
    ],
  },
};

</pre>webpack本身集成了UglifyJS插件(webpack.optimize.UglifyJsPlugin),其命令webpack -p即表示调用UglifyJS来压缩代码,还有不少webpack插件如html-webpack-plugin也会默认使用UglifyJS<pre class="js">
const UglifyJsPlugin = require('uglifyjs-webpack-plugin');
const MiniCssExtractPlugin = require('mini-css-extract-plugin');
const OptimizeCSSAssetsPlugin = require('optimize-css-assets-webpack-plugin');

module.exports = {
  optimization: {
    minimizer: [
      new UglifyJsPlugin({
        cache: true,
        parallel: true,
        sourceMap: true
      }),
      new OptimizeCSSAssetsPlugin({}),
    ],
  },
  plugins: [
    new MiniCssExtractPlugin({
      filename: "[contenthash].css",
      chunkFilename: "[contenthash].css"
    }),
  ],
  module: {
    rules: [
      {
        test: /\.css$/,
        use: [
          MiniCssExtractPlugin.loader,
          'css-loader'
        ]
      }
    ]
  }
}

</pre><pre>
Extracting all CSS in a single file
Similar to what extract-text-webpack-plugin does, the CSS can be extracted in one CSS file using optimization.splitChunks.cacheGroups.

</pre><pre class="js">
const MiniCssExtractPlugin = require('mini-css-extract-plugin');
module.exports = {
  optimization: {
    splitChunks: {
      cacheGroups: {
        styles: {
          name: 'styles',
          test: /\.css$/,
          chunks: 'all',
          enforce: true,
        },
      },
    },
  },
  plugins: [
    new MiniCssExtractPlugin({
      filename: '[name].css',
    }),
  ],
  module: {
    rules: [
      {
        test: /\.css$/,
        use: [MiniCssExtractPlugin.loader, 'css-loader'],
      },
    ],
  },
};

</pre><pre>
根据entry提取CSS
可以根据webpack的entry name来提取CSS,这对动态引入路由却想依据entry保存打包的CSS的情况十分有用。这也解决了ExtractTextPlugin中CSS重复的问题

</pre><pre class="js">
const path = require('path');
const MiniCssExtractPlugin = require('mini-css-extract-plugin');

function recursiveIssuer(m) {
  if (m.issuer) {
    return recursiveIssuer(m.issuer);
  } else if (m.name) {
    return m.name;
  } else {
    return false;
  }
}

module.exports = {
  entry: {
    foo: path.resolve(__dirname, 'src/foo'),
    bar: path.resolve(__dirname, 'src/bar'),
  },
  optimization: {
    splitChunks: {
      cacheGroups: {
        fooStyles: {
          name: 'foo',
          test: (m, c, entry = 'foo') => m.constructor.name === 'CssModule' && recursiveIssuer(m) === entry,
          chunks: 'all',
          enforce: true,
        },
        barStyles: {
          name: 'bar',
          test: (m, c, entry = 'bar') => m.constructor.name === 'CssModule' && recursiveIssuer(m) === entry,
          chunks: 'all',
          enforce: true,
        },
      },
    },
  },
  plugins: [
    new MiniCssExtractPlugin({
      filename: '[name].css',
    }),
  ],
  module: {
    rules: [
      {
        test: /\.css$/,
        use: [MiniCssExtractPlugin.loader, 'css-loader'],
      },
    ],
  },
};

</pre><pre>
Module Filename Option
With the moduleFilename option you can use chunk data to customize the filename. This is particularly useful when dealing with multiple entry points and wanting to get more control out of the filename for a given entry point/chunk. In the example below, we'll use moduleFilename to output the generated css into a different directory.

</pre><pre class="js">
const miniCssExtractPlugin = new MiniCssExtractPlugin({
  moduleFilename: ({ name }) => `${name.replace('/js/', '/css/')}.css`
})

</pre>
</div>

<div id="webpack_hmr">
<h4>Hot Module Replacement(HMR) 模块热替换插件</h4><pre>
模块热替换允许在运行时更新各种模块而无需进行完全刷新,HMR不适用于生产环境,只应当在开发环境使用

允许在修改组件代码后自动刷新实时预览修改后的效果,在webpack中实现HMR也很简单,只需要做两项配置：
1、使用webpack内置的HMR插件,在webpack配置文件中添加HMR插件;
2、更新webpack-dev-server的配置,在Webpack Dev Server中添加"hot"参数;

通过命令来修改webpack-dev-server的配置：webpack-dev-server --hotOnly

如果使用了webpack-dev-middleware而没有使用webpack-dev-server,请使用webpack-hot-middleware package包以在自定义服务或应用程序上启用HMR

</pre><pre class="js">
const path = require('path');
const webpack = require('webpack')
const { CleanWebpackPlugin } = require('clean-webpack-plugin');
const HtmlWebpackPlugin = require('html-webpack-plugin');

module.exports = {
  mode: 'development',
  devtool: 'eval-source-map',
  devServer: {
    contentBase: './dist',
    port: 8000,
    host: '0.0.0.0',
    overlay: { errors: true },
    open: true,
    hot: true,
 },
  entry: {
    app: './src/index.js',
  },
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: '[name].bundle.js'
  },
  module: {
    rules: [
      {
        test: /\.css$/,
        use: ['style-loader', 'css-loader']
      }
    ]
  },
  plugins: [
    new CleanWebpackPlugin(),
    new HtmlWebpackPlugin(),
    new webpack.NamedModulesPlugin(),         // 添加NamedModulesPlugin以便更容易查看要修补(patch)的依赖
    new webpack.HotModuleReplacementPlugin(),
  ],
};

// 将通过在命令行中运行npm start来启动并运行dev server
// 修改单入口文件index.js,以便当其依赖的print.js内部发生变更时可以告诉webpack接受更新的模块

// index.js
import _ from 'lodash';
import printMe from './print.js';

function component() {
  var element = document.createElement('div');
  var btn = document.createElement('button');
  element.innerHTML = _.join(['Hello', 'webpack'], ' ');
  btn.innerHTML = 'Click me and check the console!';
  btn.onclick = printMe;
  element.appendChild(btn);
  return element;
}

document.body.appendChild(component());

if(module.hot) {
  module.hot.accept('./print.js', function() {
    console.log('Accepting the updated printMe module!');
    printMe();  // 调用print.js模块导出的函数
  })
}

// 更改print.js中console.log的输出内容之后将会在浏览器中看到如下的输出

// print.js
export default function printMe() {
  // console.log('I get called from print.js!');
  console.log('Updating print.js...')
}

// console
[HMR] Waiting for update signal from WDS...
main.js:4395 [WDS] Hot Module Replacement enabled.
+ 2main.js:4395 [WDS] App updated. Recompiling...
+ main.js:4395 [WDS] App hot update...
+ main.js:4330 [HMR] Checking for updates on the server...
+ main.js:10024 Accepting the updated printMe module!
+ 0.4b8ee77….hot-update.js:10 Updating print.js...
+ main.js:4330 [HMR] Updated modules:
+ main.js:4330 [HMR]  - 20
+ main.js:4330 [HMR] Consider using the NamedModulesPlugin for module names.

</pre><pre>
模块热替换功能会在应用程序运行过程中替换、添加或删除模块,而无需重新加载整个页面。主要是通过以下几种方式来显著加快开发速度：
1、保留在完全重新加载页面时丢失的应用程序状态。
2、只更新变更内容,以节省宝贵的开发时间。
3、调整样式更加快速,几乎相当于在浏览器调试器中更改样式

【 通过Node.js API 】
当使用webpack dev server和Node.js API时不要将dev server选项放在webpack配置对象中,而是在创建选项时将其作为第二个参数传递。例如：
new WebpackDevServer(compiler, options)

想要启用HMR还需要修改webpack配置对象,使其包含HMR入口起点。webpack-dev-server package中具有一个叫做addDevServerEntrypoints的方法,可以通过使用这个方法来实现

</pre><pre class="js">
// dev-server.js
const webpackDevServer = require('webpack-dev-server');
const webpack = require('webpack');
const config = require('./webpack.config.js');
const options = {
  contentBase: './dist',
  hot: true,
  host: 'localhost'
};
webpackDevServer.addDevServerEntrypoints(config, options);
const compiler = webpack(config);
const server = new webpackDevServer(compiler, options);
server.listen(5000, 'localhost',() => console.log('dev server listening on port 5000'));

</pre><pre>
如果在使用webpack-dev-middleware,可以通过webpack-hot-middleware package包在自定义开发服务下启用HMR

【 问题 】
如果继续点击示例页面上的按钮会发现控制台仍在打印这旧的printMe功能,这是因为按钮的onclick事件仍然绑定在旧的printMe函数上。

为了让它与HMR正常工作,需要使用module.hot.accept更新绑定到新的printMe函数上

</pre><pre class="js">
index.js

  import _ from 'lodash';
  import printMe from './print.js';

  function component() {
    var element = document.createElement('div');
    var btn = document.createElement('button');

    element.innerHTML = _.join(['Hello', 'webpack'], ' ');

    btn.innerHTML = 'Click me and check the console!';
    btn.onclick = printMe;  // onclick 事件绑定原始的 printMe 函数上

    element.appendChild(btn);

    return element;
  }

- document.body.appendChild(component());
+ let element = component(); // 当 print.js 改变导致页面重新渲染时,重新获取渲染的元素
+ document.body.appendChild(element);

  if(module.hot) {
    module.hot.accept('./print.js', function() {
      console.log('Accepting the updated printMe module!');
-     printMe();
+     document.body.removeChild(element);
+     element = component(); // 重新渲染页面后,component 更新 click 事件处理
+     document.body.appendChild(element);
    })
  }

</pre><pre>
这只是一个例子,但还有很多其他地方可以轻松地让人犯错。幸运的是,存在很多 loader(其中一些在下面提到),使得模块热替换的过程变得更容易

【 HMR修改样式表 】
借助于style-loader的帮助,CSS的模块热替换实际上是相当简单的。当更新CSS依赖模块时此loader在后台使用module.hot.accept来修补(patch)style标签。

</pre><pre>
【 HMR的工作原理 】
在应用程序中
通过以下步骤可以做到在应用程序中置换(swap in and out)模块：
1、应用程序代码要求 HMR runtime 检查更新。
2、HMR runtime(异步)下载更新,然后通知应用程序代码。
3、应用程序代码要求 HMR runtime 应用更新。
4、HMR runtime(同步)应用更新。

可以设置HMR,以使此进程自动触发更新,或者可以选择要求在用户交互时进行更新。

在编译器中
除了普通资源,编译器(compiler)需要发出"update",以允许更新之前的版本到新的版本。

"update"由两部分组成：
更新后的manifest(JSON)
一个或多个更新后的chunk(JavaScript)

manifest包括新的编译hash和所有的待更新chunk目录。每个更新chunk都含有对应于此chunk的全部更新模块(或一个flag用于表明此模块要被移除)的代码。

编译器确保模块ID和chunk ID在这些构建之间保持一致。通常将这些ID存储在内存中(例如使用webpack-dev-server时),但是也可能将它们存储在一个JSON文件中。

在模块中
HMR是可选功能,只会影响包含HMR代码的模块。举个例子,通过style-loader为style样式追加补丁。为了运行追加补丁,style-loader实现了HMR接口;当它通过HMR接收到更新,它会使用新的样式替换旧的样式。

类似的,当在一个模块中实现了HMR接口,可以描述出当模块被更新后发生了什么。然而在多数情况下不需要强制在每个模块中写入HMR代码。如果一个模块没有HMR处理函数更新就会冒泡(bubble up)。这意味着一个简单的处理函数能够对整个模块树(complete module tree)进行更新。如果在这个模块树中,一个单独的模块被更新,那么整组依赖模块都会被重新加载。

在HMR Runtime中
对于模块系统的runtime,附加的代码被发送到parents和children跟踪模块。在管理方面runtime支持两个方法check和apply。

check发送HTTP请求来更新manifest,如果请求失败说明没有可用更新,如果请求成功待更新chunk会和当前加载过的chunk进行比较。对每个加载过的chunk会下载相对应的待更新chunk,当所有待更新chunk完成下载就会准备切换到ready状态。

apply方法将所有被更新模块标记为无效。对于每个无效模块都需要在模块中有一个更新处理函数(update handler),或者在它的父级模块们中有更新处理函数,否则无效标记冒泡,并也使父级无效。每个冒泡继续直到到达应用程序入口起点,或者到达带有更新处理函数的模块(以最先到达为准,冒泡停止)。如果它从入口起点开始冒泡则此过程失败。

之后所有无效模块都被(通过dispose处理函数)处理和解除加载,然后更新当前hash,并且调用所有"accept"处理函数。runtime切换回闲置状态(idle state),一切照常继续。

</pre>
</div>

<div id="webpack_devSever">
<h4>webpack-dev-server</h4><pre>
每次要编译代码时手动运行npm run build就会变得很麻烦,webpack中有几个不同的选项,可以帮助在代码发生变化后自动编译代码：
webpack's Watch Mode
webpack-dev-server(最常用)
webpack-dev-middleware

【 使用观察模式 】
可以指示webpack "watch"依赖图中的所有文件以进行更改。如果其中一个文件被更新,代码将被重新编译,所以不必手动运行整个构建。
在package.json中添加一个用于启动webpack的观察模式的npm script脚本,命令行中运行npm run watch就会看到webpack编译代码,然而却不会退出命令行,这是因为script脚本还在观察文件
唯一的缺点是为了看到修改后的实际效果,需要刷新浏览器

"scripts": {
  "watch": "webpack --watch",
  "build": "webpack"
},

【 webpack-dev-server 】
cnpm install --save-dev webpack-dev-server

webpack-dev-server提供了一个简单的基于node.js构建的本地开发web服务器,能够实时重新加载(live reloading),并且能够自动刷新浏览器,浏览器监听代码的修改,并自动刷新显示修改后的结果
webpack-dev-server能通过localhost:8080启动一个express静态资源web服务器,并且会以监听模式自动运行webpack,在浏览器打开http://localhost:8080/或http://localhost:8080/webpack-dev-server/可以浏览项目中的页面和编译后的资源输出,并且通过一个socket.io服务实时监听它们的变化并自动刷新页面。

# npx webpack-dev-server --config webpack.config.js --progress --colors

package.json中添加
"start": "webpack-dev-server --open",
即可执行npm start

</pre>告知webpack-dev-server在localhost:8080下建立服务,将dist目录下的文件作为可访问文件<pre class="js">
const webpack = require('webpack')
const path = require('path')
const { CleanWebpackPlugin } = require('clean-webpack-plugin');
const HtmlWebpackPlugin = require('html-webpack-plugin');

const isDev = process.env.NODE_ENV === 'development'

const config = {
  target: 'web',
  devtool: 'eval-source-map',
  entry: {
    app: './src/index.js',
    print: './src/print.js'
  },
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: '[name].bundle.js'
  },
  module: {
    rules: [
      {
        test: /\.vue$/,
        loader: 'vue-loader'
      },{
        test: /\.css$/,
        use: [ 'style-loader', 'css-loader' ]
      },{
        test: /\.styl$/,
        use: [ 'style-loader', 'css-loader', 'stylus-loader' ]
      },{
        test: /\.(gif|jpg|jpeg|png|svg)$/,
        use: [{
          loader: 'url-loader',
          options: { limit: 1024, name: '[name]-aa.[ext]''}
        }]
      }
    ]
  },
  plugins: [
    new webpack.DefinePlugin({
      'process.env': {
        NODE_ENV : isDev ? '"development"' : '"production"'
      }
    }),
    new CleanWebpackPlugin(),
    new HtmlWebpackPlugin()
  ]
}

if(isDev){
  config.devtool = '#cheap-module-eval-source-map'   // 页面上调试代码
  config.devServer = {
    port: 8080,
    host: 0.0.0.0,
    overlay: { errors: true },  // 网页上实时显示错误
    open: true,                 // 启动时自动打开浏览器
    hot: true,                  // 热重启,页面局部刷新
    contentBase: './dist',      // 本地服务器所加载的页面所在的目录
    historyApiFallback: true,   // 不跳转
    inline: true                // 实时刷新
  }
  config.plugins = [
    new webpack.HotModuleReplacementPlugin(),
    new webpack.NoEmitOnErrorPlugin()
  ]
}

module.exports = config

// 在package.json中的scripts对象中添加如下命令用以开启本地服务器：在终端中输入npm run dev即可在本地的8080端口查看结果
"scripts": {
  "build": "NODE_ENV=production webpack --config webpack.config.js",           // unix
  "build": "set NODE_ENV=production webpack --config webpack.config.js",       // win在NODE_ENV前加set
  "build": "cross-env NODE_ENV=production webpack --config webpack.config.js", // 可使用cross-env包来兼容
  "dev": "cross-env NODE_ENV=development webpack-dev-server --config webpack.config.js"
},

</pre><pre>
配置选项
output的publicPath是用来给生成的静态资源路径添加前缀的
devServer中的publicPath是用来本地服务拦截带publicPath开头的请求的
contentBase是用来指定被访问html页面所在目录的

1、devServer.contentBase boolean/string/array
必须指向应用根目录即index.html所在目录,告诉服务器从哪里提供内容,也就是服务器启动的根目录,默认为当前执行目录

告诉开发服务器(dev server)在哪里查找文件,从哪里提供bundle,只有在想要提供静态文件时才需要。
默认webpack-dev-server将使用当前工作目录作为提供内容的目录提供本地服务器,如果想为另外一个目录下的文件提供本地服务器,应该在这里设置其所在目录
设置静态资源的根目录,html-webpack-plugin生成的html不是静态资源,当用html文件里的地址无法找到静态资源文件时就会去这个目录下去找

contentbase代表html页面所在的相对目录,如果不配置项则devServer默认html所在的目录就是项目的根目录,这个时候启动服务,访问地址通常并不会看见html页面,相反展现是项目根目录文件夹,因为根目录下根本没有html文件。这个时候html在编译后实际是在dist目录下,所以需要配置contentBase:'dist'
contentBase的路径是相对与webpack.config.js文件所在的目录的,有时习惯将webpack配置文件统一放着一个build文件下,这时在写contentBase路径的时候就需要注意了

devServer: {
  contentBase: './dist',
  contentBase: path.join(__dirname, "public"),
  contentBase: [path.join(__dirname, "public"), path.join(__dirname, "assets")], // 从多个目录提供内容
  contentBase: false                                                             // 禁用contentBase
},

2、devServer.publicPath string
指定浏览器上访问所有打包(bundled)文件(在dist里生成的所有文件)的根目录,这个根目录是相对服务器地址及端口的,比devServer.contentBase和output.publicPath优先
此路径下的打包文件可在浏览器中访问,devServer.publicPath和output.publicPath一样被推荐

假设服务器运行在http://localhost:8080且output.filename被设置为bundle.js,默认publicPath是"/",所以包(bundle)可通过http://localhost:8080/bundle.js访问。
修改publicPath,将bundle放在一个目录：publicPath: "/assets/",包现在可以通过http://localhost:8080/assets/bundle.js访问。

确保publicPath总是以斜杠(/)开头和结尾,也可以使用一个完整的URL,这是模块热替换所必需的。
publicPath: "http://localhost:8080/assets/"
bundle可以通过http://localhost:8080/assets/bundle.js访问。

</pre>服务器会拦截所有public开头的uri,然后到static目录下去寻找静态资源,找到就返回。实际上在服务器上是没有public目录,这里的public可以很好的隐藏静态资源在服务器上的实际目录,另一方面也可以对静态进行分类存放<pre class="js">
const express = require("express");
const app = express();
const path = require("path");
app.use(express.static('public', path.join(__dirname,'/static')));
app.listen(8080, err => {
  if(err) throw err;
  console.log('server is listening on port 8080')
})

</pre><pre>
webpack-dev-server的实现就是用的express实现的,devServer中的publicPath其实就是相当于上面express代码中public值的变量
这两个publicPath基本上时连体兄弟,如果在本地开发环境中配置了output的publicPath,那么在devServer中也要做相应的配置

3、devServer.host string
指定使用一个host,默认是localhost,如果希望服务器外部可访问则指定host: "0.0.0.0"

4、devServer.port
设置默认监听端口,默认8080

5、devServer.index string
The filename that is considered the index file.
index: 'index.htm'

6、devServer.hot boolean
启用webpack的模块热替换特性：hot: true
that webpack.HotModuleReplacementPlugin is required to fully enable HMR. If webpack or webpack-dev-server are launched with the --hot option, this plugin will be added automatically, so you may not need to add this to your webpack.config.js. See the HMR concepts page for more information

7、devServer.hotOnly boolean
Enables Hot Module Replacement without page refresh as fallback in case of build failures
hotOnly: true

8、devServer.open boolean
When open is enabled, the dev server will open the browser
open: true
Usage via the CLI: webpack-dev-server --open
If no browser is provided, your default browser will be used. To specify a different browser, just pass its name:
webpack-dev-server --open 'Google Chrome'

9、devServer.openPage string
Specify a page to navigate to when opening the browser.
openPage: '/different/page'

10、devServer.inline boolean
设置为true表示当源文件改变时会自动刷新页面
在dev-server的两种不同模式之间切换
默认应用程序启用内联模式(inline mode),这意味着一段处理实时重载的脚本被插入到包(bundle)中,并且构建消息将会出现在浏览器控制台。
也可以使用inline: false切换到iframe模式,它在通知栏下面使用iframe标签,包含了关于构建的消息
Usage via the CLI: webpack-dev-server --inline=false
推荐使用模块热替换的内联模式,因为它包含来自websocket的HMR触发器,轮询模式可以作为替代方案,但需要一个额外的入口点：'webpack/hot/poll?1000'。

11、devServer.lazy boolean
当启用lazy时dev-server只有在请求时才编译包(bundle),这意味着webpack不会监视任何文件改动,称之为"惰性模式"。
lazy: true

12、devServer.historyApiFallback  boolean、object
在开发单页应用时非常有用,它依赖于HTML5 history API,如果设置为true则所有的跳转将指向index.html

13、devServer.compress boolean
一切服务都启用gzip压缩：compress: true
Usage via the CLI: webpack-dev-server --compress

14、devServer.filename string
在惰性模式中此选项可减少编译。 默认在惰性模式每个请求结果都会产生全新的编译。使用filename可以只在某个文件被请求时编译。
如果output.filename设置为bundle.js ,filename使用如下：
lazy: true,
filename: "bundle.js"
现在只有在请求/bundle.js时候才会编译bundle。
filename在不使用惰性加载时没有效果。

15、devServer.headers object
在所有响应中添加首部内容：
headers: {
  "X-Custom-Foo": "bar"
}

16、devServer.quiet boolean
启用quiet后,除了初始启动信息之外的任何内容都不会被打印到控制台,这也意味着来自webpack的错误或警告在控制台不可见。
quiet: true

17、devServer.noInfo boolean
启用noInfo后诸如「启动时和每次保存之后,那些显示的webpack包(bundle)信息」的消息将被隐藏,错误和警告仍然会显示。
noInfo: true

18、devServer.overlay boolean/object
Shows a full-screen overlay in the browser when there are compiler errors or warnings. Disabled by default. If you want to show only compiler errors:
overlay: true   // 编译出现错误时将错误直接显示在页面上
If you want to show warnings as well as errors:
overlay: { warnings: true, errors: true }

【 使用webpack-dev-middleware 】
webpack-dev-middleware是一个容器(wrapper),它可以把webpack处理后的文件传递给一个服务器,webpack-dev-server在内部使用了它,同时它也可以作为一个单独的包来使用,以便进行更多自定义设置来实现更多的需求

</pre>webpack-dev-middleware配合express server<pre class="js">
// npm install --save-dev express webpack-dev-middleware

webpack-demo
  |- package.json
  |- webpack.config.js
  |- server.js
  |- /dist
  |- /src
    |- index.js
    |- print.js
  |- /node_modules

// webpack.config.js
const path = require('path');
const HtmlWebpackPlugin = require('html-webpack-plugin');
const CleanWebpackPlugin = require('clean-webpack-plugin');

module.exports = {
  entry: {
    app: './src/index.js',
    print: './src/print.js'
  },
  output: {
    filename: '[name].bundle.js',
    path: path.resolve(__dirname, 'dist'),
    publicPath: '/'                        // publicPath也会在服务器脚本用到,以确保文件资源能够在http://localhost:3000下正确访问
  },
  plugins: [
    new CleanWebpackPlugin(['dist']),
    new HtmlWebpackPlugin()
  ],
};

// server.js
const express = require('express');
const webpack = require('webpack');
const webpackDevMiddleware = require('webpack-dev-middleware');

const app = express();
const config = require('./webpack.config.js');
const compiler = webpack(config);

app.use(webpackDevMiddleware(compiler, {
  publicPath: config.output.publicPath
}));

app.listen(3000,() => console.log('Example app listening on port 3000!\n'));

// package.json添加一个npm script来更方便地运行服务：
"server": "node server.js",

// 终端执行 npm run server

</pre>
</div>

<div id="webpack_devtool">
<h3>devtool: 生成Source Maps,用于开发阶段调试</h3><pre>
开发时方便的调试能极大的提高开发效率,当webpack打包源代码时可能会很难追踪到错误和警告在源代码中的原始位置,例如将三个源文件a.js,b.js和c.js打包到一个bundle(bundle.js)中,而其中一个源文件包含一个错误,那么堆栈跟踪就会简单地指向到bundle.js。这并通常没有太多帮助,因为可能需要准确地知道错误来自于哪个源文件

为了更容易地追踪错误和警告,JS提供了source map功能,通过简单的配置webpack就可以在打包时生成source maps,将编译后的代码映射回原始源代码,如果一个错误来自于b.js,source map就会明确提示,这提供了一种对应编译文件和源文件的方法,使得编译后的代码可读性更高更容易调试。

devtool
string false
选择一种source map格式来增强调试过程,不同的值会明显影响到构建(build)和重新构建(rebuild)的速度
对于开发环境通常希望更快速的source map,需要添加到bundle中以增加体积为代价,但是对于生产环境则希望更精准的source map,需要从bundle中分离并独立存在
可通过设置output.sourceMapFilename自定义生成的source map的文件名

可以直接使用SourceMapDevToolPlugin/EvalSourceMapDevToolPlugin来替代使用devtool选项,因为它有更多的选项,切勿同时使用devtool选项和这两个插件,devtool选项在内部添加过这些插件,所以最终将应用两次插件

在webpack的配置文件中配置source maps需要配置devtool,此选项控制是否生成及如何生成source map
有以下几种常用的不同的配置选项,由上到下打包速度越来越快,同时也具有越来越多的负面作用,较快的打包速度的后果就是对打包后的文件的的执行有一定影响

devtool: dev ? 'cheap-module-eval-source-map' : 'hidden-source-map',

1、source-map
在一个单独的文件中产生一个完整且功能完全的文件,这个文件具有最好的source map,但是它会减慢打包速度;

2、cheap-module-source-map
在一个单独的文件中生成一个不带列映射的map,不带列映射提高了打包速度,但是也使得浏览器开发者工具只能对应到具体的行,不能对应到具体的列(符号),会对调试造成不便;

3、eval-source-map
使用eval打包源文件模块,在同一个文件中生成干净的完整的source map。这个选项可以在不影响构建速度的前提下生成完整的sourcemap,但是对打包后输出的JS文件的执行具有性能和安全的隐患。小到中型的项目中在开发阶段这是一个非常好的选项,在生产阶段则一定不要启用这个选项;

4、cheap-module-eval-source-map
这是在打包文件时最快的生成source map的方法,生成的Source Map会和打包后的Js文件同行显示,没有列映射,和eval-source-map选项具有相似的缺点,不利于调试,推荐在大型项目考虑时间成本时使用

</pre><pre class="js">
module.exports = {
  mode: 'development',
  devtool: 'eval-source-map',
  entry:  __dirname + "/app/main.js",
  output: {
    path: __dirname + "/public",
    filename: "bundle.js"
  }
}

</pre><pre>
+++ 非常快速, ++ 快速, + 比较快, o 中等, - 比较慢, -- 慢
(none) 构建速度：+++ 重新构建速度：+++ 生产环境：yes 品质：打包后的代码
eval 构建速度：+++ 重新构建速度：+++ 生产环境：no 品质：生成后的代码
cheap-eval-source-map 构建速度：+ 重新构建速度：++ 生产环境：no 品质：转换过的代码(仅限行)
cheap-module-eval-source-map 构建速度：o 重新构建速度：++ 生产环境：no 品质：原始源代码(仅限行)
eval-source-map 构建速度：-- 重新构建速度：+ 生产环境：no 品质：原始源代码
cheap-source-map 构建速度：+ 重新构建速度：o 生产环境：no 品质：转换过的代码(仅限行)
cheap-module-source-map 构建速度：o 重新构建速度：- 生产环境：no 品质：原始源代码(仅限行)
inline-cheap-source-map 构建速度：+ 重新构建速度：o 生产环境：no 品质：转换过的代码(仅限行)
inline-cheap-module-source-map 构建速度：o 重新构建速度：- 生产环境：no 品质：原始源代码(仅限行)
source-map 构建速度：-- 重新构建速度：-- 生产环境：yes 品质：原始源代码
inline-source-map 构建速度：-- 重新构建速度：-- 生产环境：no 品质：原始源代码
hidden-source-map 构建速度：-- 重新构建速度：-- 生产环境：yes 品质：原始源代码
nosources-source-map 构建速度：-- 重新构建速度：-- 生产环境：yes 品质：无源代码内容

品质说明(quality)
打包后的代码
将所有生成的代码视为一大块代码。你看不到相互分离的模块。

生成后的代码
每个模块相互分离,并用模块名称进行注释。可以看到 webpack 生成的代码。示例：你会看到类似 var module__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(42); module__WEBPACK_IMPORTED_MODULE_1__.a();,而不是 import {test} from "module"; test();。

转换过的代码
每个模块相互分离,并用模块名称进行注释。可以看到 webpack 转换前、loader 转译后的代码。示例：你会看到类似 import {test} from "module"; var A = function(_test) { ... }(test);,而不是 import {test} from "module"; class A extends test {}。

原始源代码
每个模块相互分离,并用模块名称进行注释。你会看到转译之前的代码,正如编写它时。这取决于 loader 支持。

无源代码内容
source map 中不包含源代码内容。浏览器通常会尝试从 web 服务器或文件系统加载源代码。你必须确保正确设置 output.devtoolModuleFilenameTemplate,以匹配源代码的 url。

(仅限行)
source map被简化为每行一个映射。这通常意味着每个语句只有一个映射(假设使用这种方式)。这会妨碍语句级别上调试执行,也会妨碍每行的一些列上设置断点。与压缩后的代码组合后,映射关系是不可能实现的,因为压缩工具通常只会输出一行。

【 对于开发环境 】
以下选项非常适合开发环境：

eval
每个模块都使用eval()执行,并且都有//@ sourceURL,构建速度快,主要缺点是由于会映射到转换后的代码,而不是映射到原始代码(没有从loader中获取sourcemap),所以不能正确的显示行数。

eval-source-map
每个模块使用eval()执行,并且source map转换为DataUrl后添加到eval()中。初始化source map时比较慢,但是会在重新构建时提供比较快的速度,并且生成实际的文件。行数能够正确映射,因为会映射到原始代码中。它会生成用于开发环境的最佳品质的source map。

cheap-eval-source-map
类似eval-source-map,每个模块使用eval()执行。这是"cheap(低开销)"的source map,因为它没有生成列映射(column mapping),只是映射行数。它会忽略源自loader的source map,并且仅显示转译后的代码,就像eval devtool。

cheap-module-eval-source-map
类似cheap-eval-source-map,并且在这种情况下源自loader的source map会得到更好的处理结果。然而loader source map会被简化为每行一个映射(mapping)。

【 特定场景 】
以下选项对于开发环境和生产环境并不理想。他们是一些特定场景下需要的,例如针对一些第三方工具。

inline-source-map
source map转换为DataUrl后添加到bundle中。

cheap-source-map
没有列映射(column mapping)的source map,忽略loader source map。

inline-cheap-source-map
类似cheap-source-map,但是source map转换为DataUrl后添加到bundle中。

cheap-module-source-map
没有列映射(column mapping)的source map,将loader source map简化为每行一个映射(mapping)。
生成的source map能和源码每行对应,方便打断点调试

inline-cheap-module-source-map
类似cheap-module-source-map,但是source mapp转换为DataUrl添加到bundle中。

【 对于生产环境 】
这些选项通常用于生产环境中：

(none)(省略 devtool 选项)
不生成source map。这是一个不错的选择。

source-map
整个source map作为一个单独的文件生成。它为bundle添加了一个引用注释,以便开发工具知道在哪里可以找到它。
应该将服务器配置为不允许普通用户访问source map文件！

hidden-source-map
与source-map相同,但不会为bundle添加引用注释
生成独立的source map文件,并且不在js文件中插入source map路径,用于在error report工具中查看如Sentry
如果只想source map映射那些源自错误报告的错误堆栈跟踪信息,但不想为浏览器开发工具暴露source map,这个选项会很有用。
不应将source map文件部署到web服务器,而是只将其用于错误报告工具。

nosources-source-map
创建的source map不包含sourcesContent(源代码内容)。它可以用来映射客户端上的堆栈跟踪,而无须暴露所有的源代码。可以将source map文件部署到web服务器。
这仍然会暴露反编译后的文件名和结构,但它不会暴露原始代码。

在使用uglifyjs-webpack-plugin时必须提供sourceMap：true选项来启用source map支持。

</pre>

<h4>SourceMapDevToolPlugin</h4><pre>
本插件实现了对source map生成进行更细粒度的控制,可以替代devtool选项
new webpack.SourceMapDevToolPlugin(options)

插件选项
test(string|regex|array)：包含基于扩展名的模块的source map,默认.js和.css
include(string|regex|array)：使路径与该值匹配的模块生成source map。
exclude(string|regex|array)：使匹配该值的模块不生成source map。
filename(string)：定义生成的source map的名称,如果没有值将会变成inlined
append(string)：在原始资源后追加给定值,通常是#sourceMappingURL,[url]被替换成source map文件的URL,false将禁用追加
moduleFilenameTemplate(string): 查看output.devtoolModuleFilenameTemplate
fallbackModuleFilenameTemplate(string)：同上
module(boolean)：表示loader是否生成source map,默认true
columns(boolean)：表示是否应该使用column mapping,默认true
lineToLine(object)：通过行到行源代码映射(line to line source mappings)简化和提升匹配模块的源代码映射速度,lineToLine对象允许的值和test\include\exclude选项一样
noSources(boolean)：防止源文件的内容被包含在source map里,默认false
publicPath(string)：生成带public path前缀的绝对URL,例如https://example.com/project/
fileContext(string)：使得[file]参数作为本目录的相对路径,在想要将source maps存储到上层目录,避免 ../../出现在绝对路径[url]里面时有用。

记得在使用UglifyJSPlugin时必须使用sourceMap选项

</pre><pre class="js">
new webpack.SourceMapDevToolPlugin({
  filename: '[name].js.map',
  exclude: ['vendor.js']      // 排除vendor.js内模块的source map
})

</pre>
</div>

<div id="webpack_splitChunks">
<h3>代码分离</h3><pre>
webpack的输出的文件中__webpack_require__( )方法就是webpack的模块加载器,其中对于已加载的模块是有统一的installedModules对象来管理的,这样就避免了模块重复加载的问题,而公共模块一般也需要从bundle.js文件中提取出来,这涉及到代码分割

1. 为什么要进行代码分割？
代码分割最基本的任务是分离出第三方依赖库,因为第三方库的内容可能很久都不会变动,所以用来标记变化的摘要哈希contentHash也很久不变,这也就意味着可以利用本地缓存来避免没有必要的重复打包,并利用浏览器缓存避免冗余的客户端加载。另外当项目发布新版本时,如果第三方依赖的contentHash没有变化就可以使用客户端原来的缓存文件(通用的做法一般是给静态资源请求设置一个很大的max-age),提升访问速度。另外一些场景中,代码分割也可以提供对脚本在整个加载周期内的加载时机的控制能力。

2. 代码分割的使用场景
比如一个数据可视化类型的网站,引用到了百度的Echarts作为第三方库来渲染图表,如果将自己的代码和Echarts打包在一起生成一个main.bundle.js文件,这样的结果就是在一个网速欠佳的环境下打开网站时,用户可能需要面对很长时间的白屏,很快就会想到将Echarts从主文件中剥离出来,让体积较小的主文件先在界面上渲染出一些动画或是提示信息,然后再去加载Echarts,而分离出的Echarts也可以从速度更快的CDN节点获取,如果加载某个体积庞大的库,也可以选择使用懒加载的方案,将脚本的下载时机延迟到用户真正使用对应的功能之前。这就是一种人工的代码分割。

从上面的例子整个的生命周期来看,将原本一次就可以加载完的脚本拆分为了两次,这无疑会加重服务端的性能开销,毕竟建立TCP连接是一种开销很大的操作,但这样做却可以换来对渲染节奏的控制和用户体验的提升,异步模块和懒加载模块从宏观上来讲实际上都属于代码分割的范畴。code splitting最极端的状况其实就是拆分成打包前的原貌,也就是源码直接上线。

3. 代码分割的本质
代码分割的本质就是在"源码直接上线"和"打包为唯一的脚本main.bundle.js"这两种极端方案之间寻找一种更符合实际场景的中间状态,用可接受的服务器性能压力增加来换取更好的用户体验

代码分离是webpack中最引人注目的特性之一,此特性能够把代码分离到不同的bundle中,然后可以按需加载或并行加载这些文件。代码分离可以用于获取更小的bundle,以及控制资源加载优先级,如果使用合理,会极大影响加载时间。

webpack打包出的各种js文件大致分为两类,一种是entry字段指定的入口文件,此类文件打包的结果暂且叫做bundle;除了前面说的,剩余的比如通用文件、外部文件、运行时等等,打包出的文件叫做chunk

有三种常用的代码分离方法：
入口起点：使用entry配置手动地分离代码
防止重复：使用SplitChunksPlugin去重和分离chunk
动态导入：通过模块的内联函数调用来分离代码

</pre>

<h4>入口起点</h4><pre>
这是迄今为止最简单、最直观的分离代码的方式,不过这种方式手动配置较多,并有一些陷阱

</pre><pre class="js">
// index.js
import _ from 'lodash';
console.log( _.join(['one', 'two', 'three!'], ' ') );

// another.js
import _ from 'lodash';
console.log( _.join(['Another', 'module', 'loaded!'], ' ') );

// webpack.config.js
const path = require('path');
const HTMLWebpackPlugin = require('html-webpack-plugin');

module.exports = {
  entry: {
    index: './src/index.js',
    another: './src/another.js'
  },
  plugins: [
    new HTMLWebpackPlugin()
  ],
  output: {
    filename: '[name].bundle.js',
    path: path.resolve(__dirname, 'dist')
  }
};

// 生成如下构建结果：index.bundle.js、another.bundle.js

</pre><pre>
这种方法存在一些问题:
1、如果入口chunks之间包含重复的模块,那些重复模块都会被引入到各个bundle中,这样就在多个bundle中造成重复引用
2、这种方法不够灵活,并且不能将核心应用程序逻辑进行动态拆分代码

</pre>

<h4>SplitChunksPlugin防止重复(prevent duplication)</h4><pre>
起初chunks(代码块)和导入他们中的模块通过webpack内部的父子关系图连接,在webpack3中通过CommonsChunkPlugin来避免他们之间的依赖重复。而在webpack4中CommonsChunkPlugin被移除,取而代之的是optimization.splitChunks和optimization.runtimeChunk配置项

SplitChunksPlugin引入了chunkGroup的概念,在入口chunk和异步chunk中发现被重复使用的模块,将重叠的模块以vendor-chunk的形式分离出来,也就是vendor-chunk可能有多个

ABC三者交集为A-B-C
AB交集A-B  B-C交集B-C  A-C交集A-C
A            B         C

对于入口A来说,引入的代码只有chunkA、vendor-chunkA-B、vendor-chunkA-C、vendor-chunkA-B-C;这时候chunkA、vendor-chunkA-B、vendor-chunkA-C、vendor-chunkA-B-C形成了一个chunkGroup。下面举个列子：

example：
entryA: vue vuex  someComponents
entryB：vue axios someComponents
entryC: vue vux axios someComponents

产出后的chunk：
vendor-chunkA-C：vuex
vendor-chunkB-C：axios
vendor-chunkA-B-C：vue
chunkA: only the components
chunkB: only the components
chunkC: only the components

request请求即调用模块
const path = require("path");
import _ from 'lodash';

SplitChunksPlugin在production模式下是默认开启的,但是它默认只作用于异步chunk,如果要作用于入口chunk的话,需要配置optimization.splitChunks.chunks: "all",同时webpack自动split chunks是有几个限制条件的:
1、新产出的vendor-chunk是要被共享的,或者模块来自npm包;
2、新产出的vendor-chunk的大小得大于30kb;
3、并行请求vendor-chunk的数量不能超出5个;
4、对于entry-chunk而言,并行加载的vendor-chunk不能超出3个。
这些限制可以在SplitChunks的默认配置项中可以一一对应的看到
其实不难理解这些限制,因为SplitChunksPlugin产生的结果就是原来chunk被拆分了,引入的文件数量会变多,因此需要在文件数量上进行限制

SplitChunksPlugin拆箱即用,对于大多数的用户很好用
默认webpack会根据下述条件自动进行代码块分割：
1、node_modules中的模块或其他被重复引用的模块
如果引用的模块来自node_modules,那么只要它被引用然后满足其他条件时就可以进行自动分割。否则该模块需要被重复引用才继续判断其他条件,对应的就是配置选项中的minChunks为1或2的场景

2、新代码块大于30kb(min+gziped之前的体积)
分离前模块最小体积下限(默认30k,可修改)
30k是官方给出的默认数值,可以修改,每一次分包对应的都是服务端的性能开销的增加,所以必须要考虑分包的性价比

3、按需加载的代码块,并行请求最大数量应该小于或者等于5
对于异步模块,生成的公共模块文件不能超出5个(可修改)
触发了懒加载模块的下载时并发请求不能超过5个,高并发和压力测试

4、初始加载的代码块,并行请求最大数量应该小于或等于3
对于入口模块,抽离出的公共模块文件不能超出3个(可修改),也就是说一个入口文件的最大并行请求默认不得超过3个,原因同上

默认SplitChunksPlugin块打包默认情况下只会影响按需加载模块,因为对初始块也进行优化打包会影响HTML中的script标签数,增加请求数

</pre>模块全部是同步引入,默认打包只会影响按需加载模块,所以所有内容全部被打包到一起了<pre class="js">
// indexA.js
import React from 'react'
import ReactDOM from 'react-dom'
import _ from 'lodash'

console.log(_.join(['a', 'b'], '~'))

ReactDOM.render(
 <div>SplitChunk</div>,
 document.getElementById('root')
)

</pre>有模块动态导入,这里首先使用符合ECMAScript提案的import()语法,这里jquery使用动态导入,打包结果中可以看到jquery被单独打包成vendors~async-jquery.bundle.js<pre class="js">
// indexA.js
import React from 'react'
import ReactDOM from 'react-dom'
import _ from 'lodash'
import(/* webpackChunkName: "async-jquery" */ 'jquery').then(component => {
 console.log(component)
})

console.log(_.join(['a', 'b'], '~'))

ReactDOM.render(
 <div>SplitChunk</div>,
 document.getElementById('root')
)

</pre><pre class="js">
// index.js
import('./a')  // 动态加载 a.js

// a.js
import 'vue'
// ...

/*
打包之后的结果会创建一个包含vue的独立代码块,当包含a.js的原始代码块被调用时这个独立代码块会并行请求进来。

原因：
vue来自node_modules文件夹
vue体积超过30KB
导入调用时的并行请求数为2
不影响页面初始加载

这样做是因为vue代码并不像业务代码那样经常变动,把它单独提取出来就可以和业务代码分开缓存,极大的提高效率。
*/

</pre><pre class="js">
// entry.js
import("./a");
import("./b");

// a.js
import "./helpers";        // helpers is 40kb in size
// ...

// b.js
import "./helpers";
import "./more-helpers";   // more-helpers is also 40kb in size
// ...

/*
结果：将创建一个单独的块,其中包含./helpers它的所有依赖项,在导入调用时此块与原始块并行加载。
原因：
条件1：helpers是共享块
条件2：helpers大于30kb
条件3：导入调用的并行请求数为2
条件4：不影响初始页面加载时的请求
*/

</pre>splitChunks默认配置项,默认配置是推荐的web最佳实践,但是项目的最佳策略根据项目类型可能会有所不同<pre class="js">
module.exports = {
  //...
  splitChunks: {
    // 表示哪些代码需要优化,有三个可选值：initial(初始化的代码块)、async(默认,按需加载的代码块)、all(推荐,所有代码块)
    // 默认只作用于异步模块,为all时对所有模块生效,initial对同步模块有效
    chunks: "async",

    // 模块的最小体积,形成一个新代码块最小的体积,表示在压缩合并前模块文件的大小
    minSize: 30000,

    // 模块的最小被引用次数,分割之前这个代码块最小应该被引用的次数,保证代码块复用性,默认配置策略是不需要多次引用也可以被分割
    minChunks: 1,

    // 按需加载的最大并行请求数,最大异步请求数
    maxAsyncRequests: 5,

    // 一个入口最大并行请求数,最大初始化请求
    maxInitialRequests: 3,

    // 文件名的连接符,打包分隔符
    automaticNameDelimiter: '~',

    // 控制切割拆分之后代码块的命名即打包后chunks的名字,默认由块名和hash值自动生成,true值会自动根据切割之前的代码块和缓存组键值(key)自动分配命名,否则就需要传入一个String或function,函数可以根据条件自定义名字
    name: true,

    // 缓存组,这里开始设置缓存的chunks
    cacheGroups: {
      // key为entry中定义的入口名称
      vendors: {
        // 用于控制哪些模块被这个缓存组匹配到。原封不动传递出去的话,它默认会选择所有的模块。可以传递的值类型：RegExp、String和Function
        test: /[\\/]node_modules[\\/]/,
        minChunks:1,
        // 缓存组打包的先后优先级
        priority: -10            // 优先级更高
      },
      default: {
        minChunks: 2,
        priority: -20,
        reuseExistingChunk: true
      }
    }
  },
  runtimeChunk:{
    name:'manifest'
  }
}

cacheGroups:{  // 这里开始设置缓存的 chunks
  priority: 0, // 缓存组优先级
  vendor: {    // key为entry中定义的入口名称
    chunks: "initial",
    test: /react|lodash/, // 正则规则验证,如果符合就提取chunk
    name: "vendor",       // 要缓存的分隔出来的chunk名称
    minSize: 30000,
    minChunks: 1,
    enforce: true,
    maxAsyncRequests: 5, // 最大异步请求数, 默认1
    maxInitialRequests : 3, // 最大初始化请求书,默认1
    reuseExistingChunk: true // 可设置是否重用该chunk
  }
}

</pre><pre>
cacheGroups
缓存组,其属性除上面所有属性外,还有test、priority、reuseExistingChunk
cacheGroups会继承和覆盖splitChunks的配置项,但是test、priorty和reuseExistingChunk只能用于配置缓存组
cacheGroups.test: 用于控制哪些模块被这个缓存组匹配到
cacheGroups.priority: 缓存组打包的先后优先级,允许为负数,对于相同模块的打包执行优先级高的规则
cacheGroups.reuseExistingChunk: 如果当前代码块包含的模块已经有了就不在产生一个新的代码块

cacheGroups里的每一项最好都要加上chunks参数,不然可能打包不出来想要的东西
minSize默认是30KB(注意这个体积是压缩之前的)在小于30kb的情况下一定要设置一个值,否则也可能打包不出来想要的东西,而且要加在cacheGroups里面

默认设置会将所有来自node_modules的模块分配到一个叫vendors的缓存组,生成对应的bundle;所有重复引用至少两次的代码模块会被分配到default的缓存组,生成对应的bundle
一个模块可以被分配到多个缓存组,这个优化可以通过选择更高优先级的缓存组或者形成代码块更大的缓存组来完成

</pre>打包表现正如上面所述,产生了两个代码块vendors、default<pre class="js">
// indexA.js
import './Dashboard.jsx'

// indexB.js
import './Dashboard.jsx'

// Dashboard.jsx
import React from 'react'

// webpack.config.js
splitChunks: {
  chunks: 'initial'
}

</pre>demo<pre class="js">
entry: {
  pageA: "./pageA", // 引用utility1.js  utility2.js
  pageB: "./pageB", // 引用utility2.js  utility3.js
  pageC: "./pageC"  // 引用utility2.js  utility3.js
},

optimization: {
  splitChunks: {
    cacheGroups: {
      commons: {
        chunks: "initial",
        minChunks: 2,
        maxInitialRequests: 5, // The default limit is too small to showcase the effect
        minSize: 0             // This is example is too small to create commons chunks
      }
    }
  }
},

/*
commons~pageA~pageB~pageC.js文件就是utility2.js,utility2被引用了三次,首先就被抽离了commons~pageA~pageB~pageC.js,然后utility3被引用了两次就放到了commons~pageB~pageC.js,最后只剩下被引用一次的utility1.js,就直接放到了pageA.js里面,如果这里的utility1.js的也是两次,他还是会新建一个chunk放进去,而不是合并到commons~pageB~pageC.js,除非同入口引用才会合并

这里有个地方是需要优化一下,pageA.js pageB.js pageC.js的代码不多,但是打出来的包很大,肯定是一些webpack的运行文件,直接加上runtimeChunk
runtimeChunk: "single"
// 等价于
runtimeChunk: { name: "manifest" }
*/

// 添加第三方模块的引用：pageA引用vue.js pageB引用react react-dom
vendor: {
  test: /node_modules/,
  chunks: "initial",
  name: "vendor",
  priority: 10,
  enforce: true
}

// 但是这样子的话会把pageA pageB pageC所有的库都打包到一起vendor.js,假如想拆分这个vendor.js为pageA-vendor.js和pageB-vendor.js怎么办,去掉手动的vendor,采用默认的vendors缓存组
splitChunks: {
  chunks: "all",
  cacheGroups: {
    commons: {
      chunks: "initial",
      minChunks: 2,
      maxInitialRequests: 5, // The default limit is too small to showcase the effect
      minSize: 0             // This is example is too small to create commons chunks
    }
  }
},

// 把webpack mode改成production后不管用了,同样的配置,在生产模式下打包出来之后vendor-pageB.js被合并到了pageB.js里面了,弃用默认的vendors缓存组
commons: {
  chunks: "initial",
  minChunks: 2,
  maxInitialRequests: 5, // The default limit is too small to showcase the effect
  minSize: 0             // This is example is too small to create commons chunks
},
'vendor-pageA': {
  test: /vue/,           // 直接使用test来做路径匹配
  chunks: "initial",
  name: "vendor-pageA",
  enforce: true,
},
'vendor-pageB': {
  test: /react/,        // 直接使用test来做路径匹配
  chunks: "initial",
  name: "vendor-pageB",
  enforce: true,
},

</pre>可以通过配置optimization.splitChunks.cacheGroups.default: false禁用default缓存组<pre class="js">
splitChunks: {
  chunks: 'initial',
  cacheGroups: {
    default: false
  }
}

</pre>创建一个vendor代码块,它包含了整个应用中所有来自node_modules的代码,这会导致一个包含所有外部包的大代码块,这可能会导致下载额外的代码,建议只包括核心框架和功能,并且动态加载剩余的依赖<pre class="js">
splitChunks: {
  cacheGroups: {
    commons: {
      test: /[\\/]node_modules[\\/]/,
      name: "vendors",
      chunks: "all"
    }
  }
}

</pre>使用cacheGroups缓存组可以自定义配置打包块,创建名为"commons"的代码块,它包含了入口之间共享的所有代码,这个配置会增大初始化包,当一个模块不是立即被需要建议采用动态导入<pre class="js">
// indexA.js
import React from 'react'
import ReactDOM from 'react-dom'
import _ from 'lodash'
import $ from 'jquery'

// indexB.js
import React from 'react'
import ReactDOM from 'react-dom'
import('lodash')
import $ from 'jquery'

// webpack.config.js
optimization: {
  splitChunks: {
    cacheGroups: {
      commons: {
        name: 'commons',
        chunks: 'initial',
        minChunks: 2
      }
    }
  }
}

</pre><pre>
根据webapck分割条件,一些公共模块被打包进了commons,自定义打包块的优先级是0,所以现在公共模块会被打包进commons,而不是上述提到的默认打包块vendors(优先级为负)

但是这边为什么lodash为什么没打包在一起呢？
all和initial的差别:
initial模式下会分开优化打包异步和非异步模块,而all会把异步和非异步同时进行优化打包,也就是说moduleA在indexA中异步引入,indexB中同步引入,initial下moduleA会出现在两个打包块中,而all只会出现一个。

接下来实验下all的效果,cacheGroups.commons.chunks: 'all',结果在预期中,lodash被打包在一起了

</pre><pre class="js">
// index.js
import _ from 'lodash';
import axios from 'axios'
console.log(_.join(['hi', 'hallo'], ' '))
axios.get('aaa')

// math.js
import _ from 'lodash'
console.log(_.join(['one', 'two', 'three'], ' '))

// webpack.config.js
const path = require('path');
const webpack = require('webpack')
const { CleanWebpackPlugin } = require('clean-webpack-plugin');
const HtmlWebpackPlugin = require('html-webpack-plugin');

module.exports = {
  mode: 'development',
  devtool: 'eval-source-map',
  entry: {
    index: './src/index.js',
    math: './src/math.js'
  },
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: '[name].bundle.js'
  },
  plugins: [
    new CleanWebpackPlugin(),
    new HtmlWebpackPlugin(),
  ],
  optimization: {
    splitChunks: {
      cacheGroups: {
        common: {
          name: 'common',
          chunks: 'initial',
          minChunks: 2
        }
      }
    }
  }
};

/* 输出
>npx webpack
Hash: f70076d3e67e77782456
Version: webpack 4.35.2
Time: 2301ms
Built at: 2019-07-10 4:59:28 PM
           Asset       Size  Chunks             Chunk Names
common.bundle.js   1.38 MiB  common  [emitted]  common
 index.bundle.js    179 KiB   index  [emitted]  index
      index.html  312 bytes          [emitted]
  math.bundle.js   32.3 KiB    math  [emitted]  math
Entrypoint index = common.bundle.js index.bundle.js
Entrypoint math = common.bundle.js math.bundle.js
[./node_modules/webpack/buildin/global.js](webpack)/buildin/global.js 472 bytes {common} [built]
[./node_modules/webpack/buildin/module.js](webpack)/buildin/module.js 497 bytes {common} [built]
[./src/index.js] 115 bytes {index} [built]
[./src/math.js] 73 bytes {math} [built]
    + 28 hidden modules
Child html-webpack-plugin for "index.html"
*/

optimization: {
  splitChunks: {
    chunks: 'initial',
    automaticNameDelimiter: '.',
    cacheGroups: {
      vendors: {
        test: /[\\/]node_modules[\\/]/,
        priority: 1
      }
    }
  },
  // 配置runtimeChunk会给每个入口添加一个只包含runtime的额外的代码块,name值也可以是字符串,不过这样就会给每个入口添加相同的 runtime,配置为函数时返回当前的entry对象即可分入口设置不同的runtime
  runtimeChunk: {
    name: entrypoint => `manifest.${entrypoint.name}`
  }
}

/*输出
>npx webpack
Hash: be4c456e54dc710c331a
Version: webpack 4.35.2
Time: 1978ms
Built at: 2019-07-10 10:10:22 PM
                       Asset       Size              Chunks             Chunk Names
             index.bundle.js   1.99 KiB               index  [emitted]  index
                  index.html  535 bytes                      [emitted]
    manifest.index.bundle.js   31.1 KiB      manifest.index  [emitted]  manifest.index
     manifest.math.bundle.js   31.1 KiB       manifest.math  [emitted]  manifest.math
              math.bundle.js   1.25 KiB                math  [emitted]  math
     vendors.index.bundle.js    143 KiB       vendors.index  [emitted]  vendors.index
vendors.index.math.bundle.js   1.38 MiB  vendors.index.math  [emitted]  vendors.index.math
Entrypoint index = manifest.index.bundle.js vendors.index.math.bundle.js vendors.index.bundle.js index.bundle.js
Entrypoint math = manifest.math.bundle.js vendors.index.math.bundle.js math.bundle.js
[./node_modules/webpack/buildin/global.js](webpack)/buildin/global.js 472 bytes {vendors.index.math} [built]
[./node_modules/webpack/buildin/module.js](webpack)/buildin/module.js 497 bytes {vendors.index.math} [built]
[./src/index.js] 223 bytes {index} [built]
[./src/math.js] 73 bytes {math} [built]
    + 28 hidden modules
Child html-webpack-plugin for "index.html"
*/

</pre><pre>
单页面应用
单页面应用只有一个入口文件,splitChunks的主要作用是将引用的第三方库拆分出来

提取第三方库
最后看下之前CommonsChunkPlugin常用的分离部分第三方库功能
设置chunks: initial || all都可以提取出第三方库,但是它是把所有第三库提取出来,所以在只提取react和react-dom的情况下需要自定义一个cacheGroup

</pre><pre class="js">
// indexA.js
import React from 'react'
import ReactDOM from 'react-dom'
import _ from 'lodash'
import $ from 'jquery'

// webpack.config.js方法1
entry: {
  indexA: path.join(__dirname, 'src/indexA.js')
},
optimization: {
  splitChunks: {
    chunks: 'all',
    cacheGroups: {
      vendors: {          // 重写了vendors打包块,只打包匹配react的模块
        test: /react/,
        name: 'vendors'
      }
    }
  }
}

// webpack.config.js方法2
entry: {
  indexA: path.join(__dirname, 'src/indexA.js'),
  vendor: ["react", "react-dom"]
},
optimization: {
  splitChunks: {
    cacheGroups: {
      vendor: {
        name: "vendor",
        chunks: "initial"
      }
    }
  }
}

</pre><pre>
【 optimization.runtimeChunk 】
在使用CommonsChunkPlugin的时候,通常会把webpack runtime的基础函数提取出来单独作为一个chunk,毕竟code splitting想把不变的代码单独抽离出来,方便浏览器缓存,提升加载速度。webpack4废弃了CommonsChunkPlugin,采用了runtimeChunkPlugin可以将每个entry chunk中的runtime部分的函数分离出来,只需要一个简单的配置：optimization.runtimeChunk: true

通过optimization.runtimeChunk: true选项,webpack会添加一个只包含运行时(runtime)额外代码块到每一个入口,会导致每个入口都加载多一份运行时代码),类似于runtime~index.bundle.js,由于这部分不常变化,可以利用缓存

设置值为single,只会为所有生成的代码块创建一个共享的runtime文件

runtime:连接模块化应用程序的所有代码
runtime包含:在模块交互时连接模块所需的加载和解析逻辑,包括浏览器中的已加载模块的连接,以及懒加载模块的执行逻辑

</pre>

<h4>动态导入(dynamic imports) 异步加载组件</h4><pre>
异步模块即懒加载模块,是在打开页面时不去加载,通过某些行为才触发加载,比如用户点击按钮后才去获取xxx.js

涉及到动态代码拆分时webpack提供了两个类似的技术,对于动态导入,第一种也是优先选择的方式是使用符合ECMAScript提案的import()语法。第二种则是使用webpack特定的require.ensure

webpack中从v1到v2,v3暂且不提,一共有3种代码切割加载的方案
1、System.import()已废除,不推荐
2、require.ensure()v1和v2均可使用
3、import()v2支持,v1不支持

</pre>异步引入模块B,模块B依赖于模块A<pre class="js">
require.ensure(["模块A"], function(require) {
  var foo = require("模块B");
});

const Foo = require.ensure([], () => {
	require("a");
}, err => {
	console.error("We failed to load chunk: " + err);
}, "chunk-name");

//react-router2 or 3
< Route path="/xx" getComponent={Foo} />

</pre>ES6的import语法模块只能做静态加载,所谓静态加载就是不能写成如下形式：<pre class="js">
let filename  = 'module.js';
import {mod} from './' + filename.

也不能写成如下形式：
if(condition) {
	import {mod} from './path1'
} else {
	import {mod} from './path2'
}

</pre>但是现在有新提案让import进行动态加载,虽然还没有被ECMA委员会批准,但是webpack已经开始用了<pre class="js">
let filename = 'module.js';

import('./' + filename).then(module => console(module)).catch(err => console(err.message));

//如果知道export的函数名
import('./' + filename).then(({fnName}) => console(fnName)).catch(err => console(err.message));

//如果用的是export default function()
import('./' + filename).then(module => console(module.default)).catch(err => console(err.message));
//或者
import('./' + filename).then(({default:fnName}) => console(fnName)).catch(err => console(err.message));

</pre>import的加载是加载的模块的引用,import()加载的是模块的拷贝<pre class="js">
// module.js 文件：
export let counter = 3;
export function incCounter() {
  counter++;
}

// main.js 文件：
let filename = 'module.js';
 import('./' + filename).then(({counter, incCounter})=>{
 console.log(counter); //3
 incCounter();
 console.log(counter); //3
 });

import {counter, incCounter} from './module.js';
console.log(counter); //3
incCounter();
console.log(counter); //4


</pre><pre>
import()调用会在内部用到promises,旧有版本浏览器中使用import()时记得使用一个polyfill库(如es6-promise或promise-polyfill)来shim Promise
由于import()会返回一个promise,因此它可以和async函数一起使用,但是需要使用像Babel这样的预处理器和Syntax Dynamic Import Babel Plugin

import(/* webpackChunkName: "common-async.js" */"./common-async").then(common => {
  console.log(common);
})

</pre>可以不加/* webpackChunkName: "lodash" */<pre class="js">
// /src/index.js
// 不再使用静态导入lodash,而是通过使用动态导入来分离一个chunk,lodash会分离到一个单独的bundle
// import _ from 'lodash';
// console.log(_.join(['Hello', 'webpack'], ' '))

// 在注释中使用了webpackChunkName,这样做会导致bundle被命名为lodash.bundle.js,而不是[id].bundle.js
function getComponent() {
  return import(/* webpackChunkName: "lodash" */ 'lodash').then(_ => {
    var element = document.createElement('div');
    element.innerHTML = _.join(['Hello', 'webpack'], ' ');
    return element;
  }).catch(error => 'An error occurred while loading the component');
}

// 使用ES7语法
async function getComponent() {
  var element = document.createElement('div');
  const _ = await import(/* webpackChunkName: "lodash" */ 'lodash');
  element.innerHTML = _.join(['Hello', 'webpack'], ' ');
  return element;
}

getComponent().then(component => {
  document.body.appendChild(component);
})

// webpack.config.js
const path = require('path');
const webpack = require('webpack')
const { CleanWebpackPlugin } = require('clean-webpack-plugin');
const HtmlWebpackPlugin = require('html-webpack-plugin');

module.exports = {
  mode: 'development',
  devtool: 'eval-source-map',
  entry: {
    index: './src/index.js'
  },
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: '[name].bundle.js',
    chunkFilename: '[name].bundle.js'  // 决定非入口chunk的名称
  },
  plugins: [
    new CleanWebpackPlugin(),
    new HtmlWebpackPlugin(),
  ]
};

/*输出
>npx webpack
                   Asset       Size          Chunks             Chunk Names
         index.bundle.js   10.4 KiB           index  [emitted]  index
              index.html  188 bytes                  [emitted]
vendors~lodash.bundle.js   1.38 MiB  vendors~lodash  [emitted]  vendors~lodash

*/

</pre><pre>
【 bundle分析(bundle analysis) 】
如果以分离代码作为开始,那么就以检查模块作为结束,分析输出结果是很有用处的。官方分析工具是一个好的初始选择。下面是一些社区支持(community-supported)的可选工具：
webpack-chart: webpack数据交互饼图。
webpack-visualizer: 可视化并分析你的bundle,检查哪些模块占用空间,哪些可能是重复使用的。
webpack-bundle-analyzer: 一款分析bundle内容的插件及CLI工具,以便捷的、交互式、可缩放的树状图形式展现给用户。

$ npx webpack --profile --json > stats.json

</pre>webpack-bundle-analyzer Usage(as a plugin)<pre class="js">
$ cnpm install --save-dev webpack-bundle-analyzer

const BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin;

module.exports = {
  plugins: [
    new BundleAnalyzerPlugin()
  ]
}

</pre>

<h4>懒加载</h4><pre>
懒加载或者按需加载,是一种很好的优化网页或应用的方式。这种方式实际上是先把你的代码在一些逻辑断点处分离开,然后在一些代码块中完成某些操作后,立即引用或即将引用另外一些新的代码块。这样加快了应用的初始加载速度,减轻了它的总体体积,因为某些代码块可能永远不会被加载

import()实现代码分离时确实会在脚本运行的时候产生一个分离的代码块lodash.bundle.js ,在技术概念上"懒加载"它,问题是加载这个包并不需要用户的交互,每次加载页面的时候都会请求它,这样做并没有很多帮助,还会对性能产生负面影响

增加一个交互,当用户点击按钮的时候用console打印一些文字,但是会等到第一次交互的时候再加载那个代码块(print.js)

</pre><pre class="js">
// src/print.js
console.log('The print.js module has loaded! See the network tab in dev tools...');

export default() => {
  console.log('Button Clicked: Here\'s "some text"!');
}

// src/index.js
async function component() {
  var element = document.createElement('div');
  var button = document.createElement('button');
  var br = document.createElement('br');

  button.innerHTML = 'Click me and look at the console!';
  const _ = await import(/* webpackChunkName: "lodash" */ 'lodash')
  element.innerHTML = _.join(['Hello', 'webpack'], ' ');
  console.log(element instanceof Promise)
  element.appendChild(br);
  element.appendChild(button);
  // 当调用ES6模块的mport()方法引入模块时必须指向模块的.default值,因为它才是promise被处理后返回的实际的module对象
  button.onclick = e => import(/* webpackChunkName: "print" */ './print').then(module => {
    var print = module.default;
    print();
  });
  return element;
}

(async() => document.body.appendChild(await component()))()

// webpack.config.js
const path = require('path');
const webpack = require('webpack')
const { CleanWebpackPlugin } = require('clean-webpack-plugin');
const HtmlWebpackPlugin = require('html-webpack-plugin');

module.exports = {
  mode: 'development',
  devtool: 'eval-source-map',
  entry: {
    index: './src/index.js'
  },
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: '[name].bundle.js',
    chunkFilename: '[name].bundle.js'  // 决定非入口chunk的名称
  },
  plugins: [
    new CleanWebpackPlugin(),
    new HtmlWebpackPlugin(),
  ]
};

/*输出
>npx webpack
                   Asset       Size          Chunks             Chunk Names
         index.bundle.js   11.2 KiB           index  [emitted]  index
              index.html  188 bytes                  [emitted]
         print.bundle.js   1.18 KiB           print  [emitted]  print
vendors~lodash.bundle.js   1.38 MiB  vendors~lodash  [emitted]  vendors~lodash
*/

</pre>
</div>

<div id="webpack_cache">
<h3>缓存</h3><pre>
使用webpack来打包模块化后的应用程序,webpack会生成一个可部署的/dist 目录,然后把打包后的内容放置在此目录中。只要/dist目录中的内容部署到服务器上,客户端通常是浏览器就能够访问网站此服务器的网站及其资源。而最后一步获取资源是比较耗费时间的,这就是为什么浏览器使用缓存技术。可以通过命中缓存,以降低网络流量,使网站加载速度更快,然而如果在部署新版本时不更改资源的文件名,浏览器可能会认为它没有被更新,就会使用它的缓存版本。由于缓存的存在,当需要获取新的代码时就会显得很棘手。

webpack需要通过必要的配置,以确保webpack编译生成的文件能够被客户端缓存,而在文件内容变化后能够请求到新的文件

【 输出文件的文件名(Output Filenames) 】
使用管理输出中的html-webpack-plugin来作为项目的基础,所以不必手动处理维护index.html文件

通过使用output.filename进行文件名替换,可以确保浏览器获取到修改后的文件。[hash]替换可以用于在文件名中包含一个构建相关(build-specific)的hash,但是更好的方式是使用[chunkhash]、[contenthash]替换,在文件名中包含一个chunk相关(chunk-specific)的哈希。

hash、chunkhash、contenthash
hash一般是结合CDN缓存来使用,通过webpack构建之后,生成对应文件名自动带上对应的MD5值。如果文件内容改变的话,那么对应文件哈希值也会改变,对应的HTML引用的URL地址也会改变,触发CDN服务器从源服务器上拉取对应数据,进而更新本地缓存。但是在实际使用的时候,这几种hash计算还是有一定区别。
1、hash是跟整个项目的构建相关,只要项目里有文件更改,整个项目构建的hash值都会更改,并且全部文件都共用相同的hash值
2、chunkhash根据不同的入口文件(Entry)进行依赖文件解析、构建对应的chunk生成对应的哈希值。在生产环境里把一些公共库和程序入口文件区分开,单独打包构建,接着采用chunkhash的方式生成哈希值,那么只要不改动公共库的代码就可以保证其哈希值不会受影响

</pre>项目结构：入口文件index.js,引用了index.css,然后新建了jquery.js和test.js作为公共库<pre class="js">
//index.js
require('./index.css')
module.exports = function(){
  console.log(`I'm jack`)
  var a = 12
}

//index.css
.selected : {
  display: flex;
  transition: all .6s;
  user-select: none;
  background: linear-gradient(to bottom, white, black);
}

// webpack.config.js
const path = require('path')
const extractTextPlugin = require('extract-text-webpack-plugin')

module.exports = {
 context : path.join(__dirname,'src'),
 entry:{
   main: './index.js',
   vender:['./jquery.js','./test.js']
 },
 module:{
   rules:[{
      test:/\.css$/,
      use: extractTextPlugin.extract({
        fallback:'style-loader',
        use:'css-loader'
      })
   }]
 },
 output:{
   path:path.join(__dirname, '/dist/js'),
   filename: 'bundle.[name].[chunkhash].js',
 },
 plugins:[
  new extractTextPlugin('../css/bundle.[name].[chunkhash].css')
 ]
}

</pre><pre>
由于采用chunkhash,index.css被index.js引用了,所以项目主入口文件Index.js及其对应的依赖文件Index.css由于被打包在同一个模块,所以共用相同的chunkhash,但是公共库由于是不同的模块,所以有单独的chunkhash。这样子就保证了在线上构建的时候只要文件内容没有更改就不会重复构建

如果index.js更改了代码,css文件就算内容没有任何改变,由于是该模块发生了改变,导致css文件会重复构建。
这时可以使用extra-text-webpack-plugin里的contenthash值,保证即使css文件所处的模块里就算其他文件内容改变,只要css文件内容不变,那么不会重复构建。

向项目中再添加一个模块print.js

</pre><pre class="js">
Hash: d38a06644fdbb898d795
Version: webpack 3.3.0
Time: 1445ms
                          Asset       Size  Chunks                    Chunk Names
 vendor.a7561fb0e9a071baadb9.js     541 kB       0  [emitted]  [big]  vendor
   main.b746e3eb72875af2caa9.js    1.22 kB       1  [emitted]         main
runtime.1400d5af64fc1b7b3a45.js    5.85 kB       2  [emitted]         runtime
                     index.html  352 bytes          [emitted]
   [1] ./src/index.js 421 bytes {1} [built]
   [2](webpack)/buildin/global.js 509 bytes {0} [built]
   [3](webpack)/buildin/module.js 517 bytes {0} [built]
   [4] ./src/print.js 62 bytes {1} [built]
   [5] multi lodash 28 bytes {0} [built]
    + 1 hidden module

</pre><pre>
再次运行构建,然后期望的是只有main bundle的hash发生变化,然而文件的hash都变化了。这是因为每个module.id会基于默认的解析顺序(resolve order)进行增量。也就是说,当解析顺序发生变化,ID也会随之改变。因此简要概括：
main bundle会随着自身的新增内容的修改,而发生变化。
vendor bundle会随着自身的module.id的修改,而发生变化。
runtime bundle会因为当前包含一个新模块的引用,而发生变化。
第一个和最后一个都是符合预期的行为 -- 而vendor的hash发生变化是要修复的,可以使用两个插件来解决这个问题。第一个插件是NamedModulesPlugin,将使用模块的路径,而不是数字标识符。虽然此插件有助于在开发过程中输出结果的可读性,然而执行时间会长一些。第二个选择是使用HashedModuleIdsPlugin,推荐用于生产环境构建：

</pre><pre class="js">
// src/index.js
import _ from 'lodash';
import Print from './print';

function component() {
  var element = document.createElement('div');
  element.innerHTML = _.join(['Hello', 'webpack'], ' ');
  element.onClick = Print.bind(null, 'Hello webpack!');
  return element;
}

document.body.appendChild(component());

// src/print.js
export default function print(text) {
  console.log(text)
}

// webpack.config.js
const path = require('path');
const webpack = require('webpack')
const { CleanWebpackPlugin } = require('clean-webpack-plugin');
const HtmlWebpackPlugin = require('html-webpack-plugin');

module.exports = {
  mode: 'development',
  stats: {
    children: false,
  },
  devtool: 'eval-source-map',
  entry: {
    main: './src/index.js',
    vendor: [ 'lodash' ]       // 注释此行则不会生成vendor.033485bfcc760741a32a.js
  },
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: '[name].[contenthash].js'
  },
  plugins: [
    new CleanWebpackPlugin(),
    new HtmlWebpackPlugin(),
    new webpack.HashedModuleIdsPlugin(),
  ],
  optimization: {
    splitChunks: {
      cacheGroups: {
        vendor: {
          name: 'vendor',
          chunks: 'initial',
          minChunks: 2
        }
      }
    }
  }
};

/*输出
>npx webpack
Hash: ba288ecdaff0d00726dd
Version: webpack 4.35.2
Time: 2029ms
Built at: 2019-07-11 6:09:35 PM
                         Asset       Size  Chunks             Chunk Names
                    index.html  278 bytes          [emitted]
  main.12d12d3d7258b2146fd3.js   9.01 KiB    main  [emitted]  main
vendor.033485bfcc760741a32a.js   1.38 MiB  vendor  [emitted]  vendor
Entrypoint main = vendor.033485bfcc760741a32a.js main.12d12d3d7258b2146fd3.js
[0] multi lodash 28 bytes {vendor} [built]
[YuTi](webpack)/buildin/module.js 497 bytes {vendor} [built]
[dSPy] ./src/print.js 60 bytes {main} [built]
[tjUo] ./src/index.js 354 bytes {main} [built]
[yLpj](webpack)/buildin/global.js 472 bytes {vendor} [built]
    + 1 hidden module
*/

</pre><pre>
【 提取模板(Extracting Boilerplate) 】
代码分离中的SplitChunksPlugin可以用于将模块分离到单独的文件中,还能够在每次修改后的构建结果中将webpack的样板(boilerplate)和 manifest提取出来。通过指定entry配置中未用到的名称,此插件会自动将需要的内容提取到单独的包中：

</pre><pre class="js">
// src/index.js
async function component() {
  var button = document.createElement('button');
  button.innerHTML = 'click'
  button.onclick = e => import(/* webpackChunkName: "lodash" */ 'lodash').then(_ => {
    console.log(_.join(['Hello', 'webpack'], ' '));
  });
  return button;
}

(async() => document.body.appendChild(await component()))()

// webpack.config.js
const path = require('path');
const { CleanWebpackPlugin } = require('clean-webpack-plugin');
const HtmlWebpackPlugin = require('html-webpack-plugin');

module.exports = {
  mode: 'development',
  devtool: 'eval-source-map',
  entry: {
    index: './src/index.js'
  },
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: '[name].[chunkhash].js'
  },
  plugins: [
    new CleanWebpackPlugin(),
    new HtmlWebpackPlugin(),
  ],
  optimization: {
    runtimeChunk: {
      name: entrypoint => `manifest.${entrypoint.name}`
    }
  }
};

/*输出
>npx webpack
Hash: 43759faa3d4e994a85d1
                                 Asset       Size          Chunks             Chunk Names
         index.a3ed76aea9da8d160685.js   1.68 KiB           index  [emitted]  index
                            index.html  287 bytes                  [emitted]
manifest.index.bc4d3f07b6e3e610ad87.js   8.96 KiB  manifest.index  [emitted]  manifest.index
vendors~lodash.8ac087e0a568dd4f8e5d.js   1.38 MiB  vendors~lodash  [emitted]  vendors~lodash
*/

</pre><pre>
将第三方库(library)(例如lodash或react)提取到单独的vendor chunk文件中是比较推荐的做法,这是因为它们很少像本地的源代码那样频繁修改。因此通过实现以上步骤,利用客户端的长效缓存机制,可以通过命中缓存来消除请求,并减少向服务器获取资源,同时还能保证客户端代码和服务器端代码版本一致。这可以通过使用新的entry(入口)起点以及再额外配置splitChunks的组合方式来实现

</pre>
</div>

<div id="webpack_etc">
<h3>产品阶段的构建</h3><pre>
在产品阶段可能还需要对打包的文件进行额外的处理如优化、压缩、缓存及分离CSS和JS

复杂的项目需要复杂的配置,这时候分解配置文件为多个小的文件可以使得事情井井有条,创建一个webpack.production.config.js的文件,在里面加上基本的配置,它和原始的webpack.config.js很像

</pre><pre class="js">
// webpack.production.config.js
const webpack = require('webpack');
const HtmlWebpackPlugin = require('html-webpack-plugin');
const ExtractTextPlugin = require('extract-text-webpack-plugin');

module.exports = {
  entry: __dirname + "/app/main.js",
  output: {
    path: __dirname + "/build",
    filename: "bundle.js"
  },
  devtool: 'none',
  devServer: {
    contentBase: "./public",   //本地服务器所加载的页面所在的目录
    historyApiFallback: true,  //不跳转
    inline: true,
    hot: true
  },
  module: {
    rules: [
      {
        test: /(\.jsx|\.js)$/,
        use: { loader: "babel-loader" },
        exclude: /node_modules/
      },
      {
        test: /\.css$/,
        use: [
          { loader: "style-loader" },
          { loader: "css-loader", options: { modules: true } },
          { loader: "postcss-loader" }
        ]
      }
    ]
  },
  plugins: [
    new webpack.BannerPlugin('版权所有,翻版必究'),
    new HtmlWebpackPlugin({
        template: __dirname + "/app/index.tmpl.html"
    }),
    new webpack.optimize.OccurrenceOrderPlugin(),
    new webpack.optimize.UglifyJsPlugin(),
    new ExtractTextPlugin("style.css")
  ],
};

//package.json

"scripts": {
  "test": "echo \"Error: no test specified\" && exit 1",
  "start": "webpack",
  "server": "webpack-dev-server --open",
  "build": "NODE_ENV=production webpack --config ./webpack.production.config.js --progress"
}

如果是window则build需要配置为"build": "set NODE_ENV=production && webpack --config ./webpack.production.config.js --progress"

</pre><pre>
【 优化插件 】
OccurenceOrderPlugin 内置插件
为组件分配ID,通过这个插件webpack可以分析和优先考虑使用最多的模块,并为它们分配最小的ID

UglifyJsPlugin 内置插件
压缩JS代码

ExtractTextPlugin
分离CSS和JS文件
npm install --save-dev extract-text-webpack-plugin

【 缓存 】
使用缓存的最好方法是保证文件名和文件内容是匹配的,即内容改变时名称相应改变
webpack可以把一个哈希值添加到打包的文件名中,可添加特殊的字符串混合体([name], [id] and [hash])到输出文件名前

</pre><pre class="js">
output: {
  path: __dirname + "/build",
  filename: "bundle-[hash].js"
}

</pre><pre>
去除build文件中的残余文件
添加了hash之后会导致改变文件内容后重新打包时,文件名不同而内容越来越多可以使用插件clean-webpack-plugin

安装：
cnpm install clean-webpack-plugin --save-dev

使用：
引入clean-webpack-plugin插件后在配置文件的plugins中做相应配置即可：

</pre><pre class="js">
const CleanWebpackPlugin = require("clean-webpack-plugin");
plugins: [
    new CleanWebpackPlugin('build/*.*', {
      root: __dirname,
      verbose: true,
      dry: false
  })
]

</pre>

<h4>webpack4新版本代码分割和缓存组</h4><pre>
【 代码分割 】
webpack4删除了CommonsChunkPlugin,以支持两个新的选项optimization.splitChunks和optimization.runtimeChunk

chunk指的就是一个代码块,即一个js文件
默认webpack只产生entry中指定的代码块,chunk的个数和entry中的key值个数相等,即单入口的情况下默认只产出一个chunk
但是通常希望将入口之间的通用代码和第三方类库的代码提取出来,单独作为一个js文件来引用,第三方的文件一般很少变动,可以利用缓存机制把相关内容缓存起来,通用代码则可以避免重复加载

通过设置optimization.splitChunks.chunks: "all" 来启动默认的代码分割配置项

在新版本的webpack会默认对代码进行拆分,拆分的规则：
当前模块是公共模块(多处引用)或者模块来自node_modules
当前模块大小大于30kb
如果此模块是按需加载,并行请求的最大数量小于等于 5
如果此模块在初始页面加载,并行请求的最大数量小于等于 3

当然也可以不使用默认的配置,比如这样：

</pre><pre class="js">
new webpack.optimize.SplitChunksPlugin({
    chunks: "all",
    minSize: 20000,
    minChunks: 1,
    maxAsyncRequests: 5,
    maxInitialRequests: 3,
    name: true
)}

</pre><pre>
通过设置optimization.runtimeChunk: true来为每一个入口默认添加一个只包含runtime的chunk

【 使用缓存组(Cache Groups) 】
如果想继续细分代码可以使用缓存组(Cache Groups)。同样的缓存组也有默认的配置;缓存组默认将node_modules中的模块拆分带一个叫做vendors的代码块中,将最少重复引用两次的模块放入default中

</pre>缓存组的默认配置<pre class="js">
splitChunks: {
  chunks: "async",
  minSize: 30000,
  minChunks: 1,
  maxAsyncRequests: 5,
  maxInitialRequests: 3,
  name: true,
  cacheGroups: {
    default: {
      minChunks: 2,
      priority: -20
      reuseExistingChunk: true,
    },
    vendors: {
      test: /[\\/]node_modules[\\/]/,
      priority: -10
    }
  }
}

</pre>可以通过default:false禁用默认的缓存组,然后就可以自定义缓存组,将初始化加载时被重复引用的模块进行拆分<pre class="js">
cacheGroups: {
  commons: {
    name: "commons",
    chunks: "initial",
    minChunks: 2
  }
}

// 然后可以根据具体的需求,创建多个缓存组：
cacheGroups: {
    a: {
        // ...
    },
    b: {
        // ...
    }
    // ...
}

</pre><pre class="js">
entry: {
  vendor: ['lodash']
},

optimization: {
  splitChunks: {
    chunks: "initial",       // 表示显示块的范围,initial(初始块)、async(按需加载块异步)、all(全部块,默认)
    minSize: 0,              // 在压缩前的最小模块大小,默认为0
    minChunks: 1,            // 最小chunk,表示被引用次数,默认1
    maxAsyncRequests: 1,     // 最大的按需(异步)加载次数, 默认1
    maxInitialRequests : 1,  // 最大的初始化加载次数,默认1
    name: function(){},      // 拆分出来块的名字(Chunk Names),默认由块名和hash值自动生成
    cacheGroups:{                 // 这里开始设置缓存的chunks,缓存组
      priority: 0,                // 缓存的优先级
      vendor: {                   // key 为entry中定义的 入口名称
         chunks: "initial",       // 必须三选一： "initial" | "all" | "async"(默认就是异步)
         test: /react|lodash/,    // 缓存组的规则,表示符合条件的的放入当前缓存组,值可以是function、boolean、string、RegExp,默认为空
         name: "vendor",          // 要缓存的 分隔出来的chunk名称
         minSize: 0,
         minChunks: 1,
         enforce: true,
         maxAsyncRequests: 1,      // 最大异步请求数, 默认1
         maxInitialRequests : 1,   // 最大初始化请求书,默认1
         reuseExistingChunk: true  // 表示可以使用已经存在的块,即如果满足条件的块已经存在就使用已有的,不再创建一个新的块
      }
    }
  }
},

</pre>
</div>

<div id="esLint">
<h3>ESLint</h3><pre>
ESLint是一款开源的JavaScript lint工具,由Nicholas C. Zakas于2013年创建,eslint的代码规范只在开发阶段使用

ESLint是个代码风格管理工具,用来统一代码风格的,并不会影响整体的运行,也是为了多人协作,新手就不用了,一般项目中都会使用

ESLint是一个用来识别ECMAScript并且按照规则给出报告的代码检测工具,使用它可以避免低级错误和统一代码的风格。ESLint被设计为完全可配置的

ESLint是一个代码规范和错误检查工具,有以下几个特性
所有东西都是可以插拔的,可以调用任意的rule api或formatter api去打包或定义rule or formatter。
任意的rule都是独立的
没有特定的coding style,可以自己配置

EsLint提供以下支持：
ES6
AngularJS
JSX
Style检查
自定义错误和提示

借助ESLint可将静态代码分析和问题代码协助修复集成到编码、提交和打包过程中,及早发现并协助修复代码中：
有语法错误的部分
不符合约定的样式准则的部分
不符合约定的最佳实践的部分

EsLint提供以下几种校验：
语法错误校验
不重要或丢失的标点符号,如分号
没法运行到的代码块
未被使用的参数提醒
漏掉的结束符如}
确保样式的统一规则如sass或者less
检查变量的命名

在项目开发中获得如下收益：
在执行代码之前发现并修复语法错误,减少调试耗时和潜在bug
保证项目的编码风格统一,提高可维护性
督促团队成员在编码时遵守约定的最佳实践,提高代码质量

ESLint借助nodejs的模块化机制引用插件,所以全局安装的ESLint只能使用全局安装的ESLint插件,局部安装的ESLint只能使用局部安装的 ESLint插件

【 安装 】
全局安装,适合全部项目都需要eslint
$ npm install -g eslint
设置一个配置文件:
$ eslint --init
之后可以在任何文件或目录运行ESLint:
$ eslint yourfile.js

本地安装,使用的任何插件或共享配置必须安装在本地来与安装在本地的ESLint一起工作
npm install eslint -save-dev
项目根目录下使用--init选项来生成配置文件
$ eslint --init
之后可以运行ESLint在任何文件或目录,如测试yourfile.js
$ eslint yourfile.js

eslint --init是用于每一个项目设置和配置eslint,并将执行本地安装的ESLint及其插件的目录。如果你喜欢使用全局安装的ESLint,在你配置中使用的任何插件都必须是全局安装的

【 ESLint使用 】
使用ESLint的方式有很多种,有编辑器、构建工具、命令行、源代码管理等。可直接使用编辑器来实时检测代码并提示错误,如果使用webpack的话,需要保存修改后才会提示

ESlint被设计为完全可配置的,这意味着可以关闭每一个规则而只运行基本语法验证,或混合和匹配ESLint默认绑定的规则和你的自定义规则,以让ESLint更适合项目

详细的配置查看http://eslint.org/docs/user-guide/configuring

【 主要有两种方式来配置ESLint 】
1、Configuration Comments注释配置的写法: 使用js注释把配置信息直接嵌入到一个代码源文件中

</pre><pre class="js">
可以在文件中使用以下格式的块注释来临时禁止规则出现警告
/* eslint-disable */
alert('foo');
/* eslint-enable */

也可以对指定的规则启用或禁用警告:
/* eslint-disable no-alert, no-console */
alert('foo');
console.log('bar');
/* eslint-enable no-alert, no-console */

如果在整个文件范围内禁止规则出现警告,将 /* eslint-disable */ 块注释放在文件顶部：
/* eslint-disable */
alert('foo');

也可以对整个文件启用或禁用警告:
/* eslint-disable no-alert */
// Disables no-alert for the rest of the file
alert('foo');

可以在文件中使用以下格式的行注释或块注释在某一特定的行上禁用所有规则：
alert('foo'); // eslint-disable-line

// eslint-disable-next-line
alert('foo');

/* eslint-disable-next-line */
alert('foo');

alert('foo'); /* eslint-disable-line */

在某一特定的行上禁用某个指定的规则：
alert('foo'); // eslint-disable-line no-alert

// eslint-disable-next-line no-alert
alert('foo');

alert('foo'); /* eslint-disable-line no-alert */

/* eslint-disable-next-line no-alert */
alert('foo');

在某个特定的行上禁用多个规则：
alert('foo'); // eslint-disable-line no-alert, quotes, semi

// eslint-disable-next-line no-alert, quotes, semi
alert('foo');

alert('foo'); /* eslint-disable-line no-alert, quotes, semi */

/* eslint-disable-next-line no-alert, quotes, semi */
alert('foo');

上面的所有方法同样适用于插件规则。例如禁止eslint-plugin-example的rule-name规则,把插件名(example)和规则名(rule-name)结合为 example/rule-name：

foo(); // eslint-disable-line example/rule-name
foo(); /* eslint-disable-line example/rule-name */

注意：为文件的某部分禁用警告的注释,告诉ESLint不要对禁用的代码报告规则的冲突。ESLint仍解析整个文件,然而禁用的代码仍需要是有效的js语法。

</pre><pre>
2、Configuration Files:文件配置使用js、json或yaml文件为整个目录和它的子目录指定配置信息
可以配置一个独立的.eslintrc.*文件,或直接在package.json文件里的eslintConfig字段指定配置,ESLint会查找和自动读取它们,再者可以在命令行运行时指定一个任意的配置文件

ESLint支持几种格式的配置文件
使用.eslintrc.js然后输出一个配置对象。
使用.eslintrc.yaml或.eslintrc.yml去定义配置的结构。
使用.eslintrc.json去定义配置的结构,ESLint的JSON文件允许JS风格的注释。
使用.eslintrc,可以使JSON也可以是YAML
在package.json里创建一个eslintConfig属性定义配置
可以直接配置在webpack的属性中

如果在主目录(通常 ~/)有一个配置文件,ESLint只有在无法找到其他配置文件时才使用它
如果同一个目录下有多个配置文件,ESLint只会使用一个,优先级顺序如下
1 .eslintrc.js
2 .eslintrc.yaml
3 .eslintrc.yml
4 .eslintrc.json
5 .eslintrc
6 .package.json

当使用.eslintrc.*和package.json文件的配置时可以利用层叠配置
your-project
├── .eslintrc
├── lib
│ └── source.js
└─┬ tests
  ├── .eslintrc
  └── test.js

层叠配置使用离要检测的文件最近的.eslintrc文件作为最高优先级,然后才是父目录里的配置文件等等。当在这个项目中允许ESLint时,lib/下面的所有文件将使用项目根目录里的.eslintrc文件作为它的配置文件。当ESLint遍历到test/目录,your-project/.eslintrc之外,它还会用到 your-project/tests/.eslintrc。所以your-project/tests/test.js是基于它的目录层次结构中的两个.eslintrc文件的组合,并且离的最近的一个优先。通过这种方式可以有项目级ESLint设置,也有覆盖特定目录的ESLint设置。

同样的,如果在根目录的package.json文件中有一个eslintConfig字段,其中的配置将使用于所有子目录,但是当tests目录下的.eslintrc文件中的规则与之发生冲突时就会覆盖它。
your-project
├── package.json
├── lib
│ └── source.js
└─┬ tests
  ├── .eslintrc
  └── test.js

如果同一目录下.eslintrc和package.json同时存在,.eslintrc优先级高会被使用,package.json文件将不会被使用

如果在你的主目录下有一个自定义的配置文件 (~/.eslintrc) ,如果没有其它配置文件时它才会被使用。因为个人配置将适用于用户目录下的所有目录和文件,包括第三方的代码,当 ESLint 运行时可能会导致问题

默认情况下,ESLint 会在所有父级目录里寻找配置文件,一直到根目录。如果你想要你所有项目都遵循一个特定的约定时,这将会很有用,但有时候会导致意想不到的结果。为了将 ESLint 限制到一个特定的项目,在你项目根目录下的 package.json 文件或者 .eslintrc.* 文件里的 eslintConfig 字段下设置 "root": true。ESLint 一旦发现配置文件中有 "root": true,它就会停止在父级目录中寻找。

{
  "root": true
}

例如projectA的lib/目录下的.eslintrc文件中设置了"root": true。这种情况当检测main.js时lib/下的配置将会被使用,projectA/下的.eslintrc将不会被使用。

home
└── user
    ├── .eslintrc <- Always skipped if other configs present
    └── projectA
        ├── .eslintrc  <- Not used
        └── lib
            ├── .eslintrc  <- { "root": true }
            └── main.js

完整的配置层次结构,从最高优先级最低的优先级,如下:
1、行内配置
/*eslint-disable*/ 和 /*eslint-enable*/
/*global*/
/*eslint*/
/*eslint-env*/
2、命令行选项(或 CLIEngine 等价物)：
--global
--rule
--env
-c、--config
3、项目级配置：
与要检测的文件在同一目录下的 .eslintrc.* 或 package.json 文件
继续在父级目录寻找 .eslintrc 或 package.json文件,直到根目录(包括根目录)或直到发现一个有"root": true的配置。
4、如果不是(1)到(3)中的任何一种情况,退回到 ~/.eslintrc 中自定义的默认配置

【 有两种方式使用配置文件 】
1、使用配置文件的第一种方式是通过.eslintrc.*和package.json文件。ESLint将自动在要检测的文件目录里寻找它们,紧接着是父级目录,一直到文件系统的根目录(除非指定root: true)。当想对一个项目的不同部分的使用不同配置,或当你希望别人能够直接使用ESLint,而无需记住要在配置文件中传递什么,这种方式就很有用。
2、第二种方式是使用 -c 选项传递命令行将文件保持到你喜欢的地方。
eslint -c myconfig.json myfiletotest.js

如果使用一个配置文件,想要ESLint忽略任.eslintrc.* 文件,请确保使用--no-eslintrc的同时加上-c标记。

每种情况,配置文件都会覆盖默认设置

可以被配置的信息主要分为3类：
Environments：指定脚本的运行环境,如：nodejs,browser,commonjs等,每种环境都有一组特定的预定义全局变量
Globals：脚步在执行期间需要访问的额外全局变量
Rules：启用的规则及其各自的错误级别

所有这些选项让你可以细粒度地控制ESLint如何对待代码

</pre><pre class="js">
module.exports = {
  "env": {
    "browser": true,
    "commonjs": true,
    "es6": true
  },
  "extends": "eslint:recommended",  //可以选择一些流行的style比如google
  "parserOptions": {
    "ecmaFeatures": {
      "experimentalObjectRestSpread": true,
      "jsx": true
    },
    "ecmaVersion": 7,               // javascript版本
    "sourceType": "module"
  },
  "plugins": [
    "react"                         // 插件,支持react
  ],
  "rules": {
    "indent": [ "error", "space" ]           // 缩进,可选项为off warn error对应的数字0 1 2
    "linebreak-style": [ "error", "unix" ]   // 换行的style
    "quotes": [ "error", "single" ]          // 引号是单的还是双的
    "semi": [ "error", "never" ]
  }
};

</pre>.eslintrc.js参考<pre class="js">
module.exports = {
  root: true,
  parser: 'babel-eslint',
  parserOptions: {
    sourceType: 'module'
  },
  env: {
    browser: true,
    node: true
  },
  extends: 'eslint:recommended',
  // required to lint *.vue files
  plugins: [
    'html'
  ],
  // check if imports actually resolve
  'settings': {
    'import/resolver': {
      'webpack': {
        'config': 'build/webpack.base.conf.js'
      }
    }
  },
  // add your custom rules here
  'rules': {
      // don't require .vue extension when importing
    // 'import/extensions': ['error', 'always', {
    //     'js': 'never',
    //     'vue': 'never'
    // }],
    // allow debugger during development
    'no-debugger': process.env.NODE_ENV === 'production' ? 2 : 0,
    /*
     * Possible Errors
     */

    // disallow unnecessary parentheses
    'no-extra-parens': ['error', 'all', {'nestedBinaryExpressions': false}],

    // disallow negating the left operand of relational operators
    'no-unsafe-negation': 'error',

    // enforce valid JSDoc comments
    'valid-jsdoc': 'off',

    /*
     * Best Practices
     */
    // enforce return statements in callbacks of array methods
    'array-callback-return': 'error',
    // enforce consistent brace style for all control statements
    curly: ['error', 'multi-line'],
    // enforce consistent newlines before and after dots
    'dot-location': ['error', 'property'],
    // enforce dot notation whenever possible
    'dot-notation': 'error',
    // require the use of === and !==
    'eqeqeq': ['error', 'smart'],
    // disallow the use of arguments.caller or arguments.callee
    'no-caller': 'error',
    // disallow empty functions
    'no-empty-function': 'error',
    // disallow unnecessary calls to .bind()
    'no-extra-bind': 'error',
    // disallow unnecessary labels
    'no-extra-label': 'error',
    // disallow leading or trailing decimal points in numeric literals
    'no-floating-decimal': 'error',
    // disallow assignments to native objects or read-only global variables
    'no-global-assign': 'error',
    // disallow the use of eval()-like methods
    'no-implied-eval': 'error',
    // disallow the use of the __iterator__ property
    'no-iterator': 'error',
    // disallow unnecessary nested blocks
    'no-lone-blocks': 'error',
    // disallow multiple spaces
    'no-multi-spaces': 'error',
    // disallow new operators with the String, Number, and Boolean objects
    'no-new-wrappers': 'error',
    // disallow octal escape sequences in string literals
    'no-octal-escape': 'error',
    // disallow the use of the __proto__ property
    'no-proto': 'error',
    // disallow comparisons where both sides are exactly the same
    'no-self-compare': 'error',
    // disallow throwing literals as exceptions
    'no-throw-literal': 'error',
    // disallow unused expressions
    'no-unused-expressions': 'error',
    // disallow unnecessary calls to .call() and .apply()
    'no-useless-call': 'error',
    // disallow unnecessary concatenation of literals or template literals
    'no-useless-concat': 'error',
    // disallow unnecessary escape characters
    'no-useless-escape': 'error',
    // disallow void operators
    'no-void': 'error',
    // require parentheses around immediate function invocations
    'wrap-iife': 'error',
    // require or disallow “Yoda” conditions
    yoda: 'error',

    /*
     * Variables
     */
    // disallow labels that share a name with a variable
    'no-label-var': 'error',
    // disallow initializing variables to undefined
    'no-undef-init': 'error',
    'no-undef': 'off',
    // disallow the use of variables before they are defined
    'no-use-before-define': 'error',

    /*
     * Node.js and CommonJS
     */
    // disallow new operators with calls to require
    'no-new-require': 'error',

    /*
     * Stylistic Issues
     */
    // enforce consistent spacing inside array brackets
    'array-bracket-spacing': 'error',
    // enforce consistent spacing inside single-line blocks
    'block-spacing': 'error',
    // enforce consistent brace style for blocks
    'brace-style': ['error', '1tbs', {'allowSingleLine': true}],
    // require or disallow trailing commas
    'comma-dangle': 'error',
    // enforce consistent spacing before and after commas
    'comma-spacing': 'error',
    // enforce consistent comma style
    'comma-style': 'error',
    // enforce consistent spacing inside computed property brackets
    'computed-property-spacing': 'error',
    // require or disallow spacing between function identifiers and their invocations
    'func-call-spacing': 'error',
    // enforce consistent indentation
    indent: ['error', 2, {SwitchCase: 1}],
    // enforce the consistent use of either double or single quotes in JSX attributes
    'jsx-quotes': 'error',
    // enforce consistent spacing between keys and values in object literal properties
    'key-spacing': 'error',
    // enforce consistent spacing before and after keywords
    'keyword-spacing': 'error',
    // enforce consistent linebreak style
    'linebreak-style': 'error',
    // require or disallow newlines around directives
    'lines-around-directive': 'error',
    // require constructor names to begin with a capital letter
    'new-cap': 'off',
    // require parentheses when invoking a constructor with no arguments
    'new-parens': 'error',
    // disallow Array constructors
    'no-array-constructor': 'error',
    // disallow Object constructors
    'no-new-object': 'error',
    // disallow trailing whitespace at the end of lines
    'no-trailing-spaces': 'error',
    // disallow ternary operators when simpler alternatives exist
    'no-unneeded-ternary': 'error',
    // disallow whitespace before properties
    'no-whitespace-before-property': 'error',
    // enforce consistent spacing inside braces
    'object-curly-spacing': ['error', 'always'],
    // require or disallow padding within blocks
    'padded-blocks': ['error', 'never'],
    // require quotes around object literal property names
    'quote-props': ['error', 'as-needed'],
    // enforce the consistent use of either backticks, double, or single quotes
    quotes: ['error', 'single'],
    // enforce consistent spacing before and after semicolons
    'semi-spacing': 'error',
    // require or disallow semicolons instead of ASI
    // semi: ['error', 'never'],
    // enforce consistent spacing before blocks
    'space-before-blocks': 'error',
    'no-console': 'off',
    // enforce consistent spacing before function definition opening parenthesis
    'space-before-function-paren': ['error', 'never'],
    // enforce consistent spacing inside parentheses
    'space-in-parens': 'error',
    // require spacing around infix operators
    'space-infix-ops': 'error',
    // enforce consistent spacing before or after unary operators
    'space-unary-ops': 'error',
    // enforce consistent spacing after the // or /* in a comment
    'spaced-comment': 'error',
    // require or disallow Unicode byte order mark(BOM)
    'unicode-bom': 'error',

    /*
     * ECMAScript 6
     */
    // require braces around arrow function bodies
    'arrow-body-style': 'error',
    // require parentheses around arrow function arguments
    'arrow-parens': ['error', 'as-needed'],
    // enforce consistent spacing before and after the arrow in arrow functions
    'arrow-spacing': 'error',
    // enforce consistent spacing around * operators in generator functions
    'generator-star-spacing': ['error', 'after'],
    // disallow duplicate module imports
    'no-duplicate-imports': 'error',
    // disallow unnecessary computed property keys in object literals
    'no-useless-computed-key': 'error',
    // disallow unnecessary constructors
    'no-useless-constructor': 'error',
    // disallow renaming import, export, and destructured assignments to the same name
    'no-useless-rename': 'error',
    // require let or const instead of var
    'no-var': 'error',
    // require or disallow method and property shorthand syntax for object literals
    'object-shorthand': 'error',
    // require arrow functions as callbacks
    'prefer-arrow-callback': 'error',
    // require const declarations for variables that are never reassigned after declared
    'prefer-const': 'error',
    // disallow parseInt() in favor of binary, octal, and hexadecimal literals
    'prefer-numeric-literals': 'error',
    // require rest parameters instead of arguments
    'prefer-rest-params': 'error',
    // require spread operators instead of .apply()
    'prefer-spread': 'error',
    // enforce spacing between rest and spread operators and their expressions
    'rest-spread-spacing': 'error',
    // require or disallow spacing around embedded expressions of template strings
    'template-curly-spacing': 'error',
    // require or disallow spacing around the * in yield* expressions
    'yield-star-spacing': 'error'
  }
}

</pre><pre>
【 package.json中使用eslint 】
eslint merge.js   // 无输出则检查通过

使用内置的eslint:recommended配置,它包含了一系列核心规则,能报告一些常见的问题

</pre><pre class="js">
"eslintConfig": {
    "extends": "eslint:recommended",
    "env": {
      "node": true
    },
    "rules": {
      "no-console": "off",
      "indent": [ "error", 2 ],
      "quotes": [ "error", "single" ]
    }
  }

</pre><pre>
【 eslint配置项 】
root 限定配置文件的使用范围
parser 指定eslint的解析器
parserOptions 设置解析器选项
extends 指定eslint规范
plugins 引用第三方的插件
env 指定代码运行的宿主环境
rules 启用额外的规则或覆盖默认的规则
globals 声明在代码中的自定义全局变量

【 配置语言 】
ESLint允许指定想要支持的js语言选项,默认ESLint支持ECMAScript5语法,可以覆盖该设置以启用对ECMAScript其它版本和JSX的支持

ecmaVersion
默认设置为3,5(默认),可以使用6、7、8或9来指定想要使用的ECMAScript版本,也可以用使用年份命名的版本号指定为2015(同 6),2016(同 7),或2017(同 8)或2018(同 9)

sourceType
设置为"script"(默认)或"module"(如果代码是ECMAScript模块)

ecmaFeatures
这是个对象,表示想使用的额外的语言特性:
globalReturn - 允许在全局作用域下使用return语句
impliedStrict - 启用全局strict mode (如果ecmaVersion是5或更高)
jsx - 启用JSX
experimentalObjectRestSpread - 启用实验性的object rest/spread properties支持
　　
</pre><pre class="js">
"parserOptions": {
  "ecmaVersion": 6,
  "sourceType": "module",
  "ecmaFeatures": {
    "jsx": true
  }
}

</pre><pre>
【 自动修复,代码格式化 】
在ESLint规则列表页面,有些规则的旁边会带有一个橙色扳手图标,表示在执行eslint命令时指定--fix参数可以自动修复该问题。
目前大部分是对空白的修复
可以利用这个特性来自动格式化项目代码,这样就可以保证代码书写风格的统一

eslint merge.js --fix

【 配置继承 】
一个配置文件可以被基础配置中的已启用的规则继承
eslint配置文件中的rules配置项是可以缺省的,可以通过配置extends配置项使用第三方的

extends 属性值可以是：
1、指定配置的字符串(配置文件的路径、可共享配置的名称、eslint:recommended或eslint:all)
2、字符串数组：每个配置继承它前面的配置

ESLint递归地扩展配置,因此基本配置也可以具有extends属性。extends属性中的相对路径和可共享配置名从配置文件中出现的位置解析。

rules属性可以做下面的任何事情以扩展或覆盖规则：
1、启用额外的规则
2、改变继承的规则级别而不改变它的选项：
基础配置："eqeqeq": ["error", "allow-null"]
派生的配置："eqeqeq": "warn"
最后生成的配置："eqeqeq": ["warn", "allow-null"]
3、覆盖基础配置中的规则的选项
基础配置："quotes": ["error", "single", "avoid-escape"]
派生的配置："quotes": ["error", "single"]
最后生成的配置："quotes": ["error", "single"]

extends属性值可以是基本配置文件的绝对路径或相对路径。 ESLint解析基本配置文件的相对路径相对使用的配置文件,除非那个文件在主目录或非ESLint安装目录的父级目录。在这些情况下ESLint解析基本配合文件的相对路径相对于被检测的项目目录(尤其是当前工作目录)

</pre><pre class="js">
{
  "extends": [
    "./node_modules/coding-standard/eslintDefaults.js",
    "./node_modules/coding-standard/.eslintrc-es6",
    "./node_modules/coding-standard/.eslintrc-jsx"
  ],
  "rules": {
    "eqeqeq": "warn"
  }
}

</pre><pre>
可以使用eslint官方推荐的,也可以使用一些大公司提供的的如：aribnb, google, standard,在开发中一般使用第三方的。

1、官方推荐
extends: 'eslint:recommended',
extends: 'eslint:all',

值为"eslint:recommended"的extends属性启用一系列核心规则,这些规则报告一些常见问题,这个推荐的子集只能在ESLint主要版本进行更新

如果你的配置集成了推荐的规则：在升级到ESLint新的主版本之后,在使用命令行的--fix选项之前,检查一下报告的问题,这样就知道一个新的可修复的推荐的规则将更改代码。

eslint --init命令可以创建一个配置,这样就可以继承推荐的规则。

</pre>js格式的一个配置文件的例子<pre class="js">
module.exports = {
  "extends": "eslint:recommended",
  "rules": {
    // enable additional rules
    "indent": ["error", 4],
    "linebreak-style": ["error", "unix"],
    "quotes": ["error", "double"],
    "semi": ["error", "always"],

    // override default options for rules from base configurations
    "comma-dangle": ["error", "always"],
    "no-cond-assign": ["error", "always"],

    // disable rules from base configurations
    "no-console": "off",
  }
}

</pre><pre>
2、第三方分享
使用第三方分享的,一般需要安装相关的插件代码
npm install --save-dev eslint-config-airbnb   // bnb
npm install --save-dev eslint-config-standard // standard
在.eslintrc.js中添加如下代码：
extends: 'eslint:google',
// or
extends: 'eslint:standard',

使用这些第三方的扩展,有时需要更新一些插件,如standard：eslint-plugin-import,只要按照错误提示一步一步的安装这些插件即可。

虽然这些第三方的扩展很不错,但需要定义一些比较个性化的规则时就需要添加rules配置项

</pre><pre>
【 配置规则 】
在.eslintrc.js文件中添加rules, 代码如下：
{
  "rules": {
    "semi": ["error", "always"],
    "quotes": ["error", "double"]
  }
}

"semi" 和 "quotes" 是 ESLint 中 规则 的名称。第一个值是错误级别,可以使下面的值之一：
"off" or 0 - 关闭规则
"warn" or 1 - 将规则视为一个警告(不会影响退出码)
"error" or 2 - 将规则视为一个错误 (退出码为1)

这些规则一般分为两类：
添加默认或第三库中没有的
覆盖默认或第三库的

【 plugins:配置插件 】
项目中可能会有一些其他的文件也需要进行格式规范,如html、vue、react等,对于这些文件的处理则需要引入第三方插件。

ESLint支持使用第三方插件,在使用插件之前必须使用npm安装
插件是一个npm包,通常输出规则。一些插件也可以输出一个或多个命名的配置。要确保这个包安装在ESLint能请求到的目录下

插件是相对于ESLint进程的当前工作目录解析的,即ESLint将加载与用户通过从项目Node交互解释器运行('eslint-plugin-pluginname')获得的相同的插件

在配置文件里配置插件时可以使用plugins关键字来存放插件名字的列表,插件名称可以省略eslint-plugin-前缀

</pre><pre class="js">
{
  "plugins": [ "plugin1", "eslint-plugin-plugin2" ]
}

</pre><pre>
由于Node.js的require函数的行为,全局安装的ESLint实例只能使用全局安装的ESLint插件,本地安装的版本只能用本地安装的插件,不支持混合本地和全局插件

</pre><pre class="js">
{
  "plugins": [
    "react"
  ],
  "extends": [
    "eslint:recommended",
    "plugin:react/recommended"
  ],
  "rules": {
    "no-set-state": "off"
  }
}

</pre><pre>
安装eslint-plugin-html：
npm install --save-dev eslint-plugin-html
这个插件将会提醒模块脚本之间模拟浏览器共享全局变量的行为,因为这不适用于模块脚本。这个插件也可以扩展文件如.vue,.jsx

.eslintrc.js中,添加如下配置项：
settings: {
  'html/html-extensions': ['.html', '.vue'],
  'html/indent': '+2',
},

而对于这种用eslint-pulgin-html扩展的的文件可使用eslint --ext .html,.vue src 进行检测,如果想要在开发中边写边检测,可以使用相应文件的loader进行处理。然后执行npm run dev就可以实现边写边检测的功能。

在开发中有时根据需要可能在同一个项目不同的目录使用不同的.eslintrc.js文件,这时就需要使用配置项root

【 限定使用范围 (root: true) 】
如果想要在不同的目录中使用不同的.eslintrc就需要在该目录中添加如下的配置项：
{
  "root": true
}
如果不设置的话,它将会继续查找直到根目录,如果根目录有配置文件它将会使用根目录的,这样会导致当前配置目录配置无法起作用的问题。

【 parser：指定解析器 】
ESLint默认使用Espree作为其解析器,可以在配置文件中指定一个不同的解析器,只要该解析器符合下列要求：
1、必须是一个Node模块,可以从它出现的配置文件中加载。通常这意味着应该使用npm单独安装解析器包。
2、必须符合parser interface。

即使满足这些兼容性要求,也不能保证一个外部解析器可以与ESLint正常配合工作,ESLint也不会修复与其它解析器不兼容的相关bug

为了表明使用该npm模块作为解析器,需要在.eslintrc文件里指定parser选项

</pre>指定了Esprima作为解析器<pre class="js">
{
  "parser": "esprima",
  "rules": {
    "semi": "error"
  }
}

</pre><pre>
以下解析器与ESLint兼容：
1、Esprima
2、Babel-ESLint：一个对Babel解析器的包装,使其能够与ESLint兼容。
3、@typescript-eslint/parser：将TypeScript转换成与estree兼容的形式,以便在ESLint中使用。

在使用自定义解析器时,为了让ESLint在处理非ECMAScript 5特性时正常工作,配置属性parserOptions仍然是必须的。解析器会被传入parserOptions,但是不一定会使用它们来决定功能特性的开关

在开发中针对不同的情况要使用不同的解析器,而常用的就是babel-eslint
babel-eslint解析器是一种使用频率很高的解析器,因为现在很多公司的很多项目目前都使用了es6,为了兼容性考虑基本都使用babel插件对代码进行编译,而用babel编译后的代码使用babel-eslint这款解析器可以避免不必要的麻烦。

安装：
npm install --save-dev babel-eslint
在.eslintrc.js配置文件中添加如下配置项代码：
parser: 'babel-eslint',

如果使用的默认解析器的话,且在代码中使用了浏览器有兼容性的问题的js新特性,使用webpack编译就会出现问题,这时一般装最新的eslint或安装是使用babel-eslint来解决问题。

【 parserOptions 】
ESLint允许指定想要支持的Js语言选项,默认ESLint支持ECMAScript5语法,可以覆盖该设置以启用对ECMAScript其它版本和JSX的支持。
设置解析器选项能帮助ESLint确定什么是解析错误,所有语言选项默认都是false

支持JSX语法并不等同于支持React,React对ESLint无法识别的JSX语法应用特定的语义。如果正在使用React并且想要React语义支持,建议使用eslint-plugin-react。

同样的,支持ES6语法并不意味着同时支持新的ES6全局变量或类型(如Set等新类型)。对于ES6语法使用 { "parserOptions": { "ecmaVersion": 6 } };对于新的ES6全局变量,使用 { "env":{ "es6": true } }自动启用es6语法,但{ "parserOptions": { "ecmaVersion": 6 } } 不自动启用es6全局变量。

解析器选项可以在.eslintrc.*文件使用parserOptions属性设置,可用的选项有：
1、ecmaVersion
默认设置为3,5(默认), 可以使用6、7、8、9或10来指定想要使用的ECMAScript版本,也可以用使用年份命名的版本号指定为2015(同6),2016(同7),或2017(同8)或2018(同9)或2019 (same as 10)

2、sourceType
设置为"script" (默认) 或 "module"(如果代码是ECMAScript模块)

3、ecmaFeatures - 这是个对象,表示想使用的额外的语言特性:
globalReturn - 允许在全局作用域下使用return语句
impliedStrict - 启用全局strict mode,如果ecmaVersion是5或更高)
jsx - 启用JSX
experimentalObjectRestSpread - 启用实验性的object rest/spread properties支持,这是一个实验性的功能,在未来可能会有明显改变。 建议写的规则不要依赖该功能,除非当它发生改变时愿意承担维护成本

</pre><pre class="js">
{
  "parserOptions": {
    "ecmaVersion": 6,
    "sourceType": "module",
    "ecmaFeatures": {
      "jsx": true
    }
  },
  "rules": {
    "semi": "error"
  }
}

</pre><pre>
【 Processor处理器 】
插件可以提供处理器。处理器可以从另一种文件中提取js代码,然后让ESLint检测js代码,或者处理器可以在预处理中转换js代码。

在配置文件中使用processor键指定处理器,并使用由插件名和处理器名组成的串接字符串加上斜杠

</pre>启用插件a-plugin提供的处理器a-processor<pre class="js">
{
  "plugins": ["a-plugin"],
  "processor": "a-plugin/a-processor"
}

</pre>使用overrides键和processor键的组合为特定类型的文件指定处理器,如对*.md文件使用处理器a-plugin/markdown<pre class="js">
{
  "plugins": ["a-plugin"],
  "overrides": [
    {
      "files": ["*.md"],
      "processor": "a-plugin/markdown"
    }
  ]
}

</pre>处理器可以生成命名的代码块如0.js和1.js,ESLint将这样的命名代码块作为原始文件的子文件处理,可以在配置的overrides部分为已命名的代码块指定附加配置,如对以.js结尾的markdown文件中的已命名代码块禁用strict规则<pre class="js">
{
  "plugins": ["a-plugin"],
  "overrides": [
    {
      "files": ["*.md"],
      "processor": "a-plugin/markdown"
    },
    {
      "files": ["**/*.md/*.js"],
      "rules": {
        "strict": "off"
      }
    }
  ]
}

</pre><pre>
ESLint检查指定代码块的文件扩展名,如果--ext CLI option不包含文件扩展名则忽略这些扩展名。如果想要删除除*.js之外的已命名代码块,请确保指定--ext选项

【 配置env 】
Js有很多种运行环境,如常见的有浏览器和Node.js,另外还有很多软件系统使用js作为其脚本引擎,如PostgreSQL就支持使用js来编写存储引擎,而这些运行环境可能并不存在console这个对象。另外在浏览器环境下会有window对象,而Node.js下没有;在Node.js下会有process对象,而浏览器环境下没有

一个环境定义了一组预定义的全局变量。这些环境并不是互斥的,可以同时定义多个

browser - 浏览器环境中的全局变量。
node - Node.js全局变量和Node.js作用域。
commonjs - CommonJS全局变量和CommonJS作用域(用于Browserify/WebPack打包的只在浏览器中运行的代码)。
shared-node-browser - Node.js和Browser通用全局变量。
es6 - 启用除了modules以外的所有ECMAScript 6特性,该选项会自动设置ecmaVersion解析器选项为6
worker - Web Workers全局变量。
amd - 将require()和define()定义为像amd一样的全局变量。
mocha - 添加所有的Mocha测试全局变量。
jasmine - 添加所有的Jasmine版本1.3和2.0的测试全局变量。
jest - Jest全局变量。
phantomjs - PhantomJS全局变量。
protractor - Protractor全局变量。
qunit - QUnit全局变量。
jquery - jQuery全局变量。
prototypejs - Prototype.js全局变量。
shelljs - ShellJS全局变量。
meteor - Meteor全局变量。
mongo - MongoDB全局变量。
applescript - AppleScript全局变量。
nashorn - Java 8 Nashorn全局变量。
serviceworker - Service Worker全局变量。
atomtest - Atom测试全局变量。
embertest - Ember测试全局变量。
webextensions - WebExtensions全局变量。
greasemonkey - GreaseMonkey全局变量。

可以在源文件里、在配置文件中或使用命令行的--env选项来指定环境。

在js文件中使用注释来指定环境,如启用Node.js和Mocha环境
/* eslint-env node, mocha */

要在配置文件里指定环境,使用env关键字指定想启用的环境并设置它们为true

</pre>启用了browser和Node.js的环境<pre class="js">
{
  "env": {
    "browser": true,
    "node": true
  }
}

// 或在package.json文件中：
{
  "name": "mypackage",
  "version": "0.0.1",
  "eslintConfig": {
    "env": {
      "browser": true,
      "node": true
    }
  }
}

</pre><pre class="js">
// 指定了环境就可以放心的使用它们的全局变量和属性
"env": {
  "browser": true,
  "node": true
}

// 指定全局变量
"globals": {
  "var1": true,
  "var2": false
}

</pre>若想在一个特定的插件中使用一种环境,应提前在plugins数组里指定插件名,再在env配置中不带前缀的插件名/环境名<pre class="js">
{
  "name": "mypackage",
  "version": "0.0.1",
  "eslintConfig": {
    "plugins": ["example"],
    "env": {
      "example/custom": true
    }
  }
}

</pre><pre>
【 Globals 】
当访问当前源文件内未定义的变量时,no-undef规则将发出警告。如果想在一个源文件里使用全局变量,推荐在ESLint中定义这些全局变量,这样ESLint就不会发出警告了,可以使用注释或在配置文件中定义全局变量。

在js文件中用注释指定全局变量格式：
/* global var1, var2 */

这定义了两个全局变量var1和var2。如果想选择性地指定这些全局变量可以被写入(而不是只被读取),那么可以用一个"writable"的标志来设置它们:
/* global var1:writable, var2:writable */

要在配置文件中配置全局变量,请将globals配置属性设置为一个对象,该对象包含以希望使用的每个全局变量。对于每个全局变量键,将对应的值设置为"writable"以允许重写变量,或"readonly"不允许重写变量

</pre>var1允许被重写,var2不允许被重写<pre class="js">
{
  "globals": {
    "var1": "writable",
    "var2": "readonly"
  }
}

</pre>可以使用字符串"off"禁用全局变量,如在大多数ES2015全局变量可用但Promise不可用的环境中可以使用以下配置<pre class="js">
{
  "env": {
    "es6": true
  },
  "globals": {
    "Promise": "off"
  }
}

</pre><pre>
由于历史原因布尔值false和字符串值"readable"等价于"readonly",布尔值true和字符串值"writeable"等价于"writable",但不建议使用旧值。

要启用no-global-assign规则来禁止对只读的全局变量进行修改

【 临时禁用规则 】
ESLint提供了多种临时禁用规则的方式,比如可以通过一条eslint-disable-next-line备注来使得下一行可以跳过检查：

// eslint-disable-next-line
var a = 123;
var b = 456;

【 Disabling Rules Only for a Group of Files 】
若要禁用一组文件的配置文件中的规则,请使用overrides和files

</pre><pre class="js">
{
  "rules": {...},
  "overrides": [
    {
      "files": ["*-test.js","*.spec.js"],
      "rules": {
        "no-unused-expressions": "off"
      }
    }
  ]
}

</pre><pre>
【 配置忽略 】
可以通过在项目根目录创建一个.eslintignore文件告诉ESLint去忽略特定的文件和目录
.eslintignore文件是一个纯文本文件,其中的每一行都是一个glob模式表明哪些路径应该忽略检测

以下将忽略所有的js文件：
**/*.js

如果没有发现.eslintignore文件,也没有指定替代文件,ESLint将在package.json文件中查找eslintIgnore键来检查要忽略的文件

</pre><pre class="js">
{
  "name": "mypackage",
  "version": "0.0.1",
  "eslintConfig": {
    "env": {
      "browser": true,
      "node": true
    }
  },
  "eslintIgnore": ["hello.js", "world.js"]
}

</pre><pre>
【 Adding Shared Settings 】
ESLint支持在配置文件添加共享设置,可以添加settings对象到配置文件,它将提供给每一个将被执行的规则。如果想添加的自定义规则而且使它们可以访问到相同的信息,这将会很有用,并且很容易配置。

</pre>在JSON中<pre class="js">
{
  "settings": {
    "sharedData": "Hello"
  }
}

</pre><pre>
【 使用共享的配置文件 】
使用配置js文件是以extends: 'eslint:recommended'为基础配置,但是大多数时候我们需要制定很多规则,在一个文件中写入会变得很臃肿,管理起来会很麻烦。

可以将定义好规则的.eslintrc.js文件存储到一个公共的位置。改个名字比如public-eslintrc.js。在文件内容添加一两个规则

</pre><pre class="js">
module.exports = {
  extends: 'eslint:recommended',
  env: {
    node: true,
  },
  rules: {
    'no-console': 'off',
    'indent': [ 'error', 2 ],
    'quotes': [ 'error', 'single' ],
  },
};

// 然后将原来的.eslintrc.js文件改成这样：留下一个extends,指定一个文件名或一个eslint-config-开头的模块名
module.exports = {
  extends: './public-eslintrc.js',
};

</pre>

<h4>规则</h4><pre>
ESLint附带有大量的规则,可以使用注释或配置文件修改项目中要使用的规则。每条规则有3个等级,要改变一个规则设置,必须将规则ID设置为下列值之一：
"off"或0 - 关闭规则
"warn"或1 - 开启规则,使用警告级别的错误：warn (不会导致程序退出)
"error"或2 - 开启规则,使用错误级别的错误：error (当被触发的时候程序会退出,检查不通过)

在文件注释里配置规则使用以下格式的注释：eqeqeq规则被关闭,curly规则被打开,定义为错误级别
/* eslint eqeqeq: "off", curly: "error" */
也可以使用对应的数字定义规则严重程度：
/* eslint eqeqeq: 0, curly: 2 */
如果一个规则有额外的选项,可使用数组字面量指定它们,如为规则quotes指定了“double”选项,数组的第一项总是规则的严重程度(数字或字符串)
/* eslint quotes: ["error", "double"], curly: 2 */

</pre>也可以在配置文件中进行规则配置<pre class="js">
{
  "rules": {
    "eqeqeq": "off",
    "curly": "error",
    "quotes": ["error", "double"]
  }
}

</pre>配置定义在插件中的一个规则的时候必须使用插件名/规则ID的形式<pre class="js">
{
  "plugins": [
    "plugin1"
  ],
  "rules": {
    "eqeqeq": "off",
    "curly": "error",
    "quotes": ["error", "double"],
    "plugin1/rule1": "error"        // 来自插件plugin1的rule1规则,当指定来自插件的规则时确保删除eslint-plugin-前缀。ESLint在内部只使用没有前缀的名称去定位规则
  }
}

</pre><pre>
也可以使用这种格式的注释配置
/* eslint "plugin1/rule1": "error" */

有些规则还带有可选的参数,如comma-dangle可写成[ "error", "always-multiline" ];no-multi-spaces可写成[ "error", { exceptions: { "ImportDeclaration": true }}]

为了让你对规则有个更好的理解,ESLint对其进行了分门别类。
所有的规则默认都是禁用的。在配置文件中使用 "extends": "eslint:recommended" 来启用推荐的规则,报告一些常见的问题,在下文中这些推荐的规则都带有一个✔标记
命令行的 --fix 选项用来自动修复规则所报告的问题,目前大部分是对空白的修复,在下文中会有一个✎的图标

</pre>

<p><b>Possible Errors: 这些规则与js代码中可能的错误或逻辑错误有关</b></p>
<table>
<tr><td>✔</td><td></td><td>for-direction</td><td>强制 “for” 循环中更新子句的计数器朝着正确的方向移动</td></tr>
<tr><td>✔</td><td></td><td>getter-return</td><td>强制 getter 函数中出现 return 语句</td></tr>
<tr><td>✔</td><td></td><td>no-async-promise-executor</td><td>禁止使用异步函数作为 Promise executor</td></tr>
<tr><td></td><td></td><td>no-await-in-loop</td><td>禁止在循环中出现 await</td></tr>
<tr><td>✔</td><td></td><td>no-compare-neg-zero</td><td>禁止与 -0 进行比较</td></tr>
<tr><td>✔</td><td></td><td>no-cond-assign</td><td>禁止条件表达式中出现赋值操作符</td></tr>
<tr><td></td><td></td><td>no-console</td><td>禁用 console</td></tr>
<tr><td>✔</td><td></td><td>no-constant-condition</td><td>禁止在条件中使用常量表达式</td></tr>
<tr><td>✔</td><td></td><td>no-control-regex</td><td>禁止在正则表达式中使用控制字符</td></tr>
<tr><td>✔</td><td></td><td>no-debugger</td><td>禁用 debugger</td></tr>
<tr><td>✔</td><td></td><td>no-dupe-args</td><td>禁止 function 定义中出现重名参数</td></tr>
<tr><td>✔</td><td></td><td>no-dupe-keys</td><td>禁止对象字面量中出现重复的 key</td></tr>
<tr><td>✔</td><td></td><td>no-duplicate-case</td><td>禁止出现重复的 case 标签</td></tr>
<tr><td>✔</td><td></td><td>no-empty</td><td>禁止出现空语句块</td></tr>
<tr><td>✔</td><td></td><td>no-empty-character-class</td><td>禁止在正则表达式中使用空字符集</td></tr>
<tr><td>✔</td><td></td><td>no-ex-assign</td><td>禁止对 catch 子句的参数重新赋值</td></tr>
<tr><td>✔</td><td>✎</td><td>no-extra-boolean-cast</td><td>禁止不必要的布尔转换</td></tr>
<tr><td></td><td>✎</td><td>no-extra-parens</td><td>禁止不必要的括号</td></tr>
<tr><td>✔</td><td>✎</td><td>no-extra-semi</td><td>禁止不必要的分号</td></tr>
<tr><td>✔</td><td></td><td>no-func-assign</td><td>禁止对function声明重新赋值</td></tr>
<tr><td>✔</td><td></td><td>no-inner-declarations</td><td>禁止在嵌套的块中出现变量声明或 function 声明</td></tr>
<tr><td>✔</td><td></td><td>no-invalid-regexp</td><td>禁止 RegExp 构造函数中存在无效的正则表达式字符串</td></tr>
<tr><td>✔</td><td></td><td>no-irregular-whitespace</td><td>禁止不规则的空白</td></tr>
<tr><td>✔</td><td></td><td>no-misleading-character-class</td><td>不允许在字符类语法中出现由多个代码点组成的字符</td></tr>
<tr><td>✔</td><td></td><td>no-obj-calls</td><td>禁止把全局对象作为函数调用</td></tr>
<tr><td>✔</td><td></td><td>no-prototype-builtins</td><td>禁止直接调用 Object.prototypes 的内置属性</td></tr>
<tr><td>✔</td><td>✎</td><td>no-regex-spaces</td><td>禁止正则表达式字面量中出现多个空格</td></tr>
<tr><td>✔</td><td></td><td>no-sparse-arrays</td><td>禁用稀疏数组</td></tr>
<tr><td></td><td></td><td>no-template-curly-in-string</td><td>禁止在常规字符串中出现模板字面量占位符语法</td></tr>
<tr><td>✔</td><td></td><td>no-unexpected-multiline</td><td>禁止出现令人困惑的多行表达式</td></tr>
<tr><td>✔</td><td></td><td>no-unreachable</td><td>禁止在return、throw、continue和break语句之后出现不可达代码</td></tr>
<tr><td>✔</td><td></td><td>no-unsafe-finally</td><td>禁止在 finally 语句块中出现控制流语句</td></tr>
<tr><td>✔</td><td>✎</td><td>no-unsafe-negation</td><td>禁止对关系运算符的左操作数使用否定操作符</td></tr>
<tr><td>✔</td><td></td><td>require-atomic-updates</td><td>禁止由于await或yield的使用而可能导致出现竞态条件的赋值</td></tr>
<tr><td>✔</td><td></td><td>use-isnan</td><td>要求使用 isNaN() 检查 NaN</td></tr>
<tr><td>✔</td><td></td><td>valid-typeof</td><td>强制 typeof 表达式与有效的字符串进行比较</td></tr>
</table>

<p><b>Best Practices: 这些规则是关于最佳实践的,帮助你避免一些问题</b></p>
<table>
<tr><td></td><td></td><td>accessor-pairs</td><td>强制 getter 和 setter 在对象中成对出现</td></tr>
<tr><td></td><td></td><td>array-callback-return</td><td>强制数组方法的回调函数中有 return 语句</td></tr>
<tr><td></td><td></td><td>block-scoped-var</td><td>强制把变量的使用限制在其定义的作用域范围内</td></tr>
<tr><td></td><td></td><td>class-methods-use-this</td><td>强制类方法使用 this</td></tr>
<tr><td></td><td></td><td>complexity</td><td>指定程序中允许的最大环路复杂度</td></tr>
<tr><td></td><td></td><td>consistent-return</td><td>要求 return 语句要么总是指定返回的值,要么不指定</td></tr>
<tr><td></td><td>✎</td><td>curly</td><td>强制所有控制语句使用一致的括号风格</td></tr>
<tr><td></td><td></td><td>default-case</td><td>要求 switch 语句中有 default 分支</td></tr>
<tr><td></td><td>✎</td><td>dot-location</td><td>强制在点号之前和之后一致的换行</td></tr>
<tr><td></td><td>✎</td><td>dot-notation</td><td>强制尽可能地使用点号</td></tr>
<tr><td></td><td>✎</td><td>eqeqeq</td><td>要求使用 === 和 !==</td></tr>
<tr><td></td><td></td><td>guard-for-in</td><td>要求 for-in 循环中有一个 if 语句</td></tr>
<tr><td></td><td></td><td>max-classes-per-file</td><td>强制每个文件中包含的的类的最大数量</td></tr>
<tr><td></td><td></td><td>no-alert</td><td>禁用 alert、confirm 和 prompt</td></tr>
<tr><td></td><td></td><td>no-caller</td><td>禁用 arguments.caller 或 arguments.callee</td></tr>
<tr><td>✔</td><td></td><td>no-case-declarations</td><td>不允许在 case 子句中使用词法声明</td></tr>
<tr><td></td><td>✎</td><td>no-div-regex</td><td>禁止除法操作符显式的出现在正则表达式开始的位置</td></tr>
<tr><td></td><td>✎</td><td>no-else-return</td><td>禁止 if 语句中 return 语句之后有 else 块</td></tr>
<tr><td></td><td></td><td>no-empty-function</td><td>禁止出现空函数</td></tr>
<tr><td>✔</td><td></td><td>no-empty-pattern</td><td>禁止使用空解构模式</td></tr>
<tr><td></td><td></td><td>no-eq-null</td><td>禁止在没有类型检查操作符的情况下与 null 进行比较</td></tr>
<tr><td></td><td></td><td>no-eval</td><td>禁用 eval()</td></tr>
<tr><td></td><td></td><td>no-extend-native</td><td>禁止扩展原生类型</td></tr>
<tr><td></td><td>✎</td><td>no-extra-bind</td><td>禁止不必要的 .bind() 调用</td></tr>
<tr><td></td><td>✎</td><td>no-extra-label</td><td>禁用不必要的标签</td></tr>
<tr><td>✔</td><td></td><td>no-fallthrough</td><td>禁止 case 语句落空</td></tr>
<tr><td></td><td>✎</td><td>no-floating-decimal</td><td>禁止数字字面量中使用前导和末尾小数点</td></tr>
<tr><td>✔</td><td></td><td>no-global-assign</td><td>禁止对原生对象或只读的全局对象进行赋值</td></tr>
<tr><td></td><td>✎</td><td>no-implicit-coercion</td><td>禁止使用短符号进行类型转换</td></tr>
<tr><td></td><td></td><td>no-implicit-globals</td><td>禁止在全局范围内使用变量声明和 function 声明</td></tr>
<tr><td></td><td></td><td>no-implied-eval</td><td>禁止使用类似 eval() 的方法</td></tr>
<tr><td></td><td></td><td>no-invalid-this</td><td>禁止 this 关键字出现在类和类对象之外</td></tr>
<tr><td></td><td></td><td>no-iterator</td><td>禁用 __iterator__ 属性</td></tr>
<tr><td></td><td></td><td>no-labels</td><td>禁用标签语句</td></tr>
<tr><td></td><td></td><td>no-lone-blocks</td><td>禁用不必要的嵌套块</td></tr>
<tr><td></td><td></td><td>no-loop-func</td><td>禁止在循环语句中出现包含不安全引用的函数声明</td></tr>
<tr><td></td><td></td><td>no-magic-numbers</td><td>禁用魔术数字</td></tr>
<tr><td></td><td>✎</td><td>no-multi-spaces</td><td>禁止使用多个空格</td></tr>
<tr><td></td><td></td><td>no-multi-str</td><td>禁止使用多行字符串</td></tr>
<tr><td></td><td></td><td>no-new</td><td>禁止使用 new 以避免产生副作用</td></tr>
<tr><td></td><td></td><td>no-new-func</td><td>禁止对 Function 对象使用 new 操作符</td></tr>
<tr><td></td><td></td><td>no-new-wrappers</td><td>禁止对 String,Number 和 Boolean 使用 new 操作符</td></tr>
<tr><td>✔</td><td></td><td>no-octal</td><td>禁用八进制字面量</td></tr>
<tr><td></td><td></td><td>no-octal-escape</td><td>禁止在字符串中使用八进制转义序列</td></tr>
<tr><td></td><td></td><td>no-param-reassign</td><td>禁止对 function 的参数进行重新赋值</td></tr>
<tr><td></td><td></td><td>no-proto</td><td>禁用 __proto__ 属性</td></tr>
<tr><td>✔</td><td></td><td>no-redeclare</td><td>禁止多次声明同一变量</td></tr>
<tr><td></td><td></td><td>no-restricted-properties</td><td>禁止使用对象的某些属性</td></tr>
<tr><td></td><td></td><td>no-return-assign</td><td>禁止在 return 语句中使用赋值语句</td></tr>
<tr><td></td><td></td><td>no-return-await</td><td>禁用不必要的 return await</td></tr>
<tr><td></td><td></td><td>no-script-url</td><td>禁止使用 javascript: url</td></tr>
<tr><td>✔</td><td></td><td>no-self-assign</td><td>禁止自我赋值</td></tr>
<tr><td></td><td></td><td>no-self-compare</td><td>禁止自身比较</td></tr>
<tr><td></td><td></td><td>no-sequences</td><td>禁用逗号操作符</td></tr>
<tr><td></td><td></td><td>no-throw-literal</td><td>禁止抛出异常字面量</td></tr>
<tr><td></td><td></td><td>no-unmodified-loop-condition</td><td>禁用一成不变的循环条件</td></tr>
<tr><td></td><td></td><td>no-unused-expressions</td><td>禁止出现未使用过的表达式</td></tr>
<tr><td>✔</td><td>✎</td><td>no-unused-labels</td><td>禁用出现未使用过的标</td></tr>
<tr><td></td><td></td><td>no-useless-call</td><td>禁止不必要的 .call() 和 .apply()</td></tr>
<tr><td>✔</td><td></td><td>no-useless-catch</td><td>禁止不必要的 catch 子句</td></tr>
<tr><td></td><td></td><td>no-useless-concat</td><td>禁止不必要的字符串字面量或模板字面量的连接</td></tr>
<tr><td>✔</td><td></td><td>no-useless-escape</td><td>禁用不必要的转义字符</td></tr>
<tr><td></td><td>✎</td><td>no-useless-return</td><td>禁止多余的 return 语句</td></tr>
<tr><td></td><td></td><td>no-void</td><td>禁用 void 操作符</td></tr>
<tr><td></td><td></td><td>no-warning-comments</td><td>禁止在注释中使用特定的警告术语</td></tr>
<tr><td>✔</td><td></td><td>no-with</td><td>禁用 with 语句</td></tr>
<tr><td></td><td></td><td>prefer-named-capture-group</td><td>建议在正则表达式中使用命名捕获组</td></tr>
<tr><td></td><td></td><td>prefer-promise-reject-errors</td><td>要求使用 Error 对象作为 Promise 拒绝的原因</td></tr>
<tr><td></td><td></td><td>radix</td><td>强制在 parseInt() 使用基数参数</td></tr>
<tr><td></td><td></td><td>require-await</td><td>禁止使用不带 await 表达式的 async 函数</td></tr>
<tr><td></td><td></td><td>require-unicode-regexp</td><td>强制在 RegExp 上使用 u 标志</td></tr>
<tr><td></td><td></td><td>vars-on-top</td><td>要求所有的 var 声明出现在它们所在的作用域顶部</td></tr>
<tr><td></td><td>✎</td><td>wrap-iife</td><td>要求 IIFE 使用括号括起来</td></tr>
<tr><td></td><td>✎</td><td>yoda</td><td>要求或禁止 “Yoda” 条件</td></tr>
</table>

<p><b>Strict Mode: 该规则与使用严格模式和严格模式指令有关</b></p>
<table>
<tr><td></td><td>✎</td><td>strict</td><td>要求或禁止使用严格模式指令</td></tr>
</table>

<p><b>Variables: 这些规则与变量声明有关</b></p>
<table>
<tr><td></td><td></td><td>init-declarations</td><td>要求或禁止 var 声明中的初始化</td></tr>
<tr><td>✔</td><td></td><td>no-delete-var</td><td>禁止删除变量</td></tr>
<tr><td></td><td></td><td>no-label-var</td><td>不允许标签与变量同名</td></tr>
<tr><td></td><td></td><td>no-restricted-globals</td><td>禁用特定的全局变量</td></tr>
<tr><td></td><td></td><td>no-shadow</td><td>禁止变量声明与外层作用域的变量同名</td></tr>
<tr><td>✔</td><td></td><td>no-shadow-restricted-names</td><td>禁止将标识符定义为受限的名字</td></tr>
<tr><td>✔</td><td></td><td>no-undef</td><td>禁用未声明的变量,除非它们在 /*global */ 注释中被提到</td></tr>
<tr><td></td><td>✎</td><td>no-undef-init</td><td>禁止将变量初始化为 undefined</td></tr>
<tr><td></td><td></td><td>no-undefined</td><td>禁止将 undefined 作为标识符</td></tr>
<tr><td>✔</td><td></td><td>no-unused-vars</td><td>禁止出现未使用过的变量</td></tr>
<tr><td></td><td></td><td>no-use-before-define</td><td>禁止在变量定义之前使用它们</td></tr>
</table>

<p><b>Node.js and CommonJS: 这些规则是关于Node.js或在浏览器中使用CommonJS的</b></p>
<table>
<tr><td></td><td></td><td>callback-return</td><td>强制数组方法的回调函数中有 return 语句</td></tr>
<tr><td></td><td></td><td>global-require</td><td>要求 require() 出现在顶层模块作用域中</td></tr>
<tr><td></td><td></td><td>handle-callback-err</td><td>要求回调函数中有容错处理</td></tr>
<tr><td></td><td></td><td>no-buffer-constructor</td><td>禁用 Buffer() 构造函数</td></tr>
<tr><td></td><td></td><td>no-mixed-requires</td><td>禁止混合常规变量声明和 require 调用</td></tr>
<tr><td></td><td></td><td>no-new-require</td><td>禁止调用 require 时使用 new 操作符</td></tr>
<tr><td></td><td></td><td>no-path-concat</td><td>禁止对 __dirname 和 __filename 进行字符串连接</td></tr>
<tr><td></td><td></td><td>no-process-env</td><td>禁用 process.env</td></tr>
<tr><td></td><td></td><td>no-process-exit</td><td>禁用 process.exit()</td></tr>
<tr><td></td><td></td><td>no-restricted-modules</td><td>禁用通过 require 加载的指定模块</td></tr>
<tr><td></td><td></td><td>no-sync</td><td>禁用同步方法</td></tr>
</table>

<p><b>Stylistic Issues: 这些规则是关于风格指南的,而且是非常主观的</b></p>
<table>
<tr><td></td><td>✎</td><td>array-bracket-newline</td><td>在数组开括号后和闭括号前强制换行</td></tr>
<tr><td></td><td>✎</td><td>array-bracket-spacing</td><td>强制数组方括号中使用一致的空格</td></tr>
<tr><td></td><td>✎</td><td>array-element-newline</td><td>强制数组元素间出现换行</td></tr>
<tr><td></td><td>✎</td><td>block-spacing</td><td>禁止或强制在代码块中开括号前和闭括号后有空格</td></tr>
<tr><td></td><td>✎</td><td>brace-style</td><td>强制在代码块中使用一致的大括号风格</td></tr>
<tr><td></td><td></td><td>camelcase</td><td>强制使用骆驼拼写法命名约定</td></tr>
<tr><td></td><td>✎</td><td>capitalized-comments</td><td>强制或禁止对注释的第一个字母大写</td></tr>
<tr><td></td><td>✎</td><td>comma-dangle</td><td>要求或禁止末尾逗号</td></tr>
<tr><td></td><td>✎</td><td>comma-spacing</td><td>强制在逗号前后使用一致的空格</td></tr>
<tr><td></td><td>✎</td><td>comma-style</td><td>强制使用一致的逗号风格</td></tr>
<tr><td></td><td>✎</td><td>computed-property-spacing</td><td>强制在计算的属性的方括号中使用一致的空格</td></tr>
<tr><td></td><td></td><td>consistent-this</td><td>当获取当前执行环境的上下文时,强制使用一致的命名</td></tr>
<tr><td></td><td>✎</td><td>eol-last</td><td>要求或禁止文件末尾存在空行</td></tr>
<tr><td></td><td>✎</td><td>func-call-spacing</td><td>要求或禁止在函数标识符和其调用之间有空格</td></tr>
<tr><td></td><td></td><td>func-name-matching</td><td>要求函数名与赋值给它们的变量名或属性名相匹配</td></tr>
<tr><td></td><td></td><td>func-names</td><td>要求或禁止使用命名的 function 表达式</td></tr>
<tr><td></td><td></td><td>func-style</td><td>强制一致地使用 function 声明或表达式</td></tr>
<tr><td></td><td>✎</td><td>function-paren-newline</td><td>强制在函数括号内使用一致的换行</td></tr>
<tr><td></td><td></td><td>id-blacklist</td><td>禁用指定的标识符</td></tr>
<tr><td></td><td></td><td>id-length</td><td>强制标识符的最小和最大长度</td></tr>
<tr><td></td><td></td><td>id-match</td><td>要求标识符匹配一个指定的正则表达式</td></tr>
<tr><td></td><td>✎</td><td>implicit-arrow-linebreak</td><td>强制隐式返回的箭头函数体的位置</td></tr>
<tr><td></td><td>✎</td><td>indent</td><td>强制使用一致的缩进</td></tr>
<tr><td></td><td>✎</td><td>jsx-quotes</td><td>强制在 JSX 属性中一致地使用双引号或单引号</td></tr>
<tr><td></td><td>✎</td><td>key-spacing</td><td>强制在对象字面量的属性中键和值之间使用一致的间距</td></tr>
<tr><td></td><td>✎</td><td>keyword-spacing</td><td>强制在关键字前后使用一致的空格</td></tr>
<tr><td></td><td></td><td>line-comment-position</td><td>强制行注释的位置</td></tr>
<tr><td></td><td>✎</td><td>linebreak-style</td><td>强制使用一致的换行风格</td></tr>
<tr><td></td><td>✎</td><td>lines-around-comment</td><td>要求在注释周围有空行</td></tr>
<tr><td></td><td>✎</td><td>lines-between-class-members</td><td>要求或禁止类成员之间出现空行</td></tr>
<tr><td></td><td></td><td>max-depth</td><td>强制可嵌套的块的最大深度</td></tr>
<tr><td></td><td></td><td>max-len</td><td>强制一行的最大长度</td></tr>
<tr><td></td><td></td><td>max-lines</td><td>强制最大行数</td></tr>
<tr><td></td><td></td><td>max-lines-per-function</td><td>强制函数最大代码行数</td></tr>
<tr><td></td><td></td><td>max-nested-callbacks</td><td>强制回调函数最大嵌套深度</td></tr>
<tr><td></td><td></td><td>max-params</td><td>强制函数定义中最多允许的参数数量</td></tr>
<tr><td></td><td></td><td>max-statements</td><td>强制函数块最多允许的的语句数量</td></tr>
<tr><td></td><td></td><td>max-statements-per-line</td><td>强制每一行中所允许的最大语句数量</td></tr>
<tr><td></td><td>✎</td><td>multiline-comment-style</td><td>强制对多行注释使用特定风格</td></tr>
<tr><td></td><td></td><td>multiline-ternary</td><td>要求或禁止在三元操作数中间换行</td></tr>
<tr><td></td><td></td><td>new-cap</td><td>要求构造函数首字母大写</td></tr>
<tr><td></td><td>✎</td><td>new-parens</td><td>强制或禁止调用无参构造函数时有圆括号</td></tr>
<tr><td></td><td>✎</td><td>newline-per-chained-call</td><td>要求方法链中每个调用都有一个换行符</td></tr>
<tr><td></td><td></td><td>no-array-constructor</td><td>禁用 Array 构造函数</td></tr>
<tr><td></td><td></td><td>no-bitwise</td><td>禁用按位运算符</td></tr>
<tr><td></td><td></td><td>no-continue</td><td>禁用 continue 语句</td></tr>
<tr><td></td><td></td><td>no-inline-comments</td><td>禁止在代码后使用内联注释</td></tr>
<tr><td></td><td>✎</td><td>no-lonely-if</td><td>禁止 if 作为唯一的语句出现在 else 语句中</td></tr>
<tr><td></td><td></td><td>no-mixed-operators</td><td>禁止混合使用不同的操作符</td></tr>
<tr><td>✔</td><td></td><td>no-mixed-spaces-and-tabs</td><td>禁止空格和 tab 的混合缩进</td></tr>
<tr><td></td><td></td><td>no-multi-assign</td><td>禁止连续赋值</td></tr>
<tr><td></td><td>✎</td><td>no-multiple-empty-lines</td><td>禁止出现多行空行</td></tr>
<tr><td></td><td></td><td>no-negated-condition</td><td>禁用否定的表达式</td></tr>
<tr><td></td><td></td><td>no-nested-ternary</td><td>禁用嵌套的三元表达式</td></tr>
<tr><td></td><td></td><td>no-new-object</td><td>禁用 Object 的构造函数</td></tr>
<tr><td></td><td></td><td>no-plusplus</td><td>禁用一元操作符 ++ 和 --</td></tr>
<tr><td></td><td></td><td>no-restricted-syntax</td><td>禁用特定的语法</td></tr>
<tr><td></td><td></td><td>no-tabs</td><td>禁用 tab</td></tr>
<tr><td></td><td></td><td>no-ternary</td><td>禁用三元操作符</td></tr>
<tr><td></td><td>✎</td><td>no-trailing-spaces</td><td>禁用行尾空格</td></tr>
<tr><td></td><td></td><td>no-underscore-dangle</td><td>禁止标识符中有悬空下划线</td></tr>
<tr><td></td><td>✎</td><td>no-unneeded-ternary</td><td>禁止可以在有更简单的可替代的表达式时使用三元操作符</td></tr>
<tr><td></td><td>✎</td><td>no-whitespace-before-property</td><td>禁止属性前有空白</td></tr>
<tr><td></td><td>✎</td><td>nonblock-statement-body-position</td><td>强制单个语句的位置</td></tr>
<tr><td></td><td>✎</td><td>object-curly-newline</td><td>强制大括号内换行符的一致性</td></tr>
<tr><td></td><td>✎</td><td>object-curly-spacing</td><td>强制在大括号中使用一致的空格</td></tr>
<tr><td></td><td>✎</td><td>object-property-newline</td><td>强制将对象的属性放在不同的行上</td></tr>
<tr><td></td><td>✎</td><td>one-var</td><td>强制函数中的变量要么一起声明要么分开声明</td></tr>
<tr><td></td><td>✎</td><td>one-var-declaration-per-line</td><td>要求或禁止在变量声明周围换行</td></tr>
<tr><td></td><td>✎</td><td>operator-assignment</td><td>要求或禁止在可能的情况下使用简化的赋值操作符</td></tr>
<tr><td></td><td>✎</td><td>operator-linebreak</td><td>强制操作符使用一致的换行符</td></tr>
<tr><td></td><td>✎</td><td>padded-blocks</td><td>要求或禁止块内填充</td></tr>
<tr><td></td><td>✎</td><td>padding-line-between-statements</td><td>要求或禁止在语句间填充空行</td></tr>
<tr><td></td><td>✎</td><td>prefer-object-spread</td><td>禁止使用以对象字面量作为第一个参数的Object.assign,优先使用对象扩展。</td></tr>
<tr><td></td><td>✎</td><td>quote-props</td><td>要求对象字面量属性名称用引号括起来</td></tr>
<tr><td></td><td>✎</td><td>quotes</td><td>强制使用一致的反勾号、双引号或单引号</td></tr>
<tr><td></td><td>✎</td><td>semi</td><td>要求或禁止使用分号代替 ASI</td></tr>
<tr><td></td><td>✎</td><td>semi-spacing</td><td>强制分号之前和之后使用一致的空格</td></tr>
<tr><td></td><td>✎</td><td>semi-style</td><td>强制分号的位置</td></tr>
<tr><td></td><td></td><td>sort-keys</td><td>要求对象属性按序排列</td></tr>
<tr><td></td><td>✎</td><td>sort-vars</td><td>要求同一个声明块中的变量按顺序排列</td></tr>
<tr><td></td><td>✎</td><td>space-before-blocks</td><td>强制在块之前使用一致的空格</td></tr>
<tr><td></td><td>✎</td><td>space-before-function-paren</td><td>强制在 function的左括号之前使用一致的空格</td></tr>
<tr><td></td><td>✎</td><td>space-in-parens</td><td>强制在圆括号内使用一致的空格</td></tr>
<tr><td></td><td>✎</td><td>space-infix-ops</td><td>要求操作符周围有空格</td></tr>
<tr><td></td><td>✎</td><td>space-unary-ops</td><td>强制在一元操作符前后使用一致的空格</td></tr>
<tr><td></td><td>✎</td><td>spaced-comment</td><td>强制在注释中 // 或 /* 使用一致的空格</td></tr>
<tr><td></td><td>✎</td><td>switch-colon-spacing</td><td>强制在 switch 的冒号左右有空格</td></tr>
<tr><td></td><td>✎</td><td>template-tag-spacing</td><td>要求或禁止在模板标记和它们的字面量之间有空格</td></tr>
<tr><td></td><td>✎</td><td>unicode-bom</td><td>要求或禁止 Unicode 字节顺序标记 (BOM)</td></tr>
<tr><td></td><td>✎</td><td>wrap-regex</td><td>要求正则表达式被括号括起来</td></tr>
</table>

<p><b>ECMAScript 6: 这些规则只与ES6有关,即通常所说的ES2015</b></p>
<table>
<tr><td></td><td>✎</td><td>arrow-body-style</td><td>要求箭头函数体使用大括号</td></tr>
<tr><td></td><td>✎</td><td>arrow-parens</td><td>要求箭头函数的参数使用圆括号</td></tr>
<tr><td></td><td>✎</td><td>arrow-spacing</td><td>强制箭头函数的箭头前后使用一致的空格</td></tr>
<tr><td>✔</td><td></td><td>constructor-super</td><td>要求在构造函数中有 super() 的调用</td></tr>
<tr><td></td><td>✎</td><td>generator-star-spacing</td><td>强制 generator 函数中 * 号周围使用一致的空格</td></tr>
<tr><td>✔</td><td></td><td>no-class-assign</td><td>禁止修改类声明的变量</td></tr>
<tr><td></td><td>✎</td><td>no-confusing-arrow</td><td>禁止在可能与比较操作符相混淆的地方使用箭头函数</td></tr>
<tr><td>✔</td><td></td><td>no-const-assign</td><td>禁止修改 const 声明的变量</td></tr>
<tr><td>✔</td><td></td><td>no-dupe-class-members</td><td>禁止类成员中出现重复的名称</td></tr>
<tr><td></td><td></td><td>no-duplicate-imports</td><td>禁止重复模块导入</td></tr>
<tr><td>✔</td><td></td><td>no-new-symbol</td><td>禁止 Symbolnew 操作符和 new 一起使用</td></tr>
<tr><td></td><td></td><td>no-restricted-imports</td><td>禁止使用指定的 import 加载的模块</td></tr>
<tr><td>✔</td><td></td><td>no-this-before-super</td><td>禁止在构造函数中,在调用super()之前使用this或super</td></tr>
<tr><td></td><td>✎</td><td>no-useless-computed-key</td><td>禁止在对象中使用不必要的计算属性</td></tr>
<tr><td></td><td></td><td>no-useless-constructor</td><td>禁用不必要的构造函数</td></tr>
<tr><td></td><td>✎</td><td>no-useless-rename</td><td>禁止在import和export和解构赋值时将引用重命名为相同的名字</td></tr>
<tr><td></td><td>✎</td><td>no-var</td><td>要求使用let或const而不是var</td></tr>
<tr><td></td><td>✎</td><td>object-shorthand</td><td>要求或禁止对象字面量中方法和属性使用简写语法</td></tr>
<tr><td></td><td>✎</td><td>prefer-arrow-callback</td><td>要求回调函数使用箭头函数</td></tr>
<tr><td></td><td>✎</td><td>prefer-const</td><td>要求使用const声明那些声明后不再被修改的变量</td></tr>
<tr><td></td><td>✎</td><td>prefer-destructuring</td><td>优先使用数组和对象解构</td></tr>
<tr><td></td><td>✎</td><td>prefer-numeric-literals</td><td>禁用parseInt()和Number.parseInt(),使用二进制,八进制和十六进制字面量</td></tr>
<tr><td></td><td></td><td>prefer-rest-params</td><td>要求使用剩余参数而不是 arguments</td></tr>
<tr><td></td><td></td><td>prefer-spread</td><td>要求使用扩展运算符而非 .apply()</td></tr>
<tr><td></td><td>✎</td><td>prefer-template</td><td>要求使用模板字面量而非字符串连接</td></tr>
<tr><td>✔</td><td></td><td>require-yield</td><td>要求 generator 函数内有 yield</td></tr>
<tr><td></td><td>✎</td><td>rest-spread-spacing</td><td>强制剩余和扩展运算符及其表达式之间有空格</td></tr>
<tr><td></td><td>✎</td><td>sort-imports</td><td>强制模块内的 import 排序</td></tr>
<tr><td></td><td></td><td>symbol-description</td><td>要求 symbol 描述</td></tr>
<tr><td></td><td>✎</td><td>template-curly-spacing</td><td>要求或禁止模板字符串中的嵌入表达式周围空格的使用</td></tr>
<tr><td></td><td>✎</td><td>yield-star-spacing</td><td>强制在 yield* 表达式中 * 周围使用空格</td></tr>
</table>

<h4>IDE的插件</h4><pre>
安装了全局或本地ESLint和当前项目根目录下的规则配置文件,开始装插件并测试功能

Sublime Text3
https://github.com/roadhump/SublimeLinter-eslint
通过Package Control -> install Package -> SublimeLinter-eslint

命令模式
# eslint [选项] [操作目标]
eslint [options] [file|dir|glob]*

当使用glob语法指定操作目标时,glob模式会被shell解析,解析结果可能因shell不同而不同。如果想要使用node的glob语法,必须使用引号将glob模式串引起来,在Windows中必须使用双引号
eslint "lib/**"

使用ESLint命令时,可以通过eslint -h概览命令选项,找到自己需要的选项

有些选项可接收一组参数,这类选项支持两种传参方式(有一个选项例外：--ignore-pattern 不支持第二种方式)：
1、多次指定同一选项,每次接收一个不同的参数
2、将参数列表用逗号分隔,一次传给选项

</pre>

<h4>webpack用eslintrc.js配置</h4><pre>
1>下载npm install eslint-loader -save-dev

2>指定eslint的配置文件,如果不指定有默认的优先执行顺序,在loader中配置加载器

</pre><pre class="js">
entry: [
  'webpack/hot/dev-server',
  'webpack-dev-server/client?http://localhost:8080',
  path.resolve(__dirname, 'src/js/app.js')
],
ouput: {
  path: path.resolve(__dirname, 'dist'),
  filename: 'bundle.js'
},
eslint: {
  configFile: '.eslintrc.js'
},
module: {
  loaders: [
    // 处理jsx语法和ES6语法
    {
      test: /\.jsx?$/,   // 用正则来匹配文件路径,匹配js或jsx
      loader: 'babel',
      query: {
        presets: ['es2015', 'react']
      }
    },
    { // 一定要放到babel-loader之后去处理eslint
      test: /\.js$/,
      loader: 'eslint-loader',
      exclude: /node_modules/
    }
  ]
}

</pre><pre>
3>通过根目录下的.eslintignore文件指定不需要走eslint规范的代码,内容
node-modules
dist

4>之后执行webpack的运行命令就可以看到效果了

</pre>.eslintrc.js文件配置的代码<pre class="js">
module.exports = {
  // 开启推荐配置信息
  "extends": "eslint:recommended",
  // 默认ESLint会在所有父级目录里寻找配置文件直到根目录。如果想要所有项目都遵循一个特定的约定时这将会很有用,但有时候会导致意想不到的结果。为了将ESLint限制到一个特定的项目,在项目根目录下的package.json文件或.eslintrc.*文件里的eslintConfig字段下设置"root":true,此时它就会停止在父级目录中寻找。
  "root": true,
  // 脚本在执行期间访问的额外的全局变量;当访问未定义的变量时no-undef规则将发出警告。如果想在一个文件里使用全局变量,推荐定义这些全局变量,这样ESLint就不会发出警告了。可以使用注释或在配置文件中定义全局变量。
  "globals" : {
    "window":true,
    "document":true,
    "$":true
  },
  // "plugins": [           // 设置插件
  //     'html'
  // ],
  "parserOptions": {        // 设置解析器选项(必须设置这个属性)
    "ecmaVersion": 7,
    "sourceType": "module",
    "ecmaFeatures": {
      "jsx": true,
      // "arrowFunctions": true,
      // "experimentalObjectRestSpread": true,
      // "classes": true,
      // "modules": true,
      // "defaultParams": true
    }
  },
  "rules" : {                // 启用的规则及各自的错误级别
    "no-console":1,          // 禁止用console
    "semi":[2,'never'],      // 禁止用分号
    "no-redeclare":1         // 在同一个作用域中禁止多次重复定义
  },
  "env": {                   // 指定想启用的环境
    "browser": true,
    "node": true
  },
  "parser": "babel-eslint"   // 配置解析es6,babel、eslint都是babel公司出的
};

</pre><pre>
5>react的特殊支持
如果用了ES6的新语法那么需要下载一个模块支持,否则react中写定义箭头函数会报错
npm install babel-eslint -save

在配置文件中添加"parser": "babel-eslint"

</pre>

<h4>NodeJS配置eslint</h4><pre>
下面来介绍NodeJS环境下如何配置airbnb-base的eslint规则

1、本地安装eslint、eslint-config-airbnb-base、eslint-plugin-import,最好使用npm,而不是cnpm安装。因为在使用本地安装的eslint时,会使用其安装路径。而npm和cnpm的安装路径不一致
npm install --save-dev eslint
npm install --save-dev eslint-config-airbnb-base
npm install --save-dev eslint-plugin-import

2、安装成功后package.json文件中增加如下字段
"devDependencies": {
  "eslint": "^4.19.1",
  "eslint-config-airbnb-base": "^12.1.0",
  "eslint-plugin-import": "^2.12.0"
}

3、在根目录下设置.eslintrc.js配置文件

</pre><pre class="js">
module.exports = {
  "extends": ["airbnb-base"],
  "env": {
    "es6": true,
    "node": true
  },
  "rules": {
    "comma-dangle": ["error", "never"],     // 要求或禁止末尾逗号：不允许逗号
    "indent": ["error", 2],                 // JavaScript代码强制使用一致的缩进：2格缩进
    "semi": ["error", "never"],             // 不使用分号
    "arrow-parens": ["error", "as-needed"], // 箭头函数的参数可以不使用圆括号
    "linebreak-style": "off",               // 取消换行符\n或\r\n的验证
    "object-curly-newline": ["error", { "consistent": true }], // 花括号内的换行符不一定要格式一致
    "function-paren-newline": "off",        // 不验证函数括号内的换行
    "import/extensions": "off",             // 取消对文件扩展名的验证
    "no-param-reassign": "off",             // 允许对函数参数进行再赋值
    "no-underscore-dangle": "off",          // 允许在标识符中使用下划线
    "no-use-before-define": "off",          // 允许变量和函数在定义前使用
    "no-unused-expressions": "off",         // 允许使用未使用过的表达式,以此来支持a && a()的代码形式
    "no-console": "off",                    // 启用console控制台
    "consistent-return": "off",             // 关闭函数中return的检测
    "no-shadow": "off",                     // 可以使用同名变量,
    "newline-per-chained-call": "off",      // 取消方法链调用中的换行符的检测
    "import/newline-after-import": "off"
  }
}

</pre><pre>
4、在命令行工具中使用命令,对文件进行lint校验
PS D:\blog\api\node_modules\.bin> ./eslint ../../index.js

</pre>

<h4>Vue配置eslint</h4><pre>
使用vue-cli创建项目时,如果使用eslint,会有如下图所示的选项,选择使用standard还是airbnb规范

</pre>以standard规范创建成功后,package.json文件会出现如下字段<pre class="js">
"eslint": "^4.15.0",
"eslint-config-standard": "^10.2.1",
"eslint-friendly-formatter": "^3.0.0",
"eslint-loader": "^1.7.1",
"eslint-plugin-import": "^2.7.0",
"eslint-plugin-node": "^5.2.0",
"eslint-plugin-promise": "^3.4.0",
"eslint-plugin-standard": "^3.0.1",
"eslint-plugin-vue": "^4.0.0",

</pre>与此同时在根目录下自动生成.eslintrc.js配置文件<pre class="js">
module.exports = {
  root: true,
  parserOptions: {
    parser: 'babel-eslint'
  },
  env: {
    browser: true
  },
  extends: [
    // https://github.com/vuejs/eslint-plugin-vue#priority-a-essential-error-prevention
    // consider switching to `plugin:vue/strongly-recommended` or `plugin:vue/recommended` for stricter rules.
    'plugin:vue/base',
    // https://github.com/standard/standard/blob/master/docs/RULES-en.md
    'standard'
  ],
  // required to lint *.vue files
  plugins: ['vue'],
  // add your custom rules here
  rules: {
    // allow async-await
    'generator-star-spacing': 'off',
    // allow debugger during development
    'no-debugger': process.env.NODE_ENV === 'production' ? 'error' : 'off',
  }
}

</pre><pre>
如果需要更改为更严格的验证,可以下载并使用airbnb规范
npm install --save-dev eslint-config-airbnb-base

在extends字段中,将standard更改为airbnb-base,将plugin:vue/base更改为plugin: vue/recommended
extends: [ 'plugin:vue/recommended', 'airbnb-base' ],

</pre>添加一些自定义的规则,最终的配置文件如下所示<pre class="js">
module.exports = {
  root: true,
  parserOptions: {
    parser: 'babel-eslint'
  },
  env: {
    browser: true
  },
  extends: [
    // https://github.com/vuejs/eslint-plugin-vue#priority-a-essential-error-prevention
    // consider switching to `plugin:vue/strongly-recommended` or `plugin:vue/recommended` for stricter rules.
    'plugin:vue/recommended',
    // https://github.com/standard/standard/blob/master/docs/RULES-en.md
    'airbnb-base'
  ],
  // required to lint *.vue files
  plugins: ['vue'],
  // add your custom rules here
  rules: {
    'generator-star-spacing': 'off',                           // allow async-await
    'no-debugger': process.env.NODE_ENV === 'production' ? 'error' : 'off',  // allow debugger during development
    "linebreak-style": "off",                                  // 取消换行符\n或\r\n的验证
    "semi": ["error", "never"],                                // 不使用分号
    "arrow-parens": ["error", "as-needed"],                    // 箭头函数的参数可以不使用圆括号
    "comma-dangle": ["error", "never"],                        // 不允许末尾逗号
    "consistent-return": "off",                                // 关闭函数中return的检测
    "object-curly-newline": ["error", { "consistent": true }], // 花括号内的换行符不一定要格式一致
    "global-require": "off",                                   // 取消对require的验证,使得可使用require来加载图片的相对路径
    "function-paren-newline": "off",                           // 不验证函数括号内的换行
    "import/no-unresolved": "off",                             // 取消自动解析路径,以此开启alias的别名路径设置
    "no-param-reassign": "off",                                // 允许对函数参数进行再赋值
    "import/extensions": "off",                                // 取消对文件扩展名的验证
    "max-len": "off",                                          // 取消行的最大长度的验证,使SVG不用重新调整格式
    "no-underscore-dangle": "off",                             // 允许标识符中有下划线,从而支持vue中插件的使用
    "no-console": "off",                                       // 启用console控制台
    "no-unused-expressions": "off",                            // 允许使用未使用过的表达式,以此来支持a && a()的代码形式
    "no-shadow": "off",                                        // 取消变量声明覆盖的验证
    'vue/attribute-hyphenation': 0,                            // 取消对元素特性只能使用中划线或小驼峰形式的验证
    'vue/max-attributes-per-line': 0                           // 取消元素有多个特性时,每个特性独占一行的验证
  }
}

</pre>
</div>

</main>
    <ol>
      <li><a href="#webpack">top</a></li>
      <li><a href="#webpack_modules">modules</a></li>
      <li><a href="#webpack_cli">cli</a></li>
      <li><a href="#webpack_config">config</a></li>
      <li><a href="#webpack_entry">entry</a></li>
      <li><a href="#webpack_output">output</a></li>
      <li><a href="#webpack_mode_target">mode target</a></li>
      <li><a href="#webpack_module">module</a></li>
      <li>
        <a href="#webpack_loader">loader ▼</a>
        <ul>
          <li><a href="#babel-loader">babel-loader</a></li>
          <li><a href="#treeshaking">treeshaking</a></li>
          <li><a href="#html-loader">html-loader</a></li>
          <li><a href="#file-url">file-url</a></li>
          <li><a href="#css">css</a></li>
          <li><a href="#vue-loader">vue-loader</a></li>
        </ul>
      </li>
      <li>
        <a href="#webpack_plugins">plugins ▼</a>
        <ul>
          <li><a href="#BannerPlugin">BannerPlugin</a></li>
          <li><a href="#DefinePlugin">DefinePlugin</a></li>
          <li><a href="#cleanWebpackPlugin">cleanWebpackPlugin</a></li>
          <li><a href="#htmlWebpackPlugin">htmlWebpackPlugin</a></li>
          <li><a href="#miniCssExtractPlugin">miniCssExtractPlugin</a></li>
        </ul>
      </li>
      <li><a href="#webpack_hmr">HMR</a></li>
      <li><a href="#webpack_devSever">devSever</a></li>
      <li><a href="#webpack_devtool">devtool</a></li>
      <li><a href="#webpack_splitChunks">splitChunks</a></li>
      <li><a href="#webpack_cache">cache</a></li>
      <li><a href="#webpack_etc">etc</a></li>
      <li><a href="#esLint">esLint</a></li>
    </ol>

    <script src="vendors/jquery-3.3.1.min.js"></script>
    <script src="vendors/public.js"></script>
    <script src="vendors/SyntaxHighlighter/shCore.js"></script>
    <script>
        // 代码高亮
        $('pre[class=html]').addClass('brush:html;toolbar:false');
        $('pre[class=css]').addClass('brush:css;toolbar:false');
        $('pre[class=js]').addClass('brush:js;toolbar:false');
        $('pre[class=php]').addClass('brush:php;toolbar:false');
        SyntaxHighlighter.all();
    </script>
</body>

</html>